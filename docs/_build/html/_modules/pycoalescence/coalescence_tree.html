
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>pycoalescence.coalescence_tree &#8212; pycoalescence 1.2.7a5 documentation</title>
    <link rel="stylesheet" href="../../_static/classic.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/collapsible-lists/css/tree_view.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../',
        VERSION:     '1.2.7a5',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/javascript" src="../../_static/collapsible-lists/js/CollapsibleLists.compressed.js"></script>
    <script type="text/javascript" src="../../_static/collapsible-lists/js/apply-collapsible-lists.js"></script>
    <link rel="shortcut icon" href="../../_static/PyCoal_favicon_large.ico"/>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
  </head>
  <body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">pycoalescence 1.2.7a5 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../index.html" accesskey="U">Module code</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for pycoalescence.coalescence_tree</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Generate the coalescence tree and acquire a number of biodiversity metrics for different parameter sets. Can also be</span>
<span class="sd">used to compare against a comparison simulation object.</span>

<span class="sd">:input:</span>
<span class="sd">	- Completed simulation database from :class:`.Simulation`</span>
<span class="sd">	- Parameters and operations to apply</span>

<span class="sd">:output:</span>
<span class="sd">	- A variety of biodiversity metrics, including species richness and abundance distributions, locations of each</span>
<span class="sd">	  species, alpha and beta diversity, plus equivalent fragment biodiversity metrics.</span>
<span class="sd">	- Modifies the simulation database in place.</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">absolute_import</span><span class="p">,</span> <span class="n">division</span>

<span class="kn">import</span> <span class="nn">json</span>
<span class="kn">import</span> <span class="nn">logging</span>
<span class="kn">import</span> <span class="nn">math</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">random</span>
<span class="kn">import</span> <span class="nn">sqlite3</span>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">defaultdict</span><span class="p">,</span> <span class="n">Iterable</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>

<span class="k">try</span><span class="p">:</span>
	<span class="kn">from</span> <span class="nn">.necsim</span> <span class="kn">import</span> <span class="n">libnecsim</span>
<span class="k">except</span> <span class="ne">ImportError</span> <span class="k">as</span> <span class="n">ie</span><span class="p">:</span>
	<span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">ie</span><span class="p">))</span>
	<span class="kn">from</span> <span class="nn">necsim</span> <span class="kn">import</span> <span class="n">libnecsim</span><span class="p">,</span> <span class="n">necsimError</span>

<span class="kn">from</span> <span class="nn">.future_except</span> <span class="kn">import</span> <span class="n">FileNotFoundError</span>
<span class="kn">from</span> <span class="nn">.system_operations</span> <span class="kn">import</span> <span class="n">mod_directory</span><span class="p">,</span> <span class="n">create_logger</span><span class="p">,</span> <span class="n">write_to_log</span>
<span class="kn">from</span> <span class="nn">.spatial_algorithms</span> <span class="kn">import</span> <span class="n">calculate_distance_between</span>
<span class="kn">from</span> <span class="nn">.sqlite_connection</span> <span class="kn">import</span> <span class="n">check_sql_table_exist</span>
<span class="kn">import</span> <span class="nn">pycoalescence</span>

<span class="c1"># Reads the parameter descriptions from the json file.</span>
<span class="k">try</span><span class="p">:</span>
	<span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">mod_directory</span><span class="p">,</span> <span class="s2">&quot;reference&quot;</span><span class="p">,</span> <span class="s2">&quot;parameter_descriptions.json&quot;</span><span class="p">))</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
		<span class="n">_parameter_descriptions</span> <span class="o">=</span> <span class="n">json</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">except</span> <span class="p">(</span><span class="n">FileNotFoundError</span><span class="p">,</span> <span class="ne">IOError</span><span class="p">):</span>
	<span class="n">logging</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s2">&quot;Could not find parameter dictionary. Check install is complete.&quot;</span><span class="p">)</span>


<div class="viewcode-block" id="get_parameter_description"><a class="viewcode-back" href="../../pycoalescence.html#pycoalescence.coalescence_tree.get_parameter_description">[docs]</a><span class="k">def</span> <span class="nf">get_parameter_description</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
	<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">	Gets the parameter descriptions for the supplied key. If the key is None, returns all keys.</span>

<span class="sd">	:param key: the simulation parameter</span>

<span class="sd">	:return: string containing the parameter description or a dict containing all values if no key is supplied</span>
<span class="sd">	&quot;&quot;&quot;</span>
	<span class="k">if</span> <span class="n">key</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
		<span class="k">return</span> <span class="n">_parameter_descriptions</span>
	<span class="k">try</span><span class="p">:</span>
		<span class="k">return</span> <span class="n">_parameter_descriptions</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
	<span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
		<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Key {} was not found in parameter dictionary. Use key=None to show the whole dictionary&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="CoalescenceTree"><a class="viewcode-back" href="../../pycoalescence.html#pycoalescence.coalescence_tree.CoalescenceTree">[docs]</a><span class="k">class</span> <span class="nc">CoalescenceTree</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
	<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">	Contains the coalescence tree and performs various calculations of different biodiversity metrics, which are then</span>
<span class="sd">	stored in the SQLite database.</span>

<span class="sd">	The general process is</span>

<span class="sd">	* Import the database (:py:meth:`~set_database`) and import the comparison data,</span>
<span class="sd">	  if required (:py:meth:`~import_comparison_data`)</span>

<span class="sd">	* Apply additional speciation rates (if required) using :py:meth:`~set_speciation_parameters` and then</span>
<span class="sd">	  :py:meth:`~apply`</span>

<span class="sd">	* Calculate required metrics (such as :py:meth:`~calculate_fragment_richness`)</span>
<span class="sd">	* Optionally, calculate the goodness of fit (:py:meth:`~calculate_goodness_of_fit`)</span>
<span class="sd">	&quot;&quot;&quot;</span>

	<span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">database</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">logging_level</span><span class="o">=</span><span class="n">logging</span><span class="o">.</span><span class="n">WARNING</span><span class="p">,</span> <span class="n">log_output</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Initiates the CoalescenceTree object. By default, links to the SpeciationCounter program stored in</span>
<span class="sd">		build/default/SpeciationCounter, but optionally takes speciation_program as a path to an alternative program.</span>

<span class="sd">		:param str/pycoalescence.Simulation database: optionally specify the path to call :py:meth:`~set_database` to</span>
<span class="sd">		:param int logging_level: the level from the logging module for desired terminal outputs</span>
<span class="sd">		:param str log_output: optionally provide a file to output information to instead</span>
<span class="sd">		:return: None</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="c1"># C object for calculating the coalescence tree</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">c_community</span> <span class="o">=</span> <span class="bp">None</span>
		<span class="c1"># speciation objects</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">equalised</span> <span class="o">=</span> <span class="bp">False</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">is_setup_speciation</span> <span class="o">=</span> <span class="bp">False</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">record_spatial</span> <span class="o">=</span> <span class="bp">False</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">times</span> <span class="o">=</span> <span class="bp">None</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">sample_file</span> <span class="o">=</span> <span class="s2">&quot;null&quot;</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">record_fragments</span> <span class="o">=</span> <span class="bp">False</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">speciation_simulator</span> <span class="o">=</span> <span class="bp">None</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">applied_speciation_rates_list</span> <span class="o">=</span> <span class="p">[]</span>
		<span class="c1"># Other objects</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">is_complete</span> <span class="o">=</span> <span class="bp">False</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">total_individuals</span> <span class="o">=</span> <span class="mi">0</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">comparison_abundances_whole</span> <span class="o">=</span> <span class="bp">None</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">comparison_file</span> <span class="o">=</span> <span class="bp">None</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">file</span> <span class="o">=</span> <span class="bp">None</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">database</span> <span class="o">=</span> <span class="bp">None</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">cursor</span> <span class="o">=</span> <span class="bp">None</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">fragments</span> <span class="o">=</span> <span class="p">[]</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">fragment_abundances</span> <span class="o">=</span> <span class="p">[]</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">comparison_data</span> <span class="o">=</span> <span class="bp">None</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">comparison_abundances</span> <span class="o">=</span> <span class="bp">None</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">comparison_octaves</span> <span class="o">=</span> <span class="bp">None</span>
		<span class="c1"># Protracted parameters</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">protracted_parameters</span> <span class="o">=</span> <span class="p">[]</span>
		<span class="c1"># Metacommunity parameters</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">metacommunity_size</span> <span class="o">=</span> <span class="bp">None</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">metacommunity_speciation_rate</span> <span class="o">=</span> <span class="bp">None</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">metacommunity_option</span> <span class="o">=</span> <span class="bp">None</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">metacommunity_reference</span> <span class="o">=</span> <span class="bp">None</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">logger</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">Logger</span><span class="p">(</span><span class="s2">&quot;pycoalescence.coalescence&quot;</span><span class="p">)</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">logging_level</span> <span class="o">=</span> <span class="n">logging_level</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">_create_logger</span><span class="p">(</span><span class="nb">file</span><span class="o">=</span><span class="n">log_output</span><span class="p">)</span>
		<span class="k">if</span> <span class="n">database</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">set_database</span><span class="p">(</span><span class="n">database</span><span class="p">)</span>
		<span class="c1"># Set to true once speciation rates have been written to the output database.</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">has_outputted</span> <span class="o">=</span> <span class="bp">False</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">has_applied</span> <span class="o">=</span> <span class="bp">False</span>

	<span class="k">def</span> <span class="fm">__del__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Closes the database connection.</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">database</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">cursor</span> <span class="o">=</span> <span class="bp">None</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">database</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">database</span> <span class="o">=</span> <span class="bp">None</span>
		<span class="k">for</span> <span class="n">handler</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">handlers</span><span class="p">:</span>
			<span class="n">handler</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">removeHandler</span><span class="p">(</span><span class="n">handler</span><span class="p">)</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">c_community</span> <span class="o">=</span> <span class="bp">None</span>

	<span class="k">def</span> <span class="nf">_create_logger</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">file</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">logging_level</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Creates the logger for use with applying speciation rates to a simulation.</span>
<span class="sd">		This function should only be run during :py:meth:`~__init__`</span>

<span class="sd">		.. tip:: Supply your own logger by over-riding :attr:`~import_comparison_data`.</span>

<span class="sd">		:param str file: file to write output to. If None, outputs to terminal</span>
<span class="sd">		:param int logging_level: the logging level to use (defaults to INFO=20)</span>

<span class="sd">		:return: None</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="k">if</span> <span class="n">logging_level</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
			<span class="n">logging_level</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">logging_level</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">logger</span> <span class="o">=</span> <span class="n">create_logger</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="p">,</span> <span class="nb">file</span><span class="p">,</span> <span class="n">logging_level</span><span class="p">)</span>

	<span class="k">def</span> <span class="nf">_check_fragment_numbers_match</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Checks that the numbers of individuals match between the comparison_abundances object and the simulation</span>
<span class="sd">		database for each fragment</span>

<span class="sd">		:return: true if the numbers match</span>
<span class="sd">		:rtype: bool</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">fragment_abundances</span><span class="p">:</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">calculate_fragment_abundances</span><span class="p">()</span>
		<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">comparison_abundances</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
			<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">comparison_file</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
				<span class="bp">self</span><span class="o">.</span><span class="n">import_comparison_data</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">comparison_file</span><span class="p">)</span>
			<span class="k">else</span><span class="p">:</span>
				<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cannot check matched numbers before importing comparison database.&quot;</span><span class="p">)</span>
		<span class="k">for</span> <span class="n">fragment</span> <span class="ow">in</span> <span class="nb">set</span><span class="p">([</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">fragment_abundances</span><span class="p">]):</span>
			<span class="k">for</span> <span class="n">ref</span> <span class="ow">in</span> <span class="nb">set</span><span class="p">([</span><span class="n">x</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">fragment_abundances</span><span class="p">]):</span>
				<span class="n">sum_simulated</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">([</span><span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">fragment_abundances</span> <span class="k">if</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">fragment</span> <span class="ow">and</span>
									 <span class="n">x</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">==</span> <span class="n">ref</span><span class="p">])</span>
				<span class="k">if</span> <span class="n">sum_simulated</span> <span class="o">!=</span> <span class="nb">sum</span><span class="p">([</span><span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">comparison_abundances</span> <span class="k">if</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">fragment</span><span class="p">]):</span>
					<span class="k">return</span> <span class="bp">False</span>
		<span class="k">return</span> <span class="bp">True</span>

	<span class="k">def</span> <span class="nf">_set_record_fragments</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">record_fragments</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Checks if the fragment record flag is correctly set and sets the relevant parameter.</span>

<span class="sd">		:param bool/str record_fragments: the fragments record flag to check</span>

<span class="sd">		:rtype: None</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">record_fragments</span><span class="p">,</span> <span class="nb">bool</span><span class="p">):</span>
			<span class="k">if</span> <span class="n">record_fragments</span><span class="p">:</span>
				<span class="n">record_fragments</span> <span class="o">=</span> <span class="s2">&quot;null&quot;</span>
			<span class="k">else</span><span class="p">:</span>
				<span class="n">record_fragments</span> <span class="o">=</span> <span class="s2">&quot;F&quot;</span>
		<span class="k">if</span> <span class="n">record_fragments</span> <span class="ow">is</span> <span class="s2">&quot;T&quot;</span><span class="p">:</span>
			<span class="n">record_fragments</span> <span class="o">=</span> <span class="s2">&quot;null&quot;</span>
		<span class="k">if</span> <span class="n">record_fragments</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;F&quot;</span><span class="p">,</span> <span class="s2">&quot;null&quot;</span><span class="p">]:</span>
			<span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">record_fragments</span><span class="p">):</span>
				<span class="k">raise</span> <span class="ne">IOError</span><span class="p">(</span><span class="s2">&quot;Fragment config does not exist at {}.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">record_fragments</span><span class="p">))</span>
			<span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">record_fragments</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s2">&quot;.csv&quot;</span><span class="p">)</span> <span class="ow">or</span> <span class="n">record_fragments</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s2">&quot;.txt&quot;</span><span class="p">)):</span>
				<span class="k">raise</span> <span class="ne">IOError</span><span class="p">(</span><span class="s2">&quot;Supplied fragment config file is not a csv or txt file: {}.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">record_fragments</span><span class="p">))</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">record_fragments</span> <span class="o">=</span> <span class="n">record_fragments</span>

	<span class="k">def</span> <span class="nf">_set_record_spatial</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">record_spatial</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Checks that the spatial record flag has been correctly set and sets the relevant parameter.</span>

<span class="sd">		:param bool/str record_spatial: the object to check correctly identifies a spatial option</span>

<span class="sd">		:rtype: None</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="k">if</span> <span class="n">record_spatial</span> <span class="ow">is</span> <span class="s2">&quot;T&quot;</span><span class="p">:</span>
			<span class="n">record_spatial</span> <span class="o">=</span> <span class="bp">True</span>
		<span class="k">elif</span> <span class="n">record_spatial</span> <span class="ow">is</span> <span class="s2">&quot;F&quot;</span><span class="p">:</span>
			<span class="n">record_spatial</span> <span class="o">=</span> <span class="bp">False</span>
		<span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">record_spatial</span><span class="p">,</span> <span class="nb">bool</span><span class="p">):</span>
			<span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;record_spatial must be a boolean.&quot;</span><span class="p">)</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">record_spatial</span> <span class="o">=</span> <span class="n">record_spatial</span>

	<span class="k">def</span> <span class="nf">_set_speciation_rates</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">speciation_rates</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Checks that the speciation rates are correctly set for applying to the community and sets the applied</span>
<span class="sd">		speciation rates parameter.</span>

<span class="sd">		:param list/float speciation_rates: the speciation rates object to check is the correct format</span>

<span class="sd">		:rtype: None</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="k">if</span> <span class="n">speciation_rates</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
			<span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;No speciation rates supplied: requires at least 1 for analysis.&quot;</span><span class="p">)</span>
		<span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">speciation_rates</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">):</span>
			<span class="n">speciation_rates</span> <span class="o">=</span> <span class="p">[</span><span class="n">speciation_rates</span><span class="p">]</span>
		<span class="k">try</span><span class="p">:</span>
			<span class="n">speciation_rates</span> <span class="o">=</span> <span class="p">[</span><span class="nb">float</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">speciation_rates</span><span class="p">]</span>
		<span class="k">except</span> <span class="ne">ValueError</span> <span class="k">as</span> <span class="n">ve</span><span class="p">:</span>
			<span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Speciation rates are not floats: {}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">ve</span><span class="p">))</span>
		<span class="k">for</span> <span class="n">spec_rate</span> <span class="ow">in</span> <span class="n">speciation_rates</span><span class="p">:</span>
			<span class="k">if</span> <span class="n">spec_rate</span> <span class="o">&gt;</span> <span class="mf">1.0</span> <span class="ow">or</span> <span class="n">spec_rate</span> <span class="o">&lt;</span> <span class="mf">0.0</span><span class="p">:</span>
				<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Speciation rates must be between 0.0 and 1.0.&quot;</span><span class="p">)</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">applied_speciation_rates_list</span> <span class="o">=</span> <span class="n">speciation_rates</span>

	<span class="k">def</span> <span class="nf">_set_metacommunity_parameters</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">metacommunity_size</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">metacommunity_speciation_rate</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
									  <span class="n">metacommunity_option</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">metacommunity_reference</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Checks that the metacommunity parameters make sense and assigns them within the object.</span>

<span class="sd">		:param float metacommunity_size: the number of individuals in the metacommunity</span>
<span class="sd">		:param float metacommunity_speciation_rate: the speciation rate within the metacommunity</span>
<span class="sd">		:param str metacommunity_option: either &quot;simulated&quot;, &quot;analytical&quot;, or a path to a database to read SADs from</span>
<span class="sd">		:param int metacommunity_reference: the metacommunity reference if using a database to provide the metacommunity</span>

<span class="sd">		:rtype: None</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="k">if</span> <span class="ow">not</span> <span class="n">metacommunity_size</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">metacommunity_speciation_rate</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">metacommunity_option</span> <span class="ow">and</span> <span class="ow">not</span> \
				<span class="n">metacommunity_reference</span><span class="p">:</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">metacommunity_size</span> <span class="o">=</span> <span class="mi">0</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">metacommunity_speciation_rate</span> <span class="o">=</span> <span class="mf">0.0</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">metacommunity_option</span> <span class="o">=</span> <span class="s2">&quot;none&quot;</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">metacommunity_reference</span> <span class="o">=</span> <span class="mi">0</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="k">if</span> <span class="n">metacommunity_option</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
				<span class="n">metacommunity_option</span> <span class="o">=</span> <span class="s2">&quot;none&quot;</span>
			<span class="k">if</span> <span class="n">metacommunity_size</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span> <span class="ow">and</span> <span class="n">metacommunity_speciation_rate</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
				<span class="k">if</span> <span class="n">metacommunity_size</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="mf">0.0</span> <span class="o">&lt;</span> <span class="n">metacommunity_speciation_rate</span> <span class="o">&lt;=</span> <span class="mf">1.0</span><span class="p">:</span>
					<span class="bp">self</span><span class="o">.</span><span class="n">metacommunity_size</span> <span class="o">=</span> <span class="n">metacommunity_size</span>
					<span class="bp">self</span><span class="o">.</span><span class="n">metacommunity_speciation_rate</span> <span class="o">=</span> <span class="n">metacommunity_speciation_rate</span>
				<span class="k">else</span><span class="p">:</span>
					<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Must supply both metacommunity size &gt;0 and speciation rate between 0 and 1 for &quot;</span>
									 <span class="s2">&quot;generating a metacommunity.&quot;</span><span class="p">)</span>
				<span class="k">if</span> <span class="n">metacommunity_option</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;simulated&quot;</span><span class="p">,</span> <span class="s2">&quot;analytical&quot;</span><span class="p">,</span> <span class="s2">&quot;none&quot;</span><span class="p">]:</span>
					<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Must use &#39;simulated&#39; or &#39;analytical&#39; for metacommunity option when supplying &quot;</span>
									 <span class="s2">&quot;a metacommunity size and speciation rate.&quot;</span><span class="p">)</span>
				<span class="k">if</span> <span class="n">metacommunity_option</span> <span class="o">==</span> <span class="s2">&quot;none&quot;</span><span class="p">:</span>
					<span class="k">if</span> <span class="n">metacommunity_size</span> <span class="o">&gt;</span> <span class="mi">100000</span><span class="p">:</span>
						<span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Using analytical method for generating metacommunity.&quot;</span><span class="p">)</span>
						<span class="bp">self</span><span class="o">.</span><span class="n">metacommunity_option</span> <span class="o">=</span> <span class="s2">&quot;analytical&quot;</span>
					<span class="k">else</span><span class="p">:</span>
						<span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Using simulated method of generating metacommunity.&quot;</span><span class="p">)</span>
						<span class="bp">self</span><span class="o">.</span><span class="n">metacommunity_option</span> <span class="o">=</span> <span class="s2">&quot;simulated&quot;</span>
				<span class="k">else</span><span class="p">:</span>
					<span class="bp">self</span><span class="o">.</span><span class="n">metacommunity_option</span> <span class="o">=</span> <span class="n">metacommunity_option</span>
				<span class="bp">self</span><span class="o">.</span><span class="n">metacommunity_reference</span> <span class="o">=</span> <span class="mi">0</span>
			<span class="k">else</span><span class="p">:</span>
				<span class="k">if</span> <span class="n">metacommunity_option</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;simulated&quot;</span><span class="p">,</span> <span class="s2">&quot;analytical&quot;</span><span class="p">,</span> <span class="s2">&quot;none&quot;</span><span class="p">]:</span>
					<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Must supply both metacommunity size &gt;0 and speciation rate between 0 and 1 for &quot;</span>
									 <span class="s2">&quot;generating a metacommunity.&quot;</span><span class="p">)</span>
				<span class="k">if</span> <span class="n">metacommunity_size</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="bp">None</span><span class="p">]</span> <span class="ow">or</span> <span class="n">metacommunity_speciation_rate</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="bp">None</span><span class="p">]:</span>
					<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;No metacommunity size of speciation rate should be supplied when using an &quot;</span>
									 <span class="s2">&quot;external database for the metacommunity.&quot;</span><span class="p">)</span>
				<span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">metacommunity_option</span><span class="p">):</span>
					<span class="k">raise</span> <span class="ne">IOError</span><span class="p">(</span><span class="s2">&quot;No file exists to supply metacommunity at {}.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">metacommunity_option</span><span class="p">))</span>
				<span class="k">if</span> <span class="n">metacommunity_reference</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
					<span class="bp">self</span><span class="o">.</span><span class="n">metacommunity_reference</span> <span class="o">=</span> <span class="mi">0</span>
				<span class="k">else</span><span class="p">:</span>
					<span class="bp">self</span><span class="o">.</span><span class="n">metacommunity_reference</span> <span class="o">=</span> <span class="n">metacommunity_reference</span>
				<span class="bp">self</span><span class="o">.</span><span class="n">metacommunity_size</span> <span class="o">=</span> <span class="mi">0</span>
				<span class="bp">self</span><span class="o">.</span><span class="n">metacommunity_speciation_rate</span> <span class="o">=</span> <span class="mf">0.0</span>
				<span class="bp">self</span><span class="o">.</span><span class="n">metacommunity_option</span> <span class="o">=</span> <span class="n">metacommunity_option</span>
			<span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">c_community</span><span class="p">,</span> <span class="n">libnecsim</span><span class="o">.</span><span class="n">CMetacommunity</span><span class="p">):</span>
				<span class="bp">self</span><span class="o">.</span><span class="n">_reset_parameters</span><span class="p">()</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">c_community</span><span class="o">.</span><span class="n">add_metacommunity_parameters</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">metacommunity_size</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">metacommunity_speciation_rate</span><span class="p">,</span>
														  <span class="bp">self</span><span class="o">.</span><span class="n">metacommunity_option</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">metacommunity_reference</span><span class="p">)</span>

	<span class="k">def</span> <span class="nf">_set_protracted_parameters</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">protracted_speciation_min</span><span class="p">,</span> <span class="n">protracted_speciation_max</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Checks that the protracted parameters are valid and adds them to the simulation object.</span>

<span class="sd">		:param float protracted_speciation_min: the minimum generation for protracted speciation</span>
<span class="sd">		:param float protracted_speciation_max: the maximum generation for protracted speciation</span>

<span class="sd">		:return: list containing the set of protracted speciation minimums and maximums</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="k">if</span> <span class="n">protracted_speciation_max</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span> <span class="ow">and</span> <span class="n">protracted_speciation_min</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
			<span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_protracted</span><span class="p">():</span>
				<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Supplied protracted parameters for a non-protracted simulation.&quot;</span><span class="p">)</span>
			<span class="k">else</span><span class="p">:</span>
				<span class="bp">self</span><span class="o">.</span><span class="n">add_protracted_parameters</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">protracted_speciation_min</span><span class="p">),</span> <span class="nb">float</span><span class="p">(</span><span class="n">protracted_speciation_max</span><span class="p">))</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">add_protracted_parameters</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">)</span>

	<span class="k">def</span> <span class="nf">_check_protracted_parameters</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">min_speciation_gen</span><span class="p">,</span> <span class="n">max_speciation_gen</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Checks that the protracted parameters make sense compared to the original protracted parameters.</span>

<span class="sd">		:param float min_speciation_gen: minimum number of generations for protracted speciation</span>
<span class="sd">		:param float max_speciation_gen: maximum number of generations for protracted speciation</span>

<span class="sd">		:rtype: None</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="n">db_min</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_simulation_parameters</span><span class="p">()[</span><span class="s2">&quot;min_speciation_gen&quot;</span><span class="p">]</span>
		<span class="n">db_max</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_simulation_parameters</span><span class="p">()[</span><span class="s2">&quot;max_speciation_gen&quot;</span><span class="p">]</span>
		<span class="k">if</span> <span class="n">min_speciation_gen</span> <span class="o">&lt;</span> <span class="mf">0.0</span> <span class="ow">or</span> <span class="n">min_speciation_gen</span> <span class="o">&gt;</span> <span class="n">db_min</span><span class="p">:</span>
			<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Minimum generation for protracted speciation cannot be less than 0.0, or greater than &quot;</span>
							 <span class="s2">&quot;the initial value used during simulation ({}).&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">db_min</span><span class="p">))</span>
		<span class="k">if</span> <span class="n">max_speciation_gen</span> <span class="o">&lt;</span> <span class="n">min_speciation_gen</span> <span class="ow">or</span> <span class="n">max_speciation_gen</span> <span class="o">&gt;</span> <span class="n">db_max</span><span class="p">:</span>
			<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Maximum generation for protracted speciation cannot be less than the minimum, or greater&quot;</span>
							 <span class="s2">&quot; than the initial value used during simulation ({}).&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">db_max</span><span class="p">))</span>

	<span class="k">def</span> <span class="nf">_set_sample_file</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sample_file</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Checks that the sample file has been correctly set and sets it within the object.</span>

<span class="sd">		:param str sample_file: the file to use to determine spatial sampling</span>

<span class="sd">		:rtype: None</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="k">if</span> <span class="n">sample_file</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;No sample file provided, defaulting to null.</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">sample_file</span> <span class="o">=</span> <span class="s2">&quot;null&quot;</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="k">if</span> <span class="n">sample_file</span> <span class="o">!=</span> <span class="s2">&quot;null&quot;</span><span class="p">:</span>
				<span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">sample_file</span><span class="p">):</span>
					<span class="k">raise</span> <span class="ne">IOError</span><span class="p">(</span><span class="s2">&quot;Sample file does not exist at {}.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">sample_file</span><span class="p">))</span>
				<span class="n">ext</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">splitext</span><span class="p">(</span><span class="n">sample_file</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>
				<span class="k">if</span> <span class="n">ext</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;.tif&quot;</span><span class="p">,</span> <span class="s2">&quot;.csv&quot;</span><span class="p">]:</span>
					<span class="k">raise</span> <span class="ne">IOError</span><span class="p">(</span><span class="s2">&quot;Extension is not .tif or .csv: {}.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">ext</span><span class="p">))</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">sample_file</span> <span class="o">=</span> <span class="n">sample_file</span>

	<span class="k">def</span> <span class="nf">_set_times</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">times</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Checks that the times are valid and adds them to the object.</span>

<span class="sd">		:param list/float times: times to generate communities for</span>

<span class="sd">		:rtype: None</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="k">if</span> <span class="n">times</span> <span class="ow">in</span> <span class="p">(</span><span class="bp">None</span><span class="p">,</span> <span class="p">[],</span> <span class="p">[</span><span class="bp">None</span><span class="p">]):</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;No times provided, defaulting to 0.0.</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">add_time</span><span class="p">(</span><span class="mf">0.0</span><span class="p">)</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">times</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">):</span>
				<span class="bp">self</span><span class="o">.</span><span class="n">add_times</span><span class="p">(</span><span class="n">times</span><span class="p">)</span>
			<span class="k">else</span><span class="p">:</span>
				<span class="bp">self</span><span class="o">.</span><span class="n">add_time</span><span class="p">(</span><span class="n">times</span><span class="p">)</span>

	<span class="k">def</span> <span class="nf">_reset_parameters</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Resets the object and adds all the required parameters to the object again.</span>

<span class="sd">		Used when a standard CCommunity object is converted to a CMetacommunity object.</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">c_community</span> <span class="o">=</span> <span class="bp">None</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">_setup_c_community</span><span class="p">()</span>
		<span class="c1"># The times have already been added in the above function call, so just need to add the protracted parameters</span>
		<span class="n">tmp_protracted_params</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">protracted_parameters</span>
		<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">tmp_protracted_params</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">protracted_parameters</span> <span class="o">=</span> <span class="p">[]</span>
			<span class="k">for</span> <span class="n">min_proc</span><span class="p">,</span> <span class="n">max_proc</span> <span class="ow">in</span> <span class="n">tmp_protracted_params</span><span class="p">:</span>
				<span class="bp">self</span><span class="o">.</span><span class="n">add_protracted_parameters</span><span class="p">(</span><span class="n">min_proc</span><span class="p">,</span> <span class="n">max_proc</span><span class="p">)</span>

	<span class="k">def</span> <span class="nf">_equalise_fragment_number</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fragment</span><span class="p">,</span> <span class="n">reference</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Equalises the number of individuals in the provided fragment, altering comparison_abundances and fragments so</span>
<span class="sd">		that the numbers are equal between the two.</span>

<span class="sd">		:param fragment: the fragment to alter</span>
<span class="sd">		:param reference: the reference key for the calculated community parameters</span>

<span class="sd">		:rtype: None</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="n">total_fragments</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">([</span><span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">fragment_abundances</span> <span class="k">if</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">fragment</span> <span class="ow">and</span> <span class="n">x</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">==</span> <span class="n">reference</span><span class="p">])</span>
		<span class="k">if</span> <span class="n">total_fragments</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;No individuals found in simulated data for fragment {}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">fragment</span><span class="p">))</span>
		<span class="n">total_comparison</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">([</span><span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">comparison_abundances</span> <span class="k">if</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">fragment</span><span class="p">])</span>
		<span class="k">if</span> <span class="n">total_comparison</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;No individuals found in comparison data for fragment {}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">fragment</span><span class="p">))</span>
		<span class="n">difference</span> <span class="o">=</span> <span class="n">total_fragments</span> <span class="o">-</span> <span class="n">total_comparison</span>
		<span class="k">if</span> <span class="n">difference</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
			<span class="c1"># need to remove individuals from fragments</span>
			<span class="k">while</span> <span class="n">difference</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
				<span class="c1"># pick a random individual</span>
				<span class="n">rand_individual</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">total_fragments</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
				<span class="n">tmp_total</span> <span class="o">=</span> <span class="mi">0</span>
				<span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">f</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fragment_abundances</span><span class="p">):</span>
					<span class="k">if</span> <span class="n">f</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">fragment</span> <span class="ow">and</span> <span class="n">f</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">==</span> <span class="n">reference</span><span class="p">:</span>
						<span class="n">tmp_total</span> <span class="o">+=</span> <span class="n">f</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
						<span class="k">if</span> <span class="n">tmp_total</span> <span class="o">&gt;</span> <span class="n">rand_individual</span><span class="p">:</span>
							<span class="k">if</span> <span class="n">f</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
								<span class="bp">self</span><span class="o">.</span><span class="n">fragment_abundances</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">-=</span> <span class="mi">1</span>
								<span class="n">difference</span> <span class="o">-=</span> <span class="mi">1</span>
								<span class="n">total_fragments</span> <span class="o">-=</span> <span class="mi">1</span>
								<span class="k">break</span>
		<span class="k">elif</span> <span class="n">difference</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
			<span class="c1"># need to remove individuals from comparison_abundances</span>
			<span class="k">while</span> <span class="n">difference</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
				<span class="c1"># pick a random individual</span>
				<span class="n">rand_individual</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">total_comparison</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
				<span class="n">tmp_total</span> <span class="o">=</span> <span class="mi">0</span>
				<span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">f</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">comparison_abundances</span><span class="p">):</span>
					<span class="k">if</span> <span class="n">f</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">fragment</span><span class="p">:</span>
						<span class="n">tmp_total</span> <span class="o">+=</span> <span class="n">f</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
						<span class="k">if</span> <span class="n">tmp_total</span> <span class="o">&gt;</span> <span class="n">rand_individual</span><span class="p">:</span>
							<span class="k">if</span> <span class="n">f</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
								<span class="bp">self</span><span class="o">.</span><span class="n">comparison_abundances</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">-=</span> <span class="mi">1</span>
								<span class="n">difference</span> <span class="o">+=</span> <span class="mi">1</span>
								<span class="n">total_comparison</span> <span class="o">-=</span> <span class="mi">1</span>
								<span class="k">break</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">comparison_abundances</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">comparison_abundances</span> <span class="k">if</span> <span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">]</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">fragment_abundances</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">fragment_abundances</span> <span class="k">if</span> <span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">]</span>

	<span class="k">def</span> <span class="nf">_equalise_all_fragment_numbers</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Equalises the numbers in the fragments, removing individuals randomly from either the comparison_abundances or</span>
<span class="sd">		fragments objects so that the numbers are preserved.</span>

<span class="sd">		This is called automatically during importing the data for calculating comparison octaves, and should be called</span>
<span class="sd">		after importing all data, and before performing and goodness-of-fits.</span>

<span class="sd">		.. note:: Does not override the FRAGMENT_ABUNDANCES table - use adjust_fragment_abundances for this</span>

<span class="sd">		:return: None</span>
<span class="sd">		:rtype: None</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">equalised</span><span class="p">:</span>
			<span class="k">return</span>
		<span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">fragment_abundances</span><span class="p">:</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">calculate_fragment_abundances</span><span class="p">()</span>
		<span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">fragment_abundances</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">comparison_abundances</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
			<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cannot equalise fragment numbers if comparison or simulation data is missing.&quot;</span><span class="p">)</span>
		<span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_simulation_parameters</span><span class="p">()[</span><span class="s1">&#39;seed&#39;</span><span class="p">])</span>
		<span class="k">for</span> <span class="n">fragment</span> <span class="ow">in</span> <span class="nb">set</span><span class="p">([</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">fragment_abundances</span><span class="p">]):</span>
			<span class="k">for</span> <span class="n">reference</span> <span class="ow">in</span> <span class="nb">set</span><span class="p">([</span><span class="n">x</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">fragment_abundances</span><span class="p">]):</span>
				<span class="bp">self</span><span class="o">.</span><span class="n">_equalise_fragment_number</span><span class="p">(</span><span class="n">fragment</span><span class="p">,</span> <span class="n">reference</span><span class="p">)</span>
		<span class="c1"># now double check numbers match</span>
		<span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_check_fragment_numbers_match</span><span class="p">():</span>
			<span class="k">raise</span> <span class="ne">SystemError</span><span class="p">(</span><span class="s2">&quot;Failure attempting to equalise fragment numbers.&quot;</span><span class="p">)</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">equalised</span> <span class="o">=</span> <span class="bp">True</span>

	<span class="k">def</span> <span class="nf">_adjust_species_abundances</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Recalculates the species abundances from the equalised fragment abundances and writes over the</span>
<span class="sd">		SPECIES_ABUNDANCES table</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">equalised</span><span class="p">:</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">_equalise_all_fragment_numbers</span><span class="p">()</span>
		<span class="n">species_abundances</span> <span class="o">=</span> <span class="p">[]</span>
		<span class="nb">id</span> <span class="o">=</span> <span class="mi">0</span>
		<span class="k">for</span> <span class="n">reference</span> <span class="ow">in</span> <span class="nb">set</span><span class="p">([</span><span class="n">x</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">fragment_abundances</span><span class="p">]):</span>
			<span class="n">reference_subset</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">fragment_abundances</span> <span class="k">if</span> <span class="n">x</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">==</span> <span class="n">reference</span><span class="p">]</span>
			<span class="k">for</span> <span class="n">species_id</span> <span class="ow">in</span> <span class="nb">set</span><span class="p">([</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">reference_subset</span><span class="p">]):</span>
				<span class="nb">id</span> <span class="o">+=</span> <span class="mi">1</span>
				<span class="n">total</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">([</span><span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">reference_subset</span> <span class="k">if</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">species_id</span><span class="p">])</span>
				<span class="n">species_abundances</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="nb">id</span><span class="p">,</span> <span class="n">species_id</span><span class="p">,</span> <span class="n">total</span><span class="p">,</span> <span class="n">reference</span><span class="p">])</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">_check_database</span><span class="p">()</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">cursor</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s2">&quot;DROP TABLE IF EXISTS SPECIES_ABUNDANCES&quot;</span><span class="p">)</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">cursor</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s2">&quot;CREATE TABLE SPECIES_ABUNDANCES (ID INT NOT NULL PRIMARY KEY, species_id INT NOT NULL,&quot;</span>
							<span class="s2">&quot;no_individuals INT NOT NULL, community_reference INT NOT NULL)&quot;</span><span class="p">)</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">cursor</span><span class="o">.</span><span class="n">executemany</span><span class="p">(</span><span class="s2">&quot;INSERT INTO SPECIES_ABUNDANCES VALUES(?,?,?,?)&quot;</span><span class="p">,</span> <span class="n">species_abundances</span><span class="p">)</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">database</span><span class="o">.</span><span class="n">commit</span><span class="p">()</span>

	<span class="k">def</span> <span class="nf">_adjust_fragment_abundances</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Equalises fragment abundances with the comparison data, and overrides the FRAGMENT_ABUNDANCES table in the</span>
<span class="sd">		output database.</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">_check_database</span><span class="p">()</span>
		<span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">equalised</span><span class="p">:</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">_equalise_all_fragment_numbers</span><span class="p">()</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">cursor</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s2">&quot;DROP TABLE IF EXISTS FRAGMENT_ABUNDANCES&quot;</span><span class="p">)</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">cursor</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s2">&quot;CREATE TABLE FRAGMENT_ABUNDANCES (fragment TEXT NOT NULL, species_id INT NOT NULL,&quot;</span>
							<span class="s2">&quot; no_individuals INT NOT NULL, community_reference INT NOT NULL)&quot;</span><span class="p">)</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">cursor</span><span class="o">.</span><span class="n">executemany</span><span class="p">(</span><span class="s2">&quot;INSERT INTO FRAGMENT_ABUNDANCES VALUES(?,?,?,?)&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">fragment_abundances</span><span class="p">)</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">database</span><span class="o">.</span><span class="n">commit</span><span class="p">()</span>

	<span class="k">def</span> <span class="nf">_adjust_species_richness</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Recalculates the species richnesses equating numbers from the comparison data.</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">_check_database</span><span class="p">()</span>
		<span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">equalised</span><span class="p">:</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">_adjust_fragment_abundances</span><span class="p">()</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">_adjust_species_abundances</span><span class="p">()</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">cursor</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s2">&quot;DROP TABLE IF EXISTS SPECIES_RICHNESS&quot;</span><span class="p">)</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">calculate_richness</span><span class="p">(</span><span class="n">output_metrics</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>

	<span class="k">def</span> <span class="nf">_check_database</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Checks that the database has been opened and raises an error if it has not.</span>
<span class="sd">		Otherwise, makes sure that self.cursor is linked to the database</span>
<span class="sd">		:raises RuntimeError: if the database is None (has not been successfully imported).</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">database</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
			<span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Database has not yet been successfully imported. Can&#39;t perform calculations.&quot;</span><span class="p">)</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">cursor</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">database</span><span class="o">.</span><span class="n">cursor</span><span class="p">()</span>

	<span class="k">def</span> <span class="nf">_clear_goodness_of_fit</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Clears the goodness of fit calculations from the database.</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">_check_database</span><span class="p">()</span>
		<span class="k">if</span> <span class="n">check_sql_table_exist</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">database</span><span class="p">,</span> <span class="s2">&quot;BIODIVERSITY_METRICS&quot;</span><span class="p">):</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">cursor</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s2">&quot;DELETE FROM BIODIVERSITY_METRICS WHERE metric LIKE &#39;goodness_%&#39;&quot;</span><span class="p">)</span>

	<span class="k">def</span> <span class="nf">_get_comparison_plot_data</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Gets the plot data table containing fragment names and numbers of individuals in each fragment.</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">comparison_file</span> <span class="ow">is</span> <span class="bp">None</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">comparison_file</span><span class="p">):</span>
			<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cannot get plot data from comparison file {}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">comparison_file</span><span class="p">))</span>
		<span class="n">db</span> <span class="o">=</span> <span class="n">sqlite3</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">comparison_file</span><span class="p">)</span>
		<span class="n">c</span> <span class="o">=</span> <span class="n">db</span><span class="o">.</span><span class="n">cursor</span><span class="p">()</span>
		<span class="n">plot_data</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s2">&quot;SELECT fragment, no_individuals FROM PLOT_DATA&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">fetchall</span><span class="p">()</span>
		<span class="n">db</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
		<span class="n">db</span> <span class="o">=</span> <span class="bp">None</span>
		<span class="k">return</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">plot_data</span><span class="p">]</span>

	<span class="k">def</span> <span class="nf">_get_sim_parameters_guild</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">guild</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Gets the simulation parameters associated with this particular guild.</span>
<span class="sd">		:param guild: the guild number to obtain reference numbers for</span>
<span class="sd">		:return: dictionary containing simulation parameters for the given guild</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">_check_database</span><span class="p">()</span>
		<span class="k">try</span><span class="p">:</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">cursor</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s2">&quot;SELECT seed, job_type, output_dir, speciation_rate, sigma, tau, deme, sample_size, &quot;</span>
								<span class="s2">&quot;max_time, dispersal_relative_cost, min_num_species, habitat_change_rate, gen_since_historical, &quot;</span>
								<span class="s2">&quot;time_config_file, coarse_map_file, coarse_map_x, coarse_map_y, coarse_map_x_offset, &quot;</span>
								<span class="s2">&quot;coarse_map_y_offset, coarse_map_scale, fine_map_file, fine_map_x, fine_map_y, &quot;</span>
								<span class="s2">&quot;fine_map_x_offset, fine_map_y_offset, sample_file, grid_x, grid_y, sample_x, sample_y, &quot;</span>
								<span class="s2">&quot;sample_x_offset, sample_y_offset, historical_coarse_map, &quot;</span>
								<span class="s2">&quot; historical_fine_map, sim_complete, dispersal_method, m_probability, cutoff,&quot;</span>
								<span class="s2">&quot; landscape_type,  protracted, min_speciation_gen, max_speciation_gen, dispersal_map&quot;</span>
								<span class="s2">&quot; FROM SIMULATION_PARAMETERS WHERE guild == ?&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">guild</span><span class="p">,))</span>
		<span class="k">except</span> <span class="n">sqlite3</span><span class="o">.</span><span class="n">OperationalError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s2">&quot;Failure to get SIMULATION_PARAMETERS table from database with guild {}&quot;</span>
							  <span class="s2">&quot;. Check table exists.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">guild</span><span class="p">))</span>
			<span class="k">raise</span> <span class="n">e</span>
		<span class="n">out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cursor</span><span class="o">.</span><span class="n">fetchone</span><span class="p">()</span>
		<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">out</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
			<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;No simulation parameters exist for guild {}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">guild</span><span class="p">))</span>
		<span class="n">column_names</span> <span class="o">=</span> <span class="p">[</span><span class="n">member</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">member</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cursor</span><span class="o">.</span><span class="n">description</span><span class="p">]</span>
		<span class="n">values</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">out</span><span class="p">]</span>
		<span class="k">if</span> <span class="n">sys</span><span class="o">.</span><span class="n">version_info</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="mi">3</span><span class="p">:</span>
			<span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">each</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">values</span><span class="p">):</span>
				<span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">each</span><span class="p">,</span> <span class="nb">unicode</span><span class="p">):</span>
					<span class="n">values</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">each</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s1">&#39;ascii&#39;</span><span class="p">)</span>
		<span class="c1"># Now convert it into a dictionary</span>
		<span class="k">return</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">column_names</span><span class="p">,</span> <span class="n">values</span><span class="p">))</span>

<div class="viewcode-block" id="CoalescenceTree.setup"><a class="viewcode-back" href="../../pycoalescence.html#pycoalescence.coalescence_tree.CoalescenceTree.setup">[docs]</a>	<span class="k">def</span> <span class="nf">setup</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">speciation_program</span><span class="o">=</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">mod_directory</span><span class="p">,</span> <span class="s2">&quot;build/default/SpeciationCounter&quot;</span><span class="p">)):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Sets up the link to the SpeciationCounter program. Defaults to the build/default/SpeciationCounter</span>
<span class="sd">		:param speciation_program: optionally provide a path to an alternative SpeciationCounter program.</span>

<span class="sd">		.. deprecated:: 1.2.4</span>
<span class="sd">			Deprecated due to movement towards using Python API for applying speciation rates.</span>

<span class="sd">		:return: None</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">speciation_simulator</span> <span class="o">=</span> <span class="n">speciation_program</span>
		<span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">speciation_simulator</span><span class="p">):</span>
			<span class="k">raise</span> <span class="ne">IOError</span><span class="p">(</span><span class="s2">&quot;Speciation simulator &quot;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">speciation_simulator</span> <span class="o">+</span>
						  <span class="s2">&quot; not found. Check file path and access.&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="CoalescenceTree.set_database"><a class="viewcode-back" href="../../pycoalescence.html#pycoalescence.coalescence_tree.CoalescenceTree.set_database">[docs]</a>	<span class="k">def</span> <span class="nf">set_database</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Sets the database to the specified file and opens the sqlite connection.</span>

<span class="sd">		This must be done before any other operations can be performed and the</span>
<span class="sd">		file must exist.</span>

<span class="sd">		:raises IOError: if the simulation is not complete, as analysis can only be performed on complete simulations.</span>
<span class="sd">		 However, the database WILL be set before the error is thrown, allowing for analysis of</span>
<span class="sd">		 incomplete simulations if the error is handled correctly.</span>

<span class="sd">		:param pycoalescence.simulation.Simulation/str filename: the SQLite database file to import</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">pycoalescence</span><span class="o">.</span><span class="n">simulation</span><span class="o">.</span><span class="n">Simulation</span><span class="p">):</span>
			<span class="n">filename</span> <span class="o">=</span> <span class="n">filename</span><span class="o">.</span><span class="n">output_database</span>
			<span class="k">if</span> <span class="n">filename</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
				<span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Coalescence object does has not been set up properly and does not contain an output&quot;</span>
								   <span class="s2">&quot; database location.&quot;</span><span class="p">)</span>
		<span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">filename</span><span class="p">):</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">file</span> <span class="o">=</span> <span class="n">filename</span>
			<span class="k">try</span><span class="p">:</span>
				<span class="bp">self</span><span class="o">.</span><span class="n">database</span> <span class="o">=</span> <span class="n">sqlite3</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
			<span class="k">except</span> <span class="n">sqlite3</span><span class="o">.</span><span class="n">OperationalError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
				<span class="k">try</span><span class="p">:</span>
					<span class="bp">self</span><span class="o">.</span><span class="n">database</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
				<span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
					<span class="k">pass</span>
				<span class="bp">self</span><span class="o">.</span><span class="n">database</span> <span class="o">=</span> <span class="bp">None</span>
				<span class="k">raise</span> <span class="ne">IOError</span><span class="p">(</span><span class="s2">&quot;Error opening SQLite database: &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">e</span><span class="p">))</span>
			<span class="c1"># Now make sure that the simulation has been completed</span>
			<span class="k">try</span><span class="p">:</span>
				<span class="bp">self</span><span class="o">.</span><span class="n">cursor</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">database</span><span class="o">.</span><span class="n">cursor</span><span class="p">()</span>
				<span class="n">sql_fetch</span> <span class="o">=</span> \
					<span class="bp">self</span><span class="o">.</span><span class="n">cursor</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s2">&quot;SELECT sim_complete, time_config_file FROM SIMULATION_PARAMETERS&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">fetchall</span><span class="p">()[</span>
						<span class="mi">0</span><span class="p">]</span>
				<span class="c1"># print(sql_fetch)</span>
				<span class="n">complete</span> <span class="o">=</span> <span class="nb">bool</span><span class="p">(</span><span class="n">sql_fetch</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
				<span class="k">if</span> <span class="n">sql_fetch</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="s2">&quot;null&quot;</span><span class="p">:</span>
					<span class="bp">self</span><span class="o">.</span><span class="n">times</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">]</span>
				<span class="k">if</span> <span class="ow">not</span> <span class="n">complete</span><span class="p">:</span>
					<span class="bp">self</span><span class="o">.</span><span class="n">is_complete</span> <span class="o">=</span> <span class="bp">False</span>
					<span class="k">raise</span> <span class="ne">IOError</span><span class="p">(</span><span class="n">filename</span> <span class="o">+</span> <span class="s2">&quot; is not a complete simulation. Please finish &quot;</span> \
											 <span class="s2">&quot;simulation before performing analysis.&quot;</span><span class="p">)</span>
				<span class="k">else</span><span class="p">:</span>
					<span class="bp">self</span><span class="o">.</span><span class="n">is_complete</span> <span class="o">=</span> <span class="bp">True</span>
			<span class="k">except</span> <span class="n">sqlite3</span><span class="o">.</span><span class="n">OperationalError</span> <span class="k">as</span> <span class="n">soe</span><span class="p">:</span>
				<span class="bp">self</span><span class="o">.</span><span class="n">database</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
				<span class="k">raise</span> <span class="n">sqlite3</span><span class="o">.</span><span class="n">OperationalError</span><span class="p">(</span><span class="s2">&quot;Error checking simulation was complete: &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">soe</span><span class="p">))</span>
			<span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>
				<span class="bp">self</span><span class="o">.</span><span class="n">database</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
				<span class="k">raise</span> <span class="n">sqlite3</span><span class="o">.</span><span class="n">OperationalError</span><span class="p">(</span><span class="s2">&quot;Could not fetch SIMULATION_PARAMETERS. Table contains no data.&quot;</span><span class="p">)</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="k">raise</span> <span class="ne">IOError</span><span class="p">(</span><span class="s2">&quot;File &quot;</span> <span class="o">+</span> <span class="n">filename</span> <span class="o">+</span> <span class="s2">&quot; does not exist.&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="CoalescenceTree.set_speciation_parameters"><a class="viewcode-back" href="../../pycoalescence.html#pycoalescence.coalescence_tree.CoalescenceTree.set_speciation_parameters">[docs]</a>	<span class="k">def</span> <span class="nf">set_speciation_parameters</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">speciation_rates</span><span class="p">,</span> <span class="n">record_spatial</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">record_fragments</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
								  <span class="n">sample_file</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
								  <span class="n">times</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">protracted_speciation_min</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">protracted_speciation_max</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
								  <span class="n">metacommunity_size</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">metacommunity_speciation_rate</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
								  <span class="n">metacommunity_option</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">metacommunity_reference</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>

<span class="sd">		Set the parameters for the application of speciation rates. If no config files or time_config files are</span>
<span class="sd">		provided, they will be taken from the main coalescence simulation.</span>

<span class="sd">		:param float/list speciation_rates: a single float, or list of speciation rates to apply</span>
<span class="sd">		:param bool, str record_spatial: a boolean of whether to record spatial data (default=False)</span>
<span class="sd">		:param bool, str record_fragments: either a csv file containing fragment data, or T/F for whether fragments</span>
<span class="sd">										   should be calculated from squares of continuous habitat (default=False)</span>
<span class="sd">		:param str sample_file: a sample tif or csv specifying the sampling mask</span>
<span class="sd">		:param list times: a list of times to apply (should have been run with the original simulation)</span>
<span class="sd">		:param float protracted_speciation_min: the minimum number of generations required for speciation to occur</span>
<span class="sd">		:param float protracted speciation_max: the maximum number of generations before speciation occurs</span>
<span class="sd">		:param float metacommunity_size: the size of the metacommunity to apply</span>
<span class="sd">		:param float metacommunity_speciation_rate: speciation rate for the metacommunity</span>
<span class="sd">		:param str metacommunity_option: either &quot;simulated&quot;, &quot;analytical&quot;, or a path to a database to read SADs from</span>
<span class="sd">		:param int metacommunity_reference: the metacommunity reference if using a database to provide the metacommunity</span>

<span class="sd">		:rtype: None</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_setup_speciation</span><span class="p">:</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;Speciation parameters already set.&quot;</span><span class="p">)</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">_set_record_fragments</span><span class="p">(</span><span class="n">record_fragments</span><span class="p">)</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">_set_speciation_rates</span><span class="p">(</span><span class="n">speciation_rates</span><span class="p">)</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">_set_record_spatial</span><span class="p">(</span><span class="n">record_spatial</span><span class="p">)</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">_set_sample_file</span><span class="p">(</span><span class="n">sample_file</span><span class="p">)</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">_set_times</span><span class="p">(</span><span class="n">times</span><span class="p">)</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">_set_metacommunity_parameters</span><span class="p">(</span><span class="n">metacommunity_size</span><span class="o">=</span><span class="n">metacommunity_size</span><span class="p">,</span>
										   <span class="n">metacommunity_speciation_rate</span><span class="o">=</span><span class="n">metacommunity_speciation_rate</span><span class="p">,</span>
										   <span class="n">metacommunity_option</span><span class="o">=</span><span class="n">metacommunity_option</span><span class="p">,</span>
										   <span class="n">metacommunity_reference</span><span class="o">=</span><span class="n">metacommunity_reference</span><span class="p">)</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">_set_protracted_parameters</span><span class="p">(</span><span class="n">protracted_speciation_min</span><span class="p">,</span> <span class="n">protracted_speciation_max</span><span class="p">)</span>

		<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">sample_file</span> <span class="o">==</span> <span class="s2">&quot;null&quot;</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">record_fragments</span> <span class="o">==</span> <span class="s2">&quot;null&quot;</span><span class="p">:</span>
			<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cannot specify a null samplemask and expect automatic fragment detection; &quot;</span>
							 <span class="s2">&quot;provide a samplemask or set record_fragments=False.&quot;</span><span class="p">)</span>

		<span class="bp">self</span><span class="o">.</span><span class="n">_setup_c_community</span><span class="p">()</span></div>

	<span class="k">def</span> <span class="nf">_set_c_community</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Sets the C++ object depending on if a metacommunity is used or not.</span>

<span class="sd">		:rtype: None</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">c_community</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
			<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_check_metacommunity</span><span class="p">():</span>
				<span class="bp">self</span><span class="o">.</span><span class="n">c_community</span> <span class="o">=</span> <span class="n">libnecsim</span><span class="o">.</span><span class="n">CMetacommunity</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="p">,</span> <span class="n">write_to_log</span><span class="p">)</span>
			<span class="k">else</span><span class="p">:</span>
				<span class="bp">self</span><span class="o">.</span><span class="n">c_community</span> <span class="o">=</span> <span class="n">libnecsim</span><span class="o">.</span><span class="n">CCommunity</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="p">,</span> <span class="n">write_to_log</span><span class="p">)</span>

	<span class="k">def</span> <span class="nf">_setup_c_community</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Generates the initial parameters for the libnecsim object</span>

<span class="sd">		:rtype: None</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">_set_c_community</span><span class="p">()</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">c_community</span><span class="o">.</span><span class="n">setup</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">file</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">record_spatial</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sample_file</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">record_fragments</span><span class="p">,</span>
							   <span class="bp">self</span><span class="o">.</span><span class="n">applied_speciation_rates_list</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">times</span><span class="p">)</span>

	<span class="k">def</span> <span class="nf">_check_metacommunity</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Checks if the simulation needs to use a metacommunity.</span>

<span class="sd">		:return: true if the community is a metacommunity simulation</span>
<span class="sd">		:rtype: bool</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">metacommunity_option</span> <span class="ow">in</span> <span class="p">[</span><span class="bp">None</span><span class="p">,</span> <span class="s2">&quot;none&quot;</span><span class="p">,</span> <span class="s2">&quot;simulated&quot;</span><span class="p">,</span> <span class="s2">&quot;analytical&quot;</span><span class="p">]:</span>
			<span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">metacommunity_size</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="bp">None</span><span class="p">]</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">metacommunity_reference</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="bp">None</span><span class="p">]</span>

<div class="viewcode-block" id="CoalescenceTree.add_time"><a class="viewcode-back" href="../../pycoalescence.html#pycoalescence.coalescence_tree.CoalescenceTree.add_time">[docs]</a>	<span class="k">def</span> <span class="nf">add_time</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">time</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Adds the time to the list to be applied.</span>

<span class="sd">		:param time: the time to be applied</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">times</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">times</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">]</span>
		<span class="k">try</span><span class="p">:</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">times</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">time</span><span class="p">))</span>
		<span class="k">except</span> <span class="ne">ValueError</span> <span class="k">as</span> <span class="n">ve</span><span class="p">:</span>
			<span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Times must be floats: {}.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">ve</span><span class="p">))</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">_set_c_community</span><span class="p">()</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">c_community</span><span class="o">.</span><span class="n">add_time</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">time</span><span class="p">))</span></div>

<div class="viewcode-block" id="CoalescenceTree.add_times"><a class="viewcode-back" href="../../pycoalescence.html#pycoalescence.coalescence_tree.CoalescenceTree.add_times">[docs]</a>	<span class="k">def</span> <span class="nf">add_times</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">times</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Adds the list of times to those to be applied.</span>

<span class="sd">		:param times: list of times to be applied</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">times</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">):</span>
			<span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Times list must be iterable.&quot;</span><span class="p">)</span>
		<span class="k">for</span> <span class="n">each</span> <span class="ow">in</span> <span class="n">times</span><span class="p">:</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">add_time</span><span class="p">(</span><span class="n">each</span><span class="p">)</span></div>

<div class="viewcode-block" id="CoalescenceTree.add_protracted_parameters"><a class="viewcode-back" href="../../pycoalescence.html#pycoalescence.coalescence_tree.CoalescenceTree.add_protracted_parameters">[docs]</a>	<span class="k">def</span> <span class="nf">add_protracted_parameters</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">min_speciation_gen</span><span class="p">,</span> <span class="n">max_speciation_gen</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Adds the protracted parameter set.</span>

<span class="sd">		.. note:: Wipes (0.0, 0.0) from protracted parameters, if it is there alone.</span>

<span class="sd">		:param min_speciation_gen: the minimum number of generations required before speciation is permitted</span>
<span class="sd">		:param max_speciation_gen: the maximum number of generations required before speciation is permitted</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">protracted_parameters</span> <span class="o">==</span> <span class="p">[(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">)]:</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">protracted_parameters</span> <span class="o">=</span> <span class="p">[]</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">c_community</span><span class="o">.</span><span class="n">wipe_protracted_parameters</span><span class="p">()</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">min_speciation_gen</span><span class="p">,</span> <span class="n">max_speciation_gen</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">protracted_parameters</span><span class="p">:</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">_check_protracted_parameters</span><span class="p">(</span><span class="n">min_speciation_gen</span><span class="p">,</span> <span class="n">max_speciation_gen</span><span class="p">)</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">protracted_parameters</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">min_speciation_gen</span><span class="p">,</span> <span class="n">max_speciation_gen</span><span class="p">))</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">_set_c_community</span><span class="p">()</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">c_community</span><span class="o">.</span><span class="n">add_protracted_parameters</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">min_speciation_gen</span><span class="p">),</span> <span class="nb">float</span><span class="p">(</span><span class="n">max_speciation_gen</span><span class="p">))</span></div>

<div class="viewcode-block" id="CoalescenceTree.add_multiple_protracted_parameters"><a class="viewcode-back" href="../../pycoalescence.html#pycoalescence.coalescence_tree.CoalescenceTree.add_multiple_protracted_parameters">[docs]</a>	<span class="k">def</span> <span class="nf">add_multiple_protracted_parameters</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">min_speciation_gens</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">max_speciation_gens</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
										   <span class="n">speciation_gens</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Adds the protracted parameter set, taking an iterable as an input.</span>

<span class="sd">		.. note:: Using the keyword arguments, one can supply either a list of tuples for pairs of speciation</span>
<span class="sd">				  generations, or two lists of generations for the min and max, matching in order.</span>

<span class="sd">		:param min_speciation_gens: the minimum number of generations required before speciation is permitted. Order</span>
<span class="sd">									should match that of :attr:`max_speciation_gens`</span>
<span class="sd">		:param max_speciation_gens: the maximum number of generations required before speciation is permitted. Order</span>
<span class="sd">									should match that of :attr:`min_speciation_gens`</span>
<span class="sd">		:param speciation_gens: a list of tuples of min/max speciation generations.</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="k">if</span> <span class="n">min_speciation_gens</span> <span class="ow">and</span> <span class="n">max_speciation_gens</span><span class="p">:</span>
			<span class="n">tmp</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="n">min_speciation_gens</span><span class="p">,</span> <span class="n">max_speciation_gens</span><span class="p">)</span>
		<span class="k">elif</span> <span class="n">speciation_gens</span><span class="p">:</span>
			<span class="n">tmp</span> <span class="o">=</span> <span class="n">speciation_gens</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Must supply either minimum and maximum speciation gens, or a list of tuples containing &quot;</span>
							 <span class="s2">&quot;matching speciation generations.&quot;</span><span class="p">)</span>
		<span class="k">for</span> <span class="n">min_g</span><span class="p">,</span> <span class="n">max_g</span> <span class="ow">in</span> <span class="n">tmp</span><span class="p">:</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">add_protracted_parameters</span><span class="p">(</span><span class="n">min_g</span><span class="p">,</span> <span class="n">max_g</span><span class="p">)</span></div>

<div class="viewcode-block" id="CoalescenceTree.add_metacommunity_parameters"><a class="viewcode-back" href="../../pycoalescence.html#pycoalescence.coalescence_tree.CoalescenceTree.add_metacommunity_parameters">[docs]</a>	<span class="k">def</span> <span class="nf">add_metacommunity_parameters</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">metacommunity_size</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">metacommunity_speciation_rate</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
									 <span class="n">metacommunity_option</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
									 <span class="n">metacommunity_reference</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Adds the metacommunity parameters to the object.</span>

<span class="sd">		:param float metacommunity_size: the number of individuals in the metacommunity</span>
<span class="sd">		:param float metacommunity_speciation_rate: the speciation rate within the metacommunity</span>
<span class="sd">		:param str metacommunity_option: either &quot;simulated&quot;, &quot;analytical&quot;, or a path to a database to read SADs from</span>
<span class="sd">		:param int metacommunity_reference: the metacommunity reference if using a database to provide the metacommunity</span>

<span class="sd">		:rtype: None</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">_set_metacommunity_parameters</span><span class="p">(</span><span class="n">metacommunity_size</span><span class="p">,</span> <span class="n">metacommunity_speciation_rate</span><span class="p">,</span> <span class="n">metacommunity_option</span><span class="p">,</span>
										   <span class="n">metacommunity_reference</span><span class="p">)</span></div>

<div class="viewcode-block" id="CoalescenceTree.apply"><a class="viewcode-back" href="../../pycoalescence.html#pycoalescence.coalescence_tree.CoalescenceTree.apply">[docs]</a>	<span class="k">def</span> <span class="nf">apply</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Generates the cooalescence tree for the set of speciation parameters.</span>
<span class="sd">		This must be run after the main coalescence simulations are complete.</span>
<span class="sd">		It will create additional fields and tables in the SQLite database which contains the requested data.</span>
<span class="sd">		&quot;&quot;&quot;</span>

		<span class="c1"># Convert fragment file to null if it is true</span>
		<span class="c1"># Log warning if sample file is null and record fragments is true</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">apply_incremental</span><span class="p">()</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">c_community</span><span class="o">.</span><span class="n">output</span><span class="p">()</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">has_outputted</span> <span class="o">=</span> <span class="bp">True</span></div>

<div class="viewcode-block" id="CoalescenceTree.apply_incremental"><a class="viewcode-back" href="../../pycoalescence.html#pycoalescence.coalescence_tree.CoalescenceTree.apply_incremental">[docs]</a>	<span class="k">def</span> <span class="nf">apply_incremental</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Generates the coalescence tree for the set of speciation parameters. Does not write changes to the database,</span>
<span class="sd">		just holds the changes internally.</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="c1"># Check file exists</span>
		<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">times</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">times</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">]</span>
		<span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">file</span><span class="p">):</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="s2">&quot;Check file existance for &quot;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">file</span> <span class="o">+</span>
									<span class="s2">&quot;. Potential lack of access (verify that definition is a relative path).</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">))</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">_set_c_community</span><span class="p">()</span>
		<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_outputted</span><span class="p">:</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;Output has already been written to file - regenerating internal object.</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;To avoid this message in future, use apply_incremental() and then output() to generate &quot;</span>
							 <span class="s2">&quot;the file.</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">c_community</span><span class="o">.</span><span class="n">reset</span><span class="p">()</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">has_applied</span> <span class="o">=</span> <span class="bp">True</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">c_community</span><span class="o">.</span><span class="n">apply</span><span class="p">()</span></div>

<div class="viewcode-block" id="CoalescenceTree.output"><a class="viewcode-back" href="../../pycoalescence.html#pycoalescence.coalescence_tree.CoalescenceTree.output">[docs]</a>	<span class="k">def</span> <span class="nf">output</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Outputs the coalescence trees to the same simulation database object.</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_applied</span><span class="p">:</span>
			<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_outputted</span><span class="p">:</span>
				<span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s2">&quot;Coalescence tree has already been written to output database.</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
			<span class="k">else</span><span class="p">:</span>
				<span class="bp">self</span><span class="o">.</span><span class="n">c_community</span><span class="o">.</span><span class="n">output</span><span class="p">()</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;No changes have been applied to the coalescence tree for outputting.&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="CoalescenceTree.speciate_remaining"><a class="viewcode-back" href="../../pycoalescence.html#pycoalescence.coalescence_tree.CoalescenceTree.speciate_remaining">[docs]</a>	<span class="k">def</span> <span class="nf">speciate_remaining</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">database</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Speciates the remaining lineages in a paused database.</span>

<span class="sd">		:param str/pycoalescence.simulation.Simulation database: the paused database to open</span>

<span class="sd">		:rtype: None</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="k">try</span><span class="p">:</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">set_database</span><span class="p">(</span><span class="n">database</span><span class="p">)</span>
			<span class="k">raise</span> <span class="ne">IOError</span><span class="p">(</span><span class="s2">&quot;Database at {} is not a paused database.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">file</span><span class="p">))</span>
		<span class="k">except</span> <span class="ne">IOError</span><span class="p">:</span>
			<span class="k">pass</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">database</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">_set_c_community</span><span class="p">()</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">c_community</span><span class="o">.</span><span class="n">speciate_remaining_lineages</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">file</span><span class="p">)</span></div>

<div class="viewcode-block" id="CoalescenceTree.get_species_richness"><a class="viewcode-back" href="../../pycoalescence.html#pycoalescence.coalescence_tree.CoalescenceTree.get_species_richness">[docs]</a>	<span class="k">def</span> <span class="nf">get_species_richness</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">reference</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Get the system richness for the parameters associated with the supplied community reference.</span>

<span class="sd">		.. note::</span>

<span class="sd">			Richness of 0 is returned if there has been some problem; it is assumed that species richness</span>
<span class="sd">			will be above 0 for any simulation.</span>

<span class="sd">		.. note:: if species richness has previously been calculated and stored in SPECIES_RICHNESS table, it gets</span>
<span class="sd">				  the species richness value from there, otherwise it calculates the species richness</span>

<span class="sd">		:param reference: community reference which contains the parameters of interest</span>

<span class="sd">		:return: either a list containing the community references and respective species richness values</span>
<span class="sd">				 OR (if community_reference is provided), the species richness for that community reference.</span>

<span class="sd">		:rtype: int, list</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">_check_database</span><span class="p">()</span>
		<span class="k">try</span><span class="p">:</span>
			<span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">cursor</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s2">&quot;SELECT richness FROM SPECIES_RICHNESS &quot;</span>
									   <span class="s2">&quot;WHERE community_reference==?&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">reference</span><span class="p">,))</span><span class="o">.</span><span class="n">fetchone</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
		<span class="k">except</span> <span class="p">(</span><span class="ne">TypeError</span><span class="p">,</span> <span class="n">sqlite3</span><span class="o">.</span><span class="n">OperationalError</span><span class="p">):</span>
			<span class="k">try</span><span class="p">:</span>
				<span class="n">c</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cursor</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s2">&quot;SELECT species_id FROM SPECIES_ABUNDANCES WHERE no_individuals &gt; 0 AND &quot;</span>
										<span class="s2">&quot;community_reference == ?&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">reference</span><span class="p">,))</span><span class="o">.</span><span class="n">fetchall</span><span class="p">()</span>
				<span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">([</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">c</span><span class="p">]))</span>
			<span class="k">except</span> <span class="n">sqlite3</span><span class="o">.</span><span class="n">OperationalError</span> <span class="k">as</span> <span class="n">oe</span><span class="p">:</span>
				<span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">oe</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
				<span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;Could not find SPECIES_ABUNDANCES table in database &quot;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">file</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
				<span class="k">return</span> <span class="mi">0</span></div>

<div class="viewcode-block" id="CoalescenceTree.get_octaves"><a class="viewcode-back" href="../../pycoalescence.html#pycoalescence.coalescence_tree.CoalescenceTree.get_octaves">[docs]</a>	<span class="k">def</span> <span class="nf">get_octaves</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">reference</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Get the pre-calculated octave data for the parameters associated with the supplied reference.</span>
<span class="sd">		This will call self.calculate_octaves() if it hasn&#39;t been called previously.</span>

<span class="sd">		Returns are of form [id, &#39;whole&#39;, time, speciation rate, octave class, number of species]</span>

<span class="sd">		:param reference: community reference which contains the parameters of interest</span>
<span class="sd">		:return: output from FRAGMENT_OCTAVES on the whole landscape for the selected variables</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">_check_database</span><span class="p">()</span>
		<span class="k">if</span> <span class="n">check_sql_table_exist</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">database</span><span class="p">,</span> <span class="s2">&quot;FRAGMENT_OCTAVES&quot;</span><span class="p">):</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">calculate_octaves</span><span class="p">()</span>
		<span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_fragment_octaves</span><span class="p">(</span><span class="n">fragment</span><span class="o">=</span><span class="s2">&quot;whole&quot;</span><span class="p">,</span> <span class="n">reference</span><span class="o">=</span><span class="n">reference</span><span class="p">)</span></div>

<div class="viewcode-block" id="CoalescenceTree.get_number_individuals"><a class="viewcode-back" href="../../pycoalescence.html#pycoalescence.coalescence_tree.CoalescenceTree.get_number_individuals">[docs]</a>	<span class="k">def</span> <span class="nf">get_number_individuals</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fragment</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">community_reference</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Gets the number of individuals that exist, either in the provided fragment, or on the whole landscape.</span>
<span class="sd">		Counts individuals from FRAGMENT_ABUNDANCES or SPECIES_ABUNDANCES, respectively.</span>

<span class="sd">		If a community reference is provided, only individuals for that time slice will be counted, otherwise a mean is</span>
<span class="sd">		taken across time slices.</span>

<span class="sd">		:param fragment: the name of the fragment to get a count of individuals from</span>
<span class="sd">		:return: the number of individuals that exists in the desired location</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">_check_database</span><span class="p">()</span>
		<span class="k">if</span> <span class="n">fragment</span><span class="p">:</span>
			<span class="k">if</span> <span class="ow">not</span> <span class="n">check_sql_table_exist</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">database</span><span class="p">,</span> <span class="s2">&quot;FRAGMENT_ABUNDANCES&quot;</span><span class="p">):</span>
				<span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Cannot get a count from a fragment without calculating fragment abundances.&quot;</span><span class="p">)</span>
			<span class="k">if</span> <span class="ow">not</span> <span class="n">community_reference</span><span class="p">:</span>
				<span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">cursor</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s2">&quot;SELECT SUM(no_individuals)/COUNT(DISTINCT(community_reference))&quot;</span>
										   <span class="s2">&quot; FROM FRAGMENT_ABUNDANCES WHERE fragment == ?&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">fragment</span><span class="p">,))</span><span class="o">.</span><span class="n">fetchone</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
			<span class="k">else</span><span class="p">:</span>
				<span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">cursor</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s2">&quot;SELECT SUM(no_individuals) FROM FRAGMENT_ABUNDANCES &quot;</span>
										   <span class="s2">&quot;WHERE community_reference==?&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">community_reference</span><span class="p">,))</span><span class="o">.</span><span class="n">fetchone</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="k">if</span> <span class="ow">not</span> <span class="n">check_sql_table_exist</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">database</span><span class="p">,</span> <span class="s2">&quot;SPECIES_ABUNDANCES&quot;</span><span class="p">):</span>
				<span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
					<span class="s2">&quot;No species abundances table to fetch data from. Ensure your simulation is complete.&quot;</span><span class="p">)</span>
			<span class="k">if</span> <span class="ow">not</span> <span class="n">community_reference</span><span class="p">:</span>
				<span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">cursor</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s2">&quot;SELECT SUM(no_individuals)/COUNT(DISTINCT(community_reference)) &quot;</span>
										   <span class="s2">&quot;FROM SPECIES_ABUNDANCES&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">fetchone</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
			<span class="k">else</span><span class="p">:</span>
				<span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">cursor</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s2">&quot;SELECT SUM(no_individuals) FROM SPECIES_ABUNDANCES &quot;</span>
										   <span class="s2">&quot;WHERE community_reference==?&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">community_reference</span><span class="p">,))</span><span class="o">.</span><span class="n">fetchone</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span></div>

<div class="viewcode-block" id="CoalescenceTree.check_biodiversity_table_exists"><a class="viewcode-back" href="../../pycoalescence.html#pycoalescence.coalescence_tree.CoalescenceTree.check_biodiversity_table_exists">[docs]</a>	<span class="k">def</span> <span class="nf">check_biodiversity_table_exists</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Checks whether the biodiversity table exists and creates the table if required.</span>
<span class="sd">		</span>
<span class="sd">		:return: the max reference value currently existing</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">_check_database</span><span class="p">()</span>
		<span class="n">tmp_create</span> <span class="o">=</span> <span class="s2">&quot;CREATE TABLE BIODIVERSITY_METRICS (ref INT PRIMARY KEY NOT NULL, metric TEXT NOT NULL,&quot;</span> \
					 <span class="s2">&quot; fragment TEXT NOT NULL, community_reference INT NOT NULL,&quot;</span> \
					 <span class="s2">&quot; value FLOAT NOT NULL, simulated FLOAT, actual FLOAT)&quot;</span>
		<span class="k">if</span> <span class="ow">not</span> <span class="n">check_sql_table_exist</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">database</span><span class="p">,</span> <span class="s2">&quot;BIODIVERSITY_METRICS&quot;</span><span class="p">):</span>
			<span class="k">try</span><span class="p">:</span>
				<span class="bp">self</span><span class="o">.</span><span class="n">cursor</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">tmp_create</span><span class="p">)</span>
				<span class="bp">self</span><span class="o">.</span><span class="n">database</span><span class="o">.</span><span class="n">commit</span><span class="p">()</span>
			<span class="k">except</span> <span class="n">sqlite3</span><span class="o">.</span><span class="n">OperationalError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
				<span class="k">raise</span> <span class="n">sqlite3</span><span class="o">.</span><span class="n">OperationalError</span><span class="p">(</span><span class="s2">&quot;Error creating biodiversity metric table: &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">e</span><span class="p">))</span>
			<span class="k">return</span> <span class="mi">0</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="n">maxval</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">database</span><span class="o">.</span><span class="n">cursor</span><span class="p">()</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s2">&quot;SELECT MAX(ref) FROM BIODIVERSITY_METRICS&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">fetchone</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
			<span class="k">if</span> <span class="n">maxval</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
				<span class="k">return</span> <span class="mi">0</span>
			<span class="k">return</span> <span class="n">maxval</span></div>

<div class="viewcode-block" id="CoalescenceTree.calculate_richness"><a class="viewcode-back" href="../../pycoalescence.html#pycoalescence.coalescence_tree.CoalescenceTree.calculate_richness">[docs]</a>	<span class="k">def</span> <span class="nf">calculate_richness</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">output_metrics</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Calculates the landscape richness from across all fragments and stores result in a new table in</span>
<span class="sd">		SPECIES_RICHNESS</span>
<span class="sd">		Stores a separate result for each community reference.</span>

<span class="sd">		:param bool output_metrics: output to the BIODIVERSITY_METRICS table</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">_check_database</span><span class="p">()</span>
		<span class="n">tmp_create</span> <span class="o">=</span> <span class="s2">&quot;CREATE TABLE SPECIES_RICHNESS (ref INT PRIMARY KEY NOT NULL, community_reference INT NOT NULL,&quot;</span> \
					 <span class="s2">&quot; richness INT NOT NULL)&quot;</span>
		<span class="n">existing_references</span> <span class="o">=</span> <span class="p">[]</span>
		<span class="n">ref</span> <span class="o">=</span> <span class="mi">0</span>
		<span class="k">if</span> <span class="ow">not</span> <span class="n">check_sql_table_exist</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">database</span><span class="p">,</span> <span class="s2">&quot;SPECIES_RICHNESS&quot;</span><span class="p">):</span>
			<span class="k">try</span><span class="p">:</span>
				<span class="bp">self</span><span class="o">.</span><span class="n">cursor</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">tmp_create</span><span class="p">)</span>
				<span class="bp">self</span><span class="o">.</span><span class="n">database</span><span class="o">.</span><span class="n">commit</span><span class="p">()</span>
			<span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
				<span class="n">e</span><span class="o">.</span><span class="n">message</span> <span class="o">=</span> <span class="s2">&quot;Error creating SPECIES_RICHNESS table: &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
				<span class="k">raise</span> <span class="n">e</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="n">all_refs</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cursor</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s2">&quot;SELECT ref FROM SPECIES_RICHNESS&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">fetchall</span><span class="p">()]</span>
			<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">all_refs</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
				<span class="n">all_refs</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span>
			<span class="n">ref</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">all_refs</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
			<span class="n">existing_references</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">all_refs</span><span class="p">)</span>
		<span class="n">references</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_community_references</span><span class="p">()</span>
		<span class="n">output</span> <span class="o">=</span> <span class="p">[]</span>
		<span class="k">for</span> <span class="n">reference</span> <span class="ow">in</span> <span class="n">references</span><span class="p">:</span>
			<span class="k">if</span> <span class="n">reference</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">existing_references</span><span class="p">:</span>
				<span class="n">spec_richness</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_species_richness</span><span class="p">(</span><span class="n">reference</span><span class="p">)</span>
				<span class="n">output</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">ref</span><span class="p">,</span> <span class="n">reference</span><span class="p">,</span> <span class="n">spec_richness</span><span class="p">])</span>
				<span class="n">ref</span> <span class="o">+=</span> <span class="mi">1</span>
		<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">output</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
			<span class="n">ref</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">check_biodiversity_table_exists</span><span class="p">()</span>
			<span class="k">if</span> <span class="n">output_metrics</span><span class="p">:</span>
				<span class="n">bio_output</span> <span class="o">=</span> <span class="p">[]</span>
				<span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">output</span><span class="p">:</span>
					<span class="n">ref</span> <span class="o">+=</span> <span class="mi">1</span>
					<span class="n">tmp</span> <span class="o">=</span> <span class="p">[</span><span class="n">ref</span><span class="p">,</span> <span class="s2">&quot;fragment_richness&quot;</span><span class="p">,</span> <span class="s2">&quot;whole&quot;</span><span class="p">]</span>
					<span class="n">tmp</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">]])</span>
					<span class="n">bio_output</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tmp</span><span class="p">)</span>
				<span class="bp">self</span><span class="o">.</span><span class="n">cursor</span><span class="o">.</span><span class="n">executemany</span><span class="p">(</span><span class="s2">&quot;INSERT INTO BIODIVERSITY_METRICS VALUES (?, ?, ?, ?, ?, NULL, NULL)&quot;</span><span class="p">,</span>
										<span class="n">bio_output</span><span class="p">)</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">cursor</span><span class="o">.</span><span class="n">executemany</span><span class="p">(</span><span class="s2">&quot;INSERT INTO SPECIES_RICHNESS VALUES(?,?,?)&quot;</span><span class="p">,</span> <span class="n">output</span><span class="p">)</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">database</span><span class="o">.</span><span class="n">commit</span><span class="p">()</span></div>

<div class="viewcode-block" id="CoalescenceTree.calculate_fragment_abundances"><a class="viewcode-back" href="../../pycoalescence.html#pycoalescence.coalescence_tree.CoalescenceTree.calculate_fragment_abundances">[docs]</a>	<span class="k">def</span> <span class="nf">calculate_fragment_abundances</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Calculates the fragment abundances, including equalising with the comparison database, if it has already been</span>
<span class="sd">		set.</span>

<span class="sd">		Sets fragment_abundances object.</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">fragment_abundances</span><span class="p">:</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">_check_database</span><span class="p">()</span>
			<span class="k">if</span> <span class="ow">not</span> <span class="n">check_sql_table_exist</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">database</span><span class="p">,</span> <span class="s2">&quot;FRAGMENT_ABUNDANCES&quot;</span><span class="p">):</span>
				<span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Database does not contain FRAGMENT_ABUNDANCES table.&quot;</span><span class="p">)</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">fragment_abundances</span> <span class="o">=</span> <span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span>
										<span class="bp">self</span><span class="o">.</span><span class="n">cursor</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s2">&quot;SELECT fragment, species_id,&quot;</span>
															<span class="s2">&quot; no_individuals, community_reference &quot;</span>
															<span class="s2">&quot;FROM FRAGMENT_ABUNDANCES&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">fetchall</span><span class="p">()</span> <span class="k">if</span> <span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">]</span>
			<span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">fragment_abundances</span><span class="p">:</span>
				<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Fragment abundances table may be empty, or not properly stored.&quot;</span><span class="p">)</span>
			<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">comparison_abundances</span><span class="p">:</span>
				<span class="bp">self</span><span class="o">.</span><span class="n">_equalise_all_fragment_numbers</span><span class="p">()</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;Fragment abundances already imported.&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="CoalescenceTree.calculate_fragment_richness"><a class="viewcode-back" href="../../pycoalescence.html#pycoalescence.coalescence_tree.CoalescenceTree.calculate_fragment_richness">[docs]</a>	<span class="k">def</span> <span class="nf">calculate_fragment_richness</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">output_metrics</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Calculates the fragment richness and stores it in a new table called FRAGMENT_RICHNESS. Also adds the record to</span>
<span class="sd">		BIODIVERSITY METRICS for</span>
<span class="sd">		If the table already exists, it will simply be returned. Each time point and speciation rate combination will be</span>
<span class="sd">		recorded as a new variable.</span>

<span class="sd">		:param bool output_metrics: output to the BIODIVERSITY_METRICS table</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">_check_database</span><span class="p">()</span>
		<span class="n">tmp_create</span> <span class="o">=</span> <span class="s2">&quot;CREATE TABLE FRAGMENT_RICHNESS (ref INT PRIMARY KEY NOT NULL, fragment TEXT NOT NULL,&quot;</span> \
					 <span class="s2">&quot; community_reference INT NOT NULL,  richness INT NOT NULL)&quot;</span>
		<span class="c1"># First check the FRAGMENT_ABUNDANCES TABLE EXISTS</span>
		<span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">fragment_abundances</span><span class="p">:</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">calculate_fragment_abundances</span><span class="p">()</span>
		<span class="c1"># Now try and create FRAGMENT_RICHNESS</span>
		<span class="k">if</span> <span class="ow">not</span> <span class="n">check_sql_table_exist</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">database</span><span class="p">,</span> <span class="s2">&quot;FRAGMENT_RICHNESS&quot;</span><span class="p">):</span>
			<span class="k">try</span><span class="p">:</span>
				<span class="bp">self</span><span class="o">.</span><span class="n">cursor</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">tmp_create</span><span class="p">)</span>
				<span class="bp">self</span><span class="o">.</span><span class="n">database</span><span class="o">.</span><span class="n">commit</span><span class="p">()</span>
			<span class="k">except</span> <span class="n">sqlite3</span><span class="o">.</span><span class="n">OperationalError</span><span class="p">:</span>
				<span class="k">raise</span> <span class="n">sqlite3</span><span class="o">.</span><span class="n">OperationalError</span><span class="p">(</span><span class="s2">&quot;Could not create FRAGMENT_RICHNESS table&quot;</span><span class="p">)</span>
			<span class="n">fragment_names</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([</span><span class="n">fa</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">fa</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">fragment_abundances</span><span class="p">])</span>
			<span class="n">references</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([</span><span class="n">fa</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="k">for</span> <span class="n">fa</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">fragment_abundances</span><span class="p">])</span>
			<span class="c1"># self.fragments.extend(([]*len(times)-1))</span>
			<span class="n">ref</span> <span class="o">=</span> <span class="mi">0</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">fragments</span> <span class="o">=</span> <span class="p">[]</span>
			<span class="k">for</span> <span class="n">each</span> <span class="ow">in</span> <span class="n">fragment_names</span><span class="p">:</span>
				<span class="k">for</span> <span class="n">reference</span> <span class="ow">in</span> <span class="n">references</span><span class="p">:</span>
					<span class="n">selection</span> <span class="o">=</span> <span class="p">[</span><span class="n">row</span> <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">fragment_abundances</span> <span class="k">if</span> <span class="n">row</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">each</span> <span class="ow">and</span> <span class="n">row</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">==</span> <span class="n">reference</span><span class="p">]</span>
					<span class="bp">self</span><span class="o">.</span><span class="n">fragments</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">ref</span><span class="p">,</span> <span class="n">each</span><span class="p">,</span> <span class="n">reference</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">selection</span><span class="p">)])</span>
					<span class="n">ref</span> <span class="o">+=</span> <span class="mi">1</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">cursor</span><span class="o">.</span><span class="n">executemany</span><span class="p">(</span><span class="s2">&quot;INSERT INTO FRAGMENT_RICHNESS VALUES(?, ?, ?, ?)&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">fragments</span><span class="p">)</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">database</span><span class="o">.</span><span class="n">commit</span><span class="p">()</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">fragments</span> <span class="o">=</span> <span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cursor</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s2">&quot;SELECT fragment, community_reference, richness&quot;</span>
															   <span class="s2">&quot; FROM FRAGMENT_RICHNESS&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">fetchall</span><span class="p">()]</span>
		<span class="c1"># Move fragment richnesses into BIODIVERSITY METRICS</span>
		<span class="k">if</span> <span class="n">output_metrics</span><span class="p">:</span>
			<span class="n">ref</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">check_biodiversity_table_exists</span><span class="p">()</span>
			<span class="n">tmp_fragments</span> <span class="o">=</span> <span class="p">[]</span>
			<span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">fragments</span><span class="p">:</span>
				<span class="n">ref</span> <span class="o">+=</span> <span class="mi">1</span>
				<span class="n">tmp</span> <span class="o">=</span> <span class="p">[</span><span class="n">ref</span><span class="p">,</span> <span class="s2">&quot;fragment_richness&quot;</span><span class="p">]</span>
				<span class="n">tmp</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
				<span class="n">tmp_fragments</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tmp</span><span class="p">)</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">cursor</span><span class="o">.</span><span class="n">executemany</span><span class="p">(</span><span class="s2">&quot;INSERT INTO BIODIVERSITY_METRICS VALUES(?,?,?,?,?, NULL, NULL)&quot;</span><span class="p">,</span> <span class="n">tmp_fragments</span><span class="p">)</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">database</span><span class="o">.</span><span class="n">commit</span><span class="p">()</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">calculate_richness</span><span class="p">()</span></div>

<div class="viewcode-block" id="CoalescenceTree.calculate_alpha_diversity"><a class="viewcode-back" href="../../pycoalescence.html#pycoalescence.coalescence_tree.CoalescenceTree.calculate_alpha_diversity">[docs]</a>	<span class="k">def</span> <span class="nf">calculate_alpha_diversity</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">output_metrics</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Calculates the system alpha diversity for each set of parameters stored in COMMUNITY_PARAMETERS.</span>
<span class="sd">		Stores the output in ALPHA_DIVERSITY table.</span>

<span class="sd">		:param bool output_metrics: output to the BIODIVERSITY_METRICS table</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">_check_database</span><span class="p">()</span>
		<span class="k">if</span> <span class="ow">not</span> <span class="n">check_sql_table_exist</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">database</span><span class="p">,</span> <span class="s2">&quot;FRAGMENT_ABUNDANCES&quot;</span><span class="p">):</span>
			<span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Fragment abundances must be calculated before alpha diversity.&quot;</span><span class="p">)</span>
		<span class="k">if</span> <span class="ow">not</span> <span class="n">check_sql_table_exist</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">database</span><span class="p">,</span> <span class="s2">&quot;ALPHA_DIVERSITY&quot;</span><span class="p">):</span>
			<span class="n">tmp_create</span> <span class="o">=</span> <span class="s2">&quot;CREATE TABLE ALPHA_DIVERSITY (reference INT PRIMARY KEY NOT NULL, &quot;</span> \
						 <span class="s2">&quot;alpha_diversity INT NOT NULL)&quot;</span>
			<span class="k">try</span><span class="p">:</span>
				<span class="bp">self</span><span class="o">.</span><span class="n">cursor</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">tmp_create</span><span class="p">)</span>
				<span class="bp">self</span><span class="o">.</span><span class="n">database</span><span class="o">.</span><span class="n">commit</span><span class="p">()</span>
			<span class="k">except</span> <span class="n">sqlite3</span><span class="o">.</span><span class="n">OperationalError</span><span class="p">:</span>
				<span class="k">raise</span> <span class="n">sqlite3</span><span class="o">.</span><span class="n">OperationalError</span><span class="p">(</span><span class="s2">&quot;Could not create ALPHA_DIVERSITY table&quot;</span><span class="p">)</span>
			<span class="n">all_community_references</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_community_references</span><span class="p">()</span>
			<span class="n">all_fragments</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_fragment_list</span><span class="p">()</span>
			<span class="n">output</span> <span class="o">=</span> <span class="p">[]</span>
			<span class="k">for</span> <span class="n">reference</span> <span class="ow">in</span> <span class="n">all_community_references</span><span class="p">:</span>
				<span class="n">total</span> <span class="o">=</span> <span class="mi">0</span>
				<span class="k">for</span> <span class="n">fragment</span> <span class="ow">in</span> <span class="n">all_fragments</span><span class="p">:</span>
					<span class="n">total</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_fragment_richness</span><span class="p">(</span><span class="n">fragment</span><span class="o">=</span><span class="n">fragment</span><span class="p">,</span> <span class="n">reference</span><span class="o">=</span><span class="n">reference</span><span class="p">)</span>
				<span class="n">alpha</span> <span class="o">=</span> <span class="n">total</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">all_fragments</span><span class="p">)</span>
				<span class="n">output</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">reference</span><span class="p">,</span> <span class="n">alpha</span><span class="p">])</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">cursor</span><span class="o">.</span><span class="n">executemany</span><span class="p">(</span><span class="s2">&quot;INSERT INTO ALPHA_DIVERSITY VALUES(?,?)&quot;</span><span class="p">,</span> <span class="n">output</span><span class="p">)</span>
			<span class="c1"># Now also insert into BIODIVERSITY metrics</span>
			<span class="k">if</span> <span class="n">output_metrics</span><span class="p">:</span>
				<span class="n">ref</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">check_biodiversity_table_exists</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span>
				<span class="n">output</span> <span class="o">=</span> <span class="p">[[</span><span class="n">i</span> <span class="o">+</span> <span class="n">ref</span><span class="p">,</span> <span class="s2">&quot;alpha_diversity&quot;</span><span class="p">,</span> <span class="s2">&quot;whole&quot;</span><span class="p">,</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">output</span><span class="p">)]</span>
				<span class="bp">self</span><span class="o">.</span><span class="n">cursor</span><span class="o">.</span><span class="n">executemany</span><span class="p">(</span><span class="s2">&quot;INSERT INTO BIODIVERSITY_METRICS VALUES(?,?,?,?,?, NULL, NULL)&quot;</span><span class="p">,</span> <span class="n">output</span><span class="p">)</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">database</span><span class="o">.</span><span class="n">commit</span><span class="p">()</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;Alpha diversity already calculated.&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="CoalescenceTree.calculate_beta_diversity"><a class="viewcode-back" href="../../pycoalescence.html#pycoalescence.coalescence_tree.CoalescenceTree.calculate_beta_diversity">[docs]</a>	<span class="k">def</span> <span class="nf">calculate_beta_diversity</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">output_metrics</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Calculates the beta diversity for the system for each speciation parameter set and stores the output in</span>
<span class="sd">		BETA_DIVERSITY.</span>
<span class="sd">		Will calculate alpha diversity and species richness tables if they have not already been performed.</span>

<span class="sd">		:param bool output_metrics: output to the BIODIVERSITY_METRICS table</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">_check_database</span><span class="p">()</span>
		<span class="n">tmp_create</span> <span class="o">=</span> <span class="s2">&quot;CREATE TABLE BETA_DIVERSITY (reference INT PRIMARY KEY NOT NULL, &quot;</span> \
					 <span class="s2">&quot;beta_diversity INT NOT NULL)&quot;</span>
		<span class="k">if</span> <span class="ow">not</span> <span class="n">check_sql_table_exist</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">database</span><span class="p">,</span> <span class="s2">&quot;ALPHA_DIVERSITY&quot;</span><span class="p">):</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">calculate_alpha_diversity</span><span class="p">()</span>
		<span class="k">if</span> <span class="ow">not</span> <span class="n">check_sql_table_exist</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">database</span><span class="p">,</span> <span class="s2">&quot;SPECIES_RICHNESS&quot;</span><span class="p">):</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">calculate_richness</span><span class="p">()</span>
		<span class="k">if</span> <span class="ow">not</span> <span class="n">check_sql_table_exist</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">database</span><span class="p">,</span> <span class="s2">&quot;BETA_DIVERSITY&quot;</span><span class="p">):</span>
			<span class="k">try</span><span class="p">:</span>
				<span class="bp">self</span><span class="o">.</span><span class="n">cursor</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">tmp_create</span><span class="p">)</span>
				<span class="bp">self</span><span class="o">.</span><span class="n">database</span><span class="o">.</span><span class="n">commit</span><span class="p">()</span>
			<span class="k">except</span> <span class="n">sqlite3</span><span class="o">.</span><span class="n">OperationalError</span><span class="p">:</span>
				<span class="k">raise</span> <span class="n">sqlite3</span><span class="o">.</span><span class="n">OperationalError</span><span class="p">(</span><span class="s2">&quot;Could not create BETA_DIVERSITY table&quot;</span><span class="p">)</span>
			<span class="n">all_community_references</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_community_references</span><span class="p">()</span>
			<span class="n">output</span> <span class="o">=</span> <span class="p">[]</span>
			<span class="k">for</span> <span class="n">reference</span> <span class="ow">in</span> <span class="n">all_community_references</span><span class="p">:</span>
				<span class="n">beta</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_species_richness</span><span class="p">(</span><span class="n">reference</span><span class="p">))</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_alpha_diversity</span><span class="p">(</span><span class="n">reference</span><span class="p">))</span>
				<span class="n">output</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">reference</span><span class="p">,</span> <span class="n">beta</span><span class="p">])</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">cursor</span><span class="o">.</span><span class="n">executemany</span><span class="p">(</span><span class="s2">&quot;INSERT INTO BETA_DIVERSITY VALUES(?,?)&quot;</span><span class="p">,</span> <span class="n">output</span><span class="p">)</span>
			<span class="c1"># Now also insert into BIODIVERSITY metrics</span>
			<span class="k">if</span> <span class="n">output_metrics</span><span class="p">:</span>
				<span class="n">ref</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">check_biodiversity_table_exists</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span>
				<span class="n">output</span> <span class="o">=</span> <span class="p">[[</span><span class="n">i</span> <span class="o">+</span> <span class="n">ref</span><span class="p">,</span> <span class="s2">&quot;beta_diversity&quot;</span><span class="p">,</span> <span class="s2">&quot;whole&quot;</span><span class="p">,</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">output</span><span class="p">)]</span>
				<span class="bp">self</span><span class="o">.</span><span class="n">cursor</span><span class="o">.</span><span class="n">executemany</span><span class="p">(</span><span class="s2">&quot;INSERT INTO BIODIVERSITY_METRICS VALUES(?,?,?,?,?, NULL, NULL)&quot;</span><span class="p">,</span> <span class="n">output</span><span class="p">)</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">database</span><span class="o">.</span><span class="n">commit</span><span class="p">()</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;Beta diversity already calculated.&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="CoalescenceTree.get_alpha_diversity"><a class="viewcode-back" href="../../pycoalescence.html#pycoalescence.coalescence_tree.CoalescenceTree.get_alpha_diversity">[docs]</a>	<span class="k">def</span> <span class="nf">get_alpha_diversity</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">reference</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Gets the system alpha diversity for the provided community reference parameters.</span>
<span class="sd">		Alpha diversity is the mean number of species per fragment.</span>
<span class="sd">		:param reference: the community reference for speciation parameters</span>
<span class="sd">		:return: the alpha diversity of the system</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">_check_database</span><span class="p">()</span>
		<span class="k">if</span> <span class="ow">not</span> <span class="n">check_sql_table_exist</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">database</span><span class="p">,</span> <span class="s2">&quot;ALPHA_DIVERSITY&quot;</span><span class="p">):</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">calculate_alpha_diversity</span><span class="p">()</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">cursor</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s2">&quot;SELECT alpha_diversity FROM ALPHA_DIVERSITY WHERE reference == ?&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">reference</span><span class="p">,))</span>
		<span class="n">res</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cursor</span><span class="o">.</span><span class="n">fetchone</span><span class="p">()</span>
		<span class="k">if</span> <span class="n">res</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
			<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;No alpha diversity value for reference = {}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">reference</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">res</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span></div>

<div class="viewcode-block" id="CoalescenceTree.get_beta_diversity"><a class="viewcode-back" href="../../pycoalescence.html#pycoalescence.coalescence_tree.CoalescenceTree.get_beta_diversity">[docs]</a>	<span class="k">def</span> <span class="nf">get_beta_diversity</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">reference</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Gets the system beta diversity for the provided community reference parameters.</span>
<span class="sd">		Beta diversity is the true beta diversity (gamma / alpha).</span>
<span class="sd">		:param reference: the community reference for speciation parameters</span>
<span class="sd">		:return: the beta diversity of the system</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">_check_database</span><span class="p">()</span>
		<span class="k">if</span> <span class="ow">not</span> <span class="n">check_sql_table_exist</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">database</span><span class="p">,</span> <span class="s2">&quot;BETA_DIVERSITY&quot;</span><span class="p">):</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">calculate_beta_diversity</span><span class="p">()</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">cursor</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s2">&quot;SELECT beta_diversity FROM BETA_DIVERSITY WHERE reference == ?&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">reference</span><span class="p">,))</span>
		<span class="n">res</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cursor</span><span class="o">.</span><span class="n">fetchone</span><span class="p">()</span>
		<span class="k">if</span> <span class="n">res</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
			<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;No beta diversity value for reference = {}.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">reference</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">res</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span></div>

<div class="viewcode-block" id="CoalescenceTree.import_comparison_data"><a class="viewcode-back" href="../../pycoalescence.html#pycoalescence.coalescence_tree.CoalescenceTree.import_comparison_data">[docs]</a>	<span class="k">def</span> <span class="nf">import_comparison_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="p">,</span> <span class="n">ignore_mismatch</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Imports the SQL database that contains the biodiversity metrics that we want to compare against.</span>

<span class="sd">		This can either be real data (for comparing simulated data) or other simulated data (for comparing between models).</span>

<span class="sd">		If the SQL database does not contain the relevant biodiversity metrics, they will be calculated (if possible) or skipped.</span>

<span class="sd">		The expected form of the database is the same as the BIODIVERSITY_METRICS table, except without any speciation</span>
<span class="sd">		rates or time references, and a new column containing the number of individuals involved in each metric.</span>

<span class="sd">		.. note::</span>

<span class="sd">			This also equalises the comparison data if ignore_mismatch is not True, so that the number of individuals</span>
<span class="sd">			is equal between the simulated and comparison datasets.</span>

<span class="sd">		:param str filename: the file containing the comparison biodiversity metrics.</span>
<span class="sd">		:param bool ignore_mismatch: set to true to ignore abundance mismatches between the comparison and simulated data.</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">filename</span><span class="p">):</span>
			<span class="k">raise</span> <span class="ne">IOError</span><span class="p">(</span><span class="s2">&quot;Comparison database does not exist at {}.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">filename</span><span class="p">))</span>
		<span class="n">conn</span> <span class="o">=</span> <span class="n">sqlite3</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
		<span class="n">tmp_cursor</span> <span class="o">=</span> <span class="n">conn</span><span class="o">.</span><span class="n">cursor</span><span class="p">()</span>
		<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">comparison_file</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;Comparison data has already been imported.&quot;</span><span class="p">)</span>
		<span class="k">try</span><span class="p">:</span>
			<span class="k">if</span> <span class="n">check_sql_table_exist</span><span class="p">(</span><span class="n">conn</span><span class="p">,</span> <span class="s2">&quot;BIODIVERSITY_METRICS&quot;</span><span class="p">):</span>
				<span class="bp">self</span><span class="o">.</span><span class="n">comparison_data</span> <span class="o">=</span> <span class="n">tmp_cursor</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s2">&quot;SELECT metric, fragment, value, no_individuals&quot;</span>
														  <span class="s2">&quot; FROM BIODIVERSITY_METRICS&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">fetchall</span><span class="p">()</span>
			<span class="k">try</span><span class="p">:</span>
				<span class="bp">self</span><span class="o">.</span><span class="n">comparison_abundances</span> <span class="o">=</span> <span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">tmp_cursor</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span>
					<span class="s2">&quot;SELECT fragment, species_id, no_individuals FROM FRAGMENT_ABUNDANCES&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">fetchall</span><span class="p">()]</span>
				<span class="bp">self</span><span class="o">.</span><span class="n">comparison_abundances_whole</span> <span class="o">=</span> <span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">tmp_cursor</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span>
					<span class="s2">&quot;SELECT species_id, no_individuals FROM SPECIES_ABUNDANCES&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">fetchall</span><span class="p">()]</span>
			<span class="k">except</span> <span class="n">sqlite3</span><span class="o">.</span><span class="n">OperationalError</span> <span class="k">as</span> <span class="n">oe</span><span class="p">:</span>
				<span class="k">raise</span> <span class="n">sqlite3</span><span class="o">.</span><span class="n">OperationalError</span><span class="p">(</span><span class="s2">&quot;Problem executing fetches from comparison data: &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">oe</span><span class="p">))</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">comparison_file</span> <span class="o">=</span> <span class="n">filename</span>
		<span class="k">except</span> <span class="n">sqlite3</span><span class="o">.</span><span class="n">OperationalError</span> <span class="k">as</span> <span class="n">oe</span><span class="p">:</span>
			<span class="n">conn</span> <span class="o">=</span> <span class="bp">None</span>
			<span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Could not import from comparison data: &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">oe</span><span class="p">))</span>
		<span class="n">conn</span> <span class="o">=</span> <span class="bp">None</span>
		<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">fragment_abundances</span><span class="p">:</span>
			<span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_check_fragment_numbers_match</span><span class="p">()</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">ignore_mismatch</span><span class="p">:</span>
				<span class="bp">self</span><span class="o">.</span><span class="n">_equalise_all_fragment_numbers</span><span class="p">()</span></div>

<div class="viewcode-block" id="CoalescenceTree.adjust_data"><a class="viewcode-back" href="../../pycoalescence.html#pycoalescence.coalescence_tree.CoalescenceTree.adjust_data">[docs]</a>	<span class="k">def</span> <span class="nf">adjust_data</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Ensures that the numbers of individuals are equalised between the comparison and simulated datasets, and</span>
<span class="sd">		modifies the relevant tables with the new data</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">_equalise_all_fragment_numbers</span><span class="p">()</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">_adjust_fragment_abundances</span><span class="p">()</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">_adjust_species_abundances</span><span class="p">()</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">_adjust_species_richness</span><span class="p">()</span></div>

<div class="viewcode-block" id="CoalescenceTree.calculate_comparison_octaves"><a class="viewcode-back" href="../../pycoalescence.html#pycoalescence.coalescence_tree.CoalescenceTree.calculate_comparison_octaves">[docs]</a>	<span class="k">def</span> <span class="nf">calculate_comparison_octaves</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">store</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Calculates the octave classes for the comparison data and for fragments (if required).</span>
<span class="sd">		If the octaves exist in the FRAGMENT_OCTAVES table in the comparison database, the data will be imported</span>
<span class="sd">		instead of being re-calculated.</span>

<span class="sd">		.. note::</span>

<span class="sd">		 	If store is True, will store an EDITED version of the comparison octaves, such that the number of</span>
<span class="sd">			individuals is equal between the comparison and simulated data.</span>

<span class="sd">		:param store: if True, stores within the comparison database.</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">comparison_octaves</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
			<span class="c1"># If comparison_octaves has not been calculated, then do that now.</span>
			<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">comparison_abundances</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
				<span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
					<span class="s2">&quot;Comparison abundances not yet imported, or FRAGMENT_ABUNDANCES does not exist in comparison file.&quot;</span><span class="p">)</span>
			<span class="c1"># Check whether the FRAGMENT_OCTAVES table exists, if it is, just stored that in self.comparison_octaves</span>
			<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">comparison_file</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
				<span class="c1"># read the data from the database</span>
				<span class="n">db</span> <span class="o">=</span> <span class="n">sqlite3</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">comparison_file</span><span class="p">)</span>
				<span class="n">c</span> <span class="o">=</span> <span class="n">db</span><span class="o">.</span><span class="n">cursor</span><span class="p">()</span>
				<span class="k">if</span> <span class="n">check_sql_table_exist</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">database</span><span class="p">,</span> <span class="s2">&quot;FRAGMENT_OCTAVES&quot;</span><span class="p">):</span>
					<span class="n">tmp_list</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s2">&quot;SELECT fragment, octave, richness FROM FRAGMENT_OCTAVES&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">fetchall</span><span class="p">()</span>
					<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">tmp_list</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
						<span class="bp">self</span><span class="o">.</span><span class="n">comparison_octaves</span> <span class="o">=</span> <span class="n">tmp_list</span>
						<span class="n">store</span> <span class="o">=</span> <span class="bp">False</span>
			<span class="c1"># Need to calculate again if the fragment numbers don&#39;t match</span>
			<span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_check_fragment_numbers_match</span><span class="p">():</span>
				<span class="bp">self</span><span class="o">.</span><span class="n">comparison_octaves</span> <span class="o">=</span> <span class="bp">None</span>
			<span class="c1"># Otherwise, if comparison abundances exists, we can calculate the comparison octaves manually</span>
			<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">comparison_abundances</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">comparison_octaves</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
				<span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_check_fragment_numbers_match</span><span class="p">():</span>
					<span class="bp">self</span><span class="o">.</span><span class="n">_equalise_all_fragment_numbers</span><span class="p">()</span>
				<span class="c1"># now calculate octaves</span>
				<span class="bp">self</span><span class="o">.</span><span class="n">comparison_octaves</span> <span class="o">=</span> <span class="p">[]</span>
				<span class="n">ref</span> <span class="o">=</span> <span class="mi">0</span>
				<span class="n">fragments</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">comparison_abundances</span><span class="p">])</span>
				<span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">fragments</span><span class="p">:</span>
					<span class="n">octaves</span> <span class="o">=</span> <span class="p">[[],</span> <span class="p">[]]</span>
					<span class="n">octaves</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
					<span class="n">octaves</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
					<span class="n">abundances</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">comparison_abundances</span> <span class="k">if</span> <span class="nb">str</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">==</span> <span class="n">f</span><span class="p">]</span>
					<span class="c1"># print(abundances)</span>
					<span class="c1"># exit(0)</span>
					<span class="k">for</span> <span class="n">each</span> <span class="ow">in</span> <span class="n">abundances</span><span class="p">:</span>
						<span class="n">this_octave</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">each</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="mi">2</span><span class="p">)))</span>
						<span class="k">if</span> <span class="n">this_octave</span> <span class="ow">in</span> <span class="n">octaves</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
							<span class="n">pos</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">octaves</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="k">if</span> <span class="n">x</span> <span class="o">==</span> <span class="n">this_octave</span><span class="p">]</span>
							<span class="c1"># print(octaves)</span>
							<span class="bp">self</span><span class="o">.</span><span class="n">comparison_octaves</span><span class="p">[</span><span class="n">octaves</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">pos</span><span class="p">[</span><span class="mi">0</span><span class="p">]]][</span><span class="mi">2</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
						<span class="k">else</span><span class="p">:</span>
							<span class="bp">self</span><span class="o">.</span><span class="n">comparison_octaves</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="nb">str</span><span class="p">(</span><span class="n">f</span><span class="p">),</span> <span class="n">this_octave</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
							<span class="c1"># print(self.comparison_octaves)</span>
							<span class="n">octaves</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">this_octave</span><span class="p">)</span>
							<span class="n">octaves</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ref</span><span class="p">)</span>
							<span class="n">ref</span> <span class="o">+=</span> <span class="mi">1</span>
				<span class="c1"># print(len(self.comparison_octaves)-1)</span>
				<span class="n">octaves</span> <span class="o">=</span> <span class="p">[[],</span> <span class="p">[]]</span>
				<span class="n">octaves</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
				<span class="n">octaves</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
				<span class="n">abundances</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">comparison_abundances_whole</span>
				<span class="c1"># print(abundances)</span>
				<span class="c1"># exit(0)</span>
				<span class="k">for</span> <span class="n">each</span> <span class="ow">in</span> <span class="n">abundances</span><span class="p">:</span>
					<span class="n">this_octave</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">each</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">2</span><span class="p">)))</span>
					<span class="k">if</span> <span class="n">this_octave</span> <span class="ow">in</span> <span class="n">octaves</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
						<span class="n">pos</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">octaves</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="k">if</span> <span class="n">x</span> <span class="o">==</span> <span class="n">this_octave</span><span class="p">]</span>
						<span class="c1"># print(octaves)</span>
						<span class="bp">self</span><span class="o">.</span><span class="n">comparison_octaves</span><span class="p">[</span><span class="n">octaves</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">pos</span><span class="p">[</span><span class="mi">0</span><span class="p">]]][</span><span class="mi">2</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
					<span class="k">else</span><span class="p">:</span>
						<span class="bp">self</span><span class="o">.</span><span class="n">comparison_octaves</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="s2">&quot;whole&quot;</span><span class="p">,</span> <span class="n">this_octave</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
						<span class="c1"># print(self.comparison_octaves)</span>
						<span class="n">octaves</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">this_octave</span><span class="p">)</span>
						<span class="n">octaves</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ref</span><span class="p">)</span>
						<span class="n">ref</span> <span class="o">+=</span> <span class="mi">1</span>
			<span class="c1"># now sort the list</span>
			<span class="c1"># If we want to store the comparison octaves, overwrite the original FRAGMENT_OCTAVES table (if it exists</span>
			<span class="c1"># with the new calculated data</span>
			<span class="k">if</span> <span class="n">store</span><span class="p">:</span>
				<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">comparison_file</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
					<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Comparison file has not been imported yet, and therefore cannot be written to.&quot;</span><span class="p">)</span>
				<span class="n">conn</span> <span class="o">=</span> <span class="n">sqlite3</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">comparison_file</span><span class="p">)</span>
				<span class="n">cursor</span> <span class="o">=</span> <span class="n">conn</span><span class="o">.</span><span class="n">cursor</span><span class="p">()</span>
				<span class="n">cursor</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s2">&quot;DROP TABLE IF EXISTS FRAGMENT_OCTAVES&quot;</span><span class="p">)</span>
				<span class="n">cursor</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span>
					<span class="s2">&quot;CREATE TABLE FRAGMENT_OCTAVES (ref INT PRIMARY KEY NOT NULL, fragment TEXT NOT NULL, &quot;</span>
					<span class="s2">&quot;octave INT NOT NULL, richness INT NOT NULL)&quot;</span><span class="p">)</span>
				<span class="n">cursor</span><span class="o">.</span><span class="n">executemany</span><span class="p">(</span><span class="s2">&quot;INSERT INTO FRAGMENT_OCTAVES VALUES(?,?,?,?)&quot;</span><span class="p">,</span>
								   <span class="p">[[</span><span class="n">i</span><span class="p">,</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">]]</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">comparison_octaves</span><span class="p">)])</span>
				<span class="n">conn</span><span class="o">.</span><span class="n">commit</span><span class="p">()</span>
			<span class="n">conn</span> <span class="o">=</span> <span class="bp">None</span></div>

<div class="viewcode-block" id="CoalescenceTree.calculate_octaves"><a class="viewcode-back" href="../../pycoalescence.html#pycoalescence.coalescence_tree.CoalescenceTree.calculate_octaves">[docs]</a>	<span class="k">def</span> <span class="nf">calculate_octaves</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Calculates the octave classes for the landscape. Outputs the calculated richness into the SQL database within a</span>
<span class="sd">		FRAGMENT_OCTAVES table.</span>

<span class="sd">		&quot;&quot;&quot;</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">_check_database</span><span class="p">()</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">cursor</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span>
			<span class="s2">&quot;CREATE TABLE IF NOT EXISTS FRAGMENT_OCTAVES (ref INT PRIMARY KEY NOT NULL, fragment TEXT NOT NULL, &quot;</span>
			<span class="s2">&quot;community_reference INT NOT NULL, octave INT NOT NULL, richness INT NOT NULL)&quot;</span><span class="p">)</span>
		<span class="n">abundances</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cursor</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span>
			<span class="s2">&quot;SELECT species_id, no_individuals, community_reference FROM SPECIES_ABUNDANCES&quot;</span>
			<span class="s2">&quot; WHERE no_individuals&gt;0&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">fetchall</span><span class="p">()</span>
		<span class="n">references</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([</span><span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">abundances</span><span class="p">])</span>
		<span class="c1"># Check what the maximum reference is in FRAGMENT_OCTAVES</span>
		<span class="k">try</span><span class="p">:</span>
			<span class="n">c</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cursor</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s2">&quot;SELECT max(ref) FROM FRAGMENT_OCTAVES&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">fetchone</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>
		<span class="k">except</span> <span class="p">(</span><span class="n">sqlite3</span><span class="o">.</span><span class="n">OperationalError</span><span class="p">,</span> <span class="ne">TypeError</span><span class="p">):</span>
			<span class="n">c</span> <span class="o">=</span> <span class="mi">0</span>
		<span class="k">for</span> <span class="n">ref</span> <span class="ow">in</span> <span class="n">references</span><span class="p">:</span>
			<span class="n">select_abundances</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">abundances</span> <span class="k">if</span> <span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="n">ref</span><span class="p">]</span>
			<span class="n">log_select</span> <span class="o">=</span> <span class="p">[</span><span class="n">math</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">select_abundances</span><span class="p">]</span>
			<span class="n">out</span> <span class="o">=</span> <span class="p">[]</span>
			<span class="k">try</span><span class="p">:</span>
				<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">log_select</span><span class="p">)),</span> <span class="mi">1</span><span class="p">):</span>
					<span class="n">tot</span> <span class="o">=</span> <span class="n">log_select</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
					<span class="n">out</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">c</span><span class="p">,</span> <span class="s2">&quot;whole&quot;</span><span class="p">,</span> <span class="n">ref</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">tot</span><span class="p">])</span>
					<span class="n">c</span> <span class="o">+=</span> <span class="mi">1</span>
			<span class="k">except</span> <span class="ne">ValueError</span> <span class="k">as</span> <span class="n">ve</span><span class="p">:</span>
				<span class="k">raise</span> <span class="n">ve</span>
			<span class="k">try</span><span class="p">:</span>
				<span class="bp">self</span><span class="o">.</span><span class="n">cursor</span><span class="o">.</span><span class="n">executemany</span><span class="p">(</span><span class="s2">&quot;INSERT INTO FRAGMENT_OCTAVES VALUES (?,?,?,?,?)&quot;</span><span class="p">,</span> <span class="n">out</span><span class="p">)</span>
				<span class="bp">self</span><span class="o">.</span><span class="n">database</span><span class="o">.</span><span class="n">commit</span><span class="p">()</span>
			<span class="k">except</span> <span class="n">sqlite3</span><span class="o">.</span><span class="n">OperationalError</span> <span class="k">as</span> <span class="n">oe</span><span class="p">:</span>
				<span class="k">raise</span> <span class="n">sqlite3</span><span class="o">.</span><span class="n">OperationalError</span><span class="p">(</span><span class="s2">&quot;Could not insert into FRAGMENT_OCTAVES.&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">oe</span><span class="p">))</span></div>

<div class="viewcode-block" id="CoalescenceTree.calculate_fragment_octaves"><a class="viewcode-back" href="../../pycoalescence.html#pycoalescence.coalescence_tree.CoalescenceTree.calculate_fragment_octaves">[docs]</a>	<span class="k">def</span> <span class="nf">calculate_fragment_octaves</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Calculates the octave classes for each fragment. Outputs the calculated richness into the SQL database within a</span>
<span class="sd">		FRAGMENT_OCTAVES table</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">_check_database</span><span class="p">()</span>
		<span class="k">if</span> <span class="n">check_sql_table_exist</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">database</span><span class="p">,</span> <span class="s2">&quot;FRAGMENT_OCTAVES&quot;</span><span class="p">):</span>
			<span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;FRAGMENT_OCTAVES already exists&quot;</span><span class="p">)</span>
		<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">fragment_abundances</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">calculate_fragment_abundances</span><span class="p">()</span>
		<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fragments</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
			<span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Fragments not imported correctly&quot;</span><span class="p">)</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">cursor</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span>
			<span class="s2">&quot;CREATE TABLE IF NOT EXISTS FRAGMENT_OCTAVES (ref INT PRIMARY KEY NOT NULL, fragment TEXT NOT NULL, &quot;</span>
			<span class="s2">&quot;community_reference INT NOT NULL, octave INT NOT NULL, richness INT NOT NULL)&quot;</span><span class="p">)</span>
		<span class="n">fragments</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">fragment_abundances</span><span class="p">])</span>
		<span class="n">references</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([</span><span class="n">x</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">fragment_abundances</span><span class="p">])</span>
		<span class="n">c</span> <span class="o">=</span> <span class="mi">0</span>
		<span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">fragments</span><span class="p">:</span>
			<span class="k">for</span> <span class="n">ref</span> <span class="ow">in</span> <span class="n">references</span><span class="p">:</span>
				<span class="n">select_abundances</span> <span class="o">=</span> <span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">fragment_abundances</span> <span class="k">if</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">f</span> <span class="ow">and</span> <span class="n">x</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">==</span> <span class="n">ref</span><span class="p">]</span>
				<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">select_abundances</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
					<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Could not calculate fragment octaves for {}, with reference = {}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">ref</span><span class="p">))</span>
				<span class="n">log_select</span> <span class="o">=</span> <span class="p">[</span><span class="n">math</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">select_abundances</span><span class="p">]</span>
				<span class="n">out</span> <span class="o">=</span> <span class="p">[]</span>
				<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">log_select</span><span class="p">)),</span> <span class="mi">1</span><span class="p">):</span>
					<span class="n">tot</span> <span class="o">=</span> <span class="n">log_select</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
					<span class="n">out</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">c</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">ref</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">tot</span><span class="p">])</span>
					<span class="n">c</span> <span class="o">+=</span> <span class="mi">1</span>
				<span class="k">try</span><span class="p">:</span>
					<span class="bp">self</span><span class="o">.</span><span class="n">cursor</span><span class="o">.</span><span class="n">executemany</span><span class="p">(</span><span class="s2">&quot;INSERT INTO FRAGMENT_OCTAVES VALUES (?,?,?,?,?)&quot;</span><span class="p">,</span> <span class="n">out</span><span class="p">)</span>
				<span class="k">except</span> <span class="n">sqlite3</span><span class="o">.</span><span class="n">OperationalError</span> <span class="k">as</span> <span class="n">oe</span><span class="p">:</span>
					<span class="k">raise</span> <span class="n">sqlite3</span><span class="o">.</span><span class="n">OperationalError</span><span class="p">(</span><span class="s2">&quot;Could not insert into FRAGMENT_OCTAVES.&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">oe</span><span class="p">))</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">database</span><span class="o">.</span><span class="n">commit</span><span class="p">()</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">calculate_octaves</span><span class="p">()</span></div>

<div class="viewcode-block" id="CoalescenceTree.get_fragment_richness"><a class="viewcode-back" href="../../pycoalescence.html#pycoalescence.coalescence_tree.CoalescenceTree.get_fragment_richness">[docs]</a>	<span class="k">def</span> <span class="nf">get_fragment_richness</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fragment</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">reference</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Gets the fragment richness for each speciation rate and time for the specified simulation. If the fragment</span>
<span class="sd">		richness has not yet been calculated, it tries to calculate the fragment richness,</span>

<span class="sd">		:param fragment: the desired fragment (defaults to None)</span>
<span class="sd">		:param reference: the reference key for the calculated community parameters</span>

<span class="sd">		:raises: sqlite3.OperationalError if no table FRAGMENT_ABUNDANCES exists</span>
<span class="sd">		:raises: RuntimeError if no data for the specified fragment, speciation rate and time exists.</span>

<span class="sd">		:return: A list containing the fragment richness, or a value of the fragment richness</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">_check_database</span><span class="p">()</span>
		<span class="k">if</span> <span class="n">reference</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
			<span class="k">if</span> <span class="n">fragment</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
				<span class="k">raise</span> <span class="ne">SyntaxError</span><span class="p">(</span><span class="s2">&quot;Must supply a reference when supplying a fragment.&quot;</span><span class="p">)</span>
			<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fragments</span><span class="p">)</span> <span class="ow">is</span> <span class="mi">0</span><span class="p">:</span>
				<span class="bp">self</span><span class="o">.</span><span class="n">calculate_fragment_richness</span><span class="p">()</span>
			<span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">fragments</span>
		<span class="k">elif</span> <span class="n">fragment</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
			<span class="k">raise</span> <span class="ne">SyntaxError</span><span class="p">(</span><span class="s2">&quot;Must supply a fragment name when supplying a reference.&quot;</span><span class="p">)</span>
		<span class="n">output</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cursor</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s2">&quot;SELECT richness FROM FRAGMENT_RICHNESS WHERE community_reference == ? AND &quot;</span>
									 <span class="s2">&quot;fragment ==  ?&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">reference</span><span class="p">,</span> <span class="n">fragment</span><span class="p">))</span><span class="o">.</span><span class="n">fetchall</span><span class="p">()</span>
		<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">output</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
			<span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;No output while fetching fragment data for {}.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">fragment</span><span class="p">))</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="k">return</span> <span class="n">output</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span></div>

<div class="viewcode-block" id="CoalescenceTree.get_fragment_abundances"><a class="viewcode-back" href="../../pycoalescence.html#pycoalescence.coalescence_tree.CoalescenceTree.get_fragment_abundances">[docs]</a>	<span class="k">def</span> <span class="nf">get_fragment_abundances</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fragment</span><span class="p">,</span> <span class="n">reference</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Gets the species abundances for the supplied fragment and community reference.</span>
<span class="sd">		:param fragment: the name of the fragment to obtain</span>
<span class="sd">		:param reference: the reference for speciation parameters to obtain for</span>
<span class="sd">		:return: a list of species ids and abundances</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">_check_database</span><span class="p">()</span>
		<span class="k">if</span> <span class="ow">not</span> <span class="n">check_sql_table_exist</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">database</span><span class="p">,</span> <span class="s2">&quot;FRAGMENT_ABUNDANCES&quot;</span><span class="p">):</span>
			<span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Fragments abundances must be calculated before attempting to get fragment abundances.&quot;</span><span class="p">)</span>
		<span class="n">output</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cursor</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s2">&quot;SELECT species_id, no_individuals FROM FRAGMENT_ABUNDANCES WHERE &quot;</span>
									 <span class="s2">&quot;community_reference == ? AND fragment ==  ?&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">reference</span><span class="p">,</span> <span class="n">fragment</span><span class="p">))</span><span class="o">.</span><span class="n">fetchall</span><span class="p">()</span>
		<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">output</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
			<span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;No output while fetching fragment data for {}.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">fragment</span><span class="p">))</span>
		<span class="k">return</span> <span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">output</span><span class="p">]</span></div>

<div class="viewcode-block" id="CoalescenceTree.get_all_fragment_abundances"><a class="viewcode-back" href="../../pycoalescence.html#pycoalescence.coalescence_tree.CoalescenceTree.get_all_fragment_abundances">[docs]</a>	<span class="k">def</span> <span class="nf">get_all_fragment_abundances</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Returns the whole table of fragment abundances from the database.</span>

<span class="sd">		:return: a list of reference, fragment, species_id, no_individuals</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">_check_database</span><span class="p">()</span>
		<span class="k">if</span> <span class="ow">not</span> <span class="n">check_sql_table_exist</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">database</span><span class="p">,</span> <span class="s2">&quot;FRAGMENT_ABUNDANCES&quot;</span><span class="p">):</span>
			<span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Fragments abundances must be calculated before attempting to get fragment abundances.&quot;</span><span class="p">)</span>
		<span class="n">output</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cursor</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s2">&quot;SELECT community_reference, fragment, species_id, no_individuals FROM &quot;</span>
									 <span class="s2">&quot;FRAGMENT_ABUNDANCES&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">fetchall</span><span class="p">()</span>
		<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">output</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
			<span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;No output while fetching all fragment abundances&quot;</span><span class="p">)</span>
		<span class="k">return</span> <span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">output</span><span class="p">]</span></div>

<div class="viewcode-block" id="CoalescenceTree.get_fragment_list"><a class="viewcode-back" href="../../pycoalescence.html#pycoalescence.coalescence_tree.CoalescenceTree.get_fragment_list">[docs]</a>	<span class="k">def</span> <span class="nf">get_fragment_list</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">community_reference</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Returns a list of all fragments that exist in FRAGMENT_ABUNDANCES.</span>

<span class="sd">		:param community_reference: community reference to obtain for (default 1)</span>
<span class="sd">		:return: list all all fragment names</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">_check_database</span><span class="p">()</span>
		<span class="k">if</span> <span class="ow">not</span> <span class="n">check_sql_table_exist</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">database</span><span class="p">,</span> <span class="s2">&quot;FRAGMENT_ABUNDANCES&quot;</span><span class="p">):</span>
			<span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Fragment abundances have not been calculated; cannot obtain fragment list.&quot;</span><span class="p">)</span>
		<span class="n">fetch</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cursor</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s2">&quot;SELECT DISTINCT(fragment) FROM FRAGMENT_ABUNDANCES WHERE &quot;</span>
									<span class="s2">&quot;community_reference == ?&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">community_reference</span><span class="p">,))</span><span class="o">.</span><span class="n">fetchall</span><span class="p">()</span>
		<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">fetch</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
			<span class="k">raise</span> <span class="n">sqlite3</span><span class="o">.</span><span class="n">OperationalError</span><span class="p">(</span><span class="s2">&quot;No fragments exist in FRAGMENT_ABUNDANCES.&quot;</span><span class="p">)</span>
		<span class="k">return</span> <span class="p">[</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">fetch</span><span class="p">]</span></div>

<div class="viewcode-block" id="CoalescenceTree.get_fragment_octaves"><a class="viewcode-back" href="../../pycoalescence.html#pycoalescence.coalescence_tree.CoalescenceTree.get_fragment_octaves">[docs]</a>	<span class="k">def</span> <span class="nf">get_fragment_octaves</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fragment</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">reference</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Get the pre-calculated octave data for the specified fragment, speciation rate and time. If fragment and</span>
<span class="sd">		speciation_rate are None, returns the entire FRAGMENT_OCTAVES object</span>
<span class="sd">		This requires self.calculate_fragment_octaves() to have been run successfully at some point previously.</span>

<span class="sd">		Returns are of form [id, fragment, community_reference, octave class, number of species]</span>

<span class="sd">		:param fragment: the desired fragment (defaults to None)</span>
<span class="sd">		:param reference: the reference key for the calculated community parameters</span>

<span class="sd">		:return: output from FRAGMENT_OCTAVES for the selected variables</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">_check_database</span><span class="p">()</span>
		<span class="k">if</span> <span class="n">fragment</span> <span class="ow">is</span> <span class="bp">None</span> <span class="ow">and</span> <span class="n">reference</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
			<span class="k">return</span> <span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cursor</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s2">&quot;SELECT fragment, community_reference, octave, richness&quot;</span>
														 <span class="s2">&quot; FROM FRAGMENT_OCTAVES&quot;</span><span class="p">)]</span>
		<span class="k">elif</span> <span class="n">fragment</span> <span class="ow">is</span> <span class="bp">None</span> <span class="ow">or</span> <span class="n">reference</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
			<span class="k">raise</span> <span class="ne">SyntaxError</span><span class="p">(</span><span class="s2">&quot;Only one of fragment or reference supplied: must supply both, or neither.&quot;</span><span class="p">)</span>
		<span class="k">try</span><span class="p">:</span>
			<span class="n">output</span> <span class="o">=</span> <span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cursor</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s2">&quot;SELECT octave, richness FROM FRAGMENT_OCTAVES WHERE &quot;</span>
														   <span class="s2">&quot;community_reference == ? AND fragment == ?&quot;</span><span class="p">,</span>
														   <span class="p">(</span><span class="n">reference</span><span class="p">,</span> <span class="n">fragment</span><span class="p">))</span><span class="o">.</span><span class="n">fetchall</span><span class="p">()]</span>
			<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">output</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
				<span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
					<span class="s2">&quot;No output while fetching fragment data for {} with ref: {}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">fragment</span><span class="p">,</span> <span class="n">reference</span><span class="p">))</span>
		<span class="k">except</span> <span class="n">sqlite3</span><span class="o">.</span><span class="n">OperationalError</span> <span class="k">as</span> <span class="n">oe</span><span class="p">:</span>
			<span class="k">raise</span> <span class="n">sqlite3</span><span class="o">.</span><span class="n">OperationalError</span><span class="p">(</span><span class="s2">&quot;Failure whilst fetching fragment octave data.&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">oe</span><span class="p">))</span>
		<span class="n">output</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
		<span class="k">return</span> <span class="n">output</span></div>

<div class="viewcode-block" id="CoalescenceTree.get_species_abundances"><a class="viewcode-back" href="../../pycoalescence.html#pycoalescence.coalescence_tree.CoalescenceTree.get_species_abundances">[docs]</a>	<span class="k">def</span> <span class="nf">get_species_abundances</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fragment</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">reference</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Gets the species abundance for a particular fragment, speciation rate and time. If fragment is None, returns the</span>
<span class="sd">		whole landscape species abundances.</span>

<span class="sd">		:param fragment: the fragment to obtain the species abundance of. If None, returns landscape abundances.</span>
<span class="sd">		:param speciation_rate: speciation rate to obtain abundances for</span>
<span class="sd">		:param time: the time to obtain abundances for</span>

<span class="sd">		:return: list of species abundances [reference, species ID, speciation rate, number of individuals, generation]</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">_check_database</span><span class="p">()</span>
		<span class="k">if</span> <span class="n">fragment</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
			<span class="k">if</span> <span class="n">reference</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
				<span class="n">reference</span> <span class="o">=</span> <span class="mi">1</span>
			<span class="k">return</span> <span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span>
					<span class="bp">self</span><span class="o">.</span><span class="n">cursor</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s2">&quot;SELECT species_id, no_individuals FROM SPECIES_ABUNDANCES WHERE &quot;</span>
										<span class="s2">&quot;community_reference==?&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">reference</span><span class="p">,))</span><span class="o">.</span><span class="n">fetchall</span><span class="p">()]</span>
		<span class="k">elif</span> <span class="n">reference</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
			<span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Must specify a community reference to get a fragment species abundance&quot;</span><span class="p">)</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="k">return</span> <span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span>
					<span class="bp">self</span><span class="o">.</span><span class="n">cursor</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s2">&quot;SELECT species_id, no_individuals FROM FRAGMENT_ABUNDANCES WHERE&quot;</span>
										<span class="s2">&quot; fragment == ? AND &quot;</span>
										<span class="s2">&quot;community_reference == ?&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">fragment</span><span class="p">,</span> <span class="n">reference</span><span class="p">))]</span></div>

<div class="viewcode-block" id="CoalescenceTree.calculate_octaves_error"><a class="viewcode-back" href="../../pycoalescence.html#pycoalescence.coalescence_tree.CoalescenceTree.calculate_octaves_error">[docs]</a>	<span class="k">def</span> <span class="nf">calculate_octaves_error</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Calculates the error in octaves classes between the simulated data and the comparison data.</span>
<span class="sd">		Stores each error value as a new entry in BIODIVERSITY_METRICS under fragment_octaves.</span>
<span class="sd">		Calculates the error by comparing each octave class and summing the relative difference.</span>
<span class="sd">		Octaves are then averaged for each fragment.</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">comparison_octaves</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">calculate_comparison_octaves</span><span class="p">()</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">_check_database</span><span class="p">()</span>
		<span class="k">if</span> <span class="ow">not</span> <span class="n">check_sql_table_exist</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">database</span><span class="p">,</span> <span class="s2">&quot;FRAGMENT_OCTAVES&quot;</span><span class="p">):</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">calculate_fragment_octaves</span><span class="p">()</span>

		<span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cursor</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s2">&quot;SELECT fragment, community_reference FROM FRAGMENT_OCTAVES&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">fetchall</span><span class="p">()</span>
		<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">calculate_fragment_octaves</span><span class="p">()</span>
		<span class="k">try</span><span class="p">:</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">cursor</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s2">&quot;ALTER TABLE FRAGMENT_OCTAVES ADD COLUMN comparison FLOAT&quot;</span><span class="p">)</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">cursor</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s2">&quot;ALTER TABLE FRAGMENT_OCTAVES ADD COLUMN error FLOAT&quot;</span><span class="p">)</span>
			<span class="n">col_add</span> <span class="o">=</span> <span class="bp">True</span>
		<span class="k">except</span> <span class="n">sqlite3</span><span class="o">.</span><span class="n">OperationalError</span> <span class="k">as</span> <span class="n">soe</span><span class="p">:</span>
			<span class="k">raise</span> <span class="n">sqlite3</span><span class="o">.</span><span class="n">OperationalError</span><span class="p">(</span><span class="s2">&quot;Could not alter FRAGMENT_OCTAVES table: &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">soe</span><span class="p">))</span>
		<span class="n">fragments</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">data</span><span class="p">])</span>
		<span class="n">references</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">data</span><span class="p">])</span>
		<span class="n">fragment_errors</span> <span class="o">=</span> <span class="p">[]</span>
		<span class="n">ref</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">check_biodiversity_table_exists</span><span class="p">()</span>
		<span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">fragments</span><span class="p">:</span>
			<span class="n">comparison_octaves</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">comparison_octaves</span> <span class="k">if</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">f</span><span class="p">]</span>
			<span class="k">for</span> <span class="n">reference</span> <span class="ow">in</span> <span class="n">references</span><span class="p">:</span>
				<span class="n">octaves</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_fragment_octaves</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">reference</span><span class="p">)</span>
				<span class="k">try</span><span class="p">:</span>
					<span class="n">maxval</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="nb">max</span><span class="p">([</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">octaves</span><span class="p">]),</span> <span class="nb">max</span><span class="p">([</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">comparison_octaves</span><span class="p">]))</span>
				<span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
					<span class="k">try</span><span class="p">:</span>
						<span class="n">maxval</span> <span class="o">=</span> <span class="nb">max</span><span class="p">([</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">comparison_octaves</span><span class="p">])</span>
					<span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
						<span class="k">try</span><span class="p">:</span>
							<span class="n">maxval</span> <span class="o">=</span> <span class="nb">max</span><span class="p">([</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">octaves</span><span class="p">])</span>
						<span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
							<span class="n">maxval</span> <span class="o">=</span> <span class="mi">0</span>
				<span class="n">difference</span> <span class="o">=</span> <span class="p">[]</span>
				<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">maxval</span><span class="p">,</span> <span class="mi">1</span><span class="p">):</span>
					<span class="k">try</span><span class="p">:</span>
						<span class="n">richness_val</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">octaves</span> <span class="k">if</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
					<span class="k">except</span> <span class="p">(</span><span class="ne">ValueError</span><span class="p">,</span> <span class="ne">IndexError</span><span class="p">):</span>
						<span class="n">difference</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mf">1.0</span><span class="p">)</span>
						<span class="k">continue</span>
					<span class="k">try</span><span class="p">:</span>
						<span class="n">comp_val</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">comparison_octaves</span> <span class="k">if</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
					<span class="k">except</span> <span class="p">(</span><span class="ne">ValueError</span><span class="p">,</span> <span class="ne">IndexError</span><span class="p">):</span>
						<span class="n">difference</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mf">1.0</span><span class="p">)</span>
						<span class="n">comp_val</span> <span class="o">=</span> <span class="mf">1.0</span>
					<span class="k">else</span><span class="p">:</span>
						<span class="c1">## The error is calculated</span>
						<span class="n">difference</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
							<span class="nb">float</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">richness_val</span><span class="p">,</span> <span class="n">comp_val</span><span class="p">)</span> <span class="o">-</span> <span class="nb">min</span><span class="p">(</span><span class="n">richness_val</span><span class="p">,</span> <span class="n">comp_val</span><span class="p">))</span> <span class="o">/</span> <span class="nb">max</span><span class="p">(</span><span class="n">comp_val</span><span class="p">,</span>
																								   <span class="n">richness_val</span><span class="p">))</span>
					<span class="k">if</span> <span class="n">col_add</span><span class="p">:</span>
						<span class="bp">self</span><span class="o">.</span><span class="n">cursor</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s2">&quot;UPDATE FRAGMENT_OCTAVES SET comparison = ?, error = ? WHERE ref == ?&quot;</span><span class="p">,</span>
											<span class="p">(</span><span class="n">comp_val</span><span class="p">,</span> <span class="n">difference</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">reference</span><span class="p">))</span>
				<span class="c1"># now average the errors</span>
				<span class="n">ref</span> <span class="o">+=</span> <span class="mi">1</span>
				<span class="n">fragment_errors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
					<span class="p">[</span><span class="n">ref</span><span class="p">,</span> <span class="s2">&quot;fragment_octaves&quot;</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">reference</span><span class="p">,</span> <span class="nb">float</span><span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="n">difference</span><span class="p">)</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">difference</span><span class="p">)))])</span>

		<span class="bp">self</span><span class="o">.</span><span class="n">cursor</span><span class="o">.</span><span class="n">executemany</span><span class="p">(</span><span class="s2">&quot;INSERT INTO BIODIVERSITY_METRICS VALUES(?,?,?,?,?, NULL, NULL)&quot;</span><span class="p">,</span> <span class="n">fragment_errors</span><span class="p">)</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">database</span><span class="o">.</span><span class="n">commit</span><span class="p">()</span></div>

<div class="viewcode-block" id="CoalescenceTree.calculate_goodness_of_fit"><a class="viewcode-back" href="../../pycoalescence.html#pycoalescence.coalescence_tree.CoalescenceTree.calculate_goodness_of_fit">[docs]</a>	<span class="k">def</span> <span class="nf">calculate_goodness_of_fit</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Calculates the goodness-of-fit measure based on the calculated biodiversity metrics, scaling each metric by the</span>
<span class="sd">		number of individuals involved in the metric.</span>

<span class="sd">		This requires that import_comparison_data() has already been successfully run.</span>

<span class="sd">		.. note::</span>

<span class="sd">			This doesn&#39;t calculate anything for values which have not yet been written to the</span>
<span class="sd">			BIODIVERSITY_METRICS table. All in-built functions (e.g. calculate_alpha_diversity,</span>
<span class="sd">			calculate_fragment_richness) write to the BIODIVERSITY_METRICS table automatically, so this is only relevant</span>
<span class="sd">			for custom functions.</span>

<span class="sd">		The resulting value will then be written to the BIODIVERSITY_METRICS table in the SQL database.</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="c1"># TODO fix this as it no longer works</span>
		<span class="c1">## check that the comparison data has already been imported.</span>
		<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">comparison_data</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
			<span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Comparison data not yet imported.&quot;</span><span class="p">)</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">_check_database</span><span class="p">()</span>
		<span class="k">if</span> <span class="ow">not</span> <span class="n">check_sql_table_exist</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">database</span><span class="p">,</span> <span class="s2">&quot;BIODIVERSITY_METRICS&quot;</span><span class="p">):</span>
			<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;BIODIVERSITY_METRICS table does not exist in database: cannot calculate goodness of fit.&quot;</span><span class="p">)</span>
		<span class="n">bio_metrics</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cursor</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span>
			<span class="s2">&quot;SELECT metric, fragment, community_reference, value FROM BIODIVERSITY_METRICS&quot;</span>
			<span class="s2">&quot; WHERE metric != &#39;goodness_of_fit&#39;&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">fetchall</span><span class="p">()</span>
		<span class="k">if</span> <span class="n">check_sql_table_exist</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">database</span><span class="p">,</span> <span class="s2">&quot;FRAGMENT_OCTAVES&quot;</span><span class="p">):</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">total_individuals</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cursor</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s2">&quot;SELECT COUNT(tip) FROM SPECIES_LIST&quot;</span>
														 <span class="s2">&quot; WHERE tip==1 AND gen_added==0.0&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">fetchone</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
			<span class="k">try</span><span class="p">:</span>
				<span class="bp">self</span><span class="o">.</span><span class="n">cursor</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s2">&quot;SELECT comparison, error from FRAGMENT_OCTAVES&quot;</span><span class="p">)</span>
			<span class="k">except</span> <span class="n">sqlite3</span><span class="o">.</span><span class="n">OperationalError</span><span class="p">:</span>
				<span class="bp">self</span><span class="o">.</span><span class="n">cursor</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s2">&quot;ALTER TABLE FRAGMENT_OCTAVES ADD COLUMN comparison FLOAT&quot;</span><span class="p">)</span>
				<span class="bp">self</span><span class="o">.</span><span class="n">cursor</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s2">&quot;ALTER TABLE FRAGMENT_OCTAVES ADD COLUMN error FLOAT&quot;</span><span class="p">)</span>
		<span class="c1"># Remove the extra goodness of fit values</span>
		<span class="c1"># TODO first print out biodiversity metrics in each database</span>
		<span class="n">bio_metrics</span> <span class="o">=</span> <span class="p">[</span><span class="n">b</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">bio_metrics</span> <span class="k">if</span> <span class="s1">&#39;goodness_of_fit&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
		<span class="n">references</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([</span><span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">bio_metrics</span><span class="p">])</span>
		<span class="n">categories</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([</span><span class="n">f</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">bio_metrics</span><span class="p">])</span>
		<span class="c1"># this will contain: metric, fragment, community_reference, relative_goodness_of_fit, num_individuals, simulated, actual</span>
		<span class="c1"># Get the plot data containing fragment names and total abundances [fragment, abundance]</span>
		<span class="n">plot_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_comparison_plot_data</span><span class="p">()</span>
		<span class="n">abundance_total</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">([</span><span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">plot_data</span><span class="p">])</span>
		<span class="c1"># Calculate the error values for each metric and reference</span>
		<span class="n">ref_bio</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">check_biodiversity_table_exists</span><span class="p">()</span>
		<span class="n">output_SQL</span> <span class="o">=</span> <span class="p">[]</span>
		<span class="k">for</span> <span class="n">category</span> <span class="ow">in</span> <span class="n">categories</span><span class="p">:</span>
			<span class="n">fragments</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([</span><span class="n">f</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">bio_metrics</span> <span class="k">if</span> <span class="n">f</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">category</span><span class="p">])</span>
			<span class="n">select_comparison</span> <span class="o">=</span> <span class="p">[</span><span class="n">f</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">comparison_data</span> <span class="k">if</span> <span class="n">f</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">category</span> <span class="k">if</span> <span class="n">f</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">in</span> <span class="n">fragments</span><span class="p">]</span>
			<span class="c1"># Calculate the total number of individuals in this category</span>
			<span class="k">if</span> <span class="n">category</span> <span class="o">!=</span> <span class="s2">&quot;fragment_octaves&quot;</span><span class="p">:</span>
				<span class="k">try</span><span class="p">:</span>
					<span class="n">total_ind</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">([</span><span class="n">f</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">select_comparison</span><span class="p">])</span>
				<span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>
					<span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;Could not find comparable metric for {} and {}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">each</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">each</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
					<span class="k">continue</span>
			<span class="k">else</span><span class="p">:</span>
				<span class="n">total_ind</span> <span class="o">=</span> <span class="n">abundance_total</span>
			<span class="c1"># Now calculate the biodiversity metrics for each fragment</span>
			<span class="n">ref_dict</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>

			<span class="k">for</span> <span class="n">fragment</span> <span class="ow">in</span> <span class="n">fragments</span><span class="p">:</span>
				<span class="c1"># TODO move this into a self-contained function (after unittesting)</span>
				<span class="k">if</span> <span class="n">category</span> <span class="o">!=</span> <span class="s2">&quot;fragment_octaves&quot;</span><span class="p">:</span>
					<span class="k">try</span><span class="p">:</span>
						<span class="n">fragment_comparison</span> <span class="o">=</span> <span class="p">[</span><span class="n">f</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">select_comparison</span> <span class="k">if</span> <span class="n">f</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">fragment</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
					<span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>
						<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Could not find comparable metric for&quot;</span>
										 <span class="s2">&quot; {}, in {}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">category</span><span class="p">,</span> <span class="n">fragment</span><span class="p">))</span>
					<span class="n">actual_val</span> <span class="o">=</span> <span class="n">fragment_comparison</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
					<span class="n">no_ind</span> <span class="o">=</span> <span class="n">fragment_comparison</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
				<span class="k">else</span><span class="p">:</span>
					<span class="n">actual_val</span> <span class="o">=</span> <span class="mf">0.0</span>
					<span class="n">no_ind</span> <span class="o">=</span> <span class="p">[</span><span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">plot_data</span> <span class="k">if</span> <span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">fragment</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
				<span class="k">for</span> <span class="n">ref</span> <span class="ow">in</span> <span class="n">references</span><span class="p">:</span>
					<span class="n">select_metrics</span> <span class="o">=</span> <span class="p">[</span><span class="n">b</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">bio_metrics</span> <span class="k">if</span> <span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">category</span> <span class="ow">and</span> <span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">fragment</span> <span class="ow">and</span> <span class="n">b</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="n">ref</span><span class="p">]</span>
					<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">select_metrics</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
						<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">select_metrics</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
							<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Could not find metric for metric, {}, fragment = {}&quot;</span>
											 <span class="s2">&quot; and community_reference = {}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">category</span><span class="p">,</span> <span class="n">fragment</span><span class="p">,</span> <span class="n">ref</span><span class="p">))</span>
						<span class="k">print</span><span class="p">(</span><span class="n">select_metrics</span><span class="p">)</span>
						<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Achieved multiple matches for biodiversity metrics&quot;</span>
										 <span class="s2">&quot; for fragment {} and community reference = {}.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">fragment</span><span class="p">,</span> <span class="n">ref</span><span class="p">))</span>
					<span class="k">if</span> <span class="n">category</span> <span class="o">!=</span> <span class="s2">&quot;fragment_octaves&quot;</span><span class="p">:</span>
						<span class="n">sim_val</span> <span class="o">=</span> <span class="n">select_metrics</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">3</span><span class="p">]</span>
						<span class="n">scaled_fit</span> <span class="o">=</span> <span class="n">scale_simulation_fit</span><span class="p">(</span><span class="n">sim_val</span><span class="p">,</span> <span class="n">actual_val</span><span class="p">,</span> <span class="n">no_ind</span><span class="p">,</span> <span class="n">total_ind</span><span class="p">)</span>
						<span class="bp">self</span><span class="o">.</span><span class="n">cursor</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s2">&quot;UPDATE BIODIVERSITY_METRICS SET simulated = ?, actual = ?, value=?&quot;</span>
											<span class="s2">&quot; WHERE metric == ? AND fragment == ? AND community_reference == ?&quot;</span><span class="p">,</span>
											<span class="p">(</span><span class="n">sim_val</span><span class="p">,</span> <span class="n">actual_val</span><span class="p">,</span> <span class="n">scaled_fit</span><span class="p">,</span> <span class="n">category</span><span class="p">,</span> <span class="n">fragment</span><span class="p">,</span> <span class="n">ref</span><span class="p">))</span>
					<span class="k">else</span><span class="p">:</span>
						<span class="n">scaled_fit</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">select_metrics</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">3</span><span class="p">])</span> <span class="o">*</span> <span class="nb">float</span><span class="p">(</span><span class="n">no_ind</span><span class="p">)</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="n">total_ind</span><span class="p">)</span>
					<span class="n">ref_dict</span><span class="p">[</span><span class="n">ref</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">scaled_fit</span><span class="p">)</span>
			<span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;goodness_of_fit_{}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">category</span><span class="p">)</span>
			<span class="k">for</span> <span class="n">ref</span> <span class="ow">in</span> <span class="n">ref_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
				<span class="n">value</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">ref_dict</span><span class="p">[</span><span class="n">ref</span><span class="p">])</span>
				<span class="n">ref_bio</span> <span class="o">+=</span> <span class="mi">1</span>
				<span class="n">output_SQL</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">ref_bio</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="s2">&quot;whole&quot;</span><span class="p">,</span> <span class="n">ref</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="bp">None</span><span class="p">,</span> <span class="bp">None</span><span class="p">])</span>
		<span class="c1"># Now generate out metrics for the whole system for each community reference</span>
		<span class="k">for</span> <span class="n">reference</span> <span class="ow">in</span> <span class="n">references</span><span class="p">:</span>
			<span class="n">value</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">([</span><span class="n">g</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="n">output_SQL</span> <span class="k">if</span> <span class="n">g</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">==</span> <span class="n">reference</span><span class="p">])</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">categories</span><span class="p">)</span>
			<span class="n">ref_bio</span> <span class="o">+=</span> <span class="mi">1</span>
			<span class="n">output_SQL</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">ref_bio</span><span class="p">,</span> <span class="s2">&quot;goodness_of_fit&quot;</span><span class="p">,</span> <span class="s2">&quot;whole&quot;</span><span class="p">,</span> <span class="n">reference</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="bp">None</span><span class="p">,</span> <span class="bp">None</span><span class="p">])</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">cursor</span><span class="o">.</span><span class="n">executemany</span><span class="p">(</span><span class="s2">&quot;INSERT INTO BIODIVERSITY_METRICS VALUES(?, ?, ?, ?, ?, ?, ?)&quot;</span><span class="p">,</span> <span class="n">output_SQL</span><span class="p">)</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">database</span><span class="o">.</span><span class="n">commit</span><span class="p">()</span></div>

<div class="viewcode-block" id="CoalescenceTree.get_species_list"><a class="viewcode-back" href="../../pycoalescence.html#pycoalescence.coalescence_tree.CoalescenceTree.get_species_list">[docs]</a>	<span class="k">def</span> <span class="nf">get_species_list</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Gets the entirety of the SPECIES_LIST table, returning a tuple with an entry for each row. This can be used to</span>
<span class="sd">		construct custom analyses of the coalescence tree.</span>

<span class="sd">		.. note:: The species list will be produced in an unprocessed format</span>

<span class="sd">		:return: a list of each coalescence and speciation event, with locations, performed in the simulation</span>

<span class="sd">		:rtype: tuple</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">_check_database</span><span class="p">()</span>
		<span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">cursor</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s2">&quot;SELECT * FROM SPECIES_LIST&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">fetchall</span><span class="p">()</span></div>

<div class="viewcode-block" id="CoalescenceTree.get_species_locations"><a class="viewcode-back" href="../../pycoalescence.html#pycoalescence.coalescence_tree.CoalescenceTree.get_species_locations">[docs]</a>	<span class="k">def</span> <span class="nf">get_species_locations</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">community_reference</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Gets the list of species locations after coalescence.</span>

<span class="sd">		If a community reference is provided, will return just the species for that community reference, otherwise</span>
<span class="sd">		returns the whole table</span>

<span class="sd">		:param int community_reference: community reference number</span>
<span class="sd">		:return: a list of lists containing each row of the SPECIES_LOCATIONS table</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">_check_database</span><span class="p">()</span>
		<span class="k">if</span> <span class="n">community_reference</span><span class="p">:</span>
			<span class="k">return</span> <span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cursor</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s2">&quot;SELECT species_id, x, y&quot;</span>
														 <span class="s2">&quot; FROM SPECIES_LOCATIONS WHERE community_reference==?&quot;</span><span class="p">,</span>
														 <span class="p">(</span><span class="n">community_reference</span><span class="p">,))]</span>
		<span class="k">return</span> <span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cursor</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s2">&quot;SELECT species_id, x, y, community_reference&quot;</span>
													 <span class="s2">&quot; FROM SPECIES_LOCATIONS&quot;</span><span class="p">)]</span></div>

<div class="viewcode-block" id="CoalescenceTree.get_goodness_of_fit"><a class="viewcode-back" href="../../pycoalescence.html#pycoalescence.coalescence_tree.CoalescenceTree.get_goodness_of_fit">[docs]</a>	<span class="k">def</span> <span class="nf">get_goodness_of_fit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">reference</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Returns the goodness of fit from the file.</span>

<span class="sd">		:param reference: the community reference to get from</span>
<span class="sd">		:return: the full output from the SQL query</span>

<span class="sd">		:rtype: list</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">_check_database</span><span class="p">()</span>
		<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">check_biodiversity_table_exists</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
			<span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Biodiversity table does not contain any values.&quot;</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cursor</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span>
			<span class="s2">&quot;SELECT value FROM BIODIVERSITY_METRICS WHERE fragment==&#39;whole&#39; AND metric==&#39;goodness_of_fit&#39; AND &quot;</span>
			<span class="s2">&quot;community_reference == ?&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">reference</span><span class="p">,))</span><span class="o">.</span><span class="n">fetchall</span><span class="p">()</span>
		<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="ow">is</span> <span class="mi">0</span><span class="p">:</span>
			<span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Biodiversity table does not contain goodness-of-fit values.&quot;</span><span class="p">)</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="k">return</span> <span class="n">ret</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span></div>

<div class="viewcode-block" id="CoalescenceTree.get_goodness_of_fit_metric"><a class="viewcode-back" href="../../pycoalescence.html#pycoalescence.coalescence_tree.CoalescenceTree.get_goodness_of_fit_metric">[docs]</a>	<span class="k">def</span> <span class="nf">get_goodness_of_fit_metric</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">metric</span><span class="p">,</span> <span class="n">reference</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Gets the goodness-of-fit measure for the specified metric and community reference.</span>

<span class="sd">		:param metric: the metric goodness of fit has been calculated for to obtain</span>
<span class="sd">		:param reference: the community reference to fetch fits for</span>
<span class="sd">		:return: the goodness of fit value</span>
<span class="sd">		:rtype: float</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">_check_database</span><span class="p">()</span>
		<span class="k">if</span> <span class="ow">not</span> <span class="n">check_sql_table_exist</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">database</span><span class="p">,</span> <span class="s2">&quot;BIODIVERSITY_METRICS&quot;</span><span class="p">):</span>
			<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Biodiversity table does not contain any values.&quot;</span><span class="p">)</span>
		<span class="n">metric_sql</span> <span class="o">=</span> <span class="s2">&quot;goodness_of_fit_{}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">metric</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cursor</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s2">&quot;SELECT value FROM BIODIVERSITY_METRICS WHERE fragment==&#39;whole&#39; AND metric==? and &quot;</span>
								  <span class="s2">&quot;community_reference == ?&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">metric_sql</span><span class="p">,</span> <span class="n">reference</span><span class="p">,))</span><span class="o">.</span><span class="n">fetchone</span><span class="p">()</span>
		<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
			<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;No goodness-of-fit for {} with&quot;</span>
							 <span class="s2">&quot; community reference = {}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">metric</span><span class="p">,</span> <span class="n">reference</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span></div>

<div class="viewcode-block" id="CoalescenceTree.get_goodness_of_fit_fragment_richness"><a class="viewcode-back" href="../../pycoalescence.html#pycoalescence.coalescence_tree.CoalescenceTree.get_goodness_of_fit_fragment_richness">[docs]</a>	<span class="k">def</span> <span class="nf">get_goodness_of_fit_fragment_richness</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">reference</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Returns the goodness of fit for fragment richness from the file.</span>

<span class="sd">		:raises ValueError: if BIODIVERSITY_METRICS table does not exist.</span>

<span class="sd">		:param reference: the community reference number</span>
<span class="sd">		:return: the full output from the SQL query</span>

<span class="sd">		:rtype: float</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_goodness_of_fit_metric</span><span class="p">(</span><span class="s2">&quot;fragment_richness&quot;</span><span class="p">,</span> <span class="n">reference</span><span class="o">=</span><span class="n">reference</span><span class="p">)</span></div>

<div class="viewcode-block" id="CoalescenceTree.get_goodness_of_fit_fragment_octaves"><a class="viewcode-back" href="../../pycoalescence.html#pycoalescence.coalescence_tree.CoalescenceTree.get_goodness_of_fit_fragment_octaves">[docs]</a>	<span class="k">def</span> <span class="nf">get_goodness_of_fit_fragment_octaves</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">reference</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Returns the goodness of fit for fragment octaves from the file.</span>

<span class="sd">		:raises ValueError: if BIODIVERSITY_METRICS table does not exist.</span>

<span class="sd">		:param reference: the community reference number</span>
<span class="sd">		:return: the full output from the SQL query</span>

<span class="sd">		:rtype: list</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="c1"># TODO This needs to be fixed</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">_check_database</span><span class="p">()</span>
		<span class="k">if</span> <span class="ow">not</span> <span class="n">check_sql_table_exist</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">database</span><span class="p">,</span> <span class="s2">&quot;BIODIVERSITY_METRICS&quot;</span><span class="p">):</span>
			<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Biodiversity table does not contain any values.&quot;</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cursor</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s2">&quot;SELECT value FROM BIODIVERSITY_METRICS WHERE fragment==&#39;whole&#39; AND &quot;</span>
								  <span class="s2">&quot;metric==&#39;goodness_of_fit_fragment_octaves&#39; and &quot;</span>
								  <span class="s2">&quot;community_reference == ?&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">reference</span><span class="p">,))</span><span class="o">.</span><span class="n">fetchone</span><span class="p">()</span>
		<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
			<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;No goodness-of-fit for fragment octaves with&quot;</span>
							 <span class="s2">&quot; community reference = {}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">reference</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span></div>

<div class="viewcode-block" id="CoalescenceTree.dispersal_parameters"><a class="viewcode-back" href="../../pycoalescence.html#pycoalescence.coalescence_tree.CoalescenceTree.dispersal_parameters">[docs]</a>	<span class="k">def</span> <span class="nf">dispersal_parameters</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Reads the dispersal parameters from the database and returns them.</span>

<span class="sd">		:return: a list of the dispersal parameters [sigma, tau, m_probability, cutoff]</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_simulation_parameters</span><span class="p">()</span>
		<span class="k">return</span> <span class="p">[</span><span class="n">ret</span><span class="p">[</span><span class="s2">&quot;sigma&quot;</span><span class="p">],</span> <span class="n">ret</span><span class="p">[</span><span class="s2">&quot;tau&quot;</span><span class="p">],</span> <span class="n">ret</span><span class="p">[</span><span class="s2">&quot;m_probability&quot;</span><span class="p">],</span> <span class="n">ret</span><span class="p">[</span><span class="s2">&quot;cutoff&quot;</span><span class="p">]]</span></div>

<div class="viewcode-block" id="CoalescenceTree.get_job"><a class="viewcode-back" href="../../pycoalescence.html#pycoalescence.coalescence_tree.CoalescenceTree.get_job">[docs]</a>	<span class="k">def</span> <span class="nf">get_job</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Gets the job number (the seed) and the job type (the task identifier).</span>

<span class="sd">		:return: list containing [seed, job_type (the task identifier)]</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_simulation_parameters</span><span class="p">()</span>
		<span class="k">return</span> <span class="p">[</span><span class="n">ret</span><span class="p">[</span><span class="s2">&quot;seed&quot;</span><span class="p">],</span> <span class="n">ret</span><span class="p">[</span><span class="s2">&quot;job_type&quot;</span><span class="p">]]</span></div>

<div class="viewcode-block" id="CoalescenceTree.get_simulation_parameters"><a class="viewcode-back" href="../../pycoalescence.html#pycoalescence.coalescence_tree.CoalescenceTree.get_simulation_parameters">[docs]</a>	<span class="k">def</span> <span class="nf">get_simulation_parameters</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">guild</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Reads the simulation parameters from the database and returns them.</span>

<span class="sd">		:return: a dictionary mapping names to values for seed, job_type, output_dir, speciation_rate, sigma, L_value, deme,</span>
<span class="sd">		sample_size, maxtime, dispersal_relative_cost, min_spec, habitat_change_rate, gen_since_historical, time_config,</span>
<span class="sd">		coarse_map vars, fine map vars, sample_file, gridx, gridy, historical coarse map, historical fine map, sim_complete,</span>
<span class="sd">		dispersal_method, m_probability, cutoff, landscape_type, protracted, min_speciation_gen, max_speciation_gen,</span>
<span class="sd">		dispersal_map</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">_check_database</span><span class="p">()</span>
		<span class="k">if</span> <span class="ow">not</span> <span class="n">guild</span><span class="p">:</span>
			<span class="k">try</span><span class="p">:</span>
				<span class="bp">self</span><span class="o">.</span><span class="n">cursor</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span>
					<span class="s2">&quot;SELECT seed, job_type, output_dir, speciation_rate, sigma, tau, deme, sample_size, &quot;</span>
					<span class="s2">&quot;max_time, dispersal_relative_cost, min_num_species, habitat_change_rate, gen_since_historical, &quot;</span>
					<span class="s2">&quot;time_config_file, coarse_map_file, coarse_map_x, coarse_map_y, coarse_map_x_offset, &quot;</span>
					<span class="s2">&quot;coarse_map_y_offset, coarse_map_scale, fine_map_file, fine_map_x, fine_map_y, &quot;</span>
					<span class="s2">&quot;fine_map_x_offset, fine_map_y_offset, sample_file, grid_x, grid_y, sample_x, sample_y, &quot;</span>
					<span class="s2">&quot;sample_x_offset, sample_y_offset, historical_coarse_map, &quot;</span>
					<span class="s2">&quot; historical_fine_map, sim_complete, dispersal_method, m_probability, cutoff,&quot;</span>
					<span class="s2">&quot; landscape_type,  protracted, min_speciation_gen, max_speciation_gen, dispersal_map&quot;</span>
					<span class="s2">&quot; FROM SIMULATION_PARAMETERS&quot;</span><span class="p">)</span>
			<span class="k">except</span> <span class="n">sqlite3</span><span class="o">.</span><span class="n">OperationalError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
				<span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s2">&quot;Failure to get SIMULATION_PARAMETERS table from database. Check table exists.&quot;</span><span class="p">)</span>
				<span class="k">raise</span> <span class="n">e</span>
			<span class="n">column_names</span> <span class="o">=</span> <span class="p">[</span><span class="n">member</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">member</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cursor</span><span class="o">.</span><span class="n">description</span><span class="p">]</span>
			<span class="n">values</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cursor</span><span class="o">.</span><span class="n">fetchone</span><span class="p">()]</span>
			<span class="k">if</span> <span class="n">sys</span><span class="o">.</span><span class="n">version_info</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="mi">3</span><span class="p">:</span>
				<span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">each</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">values</span><span class="p">):</span>
					<span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">each</span><span class="p">,</span> <span class="nb">unicode</span><span class="p">):</span>
						<span class="n">values</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">each</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s1">&#39;ascii&#39;</span><span class="p">)</span>
			<span class="c1"># Now convert it into a dictionary</span>
			<span class="k">return</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">column_names</span><span class="p">,</span> <span class="n">values</span><span class="p">))</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_sim_parameters_guild</span><span class="p">(</span><span class="n">guild</span><span class="o">=</span><span class="n">guild</span><span class="p">)</span></div>

<div class="viewcode-block" id="CoalescenceTree.get_community_references"><a class="viewcode-back" href="../../pycoalescence.html#pycoalescence.coalescence_tree.CoalescenceTree.get_community_references">[docs]</a>	<span class="k">def</span> <span class="nf">get_community_references</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Gets a list of all the commuity references already calculated for the simulation.</span>

<span class="sd">		:return: list of all calculated community references</span>

<span class="sd">		:rtype: list</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">_check_database</span><span class="p">()</span>
		<span class="k">try</span><span class="p">:</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">cursor</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s2">&quot;SELECT reference FROM COMMUNITY_PARAMETERS&quot;</span><span class="p">)</span>
		<span class="k">except</span> <span class="n">sqlite3</span><span class="o">.</span><span class="n">OperationalError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s2">&quot;Failure to fetch references from COMMUNITY_PARAMETERS table in database.&quot;</span>
							  <span class="s2">&quot; Check table exists.&quot;</span><span class="p">)</span>
			<span class="k">raise</span> <span class="n">e</span>
		<span class="n">references</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cursor</span><span class="o">.</span><span class="n">fetchall</span><span class="p">()]</span>
		<span class="k">return</span> <span class="n">references</span></div>

<div class="viewcode-block" id="CoalescenceTree.get_community_parameters"><a class="viewcode-back" href="../../pycoalescence.html#pycoalescence.coalescence_tree.CoalescenceTree.get_community_parameters">[docs]</a>	<span class="k">def</span> <span class="nf">get_community_parameters</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">reference</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Returns a dictionary containing the parameters for the calculated community.</span>

<span class="sd">		:param reference: the reference key for the calculated parameters (default is 1)</span>

<span class="sd">		:return: dictionary containing the speciation_rate, time, fragments, metacommunity_reference and min/max</span>
<span class="sd">		         speciation generation for protracted sims</span>

<span class="sd">		:rtype: dict</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">_check_database</span><span class="p">()</span>
		<span class="k">try</span><span class="p">:</span>
			<span class="k">try</span><span class="p">:</span>
				<span class="bp">self</span><span class="o">.</span><span class="n">cursor</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s2">&quot;SELECT speciation_rate, time, fragments, metacommunity_reference, &quot;</span>
									<span class="s2">&quot;min_speciation_gen, max_speciation_gen &quot;</span>
									<span class="s2">&quot;FROM COMMUNITY_PARAMETERS WHERE reference==?&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">reference</span><span class="p">,))</span>
			<span class="k">except</span> <span class="n">sqlite3</span><span class="o">.</span><span class="n">OperationalError</span><span class="p">:</span>
				<span class="bp">self</span><span class="o">.</span><span class="n">cursor</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s2">&quot;SELECT speciation_rate, time, fragments, metacommunity_reference &quot;</span>
									<span class="s2">&quot;FROM COMMUNITY_PARAMETERS WHERE reference==?&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">reference</span><span class="p">,))</span>
		<span class="k">except</span> <span class="n">sqlite3</span><span class="o">.</span><span class="n">OperationalError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s2">&quot;Failure to fetch COMMUNITY_PARAMETERS table from database. Check table exists.&quot;</span><span class="p">)</span>
			<span class="k">raise</span> <span class="n">e</span>
		<span class="n">fetch</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cursor</span><span class="o">.</span><span class="n">fetchone</span><span class="p">()</span>
		<span class="k">if</span> <span class="n">fetch</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
			<span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="s2">&quot;No community parameters found for reference of {}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">reference</span><span class="p">))</span>
		<span class="n">values</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">fetch</span><span class="p">]</span>
		<span class="n">column_names</span> <span class="o">=</span> <span class="p">[</span><span class="n">member</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">member</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cursor</span><span class="o">.</span><span class="n">description</span><span class="p">]</span>
		<span class="k">if</span> <span class="n">sys</span><span class="o">.</span><span class="n">version_info</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="mi">3</span><span class="p">:</span>
			<span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">each</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">values</span><span class="p">):</span>
				<span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">each</span><span class="p">,</span> <span class="nb">unicode</span><span class="p">):</span>
					<span class="n">values</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">each</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s1">&#39;ascii&#39;</span><span class="p">)</span>
		<span class="c1"># Now convert it into a dictionary</span>
		<span class="k">return</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">column_names</span><span class="p">,</span> <span class="n">values</span><span class="p">))</span></div>

<div class="viewcode-block" id="CoalescenceTree.get_community_reference"><a class="viewcode-back" href="../../pycoalescence.html#pycoalescence.coalescence_tree.CoalescenceTree.get_community_reference">[docs]</a>	<span class="k">def</span> <span class="nf">get_community_reference</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">speciation_rate</span><span class="p">,</span> <span class="n">time</span><span class="p">,</span> <span class="n">fragments</span><span class="p">,</span> <span class="n">metacommunity_size</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
								<span class="n">metacommunity_speciation_rate</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">metacommunity_option</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">external_reference</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
								<span class="n">min_speciation_gen</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">max_speciation_gen</span><span class="o">=</span><span class="mf">0.0</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Gets the community reference associated with the supplied community parameters</span>

<span class="sd">		:raises KeyError: if COMMUNITY_PARAMETERS (or METACOMMUNITY_PARAMETERS) does not exist in database or no</span>
<span class="sd">			reference exists for the supplied parameters</span>

<span class="sd">		:param float speciation_rate: the speciation rate of the community</span>
<span class="sd">		:param float time: the time in generations of the community</span>
<span class="sd">		:param bool/int fragments: whether fragments were determined for the community</span>
<span class="sd">		:param int/float metacommunity_size: the metacommunity size</span>
<span class="sd">		:param float metacommunity_speciation_rate: the metacommunity speciation rate</span>
<span class="sd">		:param str metacommunity_option: option used for metacommunity creation</span>
<span class="sd">		:param int external_reference: the metacommunity reference for external metacommunity databases</span>
<span class="sd">		:param float min_speciation_gen: the minimum number of generations required before speciation</span>
<span class="sd">		:param float max_speciation_gen: the maximum number of generations required before speciation</span>
<span class="sd">		:return: the reference associated with this set of simulation parameters</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="k">if</span> <span class="n">fragments</span> <span class="ow">is</span> <span class="bp">False</span><span class="p">:</span>
			<span class="n">fragments</span> <span class="o">=</span> <span class="mi">0</span>
		<span class="k">elif</span> <span class="n">fragments</span> <span class="ow">is</span> <span class="bp">True</span><span class="p">:</span>
			<span class="n">fragments</span> <span class="o">=</span> <span class="mi">1</span>
		<span class="k">if</span> <span class="n">metacommunity_size</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">external_reference</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
			<span class="n">metacommunity_reference</span> <span class="o">=</span> <span class="mi">0</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">_check_database</span><span class="p">()</span>
			<span class="k">if</span> <span class="ow">not</span> <span class="n">check_sql_table_exist</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">database</span><span class="p">,</span> <span class="s2">&quot;METACOMMUNITY_PARAMETERS&quot;</span><span class="p">):</span>
				<span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="s2">&quot;No table METACOMMUNITY_PARAMETERS exists in database {}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">file</span><span class="p">))</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">cursor</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s2">&quot;SELECT reference FROM METACOMMUNITY_PARAMETERS WHERE metacommunity_size == ? AND &quot;</span>
								<span class="s2">&quot;speciation_rate == ? AND option == ? and external_reference == ?&quot;</span><span class="p">,</span>
								<span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">metacommunity_size</span><span class="p">),</span> <span class="n">metacommunity_speciation_rate</span><span class="p">,</span> <span class="n">metacommunity_option</span><span class="p">,</span>
								 <span class="n">external_reference</span><span class="p">))</span>
			<span class="k">try</span><span class="p">:</span>
				<span class="n">metacommunity_reference</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cursor</span><span class="o">.</span><span class="n">fetchone</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
			<span class="k">except</span> <span class="p">(</span><span class="ne">IndexError</span><span class="p">,</span> <span class="ne">TypeError</span><span class="p">):</span>
				<span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="s2">&quot;Cannot obtain metacommunity reference from database with provided parameters.&quot;</span><span class="p">)</span>
		<span class="k">try</span><span class="p">:</span>
			<span class="k">if</span> <span class="n">check_sql_table_exist</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">database</span><span class="p">,</span> <span class="s2">&quot;COMMUNITY_PARAMETERS&quot;</span><span class="p">):</span>
				<span class="k">try</span><span class="p">:</span>
					<span class="bp">self</span><span class="o">.</span><span class="n">cursor</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s2">&quot;SELECT reference FROM COMMUNITY_PARAMETERS WHERE speciation_rate == ? AND &quot;</span>
										<span class="s2">&quot;time == ? AND fragments == ? AND metacommunity_reference == ? AND &quot;</span>
										<span class="s2">&quot;min_speciation_gen == ? AND max_speciation_gen == ?&quot;</span><span class="p">,</span>
										<span class="p">(</span><span class="n">speciation_rate</span><span class="p">,</span> <span class="n">time</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">fragments</span><span class="p">),</span> <span class="n">metacommunity_reference</span><span class="p">,</span>
										 <span class="n">min_speciation_gen</span><span class="p">,</span>
										 <span class="n">max_speciation_gen</span><span class="p">))</span>
				<span class="k">except</span> <span class="n">sqlite3</span><span class="o">.</span><span class="n">OperationalError</span><span class="p">:</span>
					<span class="k">if</span> <span class="n">min_speciation_gen</span> <span class="o">!=</span> <span class="mf">0.0</span> <span class="ow">or</span> <span class="n">max_speciation_gen</span> <span class="o">!=</span> <span class="mf">0.0</span><span class="p">:</span>
						<span class="k">raise</span> <span class="ne">IndexError</span>
					<span class="bp">self</span><span class="o">.</span><span class="n">cursor</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s2">&quot;SELECT reference FROM COMMUNITY_PARAMETERS WHERE speciation_rate == ? AND &quot;</span>
										<span class="s2">&quot;time == ? AND fragments == ? AND metacommunity_reference == ?&quot;</span><span class="p">,</span>
										<span class="p">(</span><span class="n">speciation_rate</span><span class="p">,</span> <span class="n">time</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">fragments</span><span class="p">),</span> <span class="n">metacommunity_reference</span><span class="p">))</span>
				<span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">cursor</span><span class="o">.</span><span class="n">fetchone</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
		<span class="k">except</span> <span class="p">(</span><span class="ne">IndexError</span><span class="p">,</span> <span class="ne">TypeError</span><span class="p">):</span>
			<span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="s2">&quot;Cannot obtain community reference from database with provided parameters.&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="CoalescenceTree.get_metacommunity_references"><a class="viewcode-back" href="../../pycoalescence.html#pycoalescence.coalescence_tree.CoalescenceTree.get_metacommunity_references">[docs]</a>	<span class="k">def</span> <span class="nf">get_metacommunity_references</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Gets a list of all the metacommuity references already calculated for the simulation.</span>

<span class="sd">		.. note:: Returns an empty list and logs an error message if the METACOMMUNITY_PARAMETERS table does not exist.</span>

<span class="sd">		:return: list of all calculated metacommunity references</span>

<span class="sd">		:rtype: list</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">_check_database</span><span class="p">()</span>
		<span class="k">if</span> <span class="ow">not</span> <span class="n">check_sql_table_exist</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">database</span><span class="p">,</span> <span class="s2">&quot;METACOMMUNITY_PARAMETERS&quot;</span><span class="p">):</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s2">&quot;No table METACOMMUNITY_PARAMETERS exists in database {}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">file</span><span class="p">))</span>
			<span class="k">return</span> <span class="p">[]</span>
		<span class="k">try</span><span class="p">:</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">cursor</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s2">&quot;SELECT reference FROM METACOMMUNITY_PARAMETERS&quot;</span><span class="p">)</span>
		<span class="k">except</span> <span class="n">sqlite3</span><span class="o">.</span><span class="n">OperationalError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s2">&quot;Failure to fetch references from METACOMMUNITY_PARAMETERS table in database.&quot;</span>
							  <span class="s2">&quot; Check table exists.&quot;</span><span class="p">)</span>
			<span class="k">raise</span> <span class="n">e</span>
		<span class="n">references</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cursor</span><span class="o">.</span><span class="n">fetchall</span><span class="p">()]</span>
		<span class="k">return</span> <span class="n">references</span></div>

<div class="viewcode-block" id="CoalescenceTree.get_metacommunity_parameters"><a class="viewcode-back" href="../../pycoalescence.html#pycoalescence.coalescence_tree.CoalescenceTree.get_metacommunity_parameters">[docs]</a>	<span class="k">def</span> <span class="nf">get_metacommunity_parameters</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">reference</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Returns a dictionary containing the parameters for the calculated community.</span>

<span class="sd">		:param reference: the reference key for the calculated parameters. (default is 1)</span>

<span class="sd">		:raises sqlite3.OperationalError: if the METACOMMUNITY_PARAMETERS table does not exist, or some other sqlite</span>
<span class="sd">			error occurs</span>

<span class="sd">		:raises KeyError: if the supplied reference does not exist in the METACOMMUNITY_PARAMETERS table</span>

<span class="sd">		:return: dictionary containing the speciation_rate, metacommunity_size, metacommunity option and metacommunity</span>
<span class="sd">				 reference.</span>
<span class="sd">		:rtype: dict</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">_check_database</span><span class="p">()</span>
		<span class="k">try</span><span class="p">:</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">cursor</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s2">&quot;SELECT speciation_rate, metacommunity_size, option, external_reference FROM&quot;</span>
								<span class="s2">&quot; METACOMMUNITY_PARAMETERS  WHERE reference== ?&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">reference</span><span class="p">,))</span>
		<span class="k">except</span> <span class="n">sqlite3</span><span class="o">.</span><span class="n">OperationalError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s2">&quot;Failure to fetch METACOMMUNITY_PARAMETERS table from database. Check table exists. </span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
			<span class="k">raise</span> <span class="n">e</span>
		<span class="n">fetch</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cursor</span><span class="o">.</span><span class="n">fetchone</span><span class="p">()</span>
		<span class="k">if</span> <span class="n">fetch</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
			<span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="s2">&quot;No metacommunity parameters found for reference of {}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">reference</span><span class="p">))</span>
		<span class="n">values</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">fetch</span><span class="p">]</span>
		<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
			<span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="s2">&quot;No metacommunity parameters found for reference of {}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">reference</span><span class="p">))</span>
		<span class="n">column_names</span> <span class="o">=</span> <span class="p">[</span><span class="n">member</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">member</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cursor</span><span class="o">.</span><span class="n">description</span><span class="p">]</span>
		<span class="k">if</span> <span class="n">sys</span><span class="o">.</span><span class="n">version_info</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="mi">3</span><span class="p">:</span>
			<span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">each</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">values</span><span class="p">):</span>
				<span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">each</span><span class="p">,</span> <span class="nb">unicode</span><span class="p">):</span>
					<span class="n">values</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">each</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s1">&#39;ascii&#39;</span><span class="p">)</span>
		<span class="c1"># Now convert it into a dictionary</span>
		<span class="k">return</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">column_names</span><span class="p">,</span> <span class="n">values</span><span class="p">))</span></div>

<div class="viewcode-block" id="CoalescenceTree.get_parameter_description"><a class="viewcode-back" href="../../pycoalescence.html#pycoalescence.coalescence_tree.CoalescenceTree.get_parameter_description">[docs]</a>	<span class="k">def</span> <span class="nf">get_parameter_description</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Gets the description of the parameter matching the key from those contained in SIMULATION_PARAMETERS</span>

<span class="sd">		Simply accesses the _parameter_descriptions data stored in parameter_descriptions.json</span>

<span class="sd">		:return: string containing the parameter description or a dict containing all values if no key is supplied</span>

<span class="sd">		:rtype: str</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="k">return</span> <span class="n">get_parameter_description</span><span class="p">(</span><span class="n">key</span><span class="p">)</span></div>

<div class="viewcode-block" id="CoalescenceTree.is_completed"><a class="viewcode-back" href="../../pycoalescence.html#pycoalescence.coalescence_tree.CoalescenceTree.is_completed">[docs]</a>	<span class="k">def</span> <span class="nf">is_completed</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Indicates whether the simulation has been performed to completion, or if the simulation has been paused and</span>
<span class="sd">		needs to be completed before analysis can be performed.</span>

<span class="sd">		:return: bool: true if simulation is complete</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_complete</span></div>

<div class="viewcode-block" id="CoalescenceTree.is_protracted"><a class="viewcode-back" href="../../pycoalescence.html#pycoalescence.coalescence_tree.CoalescenceTree.is_protracted">[docs]</a>	<span class="k">def</span> <span class="nf">is_protracted</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Indicates whether the simulation is a protracted simulation or not. This is read from the completed database file.</span>

<span class="sd">		:return: boolean, true if the simulation was performed with protracted speciation.</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="k">return</span> <span class="nb">bool</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_simulation_parameters</span><span class="p">()</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;protracted&quot;</span><span class="p">,</span> <span class="bp">False</span><span class="p">))</span></div>

<div class="viewcode-block" id="CoalescenceTree.clear_calculations"><a class="viewcode-back" href="../../pycoalescence.html#pycoalescence.coalescence_tree.CoalescenceTree.clear_calculations">[docs]</a>	<span class="k">def</span> <span class="nf">clear_calculations</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Removes the BIODIVERSITY_METRICS and FRAGMENT_OCTAVES tables completely.</span>

<span class="sd">		.. note:: that this cannot be undone (other than re-running the calculations).</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">_check_database</span><span class="p">()</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">cursor</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s1">&#39;DROP TABLE IF EXISTS BIODIVERSITY_METRICS&#39;</span><span class="p">)</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">cursor</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s1">&#39;DROP TABLE IF EXISTS FRAGMENT_OCTAVES&#39;</span><span class="p">)</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">cursor</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s1">&#39;DROP TABLE IF EXISTS FRAGMENT_RICHNESS&#39;</span><span class="p">)</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">cursor</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s1">&#39;DROP TABLE IF EXISTS PLOT_DATA&#39;</span><span class="p">)</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">cursor</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s1">&#39;DROP TABLE IF EXISTS SPECIES_RICHNESS&#39;</span><span class="p">)</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">cursor</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s2">&quot;DROP TABLE IF EXISTS ALPHA_DIVERSITY&quot;</span><span class="p">)</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">cursor</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s2">&quot;DROP TABLE IF EXISTS BETA_DIVERSITY&quot;</span><span class="p">)</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">cursor</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s2">&quot;DROP TABLE IF EXISTS SPECIES_DISTANCE_SIMILARITY&quot;</span><span class="p">)</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">database</span><span class="o">.</span><span class="n">commit</span><span class="p">()</span>
		<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">c_community</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">c_community</span><span class="o">.</span><span class="n">reset</span><span class="p">()</span></div>

<div class="viewcode-block" id="CoalescenceTree.wipe_data"><a class="viewcode-back" href="../../pycoalescence.html#pycoalescence.coalescence_tree.CoalescenceTree.wipe_data">[docs]</a>	<span class="k">def</span> <span class="nf">wipe_data</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Wipes all calculated data apart from the original, unformatted coalescence tree.</span>
<span class="sd">		The Speciation_Counter program will have to be re-run to perform any analyses.</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">_check_database</span><span class="p">()</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">cursor</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s2">&quot;DROP TABLE IF EXISTS FRAGMENT_ABUNDANCES&quot;</span><span class="p">)</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">cursor</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s2">&quot;DROP TABLE IF EXISTS SPECIES_ABUNDANCES&quot;</span><span class="p">)</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">cursor</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s2">&quot;DROP TABLE IF EXISTS COMMUNITY_PARAMETERS&quot;</span><span class="p">)</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">cursor</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s2">&quot;DROP TABLE IF EXISTS METACOMMUNITY_PARAMETERS&quot;</span><span class="p">)</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">cursor</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s2">&quot;DROP TABLE IF EXISTS SPECIES_LOCATIONS&quot;</span><span class="p">)</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">clear_calculations</span><span class="p">()</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">database</span><span class="o">.</span><span class="n">commit</span><span class="p">()</span>
		<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">c_community</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">c_community</span><span class="o">.</span><span class="n">reset</span><span class="p">()</span></div>

<div class="viewcode-block" id="CoalescenceTree.sample_fragment_richness"><a class="viewcode-back" href="../../pycoalescence.html#pycoalescence.coalescence_tree.CoalescenceTree.sample_fragment_richness">[docs]</a>	<span class="k">def</span> <span class="nf">sample_fragment_richness</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fragment</span><span class="p">,</span> <span class="n">number_of_individuals</span><span class="p">,</span> <span class="n">community_reference</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Samples from the database from FRAGMENT_ABUNDANCES, the desired number of individuals.</span>

<span class="sd">		Randomly selects the desired number of individuals from the database n times and returns the mean richness for</span>
<span class="sd">		the random samples.</span>

<span class="sd">		:raises IOError: if the FRAGMENT_ABUNDANCES table does not exist in the database.</span>

<span class="sd">		:param fragment: the reference of the fragment to aquire the richness for</span>
<span class="sd">		:param number_of_individuals: the number of individuals to sample</span>
<span class="sd">		:param community_reference: the reference for the community parameters</span>
<span class="sd">		:param n: number of times to repeatedly sample</span>

<span class="sd">		:return: the mean of the richness from the repeats</span>
<span class="sd">		:rtype: float</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">fragment_abundances</span><span class="p">:</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">calculate_fragment_abundances</span><span class="p">()</span>
		<span class="k">try</span><span class="p">:</span>
			<span class="n">chosen</span><span class="p">,</span> <span class="n">richness</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="p">[[</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">]]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">fragment_abundances</span> <span class="k">if</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">fragment</span> <span class="ow">and</span>
									 <span class="n">x</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">==</span> <span class="n">community_reference</span><span class="p">])</span>
		<span class="k">except</span> <span class="ne">ValueError</span> <span class="k">as</span> <span class="n">ve</span><span class="p">:</span>
			<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Fragment abundances do not contain data&quot;</span>
							 <span class="s2">&quot; for {} with reference={}: {}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">fragment</span><span class="p">,</span>
																	<span class="n">number_of_individuals</span><span class="p">,</span>
																	<span class="n">ve</span><span class="p">))</span>
		<span class="n">species_ids</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">chosen</span><span class="p">,</span> <span class="n">richness</span><span class="p">)</span>
		<span class="n">richness_out</span> <span class="o">=</span> <span class="p">[]</span>
		<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
			<span class="c1"># Randomly select number_of_individuals</span>
			<span class="n">richness_out</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">species_ids</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="n">number_of_individuals</span><span class="p">,</span> <span class="n">replace</span><span class="o">=</span><span class="bp">False</span><span class="p">))))</span>
		<span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">richness_out</span><span class="p">)</span></div>

<div class="viewcode-block" id="CoalescenceTree.sample_landscape_richness"><a class="viewcode-back" href="../../pycoalescence.html#pycoalescence.coalescence_tree.CoalescenceTree.sample_landscape_richness">[docs]</a>	<span class="k">def</span> <span class="nf">sample_landscape_richness</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">number_of_individuals</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">community_reference</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Samples from the landscape the required number of individuals, returning the mean of the species richnesses</span>
<span class="sd">		produced.</span>

<span class="sd">		If number_of_individuals is a dictionary mapping fragment names to numbers sampled, will sample the respective</span>
<span class="sd">		number from each fragment and return the whole landscape richness.</span>

<span class="sd">		:raises KeyError: if the dictionary supplied contains more sampled individuals than exist in a fragment, or</span>
<span class="sd">			if the fragment is not contained within the dictionary.</span>

<span class="sd">		:param int/dict number_of_individuals: either an int containing the number of individuals to be sampled, or a</span>
<span class="sd">			dictionary mapping fragment names to numbers of individuals to be sampled</span>
<span class="sd">		:param n: the number of repeats to average over</span>
<span class="sd">		:param community_reference: the community reference to fetch abundances for</span>

<span class="sd">		:return: the mean of the richness from the repeats for the whole landscape</span>
<span class="sd">		:rtype: float</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="n">richness_out</span> <span class="o">=</span> <span class="p">[]</span>
		<span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">number_of_individuals</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
			<span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">fragment_abundances</span><span class="p">:</span>
				<span class="bp">self</span><span class="o">.</span><span class="n">calculate_fragment_abundances</span><span class="p">()</span>
			<span class="n">select_abundances</span> <span class="o">=</span> <span class="p">[[</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">]]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">fragment_abundances</span> <span class="k">if</span> <span class="n">x</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">==</span> <span class="n">community_reference</span><span class="p">]</span>
			<span class="n">fragments</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">select_abundances</span><span class="p">])</span>
			<span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">fragments</span><span class="p">:</span>
				<span class="k">try</span><span class="p">:</span>
					<span class="n">_</span> <span class="o">=</span> <span class="n">number_of_individuals</span><span class="p">[</span><span class="n">f</span><span class="p">]</span>
				<span class="k">except</span> <span class="ne">KeyError</span> <span class="k">as</span> <span class="n">ke</span><span class="p">:</span>
					<span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="s2">&quot;Fragment not found in number_of_individuals dictionary: {}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">ke</span><span class="p">))</span>
				<span class="n">sum_total</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">([</span><span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">select_abundances</span> <span class="k">if</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">f</span><span class="p">])</span>
				<span class="k">if</span> <span class="n">sum_total</span> <span class="o">&lt;</span> <span class="n">number_of_individuals</span><span class="p">[</span><span class="n">f</span><span class="p">]:</span>
					<span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="s2">&quot;Sampled number of individuals is greater&quot;</span>
								   <span class="s2">&quot; than exists for fragment {}: {} &lt; {}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">sum_total</span><span class="p">,</span>
																				  <span class="n">number_of_individuals</span><span class="p">[</span><span class="n">f</span><span class="p">]))</span>
			<span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
				<span class="n">ids</span> <span class="o">=</span> <span class="p">[]</span>
				<span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">fragments</span><span class="p">:</span>
					<span class="n">chosen</span><span class="p">,</span> <span class="n">richness</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="p">[[</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">]]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">select_abundances</span> <span class="k">if</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">f</span><span class="p">])</span>
					<span class="n">species_ids</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">chosen</span><span class="p">,</span> <span class="n">richness</span><span class="p">)</span>
					<span class="n">ids</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">species_ids</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="n">number_of_individuals</span><span class="p">[</span><span class="n">f</span><span class="p">],</span> <span class="n">replace</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">())</span>
				<span class="n">richness_out</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">ids</span><span class="p">)))</span>
			<span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">richness_out</span><span class="p">)</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="c1"># straightforward case</span>
			<span class="n">chosen</span><span class="p">,</span> <span class="n">richness</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="p">[[</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_species_abundances</span><span class="p">(</span><span class="n">reference</span><span class="o">=</span><span class="n">community_reference</span><span class="p">)])</span>
			<span class="n">species_ids</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">chosen</span><span class="p">,</span> <span class="n">richness</span><span class="p">)</span>
			<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
				<span class="c1"># Randomly select number_of_individuals</span>
				<span class="n">richness_out</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">species_ids</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="n">number_of_individuals</span><span class="p">,</span> <span class="n">replace</span><span class="o">=</span><span class="bp">False</span><span class="p">))))</span>
			<span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">richness_out</span><span class="p">)</span></div>

<div class="viewcode-block" id="CoalescenceTree.calculate_species_distance_similarity"><a class="viewcode-back" href="../../pycoalescence.html#pycoalescence.coalescence_tree.CoalescenceTree.calculate_species_distance_similarity">[docs]</a>	<span class="k">def</span> <span class="nf">calculate_species_distance_similarity</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">output_metrics</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Calculates the probability two individuals are of the same species as a function of distance.</span>

<span class="sd">		Stores the mean distance between individuals of the same species in the BIODIVERSITY_METRICS table, and stores</span>
<span class="sd">		the full data in new table (SPECIES_DISTANCE_SIMILARITY). Distances are binned to the nearest integer.</span>

<span class="sd">		:param output_metrics: if true, outputs to the BIODIVERSITY_METRICS table as well, for metric comparison</span>

<span class="sd">		.. note:: Extremely slow for large landscape sizes.</span>

<span class="sd">		&quot;&quot;&quot;</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">_check_database</span><span class="p">()</span>
		<span class="n">species_locations</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cursor</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s2">&quot;SELECT species_id, x, y, community_reference FROM &quot;</span>
												<span class="s2">&quot;SPECIES_LOCATIONS&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">fetchall</span><span class="p">()</span>
		<span class="n">tmp_create</span> <span class="o">=</span> <span class="s2">&quot;CREATE TABLE SPECIES_DISTANCE_SIMILARITY (ref INT PRIMARY KEY NOT NULL, distance INT NOT NULL,&quot;</span> \
					 <span class="s2">&quot; no_individuals INT NOT NULL, community_reference INT NOT NULL)&quot;</span>
		<span class="k">if</span> <span class="ow">not</span> <span class="n">check_sql_table_exist</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">database</span><span class="p">,</span> <span class="s2">&quot;SPECIES_DISTANCE_SIMILARITY&quot;</span><span class="p">):</span>
			<span class="k">try</span><span class="p">:</span>
				<span class="bp">self</span><span class="o">.</span><span class="n">cursor</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">tmp_create</span><span class="p">)</span>
				<span class="bp">self</span><span class="o">.</span><span class="n">database</span><span class="o">.</span><span class="n">commit</span><span class="p">()</span>
			<span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
				<span class="n">e</span><span class="o">.</span><span class="n">message</span> <span class="o">=</span> <span class="s2">&quot;Error creating SPECIES_RICHNESS table: &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
				<span class="k">raise</span> <span class="n">e</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;SPECIES_DISTANCE_SIMILARITY table already exists in the output database.&quot;</span><span class="p">)</span>
		<span class="k">if</span> <span class="ow">not</span> <span class="n">check_sql_table_exist</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">database</span><span class="p">,</span> <span class="s2">&quot;SPECIES_LOCATIONS&quot;</span><span class="p">):</span>
			<span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;SPECIES_LOCATIONS table does not exist in output database - calculate species locations&quot;</span>
							   <span class="s2">&quot;first.&quot;</span><span class="p">)</span>
		<span class="n">max_val</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cursor</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s2">&quot;SELECT min(x), max(x),&quot;</span>
												  <span class="s2">&quot; min(y), max(y) FROM SPECIES_LOCATIONS&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">fetchone</span><span class="p">()]</span>
		<span class="n">references</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([</span><span class="n">x</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">species_locations</span><span class="p">])</span>
		<span class="n">ref</span> <span class="o">=</span> <span class="mi">0</span>
		<span class="n">output</span> <span class="o">=</span> <span class="p">[]</span>
		<span class="n">means</span> <span class="o">=</span> <span class="p">[]</span>
		<span class="n">max_distance</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">calculate_distance_between</span><span class="p">(</span><span class="n">max_val</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">max_val</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">max_val</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">max_val</span><span class="p">[</span><span class="mi">3</span><span class="p">]))</span> <span class="o">+</span> <span class="mi">1</span>
		<span class="k">for</span> <span class="n">reference</span> <span class="ow">in</span> <span class="n">references</span><span class="p">:</span>
			<span class="n">select</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">3</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">species_locations</span> <span class="k">if</span> <span class="n">x</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">==</span> <span class="n">reference</span><span class="p">]</span>
			<span class="n">species_list</span> <span class="o">=</span> <span class="p">{}</span>
			<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">select</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
				<span class="k">continue</span>
			<span class="n">sum_distances</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">max_distance</span>
			<span class="c1"># first loop over every individual</span>
			<span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">select</span><span class="p">:</span>
				<span class="k">if</span> <span class="n">row</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">species_list</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
					<span class="n">species_list</span><span class="p">[</span><span class="n">row</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="p">[]</span>
				<span class="n">species_list</span><span class="p">[</span><span class="n">row</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">row</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">row</span><span class="p">[</span><span class="mi">2</span><span class="p">]])</span>
			<span class="c1"># Now loop over every species and calculate the mean distance</span>
			<span class="k">for</span> <span class="n">species_id</span><span class="p">,</span> <span class="n">locations</span> <span class="ow">in</span> <span class="n">species_list</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
				<span class="n">total_length</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">locations</span><span class="p">)</span>
				<span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">location</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">locations</span><span class="p">):</span>
					<span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">total_length</span><span class="p">):</span>
						<span class="n">distance</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">calculate_distance_between</span><span class="p">(</span><span class="n">location</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">location</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
																  <span class="n">locations</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">locations</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">1</span><span class="p">]))</span>
						<span class="n">sum_distances</span><span class="p">[</span><span class="n">distance</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
			<span class="n">total_sim</span> <span class="o">=</span> <span class="mi">0</span>
			<span class="n">number_all</span> <span class="o">=</span> <span class="mi">0</span>
			<span class="k">for</span> <span class="n">distance</span><span class="p">,</span> <span class="n">item</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">sum_distances</span><span class="p">):</span>
				<span class="k">if</span> <span class="n">item</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
					<span class="k">continue</span>
				<span class="n">output</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">distance</span><span class="p">,</span> <span class="n">item</span><span class="p">,</span> <span class="n">reference</span><span class="p">])</span>
				<span class="n">total_sim</span> <span class="o">+=</span> <span class="n">item</span> <span class="o">*</span> <span class="n">distance</span>
				<span class="n">number_all</span> <span class="o">+=</span> <span class="n">item</span>
			<span class="k">if</span> <span class="n">number_all</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
				<span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;No distances found for {} - likely no species exist with more than one&quot;</span>
								 <span class="s2">&quot; location.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">reference</span><span class="p">))</span>
				<span class="n">mean</span> <span class="o">=</span> <span class="mi">0</span>
			<span class="k">else</span><span class="p">:</span>
				<span class="n">mean</span> <span class="o">=</span> <span class="n">total_sim</span> <span class="o">/</span> <span class="n">number_all</span>
			<span class="n">means</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">reference</span><span class="p">,</span> <span class="n">mean</span><span class="p">])</span>
		<span class="n">sql_output</span> <span class="o">=</span> <span class="p">[]</span>
		<span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">output</span><span class="p">:</span>
			<span class="n">ref</span> <span class="o">+=</span> <span class="mi">1</span>
			<span class="n">tmp</span> <span class="o">=</span> <span class="p">[</span><span class="n">ref</span><span class="p">]</span>
			<span class="n">tmp</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">row</span><span class="p">)</span>
			<span class="n">sql_output</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tmp</span><span class="p">)</span>
		<span class="k">if</span> <span class="n">output_metrics</span><span class="p">:</span>
			<span class="n">ref</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">check_biodiversity_table_exists</span><span class="p">()</span>
			<span class="n">bio_output</span> <span class="o">=</span> <span class="p">[]</span>
			<span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">means</span><span class="p">:</span>
				<span class="n">ref</span> <span class="o">+=</span> <span class="mi">1</span>
				<span class="n">tmp</span> <span class="o">=</span> <span class="p">[</span><span class="n">ref</span><span class="p">,</span> <span class="s2">&quot;mean_distance_between_individuals&quot;</span><span class="p">,</span> <span class="s2">&quot;whole&quot;</span><span class="p">]</span>
				<span class="n">tmp</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">float</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">])])</span>
				<span class="n">bio_output</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tmp</span><span class="p">)</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">cursor</span><span class="o">.</span><span class="n">executemany</span><span class="p">(</span><span class="s2">&quot;INSERT INTO BIODIVERSITY_METRICS VALUES (?, ?, ?, ?, ?, NULL, NULL)&quot;</span><span class="p">,</span> <span class="n">bio_output</span><span class="p">)</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">cursor</span><span class="o">.</span><span class="n">executemany</span><span class="p">(</span><span class="s2">&quot;INSERT INTO SPECIES_DISTANCE_SIMILARITY VALUES(?,?,?,?)&quot;</span><span class="p">,</span> <span class="n">sql_output</span><span class="p">)</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">database</span><span class="o">.</span><span class="n">commit</span><span class="p">()</span></div>

<div class="viewcode-block" id="CoalescenceTree.get_species_distance_similarity"><a class="viewcode-back" href="../../pycoalescence.html#pycoalescence.coalescence_tree.CoalescenceTree.get_species_distance_similarity">[docs]</a>	<span class="k">def</span> <span class="nf">get_species_distance_similarity</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">community_reference</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Gets the species distance similarity table for the provided community reference.</span>

<span class="sd">		:return: list containing the distance, number of similar species with that distance</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">_check_database</span><span class="p">()</span>
		<span class="k">if</span> <span class="ow">not</span> <span class="n">check_sql_table_exist</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">database</span><span class="p">,</span> <span class="s2">&quot;SPECIES_DISTANCE_SIMILARITY&quot;</span><span class="p">):</span>
			<span class="k">raise</span> <span class="ne">IOError</span><span class="p">(</span><span class="s2">&quot;Database {} does not contain SPECIES_DISTANCE_SIMILARITY table&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">file</span><span class="p">))</span>
		<span class="n">sql_fetch</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cursor</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s2">&quot;SELECT distance, no_individuals FROM SPECIES_DISTANCE_SIMILARITY &quot;</span>
										<span class="s2">&quot;WHERE community_reference == ?&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">community_reference</span><span class="p">,))</span><span class="o">.</span><span class="n">fetchall</span><span class="p">()</span>
		<span class="k">return</span> <span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">sql_fetch</span><span class="p">]</span></div></div>


<div class="viewcode-block" id="collate_fits"><a class="viewcode-back" href="../../pycoalescence.html#pycoalescence.coalescence_tree.collate_fits">[docs]</a><span class="k">def</span> <span class="nf">collate_fits</span><span class="p">(</span><span class="n">file_dir</span><span class="p">,</span> <span class="n">filename</span><span class="o">=</span><span class="s2">&quot;Collated_fits.db&quot;</span><span class="p">):</span>
	<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">	Collates the goodness of fit values from every file in the specified directory and places them in one new file.</span>

<span class="sd">	.. note:: Files with &#39;collated&#39; in the name will be ignored.</span>

<span class="sd">	.. note:: If the output file exists, it will be deleted.</span>

<span class="sd">	Creates three separate tables in the output file, one for overall goodness of fit, one for fragment richness fits,</span>
<span class="sd">	and one for fragment octaves fits.</span>

<span class="sd">	:param file_dir: the file directory to examine</span>
<span class="sd">	:param filename: [optional] the output file name.</span>
<span class="sd">	&quot;&quot;&quot;</span>
	<span class="k">if</span> <span class="n">filename</span> <span class="o">==</span> <span class="s2">&quot;Collated_fits.db&quot;</span><span class="p">:</span>
		<span class="n">filename</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">file_dir</span><span class="p">,</span> <span class="n">filename</span><span class="p">)</span>
	<span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">filename</span><span class="p">):</span>
		<span class="n">os</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>

	<span class="k">try</span><span class="p">:</span>
		<span class="n">database</span> <span class="o">=</span> <span class="n">sqlite3</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
	<span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
		<span class="k">raise</span> <span class="ne">IOError</span><span class="p">(</span><span class="s2">&quot;Error opening SQLite database: &quot;</span> <span class="o">+</span> <span class="n">e</span><span class="o">.</span><span class="n">message</span><span class="p">)</span>
	<span class="n">database</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s2">&quot;CREATE TABLE GOODNESS_FIT (ref INT PRIMARY KEY NOT NULL, task INT NOT NULL, seed INT NOT NULL, &quot;</span>
					 <span class="s2">&quot;sigma FLOAT NOT NULL, tau FLOAT NOT NULL, m_probability FLOAT NOT NULL, cutoff FLOAT NOT NULL,&quot;</span> \
					 <span class="s2">&quot;time FLOAT NOT NULL, speciation_rate FLOAT NOT NULL, value FLOAT NOT NULL)&quot;</span><span class="p">)</span>
	<span class="n">database</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span>
		<span class="s2">&quot;CREATE TABLE GOODNESS_FIT_FRAGMENT_RICHNESS (ref INT PRIMARY KEY NOT NULL, task INT NOT NULL, seed INT NOT NULL, &quot;</span>
		<span class="s2">&quot;sigma FLOAT NOT NULL, tau FLOAT NOT NULL, m_probability FLOAT NOT NULL, cutoff FLOAT NOT NULL,&quot;</span> \
		<span class="s2">&quot;time FLOAT NOT NULL, speciation_rate FLOAT NOT NULL, value FLOAT NOT NULL)&quot;</span><span class="p">)</span>
	<span class="n">database</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span>
		<span class="s2">&quot;CREATE TABLE GOODNESS_FIT_FRAGMENT_OCTAVES (ref INT PRIMARY KEY NOT NULL, task INT NOT NULL, seed INT NOT NULL, &quot;</span>
		<span class="s2">&quot;sigma FLOAT NOT NULL, tau FLOAT NOT NULL, m_probability FLOAT NOT NULL, cutoff FLOAT NOT NULL,&quot;</span> \
		<span class="s2">&quot;time FLOAT NOT NULL, speciation_rate FLOAT NOT NULL, value FLOAT NOT NULL)&quot;</span><span class="p">)</span>
	<span class="n">ref</span> <span class="o">=</span> <span class="mi">0</span>
	<span class="n">ref_richness</span> <span class="o">=</span> <span class="mi">0</span>
	<span class="n">ref_octaves</span> <span class="o">=</span> <span class="mi">0</span>
	<span class="n">out</span> <span class="o">=</span> <span class="p">[]</span>
	<span class="n">out_richness</span> <span class="o">=</span> <span class="p">[]</span>
	<span class="n">out_octaves</span> <span class="o">=</span> <span class="p">[]</span>
	<span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">file_dir</span><span class="p">):</span>
		<span class="k">for</span> <span class="nb">file</span> <span class="ow">in</span> <span class="n">os</span><span class="o">.</span><span class="n">listdir</span><span class="p">(</span><span class="n">file_dir</span><span class="p">):</span>
			<span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">file_dir</span><span class="p">,</span> <span class="nb">file</span><span class="p">)</span> <span class="o">==</span> <span class="n">filename</span> <span class="ow">or</span> <span class="s2">&quot;Collated&quot;</span> <span class="ow">in</span> <span class="nb">file</span><span class="p">:</span>
				<span class="k">continue</span>
			<span class="k">elif</span> <span class="s2">&quot;.db&quot;</span> <span class="ow">in</span> <span class="nb">file</span> <span class="ow">and</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">file_dir</span><span class="p">,</span> <span class="nb">file</span><span class="p">)):</span>
				<span class="n">temp</span> <span class="o">=</span> <span class="n">CoalescenceTree</span><span class="p">()</span>
				<span class="k">try</span><span class="p">:</span>
					<span class="n">temp</span><span class="o">.</span><span class="n">set_database</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">file_dir</span><span class="p">,</span> <span class="nb">file</span><span class="p">))</span>
				<span class="k">except</span> <span class="ne">IOError</span><span class="p">:</span>
					<span class="n">temp</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;Database {} is not complete or does not exist.</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">file</span><span class="p">))</span>
					<span class="k">continue</span>
				<span class="k">try</span><span class="p">:</span>
					<span class="n">gof</span> <span class="o">=</span> <span class="n">temp</span><span class="o">.</span><span class="n">get_goodness_of_fit</span><span class="p">()</span>
				<span class="k">except</span><span class="p">:</span>
					<span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;File: &quot;</span> <span class="o">+</span> <span class="nb">file</span><span class="p">)</span>
				<span class="n">gof_octaves</span> <span class="o">=</span> <span class="n">temp</span><span class="o">.</span><span class="n">get_goodness_of_fit_fragment_octaves</span><span class="p">()</span>
				<span class="n">gof_richness</span> <span class="o">=</span> <span class="n">temp</span><span class="o">.</span><span class="n">get_goodness_of_fit_fragment_richness</span><span class="p">()</span>
				<span class="n">disp</span> <span class="o">=</span> <span class="n">temp</span><span class="o">.</span><span class="n">dispersal_parameters</span><span class="p">()</span>
				<span class="n">j</span> <span class="o">=</span> <span class="n">temp</span><span class="o">.</span><span class="n">get_job</span><span class="p">()</span>
				<span class="k">for</span> <span class="n">each</span> <span class="ow">in</span> <span class="n">gof</span><span class="p">:</span>
					<span class="n">out</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">ref</span><span class="p">,</span> <span class="n">j</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">j</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">disp</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">disp</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">disp</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">disp</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">each</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">each</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span> <span class="n">each</span><span class="p">[</span><span class="mi">5</span><span class="p">]])</span>
					<span class="n">ref</span> <span class="o">+=</span> <span class="mi">1</span>
				<span class="k">for</span> <span class="n">each</span> <span class="ow">in</span> <span class="n">gof_richness</span><span class="p">:</span>
					<span class="n">out_richness</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
						<span class="p">[</span><span class="n">ref_richness</span><span class="p">,</span> <span class="n">j</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">j</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">disp</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">disp</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">disp</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">disp</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">each</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">each</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span> <span class="n">each</span><span class="p">[</span><span class="mi">5</span><span class="p">]])</span>
					<span class="n">ref_richness</span> <span class="o">+=</span> <span class="mi">1</span>
				<span class="k">for</span> <span class="n">each</span> <span class="ow">in</span> <span class="n">gof_octaves</span><span class="p">:</span>
					<span class="n">out_octaves</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
						<span class="p">[</span><span class="n">ref_octaves</span><span class="p">,</span> <span class="n">j</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">j</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">disp</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">disp</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">disp</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">disp</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">each</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">each</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span> <span class="n">each</span><span class="p">[</span><span class="mi">5</span><span class="p">]])</span>
					<span class="n">ref_octaves</span> <span class="o">+=</span> <span class="mi">1</span>
		<span class="n">database</span><span class="o">.</span><span class="n">executemany</span><span class="p">(</span><span class="s2">&quot;INSERT INTO GOODNESS_FIT VALUES(?,?,?,?,?,?,?,?,?,?)&quot;</span><span class="p">,</span> <span class="n">out</span><span class="p">)</span>
		<span class="n">database</span><span class="o">.</span><span class="n">executemany</span><span class="p">(</span><span class="s2">&quot;INSERT INTO GOODNESS_FIT_FRAGMENT_RICHNESS VALUES(?,?,?,?,?,?,?,?,?,?)&quot;</span><span class="p">,</span> <span class="n">out_richness</span><span class="p">)</span>
		<span class="n">database</span><span class="o">.</span><span class="n">executemany</span><span class="p">(</span><span class="s2">&quot;INSERT INTO GOODNESS_FIT_FRAGMENT_OCTAVES VALUES(?,?,?,?,?,?,?,?,?,?)&quot;</span><span class="p">,</span> <span class="n">out_octaves</span><span class="p">)</span>
		<span class="n">database</span><span class="o">.</span><span class="n">commit</span><span class="p">()</span>
	<span class="k">else</span><span class="p">:</span>
		<span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Specified file directory &quot;</span> <span class="o">+</span> <span class="n">file_dir</span> <span class="o">+</span> <span class="s2">&quot; does not exist&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="scale_simulation_fit"><a class="viewcode-back" href="../../pycoalescence.html#pycoalescence.coalescence_tree.scale_simulation_fit">[docs]</a><span class="k">def</span> <span class="nf">scale_simulation_fit</span><span class="p">(</span><span class="n">simulated_value</span><span class="p">,</span> <span class="n">actual_value</span><span class="p">,</span> <span class="n">number_individuals</span><span class="p">,</span> <span class="n">total_individuals</span><span class="p">):</span>
	<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">	Calculates goodness of fit for the provided values, and scales based on the total number of individuals that exist.</span>
<span class="sd">	The calculation is 1 - (abs(x - y)/max(x, y)) * n/n_tot for x, y simulated and actual values, n, n_tot for metric and total</span>
<span class="sd">	number of individuals.</span>

<span class="sd">	:param simulated_value: the simulated value of the metric</span>
<span class="sd">	:param actual_value: the actual value of the metric</span>
<span class="sd">	:param number_individuals: the number of individuals this metric relates to</span>
<span class="sd">	:param total_individuals: the total number of individuals across all sites for this metric</span>
<span class="sd">	:return: the scaled fit value</span>
<span class="sd">	&quot;&quot;&quot;</span>
	<span class="k">return</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">simulated_value</span> <span class="o">-</span> <span class="n">actual_value</span><span class="p">))</span> <span class="o">/</span> <span class="nb">max</span><span class="p">(</span><span class="n">simulated_value</span><span class="p">,</span> <span class="n">actual_value</span><span class="p">))</span> <span class="o">*</span> \
		   <span class="n">number_individuals</span> <span class="o">/</span> <span class="n">total_individuals</span></div>
</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../../index.html">
              <img class="logo" src="../../_static/PyCoal_logo.png" alt="Logo"/>
            </a></p>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="../../search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="Go" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">pycoalescence 1.2.7a5 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../index.html" >Module code</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright Copyright 2016, pycoalescence.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.6.7.
    </div>
  </body>
</html>