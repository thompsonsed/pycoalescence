<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Simulating and generating landscapes &#8212; pycoalescence 1.2.6rc55 documentation</title>
    
    <link rel="stylesheet" href="_static/classic.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="_static/collapsible-lists/css/tree_view.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '1.2.6rc55',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/javascript" src="_static/collapsible-lists/js/CollapsibleLists.compressed.js"></script>
    <script type="text/javascript" src="_static/collapsible-lists/js/apply-collapsible-lists.js"></script>
    <link rel="shortcut icon" href="_static/PyCoal_favicon_large.ico"/>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Merging simulation outputs" href="README_merger.html" />
    <link rel="prev" title="Program Listing for File TreeNode.h" href="necsim/program_listing_file_necsim_TreeNode.h.html" /> 
  </head>
  <body role="document">
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="README_merger.html" title="Merging simulation outputs"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="necsim/program_listing_file_necsim_TreeNode.h.html" title="Program Listing for File TreeNode.h"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">pycoalescence 1.2.6rc55 documentation</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="simulating-and-generating-landscapes">
<span id="simulate-and-generate-landscapes"></span><h1>Simulating and generating landscapes<a class="headerlink" href="#simulating-and-generating-landscapes" title="Permalink to this headline">¶</a></h1>
<div class="section" id="introduction">
<h2>Introduction<a class="headerlink" href="#introduction" title="Permalink to this headline">¶</a></h2>
<p><strong>pycoalescence</strong> provides functionality for generating fragmented landscapes for simulations, and simulating dispersal
kernels to produce a variety of landscape-level dispersal metrics. Generation of landscapes is provided through the
<a class="reference internal" href="pycoalescence.html#pycoalescence.fragments.FragmentedLandscape" title="pycoalescence.fragments.FragmentedLandscape"><code class="xref py py-class docutils literal"><span class="pre">FragmentedLandscape</span> <span class="pre">class</span></code></a>. Simulations of dispersal kernels is
provided through the <a class="reference internal" href="pycoalescence.html#pycoalescence.dispersal_simulation.DispersalSimulation" title="pycoalescence.dispersal_simulation.DispersalSimulation"><code class="xref py py-class docutils literal"><span class="pre">DispersalSimulation</span> <span class="pre">class</span></code></a>.</p>
</div>
<div class="section" id="generating-landscapes">
<span id="generate-landscapes"></span><h2>Generating landscapes<a class="headerlink" href="#generating-landscapes" title="Permalink to this headline">¶</a></h2>
<div class="section" id="fragmented-landscapes">
<h3>Fragmented Landscapes<a class="headerlink" href="#fragmented-landscapes" title="Permalink to this headline">¶</a></h3>
<p>For our purposes, we define fragmented landscapes as continuous, fully spatial landscapes of a particular size, with n
individuals split across i equally (or as close to) sized fragments, which are evenly spaced across the landscape.
<strong>pycoalescence</strong> provides the routines for generating these landscapes within
<a class="reference internal" href="pycoalescence.html#pycoalescence.fragments.FragmentedLandscape" title="pycoalescence.fragments.FragmentedLandscape"><code class="xref py py-class docutils literal"><span class="pre">FragmentedLandscape</span> <span class="pre">class</span></code></a>.</p>
<p>The parameters for generating a fragmented landscape are the total landscape size, the habitat area within the landscape
(i.e. the number of individuals) and the number of fragments to place. The habitat area cannot be more than 50% of the
landscape size, as at this point fragments become non-distinct. The process is:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">pycoalescence</span> <span class="kn">import</span> <span class="n">FragmentedLandscape</span>
<span class="n">f</span> <span class="o">=</span> <span class="n">FragmentedLandscape</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">number_fragments</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">total</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span> <span class="n">output_file</span><span class="o">=</span><span class="s2">&quot;fragment.tif&quot;</span><span class="p">)</span>
<span class="n">f</span><span class="o">.</span><span class="n">generate</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="section" id="patched-landscapes">
<h3>Patched Landscapes<a class="headerlink" href="#patched-landscapes" title="Permalink to this headline">¶</a></h3>
<p>We define patched landscapes as a number of interconnected patches, each containing a certain number of well-mixed
individuals (the patch&#8217;s density) and every patch is has some probability of dispersal to every other patch (which can
be 0). Another imagination of this concept is of a series of connected islands, where each island is modelled
non-spatially, and every island has a probability of dispersing to all other islands.
<strong>pycoalescence</strong> provides the routines for generating these landscapes within
<a class="reference internal" href="pycoalescence.html#pycoalescence.patched_landscape.PatchedLandscape" title="pycoalescence.patched_landscape.PatchedLandscape"><code class="xref py py-class docutils literal"><span class="pre">PatchedLandscape</span> <span class="pre">class</span></code></a>.</p>
<p>Creation of a patched landscape requires first defining all the patches that exist in the landscape, and then setting
the dispersal probability between each island. If any dispersal probability is not set, it is assumed to be 0. The
dispersal probability from one patch to itself must be provided (but can be 0). The probability values provided are then
re-scaled to sum to 1, and re-generated as cumulative probabilities.</p>
</div>
</div>
<div class="section" id="simulated-landscapes">
<h2>Simulated landscapes<a class="headerlink" href="#simulated-landscapes" title="Permalink to this headline">¶</a></h2>
<p>To simulate a dispersal kernel on a landscape, there are two processes; simulating a single step and simulating multiple
steps. For a single step, the distance travelled is recorded into the output database. The mean, standard deviation and
other metrics can be obtained from this. For multiple steps, the total distance travelled after n steps is recorded.
Both methods follow the same structure,</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">pycoalescence</span> <span class="kn">import</span> <span class="n">DispersalSimulation</span>
<span class="n">m</span> <span class="o">=</span> <span class="n">DispersalSimulation</span><span class="p">(</span><span class="n">dispersal_db</span><span class="o">=</span><span class="s2">&quot;path/output.db&quot;</span><span class="p">)</span>
<span class="n">m</span><span class="o">.</span><span class="n">test_mean_dispersal</span><span class="p">(</span><span class="n">number_repeats</span><span class="o">=</span><span class="mi">100000</span><span class="p">,</span> <span class="n">output_database</span><span class="o">=</span><span class="n">out_db</span><span class="p">,</span> <span class="n">map_file</span><span class="o">=</span><span class="s2">&quot;path/map.tif&quot;</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="n">seed</span><span class="p">,</span>
                      <span class="n">dispersal_method</span><span class="o">=</span><span class="s2">&quot;normal&quot;</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="n">sigma</span><span class="p">,</span> <span class="n">landscape_type</span><span class="o">=</span><span class="s2">&quot;tiled&quot;</span><span class="p">)</span>
<span class="n">m</span><span class="o">.</span><span class="n">test_mean_distance_travelled</span><span class="p">(</span><span class="n">number_repeats</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span> <span class="n">number_steps</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span>
                               <span class="n">map_file</span><span class="o">=</span><span class="s2">&quot;path/map.tif&quot;</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="n">seed</span><span class="p">,</span> <span class="n">dispersal_method</span><span class="o">=</span><span class="s2">&quot;normal&quot;</span><span class="p">,</span>
                               <span class="n">sigma</span><span class="o">=</span><span class="n">sigma</span><span class="p">,</span> <span class="n">landscape_type</span><span class="o">=</span><span class="s2">&quot;tiled&quot;</span><span class="p">)</span>
<span class="c1"># The reference parameters correspond to the order they were simulated with</span>
<span class="n">parameters_list</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">getdatabase_parameters</span><span class="p">()</span>
<span class="c1"># Each of these contain parameters for the first and second simulation</span>
<span class="n">parameters_1</span> <span class="o">=</span> <span class="n">parameters_list</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="n">parameters_2</span> <span class="o">=</span> <span class="n">parameters_list</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
<span class="c1"># We can therefore just use the reference numbers (1 or 2) to obtain metrics</span>
<span class="n">m</span><span class="o">.</span><span class="n">get_mean_dispersal</span><span class="p">(</span><span class="n">parameter_reference</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="n">m</span><span class="o">.</span><span class="n">get_mean_distance_travelled</span><span class="p">(</span><span class="n">parameter_reference</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="n">m</span><span class="o">.</span><span class="n">get_stdev_dispersal</span><span class="p">(</span><span class="n">parameters_reference</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="reading-and-writing-tif-files">
<h2>Reading and writing tif files<a class="headerlink" href="#reading-and-writing-tif-files" title="Permalink to this headline">¶</a></h2>
<p>The <a class="reference internal" href="pycoalescence.html#pycoalescence.map.Map" title="pycoalescence.map.Map"><code class="xref py py-class docutils literal"><span class="pre">Map</span> <span class="pre">class</span></code></a> is used for detecting offsets and dimensions of tif files for
the main program. There are therefore a number of additional features in this class.</p>
<ul class="simple">
<li>Data can be read using <a class="reference internal" href="pycoalescence.html#pycoalescence.map.Map.get_subset" title="pycoalescence.map.Map.get_subset"><code class="xref py py-func docutils literal"><span class="pre">get_subset()</span></code></a> and
<a class="reference internal" href="pycoalescence.html#pycoalescence.map.Map.get_cached_subset" title="pycoalescence.map.Map.get_cached_subset"><code class="xref py py-func docutils literal"><span class="pre">get_cached_subset()</span></code></a>.</li>
<li>Dimensions can be determined using <a class="reference internal" href="pycoalescence.html#pycoalescence.map.Map.get_dimensions" title="pycoalescence.map.Map.get_dimensions"><code class="xref py py-func docutils literal"><span class="pre">get_dimensions()</span></code></a>. The entire tif
file can also be read into a numpy array using <a class="reference internal" href="pycoalescence.html#pycoalescence.map.Map.open" title="pycoalescence.map.Map.open"><code class="xref py py-func docutils literal"><span class="pre">open()</span></code></a> and then indexing on
<code class="xref py py-attr docutils literal"><span class="pre">data</span></code>.</li>
<li>A shapefile can be rasterised to a new tif file using <a class="reference internal" href="pycoalescence.html#pycoalescence.map.Map.rasterise" title="pycoalescence.map.Map.rasterise"><code class="xref py py-func docutils literal"><span class="pre">rasterise()</span></code></a>.</li>
<li>Tif files can be re-projected to either a new or the same file using
<a class="reference internal" href="pycoalescence.html#pycoalescence.map.Map.reproject_raster" title="pycoalescence.map.Map.reproject_raster"><code class="xref py py-func docutils literal"><span class="pre">open()</span></code></a>.</li>
</ul>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">All processing is done using the gdal module.</p>
</div>
</div>
<div class="section" id="obtaining-landscape-metrics">
<h2>Obtaining landscape metrics<a class="headerlink" href="#obtaining-landscape-metrics" title="Permalink to this headline">¶</a></h2>
<p><a class="reference internal" href="pycoalescence.html#pycoalescence.landscape_metrics.LandscapeMetrics" title="pycoalescence.landscape_metrics.LandscapeMetrics"><code class="xref py py-class docutils literal"><span class="pre">LandscapeMetrics</span></code></a> contains methods for calculating some
landscape metrics on a map file. This is a work in progress, and additional metrics may be added later.</p>
<p>MNN here refers to the mean distance from each cell to its nearest neighbouring habitat cell. The distance can be
calculated for a landscape using the following:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="o">&gt;&gt;</span> <span class="kn">from</span> <span class="nn">pycoalescence</span> <span class="kn">import</span> <span class="n">LandscapeMetrics</span>
<span class="o">&gt;&gt;</span> <span class="n">lm</span> <span class="o">=</span> <span class="n">LandscapeMetrics</span><span class="p">(</span><span class="s2">&quot;map_file.tif&quot;</span><span class="p">)</span>
<span class="o">&gt;&gt;</span> <span class="n">lm</span><span class="o">.</span><span class="n">get_mnn</span><span class="p">()</span>
<span class="mf">1.50</span>
</pre></div>
</div>
<p>The clumpiness metric is a measure of the proportional deviation of proportion of like adjacencies involving the
corresponding class from that expected under a spatially random distribution. It produces a <span class="math">\(\text{CLUMPY}\)</span> value,
where <span class="math">\(-1 &lt;= \text{CLUMPY} &lt;= 1\)</span>. -1 represents a perfectly disaggregated landscape. 1 represents a perfectly
aggregated landscape. 0 represents a random landscape. The formula outlined below works where there are <span class="math">\(k\)</span>
patches; in our scenario there <span class="math">\(k=2\)</span> as we have just habitat or non-habitat.</p>
<p>We have:</p>
<blockquote>
<div><ul class="simple">
<li><span class="math">\(g_ii\)</span>, the number of adjacencies between pixels of patch type <span class="math">\(i\)</span> using the the double count method.</li>
<li><span class="math">\(g_ik\)</span>, the number of adjacencies between pixels of patches <span class="math">\(i\)</span> and <span class="math">\(j\)</span></li>
<li><span class="math">\(\text{min}(e_i)\)</span>, the minimum perimeter (in cell surfaces) for a maximally-clumped class <span class="math">\(i\)</span></li>
<li><span class="math">\(P_i\)</span>, the proportion of the landscape occupied by class <span class="math">\(i\)</span>.</li>
</ul>
</div></blockquote>
<p>Given</p>
<div class="math">
\[G_i = (\frac{g_{ii}}{(\sum_{k=1}^{n} g_{ik}) - \text{min} (e_i)}\]</div>
<p>then</p>
<div class="math">
\[\begin{split}\text{CLUMPY} = \begin{cases}
  \frac{G_i - P_i}{P_i}, &amp; \text{if}\ G_i &lt; P_i\ \&amp;\ P_i &lt; 0.5 \\
  \frac{G_i - P_i}{1-P_i}, &amp; \text{otherwise}
\end{cases}\end{split}\]</div>
<p>The <span class="math">\(\text{CLUMPY}\)</span> metric can be calculated similarly as</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="o">&gt;&gt;</span> <span class="kn">from</span> <span class="nn">pycoalescence</span> <span class="kn">import</span> <span class="n">LandscapeMetrics</span>
<span class="o">&gt;&gt;</span> <span class="n">lm</span> <span class="o">=</span> <span class="n">LandscapeMetrics</span><span class="p">(</span><span class="s2">&quot;map_file.tif&quot;</span><span class="p">)</span>
<span class="o">&gt;&gt;</span> <span class="n">lm</span><span class="o">.</span><span class="n">get_clumpiness</span><span class="p">()</span>
<span class="mf">0.8</span>
</pre></div>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="index.html">
              <img class="logo" src="_static/PyCoal_logo.png" alt="Logo"/>
            </a></p>
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Simulating and generating landscapes</a><ul>
<li><a class="reference internal" href="#introduction">Introduction</a></li>
<li><a class="reference internal" href="#generating-landscapes">Generating landscapes</a><ul>
<li><a class="reference internal" href="#fragmented-landscapes">Fragmented Landscapes</a></li>
<li><a class="reference internal" href="#patched-landscapes">Patched Landscapes</a></li>
</ul>
</li>
<li><a class="reference internal" href="#simulated-landscapes">Simulated landscapes</a></li>
<li><a class="reference internal" href="#reading-and-writing-tif-files">Reading and writing tif files</a></li>
<li><a class="reference internal" href="#obtaining-landscape-metrics">Obtaining landscape metrics</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="necsim/program_listing_file_necsim_TreeNode.h.html"
                        title="previous chapter">Program Listing for File TreeNode.h</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="README_merger.html"
                        title="next chapter">Merging simulation outputs</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/README_landscapes.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="Go" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="README_merger.html" title="Merging simulation outputs"
             >next</a> |</li>
        <li class="right" >
          <a href="necsim/program_listing_file_necsim_TreeNode.h.html" title="Program Listing for File TreeNode.h"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">pycoalescence 1.2.6rc55 documentation</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright Copyright 2016, pycoalescence.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.5.2.
    </div>
  </body>
</html>