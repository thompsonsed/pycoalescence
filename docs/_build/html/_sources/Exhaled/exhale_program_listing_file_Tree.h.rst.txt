.. _program_listing_file_Tree.h:

Program Listing for File Tree.h
========================================================================================

- Return to documentation for :ref:`file_Tree.h`

.. code-block:: cpp

   // This file is part of NECSim project which is released under BSD-3 license.
   // See file **LICENSE.txt** or visit https://opensource.org/licenses/BSD-3-Clause) for full license details.
   //
   #ifndef TREE
   #define TREE
   
   /************************************************************
                                                   INCLUDES
    ************************************************************/
   // standard includes
   #include <stdio.h>
   #include <fstream>
   #include <vector>
   #include <iostream>
   #include <string>
   #include <cstring>
   #include <math.h>
   #include <iomanip>
   #include <cmath>
   #include <time.h>
   #include <ctime>
   #include <sqlite3.h>
   #include <string>
   //# include <sqlite.h>
   #include <unistd.h>
   #include <algorithm>
   #include <stdexcept>
   //#define with_gdal
   // extra boost include - this requires the installation of boost on the system
   // note that this requires compilation with the -lboost_filesystem and -lboost_system linkers.
   #include <boost/filesystem.hpp>
   
   // include fast-csv-parser by Ben Strasser (available from https://github.com/ben-strasser/fast-cpp-csv-parser)
   // for fast file reading
   #ifdef use_csv
   #include "fast-cpp-csv-parser/csv.h"
   #endif
   
   //#define use_csv // for integration with the matrix header file
   //#include "fast-cpp-csv-parser/csv.h"
   //#define record_space // tells the compiler whether to include the routines for outputting full spatial data of
   //lineages. Usually this will not be required.
   
   // this uses the RAM for the storage of the active SQL database.
   // If the RAM requirements get too huge, comment this out to instead write directly to disc.
   // For HPC systems, it is recommended to use this option as write speeds are generally fast and large simulations don't
   // have a linear increase in the SQL database size (at least in RAM).
   #define sql_ram
   
   // other includes for required files
   #include "Matrix.h"
   #include "Fattaildeviate.h"
   #include "Datapoint.h"
   #include "Treenode.h"
   #include "SpeciesList.h"
   #include "Map.h"
   #include "Treelist.h"
   #include "Config.h"
   
   using namespace std;
   
   /************************************************************
                                                   MAIN TREE OBJECT
    ************************************************************/
   
   class Tree
   {
       // declare private variables
      private:
       // storing the coalescence tree itself
       Row<Treenode> data;
       unsigned long enddata;
       // for storing the command line parameters and parsing the required information.
       Mapvars mapvarsin;
       // random number generator
       NRrand NR;
       bool seeded;
       // random seed
       long long the_seed;
   
       // for general debugging use
       //  bool debug;
   
       // for enabling the logging mode
       bool log_all;
       // note: in earlier versions I had the minspecsetup variable here
       // I've removed it because this version implements speciation as it goes rather than on the tree later
       // I've also removed sim_counter which recorded the number of repeat simulations
       // because each job will be 1 simulation in this implementation
   
       // for file naming - good to know which task in a series is being executed here
       long long the_task;
   
       // The map file containing the times that we want to expand the model and record all lineages again.
       // If this is null, bAutocorrel will be false and the vector will be empty.
       string autocorrel_file;
       vector<double> autocorrel_times;
       // Set to true if we are recording at times other than the present day.
       bool bAutocorrel;
       // the map files // these are now removed from the class object and replaced with a function fed by a series of
       // strings serving the same purpose.
       /*vector<string> map_list;
       // the sizes of the same map files
       vector<long> map_x_size;
       vector<long> map_y_size;
       // The list of size of the grid within the map and the dimensions of the offset.
       vector<long> grid_x_size;
       vector<long>grid_y_size;
       vector<long> grid_x_offset;
       vector<long>grid_y_offset;
        * */
       // tmp debugging
       bool bSpec;
       // A list of new variables which will contain the relevant information for maps and grids.
       string finemapinput, coarsemapinput, outdirectory;  //  strings containing the file names to be imported.
       string pristinefinemapinput, pristinecoarsemapinput;
       double dPristine, dForestTransform;  // the time since pristine forest and the rate of change of the rainforest.
       long gridxsize, gridysize;  // the variables for the grid containing the initial individuals.
       long finemapxsize, finemapysize, finemapxoffset,
           finemapyoffset;  // The fine map variables at the same resolution as the grid.
       long coarsemapxsize, coarsemapysize, coarsemapxoffset, coarsemapyoffset,
           coarsemapscale;  // the coarse map variables at a scaled resolution of the fine map.
       bool varimport;  // Used to check whether the map variables have already been imported.
       // New private vectors
       // The time variables (for timing the simulation in real time)
       time_t start, sim_start, sim_end, now, sim_finish, out_finish;
       time_t time_taken;
       // Map object containing both the coarse and fine maps for checking whether or not there is forest at a particular
       // location.
       Map forestmap;
       // An indexing spread for the lineages
       Matrix<SpeciesList> grid;
       Row<Datapoint> active;
       // Active lineages stored as a row of datapoints
       // Stores the point of the end of the active vector
       unsigned long endactive;  // 0 is reserved as null
       unsigned long startendactive;  // the maximum size of endactive
       unsigned long maxsimsize;  // the maximum simulated number of individuals in the present day.
       // This might need to be updated for simulations that have large changes in maximum population size over time.
   
       // number of simulation steps
       long steps;
       // number of generations passed, dispersal and sigma references
       double generation, sigma, nu, maxtime, deme_sample;
       long double spec;
       double lambda;  // the cost for moving through non-forest. 1.0 means there is no cost. 10 means that movement is 10x
                       // slower through forest.
       long deme;
       unsigned long
           desired_specnum;  // the desired number of species we are aiming for. If it is 0, we will carry on forever.
       // sqlite3 object that stores all the data
       sqlite3 *database;
   // If sql database is written first to memory, then need another object to contain the in-memory database.
   #ifdef sql_ram
       sqlite3 *outdatabase;
   #endif
       string sqloutname;
       Treelist tl;  // for create the link to the speciationcounter object which handles everything.
       Datamask samplegrid;  // contains the Datamask for where we should start lineages from.
       bool sim_complete;  // only set to true if the simulation has finished, otherwise will be false.
      public:
       // constructor
       Tree() : tl(data)
       {
       enddata = 0;
       seeded = false;
       the_seed = -10;
       log_all = true;  // set this equal to true if you want to log every 5 seconds to a logfile.
       the_task = -1;
       varimport = false;
       sqloutname = "null";
       sim_complete = false;
       time_taken = 0;  // the time taken starts at 0, unless imported from file.
       maxtime = 0;
       }
   
       void setMapVars(vector<string> comargs, bool fullmode);
   
       vector<double> getTemporalSampling();
   
       // Imports the maps using the variables stored in the class. This function must be run after the set_mapvars() in
       // order to function correctly.
       void importMaps();
   
       long long getSeed();
   
       void setSeed(long long theseedin);
   
       vector<long> randomList(long maxnum, long numnum);
   
       unsigned long setObjectSizes();
   
       void setup(vector<string> &comargs, bool fullmode);
   
       void removeOldPos(const unsigned long &chosen);
   
       void calcMove(long &oldx, long &oldy, long &oldxwrap, long &oldywrap);
   
       //
       //
       long double calcMinMax(const unsigned long &current);
   
       void coalescenceEvent(const unsigned long &chosen, unsigned long &coalchosen);
   
       //
       //
       void calcNewPos(bool &coal,
                       const unsigned long &chosen,
                       unsigned long &coalchosen,
                       const long &oldx,
                       const long &oldy,
                       const long &oldxwrap,
                       const long &oldywrap);
   
       void switchPositions(const unsigned long chosen);
   
       void speciation(const unsigned long &chosen);
   
       unsigned long estSpecnum();
   
       void runChecks(const unsigned long &chosen, const unsigned long &coalchosen);
   
       void validationCheck(const unsigned long &chosen, int o, const unsigned long &current, const bool &coal);
   
       void checkSimSize(unsigned long req_data, unsigned long req_active);
   
       bool runSim();
   
       void expandMap(double generationin);
   
       unsigned long sortData();
   
       void outputData();
       void outputData(unsigned long species_richness);
   
       void writeTimes();
   
       void simPause();
   
       void setResumeParameters(string outdir, unsigned long seed, unsigned long task, double new_max_time);
   
       void loadMainSave();
   
       void loadDataSave();
   
       void loadActiveSave();
   
       void loadGridSave();
   
       void loadMapSave();
   
       void simResume(bool cont_sim);
   
       void sqlCreate();
   
       void sqlOutput();
   
       void applySpecRates(double sr, double t);
   
       void applySpecRates(double sr);
   };
   
   #endif  // TREE


