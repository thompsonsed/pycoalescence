.. _program_listing_file_Map.h:

Program Listing for File Map.h
========================================================================================

- Return to documentation for :ref:`file_Map.h`

.. code-block:: cpp

   //This file is part of NECSim project which is released under BSD-3 license.
   //See file **LICENSE.txt** or visit https://opensource.org/licenses/BSD-3-Clause) for full license details
   #ifndef MAP
   #define MAP
    # include <string>
    # include <stdio.h>
    #include <vector>
    # include <iostream>
    # include <fstream>
    # include <math.h>
    # include <stdexcept>
    # include "Config.h"
    # include <boost/filesystem.hpp>
    
    #include "Matrix.h"
    //#include <Setup.h>
    //# include "Fattaildeviate.cpp"
    using namespace std;
    
   
    
    
   /************************************************************
                       MAPVARS STRUCTURE
    ************************************************************/
   struct Mapvars
   {
       string finemapfile, coarsemapfile,outdirectory,pristinefinemapfile,pristinecoarsemapfile, samplemaskfile;
        // for file naming purposes.
       long the_task;
       // the variables for the grid containing the initial individuals.
       unsigned long vargridxsize, vargridysize; 
       // The fine map variables at the same resolution as the grid.
       unsigned long varfinemapxsize, varfinemapysize, varfinemapxoffset, varfinemapyoffset; 
       // the coarse map variables at a scaled resolution of the fine map.
       unsigned long varcoarsemapxsize, varcoarsemapysize, varcoarsemapxoffset, varcoarsemapyoffset,varcoarsemapscale; 
       unsigned long desired_specnum;
       // the relative cost of moving through non-forest
       double lambda; 
       // the size of each square of habitat in numbers of individuals
       long deme;
       // the sample proportion, 
        double deme_sample;
       // the speciation rate.
       long double  spec; 
       // the variance of the dispersal kernel.
       double sigma; 
       // max time to run for
       double maxtime; 
       // the number of generations since a pristine landscape was encountered.
       double dPristine;
       // the transform rate of the forest from pristine to modern forest.
       double dForestTransform;
       // the fatness of the dispersal kernel
       double nu;
       // file containing the points to record data from
       string autocorrel_file;
       // Stores the full list of configs imported from file
       ConfigOption configs;
       // Set to true if the completely pristine state has been reached.
       bool bPristine;
   
       
       void import(const vector<string> &comargs, bool fullmode)
       {
           finemapfile = "null";
           coarsemapfile = "null";
           pristinefinemapfile = "null";
           pristinecoarsemapfile = "null";
           if(fullmode)
           {
               vargridxsize = stol(comargs[2]);
               vargridysize = stol(comargs[3]);
               finemapfile = comargs[4];
               varfinemapxsize = stol(comargs[5]);
               varfinemapysize = stol(comargs[6]);
               varfinemapxoffset = stol(comargs[7]);
               varfinemapyoffset = stol(comargs[8]);
               coarsemapfile = comargs[9];
               varcoarsemapxsize = stol(comargs[10]);
               varcoarsemapysize = stol(comargs[11]);
               varcoarsemapxoffset = stol(comargs[12]);
               varcoarsemapyoffset = stol(comargs[13]);
               varcoarsemapscale = stol(comargs[14]);
               outdirectory = comargs[15];
               lambda = stod(comargs[21]);
               the_task = stol(comargs[22]);
               desired_specnum = stol(comargs[23]);
               pristinefinemapfile = comargs[24];
               pristinecoarsemapfile = comargs[25];
               dForestTransform = stod(comargs[26]);
               dPristine = stod(comargs[27]);
               deme = stol(comargs[18]);
               deme_sample = stod(comargs[19]);
               spec = stold(comargs[16]);
               sigma = stod(comargs[17]);
               maxtime = stod(comargs[20]);
               nu = stod(comargs[28]);
               samplemaskfile = comargs[29];
               autocorrel_file = comargs[30];
           }
           else
           {
               // do the import of the values from combination of command-line arguments and file.
               configs.setConfig(comargs[3],false,true);
               configs.parseConfig();
               vargridxsize = stol(configs.getSectionOptions("sample_grid", "x"));
               vargridysize = stol(configs.getSectionOptions("sample_grid", "y"));
               samplemaskfile = configs.getSectionOptions("sample_grid","mask");
               finemapfile = configs.getSectionOptions("fine_map", "path");
               varfinemapxsize = stol(configs.getSectionOptions("fine_map", "x"));
               varfinemapysize = stol(configs.getSectionOptions("fine_map", "y"));
               varfinemapxoffset = stol(configs.getSectionOptions("fine_map", "x_off"));
               varfinemapyoffset = stol(configs.getSectionOptions("fine_map", "y_off"));
               coarsemapfile = configs.getSectionOptions("coarse_map", "path");
               varcoarsemapxsize = stol(configs.getSectionOptions("coarse_map", "x"));
               varcoarsemapysize = stol(configs.getSectionOptions("coarse_map", "y"));
               varcoarsemapxoffset = stol(configs.getSectionOptions("coarse_map", "x_off"));
               varcoarsemapyoffset = stol(configs.getSectionOptions("coarse_map", "y_off"));
               varcoarsemapscale = stol(configs.getSectionOptions("coarse_map", "scale"));
               pristinefinemapfile = configs.getSectionOptions("pristine_fine0", "path");
               pristinecoarsemapfile = configs.getSectionOptions("pristine_coarse0", "path");
               outdirectory = comargs[4];
               the_task = stol(comargs[2]);
                //= stol(comargs[5]);
               sigma = stod(comargs[6]);
               nu = stod(comargs[7]);
               deme = stol(comargs[8]);
               deme_sample = stod(comargs[9]);
               maxtime = stod(comargs[10]);
               lambda = stod(comargs[11]);
               autocorrel_file = comargs[12];
               spec = stod(comargs[5]);
   //          cout << spec<< endl;
   //          cout << comargs[5] << endl;
   //          cout << "auto" << autocorrel_file << endl;
               desired_specnum = stol(comargs[13]);
   //          printVars();
           }
       }
       
       void setPristine(unsigned int n)
       {
           bPristine = true;
           // Loop over each element in the config file (each line) and check if it is pristine fine or pristine coarse.
           for(unsigned int i = 0; i < configs.getSectionOptionsSize(); i ++ )
           {
               
               if(configs[i].section.find("pristine_fine") == 0)
               {
                   // Then loop over each element to find the number, and check if it is equal to our input number.
                   if(stol(configs[i].getOption("number")) == n)
                   {
                       bPristine = false;
                       pristinefinemapfile = configs[i].getOption("path");
                       dForestTransform = stod(configs[i].getOption("rate"));
                       dPristine = stod(configs[i].getOption("time"));
                   }
               }
               else if(configs[i].section.find("pristine_coarse") == 0)
               {
                   if(stol(configs[i].getOption("number")) == n)
                   {
                       bPristine = false;
                       pristinefinemapfile = configs[i].getOption("path");
                       // check matches
                       if(dForestTransform != stod(configs[i].getOption("rate")) || dPristine != stod(configs[i].getOption("time")))
                       {
                           cerr << "Forest transform values do not match between fine and coarse maps. Using fine values." << endl;
                       }
                   }
               }
           }
       }
       void printVars()
       {
           cout << "task: " << the_task << endl;
           cout << "Fine input file: " << finemapfile  << endl;
           cout << "-dimensions: (" << varfinemapxsize << "," << varfinemapysize <<")"<< endl;
           cout << "-offset: (" << varfinemapxoffset << "," << varfinemapyoffset << ")" << endl;
           cout << "Coarse input file: " << coarsemapfile  << endl;
           cout << "-dimensions: (" << varcoarsemapxsize << "," << varcoarsemapysize <<")"<< endl;
           cout << "-offset: (" << varcoarsemapxoffset << "," << varcoarsemapyoffset << ")" << endl;
           cout << "-scale: " << varcoarsemapscale << endl;
           cout << "Sample grid" << endl;
           cout << "-dimensions: (" << vargridxsize << "," << vargridysize << ")" << endl;
           cout << "-deme: " << deme << endl;
           cout << "-deme sample: " << deme_sample << endl;
           cout << "Output directory: " << outdirectory << endl;
           cout << "Lambda: " << lambda << endl;
           
       }
       
       friend ostream& operator<<(ostream& os,const Mapvars& m) 
       { 
           os << m.finemapfile << "\n" << m.coarsemapfile << "\n" << m.pristinefinemapfile << "\n" << m.pristinecoarsemapfile << "\n" << m.samplemaskfile << "\n";
           os << m.the_task << "\n" <<  m.vargridxsize << "\n" << m.vargridysize << "\n" << m.varfinemapxsize << "\n" << m.varfinemapysize << "\n";
           os << m.varfinemapxoffset << "\n" << m.varfinemapyoffset << "\n" << m.varcoarsemapxsize << "\n" << m.varcoarsemapysize << "\n" << m.varcoarsemapxoffset << "\n";
           os << m.varcoarsemapyoffset << "\n" << m.varcoarsemapscale << "\n" << m.desired_specnum << "\n" << m.lambda << "\n" << m.deme << "\n" << m.deme_sample<< "\n";
           os << m.spec << "\n" << m.sigma << "\n" << m.maxtime << "\n" << m.dPristine << "\n" << m. dForestTransform << "\n" << m.nu << "\n" << m.autocorrel_file << "\n";
           os << m.configs;
           return os;
       }
       
       friend istream& operator>>(istream& is, Mapvars& m) 
       { 
           is >> m.finemapfile >> m.coarsemapfile >> m.pristinefinemapfile >> m.pristinecoarsemapfile >> m.samplemaskfile ;
   //      cout << "test0" << endl;
           is >> m.the_task >>  m.vargridxsize >> m.vargridysize >> m.varfinemapxsize >> m.varfinemapysize ;
   //      cout << "test1" << endl;
   //      cout << "task: " << m.the_task << endl;
           is >> m.varfinemapxoffset >> m.varfinemapyoffset >> m.varcoarsemapxsize >> m.varcoarsemapysize >> m.varcoarsemapxoffset ;
   //      cout << "test2" << endl;
           is >> m.varcoarsemapyoffset >> m.varcoarsemapscale >> m.desired_specnum >> m.lambda >> m.deme >> m.deme_sample;
   //      cout << "test3" << endl;
           is >> m.spec >> m.sigma >> m.maxtime >> m.dPristine >> m. dForestTransform >> m.nu >> m.autocorrel_file;
   //      cout << "test4" << endl;
           //cout << "2" << endl;
           is >> m.configs;
   //      cout << "test5" << endl;
           //cout << "mate" << endl;
           return is;
       }
   };
   
   // Class which contains the Datamask object, telling us where to sample from within the habitat map.
   class Datamask
   {
   private:
       string inputfile; // the file to read in from
       bool bDefault;
   public:
       Matrix<bool> sample_mask; 
       Datamask()
       {
           bDefault = true;
       }
       
       void importDatamask(Mapvars& mapvarin)
       {
           inputfile = mapvarin.samplemaskfile;
   //      cout << "inputfile: " << inputfile;
           if(inputfile == "null")
           {
               bDefault = true;
           }
           else
           {
               sample_mask.SetSize(mapvarin.vargridysize,mapvarin.vargridxsize);
               bDefault = false;
               sample_mask.import(inputfile);
           }
       }
       
       bool getVal(long x, long y)
       {
           if(bDefault)
           {
               return true;
           }
           else
           {
               return sample_mask[y][x];
           }
       }
   };
   /************************************************************
                       MAP OBJECT
    ************************************************************/
    // Object containing both the maps (the coarse and fine version) and routines for easy setting up and switching between the different coordinate systems.
    class Map
    {
   private:
       // The map files which are read in (or generated if running with "null" as the map file".
       // Pristine maps are meant for before any deforestation occured, whereas the other maps are intended for modern day maps.
       // A linear transformation from modern to pristine maps is used, approaching the dForestTransform variable times the difference between the pristine and modern maps.
       // Once the dPristine number of generations has been reached, the map will jump to the pristine condition.
        Matrix<unsigned short> fine_map; // the finer grid for the area around the sample area.
        Matrix<unsigned short> pristine_fine_map; // the pristine finer map.
        Matrix<unsigned short> coarse_map; // the coarser grid for the wider zone.
        Matrix<unsigned short> pristine_coarse_map; // the pristine coarser map.
        Mapvars mapvars; // for importing and storing the simulation set-up options.
        long finexmin,fineymin,coarsexmin,coarseymin; // the minimum values for each dimension for offsetting.
        long finexmax,fineymax,coarsexmax,coarseymax; // the maximum values for each dimension for offsetting.
        long finexoffset, fineyoffset, coarsexoffset, coarseyoffset; // the offsetting of the map in FINE map units.
        int scale; // the scale of the coarse map compared with the smaller map.
        long xdim; // the length of the grid where the species start.
        long ydim; // the height of the grid where the species start.
        long deme;
        bool checksetdim; // for checking that the dimensions have been set before attempting to import the maps.
        double lambda; // for setting the movement cost through forest.
       
       double dUpdateTime; // the last time the map was updated, in generations.
       double dForestTransform; // the rate at which the forest transforms from the modern forest map to the pristine forest map. A value of 1 will give a smooth curve from the present day to pristine forest.
       double dPristine; // the number of generations at which point the forest becomes entirely pristine.
       double dCurrent; // the time the current map was updated.
       bool bPristine; // checks whether the simulation has already been set to the pristine state.
        
        string NextMap;
        unsigned int nUpdate; // the number of updates to have occured.
       
   public:
       Map()
       {
           checksetdim = false; // sets the check to false.
           bPristine = false;
           dCurrent = 0;
       }
       
       void setDims(Mapvars mapvarsin);
       
       bool checkMapExists();
       
       /********************************************
        * CALC MAP FUNCTIONS
        ********************************************/
        
        void calcFineMap() ;
       
       void calcPristineFineMap() ;
       
       void calcCoarseMap();
       
       void calcPristineCoarseMap();
       
       // Map setters
       void setTimeVars(double dPristinein, double dForestTransformin);
       
       
       void calcOffset();
       /********************************************
        * VALIDATE MAPS
        ********************************************/
       
       void validateMaps();
       
       /********************************************
        * CHANGE MAP FUNCTIONS
        ********************************************/
       
       void updateMap(double generation);
       
       bool isPristine()
       {
           return bPristine;
       }
       
       void setPristine(const bool &bPristinein)
       {
           bPristine = bPristinein;
       }
       // 
       /********************************************
        * GET VAL FUNCTIONS
        ********************************************/
        
        
       // Function for getting the val at a particular coordinate from either the coarse or fine map
       // altered to use the current generation as well to determine the value.
       unsigned short getVal(const double &x,const double &y,const long &xwrap,const long &ywrap, const double &dCurrentGen); 
   
       unsigned long getInitialCount(double dSample, Datamask& samplemask);
       
       /********************************************
        * CHECK MAP FUNCTIONS
        ********************************************/
        bool checkMap(const double &x,const double &y, const long &xwrap,const long &ywrap,const double generation);
        
        
        bool checkFine(const double &x,const double &y, const long &xwrap,const long &ywrap);
       
       
       void convertCoordinates(double &x, double &y, long &xwrap, long &ywrap);
       
       /********************************************
        * MAIN DISPERSAL FUNCTION
        ********************************************/
       void runDispersal(const double &dist, const double &angle, long &startx ,long  &starty , long &startxwrap, long &startywrap, bool &disp_comp, const double &generation);
       
       
       friend ostream& operator<<(ostream& os,const Map& r) 
       {
           os << r.mapvars << "\n" << r.finexmin << "\n" << r.finexmax << "\n" << r.coarsexmin << "\n" << r.coarsexmax ;
           os << "\n" << r.fineymin << "\n" << r.fineymax << "\n" << r.coarseymin << "\n" << r.coarseymax << "\n";
           os << r.finexoffset << "\n" << r.fineyoffset << "\n" << r.coarsexoffset << "\n" << r.coarseyoffset << "\n";
           os << r.scale << "\n" << r.xdim << "\n" << r.ydim << "\n" << r.deme << "\n" << r.checksetdim << "\n" << r.lambda << "\n";
           os << r.dUpdateTime << "\n" << r.dForestTransform << "\n" << r.dPristine << "\n" << r.dCurrent << "\n" << r.bPristine << "\n" << r.NextMap << "\n" << r.nUpdate << "\n";
           return os;
       }
   
       friend istream& operator>>(istream& is, Map& r) 
       {
           //double temp1,temp2;
           //is << m.numRows<<" , "<<m.numCols<<" , "<<endl;
           is >> r.mapvars >> r.finexmin >> r.finexmax >> r.coarsexmin >> r.coarsexmax >> r.fineymin >> r.fineymax >> r.coarseymin >> r.coarseymax;
           is >> r.finexoffset >> r.fineyoffset >> r.coarsexoffset >> r.coarseyoffset >> r.scale >> r.xdim >> r.ydim >> r.deme >> r.checksetdim >> r.lambda;
           is >> r.dUpdateTime >> r.dForestTransform >> r.dPristine >> r.dCurrent >> r.bPristine >> r.NextMap >> r.nUpdate;
           r.calcFineMap();
           r.calcCoarseMap();
   //      cout << "mapsample: " << r.mapvars.samplemaskfile << endl;
           r.calcPristineFineMap();
           r.calcPristineCoarseMap();
           return is;
       }
       
       void printVars()
       ;
       
       void clearMap()
       ;
    };
    #endif
    


