.. _program_listing_file_Setup.cpp:

Program Listing for File Setup.cpp
========================================================================================

- Return to documentation for :ref:`file_Setup.cpp`

.. code-block:: cpp

   //This file is part of NECSim project which is released under BSD-3 license.
   //See file **LICENSE.txt** or visit https://opensource.org/licenses/BSD-3-Clause) for full license details.
   // 
   #include "Setup.h"
   
   // Global variables
   // store the log file name for access anywhere.
   string log_name = "null"; 
   // the old stdout 
   int saved_stdout;
   #ifndef verbose
   
   void openLogFile(bool append)
   {
       // If verbose mode is not defined, we output to a log file instead of to the terminal
       // Get the current time
       saved_stdout = dup(fileno(stdout));
       //dup2(stdout, 1);
       auto t = time(nullptr);
       auto tm = *localtime(&t);
       // get the time string
       ostringstream oss;
       oss << std::put_time(&tm, "%d-%m-%Y-%H:%M:%S");
       if(log_name == "null")
       {
           log_name = "Logs/Log_"+oss.str() + ".txt";
       }
       // Check that the Log folder exists, and create if necessary.
       if(!boost::filesystem::exists("Logs"))
       {
           if(!boost::filesystem::create_directory("Logs"))
           {
               cerr << "Cannot create log directory (check write access) - defaulting to terminal." << endl;
           }
       }
       if(boost::filesystem::exists("Logs"))
       {
           // Open the log file for writing to.
           FILE * tmpfileptr;
           if(append)
           {
               tmpfileptr = freopen(log_name.c_str(), "a", stdout);
           }
           else
           {
               tmpfileptr = freopen(log_name.c_str(), "w", stdout);
           }
           if(stdout == nullptr || tmpfileptr == nullptr)
           {
               cerr << "Cannot create log file (check write access) - defaulting to terminal." << endl;
               dup2(saved_stdout, fileno(stdout));
               close(saved_stdout);
           }
       }
       //cerr<< "logfile2 : " << log_name << endl;
   }
   #endif /* verbose */
   
   // 
   bool checkSims(int the_task,int the_seed,string outdirect)
   {
       cout << "Checking for unfinished simulations..." << flush;
       ifstream out;
       string file_to_open;
   //  char file_to_open[100];
   //  sprintf (file_to_open, "%s/Pause/Data_%i.csv",outdirect,int(the_task));
       file_to_open = outdirect + string("/Pause/Dump_active_") + to_string((unsigned long long)the_task)+"_"+to_string((unsigned long long)the_seed) + string(".csv");
       out.open(file_to_open);
       if(out.good())
       {
           cout << "done!" << endl << "File found containing unfinished simulations." << endl;
           return(true);
       }
       else
       {
           cout << "done!" << endl << "No files found containing unfinished simulations." << endl;
           return(false);
       }
   }
   
   
   void checkFolders(string sFineMap, string sCoarseMap, string sFineMapPristine, string sCoarseMapPristine, string sOutputFolder,string sSampleMask)
   {
       cout << "Checking folder existance..." << flush;
       bool bFineMap, bCoarseMap, bFineMapPristine, bCoarseMapPristine, bOutputfolder, bSampleMask;
       try
       {
           bFineMap = doesExistNull(sFineMap);
       }
       catch(Fatal_Exception& fe)
       {
           cerr << fe.what() << endl;
           bFineMap = false;
       }
       try
       {
           bCoarseMap = doesExistNull(sCoarseMap);
       }
       catch(Fatal_Exception& fe)
       {
           cerr << fe.what() << endl;
           bCoarseMap = false;
       }
       try
       {
           bFineMapPristine = doesExistNull(sFineMapPristine);
       }
       catch(Fatal_Exception& fe)
       {
           cerr << fe.what() << endl;
           bFineMapPristine = false;
       }
       try
       {
           bCoarseMapPristine = doesExistNull(sCoarseMapPristine);
       }
       catch(Fatal_Exception& fe)
       {
           cerr << fe.what() << endl;
           bCoarseMapPristine = false;
       }
       if(sOutputFolder != "null")
       {
           try
           {
               bOutputfolder = doesExist(sOutputFolder);
           }
           catch(runtime_error &re)
           {
               cerr << "Output folder does not exist... creating..." << flush;
               bOutputfolder = boost::filesystem::create_directory(sOutputFolder);
               if( bOutputfolder)
               {
                   cerr << "done!" << endl;
               }
               else
               {
                   cerr << endl << re.what() << endl;
               }
           }
       }
       else
       {
           throw Fatal_Exception("ERROR_MAIN_009: FATAL. Output folder cannot be null.");
       }
       try
       {
           bSampleMask = doesExistNull(sSampleMask);
       }
       catch(Fatal_Exception& fe)
       {
           cerr << fe.what() << endl;
           bSampleMask = false;
       }
       if(bFineMap && bCoarseMap && bFineMapPristine && bCoarseMapPristine && bOutputfolder && bSampleMask)
       {
           cout << "\rChecking folder existance...done!                                                                " << endl;
           return;
       }
       else
       {
           throw Fatal_Exception();
       }
       
   }
   
   void runAsDefault(vector<string> &comargs)
   {
       cout << "Setting default variables on small grid..." << flush;
       comargs.push_back("-f");
       comargs.push_back("1");
       comargs.push_back("10");
       comargs.push_back("10");
       comargs.push_back("null");
       comargs.push_back("150");
       comargs.push_back("150");
       comargs.push_back("25");
       comargs.push_back("25");
       comargs.push_back("null");
       comargs.push_back("2000");
       comargs.push_back("2000");
       comargs.push_back("500");
       comargs.push_back("500");
       comargs.push_back("100");
       comargs.push_back("Default/");
       comargs.push_back("0.000009");
       comargs.push_back("4");
       comargs.push_back("1");
       comargs.push_back("1");
       comargs.push_back("4");
       comargs.push_back("1");
       comargs.push_back("0");
       comargs.push_back("100");
       comargs.push_back("null");
       comargs.push_back("null");
       comargs.push_back("0.5");
       comargs.push_back("20.0");
       comargs.push_back("1.0");
       comargs.push_back("null");
       comargs.push_back("null");
       comargs.push_back("0.000009");
       cout << "done!" << endl;
   }
   void runLarge(vector<string> &comargs)
   {
       cout << "Setting default variables on large grid..." << flush;
       comargs.push_back("-f");
       comargs.push_back("1");
       comargs.push_back("500");
       comargs.push_back("500");
       comargs.push_back("null");
       comargs.push_back("500");
       comargs.push_back("500");
       comargs.push_back("0");
       comargs.push_back("0");
       comargs.push_back("null");
       comargs.push_back("100");
       comargs.push_back("100");
       comargs.push_back("2500");
       comargs.push_back("2500");
       comargs.push_back("100");
       comargs.push_back("Default/");
       comargs.push_back("0.00001");
       comargs.push_back("8");
       comargs.push_back("10");
       comargs.push_back("1");
       comargs.push_back("3600");
       comargs.push_back("1");
       comargs.push_back("1");
       comargs.push_back("50000");
       comargs.push_back("null");
       comargs.push_back("null");
       comargs.push_back("0.5");
       comargs.push_back("20.0");
       comargs.push_back("1.0");
       comargs.push_back("null");
       comargs.push_back("null");
       comargs.push_back("0.000009");
       cout << "done!" << endl;
   }
   
   void runXL(vector<string> &comargs)
   {
       cout << "Setting default variables on large grid..." << flush;
       comargs.push_back("-f");
       comargs.push_back("1");
       comargs.push_back("6000");
       comargs.push_back("6400");
       comargs.push_back("null");
       comargs.push_back("34000");
       comargs.push_back("28000");
       comargs.push_back("8800");
       comargs.push_back("14800");
       comargs.push_back("null");
       comargs.push_back("24000");
       comargs.push_back("20000");
       comargs.push_back("10320");
       comargs.push_back("8080");
       comargs.push_back("10");
       comargs.push_back("Default/");
       comargs.push_back("0.0000001");
       comargs.push_back("2");
       comargs.push_back("49");
       comargs.push_back("0.2");
       comargs.push_back("21600");
       comargs.push_back("1");
       comargs.push_back("3");
       comargs.push_back("600");
       comargs.push_back("null");
       comargs.push_back("null");
       comargs.push_back("0");
       comargs.push_back("2.2");
       comargs.push_back("1.0");
       comargs.push_back("null");
       comargs.push_back("null");
       comargs.push_back("0.000009");
       cout << "done!" << endl;
   }
   
   
   // 
   // 
   void removeComOption(int &argc, vector<string> &comargs)
   {
       // stupidly long list of possible arguments, but can't think of a better way to check this.
       if(comargs[1] == "-d" || comargs[1] == "-D" ||  comargs[1] == "-dl" ||  comargs[1] == "-dL" ||  comargs[1] == " -Dl" ||  comargs[1] == "-DL" ||
           comargs[1] == "-dx" || comargs[1] == "-dX" ||  comargs[1] == "-DX" ||  comargs[1] == " -Dx" ||  comargs[1] == "-c" ||  comargs[1] == "-C" ||
           comargs[1] == "-config" ||  comargs[1] == "-Config" || comargs[1] == "-f" || comargs[1] == "-h" || comargs[1] == "-H" || comargs[1] == "-F)")
       {
           comargs.erase(comargs.begin() + 1);
           argc --;
       }
       return;
   }
   
   vector<string> importConfig(string configfile)
   {
       ConfigOption conf;
       conf.setConfig(configfile,true);
       conf.parseConfig();
       vector<string> sections = conf.getSections();
       vector<string> comargs;
       bool maincheck = false;
       for(unsigned i = 0; i < sections.size(); i++)
       {
           if(sections[i] == "main")
           {
               maincheck = true;
               break;
           }
       }
       if(maincheck)
       {
           comargs.push_back(conf.getSectionOptions("main", "seed"));
           comargs.push_back(conf.getSectionOptions("main", "job_type"));
           comargs.push_back(conf.getSectionOptions("main", "map_config"));
           comargs.push_back(conf.getSectionOptions("main", "output_directory"));
           comargs.push_back(conf.getSectionOptions("main", "min_spec_rate"));
           comargs.push_back(conf.getSectionOptions("main", "sigma"));
           comargs.push_back(conf.getSectionOptions("main", "nu"));
           comargs.push_back(conf.getSectionOptions("main", "deme"));
           comargs.push_back(conf.getSectionOptions("main", "sample_size"));
           comargs.push_back(conf.getSectionOptions("main", "max_time"));
           comargs.push_back(conf.getSectionOptions("main", "lambda"));
           comargs.push_back(conf.getSectionOptions("main", "time_config"));
           comargs.push_back(conf.getSectionOptions("main", "min_species"));
           if(conf.hasSection("spec_rates"))
           {
               vector<string> spec_rates = conf.getSectionValues("spec_rates");
               for(unsigned i = 0; i < spec_rates.size(); i ++)
               {
                   comargs.push_back(spec_rates[i]);
               }
           }
           return(comargs);
       }
       else
       {
           throw Config_Exception("Could not find main section in config file. Aborting");
       }
       
   }
   
   bool parseArgs(int &argc, vector<string> &comargs)
   {
       bool bCheckUser=false;
       if(argc==1)
       {
           comargs.push_back("-e");
           if(comargs.size()!=2)
           {
               cerr << "ERROR_MAIN_010: Incorrect command line parsing." << endl;
           }
       }
       if(comargs[1]=="-h"||comargs[1]=="-H"||argc==1||comargs[1]=="-help" || comargs[1] == "-e")
       {
           // Sort out piping to terminal if verbose has not been defined.
           #ifndef verbose
           dup2(saved_stdout, fileno(stdout));
           //close(saved_stdout);
           #endif
           if(argc==1)
           {
               cout << "No arguments supplied: expected 30. These are: " << endl;
           }
           else
           {
               cout << "30 command line arguments are required. These are: " << endl;
           }
           cout << "1: the seed for the simulation." << endl;
           cout << "2: the simulation task (for file reference)." << endl;
           cout << "3: the map config file." << endl;
           cout << "4: the output directory." << endl;
           cout << "5: the minimum speciation rate." << endl;
           cout << "6: the dispersal sigma value." << endl;
           cout << "7: the dispersal nu value." << endl;
           cout << "8: the deme size." << endl;
           cout << "9: the deme sample size." << endl;
           cout << "10: the maximum simulation time (in seconds)." << endl;
           cout << "11: the lambda value for moving through non-habitat." << endl;
           cout << "12: the temporal sampling file containing tab-separated generation values for sampling points in time (null for only sampling the present)." << endl;
           cout << "13: the minimum number of species known to exist. (Currently has no effect)." << endl;
           cout << "14 onwards: speciation rates to apply after simulation." << endl;
           cout << "There is also a full-command line mode, (flag -f), which allows for more options to be specified via the command line." << endl;
           cout << "Would you like to see these options? Y/N: " << flush;
           string fullopts;
           cin >> fullopts;
           if(fullopts == "Y" || fullopts == "y")
           {
               cout << "1: the task_iter used for setting the seed." << endl;
               cout << "2: the sample grid x dimension." << endl;
               cout << "3: the sample grid y dimension." << endl;
               cout << "4: the fine map file relative path." << endl;
               cout << "5: the fine map x dimension." << endl;
               cout << "6: the fine map y dimension." << endl;
               cout << "7: the fine map x offset." << endl;
               cout << "8 the fine map y offset." << endl;
               cout << "9: the coarse map file relative path." << endl;
               cout << "10: the coarse map x dimension." << endl;
               cout << "11: the coarse map y dimension." << endl;
               cout << "12: the coarse map x offset." << endl;
               cout << "13: the coarse map y offset." << endl;
               cout << "14: the scale of the coarse map compared to the fine (10 means resolution of coarse map = 10 x resolution of fine map)." << endl;
               cout << "15: the output directory." << endl;
               cout << "16: the speciation rate." << endl;
               cout << "17: the dispersal distance (sigma)." << endl;
               cout << "18: the deme size." << endl;
               cout << "19: the deme sample size (as a proportion of deme size)." << endl;
               cout << "20: the time to run the simulation (in seconds)." << endl;
               cout << "21: lambda - the relative cost of moving through non-forest." << endl;
               cout << "22: the_task - for referencing the specific task later on." << endl;
               cout << "23: the minimum number of species the system is known to contain." << endl;
               cout << "24: the pristine fine map file to use." << endl;
               cout << "25: the pristine coarse map file to use." << endl;
               cout << "26: the rate of forest change from pristine." << endl;
               cout << "27: the time (in generations) since the pristine forest was seen." << endl;
               cout << "28: the dispersal nu value (the width of the kernel." << endl;
               cout << "29: the sample mask, with binary 1:0 values for areas that we want to sample from. If this is not provided then this will default to mapping the entire grid." << endl;
               cout << "30: a file containing a tab-separated list of sample points in time (in generations). If this is null then only the present day will be sampled." << endl;
               cout << "31-onwards: speciation rates to be applied at the end of the simulation" << endl;
               cout << "Note that using the -f flag prohibits more than one two historic maps being used." << endl;
           }
           cout << "Would you like to run with the default settings? (Y/N)" << flush;
           string cDef;
           cin >> cDef;
           if(cDef == "Y"||cDef=="y")
           {
               bCheckUser = true;
           }
           else
           {
               bCheckUser = false;
               cout << "Possible command line arguments: " << endl;
               cout << "-h/-help: Show the help file." << endl;
               cout << "-d/-D: Run with default small parameters." << endl;
               cout << "-dl/-DL: Run with default large parameters." << endl;
               cout << "-dx/-DX: Run with the default very large parameters." << endl;
               cout << "-c/-config: Run with the supplied config file." << endl;
               exit(1); // exit the program right away as there is no need to continue if there is no simulation to run!
           }
           #ifndef verbose
           openLogFile(true);
           #endif
       }
       
       if(comargs[1] == "-r" || comargs[1] == "-R" || comargs[1] == "-resume")
       {
           comargs[1] = "resuming";
           if(argc != 6)
           {
               cerr << "Incorrect number of parameters provided for resuming simulation. Expecting:" << endl;
               cerr << "1: -r flag" << endl;
               cerr << "2: the folder containing the paused simulation (should hold a 'Pause' folder)" << endl;
               cerr << "3: the simulation seed" << endl;
               cerr << "4: the simulation task" << endl;
               cerr << "5: the time to run the simulation for" << endl;
               exit(-1);
           }
           else
           {
               if(!checkSims(stoi(comargs[4]), stoi(comargs[3]), comargs[2]))
               {
                   string msg = "ERROR_MAIN_015: FATAL. Cannot find simulation to resume from. ";
                   msg += "Check path to simulation output, seed and task numbers.";
                   throw Main_Exception(msg);
               }
               return(false);
           }
       }
       // Import the default parameters if required.
       if(comargs[1]=="-d"||comargs[1]=="-D"||bCheckUser)
       {
           runAsDefault(comargs);
           bCheckUser=true;
       }
       if(comargs[1]=="-dl"||comargs[1]=="-DL"||comargs[1]=="-dL"||comargs[1]=="-Dl")
       {
           runLarge(comargs);
           bCheckUser = true;
       }
       if(comargs[1]=="-dx"||comargs[1]=="-dX"||comargs[1]=="-DX"||comargs[1]=="-Dx")
       {
           runXL(comargs);
           bCheckUser = true;
       }
       bool bConfig = false;
       if(comargs[1]=="-c"||comargs[1]=="-C"||comargs[1]=="-config"|| comargs[1]=="-Config")
       {
           // Check that the config file is supplied.
           if(argc!=3)
           {
               throw Main_Exception("ERROR_MAIN_011: FATAL. -c or -config used to attempt import from config file, but no config file provided.");
           }
           bConfig = true;
           cout << "Importing values from config file " << comargs[2] << "...." << flush;
           try
           {
               vector<string> tmp_comargs = importConfig(comargs[2]);
               vector<string> tmp2_comargs;
               tmp2_comargs.push_back(comargs[0]);
               tmp2_comargs.push_back(comargs[1]);
               tmp2_comargs.insert(tmp2_comargs.end(), tmp_comargs.begin(), tmp_comargs.end());
               comargs = tmp2_comargs;
   //          for(unsigned i = 0; i < tmp2_comargs.size(); i++)
   //          {
   //              cout << tmp2_comargs[i] << endl;
   //          }
               argc = comargs.size();
   //          argc = conf.importConfig(comargs);
           }
           catch(Config_Exception& c_e)
           {
               cerr << c_e.what() << endl;
               throw Fatal_Exception(); 
           }
           //cout << "test" << endl;
           //cout << endl << comargs[0] << endl;
           cout << "done!" << endl;
       }
       bool bFullMode = false;
       if(comargs[1] == "-f" || comargs[2] == "-f")
       {
           cout << "Full command-line mode enabled." << endl;
           bFullMode = true;
       }
       removeComOption(argc, comargs);
       removeComOption(argc, comargs);
       if(argc > 12 && !bFullMode)
       {
           return(false);
       }
       if(argc<31&&!bCheckUser &&!bConfig)
       {
           string err = "ERROR_MAIN_000: FATAL.  Incorrect arguments supplied (" + to_string((long long)argc-1) + " supplied; expected 30).";
           throw Main_Exception(err);
           // note argc-1 which takes in to account the automatic generation of one command line argument which is the number of arguments.
       }
       argc = comargs.size();
       return(true);
   }
   
   void getSR(int argc,const  vector<string> & comargs, Tree & t)
   {
       if(argc>31)
       {
           unsigned int iMultiNumber = argc - 31;
           vector<double> dSpecArray;
           for(int i =31;i<argc;i++)
           {
               dSpecArray.push_back(stod(comargs[i]));
           }
           cout << "Speciation rate" << flush;
           if(dSpecArray.size() > 1)
           {
               cout << "s are: " << flush;
           }
           else
           {
               cout << " is: " << flush;
           }
           for(unsigned int i=0;i<iMultiNumber;i++)
           {
               cout << dSpecArray[i] << flush;
               if(i +1 == iMultiNumber)
               {
                   cout << "." << endl;
               }
               else
               {
                   cout << ", " << flush;
               }
           }
           // Now check to make sure repeat speciation rates aren't done twice (this is done to avoid the huge number of errors SQL throws if you try to add identical data
           double dUniqueSpec[iMultiNumber];
           unsigned long spec_upto = t.sortData();
           t.sqlCreate();
           for(unsigned int i =0;i<iMultiNumber;i++)
           {
               bool bCont = true;
               for(unsigned int j =0;j<iMultiNumber;j++)
               {
                   if(dUniqueSpec[j]==dSpecArray[i])
                   {
                       bCont = false;
                   }
               }
               if(bCont)
               {
                   vector<double> temp_sampling = t.getTemporalSampling();
                   for(unsigned k = 0; k < temp_sampling.size(); k++)
                   {
                       try
                       {
                           cout << "Calculating generation " << temp_sampling[k] << endl;
                           t.applySpecRates(dSpecArray[i], temp_sampling[k]);
                       }
                       catch(const std::exception & e)
                       {
                           cout << e.what() << endl;
                       }
                   }
               }
               else
               {
                   cout << "Repeat speciation rate... ignoring" << endl;
               }
           }
           t.outputData(spec_upto);
       }
       else
       {
           t.sqlCreate();
           t.outputData();
           return;
       }
   }
   
   
   bool doesExist(string testfile)
   {
       if(boost::filesystem::exists(testfile))
       {
               cout << "\rChecking folder existance..." << testfile << " exists!               " << endl;
           return true;
       }
       else
       {
           cout << testfile << " does not exist!               " << endl;
           throw runtime_error(string("ERROR_MAIN_008: FATAL. Input or output folder does not exist: " + testfile + "."));
       }
       return false;
   }
   
   bool doesExistNull(string testfile)
   {
       if(testfile=="null")
       {
           return(true);
       }
       else
       {
           return(doesExist(testfile));
       }
   }


