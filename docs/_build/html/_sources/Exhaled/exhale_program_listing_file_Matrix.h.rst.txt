.. _program_listing_file_Matrix.h:

Program Listing for File Matrix.h
========================================================================================

- Return to documentation for :ref:`file_Matrix.h`

.. code-block:: cpp

   //This file is part of NECSim project which is released under BSD-3 license.
   //See file **LICENSE.txt** or visit https://opensource.org/licenses/BSD-3-Clause) for full license details.
   // Matrix.cpp version 1.12
   // Author - James Rosindell Leeds University, modified to include additional functionality by Samuel Thompson, Imperial College London
   // but with large usage of reference http://www.devarticles.com/c/a/Cplusplus/Operator-Overloading-in-C-plus/1
   //
   # define version1_11
   // # define version1_1
   
   #ifndef MATRIX
   # define MATRIX
   # define null 0
   //# include "stdiostream.h"
   # include <stdio.h>
   #include <iostream>
   #include <sstream>
   #include <fstream>
   #include <cstdlib>
   #include <cstring>
   #include <stdexcept>
   //#define NDEBUG // uncomment this to disable all asserts.
   #include <assert.h>
   #ifdef use_csv
   #include<cmath>
   #include <stdexcept>
   #include "fast-cpp-csv-parser/csv.h"
   #endif
   #ifdef with_gdal
   #include <gdal_priv.h>
   #include <cpl_conv.h> // for CPLMalloc()
   #endif
   #include <stdint.h>
   using namespace std;
   
   // Array of data sizes for importing tif files.
   const int gdal_data_sizes[] = {0,8,16,16,32,32,32,64};
   
   // Template class Row
   template<class T>
   class Row
   {
       // private variables
   private:
       unsigned long numCols; // stores the number of columns in the row
       T* row; // an array to store the row
   
       // public variables
   public:
   
       Row(int cols = 0):row(0)
       {
           SetRowSize(cols);
       }
   
       ~Row()
       {
           delete[] row;
       }
   
       Row(const Row &r):row(0)
       {
           SetRowSize(r.numCols);
           for(unsigned int i=0; i<numCols; i++)
           {
               row[i]=r.row[i];
           }
       }
   
       // setter for row size
   
       void SetRowSize(unsigned long n)
       {
           if(row)
           {
               delete[] row;
           }
           if(n>0)
           {
               row=new T[n];
               // FIX THIS LATER!!!!!  memset(row,0,sizeof(T)*n/sizeof(char));
               // The call to memset() just zeroes out the array after figuring out how many bytes the row uses and
               // dividing this by the size of character, because memset() works in terms of chars.
           }
           else
           {
               row=0;
           }
           numCols=n;
       }
   
       void changeSize(unsigned long n)
       {
           try
           {
               T* tmprow = new T[n];
               for(unsigned int i =0; i < numCols; i++)
               {
                   tmprow[i] = row[i];
               }
               delete[] row;
               row = tmprow;
               //      tmprow = NULL;
           }
           catch(bad_alloc & ba)
           {
               cerr << ba.what() << endl;
               cerr << "numCols: " << numCols << endl;
               cerr << "n: " << n << endl;
               exit(EXIT_FAILURE);
           }
           numCols = n;
       }
   
       unsigned long size()
       {
           return numCols;
       }
   
       T& operator[](unsigned long column)
       {
           // assert(column<numCols);
           // check we are within bounds
   
   # ifdef version1_1
           if(column >= numCols)
           {
               column = numCols -1;
           }
           if(column < 0)
           {
               column = 0;
           }
   # endif
   # ifdef version1_11
           if(column <0 || column >= numCols)
           {
               string err = "ERROR_MAIN_013b: Tried to call an indices that was out of range of the row. Check row size definition. numCols: " + to_string((long long) numCols) + " index: " + to_string((long long) column);
               throw out_of_range(err);
           }
   //      if (column < 0)
   //        {
   //          column = -1 * column;
   //          column = column % numCols;
   //          column = numCols - column;
   //        }
           column = column % numCols;
   # endif
   
           return row[column];
       }
   
       // Overloading = operator
       Row&  operator=(const Row& r)
       {
           SetRowSize(r.numCols);
           for(unsigned int i=0; i<numCols; i++)
           {
               row[i]=r.row[i];
           }
   
           //we return a reference, but this time it's a reference to itself.
           //First we set the size of the current row equal to that of the source row, then we copy its values.
           //There is an important note here. Notice that I'm using [] on the primitive T array itself
           //--NOT the overloaded []s of Row. Remember that Row's [] returns a reference, thus if we had written row[i]=r[i],
           //we would get a row that references the exact same data in memory, so that when we changed one the other would change
           //--this isn't what we want at all, so we need to access the raw data in the Row class.
   
           return *this;
       }
   
       friend ostream& operator<<(ostream& os,const Row& r)
       {
           //os << m.numRows<<" , "<<m.numCols<<" , "<<endl;
           os << r.numCols << ",";
           for(unsigned int c=0; c<r.numCols; c++)
           {
               os << r.row[c] << ",";
           }
           return os;
       }
   
       friend istream& operator>>(istream& is, Row& r)
       {
           //os << m.numRows<<" , "<<m.numCols<<" , "<<endl;
           char delim;
           int n;
           is >> n;
           r.SetRowSize(n);
           is >> delim;
           for(unsigned int c=0; c<r.numCols; c++)
           {
               is >> r.row[c];
               is >> delim;
           }
           return is;
       }
   };
   
   
   // Template class Matrix as an array of rows
   template<class T>
   class Matrix
   {
   
   protected:
   
       // number of rows and columns
       unsigned long numCols, numRows;
       // a matrix is an array of rows
       Row<T>* matrix;
   
   public:
   
       Matrix(int rows=0, int cols=0): matrix(null)
       {
           SetSize(rows,cols);
       }
   
       Matrix(const Matrix& m): matrix(null)
       {
           SetSize(m.numRows,m.numCols);
           for(int r=0; r<numRows; r++)
               matrix[r]=Row<T>(m.matrix[r]);//assign to primitive array, NOT overloaded []--to get a copy
       }
   
       // HAD TO FIX NASTY MEMEORY LEAK HERE SINCE DOWLOADING!!
       ~Matrix()
       {
           delete[] matrix;
   
       }
   
       void SetSize(int rows, int cols)
       {
           if(matrix)
           {
               delete[]matrix;
               //if (rows) delete[]matrix; - was in original code - seems silly so changed to the above
           }
           if(cols > 0 && rows >0)
           {
               matrix=new Row<T>[rows];
               for(int i=0; i<rows; i++)
               {
                   matrix[i].SetRowSize(cols);
               }
           }
           else
           {
               rows=null;
           }
           numCols=cols;
           numRows=rows;
       }
   
       int GetCols() const
       {
           return numCols;
       }
   
       int GetRows()  const
       {
           return numRows;
       }
   
       // This whole piece so far follows similarly to that of the Row Class
       // now we go on to overload all the operators
   
       Row<T>& operator[](unsigned long index)
       {
   
           //assert(index<numRows);
   # ifdef version1_1
           if(index >= numRows)
           {
               index = numRows -1;
           }
           if(index < 0)
           {
               index = 0;
           }
   # endif
   # ifdef version1_11
   //      if (index < 0)
   //      {
   //              index = -1 * index;
   //              index = index % numRows;
   //              index = numRows - index;
   //      }
   //      These asserts were lazy - changed to exceptions and proper error reporting now.
   //      assert(index<numRows && "out of range - index greater than the number of rows");
   //      assert(index>=0 && "out of range - index less than 0");
           if(index <0 || index >= numRows)
           {
               string err = "ERROR_MAIN_013: Tried to call an indices that was out of range of the matrix. Check matrix size definition. numRows: " + to_string((long long) numRows) + " index: " + to_string((long long) index);
               throw out_of_range(err);
           }
           index = index % numRows;
   # endif
   
           return matrix[index];
       }
       Matrix& operator=(const Matrix& m)
       {
           SetSize(m.numRows,m.numCols);
           for(unsigned long r=0; r<numRows; r++)
           {
               matrix[r]=Row<T>(m.matrix[r]);
               //assign to primitive array, NOT overloaded []--to get a copy
           }
           return *this;
       }
   
   
       const Matrix operator+(const Matrix& m)
       {
           //Since addition creates a new matrix, we don't want to return a reference, but an actual matrix object.
   
           //assert(numCols==m.numCols && numRows==m.numRows);
           int newnumcols , newnumrows ;
           if(numCols > m.numCols)
           {
               newnumcols = m.numCols;
           }
           else
           {
               newnumcols = numCols;
           }
           if(numRows > m.numRows)
           {
               newnumrows = m.numRows;
           }
           else
           {
               newnumrows = numRows;
           }
   
           Matrix result(newnumrows,newnumcols);
           for(int r=0; r<newnumrows; r++)
           {
               for(int c=0; c<newnumcols; c++)
               {
                   result[r][c]=matrix[r][c]+m.matrix[r][c];
               }
           }
           return result;
       }
   
       const Matrix operator-(const Matrix& m)
       {
   
           //assert(numCols==m.numCols && numRows==m.numRows);
           int newnumcols , newnumrows ;
           if(numCols > m.numCols)
           {
               newnumcols = m.numCols;
           }
           else
           {
               newnumcols = numCols;
           }
           if(numRows > m.numRows)
           {
               newnumrows = m.numRows;
           }
           else
           {
               newnumrows = numRows;
           }
   
           Matrix result(newnumrows,newnumcols);
           for(int r=0; r<newnumrows; r++)
           {
               for(int c=0; c<newnumcols; c++)
               {
                   result[r][c]=matrix[r][c]-m.matrix[r][c];
               }
           }
           return result;
       }
   
       Matrix& operator+=(const Matrix& m)
       {
           // don't want to create a new object
           // just add whatever is currently in it to the other matrix, and return a reference to itself:
   
           //assert(numCols==m.numCols && numRows==m.numRows);
           int newnumcols , newnumrows ;
           if(numCols > m.numCols)
           {
               newnumcols = m.numCols;
           }
           else
           {
               newnumcols = numCols;
           }
           if(numRows > m.numRows)
           {
               newnumrows = m.numRows;
           }
           else
           {
               newnumrows = numRows;
           }
   
           for(int r=0; r<newnumrows; r++)
           {
               for(int c=0; c<newnumcols; c++)
               {
                   matrix[r][c]+=m.matrix[r][c];
               }
           }
           return *this;
       }
   
   
       Matrix& operator-=(const Matrix& m)
       {
           // don't want to create a new object
           // just subtractthe other matrix from whatever is currently in it, and return a reference to itself:
   
           //assert(numCols==m.numCols && numRows==m.numRows);
           int newnumcols , newnumrows ;
           if(numCols > m.numCols)
           {
               newnumcols = m.numCols;
           }
           else
           {
               newnumcols = numCols;
           }
           if(numRows > m.numRows)
           {
               newnumrows = m.numRows;
           }
           else
           {
               newnumrows = numRows;
           }
   
           for(int r=0; r<newnumrows; r++)
           {
               for(int c=0; c<newnumcols; c++)
               {
                   matrix[r][c]-=m.matrix[r][c];
               }
           }
           return *this;
       }
   
       const Matrix operator*(const double s)
       {
           Matrix result(numRows,numCols);
           for(int r=0; r<numRows; r++)
           {
               for(int c=0; c<numCols; c++)
               {
                   result[r][c]=matrix[r][c]*s;
               }
           }
           return result;
       }
   
       const Matrix operator*(Matrix& m)
       {
           //assert(numCols==m.numRows);
           int newnumcols;
           if(numCols > m.numRows)
           {
               newnumcols = m.numRows;
           }
           else
           {
               newnumcols = numCols;
           }
   
           Matrix result(numRows,m.numCols);
           for(int r=0; r<numRows; r++)
           {
               for(int c=0; c<m.numCols; c++)
               {
                   for(int i=0; i<newnumcols; i++)
                   {
                       result[r][c]+=matrix[r][i]*m[i][c];
                   }
               }
           }
           return result;
       }
   
   
       // The streaming operators << and >> allow your object to be saved and restored from any
       // stream, be it console, network, or file.
       // There is a slight additional challenge with these operators because we must allow the stream access to our object's private data.
       // Therefore, these functions must be declared as friends inside the Matrix class.
   
       friend ostream& operator<<(ostream& os,const Matrix& m)
       {
           //os << m.numRows<<" , "<<m.numCols<<" , "<<endl;
           for(unsigned long r=0; r<m.numRows; r++)
           {
               for(unsigned long c=0; c<m.numCols; c++)
               {
                   os << m.matrix[r][c] << ",";
               }
               os << "\n";
           }
           return os;
       }
   
       friend istream& operator>>(istream& is, Matrix& m)
       {
           //is << m.numRows<<" , "<<m.numCols<<" , "<<endl;
           char delim;
           for(unsigned long r=0; r<m.numRows; r++)
           {
   //          string line;
   //          getline(is, line);
   //          if ( !is.good() )
   //          {
   //              break;
   //          }
   //          stringstream iss(line);
   //
   //          for (int c = 0; c < m.numRows; c++)
   //          {
   //              std::string val;
   //              std::getline(iss, val, ',');
   //              if ( !iss.good() )
   //                  break;
   //
   //              std::stringstream convertor(val);
   //              convertor >> m.matrix[r][c];
   //          }
               for(unsigned long c=0; c<m.numCols; c++)
               {
                   is >> m.matrix[r][c];
                   is >> delim;
               }
           }
           return is;
       }
   
       bool symmetric()
       {
           bool result = true;
           for(int c=0; c<numCols; c++)
           {
               for(int r=0; r<c+1; r++)
               {
                   if(matrix[r][c] != matrix[c][r])
                   {
                       result = false;
                       break;
                   }
               }
           }
           return result;
       }
   
       void setValue(const unsigned long &x, const unsigned long &y, char* value,const double & t)
       {
           matrix[y][x] = atof(value);
           return;
       }
   
       void setValue(const unsigned long &x, const unsigned long &y, char* value, const char & t)
       {
           matrix[y][x] = *value;
       }
   
       void setValue(const unsigned long &x, const unsigned long &y, char* value, const int8_t & t)
       {
           matrix[y][x] = *value;
       }
   
       void setValue(const unsigned long &x, const unsigned long &y, char* value, const uint8_t & t)
       {
           matrix[y][x] = *value;
       }
   
       void setValue(const unsigned long &x, const unsigned long &y, char* value,const bool & t)
       {
           matrix[y][x] = bool(atoi(value));
           return;
       }
   
       void setValue(const unsigned long &x, const unsigned long &y, char* value,const unsigned long &t)
       {
           matrix[y][x] = long(value);
           return;
       }
   
       void setValue(const unsigned long &x, const unsigned long &y, char * value, const long &t)
       {
           matrix[y][x] = long(value);
           return;
       }
   
       void import(string filename)
       {
           if(filename.find(".csv") != string::npos)
           {
               importCsv(filename);
           }
           else if(filename.find(".tif") != string::npos)
           {
   #ifdef with_gdal
               importTif(filename);
               return;
   #endif
               cerr << "Tif file specified, but program not compiled with gdal libraries. Please recompile  with  -D with_gdal or edit your code to include #define with_gdal." << endl;
               exit(EXIT_FAILURE);
           }
           else
           {
               string s = "Type detection failed for " + filename + ". Check filename is correct.";
               throw runtime_error(s);
           }
       }
   
   #ifdef with_gdal
       void importTif(string filename)
       {
           cout  << "Importing " << filename << " " << flush;
           GDALDataset  *poDataset;
           GDALAllRegister();
           poDataset = (GDALDataset *) GDALOpen(filename.c_str(), GA_ReadOnly);
           if(poDataset == NULL)
           {
               string s = "File " + filename + " not found.";
               throw runtime_error(s);
           }
           GDALRasterBand  *poBand;
           int nBlockXSize, nBlockYSize;
           // Import the raster band 1
           poBand = poDataset->GetRasterBand(1);
           nBlockXSize = poDataset->GetRasterXSize();
           nBlockYSize = poDataset->GetRasterYSize();
           // Check sizes
           //cerr << "X dimension: " << nBlockXSize << endl;
           //cerr << "Y dimension: " << nBlockYSize << endl;
           if((numCols != (unsigned long) nBlockXSize || numRows != (unsigned long) nBlockYSize) || numCols == 0 || numRows == 0)
           {
               cerr << "Raster data size does not match inputted dimensions. Using raster sizes." << endl;
               cerr << "Old dimensions: " << numCols << ", " << numRows << endl;
               cerr << "New dimensions: " << nBlockXSize << ", " << nBlockYSize << endl;
               SetSize(nBlockYSize,nBlockXSize);
           }
           // Check sizes match
           GDALDataType dt = poBand->GetRasterDataType();
           unsigned int number_printed = 0;
           // Note that if data sizes do not match, row objects will be temporarily create, so RAM usage will increase
           if(sizeof(T)*8 != gdal_data_sizes[dt])
           {
               // only produce the extra info if debugging is enabled.
               #ifdef DEBUG
               cerr << "Object data size: " << sizeof(T)*8 << endl;
               cerr << "Tif data size: " << gdal_data_sizes[dt] << endl;
               cerr << "Tif data type does not match object data size in " << filename << endl;
               #endif
               // Should this be a warning? I think this should be a warning...
               // Now figure out a way of dealing with types of different size.
               const char * dt_name = GDALGetDataTypeName(dt);
               unsigned int datasize = sizeof(T);
               bool fail = false;
               if(datasize == sizeof(bool))
               {
                   // then the data type is likely boolean.
                   // check that the raster type is integer
                   if(string(dt_name) == "Int16" || string(dt_name) == "UInt16" || string(dt_name) == "UInt32" 
                       || string(dt_name) == "Int32")
                   {
                       // create an empty row of type int
                       Row<int> tmprow;
                       tmprow.SetRowSize(numCols);
                       // import the data a row at a time, using our template row.
                       for(unsigned int j = 0; j < numRows; j ++)
                       {
                           double dComplete = ((double)j/(double)numRows)*20;
                           if (number_printed < dComplete)
                           {
                               cout  << "\rImporting " << filename << " ";
                               number_printed = 0;
                               while(number_printed < dComplete)
                               {
                                   cout << ".";
                                   number_printed ++;
                               }
                               cout << flush;
                           }
                           
                           CPLErr r = poBand->RasterIO(GF_Read, 0, j, nBlockXSize, 1, &tmprow[0], nBlockXSize, 1, dt,0, 0);
                           if(r == CE_Failure)
                           {
                               throw runtime_error("CPL error during tif import: CE_Failure.");
                           }
                           // now copy the data to our matrix, converting int to bool.
                           for(unsigned i = 0; i < numCols; i++)
                           {
                               matrix[j][i] = (tmprow[i] != 0);
                           }
                       }
                   }
                   else if(string(dt_name) == "Float32")
                   {
                       // create an empty row of type float for 32 bit, double for 64 bit.
                       Row<float> tmprow;
                       tmprow.SetRowSize(numCols);
                       // import the data a row at a time, using our template row.
                       for(unsigned int j = 0; j < numRows; j ++)
                       {
                           double dComplete = ((double)j/(double)numRows)*20;
                           if (number_printed < dComplete)
                           {
                               cout  << "\rImporting " << filename << " ";
                               number_printed = 0;
                               while(number_printed < dComplete)
                               {
                                   cout << ".";
                                   number_printed ++;
                               }
                               cout << flush;
                           }
                           
                           CPLErr r = poBand->RasterIO(GF_Read, 0, j, nBlockXSize, 1, &tmprow[0], nBlockXSize, 1, dt,0, 0);
                           if(r == CE_Failure)
                           {
                               throw runtime_error("CPL error during tif import: CE_Failure.");
                           }
                           // now copy the data to our matrix, converting int to bool.
                           for(unsigned i = 0; i < numCols; i++)
                           {
                               if(tmprow[i] >= 0.5)
                               {
                                   matrix[j][i] = true;
                               }
                               else
                               {
                                   matrix[j][i] = false;
                               }
                           }
                       }
                   }
                   else if(string(dt_name) == "Float64")
                   {
                       Row<double> tmprow;
                       tmprow.SetRowSize(numCols);
                       // import the data a row at a time, using our template row.
                       for(unsigned int j = 0; j < numRows; j ++)
                       {
                           double dComplete = ((double)j/(double)numRows)*20;
                           if (number_printed < dComplete)
                           {
                               cout  << "\rImporting " << filename << " ";
                               number_printed = 0;
                               while(number_printed < dComplete)
                               {
                                   cout << ".";
                                   number_printed ++;
                               }
                               cout << flush;
                           }
                           
                           CPLErr r = poBand->RasterIO(GF_Read, 0, j, nBlockXSize, 1, &tmprow[0], nBlockXSize, 1, dt,0, 0);
                           if(r == CE_Failure)
                           {
                               throw runtime_error("CPL error during tif import: CE_Failure.");
                           }
                           // now copy the data to our matrix, converting int to bool.
                           for(unsigned i = 0; i < numCols; i++)
                           {
                               if(tmprow[i] >= 0.5)
                               {
                                   matrix[j][i] = true;
                               }
                               else
                               {
                                   matrix[j][i] = false;
                               }
                           }
                       }
                   }
                   else
                   {
                       fail = true;
                   }
               }
               else if(datasize == sizeof(unsigned long) || datasize == sizeof(int))
               {
                   // Then the likely conversion problem is float -> integer. A warning has already been given,
                   // so let's proceed.
                   // Check that the raster type is float
                   if(string(dt_name) == "Float32" || string(dt_name) == "Float64")
                   {
                       // create an empty row of type float
                       Row<double> tmprow;
                       tmprow.SetRowSize(numCols);
                       // import the data a row at a time, using our template row.
                       for(unsigned int j = 0; j < numRows; j ++)
                       {
                           double dComplete = ((double)j/(double)numRows)*20;
                           if (number_printed < dComplete)
                           {
                               cout  << "\rImporting " << filename << " ";
                               number_printed = 0;
                               while(number_printed < dComplete)
                               {
                                   cout << ".";
                                   number_printed ++;
                               }
                               cout << flush;
                           }
                           
                           CPLErr r = poBand->RasterIO(GF_Read, 0, j, nBlockXSize, 1, &tmprow[0], nBlockXSize, 1, dt,0, 0);
                           if(r == CE_Failure)
                           {
                               throw runtime_error("CPL error during tif import: CE_Failure.");
                           }
                           // now copy the data to our matrix, converting float to int. Round or floor...? hmm, floor?
                           for(unsigned i = 0; i < numCols; i++)
                           {
                               matrix[j][i] = floor(tmprow[i]);
                           }
                       }
                   }
                   else
                   {
                       fail = true;
                   }
                   
               }
               if(fail)
               {
                   // then throw a proper error.
                   throw runtime_error("Could not match data type in file to data type in memory. Raster type: " + 
                                       string(dt_name));
               }
           }
           else
           {
               // There is no type issue to try and solve.
               // Iterate over rows, reading each data segment into the matrix row.
               for(unsigned int j = 0; j < numRows; j ++)
               {
                   double dComplete = ((double)j/(double)numRows)*20;
                   if (number_printed < dComplete)
                   {
                       cout  << "\rImporting " << filename << " ";
                       number_printed = 0;
                       while(number_printed < dComplete)
                       {
                           cout << ".";
                           number_printed ++;
                       }
                       cout << flush;
                   }
                   
                   CPLErr r = poBand->RasterIO(GF_Read, 0, j, nBlockXSize, 1, &matrix[j][0], nBlockXSize, 1, dt,0, 0);
                   if(r == CE_Failure)
                   {
                       throw runtime_error("CPL error during tif import: CE_Failure.");
                   }
               }
           }
           cout  << "done!" << endl;
       }
   #endif
   
   #ifdef use_csv
       void importCsv(string filename)
       {
           cout  << "Importing " << filename << " " << flush;
           // LineReader option
           io::LineReader in(filename);
           // Keep track of whether we've printed to terminal or not.
           bool bPrint = false;
           // Initialies empty variable so that the setValue operator overloading works properly.
           T type_reference = null;
           unsigned int number_printed = 0;
           for(unsigned long i =0; i<numRows; i++)
           {
               char* line = in.next_line();
               if(line == nullptr)
               {
                   if(!bPrint)
                   {
                       cerr << "Input dimensions incorrect - read past end of file." << endl;
                       bPrint = true;
                   }
                   break;
               }
               else
               {
                   char *dToken;
                   dToken = strtok(line,",");
                   for(unsigned long j = 0; j<numCols; j++)
                   {
                       if(dToken == nullptr)
                       {
                           if(!bPrint)
                           {
                               cerr << "Input dimensions incorrect - read past end of file." << endl;
                               bPrint = true;
                           }
                           break;
                       }
                       else
                       {
                           // This function is overloaded to correctly determine the type of the template
                           setValue(j,i,dToken,type_reference);
                           dToken = strtok(NULL,",");
                       }
                   }
                   // output the percentage complete
                   double dComplete = ((double)i/(double)numRows)*20;
                   if( number_printed < dComplete)
                   {
                       cout  << "\rImporting " << filename << " ";
                       number_printed = 0;
                       while(number_printed < dComplete)
                       {
                           cout << ".";
                           number_printed ++;
                       }
                       cout << flush;
                   }
                   
               }
           }
           cout << "done!" << "           " << endl;
       }
   #endif
   #ifndef use_csv
       // OLD VERSION - currently unused)
       void importCsv(string filename)
       {
           cout  << "Importing" << filename << " " << flush;
           ifstream inputstream;
           inputstream.open(filename.c_str());
           unsigned int number_printed = 0;
           for(int j =0; j<numRows; j++)
           {
               string line;
               getline(inputstream,line);
   //          cout << "got line" << endl;
   //          cout << line << endl;
               istringstream iss(line);
   //          cout << numCols << endl;
   //          string sam;
   //          cin >> sam;
   
   //          getline(inputstream,line);
   //          cout << line << endl;
   //          cin >> sam;
               for(int i = 0; i<numCols; i++)
               {
                   char delim;
                   T val;
                   iss >> val >> delim;
                   matrix[j][i] =val;
   //              cout << i  << "-"<< matrix[j][i] << endl;
               }
               double dComplete = ((double)j/(double)numRows)*5;
               if(number_printed < dComplete)
               {
                   cout  << "\rImporting " << filename << " " << flush;
                   while(number_printed < dComplete)
                   {
                       cout << ".";
                       number_printed ++;
                   }
                   cout << flush;
               }
           }
           cout  << "\rImporting" << filename << "..."  << "done!" << "                          " << endl;
           inputstream.close();
           return;
       }
   #endif
   };
   
   #endif
   
   // THE END OF THE CODE


