.. _program_listing_file_SpeciationCounter.cpp:

Program Listing for File SpeciationCounter.cpp
========================================================================================

- Return to documentation for :ref:`file_SpeciationCounter.cpp`

.. code-block:: cpp

   //This file is part of NECSim project which is released under BSD-3 license.
   //See file **LICENSE.txt** or visit https://opensource.org/licenses/BSD-3-Clause) for full license details.
   
   #include <stdio.h>
   //#include "fast-cpp-csv-parser/csv.h"
   #include "Treelist.h"
   #include "Config.h" // Just for the importing of command-line arguments for now. Later on parsing parameters from a file might be implemented.
   #include "Setup.h"
   #include <boost/filesystem.hpp>
   
   
   using namespace std;
   // INPUTS
   // requires a SQL database file containing the the Treenode objects from a coalescence simulations.
   // the required speciation rate.
   
   // OUTPUTS
   // An updated database file that contains the species richness and species abundances of the intended lineage.
   
   struct simParameters
   {
       bool RecordSpatial;
       bool bMultiRun;
       bool RecordFragments;
       string filename;
       vector<double> vSpecRates;
       string samplemask;
       string autocorrel_file;
       vector<double> autocorrel_times;
       bool bAuto;
       string fragment_config_file;
   };
   
   void parseArgs(int &argc, vector<string> &comargs, simParameters &sp)
   {
       bool bRunDefault=false;
       bool bInvalidArguments = false;
       bool bAskHelp = false;
       #ifndef verbose
       dup2(saved_stdout, fileno(stdout));
       //close(saved_stdout);
       #endif
       if(argc<7)
       {
           if(argc == 1)
           {
               bInvalidArguments = true;
           }
           bInvalidArguments = true;
           if(argc==2)
           {
               if((comargs[1])=="-d")
               {
                   bInvalidArguments = false;
                   bRunDefault = true;
               }
               if(comargs[1]=="-h"||comargs[1]=="-help")
               {
                   bInvalidArguments = false;
                   bAskHelp = true;
               }
           }
           if(bInvalidArguments)
           {
               cout << "Incorrect number of arguments." << endl;
               bInvalidArguments = true;
               if(argc == 1)
               {
                   comargs.push_back("-e");
               }
               else
               {
                   comargs[1] = "-e";
               }
           }
       }
       else
       {
           sp.samplemask = comargs[3];
           sp.filename = comargs[1];
           sp.autocorrel_file = comargs[4];
       }
       if(argc>7)
       {
           sp.bMultiRun = true;
           int i = 6;
           while(i<argc)
           {
               sp.vSpecRates.push_back(stof(comargs[i]));
               i++;
           }
       }
       else if(argc == 7 && !bInvalidArguments && !bAskHelp)
       {
           sp.bMultiRun = false;
           sp.vSpecRates.push_back(stod(comargs[6]));
       }
       if(!bInvalidArguments && !bAskHelp && !bRunDefault)
       {
           if(comargs[2] == "true" || comargs[2] == "True" || comargs[2] == "T" || comargs[2] == "TRUE" || comargs[2] == "t")
           {
               sp.RecordSpatial = true;
           }
           else
           {
               sp.RecordSpatial = false;
           }
           if(comargs[5] == "false" || comargs[5] == "False" || comargs[5] == "F" || comargs[5] == "FALSE" || comargs[5] == "f")
           {
               sp.RecordFragments = false;
           }
           else
           {
               if(comargs[5] == "true" || comargs[5] == "True" || comargs[5] == "T" || comargs[5] == "TRUE" || comargs[5] == "t")
               {
                   sp.fragment_config_file = "null";
               }
               else
               {
                   sp.fragment_config_file = comargs[5];
               }
               sp.RecordFragments = true;
           }
       }
       if(bInvalidArguments||bAskHelp)
       {
           cout << "At least six command-line arguments are expected." << endl;
           cout << "1 - Path to SQL database file." << endl;
           cout << "2 - T/F of whether to record full spatial data." << endl;
           cout << "3 - the sample mask to use (use null if no mask is to be used)" << endl;
           cout << "4 - the file containing tempororal points of interest. If null, the present is used for all calculations." << endl;
           cout << "5 - T/F of whether to calculate abundances for each rectangular fragment. Alternatively, provide a csv file with fragment data to be read." << endl;
           cout << "6 - Speciation rate." << endl;
           cout <<"7 - onwards - Further speciation rates. [OPTIONAL]" << endl;
           cout << "Would you like to run with the default paramenters?" << endl;
           cout << "       (This requires a SQL database file at ../../Data/Coal_sim/Test_output/SQL_data/data_0_1.db)" << endl;
           cout << "Enter Y/N: " << flush;
           string sDef;
           cin >> sDef;
           if(sDef=="Y"||sDef=="y")
           {
               bRunDefault = true;
           }
           else
           {
               bRunDefault = false;
               exit(0);
           }
       }
       if(comargs[1]=="-d" || bRunDefault)
       {
           sp.filename= "../../Data/Coal_sim/Test_output/SQL_data/data_0_1.db";
           sp.vSpecRates.push_back(0.001);
           sp.samplemask = "null";
           sp.autocorrel_file = "null";
           sp.fragment_config_file = "null";
           sp.RecordFragments = false;
           sp.RecordSpatial = true;
       }
       try
       {
           if(sp.autocorrel_file == "null")
           {
               sp.bAuto = false;
           }
           else
           {
               sp.bAuto = true;
               vector<string> tmpimport;
               ConfigOption tmpconfig;
               tmpconfig.setConfig(sp.autocorrel_file,false);
               tmpconfig.importConfig(tmpimport);
               for(unsigned int i = 0;i<tmpimport.size();i++)
               {
                   sp.autocorrel_times.push_back(stod(tmpimport[i]));
   //                  cout << "t_i: " << sp.autocorrel_times[i] << endl;
               }
           }
       }
       catch(Config_Exception& ce)
       {
           cerr << ce.what() << endl;
       }
       #ifndef verbose
       openLogFile(true);
       #endif
   }
   
   
   
   int main(int argc, char **argv)
   {
       time_t tStart,tEnd;
       time(&tStart);
       simParameters sp;
       Row<Treenode> data;
   //  sqlite3 * database;
       string inputfile;
       unsigned int iMultiNumber = argc-6;
       #ifndef verbose
       openLogFile(false);
       #endif
       // vector to store the command-line arguments
       vector<string> comargs;
       importArgs(argc,argv,comargs);
       parseArgs(argc,comargs,sp);
       // Import the arguments
   //  for(int i =0;i < comargs.size();i++)
   //  {
   //      cout << comargs[i] << endl;
   //  }
       
           
       // Now do the actual calculation
       // First print the variables
       cout << "***************************" << endl;
       cout << "STARTING CALCULATIONS" << endl;
       cout << "Input file is " << sp.filename << endl;
       if(!sp.bMultiRun)
       {
           cout << "Speciation rate is " << sp.vSpecRates[0] << endl;
       }
       else
       {
           cout << "Speciation rates are: " << flush;
           for(unsigned int i=0;i<iMultiNumber;i++)
           {
               cout << sp.vSpecRates[i] << flush;
               if(i +1 == iMultiNumber)
               {
                   cout << "." << endl;
               }
               else
               {
                   cout << ", " << flush;
               }
           }
       }
       
       
       // Set up the objects
       Treelist nodes(data);
       nodes.setList(data);
   //  unsigned long iCount;
       // Import the data from the file into the Row<Treenode> object.
       try
       {
   //      nodes.detectDimensions(sp.filename);
           // First import the parameters so that the samplemask file will be the correct size.
           nodes.importSimParameters(sp.filename);
           nodes.importSamplemask(sp.samplemask);
           nodes.importData(sp.filename);
           if( sp.RecordFragments)
           {
               nodes.calcFragments(sp.fragment_config_file);
           }
       }
       catch(exception& se)
       {
           cerr << se.what() << endl;
           exit(-1);
       }
       // Get rid of any previous speciation calculations
       nodes.resetTree();
       nodes.setGeneration(0);
       // Calculate the new tree structure.
       if(sp.bMultiRun)
       {
           vector<double> dUniqueSpec;
           for(unsigned int i =0;i<iMultiNumber;i++)
           {
               bool bCont = true;
               for(unsigned int j =0;j<dUniqueSpec.size();j++)
               {
                   if(dUniqueSpec[j]==sp.vSpecRates[i])
                   {
                       bCont = false;
                   }
               }
               if(bCont)
               {
                   if(sp.bAuto)
                   {
                       dUniqueSpec.push_back(sp.vSpecRates[i]);
                       for(unsigned int k = 0;k < sp.autocorrel_times.size(); k++)
                       {
                           cout << "Calculating generation " << sp.autocorrel_times[k] << endl;
                           nodes.setGeneration(sp.autocorrel_times[k]);
                           nodes.resetTree();
                           try
                           {
                               nodes.createDatabase(sp.vSpecRates[i]);
                               if(sp.RecordSpatial)
                               {
                                   nodes.recordSpatial();
                               }
                               if(sp.RecordFragments)
                               {
                                   nodes.applyFragments();
                               }
                           }
                           catch(SpeciesException &se)
                           {
                               cerr << se.what() << endl;
                           }
                       }
                   }
                   else
                   {
                       dUniqueSpec.push_back(sp.vSpecRates[i]);
                       nodes.resetTree();
                       try
                       {
                           nodes.createDatabase(sp.vSpecRates[i]);
                           if(sp.RecordSpatial)
                           {
                               nodes.recordSpatial();
                           }
                           if(sp.RecordFragments)
                           {
                               nodes.applyFragments();
                           }
                           
                       }
                       catch(SpeciesException &se)
                       {
                           cerr << se.what() << endl;
                       }
                   }
               }
               else
               {
                   cout << "Repeat speciation rate... ignoring" << endl;
               }
           }
       }
       else
       {
           if(sp.bAuto)
           {
               for(unsigned int k = 0;k < sp.autocorrel_times.size(); k++)
               {
                   cout << "Calculating generation " << sp.autocorrel_times[k] << endl;
                   nodes.setGeneration(sp.autocorrel_times[k]);
                   nodes.resetTree();
                   try
                   {
                       nodes.createDatabase(sp.vSpecRates[0]);
                       if(sp.RecordSpatial)
                       {
                           nodes.recordSpatial();
                       }
                       if(sp.RecordFragments)
                       {
                           nodes.applyFragments();
                       }
                   }
                   catch(SpeciesException &se)
                   {
                       cerr << se.what() <<endl;
                   }
               }
           }
           else
           {
               try
               {
                   nodes.createDatabase(sp.vSpecRates[0]);
                   if(sp.RecordSpatial)
                   {
                       nodes.recordSpatial();
                   }
                   if(sp.RecordFragments)
                   {
                       nodes.applyFragments();
                   }
               }
               catch(SpeciesException &se)
               {
                   cerr << se.what() << endl;
               }
           }
       }
       nodes.exportDatabase(sp.filename);
   //  cout << "speciation rate of 0.0001: " << list.calcSpecies(0.0001);
   //  list.resetTree();
   //  cout << "speciation rate of 0.001: " << list.calcSpecies(0.001);
   //  list.resetTree();
   //  cout << "speciation rate of 0.01: " << list.calcSpecies(0.01);
       time(&tEnd);
       cout << "Calculations complete." << endl;
       cout << "Time taken was " <<floor((tEnd - tStart)/3600) << " hours " << (floor((tEnd - tStart)/60)-60*floor((tEnd - tStart)/3600)) << " minutes " << (tEnd-tStart)%60<< " seconds" << endl;
   
       return 0;
   }


