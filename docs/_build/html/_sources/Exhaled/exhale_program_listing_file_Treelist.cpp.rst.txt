.. _program_listing_file_Treelist.cpp:

Program Listing for File Treelist.cpp
========================================================================================

- Return to documentation for :ref:`file_Treelist.cpp`

.. code-block:: cpp

   // This file is part of NECSim project which is released under BSD-3 license.
   // See file **LICENSE.txt** or visit https://opensource.org/licenses/BSD-3-Clause) for full license details.
   
   //#define use_csv
   #include "Treelist.h"
   void Treelist::setList(Row<Treenode>& l)
   {
       nodes = l;
   }
   
   void Treelist::setDatabase(sqlite3* dbin)
   {
       if(!bFileSet)
       {
           database = dbin;
       }
       else
       {
           throw SpeciesException("ERROR_SPEC_002: Attempt to set database - database link has already been set");
       }
       bFileSet = true;  // this just specifies that the database has been created in memory.
   }
   
   bool Treelist::hasImportedData()
   {
       return bDataImport;
   }
   
   double Treelist::getMinimumSpeciation()
   {
       return min_spec_rate;
   }
   
   void Treelist::importSamplemask(string sSamplemask)
   {
       // Check that the sim data has been imported.
       if(!bDataImport)
       {
           throw SpeciesException("ERROR_SPEC_003: Attempt to import samplemask object before simulation parameters: dimensions not known");
       }
       // Check that the main data has been imported already, otherwise the dimensions of the samplemask will not be correct
       if(!bSample)
       {
           samplemaskfile = sSamplemask;
           if(sSamplemask != "null")
           {
               samplemask.SetSize(grid_y_size, grid_x_size);
               //              cout << "importing samplemask: " << sSamplemask << endl;
               samplemask.setIsNull(false);
               samplemask.import(sSamplemask);
               //              Matrix<unsigned short> tempsampmask;
               //              tempsampmask.SetSize(samplemask.GetRows(),samplemask.GetCols());
               //              tempsampmask.importCsv(sSamplemask);
               unsigned long total = 0;
               for(int i = 0; i < samplemask.GetCols(); i++)
               {
                   for(int j = 0; j < samplemask.GetRows(); j++)
                   {
                       if(samplemask[j][i])
                       {
                           total++;
                           // Check
                           if(!samplemask.getVal(i, j))
                           {
                               cerr << "BUG!" << endl;
                               exit(1);
                           }
                       }
                   }
               }
               cout << "Sampling " << total << " cells." << endl;
           }
           else
           {
               samplemask.setIsNull(true);
   #ifdef DEBUG
               cout << "Sampling all areas." << endl;
   #endif
           }
           bSample = true;
       }
   }
   
   unsigned long Treelist::countSpecies()
   {
       unsigned int precount = 0;
       for(unsigned int i = 1; i < nodes.size(); i++)
       {
           if(nodes[i].hasSpeciated())
           {
               precount++;
           }
       }
       // cout << "Precount: " << precount << endl;
       return (precount);
   }
   
   bool Treelist::doubleCompare(double d1, double d2, double epsilon)
   {
       return (abs(float(d1 - d2)) < epsilon);
   }
   
   unsigned long Treelist::calcSpecies(double s)
   {
       resetTree();
       if(!bSample)
       {
   #ifdef DEBUG
           cerr << "No samplemask imported. Defaulting to null." << endl;
   #endif
           importSamplemask("null");
       }
       //      cout << "listsize: " << nodes.size() << endl;
       dSpecRate = s;
       unsigned long iSpecCount = 0;  // start at 2 because the last species has been burnt already.
       // check that tips exist within the spatial and temporal frame of interest.
       for(unsigned int i = 1; i < nodes.size(); i++)
       {
           if(nodes[i].isTip() && !samplemask.getVal(nodes[i].getXpos(), nodes[i].getYpos()))
           {
               cout << "Outside sample zone: " << i << " (" << nodes[i].getXpos() << "," << nodes[i].getYpos()
                    << ")" << endl;
               exit(EXIT_FAILURE);
           }
           if(nodes[i].getParent() >= nodes.size())
           {
               cerr << "i: " << endl;
               cerr << "parent: " << nodes[i].getParent() << endl;
               cerr << "size: " << nodes.size() << endl;
               throw SpeciesException("ERROR_SQL_017: The parent is outside the size of the the data object. Bug "
                                      "in expansion of data structures or object set up likely.");
           }
           if(nodes[i].isTip() && samplemask.getVal(nodes[i].getXpos(), nodes[i].getYpos()) &&
                   doubleCompare(nodes[i].getGeneration(), generation, 0.0001))
           {
               // if they exist exactly in the generation of interest.
               nodes[i].setExistance(true);
           }
           else
           {
               nodes[i].setExistance(false);
           }
           // Calculate if speciation occured at any point in the lineage's branch
           if(checkSpeciation(nodes[i].getSpecRate(), s, nodes[i].getGenRate()))
           {
               iSpecCount++;
               nodes[i].speciate();
               //              nodes[i].burnSpecies(iSpecCount);
           }
       }
       // now continue looping to calculate species identities for lineages given the new speciation probabilities.
       bool bSorter = true;
       while(bSorter)
       {
           bSorter = false;
           for(unsigned int i = 1; i < nodes.size(); i++)
           {
               // check if any parents exist
               if(!nodes[nodes[i].getParent()].getExistance() && nodes[i].getExistance() &&
                       !nodes[i].hasSpeciated())
               {
                   bSorter = true;
                   nodes[nodes[i].getParent()].setExistance(true);
               }
           }
       }
       iSpecCount = 0;
       // Now loop again, creating a new species for each species that actually exists.
       for(unsigned int i = 1; i < nodes.size(); i++)
       {
           if(nodes[i].getExistance() && nodes[i].hasSpeciated())
           {
               iSpecCount++;
               nodes[i].burnSpecies(iSpecCount);
           }
       }
       // now loop to correctly assign each species id
       bool loopon = true;
       bool error_printed = false;
       while(loopon)
       {
           loopon = false;
           // if we start at the end of the loop and work backwards, we should remove some of the repeat
           // speciation events.
           for(unsigned long i = (nodes.size()) - 1; i > 0; i--)  
           {
               //              cout << i << endl;
               if(nodes[i].getSpeciesID() == 0 && nodes[i].getExistance())
               {
                   loopon = true;
                   nodes[i].burnSpecies(nodes[nodes[i].getParent()].getSpeciesID());
                   if(nodes[nodes[i].getParent()].getSpeciesID() == 0 &&
                           doubleCompare(nodes[i].getGeneration(), generation, 0.001))
                   {
                       if(!error_printed)
                       {
                           #ifdef DEBUG
                           cerr << "dSpec: " << nodes[i].getSpecRate() << endl;
                           cerr << "tip: " << nodes[i].isTip() << endl;
                           cerr << "i: " << i << endl;
                           cerr << "parent: " << nodes[i].getParent() << endl;
                           cerr << "parent_id: " << nodes[nodes[i].getParent()].getSpeciesID() << endl;
                           cerr << "existance: " << nodes[i].getExistance() << endl;
                           cerr << "speciated: " << nodes[i].hasSpeciated() << endl;
                           cerr << "generation: " << nodes[i].getGeneration() << endl;
                           #endif
                           cerr << "Potential parent ID error - incomplete simulation likely." << flush;
                           error_printed = true;
                       }
                   }
               }
           }
       }
       // count the number of species that have been created
       iSpecCount = 0;
       for(unsigned int i = 0; i < nodes.size(); i++)
       {
           // count all speciation events, not just the ones that exist!
           if(nodes[i].hasSpeciated() && nodes[i].getExistance() && nodes[i].getSpeciesID() != 0)  
           {
               iSpecCount++;
           }
           if(nodes[i].getExistance() && nodes[i].getSpeciesID() == 0)
           {
               cerr << "ERROR_SQL_006: Species exists but hasn't been assigned a species ID. Check the tree "
                    "speciation calculations."
                    << endl;
           }
       }
       iSpecies = iSpecCount;
       //      cout << "iSpecies: " << iSpecies << endl;
       return iSpecCount;
   }
   
   void Treelist::calcSpeciesAbundance()
   {
       rOut.SetRowSize(iSpecies + 1);
       //      cout << "iSpecies: " << iSpecies << endl;
       for(unsigned int i = 0; i < rOut.size(); i++)
       {
           rOut[i] = 0;
       }
       for(unsigned int i = 1; i < nodes.size(); i++)
       {
           if(nodes[i].isTip() && doubleCompare(nodes[i].getGeneration(), generation, 0.0001) &&
                   nodes[i].getExistance())
           {
               if(!samplemask.getVal(nodes[i].getXpos(), nodes[i].getYpos()) &&
                       doubleCompare(nodes[i].getGeneration(), generation, 0.0001))
               {
                   cerr << "x,y " << nodes[i].getXpos() << ", " << nodes[i].getYpos() << endl;
                   cerr << "tip: " << nodes[i].isTip() << " Existance: " << nodes[i].getExistance()
                        << " samplemask: " << samplemask.getVal(nodes[i].getXpos(), nodes[i].getYpos())
                        << endl;
                   cerr << "ERROR_SQL_005: Tip doesn't exist. Something went wrong either in the import or "
                        "main simulation running."
                        << endl;
               }
               // The line that counts the number of individuals
               rOut[nodes[i].getSpeciesID()]++;
               if(nodes[i].getSpeciesID() == 0 && samplemask.getVal(nodes[i].getXpos(), nodes[i].getYpos()) &&
                       doubleCompare(nodes[i].getGeneration(), generation, 0.0001))
               {
                   cerr << "x,y " << nodes[i].getXpos() << ", " << nodes[i].getYpos() << endl;
                   cout << "generation (point,required): " << nodes[i].getGeneration() << ", " << generation
                        << endl;
                   unsigned long p = nodes[i].getParent();
                   cout << "samplemasktest: " << samplemask.getTestVal(nodes[i].getXpos(), nodes[i].getYpos())
                        << endl;
                   cout << "samplemask: " << samplemask.getVal(nodes[i].getXpos(), nodes[i].getYpos()) << endl;
                   cout << "parent (tip, exists, generations): " << nodes[p].isTip() << ", "
                        << nodes[p].getExistance() << ", " << nodes[p].getGeneration() << endl;
                   cout << "species id zero - i: " << i << " parent: " << nodes[i].getParent()
                        << " dSpec: " << nodes[i].getSpecRate() << "has speciated: " << nodes[i].hasSpeciated()
                        << endl;
                   throw runtime_error("Fatal, exiting program.");
               }
           }
       }
   }
   
   void Treelist::resetTree()
   {
       for(unsigned int i = 0; i < nodes.size(); i++)
       {
           nodes[i].qReset();
       }
   }
   
   void Treelist::detectDimensions(string db)
   {
       sqlite3* tmpdb;
       int rc = sqlite3_open_v2(db.c_str(), &tmpdb, SQLITE_OPEN_READWRITE, "unix-dotfile");
       string to_exec = "SELECT MAX(xval),MAX(yval) FROM SPECIES_LIST;";
       sqlite3_stmt* stmt;
       rc = sqlite3_prepare_v2(tmpdb, to_exec.c_str(), strlen(to_exec.c_str()), &stmt, NULL);
       unsigned int xvalmax, yvalmax;
       rc = sqlite3_step(stmt);
       xvalmax = sqlite3_column_int(stmt, 0) + 1;
       yvalmax = sqlite3_column_int(stmt, 1) + 1;
       samplemask.SetSize(xvalmax, yvalmax);
       // close the old statement
       rc = sqlite3_finalize(stmt);
       if(rc != SQLITE_OK && rc != SQLITE_DONE)
       {
           cerr << "rc: " << rc << endl;
           throw SpeciesException("Could not detect dimensions");
       }
   }
   
   void Treelist::openSqlConnection(string inputfile)
   {
       // open the database objects
       sqlite3_backup* backupdb;
       // open one db in memory and one from the file.
       int o1 = sqlite3_open(":memory:", &database);
       int o2 = -1;
       // Check the outdatabase exists
       if(!boost::filesystem::exists(inputfile))
       {
           throw SpeciesException("ERROR_SQL_015: FATAL. Source file does not exist.");
       }
       o2 = sqlite3_open_v2(inputfile.c_str(), &outdatabase, SQLITE_OPEN_READWRITE, "unix-dotfile");
       // cout << "o2: " << o2 << endl;
       if(o2 != SQLITE_OK && o2 != SQLITE_DONE)
       {
           throw SpeciesException("ERROR_SQL_002: FATAL. Source file cannot be opened.");
       }
       if(sqlite3_errcode(database) != 0)
       {
           cerr << "Can't open in-memory database. Writing to file instead (this will be slower)." << endl;
           bMem = false;
           sqlite3_close(database);
           sqlite3_close(outdatabase);
           int rc = sqlite3_open_v2(inputfile.c_str(), &database, SQLITE_OPEN_READWRITE, "unix-dotfile");
           // Revert to different VFS file opening method if the backup hasn't started properly.
           // Two different versions will be attempted before an error will be thrown.
           // A different way of assigning the VFS method and opening the file correctly could be implemented later.
           // Currently "unix-dotfile" works for HPC runs and "unix" works for PC runs.
           if(rc != SQLITE_OK)
           {
               throw SpeciesException("ERROR_SQL_002: FATAL. Source file cannot be opened. Error codes: " + to_string(o1) +
                                      " and " + to_string(rc));
           }
       }
       else
       {
           bMem = true;
           // copy the db from file into memory.
           backupdb = sqlite3_backup_init(database, "main", outdatabase, "main");
           int rc = sqlite3_backup_step(backupdb, -1);
           
           if(rc != SQLITE_DONE && rc != SQLITE_OK)
           {
               sqlite3_close(outdatabase);
               sqlite3_open(inputfile.c_str(), &outdatabase);
               backupdb = sqlite3_backup_init(database, "main", outdatabase, "main");
           }
           rc = sqlite3_backup_finish(backupdb);
           //          cout << "rc: " << rc << endl;
           if(rc != SQLITE_DONE && rc != SQLITE_OK)
           {
               throw SpeciesException("ERROR_SQL_002: FATAL. Source file cannot be opened.");
               sqlite3_close(database);
               sqlite3_close(outdatabase);
           }
           sqlite3_close(outdatabase);
       }
       bSqlConnection = true;
   }
   
   void Treelist::importData(string inputfile)
   {
       if(!bSqlConnection)
       {
           openSqlConnection(inputfile);
       }
       if(!bDataImport)
       {
           importSimParameters(inputfile);
       }
       cout << "Beginning data import..." << flush;
       // The sql statement to store the sql statement message object
       sqlite3_stmt* stmt;
   
       // Now find out the max size of the list, so we have a count to work from
       string count_command = "SELECT MAX(ID) FROM SPECIES_LIST;";
       sqlite3_prepare_v2(database, count_command.c_str(), strlen(count_command.c_str()), &stmt, NULL);
       unsigned int datasize;
       // skip first row (should be blank)
       sqlite3_step(stmt);
       datasize = sqlite3_column_int(stmt, 0);
       //      cout << "datasize: " << datasize << endl;
       // close the old statement
       sqlite3_finalize(stmt);
   
       // Create db query
       string all_commands = "SELECT * FROM SPECIES_LIST;";
       sqlite3_prepare_v2(database, all_commands.c_str(), strlen(all_commands.c_str()), &stmt, NULL);
       nodes.SetRowSize(datasize + 1);
       // Check that the file opened correclty.
       sqlite3_step(stmt);
       // Copy the data across to the Treenode data structure.
       // For storing the number of ignored lineages so this can be subtracted off the parent number.
       unsigned long ignored_lineages = 0;
       #ifdef DEBUG
       bool has_printed_error = false;
       #endif
       for(unsigned int i = 1; i <= datasize; i++)
       {
           unsigned long species_id = sqlite3_column_int(stmt, 1);
           //      cout << species_id << endl;
           long xval = sqlite3_column_int(stmt, 2);
           long yval = sqlite3_column_int(stmt, 3);
           long xwrap = sqlite3_column_int(stmt, 4);
           long ywrap = sqlite3_column_int(stmt, 5);
           bool tip = bool(sqlite3_column_int(stmt, 6));
           bool speciation = bool(sqlite3_column_int(stmt, 7));
           unsigned long parent = sqlite3_column_int(stmt, 8);
           unsigned long iGen = sqlite3_column_int(stmt, 11);
           bool existance = bool(sqlite3_column_int(stmt, 9));
           double dSpec = sqlite3_column_double(stmt, 10);
           long double generationin = sqlite3_column_double(stmt, 12);
           //          cout << xval << ", " << yval << endl;
           if(tip && !samplemask.getVal(xval, yval) && generationin > generation && false)
           {
               ignored_lineages++;
               sqlite3_step(stmt);
           }
           else
           {
               // the -1 is to ensure that the list includes all lineages, but fills the output from the beginning
               unsigned int index = i - 1 - ignored_lineages;
               nodes[index].setup(tip, xval, yval, xwrap, ywrap, generationin);
               nodes[index].burnSpecies(species_id);
               nodes[index].setSpec(dSpec);
               nodes[index].setExistance(existance);
               nodes[index].setIGen(iGen);
               nodes[index].setParent(parent - ignored_lineages);
               if(index == parent && parent != 0)
               {
                   cerr << " i: " << index << " parent: " << parent << endl;
                   cerr << "ERROR_SQL_001: Import failed as parent is self. Check import function." << endl;
               }
               nodes[index].setSpeciation(speciation);
               sqlite3_step(stmt);
               #ifdef DEBUG
               if(parent < index && !speciation)
               {
                   if(!has_printed_error)
                   {
                       cerr << "parent: " << parent << " index: " << index << endl;
                       cerr << "Parent before index error. Check program." << endl;
                       has_printed_error = true;
                   }
               }
               #endif
           }
       }
       // Now we need to blank all objects
       sqlite3_finalize(stmt);
       // Now read the useful information from the SIMULATION_PARAMETERS table
       cout << "\rBeginning data import..." << "done             " << endl;
   }
   
   
   void Treelist::setGeneration(long double generationin)
   {
       generation = generationin;
   }
   
   void Treelist::createDatabase(double s)
   {
       cout << "Calculating tree structure..." << flush;
       if(s < min_spec_rate && s != min_spec_rate)
       {
           cerr << "s: " << s << endl;
           cerr << "min_spec: " << min_spec_rate << endl;
           throw SpeciesException(
               "ERROR_SQL_018: Speciation rate is less than the minimum speciation rate. Skipping.");
       }
       else
       {
           unsigned long nspec = calcSpecies(s);
           calcSpeciesAbundance();
           cout << "done!" << endl;
           cout << "Number of species: " << nspec << endl;
           cout << "Generating new SQL table for speciation rate " << s << "..." << flush;
           string table_command = "CREATE TABLE IF NOT EXISTS SPECIES_ABUNDANCES (ID TEXT PRIMARY KEY NOT NULL, "
                                  "species_id INT NOT NULL, speciation_rate DOUBLE NOT NULL, no_individuals INT NOT "
                                  "NULL,generation DOUBLE NOT NULL);";
           int rc = sqlite3_exec(database, table_command.c_str(), NULL, NULL, NULL);
           if(rc != SQLITE_OK)
           {
               throw SpeciesException("ERROR_SQL_002b: Could not create SPECIES_ABUNDANCES table.");
           }
   
           sqlite3_stmt* stmt;
           table_command = "INSERT INTO SPECIES_ABUNDANCES (ID,species_id, speciation_rate, "
                           "no_individuals,generation) VALUES (?,?,?,?,?);";
           sqlite3_prepare_v2(database, table_command.c_str(), strlen(table_command.c_str()), &stmt, NULL);
   
           // Start the transaction
           sqlite3_exec(database, "BEGIN TRANSACTION;", NULL, NULL, NULL);
           for(unsigned int i = 0; i < rOut.size(); i++)
           {
               // only do all the export itself if the value of i is not 0
               // if(rOut[i] != 0)
               //{
               string id_var = boost::lexical_cast<std::string>(dSpecRate) + "-" +
                               to_string((unsigned long long)i) + "_" + to_string((long double)generation);
               // fixed precision problem - lexical cast allows for printing of very small doubles.
               sqlite3_bind_text(stmt, 1, id_var.c_str(), -1, SQLITE_STATIC);
               sqlite3_bind_int(stmt, 2, i);
               sqlite3_bind_double(stmt, 3, dSpecRate);
               sqlite3_bind_int(stmt, 4, rOut[i]);
               sqlite3_bind_double(stmt, 5, generation);
               int step = sqlite3_step(stmt);
               // makes sure the while loop doesn't go forever.
               time_t start_check, end_check;
               time(&start_check);
               time(&end_check);
               while(step != SQLITE_DONE && (end_check - start_check) < 1)
               {
                   step = sqlite3_step(stmt);
                   time(&end_check);
               }
               if(step != SQLITE_DONE)
               {
                   cerr << "SQLITE error code: " << step << endl;
                   cerr << "ERROR_SQL_004: Could not insert into database. Check destination file has not "
                        "been moved or deleted and that an entry doesn't already exist with the same ID."
                        << endl;
                   sqlite3_clear_bindings(stmt);
                   sqlite3_reset(stmt);
                   break;
               }
               sqlite3_clear_bindings(stmt);
               sqlite3_reset(stmt);
               
           }
           // execute the command and close the connection to the database
           int rc1 = sqlite3_exec(database, "END TRANSACTION;", NULL, NULL, NULL);
           // Need to finalise the statement
           int rc2 = sqlite3_finalize(stmt);
           if(rc1 != SQLITE_OK || rc2 != SQLITE_OK)
           {
               cerr << "ERROR_SQL_013: Could not complete SQL transaction. Check memory database assignment and "
                    "SQL commands. Ensure SQL statements are properly cleared and that you are not attempting "
                    "to insert repeat IDs into the database."
                    << endl;
           }
           else
           {
               cout << "\rGenerating new SQL table for speciation rate " << s << "...done!" << endl;
           }
       }
   }
   
   void Treelist::createFragmentDatabase(const Fragment& f)
   {
       //      cout << "Generating new SQL table for speciation rate " << s << "..." << flush;
       string table_command = "CREATE TABLE IF NOT EXISTS FRAGMENT_ABUNDANCES (ID TEXT PRIMARY KEY NOT NULL, fragment "
                              "TEXT NOT NULL, area DOUBLE NOT NULL, size INT NOT NULL,  species_id INT NOT NULL, "
                              "speciation_rate DOUBLE NOT NULL, no_individuals INT NOT NULL,generation DOUBLE NOT NULL);";
       sqlite3_exec(database, table_command.c_str(), NULL, NULL, NULL);
   
       sqlite3_stmt* stmt;
       table_command = "INSERT INTO FRAGMENT_ABUNDANCES (ID, fragment, area, size, species_id, speciation_rate, "
                       "no_individuals,generation) VALUES (?,?,?,?,?,?,?,?);";
       sqlite3_prepare_v2(database, table_command.c_str(), strlen(table_command.c_str()), &stmt, NULL);
   
       // Start the transaction
       sqlite3_exec(database, "BEGIN TRANSACTION;", NULL, NULL, NULL);
       for(unsigned int i = 0; i < rOut.size(); i++)
       {
           if(rOut[i] != 0)
           {
               string id_var = boost::lexical_cast<std::string>(dSpecRate) + "_" + f.name + "_" +
                               to_string((unsigned long long)i) + "_" + to_string((long double)generation);
               // fixed precision problem - lexical cast allows for printing of very small doubles.
               sqlite3_bind_text(stmt, 1, id_var.c_str(), -1, SQLITE_STATIC);
               sqlite3_bind_text(stmt, 2, f.name.c_str(), -1, SQLITE_STATIC);
               sqlite3_bind_double(stmt, 3, f.area);
               sqlite3_bind_int(stmt, 4, f.num);
               sqlite3_bind_int(stmt, 5, i);
               sqlite3_bind_double(stmt, 6, dSpecRate);
               sqlite3_bind_int(stmt, 7, rOut[i]);
               sqlite3_bind_double(stmt, 8, generation);
               int step = sqlite3_step(stmt);
               // makes sure the while loop doesn't go forever.
               time_t start_check, end_check;
               time(&start_check);
               time(&end_check);
               while(step != SQLITE_DONE && (end_check - start_check) < 10)
               {
                   step = sqlite3_step(stmt);
                   time(&end_check);
               }
               if(step != SQLITE_DONE)
               {
                   cerr << "SQLITE error code: " << step << endl;
                   cerr << "ERROR_SQL_004: Could not insert into database. Check destination file has not "
                        "been moved or deleted and that an entry doesn't already exist with the same ID."
                        << endl;
                   sqlite3_clear_bindings(stmt);
                   sqlite3_reset(stmt);
                   break;
               }
               sqlite3_clear_bindings(stmt);
               sqlite3_reset(stmt);
           }
       }
       // execute the command and close the connection to the database
       int rc1 = sqlite3_exec(database, "END TRANSACTION;", NULL, NULL, NULL);
       // Need to finalise the statement
       int rc2 = sqlite3_finalize(stmt);
       if(rc1 != SQLITE_OK || rc2 != SQLITE_OK)
       {
           cerr << "ERROR_SQL_013: Could not complete SQL transaction. Check memory database assignment and SQL "
                "commands. Ensure SQL statements are properly cleared and that you are not attempting to insert "
                "repeat IDs into the database."
                << endl;
       }
   }
   
   void Treelist::exportDatabase(string outputfile)
   {
       if(bMem)
       {
           cout << "Writing out to " << outputfile << "..." << flush;
           // Now write the database to the file object.
           sqlite3* outdatabase2;
   
           int rc = sqlite3_open_v2(outputfile.c_str(), &outdatabase2, SQLITE_OPEN_READWRITE, "unix-dotfile");
           // check that the connection to file has opened correctly
           if(rc != SQLITE_OK && rc != SQLITE_DONE)
           {
               // attempt other output method
               sqlite3_close(outdatabase2);
               rc = sqlite3_open(outputfile.c_str(), &outdatabase2);
               if(rc != SQLITE_OK && rc != SQLITE_DONE)
               {
                   cerr << "ERROR_SQL_016: Connection to output database cannot be opened. Check write access "
                        "on output folder. Error code: "
                        << rc << "." << endl;
               }
           }
   
           // create the backup object to write data to the file from memory.
   
           sqlite3_backup* backupdb;
           backupdb = sqlite3_backup_init(outdatabase2, "main", database, "main");
           if(!backupdb)
           {
               cerr << "ERROR_SQL_003: Could not backup to SQL database. Check destination file has not been "
                    "moved or deleted."
                    << endl;
           }
           // Perform the backup
           rc = sqlite3_backup_step(backupdb, -1);
           if(rc != SQLITE_OK && rc != SQLITE_DONE)
           {
               cerr << "ERROR_SQL_016: Connection to output database cannot be opened. Check write access on "
                    "output folder. Error code: "
                    << rc << "." << endl;
           }
           rc = sqlite3_backup_finish(backupdb);
           if(rc != SQLITE_OK && rc != SQLITE_DONE)
           {
               cerr << "ERROR_SQL_016: Connection to output database cannot be opened. Check write access on "
                    "output folder. Error code: "
                    << rc << "." << endl;
           }
           //          cout << "rc: " << rc << endl;
           sqlite3_close(outdatabase2);
           sqlite3_close(database);
           cout << "done!" << endl;
       }
       else
       {
           cout << "Closing file..." << flush;
           sqlite3_close(database);
           cout << "\rClosing file...done!" << endl;
       }
       //      database
   }
   
   void Treelist::recordSpatial()
   {
       cout << "Recording spatial data for speciation rate " << dSpecRate << "..." << flush;
       string table_command = "CREATE TABLE IF NOT EXISTS SPECIES_LOCATIONS (ID TEXT PRIMARY KEY NOT NULL, species_id INT "
                              "NOT NULL, speciation_rate DOUBLE NOT NULL, x INT NOT NULL, y INT NOT NULL,generation "
                              "DOUBLE NOT NULL);";
       sqlite3_exec(database, table_command.c_str(), NULL, NULL, NULL);
       sqlite3_stmt* stmt;
       table_command =
           "INSERT INTO SPECIES_LOCATIONS (ID,species_id, speciation_rate, x,y,generation) VALUES (?,?,?,?,?,?);";
       sqlite3_prepare_v2(database, table_command.c_str(), strlen(table_command.c_str()), &stmt, NULL);
       //      cout << "test1" << endl;
       // Start the transaction
       sqlite3_exec(database, "BEGIN TRANSACTION;", NULL, NULL, NULL);
       // Make sure only the tips which we want to check are recorded
       //      cout << "nodes.size(): " << nodes.size() << endl;
       for(unsigned int i = 0; i < nodes.size(); i++)
       {
           //          cout << nodes[i].getExistance() << endl;
           if(samplemask.getVal(nodes[i].getXpos(), nodes[i].getYpos()) && nodes[i].isTip() &&
                   nodes[i].getExistance() && doubleCompare(nodes[i].getGeneration(), generation, 0.0001))
           {
               string id_var = boost::lexical_cast<std::string>(dSpecRate) + "-" +
                               to_string((unsigned long long)i) + "_" + to_string((long double)generation);
               //              cout << id_var << endl;
               // fixed precision problem - lexical cast allows for printing of very small doubles.
               sqlite3_bind_text(stmt, 1, id_var.c_str(), -1, SQLITE_STATIC);
               sqlite3_bind_int(stmt, 2, nodes[i].getSpeciesID());
               sqlite3_bind_double(stmt, 3, dSpecRate);
               sqlite3_bind_int(stmt, 4, nodes[i].getXpos());
               sqlite3_bind_int(stmt, 5, nodes[i].getYpos());
               sqlite3_bind_double(stmt, 6, nodes[i].getGeneration());
               int step = sqlite3_step(stmt);
               // makes sure the while loop doesn't go forever.
               time_t start_check, end_check;
               time(&start_check);
               time(&end_check);
               while(step != SQLITE_DONE && (end_check - start_check) < 10 && step != SQLITE_OK)
               {
                   step = sqlite3_step(stmt);
                   time(&end_check);
               }
               if(step != SQLITE_DONE)
               {
                   cerr << "SQLITE error code: " << step << endl;
                   cerr << "ERROR_SQL_004: Could not insert into database. Check destination file has not "
                        "been moved or deleted and that an entry doesn't already exist with the same ID."
                        << endl;
                   break;
               }
               sqlite3_clear_bindings(stmt);
               sqlite3_reset(stmt);
           }
       }
       // execute the command and close the connection to the database
       int rc1 = sqlite3_exec(database, "END TRANSACTION;", NULL, NULL, NULL);
       // Need to finalise the statement
       int rc2 = sqlite3_finalize(stmt);
       if(rc1 != SQLITE_OK || rc2 != SQLITE_OK)
       {
           cerr << "ERROR_SQL_013: Could not complete SQL transaction. Check memory database assignment and SQL "
                "commands. Ensure SQL statements are properly cleared and that you are not attempting to insert "
                "repeat IDs into the database."
                << endl;
       }
       else
       {
           cout << "\rRecording spatial data for speciation rate " << dSpecRate << "...done!" << endl;
       }
   }
   
   void Treelist::calcFragments(string fragment_file)
   {
       // Loop over every grid cell in the samplemask to determine if it is the start (top left corner) of a fragment.
       // Note that fragment detection only works for squares and rectangles. Adjacent squares and rectangles will be
       // treated as separate fragments if they are different sizes.
       // Downwards shapes are prioritised (i.e. a vertical rectangle on top of a horizontal rectangle will produce 3
       // fragments instead of two - this is a known bug).
       if(fragment_file == "null")
       {
           unsigned int fragment_number = 0;
           for(int i = 0; i < samplemask.GetCols(); i++)
           {
               for(int j = 0; j < samplemask.GetRows(); j++)
               {
                   bool in_fragment = false;
                   // Make sure is isn't on the top or left edge
                   if(samplemask.getVal(i, j))
                   {
                       if(i > 0 && j > 0)
                       {
                           // Perform the check
                           if(samplemask.getVal(i - 1, j) || samplemask.getVal(i, j - 1))
                           {
                               // then it is not a fragment
                               in_fragment = false;
                           }
                           else
                           {
                               in_fragment = true;
                           }
                       }
                       // if it is on an edge, we need to check the fragment
                       else
                       {
                           // if it is on the left edge we need to check above it - if there is forest
                           // there, it is not a fragment.
                           if(i == 0 && j > 0)
                           {
                               if(!samplemask.getVal(i, j - 1))
                               {
                                   in_fragment = true;
                               }
                           }
                           // if it is on the top edge, need to check to the left of it -  if there is
                           // forest there, it is not a fragment.
                           else if(j == 0 && i > 0)
                           {
                               if(!samplemask.getVal(i - 1, j))
                               {
                                   in_fragment = true;
                               }
                           }
                           else if(i == 0 && j == 0)
                           {
                               in_fragment = true;
                           }
                       }
                   }
                   if(in_fragment)
                   {
                       // Now move along the x and y axis (separately) until we hit a non-forest patch.
                       // This marks the edge of the fragment and the value is recorded.
                       bool x_continue = true;
                       bool y_continue = true;
                       unsigned long x, y;
                       x = i;
                       y = j;
                       fragment_number++;
                       // Also need to check that fragments that lie partly next to each other aren't
                       // counted twice.
                       // So count along the x axis until we hit non-habitat. Then count down the y axis
                       // checking both extremes of the square for non-habitat.
                       // Perform a check on the x axis to make sure that the square above is empty, as
                       // fragments give priority in a downwards motion.
                       while(x_continue)
                       {
                           x++;
                           if(samplemask.getVal(x, j))
                           {
                               // Check we're not on top edge of the map.
                               if(j > 0)
                               {
                                   // if the cell above is non-fragment then we don't need to
                                   // continue (downwards fragments get priority).
                                   if(samplemask.getVal(x, j - 1))
                                   {
                                       x_continue = true;
                                   }
                                   else
                                   {
                                       x_continue = false;
                                   }
                               }
                               else
                               {
                                   x_continue = true;
                               }
                           }
                           else
                           {
                               x_continue = false;
                           }
                       }
                       while(y_continue)
                       {
                           y++;
                           // Make sure both extremes of the rectangle are still within patch.
                           if(samplemask.getVal(i, y) && samplemask.getVal(x - 1, y))
                           {
                               y_continue = true;
                           }
                           else
                           {
                               y_continue = false;
                           }
                       }
                       // Create the fragment to add.
                       Fragment to_add;
                       to_add.name = to_string((long long)fragment_number);
                       to_add.x_west = i;
                       to_add.x_east = x - 1;
                       to_add.y_north = j;
                       to_add.y_south = y - 1;
                       // calculate the square area of the plot and record it.
                       to_add.area = (x - i) * (y - j);
                       // Now store the size of the fragment in the vector.
                       fragments.push_back(to_add);
                   }
               }
           }
       }
       else
       {
   #ifdef use_csv
           cout << "Importing fragments from " << fragment_file << endl;
           // There is a config file to import - here we use a specific piece of import code to parse the csv file.
           // first count the number of lines
           int number_of_lines = 0;
           string line;
           ifstream fragment_configs(fragment_file);
           while(getline(fragment_configs, line))
           {
               number_of_lines++;
           }
           //          cout << "Number of lines in text file: " << number_of_lines << endl;
           fragment_configs.close();
           io::LineReader in(fragment_file);
           // Keep track of whether we've printed to terminal or not.
           bool bPrint = false;
           fragments.resize(number_of_lines);
   //      cout << "size: "  << fragments.capacity() << endl;
           for(int i = 0; i < number_of_lines; i++)
           {
   
               //              cout << i << endl;
               char* line = in.next_line();
   //          cout << line << endl;
               if(line == nullptr)
               {
                   if(!bPrint)
                   {
                       cerr << "Input dimensions incorrect - read past end of file." << endl;
                       bPrint = true;
                   }
                   break;
               }
               else
               {
                   char* dToken;
                   dToken = strtok(line, ",");
                   for(int j = 0; j < 6; j++)
                   {
                       //                      cout << j << endl;
                       if(dToken == nullptr)
                       {
                           if(!bPrint)
                           {
                               cerr << "Input dimensions incorrect - read past end of file."
                                    << endl;
                               bPrint = true;
                           }
                           break;
                       }
                       else
                       {
                           //                          cout << "-" << endl;
                           switch(j)
                           {
                               case 0:
                                   fragments[i].name = string(dToken);
                                   break;
                               case 1:
                                   fragments[i].x_west = atoi(dToken);
                                   break;
                               case 2:
                                   fragments[i].y_north = atoi(dToken);
                                   break;
                               case 3:
                                   fragments[i].x_east = atoi(dToken);
                                   break;
                               case 4:
                                   fragments[i].y_south = atoi(dToken);
                                   break;
                               case 5:
                                   fragments[i].area = atof(dToken);
                                   break;
                           }
                           dToken = strtok(NULL, ",");
                       }
                   }
               }
           }
   #endif
   #ifndef use_csv
           cerr << "Cannot import fragments from " << fragment_file << " without fast-cpp-csv-parser." << endl;
           cerr << "Make sure the program has been compiled with -D use_csv." << endl;
   #endif
       }
       cout << "Completed fragmentation analysis: " << fragments.size() << " fragments identified." << endl;
   }
   
   void Treelist::applyFragments()
   {
       //      calculateFragments(); // don't need to do this each time - just once per simulation.
       // For each fragment in the vector, perform the analysis and record the data in to a new data object, which will
       // then be outputted to an SQL file.
       for(unsigned int i = 0; i < fragments.size(); i++)
       {
           //          cout  << fragments[i].x_west << endl;
           cout << "\rApplying fragments... " << (i + 1) << "/" << fragments.size() << "      " << flush;
           // Set the new samplemask to the fragment
           samplemask.setFragment(fragments[i]);
           // Now filter only those lineages which exist in the fragments.
           // We also want to count the number of individuals that actually exist
           unsigned long iSpecCount = 0;
           for(unsigned long j = 0; j < nodes.size(); j++)
           {
               if(nodes[j].isTip() && samplemask.getVal(nodes[j].getXpos(), nodes[j].getYpos()) &&
                       doubleCompare(nodes[j].getGeneration(), generation, 0.0001))
               {
                   // if they exist exactly in the generation of interest.
                   nodes[j].setExistance(true);
                   iSpecCount++;
               }
               else if(nodes[j].isTip())
               {
                   nodes[j].setExistance(false);
               }
           }
           fragments[i].num = iSpecCount;
           // Now calculate the species abundance. This will create a vector with lots of zeros in it. However, the
           // database creation will filter these out.
           calcSpeciesAbundance();
           createFragmentDatabase(fragments[i]);
           //          cout << "done!" << endl;
       }
       samplemask.removeFragment();
       cout << "\rApplying fragments... "
            << "done!      " << endl;
   }
   
   
   void Treelist::importSimParameters(string file)
   {
       if(!bSqlConnection)
       {
           #ifdef DEBUG
           cout << "opening connection..." << flush;
           #endif
           openSqlConnection(file);
           #ifdef DEBUG
           cout << "done!" << endl;
           #endif
       }
       try
       {
           #ifdef DEBUG
           cout << "Reading parameters..." << flush;
           #endif
           sqlite3_stmt* stmt2;
           string sql_parameters = "SELECT spec_rate, grid_x,grid_y FROM SIMULATION_PARAMETERS;";
           
           int rc = sqlite3_prepare_v2(database, sql_parameters.c_str(), strlen(sql_parameters.c_str()), &stmt2, NULL);
           if(rc != SQLITE_DONE && rc != SQLITE_OK)
           {
               sqlite3_close(outdatabase);
               sqlite3_close(database);
               throw SpeciesException("ERROR_SQL_020: FATAL. Could not open simulation parameters. Error code: " +
                                      to_string(rc));
               //              exit(EXIT_FAILURE);
           }
           sqlite3_step(stmt2);
           min_spec_rate = sqlite3_column_double(stmt2, 0);
           //          cout << sql_parameters << endl;
           //          cout << sqlite3_column_double(stmt2,0) << endl;
           //          cout << sqlite3_column_int(stmt2,2) << endl;
           grid_x_size = sqlite3_column_int(stmt2, 1);
           grid_y_size = sqlite3_column_int(stmt2, 2);
           //          cout << "min: " << min_spec_rate << endl << "x,y: " << grid_x_size << "," << grid_y_size <<
           //endl;
           sqlite3_step(stmt2);
           sqlite3_finalize(stmt2);
           #ifdef DEBUG
           cout << "done!" << endl;
           #endif
       }
       catch(exception& er)
       {
           throw SpeciesException(er.what());
       }
       bDataImport = true;
   }
   
   void Treelist::internalOption()
   {
       bDataImport = true;
       bSqlConnection = true;
       bFileSet = true;
   }
   
   bool checkSpeciation(long double random_number, long double speciation_rate, int number_of_generations)
   {
       // bool result1, result2, result3, result4;
       long double res = double(1.0 - pow(double(1.0 - speciation_rate), double(number_of_generations)));
       if(random_number <= res)
       {
           return (true);
       }
       else
       {
           return (false);
       }
   }


