.. _program_listing_file_Tree.cpp:

Program Listing for File Tree.cpp
========================================================================================

- Return to documentation for :ref:`file_Tree.cpp`

.. code-block:: cpp

   //This file is part of NECSim project which is released under BSD-3 license.
   //See file **LICENSE.txt** or visit https://opensource.org/licenses/BSD-3-Clause) for full license details.
   
   #include "Tree.h"
   
   void Tree::setMapVars(vector<string> comargs, bool fullmode)
   {
       mapvarsin.import(comargs, fullmode);
       mapvarsin.printVars();
       if(!varimport)
       {
           // Set the variables equal to the value from the Mapvars object.
           finemapinput = mapvarsin.finemapfile;
           coarsemapinput = mapvarsin.coarsemapfile;
           gridxsize = mapvarsin.vargridxsize;
           gridysize = mapvarsin.vargridysize;
   
           finemapxsize = mapvarsin.varfinemapxsize;
           finemapysize = mapvarsin.varfinemapysize;
           finemapxoffset = mapvarsin.varfinemapxoffset;
           finemapyoffset = mapvarsin.varfinemapyoffset;
   
           coarsemapxsize = mapvarsin.varcoarsemapxsize;
           coarsemapysize = mapvarsin.varcoarsemapysize;
           coarsemapxoffset = mapvarsin.varcoarsemapxoffset;
           coarsemapyoffset = mapvarsin.varcoarsemapyoffset;
           coarsemapscale = mapvarsin.varcoarsemapscale;
   
           outdirectory = mapvarsin.outdirectory;
   
           lambda = mapvarsin.lambda;
           the_task = mapvarsin.the_task;
           desired_specnum = mapvarsin.desired_specnum;
   
           // pristine map information
           pristinefinemapinput = mapvarsin.pristinefinemapfile;
           pristinecoarsemapinput = mapvarsin.pristinecoarsemapfile;
           dPristine = mapvarsin.dPristine;
           dForestTransform = mapvarsin.dForestTransform;
   
           deme = mapvarsin.deme;
           deme_sample = mapvarsin.deme_sample;
           spec = mapvarsin.spec;
           sigma = mapvarsin.sigma;
           nu = mapvarsin.nu;
           maxtime = mapvarsin.maxtime;
           autocorrel_file = mapvarsin.autocorrel_file;
           varimport = true;
       }
       else
       {
           throw Main_Exception("ERROR_MAIN_001: Variables already imported.");
       }
       return;
   }
   
   vector<double> Tree::getTemporalSampling()
   {
       if(bAutocorrel)
       {
           return (autocorrel_times);
       }
       else
       {
           vector<double> tmp;
           tmp.push_back(0.0);
           return (tmp);
       }
   }
   
   void Tree::importMaps()
   {
       if(varimport)
       {
           // Set the dimensions
           try
           {
               forestmap.setDims(mapvarsin);
           }
           catch(Map_Fatal_Exception& mf)
           {
               cerr << mf.what() << endl;
               exit(-1);
           }
           try
           {
               // Set the time variables
               forestmap.checkMapExists();
               // forestmap.setTimeVars(dPristine,dForestTransform);
               // Import the fine map
               forestmap.calcFineMap();
               // Import the coarse map
               forestmap.calcCoarseMap();
               // Calculate the offset for the extremeties of each map
               forestmap.calcOffset();
               // Import the pristine maps;
               forestmap.calcPristineFineMap();
               forestmap.calcPristineCoarseMap();
           }
           catch(Map_Exception& me)
           {
               cerr << me.what() << endl;
               cerr << "No dimensions set - can't start simulations" << endl;
               exit(-1);
           }
           catch(Map_Fatal_Exception& mfe)
           {
               cerr << mfe.what() << endl;
               exit(-1);
           }
       }
       else
       {
           throw Fatal_Exception("ERROR_MAIN_002: Variables not imported.");
       }
   }
   
   long long Tree::getSeed()
   {
       return the_seed;
   }
   
   void Tree::setSeed(long long theseedin)
   {
       if(!seeded)
       {
           NR.setSeed(theseedin);
           the_seed = theseedin;
           seeded = true;
       }
   }
   
   vector<long> Tree::randomList(long maxnum, long numnum)
   {
       vector<long> isin;
       vector<long> isout;
       isin.clear();
       isout.clear();
       long endisout = maxnum + 1;
       for(long i = 0; i <= maxnum; i++)
       {
           isout.push_back(i);
       }
       while(unsigned(isin.size()) < numnum)
       {
           long chosen = NR.i0(endisout - 1);
           isin.push_back(isout[chosen]);
           isout[chosen] = isout[endisout - 1];
           endisout--;
       }
   
       return isin;
   }
   
   unsigned long Tree::setObjectSizes()
   {
       unsigned long initcount;
   
       samplegrid.importDatamask(mapvarsin);
       // Get a count of the number of individuals on the grid.
       try
       {
           initcount = forestmap.getInitialCount(deme_sample, samplegrid);
       }
       catch(exception& e)
       {
           cerr << e.what() << endl;
           throw Fatal_Exception();
       }
       // Set active and data at the correct sizes.
       if(initcount == 0)
       {
           cout << "Initial count is 0. No individuals to simulate. Exiting program." << endl;
           exit(0);
       }
       //      cout << "initcount: " << initcount << endl;
       active.SetRowSize(initcount + 1);
       data.SetRowSize(2 * initcount + 1);
       // Make the grid size with 1 entry per deme.
       // Previous versions used 1 entry per individual for increased spatial movement. However, with percentage cover,
       // this was now deemed unneccessary.
       grid.SetSize(gridysize, gridxsize);
       return (initcount);
   }
   
   void Tree::setup(vector<string>& comargs, bool fullmode)
   {
       cout << "*************************************************" << endl;
       cout << "Setting up simulation..." << endl;
       // deme = square root of Deme size - note deme*deme*number of demes is the total size of the system.  Number of
       // demes is given by the map scenario
       // deme_sample = number of individuals to be sampled from each deme (cannot be more than deme^2)
       // spec = speciation rate required
       // dispersal = dispersal distance (double)
       // typeflag = 2 normal
       // typeflag != 2 fat
       // sigma = kernel fatness
       // map_scenario gives the index of the predefined map list vectors that will indicate which habitat map to load
       // generations_since = number of generations since disturbance at present day of sampling
       // equilibrium mask = do we ignore the generations_since tag and simply run all the way to equilibrium on the
       // fragmented landscape?
       // max time allowed for this simulation (useful for HPC runs)
       // Set the private variables for the simulation
       // Start the timer
       time(&start);
       // Use the Mapvars object to import the necessary information
       setMapVars(comargs, fullmode);
   
       try
       {
           if(autocorrel_file == "null")
           {
               bAutocorrel = false;
           }
           else
           {
               bAutocorrel = true;
               vector<string> tmpimport;
               ConfigOption tmpconfig;
               tmpconfig.setConfig(autocorrel_file, false);
               tmpconfig.importConfig(tmpimport);
               for(unsigned int i = 0; i < tmpimport.size(); i++)
               {
                   autocorrel_times.push_back(stod(tmpimport[i]));
                   //                  cout << "t_i: " << autocorrel_times[i] << endl;
               }
           }
       }
       catch(Config_Exception& ce)
       {
           cerr << ce.what() << endl;
       }
       // Make the mask map with 1 entry in each deme
       // Previous versions worked with 1 entry per individual.
       try
       {
           importMaps();  // This will import the fine and coarse maps using the routine specified in the Map class.
       }
       catch(Fatal_Exception& fe)
       {
           cerr << fe.what() << endl;
           throw Fatal_Exception();
       }
       // Set up the map recording information
   
       // Set the map dispersal values (so they don't have to be passed with every function call).
       NR.setDispersalParams(sigma, nu);
       if(sigma < 2.0)
       {
           cerr << "WARNING: sigma value is less than 2. This is likely to cause severe problems with dispersal "
                   "distances."
                << endl;
       }
   // forestmap.validateMaps();
   #ifdef debug_mode
       forestmap.validateMaps();  // If you're having problems with the maps generating errors, run this line to check the
   // maps are correctly formatted.
   #endif
       unsigned long initcount = setObjectSizes();
       // import the grid file
       unsigned long numstart;
       numstart = 0;
       endactive = 0;
       active[0].setup(0, 0, 0, 0, 0, 0, 0);
       //      data[0].setSpec(1.0);
       cout << "\rSetting up simulation...filling grid                           " << flush;
   
       for(long i = 0; i < gridxsize; i++)
       {
           for(long j = 0; j < gridysize; j++)
           {
               grid[j][i].initialise(forestmap.getVal(i, j, 0, 0, 0));
               grid[j][i].fillList();
               grid[j][i].setNwrap(0);
               grid[j][i].setNext(0);
               // loop over the species list, adding the correct number of species in each placement.
               // Use the sampling to determine how many individuals to start in each position.
               if(samplegrid.getVal(i, j))
               {
                   double dSample_amount = floor(deme_sample * grid[j][i].getMaxsize());
                   for(int k = 0; k < dSample_amount; k++)
                   {
                       if(k >= grid[j][i].getMaxsize())
                       {
                           break;
                       }
                       else
                       {
                           numstart++;
                           int listpos = grid[j][i].addSpecies(numstart);
                           // Add the species to active
                           active[numstart].setup(i, j, 0, 0, numstart, listpos, 1);
                           // Add a tip in the Treenode for calculation of the coalescence tree at the
                           // end of the simulation.
                           // This also contains the start x and y position of the species.
                           data[numstart].setup(1, i, j, 0, 0);
                           data[numstart].setSpec(NR.d01());
                           endactive++;
                           enddata++;
                       }
                   }
               }
           }
       }
       //      cout << "check!" << endl;
       if(numstart == initcount)  // Check that the two counting methods match up.
       {
       }
       else
       {
           if(initcount > 1.1 * numstart)
           {
               cerr << "Data usage higher than neccessary - check allocation of individuals to the grid." << endl;
           }
           // this error is silenced as of v3.1 due to a difference in the counting methods of initcount and numstart
           // when taking into account the sampling.
           //          cout << "ERROR_MAIN_004: numstart not equal to initcount" << endl;
           //          cout << "numstart: " << numstart << " initcount: " << initcount << endl;
           //          cout << "endactive: " << endactive << " enddata: " << enddata << endl;
       }
       // other variables
       steps = 0;
       generation = 0;
       cout << "\rSetting up simulation...done!                           " << endl;
       cout << "Number of individuals simulated: " << endactive << endl;
       maxsimsize = enddata;
       //      cout << "Endactive: " << endactive << endl;
       if(active.size() < endactive || endactive == 0)
       {
           cerr << "endactive: " << endactive << endl;
           cerr << "active.size: " << active.size() << endl;
           cerr << "initcount: " << initcount << endl;
           cerr << "numstart: " << numstart << endl;
           if(endactive == 0)
           {
               cout << "No individuals to simulate! Check map set up. Exiting..." << endl;
               exit(EXIT_SUCCESS);
           }
           else
           {
               throw Fatal_Exception(
                   "ERROR_MAIN_007: FATAL. Sizing error - endactive is greater than the size of active.");
           }
       }
   #ifdef debug_mode
       // Checks that each lineage is placed in a legal place.
       for(unsigned int i = 0; i <= endactive; i++)
       {
           if(forestmap.getVal(active[i].getXpos(), active[i].getYpos(), 0, 0, 0) == 0)
           {
               throw Fatal_Exception("ERROR_MAIN_006: FATAL.  Setup is placing lineages in areas with no forest.");
           }
           if(active[i].getListpos() > grid[active[i].getYpos()][active[i].getXpos()].getMaxsize())
           {
               cout << "FAIL2 IN " << i << endl;
               cout << "x,y: " << active[i].getXpos() << "," << active[i].getYpos()
                    << " - listpos: " << active[i].getListpos()
                    << " maxsize: " << grid[active[i].getYpos()][active[i].getYpos()].getMaxsize() << endl;
               cout << "forestmap count: " << forestmap.getVal(active[i].getXpos(), active[i].getYpos(), 0, 0, 0)
                    << endl;
               exit(0);
           }
       }
   
       // validate all lineages
       for(unsigned int i = 1; i <= endactive; i++)
       {
           validationCheck(i, 200, i);
       }
   #endif
       startendactive = endactive;
   }
   
   void Tree::removeOldPos(const unsigned long& chosen)
   {
       long nwrap = active[chosen].getNwrap();
       long oldx = active[chosen].getXpos();
       long oldy = active[chosen].getYpos();
       if(nwrap == 0)
       {
           if(active[chosen].getXwrap() != 0 || active[chosen].getYwrap() != 0)
           {
               cerr << "chosen: " << chosen << endl;
               cerr << "x,y wrap: " << active[chosen].getXwrap() << "," << active[chosen].getYwrap() << endl;
               throw Fatal_Exception("ERROR_MOVE_015: Nwrap not set correctly. Nwrap 0, but x and y wrap not 0. ");
           }
   // Then the lineage exists in the main list;
   // debug (can be removed later)
   #ifdef pristine_mode
           if(grid[oldy][oldx].getMaxsize() < active[chosen].getListpos())
           {
               cerr << "grid maxsize: " << grid[oldy][oldx].getMaxsize() << endl;
               throw Fatal_Exception("ERROR_MOVE_001: Listpos outside maxsize. Check move programming function.");
           }
   #endif
           // delete the species from the list
           grid[oldy][oldx].deleteSpecies(active[chosen].getListpos());
           // clear out the variables.
           active[chosen].setNext(0);
           active[chosen].setNwrap(0);
           active[chosen].setListpos(0);
       }
       else  // need to loop over the nwrap to check nexts
       {
           if(nwrap == 1)
           {
               grid[oldy][oldx].setNext(active[chosen].getNext());
               // Now reduce the nwrap of the lineages that have been effected.
               long nextpos = active[chosen].getNext();
               // loop over the rest of the list, reducing the nwrap
               while(nextpos != 0)
               {
                   active[nextpos].decreaseNwrap();
                   nextpos = active[nextpos].getNext();
               }
               // decrease the nwrap
               grid[oldy][oldx].decreaseNwrap();
               active[chosen].setNwrap(0);
               active[chosen].setNext(0);
               active[chosen].setListpos(0);
               nwrap = 0;
           }
           else
           {
               long lastpos = grid[oldy][oldx].getNext();
               while(active[lastpos].getNext() !=
                     chosen)  // loop until we reach the next, then set the next correctly.
               {
                   lastpos = active[lastpos].getNext();
               }
               if(lastpos != 0)
               {
                   active[lastpos].setNext(active[chosen].getNext());
                   // check
                   if(active[lastpos].getNwrap() != (active[chosen].getNwrap() - 1))
                   {
                       cerr << "lastpos : " << lastpos << " lastpos nwrap: " << active[lastpos].getNwrap()
                            << endl;
                       cerr << "chosen: " << chosen << " chosen nwrap: " << active[chosen].getNwrap()
                            << endl;
                       throw Fatal_Exception("ERROR_MOVE_022: nwrap setting of either chosen or the "
                                             "lineage wrapped before chosen. Check move function.");
                   }
                   lastpos = active[lastpos].getNext();
                   while(lastpos != 0)
                   {
                       active[lastpos].decreaseNwrap();
                       lastpos = active[lastpos].getNext();
                   }
               }
               else
               {
                   cerr << "lastpos: " << lastpos << " endactive: " << endactive << " chosen: " << chosen
                        << endl;
                   throw Fatal_Exception(
                       "ERROR_MOVE_024: Last position before chosen is 0 - this is impossible.");
               }
               grid[oldy][oldx].decreaseNwrap();
               active[chosen].setNwrap(0);
               active[chosen].setNext(0);
               active[chosen].setListpos(0);
               nwrap = 0;
           }
           unsigned short iCount = 1;
           long pos = grid[oldy][oldx].getNext();
           if(pos == 0)
           {
               iCount = 0;
           }
           else
           {
               int c = 0;
               while(active[pos].getNext() != 0)
               {
                   c++;
                   iCount++;
                   pos = active[pos].getNext();
                   if(c > 10000)
                   {
                       cout << pos << endl;
                       cout << active[pos].getNext() << endl;
                       break;
                   }
               }
           }
   
           if(iCount != grid[oldy][oldx].getNwrap())
           {
               cerr << "Nwrap: " << grid[oldy][oldx].getNwrap() << " Counted lineages: " << iCount << endl;
               throw Fatal_Exception("ERROR_MOVE_014: Nwrap not set correctly after move for grid cell");
           }
       }
   }
   
   void Tree::calcMove(long& oldx, long& oldy, long& oldxwrap, long& oldywrap)
   {
       // initiate the move variables (distance and angle of movement)
   
       bool fail;
       fail = true;
       // keep looping until we reach a viable place to move from.
       while(fail)
       {
   #ifdef restrict_self
           long startx, starty, startxwrap, startywrap;
           startx = oldx;
           starty = oldy;
           startxwrap = oldxwrap;
           startywrap = oldywrap;
   #endif
   
           double dist, angle;
   #ifndef normal_dispersal
           dist = NR.fattail();
   #endif
   #ifdef normal_dispersal
           dist = sigma * NR.norm();
   #endif
           // Test different angle version - this is more correct (but for some reason massively increases compute
           // time).
           angle = NR.d01() * 2 * M_PI;
           forestmap.runDispersal(dist, angle, oldx, oldy, oldxwrap, oldywrap, fail, generation);
   #ifdef restrict_self
           if(startx == oldx && starty == oldy && startxwrap == oldxwrap && startywrap == oldywrap)
           {
               fail = true;
           }
   #endif
           if(forestmap.getVal(oldx, oldy, oldxwrap, oldywrap, generation) == 0 && !fail)
           {
               cerr << "x,y: " << oldx << "," << oldy << " x,y wrap: " << oldxwrap << "," << oldywrap << endl
                    << "Forest cover: " << forestmap.getVal(oldx, oldy, oldxwrap, oldywrap, generation) << endl;
               throw Fatal_Exception(
                   "ERROR_MOVE_007: Dispersal attempted to non-forest. Check dispersal function.");
           }
       }
   }
   
   long double Tree::calcMinMax(const unsigned long& current)
   {
       // this formula calculates the speciation rate required for speciation to have occured on this branch.
       // need to allow for the case that the number of gens was 0
       long double newminmax = 1;
       long double oldminmax = active[current].getMinmax();
       if(data[active[current].getMpos()].getGenRate() == 0)
       {
           newminmax = data[active[current].getMpos()].getSpecRate();
       }
       else
       {
           // variables need to be defined separately for the decimal division to function properly.
           long double tmpdSpec = data[active[current].getMpos()].getSpecRate();
           long double tmpiGen = data[active[current].getMpos()].getGenRate();
           newminmax = 1 - (pow(1 - tmpdSpec, (1 / tmpiGen)));
       }
       long double toret = min(newminmax, oldminmax);
       return toret;
   }
   
   void Tree::coalescenceEvent(const unsigned long& chosen, unsigned long& coalchosen)
   {
       // coalescence occured, so we need to adjust the data appropriatedly
       // our chosen lineage has merged with the coalchosen lineage, so we need to sync up the data.
       enddata++;
       data[enddata].setup(0, active[chosen].getXpos(), active[chosen].getYpos(), active[chosen].getXwrap(),
                           active[chosen].getYwrap());
   
       // First perform the move
       data[active[chosen].getMpos()].setParent(enddata);
       data[active[coalchosen].getMpos()].setParent(enddata);
       active[coalchosen].setMinmax(
           max(active[coalchosen].getMinmax(),
               active[chosen].getMinmax()));  // set the new minmax to the maximum of the two minimums.
       active[chosen].setMinmax(active[coalchosen].getMinmax());
       data[enddata].setIGen(0);
       data[enddata].setSpec(NR.d01());
       active[chosen].setMpos(enddata);
       active[coalchosen].setMpos(enddata);
       //      removeOldPos(chosen);
       switchPositions(chosen);
   }
   
   void Tree::calcNewPos(bool& coal,
                         const unsigned long& chosen,
                         unsigned long& coalchosen,
                         const long& oldx,
                         const long& oldy,
                         const long& oldxwrap,
                         const long& oldywrap)
   {
       // Calculate the new position of the move, whilst also calculating the probability of coalescence.
       unsigned short nwrap = active[chosen].getNwrap();
       if(oldxwrap == 0 && oldywrap == 0)
       {
           // Debug check (to remove later)
           if(nwrap != 0)
           {
               throw Fatal_Exception(
                   "ERROR_MOVE_006: NON FATAL. Nwrap not set correctly. Check move programming function.");
           }
           // then the procedure is relatively simple.
           // check for coalescence
           // check if the grid needs to be updated.
           if(grid[oldy][oldx].getMaxsize() != forestmap.getVal(oldx, oldy, oldxwrap, oldywrap, generation))
           {
               grid[oldy][oldx].setMaxsize(forestmap.getVal(oldx, oldy, 0, 0, generation));
           }
           coalchosen = grid[oldy][oldx].getRandLineage(NR);
           //#ifdef DEBUG
           if(coalchosen != 0)
           {
               if(active[coalchosen].getXpos() != (unsigned long)oldx ||
                  active[coalchosen].getYpos() != (unsigned long)oldy ||
                  active[coalchosen].getXwrap() != oldxwrap || active[coalchosen].getYwrap() != oldywrap)
               {
                   cerr << chosen << "," << coalchosen << endl;
                   cerr << "chosen - x,y: " << oldx << "," << oldy << endl
                        << "x, y wrap: " << oldxwrap << "," << oldywrap << endl;
                   cerr << "coalchosen - x,y:" << active[coalchosen].getXpos() << ","
                        << active[coalchosen].getYpos() << endl;
                   cerr << " x,y wrap: " << active[coalchosen].getXwrap() << ","
                        << active[coalchosen].getYwrap() << endl;
                   throw Fatal_Exception(
                       "ERROR_MOVE_006: NON FATAL. Nwrap not set correctly. Check move programming function.");
               }
           }
           //#endif
           if(coalchosen == 0)  // then the lineage can be placed in the empty space.
           {
               long tmplistindex = grid[oldy][oldx].addSpecies(chosen);
               // check
               if(grid[oldy][oldx].getSpecies(tmplistindex) != chosen)
               {
                   throw Fatal_Exception("ERROR_MOVE_005: Grid index not set correctly for species. Check "
                                         "move programming function.");
               }
   #ifdef pristine_mode
               if(grid[oldy][oldx].getListsize() > grid[oldy][oldx].getMaxsize())
               {
                   throw Fatal_Exception(
                       "ERROR_MOVE_001: Listpos outside maxsize. Check move programming function.");
               }
   #endif
               active[chosen].setNwrap(0);
               active[chosen].setListpos(tmplistindex);
               coal = false;
           }
           else  // then coalescence has occured
           {
               active[chosen].setNwrap(0);
               active[chosen].setListpos(0);
               // DO THE COALESCENCE STUFF
               coal = true;
           }
       }
       else  // need to check all the possible places the lineage could be.
       {
           if(nwrap != 0)
           {
               throw Fatal_Exception("ERROR_MOVE_022: Nwrap not set correctly in move.");
           }
           nwrap = grid[oldy][oldx].getNwrap();
           if(nwrap != 0)  // then coalescence is possible and we need to loop over the nexts to check those that are
           // in the same position
           {
               // Count the possible matches of the position.
               int matches = 0;
               // Create an array containing the list of active references for those that match as
               // this stops us having to loop twice over the same list.
               unsigned long matchlist[nwrap];
               long next_active;
               next_active = grid[oldy][oldx].getNext();
               // Count if the first "next" matches
               if(active[next_active].getXwrap() == oldxwrap && active[next_active].getYwrap() == oldywrap)
               {
   // check
   #ifdef DEBUG
                   if(active[next_active].getNwrap() != 1)
                   {
                       throw Fatal_Exception("ERROR_MOVE_022a: Nwrap not set correctly in move.");
                   }
   #endif
                   matchlist[matches] = next_active;  // add the match to the list of matches.
                   matches++;
               }
               // Now loop over the remaining nexts counting matches
               //#ifdef DEBUG
               unsigned int ncount = 1;
               //#endif
               while(active[next_active].getNext() != 0)
               {
                   next_active = active[next_active].getNext();
                   if(active[next_active].getXwrap() == oldxwrap && active[next_active].getYwrap() == oldywrap)
                   {
                       matchlist[matches] = next_active;
                       matches++;
                   }
                   // check
                   //#ifdef DEBUG
                   ncount++;
   #ifdef DEBUG
                   if(active[next_active].getNwrap() != ncount)
                   {
                       throw Fatal_Exception("ERROR_MOVE_022d: Nwrap not set correctly in move.");
                   }
   #endif
               }
               if(nwrap != ncount)
               {
                   throw Fatal_Exception("ERROR_MOVE_022c: Nwrap not set correctly in move.");
               }
               // Matches now contains the number of lineages at the exact x,y, xwrap and ywrap position.
               // Check if there were no matches at all
               if(matches == 0)
               {
                   coalchosen = 0;
                   coal = false;
                   active[next_active].setNext(chosen);
                   grid[oldy][oldx].increaseNwrap();
                   active[chosen].setNwrap(grid[oldy][oldx].getNwrap());
                   active[chosen].setListpos(0);
               }
               else  // if there were matches, generate a random number to see if coalescence occured or not
               {
                   unsigned short randwrap =
                       floor(NR.d01() * (forestmap.getVal(oldx, oldy, oldxwrap, oldywrap, generation)) + 1);
                   // Get the random reference from the match list.
                   // If the movement is to an empty space, then we can update the chain to include the new
                   // lineage.
                   if(randwrap > forestmap.getVal(oldx, oldy, oldxwrap, oldywrap, generation))
                   {
                       throw Fatal_Exception(
                           "ERROR_MOVE_004: Randpos outside maxsize. Check move programming function");
                   }
                   if(matches > forestmap.getVal(oldx, oldy, oldxwrap, oldywrap, generation))
                   {
                       cerr << "matches: " << matches << endl
                            << "forestmap value: "
                            << forestmap.getVal(oldx, oldy, oldxwrap, oldywrap, generation);
                       throw Fatal_Exception(
                           "ERROR_MOVE_004: matches outside maxsize. Check move programming function");
                   }
                   if(randwrap > matches)  // coalescence has not occured
                   {
                       // cout << "This shouldn't happen" << endl;
                       coalchosen = 0;
                       coal = false;
                       active[next_active].setNext(chosen);
                       grid[oldy][oldx].increaseNwrap();
                       active[chosen].setNwrap(grid[oldy][oldx].getNwrap());
                       active[chosen].setListpos(0);
                   }
                   else  // coalescence has occured
                   {
                       coal = true;
                       coalchosen = matchlist[randwrap - 1];
                       active[chosen].setEndpoint(oldx, oldy, oldxwrap, oldywrap);
                       if(coalchosen == 0)
                       {
                           throw Fatal_Exception(
                               "ERROR_MOVE_025: Coalescence attempted with lineage of 0.");
                       }
                   }
               }
   #ifdef pristine_mode
               if(grid[oldy][oldx].getMaxsize() < active[chosen].getListpos())
               {
                   throw Fatal_Exception(
                       "ERROR_MOVE_001: Listpos outside maxsize. Check move programming function.");
               }
   #endif
           }
           else  // just add the lineage to next.
           {
               if(grid[oldy][oldx].getNext() != 0)
               {
                   throw Fatal_Exception("ERROR_MOVE_026: No nwrap recorded, but next is non-zero.");
               }
               coalchosen = 0;
               coal = false;
               //              if(chosen==3893119)
               //              {
               //                  validationCheck(31556348,12,chosen);
               //                  cout << "test1..." << endl;
               //              }
               //              debug_504(chosen,12);
               grid[oldy][oldx].setNext(chosen);
               active[chosen].setNwrap(1);
               active[chosen].setNext(0);
               grid[oldy][oldx].increaseNwrap();
   // check
   #ifdef DEBUG
               if(grid[oldy][oldx].getNwrap() != 1)
               {
                   throw Fatal_Exception("ERROR_MOVE_022b: Nwrap not set correctly in move.");
               }
   #endif
               //              debug_504(chosen,11);
               //              if(chosen==3893119)
               //              {
               //                  validationCheck(31556348,13,chosen);
               //                  cout << "test2..." << endl;
               //              }
           }
           //#ifdef DEBUG
           if(coalchosen != 0)
           {
               if(active[coalchosen].getXpos() != (unsigned long)oldx ||
                  active[coalchosen].getYpos() != (unsigned long)oldy ||
                  active[coalchosen].getXwrap() != oldxwrap || active[coalchosen].getYwrap() != oldywrap)
               {
                   cerr << chosen << "," << coalchosen << endl;
                   cerr << "chosen - x,y: " << oldx << "," << oldy << endl
                        << "x, y wrap: " << oldxwrap << "," << oldywrap << endl;
                   cerr << "coalchosen - x,y:" << active[coalchosen].getXpos() << ","
                        << active[coalchosen].getYpos() << endl;
                   cerr << " x,y wrap: " << active[coalchosen].getXwrap() << ","
                        << active[coalchosen].getYwrap() << endl;
                   throw Fatal_Exception("ERROR_MOVE_006b: NON FATAL. Nwrap not set correctly. Check move "
                                         "programming function.");
               }
           }
           //#endif
       }
   }
   
   void Tree::switchPositions(const unsigned long chosen)
   {
       if(chosen > endactive)
       {
           cerr << "chosen: " << chosen << " endactive: " << endactive << endl;
           throw Fatal_Exception("ERROR_MOVE_023: Chosen is greater than endactive. Check move function.");
       }
       if(chosen != endactive)
       {
           // This routine assumes that the previous chosen position has already been deleted.
           Datapoint tmpdatactive;
           tmpdatactive.setup(active[chosen]);
           // now need to remove the chosen lineage from memory, by replacing it with the lineage that lies in the last
           // place.
           if(active[endactive].getXwrap() == 0 &&
              active[endactive].getYwrap() == 0)  // if the end lineage is simple, we can just copy it across.
           {
               // check endactive
               if(active[endactive].getNwrap() != 0)
               {
                   cerr << "ERROR_MOVE_020: NON FATAL. Nwrap is not set correctly for endactive (nwrap should "
                           "be 0, but is "
                        << active[endactive].getNwrap() << " ). Identified during switch of positions."
                        << endl;
               }
               grid[active[endactive].getYpos()][active[endactive].getXpos()].setSpecies(
                   active[endactive].getListpos(), chosen);
               active[chosen].setup(active[endactive]);
               active[endactive].setup(tmpdatactive);
               active[endactive].setNwrap(0);
               active[endactive].setNext(0);
           }
           else  // else the end lineage is wrapped, and needs to be processed including the wrapping routines.
           {
               if(active[endactive].getNwrap() == 0)
               {
                   cerr << "ERROR_MOVE_021: NON FATAL. Nwrap is not set correctly for endactive (nwrap "
                           "incorrectly 0). Identified during switch of positions."
                        << endl;
               }
               //              cout << "wrap"<<endl;
               long tmpactive = grid[active[endactive].getYpos()][active[endactive].getXpos()].getNext();
               int tmpnwrap = active[endactive].getNwrap();
   
               // if the wrapping is just once, we need to set the grid next to the chosen variable.
               if(tmpnwrap == 1)
               {
                   // check
                   if(grid[active[endactive].getYpos()][active[endactive].getXpos()].getNext() != endactive)
                   {
                       throw Fatal_Exception(string(
                           "ERROR_MOVE_019: FATAL. Nwrap for endactive not set correctly. Nwrap is 1, but "
                           "lineage at 1st position is " +
                           to_string(
                               (long long)grid[active[endactive].getYpos()][active[endactive].getXpos()]
                                   .getNext()) +
                           ". Identified during the move."));
                   }
                   grid[active[endactive].getYpos()][active[endactive].getXpos()].setNext(chosen);
               }
               else  // otherwise, we just set the next to chosen instead of endactive.
               {
                   int tmpcount = 0;
                   // loop over nexts until we reach the right lineage.
                   while(active[tmpactive].getNext() != endactive)
                   {
                       tmpactive = active[tmpactive].getNext();
                       tmpcount++;
                       // debug check
                       if(tmpcount > tmpnwrap)
                       {
                           cerr << "ERROR_MOVE_013: NON FATAL. Looping has not encountered a match, "
                                   "despite going further than required. Check nwrap counting."
                                << endl;
                           if(tmpactive == 0)
                           {
                               cerr << "gridnext: "
                                    << grid[active[endactive].getYpos()][active[endactive]
                                                                             .getXpos()]
                                           .getNext()
                                    << endl;
                               cerr << "x,y: " << active[endactive].getXpos() << ","
                                    << active[endactive].getYpos() << endl;
                               cerr << "xwrap,ywrap: " << active[endactive].getXwrap() << ","
                                    << active[endactive].getYwrap() << endl;
                               cerr << "endactive: " << endactive << endl;
                               cerr << "tmpactive: " << tmpactive << endl;
                               cerr << "bSpec: " << bSpec << endl;
                               cerr << "tmpnwrap: " << tmpnwrap << " tmpcount: " << tmpcount
                                    << endl;
                               cerr << "FATAL!" << endl;
                               throw Fatal_Exception();
                           }
                       }
                   }
                   active[tmpactive].setNext(chosen);
               }
               active[chosen].setup(active[endactive]);
               active[endactive].setup(tmpdatactive);
   
               // check - debugging
               long testwrap = active[chosen].getNwrap();
               unsigned long testnext = grid[active[chosen].getYpos()][active[chosen].getXpos()].getNext();
               for(int i = 1; i < testwrap; i++)
               {
                   testnext = active[testnext].getNext();
               }
   
               if(testnext != chosen)
               {
                   throw Fatal_Exception("ERROR_MOVE_009: Nwrap position not set correctly after coalescence. "
                                         "Check move process.");
               }
           }
       }
       endactive--;
   }
   
   void Tree::speciation(const unsigned long& chosen)
   {
       // alter the data such that it reflects the speciation event.
       unsigned long tmpmpos = active[chosen].getMpos();
   // data[tmpmpos].increaseGen();
   #ifdef DEBUG
       if(data[tmpmpos].hasSpeciated())
       {
           throw Fatal_Exception("ERROR_MOVE_028: Attempting to speciate a speciated species.");
       }
   #endif
       data[tmpmpos].speciate();
       // TEST REMOVE THIS WHEN TESTING COMPLETE!! done
       //      data[tmpmpos].setPosition(active[chosen].getXpos(),active[chosen].getYpos(),active[chosen].getXwrap(),active[chosen].getYwrap());
       // Now remove the old chosen lineage from the active directory.
       removeOldPos(chosen);
       switchPositions(chosen);
   }
   
   unsigned long Tree::estSpecnum()
   {
       long double dMinmax = 0;
       // first loop to find the maximum speciation rate required
       for(unsigned int i = 1; i <= endactive; i++)
       {
           long double tmpminmax = calcMinMax(i);
           active[i].setMinmax(tmpminmax);
           dMinmax = (long double)max(dMinmax, tmpminmax);
       }
       for(unsigned int i = 0; i <= enddata; i++)
       {
           if(data[i].isTip())
           {
               data[i].setExistance(true);
           }
           double maxret = 1;
           if(data[i].getGenRate() == 0)
           {
               maxret = 1;
           }
           else
           {
               maxret = data[i].getGenRate();
           }
           // This is the line that compares the individual random numbers against the speciation rate.
           if(data[i].getSpecRate() < (1 - pow((1 - dMinmax), maxret)))
           {
               data[i].speciate();
           }
       }
       bool loop = true;
       while(loop)
       {
           loop = false;
           for(unsigned int i = 0; i <= enddata; i++)
           {
               if(data[i].getExistance() && !data[data[i].getParent()].getExistance() && !data[i].hasSpeciated())
               {
                   loop = true;
                   data[data[i].getParent()].setExistance(true);
               }
           }
       }
       unsigned long iSpecies = 0;
       for(unsigned int i = 0; i <= enddata; i++)
       {
           if(data[i].getExistance() && data[i].hasSpeciated())
           {
               iSpecies++;
           }
       }
       for(unsigned int i = 0; i <= enddata; i++)
       {
           data[i].qReset();
       }
       //      cout << "Estimated species number is: " << iSpecies << endl;
       return iSpecies;
   }
   
   void Tree::runChecks(const unsigned long& chosen, const unsigned long& coalchosen)
   {
   // final checks
   #ifdef pristine_mode
       if(active[chosen].getListpos() > grid[active[chosen].getYpos()][active[chosen].getXpos()].getMaxsize() &&
          active[chosen].getNwrap() == 0)
       {
           //              usleep(1);
           cerr << "listpos: " << active[chosen].getListpos()
                << " maxsize: " << grid[active[chosen].getYpos()][active[chosen].getXpos()].getMaxsize() << endl;
           throw Fatal_Exception("ERROR_MOVE_001: Listpos outside maxsize.");
       }
   
       if(active[coalchosen].getListpos() >
              grid[active[coalchosen].getYpos()][active[coalchosen].getXpos()].getMaxsize() &&
          active[coalchosen].getNwrap() == 0 && coalchosen != 0)
       {
           //              usleep(1);
           throw Fatal_Exception("ERROR_MOVE_002: Coalchosen listpos outside maxsize.");
       }
   #endif
       if(active[chosen].getNwrap() != 0)
       {
           unsigned long tmpactive = grid[active[chosen].getYpos()][active[chosen].getXpos()].getNext();
           unsigned long lastactive = 0;
           for(int i = 1; i < active[chosen].getNwrap(); i++)
           {
               lastactive = tmpactive;
               tmpactive = active[tmpactive].getNext();
           }
           if(tmpactive != chosen)
           {
               cerr << "nwrap: " << active[chosen].getNwrap() << endl;
               cerr << "gridnwrap: " << grid[active[chosen].getYpos()][active[chosen].getXpos()].getNwrap()
                    << endl;
               cerr << "chosen: " << chosen << endl;
               cerr << "active x,y" << active[chosen].getXpos() << "," << active[chosen].getYpos() << endl;
               cerr << "wrap x,y: " << active[chosen].getXwrap() << "," << active[chosen].getYwrap() << endl;
               cerr << "tmpactive: " << tmpactive << " chosen: " << chosen
                    << " chosennext: " << active[chosen].getNext() << "lastactive: " << lastactive << endl;
               throw Fatal_Exception("ERROR_MOVE_003: Nwrap not set correctly.");
           }
       }
   
       if(active[chosen].getNwrap() != 0)
       {
           if(active[chosen].getXwrap() == 0 && active[chosen].getYwrap() == 0)
           {
               throw Fatal_Exception("ERROR_MOVE_10: Nwrap set to non-zero, but x and y wrap 0.");
           }
       }
       if(active[endactive].getNwrap() != 0)
       {
           int nwrap = active[endactive].getNwrap();
           if(nwrap == 1)
           {
               if(grid[active[endactive].getYpos()][active[endactive].getXpos()].getNext() != endactive)
               {
                   cerr << "Lineage at 1st position: "
                        << grid[active[endactive].getYpos()][active[endactive].getXpos()].getNext() << endl;
                   cerr << "endactive: " << endactive << endl
                        << "nwrap: " << nwrap << endl
                        << "x,y: " << active[endactive].getXpos() << "," << active[endactive].getYpos()
                        << endl;
                   cerr << "chosen: " << chosen << endl;
                   throw Fatal_Exception("ERROR_MOVE_016: Nwrap for endactive not set correctly. Nwrap is 1, "
                                         "but the lineage at 1st position is not endactive.");
               }
           }
           else
           {
               unsigned long tmpcheck = grid[active[endactive].getYpos()][active[endactive].getXpos()].getNext();
               int tmpnwrap = 1;
               while(tmpcheck != endactive)
               {
                   tmpnwrap++;
                   tmpcheck = active[tmpcheck].getNext();
                   if(tmpnwrap > nwrap + 1)
                   {
                       cerr << "ERROR_MOVE_017: NON FATAL. Nrap for endactive not set correctly; looped "
                               "beyond nwrap and not yet found enactive."
                            << endl;
                       cerr << "endactive: " << endactive << endl
                            << "nwrap: " << nwrap << endl
                            << "x,y: " << active[endactive].getXpos() << "," << active[endactive].getYpos()
                            << endl;
                       cerr << "chosen: " << chosen << endl;
                   }
               }
               if(tmpnwrap != nwrap)
               {
                   cerr << "ERROR_MOVE_018: NON FATAL. Nwrap for endactive not set correctly. Nwrap is "
                        << nwrap << " but endactive is at position " << tmpnwrap << endl;
                   cerr << "endactive: " << endactive << endl
                        << "nwrap: " << nwrap << endl
                        << "x,y: " << active[endactive].getXpos() << "," << active[endactive].getYpos()
                        << endl;
                   cerr << "chosen: " << chosen << endl;
               }
           }
       }
   }
   
   void Tree::validationCheck(const unsigned long& chosen, int o, const unsigned long& current, const bool& coal)
   {
       // if(active[chosen].getNwrap()!=0||chosen>endactive)
       //{
       //  return;
       //}
       //      cout << "check..." << endl;
       if(active[chosen].getListpos() > grid[active[chosen].getYpos()][active[chosen].getXpos()].getMaxsize() &&
          active[chosen].getNwrap() == 0)
       {
           //              usleep(1);
           cout << "listpos: " << active[chosen].getListpos()
                << " maxsize: " << grid[active[chosen].getYpos()][active[chosen].getXpos()].getMaxsize() << endl;
           cout << "VALIDATION_001: Listpos outside maxsize." << endl;
           throw Fatal_Exception("VALIDATION_001: Listpos outside maxsize.");
       }
       if(!coal && !data[active[chosen].getMpos()].hasSpeciated() && active[chosen].getNwrap() == 0 &&
          chosen != grid[active[chosen].getYpos()][active[chosen].getXpos()].getSpecies(active[chosen].getListpos()))
       {
           cout << "nwrap: " << active[chosen].getNwrap() << endl;
           cout << "gridnwrap: " << grid[active[chosen].getYpos()][active[chosen].getXpos()].getNwrap() << endl;
           cout << "chosen: " << chosen << endl;
           cout << "active x,y: " << active[chosen].getXpos() << "," << active[chosen].getYpos() << endl;
           cout << "wrap x,y: " << active[chosen].getXwrap() << "," << active[chosen].getYwrap() << endl;
           cout << " chosen: " << chosen << " chosennext: " << active[chosen].getNext() << endl;
           cout << "listpos: " << active[chosen].getListpos() << endl;
           cout << "lineage at pos " << active[chosen].getListpos() << ": "
                << grid[active[chosen].getYpos()][active[chosen].getXpos()].getSpecies(active[chosen].getListpos())
                << endl;
           cout << "o: " << o << endl;
           cout << "current chosen: " << current << endl;
           throw Fatal_Exception("VALIDATION_003: Listpos not set correctly.");
       }
       if(active[chosen].getNwrap() != 0)
       {
           //              cout << "nwrap1: " << active[chosen].getNwrap() << endl;
           unsigned long tmpactive = grid[active[chosen].getYpos()][active[chosen].getXpos()].getNext();
           unsigned long lastactive = 0;
           for(int i = 1; i < active[chosen].getNwrap(); i++)
           {
               lastactive = tmpactive;
               tmpactive = active[tmpactive].getNext();
           }
           if(tmpactive != chosen)
           {
               cout << "nwrap: " << active[chosen].getNwrap() << endl;
               cout << "gridnwrap: " << grid[active[chosen].getYpos()][active[chosen].getXpos()].getNwrap()
                    << endl;
               //              cout << "speccounter: " << spec_counter << endl;
               //              cout << "startnwrap: " << startnwrap << endl;
               cout << "chosen: " << chosen << endl;
               //              cout << "start x,y: " << startx << "," << starty << endl;
               //              cout << "end x,y: " << oldx << "," << oldy << endl;
               cout << "active x,y: " << active[chosen].getXpos() << "," << active[chosen].getYpos() << endl;
               cout << "wrap x,y: " << active[chosen].getXwrap() << "," << active[chosen].getYwrap() << endl;
               cout << "tmpactive: " << tmpactive << " chosen: " << chosen
                    << " chosennext: " << active[chosen].getNext() << "lastactive: " << lastactive << endl;
               cout << "VALIDATION_002: Nwrap not set correctly." << endl;
               cout << "o: " << o << endl;
               cout << "current chosen: " << current << endl;
               throw Fatal_Exception("VALIDATION_001: Listpos outside maxsize.");
           }
       }
   }
   
   void Tree::checkSimSize(unsigned long req_data, unsigned long req_active)
   {
       //      cout << "Started change size" << endl;
       // need to be double the size of the maximum number of individuals plus enddata
       unsigned long min_data = (2 * req_data) + enddata;
       unsigned long min_active = endactive + req_active;
       if(data.size() < min_data)
       {
           // change the size of data
           data.changeSize(min_data);
       }
   
       if(active.size() < min_active)
       {
           // change the size of active.
           active.changeSize(min_active);
       }
       //      cout << "finished change size" << endl;
   }
   
   bool Tree::runSim()
   {
       // now do the calculations required to build the tree
       cout << "*************************************************" << endl;
       cout << "Beginning simulations..." << flush;
       //      double current_gen =0;
       // check time
       time(&sim_start);
       time(&sim_end);
       time(&now);
       bool bContinueSim = true;
   #ifdef verbose
       double dPercentComplete;
       unsigned int number_printed = 0;
   #endif
       unsigned int iAutoComplete = 0;
       //      time_t loopend;
       // Main while loop to process while there is still time left and the simulation is not complete.
       do
       {
           // check the size of the simulations - decided this doesn't need to be here if the check is performed
           // properly at map expansion.
           //          checkSimSize(100,false,0);
           //          time(&loopstart);
           steps++;
   #ifdef verbose
           if(steps % 10000 == 0)
           {
               time(&sim_end);
               if(sim_end - now > 0.2 && log_all)  // output every 0.2 seconds
               {
                   dPercentComplete = 20 * (1 - (double(endactive) / double(startendactive)));
                   time(&now);
                   if(number_printed < dPercentComplete)
                   {
                       cout << "\rBeginning simulations...";
                       number_printed = 0;
                       while(number_printed < dPercentComplete)
                       {
                           cout << ".";
   
                           number_printed++;
                       }
                       cout << flush;
                   }
   
                   //                  cout  << "\rBeginning simulations..."<<endactive << "
                   // lineages
                   // remaining:
                   //"
                   //<<
                   // dPercentComplete << "%                                                     " << flush;
               }
           }
   #endif
           // increment generation counter
           generation += 2.0 / (double(endactive));
           if(bAutocorrel && iAutoComplete < autocorrel_times.size())
           {
               // cout << "Check1" << endl;
               //              cout << iAutoComplete << endl;
               //              cout << autocorrel_file << endl;
               //              for (int i = 0;i<autocorrel_times.size(); i ++)
               //              {
               //                  cout << autocorrel_times[i] << endl;
               //              }
               // check if we need to update
               if(autocorrel_times[iAutoComplete] <= generation)
               {
                   //                  cout << "check2" << endl;
                   if(autocorrel_times[iAutoComplete] > 0.0)
                   {
                       cout << "expanding map at generation " << generation << "..." << flush;
                       expandMap(autocorrel_times[iAutoComplete]);
                       cout << "done!" << endl;
                   }
                   iAutoComplete++;
               }
           }
           // check if the map is pristine yet
           if(generation >= dPristine)
           {
               forestmap.setPristine(true);
           }
           // choose a random lineage to die and be reborn out of those currently active
           unsigned long chosen = NR.i0(endactive - 1) + 1;  // cannot be 0
           unsigned long coalchosen = 0;
           // record old position of lineage
           long oldx = active[chosen].getXpos();
           long oldy = active[chosen].getYpos();
           //          long startxpos, startypos;
           //          startxpos = oldx;
           //          startypos = oldy;
           long oldxwrap = active[chosen].getXwrap();
           long oldywrap = active[chosen].getYwrap();
           bool coal = false;
   #ifdef pristine_mode
           if(forestmap.getVal(oldx, oldy, oldxwrap, oldywrap, generation) == 0)
           {
               cerr << "x,y: " << oldx << "," << oldy << " xwrap, ywrap: " << oldxwrap << "," << oldywrap << endl;
               cerr << "listsize: " << grid[oldy][oldx].getListsize()
                    << "maxsize: " << grid[oldy][oldx].getMaxsize() << endl;
               throw Fatal_Exception(
                   string("ERROR_MOVE_008: Dispersal attempted from non-forest. Check dispersal function. Forest "
                          "cover: " +
                          to_string((long long)forestmap.getVal(oldx, oldy, oldxwrap, oldywrap, generation))));
           }
   #endif
   // This bit has been removed as it has a very significant performance hit and is not required for most simulations.
   // As of version 3.2 it was fully compatible with the rest of the simulation, however.
   /*
   if(steps%1000000==0)
   {
                                   time(&now);
                                   if(now - time_taken>200&&dPercentComplete>95)
                                   {
                                                                   time(&time_taken);
                                                                   unsigned long specnum = est_specnum();
                                                                   cout << "Estimated number of species: " << specnum <<
   flush;
                                                                   if(specnum<desired_specnum)
                                                                   {
                                                                                                   cout << " - desired
   number of species reached." << endl << "Halting
   simulations..." << endl;
                                                                                                   bContinueSim = false;
                                                                   }
                                                                   else
                                                                   {
                                                                                                   cout << endl;
                                                                   }
                                   }
   }
   //*/
   // LIST OF POTENTIAL IMPROVEMENTS FOR THE FUTURE
   // 1 - Improve the SpeciesList referencing method when a species is deleted from the list.
   // 2 - Improve how the looping over next and last occurs so that the loop only needs to be performed once. This could
   // have major speed implications.
   // decide if speciation occured
   // Include alteration of forestmap over time.
   // Continue the simulation if the conditions are met for bContinueSim (in test scenarios this will always be true until
   // all lineages have coalesced.
   #ifdef DEBUG
           string location = "none";
   #endif
           try
           {
               if(bContinueSim)
               {
                   // cout << "check1" << endl;
                   coal = false;
                   // increase the counter of the number of moves (or generations) the lineage has undergone.
                   data[active[chosen].getMpos()].increaseGen();
                   // Check if speciation happens
                   if(checkSpeciation(data[active[chosen].getMpos()].getSpecRate(), spec,
                                      data[active[chosen].getMpos()].getGenRate()))
                   {
   // cout << "spec: " << spec << endl;
   // cout << "data spec rate: " << data[active[chosen].getMpos()].getSpecRate() << endl;
   // cout << "iGen: " << data[active[chosen].getMpos()].getGenRate() << endl;
   // string sam;
   // cin >> sam;
   #ifdef DEBUG
                       location = "speciation";
   // if ( data[active[chosen].getMpos()].)
   #endif
                       speciation(chosen);
                   }
                   else
                   {
   #ifdef DEBUG
                       location = "standard: oldpos " + to_string(oldx) + to_string(oldy);
   #endif
                       removeOldPos(chosen);  // remove the species data from the species list to be placed
                       // somewhere new.
                       //                      long oldoldxwrap = oldxwrap;
                       // cout << "check1.b" << endl;
   
                       calcMove(oldx, oldy, oldxwrap, oldywrap);
                       //                      if(oldoldxwrap != oldxwrap)
                       //                      {
                       //                          cout << "CHANGED!" <<
                       // oldoldxwrap
                       //<<
                       //","
                       //<<
                       // oldxwrap
                       //<<
                       // endl;
                       //                      }
                       // cout << "check2.a" << endl;
   
                       // Calculate the new position, perform the move if coalescence doesn't occur or
                       // return the variables for the coalescence event if coalescence does occur.
                       active[chosen].setEndpoint(oldx, oldy, oldxwrap, oldywrap);  // the "old" variables
                       // have been updated,
                       // so we can just input
                       // them back in to the
                       // function.
                       calcNewPos(coal, chosen, coalchosen, oldx, oldy, oldxwrap, oldywrap);
                       // cout << "check2.b" << endl;
                       if(coal)  // coalescence occured, so we need to adjust the data appropriatedly
                       {
   #ifdef DEBUG
                           location = "coalescence: coalchosen - " + to_string(coalchosen);
                           if(active[coalchosen].getXpos() != active[chosen].getXpos() ||
                              active[coalchosen].getYpos() != active[chosen].getYpos() ||
                              active[coalchosen].getXwrap() != active[chosen].getXwrap() ||
                              active[coalchosen].getYwrap() != active[chosen].getYwrap())
                           {
                               cerr << chosen << "," << coalchosen << endl;
                               cerr << "chosen - x,y: " << active[chosen].getXpos() << ","
                                    << active[chosen].getYpos() << endl
                                    << "x, y wrap: " << active[chosen].getXwrap();
                               cerr << "," << active[chosen].getYwrap() << endl;
                               cerr << "coalchosen - x,y:" << active[coalchosen].getXpos() << ","
                                    << active[coalchosen].getYpos() << endl;
                               cerr << " x,y wrap: " << active[coalchosen].getXwrap() << ","
                                    << active[coalchosen].getYwrap() << endl;
                               throw Fatal_Exception("ERROR_MOVE_006: NON FATAL. Nwrap not set "
                                                     "correctly. Check move programming "
                                                     "function.");
                           }
                           if(active[coalchosen].getXpos() != (unsigned long)oldx ||
                              active[coalchosen].getYpos() != (unsigned long)oldy ||
                              active[coalchosen].getXwrap() != oldxwrap ||
                              active[coalchosen].getYwrap() != oldywrap)
                           {
                               cerr << chosen << "," << coalchosen << endl;
                               cerr << "chosen - x,y: " << oldx << "," << oldy << endl
                                    << "x, y wrap: " << oldxwrap << "," << oldywrap << endl;
                               cerr << "coalchosen - x,y:" << active[coalchosen].getXpos() << ","
                                    << active[coalchosen].getYpos() << endl;
                               cerr << " x,y wrap: " << active[coalchosen].getXwrap() << ","
                                    << active[coalchosen].getYwrap() << endl;
                               throw Fatal_Exception("ERROR_MOVE_006: NON FATAL. Nwrap not set "
                                                     "correctly. Check move programming "
                                                     "function.");
                           }
   #endif
                           coalescenceEvent(chosen, coalchosen);
                       }
                       else  // debugging only now as the move process has been incorportated into
                       // calcNewPos().
                       {
                           // for debugging only
                           if(forestmap.getVal(oldx, oldy, oldxwrap, oldywrap, generation) == 0)
                           {
                               throw Fatal_Exception(
                                   string("ERROR_MOVE_007: Dispersal attempted to non-forest. "
                                          "Check dispersal function. Forest cover: " +
                                          to_string((long long)forestmap.getVal(
                                              oldx, oldy, oldxwrap, oldywrap, generation))));
                           }
                       }
                   }
               }
           }
           catch(Fatal_Exception& fe)
           {
               cerr << fe.what() << endl;
               exit(-1);
           }
   #ifdef DEBUG
           try
           {
               validationCheck(chosen, 112, chosen, coal);  // this can probably be removed now
           }
           catch(Fatal_Exception& fe)
           {
               cerr << fe.what() << endl;
               cerr << "Location tag: " << location << endl;
               throw Fatal_Exception();
           }
   #endif
           try
           {
               runChecks(chosen, coalchosen);  // as can this (but there is likely minimal performance hit and it
   // does prevent errors).
   // if debug mode is enabled, run a full debug every single time step (this will have  a massive performance hit)
   #ifdef debug_mode
               // runs the debug every 10,000 time steps
               if(steps % 10000 == 0)
               {
                   for(int i = 0; i <= endactive; i++)
                   {
                       runChecks(i, i);
                   }
               }
   #endif
           }
           catch(Fatal_Exception& fe)
           {
               cerr << fe.what() << endl;
               cerr << "dumping data file..." << endl;
               sqlCreate();
   #ifdef sql_ram
               sqlOutput();
   #endif
               cerr << "done!" << endl;
           }
       }
       while((endactive > 1) && (difftime(sim_end, start) < maxtime) && bContinueSim);
       // If the simulations finish correctly, output the completed data.
       // Otherwise, pause the simulation and save objects to file.
   
       if(endactive > 1)
       {
           time(&sim_finish);
           time_taken += sim_finish - start;
           cout << "........out of time!" << endl;
           //          cout << "Time taken: " << time_taken << endl;
           cout << "Pausing simulation: add extra time or re-run to ensure simulation completion." << endl;
           simPause();
           return false;
       }
       else
       {
           for(unsigned int i = 0; i <= endactive; i++)
           {
               data[active[i].getMpos()].speciate();
               data[active[i].getMpos()].setSpec(0);
           }
           sim_complete = true;
           time(&sim_finish);
           time_taken += sim_finish - start;
           if(!bContinueSim)
           {
               cout << "done - desired number of species achieved!" << endl;
               return true;
               //              sqlCreate();
           }
           else
           {
               cout << "done!" << endl;
               return true;
               //              sqlCreate();
           }
       }
   }
   
   void Tree::expandMap(double generationin)
   {
       //      cout << "expanding..." << endl;
       //  / loop over the grid first to check how many we need to add
       //      cout << "enddata: " << enddata << endl;
       //      cout << "endactive: " << endactive << endl;
       unsigned long added_active = 0;
       unsigned long added_data = 0;
       for(int i = 0; i < grid.GetCols(); i++)
       {
           //          cout << i << endl;
           for(int j = 0; j < grid.GetRows(); j++)
           {
               if(samplegrid.getVal(i, j))
               {
                   added_active +=
                       (long(forestmap.getVal(i, j, 0, 0, generationin)) - grid[j][i].getListsize());
               }
           }
       }
       //      cout << "added_data: " << added_data << endl;
       //      cout << "added_active: " << added_active << endl;
       added_data = added_active;
       // count all the tips
       for(unsigned int i = 0; i < enddata; i++)
       {
           if(samplegrid.getVal(data[i].getXpos(), data[i].getYpos()) && data[i].getXwrap() == 0 &&
              data[i].getYwrap() == 0)
           {
               // if the lineage isn't yet a tip, we can just make it a tip.
               if(data[i].isTip())
               {
                   added_data++;
               }
           }
       }
       //      cout << "added_data: " << added_data << endl;
       //      cout << "added_active: " << added_active << endl;
       // now resize data and active if necessary
       checkSimSize(added_data, added_active);
       // set the lineages that currently exist within sample area to a tip
       for(unsigned int i = 1; i < endactive; i++)
       {
           //          if(samplegrid.getVal(data[active[i].getMpos()].getXpos(),
           // data[active[i].getMpos()].getYpos())
           //&&
           // data[active[i].getMpos()].getXwrap() == 0 && data[active[i].getMpos()].getYwrap() == 0)
           // TEST new method
           if(samplegrid.getVal(active[i].getXpos(), active[i].getYpos()) && active[i].getXwrap() == 0 &&
              active[i].getYwrap() == 0)
           {
               // if the lineage isn't yet a tip, we can just make it a tip.
               if(!data[active[i].getMpos()].isTip())
               {
                   data[active[i].getMpos()].setGeneration(generationin);
                   data[active[i].getMpos()].setTip(true);
               }
               // if the lineage is already a tip, we must create a new tip to allow for the simulation building
               // afterwards.
               else
               {
                   enddata++;
                   // need to change the species list reference
                   try
                   {
                       grid[active[i].getYpos()][active[i].getXpos()].setSpecies(active[i].getListpos(),
                                                                                 i);
                   }
                   catch(runtime_error& re)
                   {
                       cerr << "RP_01" << endl;
                       cerr << re.what() << endl;
                       exit(EXIT_FAILURE);
                   }
                   data[enddata].setup(true, active[i].getXpos(), active[i].getYpos(), active[i].getXwrap(),
                                       active[i].getYwrap(), generationin);
                   // Now link the old tip to the new tip
                   data[active[i].getMpos()].setParent(enddata);
                   data[enddata].setIGen(0);
                   data[enddata].setSpec(NR.d01());
                   active[i].setMpos(enddata);
                   //      removeOldPos(chosen);
               }
           }
       }
   
       // add new lineages.
       for(int i = 0; i < grid.GetCols(); i++)
       {
           //          cout << i << endl;
           for(int j = 0; j < grid.GetRows(); j++)
           {
               if(samplegrid.getVal(i, j))
               {
                   unsigned short mapcover = forestmap.getVal(i, j, 0, 0, generationin) * deme_sample;
                   int num_to_add = mapcover - grid[j][i].getListsize();
                   if(num_to_add > 0)
                   {
                       if(mapcover >= grid[j][i].getMaxsize())
                       {
                           grid[j][i].changePercentCover(mapcover);
                       }
                       if(num_to_add + grid[j][i].getListsize() > mapcover)
                       {
                           throw Fatal_Exception("Shouldn't add more than the mapcover.");
                       }
                       for(int k = 0; k < num_to_add; k++)
                       {
                           endactive++;
                           enddata++;
                           int listpos = 0;
                           try
                           {
                               listpos = grid[j][i].addSpecies(endactive);
                           }
                           catch(out_of_range& oor)
                           {
                               cerr << "k: " << k << endl;
                               cerr << "num_to_add: " << num_to_add << endl;
                               cerr << "mapcover: " << mapcover << endl;
                               cerr << "maxsize: " << grid[j][i].getMaxsize() << endl;
                               cerr << "listsize: " << grid[j][i].getListsize() << endl;
                               cerr << oor.what() << endl;
                               exit(EXIT_FAILURE);
                           }
                           // Add the species to active
                           active[endactive].setup(i, j, 0, 0, enddata, listpos, 1);
                           // Add a tip in the Treenode for calculation of the coalescence tree at the
                           // end of the simulation.
                           // This also contains the start x and y position of the species.
                           data[enddata].setup(true, i, j, 0, 0, generationin);
                           data[enddata].setSpec(NR.d01());
                       }
                   }
               }
           }
       }
       // double check sizes
       if(enddata > data.size() || endactive > active.size())
       {
           cerr << "Enddata: " << enddata << endl;
           cerr << "data.size : " << data.size() << endl;
           cerr << "Endactive: " << endactive << endl;
           cerr << "active.size: " << active.size() << endl;
           throw Fatal_Exception("ERROR_MAIN_012: FATAL. Enddata or endactive is greater than the size of the "
                                 "relevant object. Programming error likely.");
       }
       if(endactive > startendactive)
       {
           startendactive = endactive;
       }
   }
   
   unsigned long Tree::sortData()
   {
       // Sort and process the species list so that the useful information can be extracted from it.
       cout << "Finalising data..." << flush;
       // coalescence finished - process speciation
       // check the data structure
       if(enddata > data.size())
       {
           cerr << "enddata: " << enddata << endl;
           cerr << "data.size(): " << data.size() << endl;
           throw Fatal_Exception("Enddata greater than data size. Programming error likely.");
       }
       // Now make sure those left in endactive will definitely speciate.
       for(unsigned int i = 1; i <= endactive; i++)
       {
           // check
           data[active[i].getMpos()].setSpec(0.0);
       }
       // Double check speciation events have been counted.
       unsigned long spec_up_to = 0;
       for(unsigned int i = 1; i <= enddata; i++)
       {
           if(checkSpeciation(data[i].getSpecRate(), spec, data[i].getGenRate()))
           {
               spec_up_to++;
               data[i].speciate();
           }
       }
       // cout << "Precount1: " << lineages.countSpecies() << endl;
       // lineages.resetTree();
       // Calculates the lineage data for the minimum speciation rate. // removed this process as output data is not
       // required to be as a calculated tree.
       // unsigned long spec_up_to = 1;
       // disabled checks...
       // here we check the data is valid - only required for debugging
       try
       {
           for(unsigned long i = 1; i <= enddata; i++)
           {
               if((!(data[i].hasSpeciated())) && (data[i].getParent() == 0 && data[i].getExistance()))
               {
                   throw Main_Exception(string("ERROR_MAIN_004: " + to_string((long long)i) +
                                               " has not speciated and parent is 0."));
               }
               if(data[i].isTip() && !samplegrid.getVal(data[i].getXpos(), data[i].getYpos()))
               {
                   cerr << "ERROR_MAIN_014: Tip assignment error. Samplemask is not correctly assigning tips. "
                           "Check samplemask programming."
                        << endl;
               }
           }
   
           // here we check the data is valid - alternative validity check.
           for(unsigned long i = 1; i <= enddata; i++)
           {
               if(!(data[i].hasSpeciated()) && data[i].getExistance())
               {
                   long j = i;
                   while(!(data[j].hasSpeciated()))
                   {
                       j = data[j].getParent();
                       if(j == 0)
                       {
                           throw Main_Exception(
                               "ERROR_MAIN_005:0 found in parent while following speciation trail.");
                           // string james;
                           // cin >> james;
                       }
                   }
               }
           }
       }
       catch(Main_Exception& me)
       {
           cerr << me.what() << endl;
           cerr << "Returning max possible size (may cause RAM issues)." << endl;
           return data.size();
       }
       cout << "done!" << endl;
       return spec_up_to;
   }
   
   void Tree::outputData()
   {
       unsigned long species_richness = sortData();
       outputData(species_richness);
       return;
   }
   
   void Tree::outputData(unsigned long species_richness)
   {
       // Run the data sorting functions and output the data into the correct format.
       // sort the data
       //          bool loopon;
       // Write the data to the first file
       // species richness data
       cout << "Writing results to file..." << flush;
       ofstream out;
       out.precision(10);
       string filename_ab;
       // sprintf (filename_ab, "%s/Data_%i.csv",outdirectory, int(the_task)); // altered in v3.0
       filename_ab = outdirectory + string("/Data_") + to_string((long long)the_task) + "_" +
                     to_string((long long)the_seed) + string(".csv");
       out.open(filename_ab);
       // Simulation fixed variables
       out << "random_seed=," << the_seed << "\n";
       out << "fine map=," << finemapinput << "\n";
       out << "fine map x y," << finemapxsize << " - " << finemapysize << "\n";
       out << "coarse map=," << coarsemapinput << "\n";
       out << "coarse map x y," << coarsemapxsize * deme << " - " << coarsemapysize * deme << "\n";
       out << "deme=," << deme << "\n";
       out << "deme_sample=," << deme_sample << "\n";
       out << "spec=," << spec << "\n";
       out << "sigma=," << sigma << "\n";
       out << "maxtime=," << maxtime << "\n\n";
       out << "species_richness=," << species_richness << "\n\n";
       out.close();
   
       // now we sort the map output and store to another file
       // removed the sparse output format - v3.0
       // this bit is now uneccessary and has been removed.
       /*
       if(false)
       {
               // output data as matrix
               string filename_map;
   //              char filename_map[100];
   //              sprintf (filename_ab, "%s/Map_dense%i.csv",outdirectory, int(the_task));
               filename_map = outdirectory + string("/Map_dense") + to_string(the_task)+"_"+to_string(the_seed) +
   string(".csv");
   
               out.open(filename_map);
   
               Matrix<unsigned short> toret;
               toret.SetSize(finemapysize,finemapxsize);
               for (long i = 0 ; i < finemapysize; i ++)
               {
                       for (long j = 0 ; j < finemapxsize; j ++)
                       {
                               toret[i][j] = 0;
                       }
               }
   
               for (unsigned long i = 1 ; i <= enddata ; i ++)
               {
                       if (data[i].isTip())
                       {
                               // Write data to a toret object.
                               toret[data[i].getYpos()][data[i].getXpos()]++;
   
                       }
               }
               // Write toret object to a file.
               out << toret << "\n";
               out.close();
       }
       //*/
       cout << "done!              " << endl;
       time(&out_finish);
   #ifdef sql_ram
       sqlOutput();
   #endif
       time(&sim_end);
       writeTimes();
   }
   
   void Tree::writeTimes()
   {
       cout << "Total generations simulated (steps): " << generation << " (" << steps << ")" << endl;
       cout << "Setup time was " << floor((sim_start - start) / 60) << " minutes " << (sim_start - start) % 60
            << " seconds" << endl;
       cout << "Simulation time was " << floor((sim_finish - sim_start) / 3600) << " hours "
            << (floor((sim_finish - sim_start) / 60) - 60 * floor((sim_finish - sim_start) / 3600)) << " minutes "
            << (sim_finish - sim_start) % 60 << " seconds" << endl;
       cout << "File output and species calculation time was " << floor((out_finish - sim_finish) / 60) << " minutes "
            << (out_finish - sim_finish) % 60 << " seconds" << endl;
       cout << "SQL output time was " << floor((sim_end - out_finish) / 60) << " minutes " << (sim_end - out_finish) % 60
            << " seconds" << endl;
       cout << "Total time taken was " << floor((time_taken) / 3600) << " hours " << flush;
       cout << (floor((time_taken) / 60) - 60 * floor((time_taken) / 3600)) << flush;
       cout << " minutes " << (time_taken) % 60 << " seconds" << endl;
   }
   
   void Tree::simPause()
   {
       // Completely changed how this sections works - it won't currently allow restarting of the simulations, but will
       // dump the data file to memory. - simply calls sqlCreate and sqlOutput.
       // sqlCreate();
       // sqlOutput();
   
       // This function saves the data to 4 files. One contains the main simulation parameters, the other 3 contain the
       // simulation results thus far
       // including the grid object, data object and active object.
       cout << "Pausing simulation..." << endl << "Saving data to temp file in " << outdirectory << "/Pause/ ..." << flush;
       ofstream out;
       out.precision(10);
       string file_to_open;
       // Create the pause directory
       string pause_folder = outdirectory + "/Pause/";
       boost::filesystem::path pause_dir(pause_folder);
       if(!boost::filesystem::exists(pause_dir))
       {
           try
           {
               boost::filesystem::create_directory(pause_dir);
           }
           catch(exception& e)
           {
               cerr << "Failure to create " << outdirectory << "/Pause/"
                    << "." << endl;
               cerr << e.what() << endl;
               cerr << "Writing directly to output directory." << endl;
               pause_folder = outdirectory;
           }
       }
       try
       {
           file_to_open = pause_folder + "Dump_main_" + to_string(the_task) + "_" + to_string(the_seed) + ".csv";
           out.open(file_to_open.c_str());
           out << setprecision(16);
           // Saving the initial data to one file.
           out << enddata << "\n" << seeded << "\n" << the_seed << "\n" << the_task << "\n" << autocorrel_file << "\n"
               << bAutocorrel << "\n" << bSpec << "\n";
           out << finemapinput << "\n" << coarsemapinput << "\n" << outdirectory << "\n" << pristinefinemapinput
               << "\n" << pristinecoarsemapinput << "\n";
           out << dPristine << "\n" << dForestTransform << "\n" << gridxsize << "\n" << gridysize << "\n"
               << finemapxsize << "\n" << finemapysize << "\n";
           out << finemapxoffset << "\n" << finemapyoffset << "\n" << coarsemapxsize << "\n" << coarsemapysize << "\n"
               << coarsemapxoffset << "\n";
           out << coarsemapyoffset << "\n" << coarsemapscale << "\n" << varimport << "\n" << start << "\n" << sim_start
               << "\n" << sim_end << "\n" << now << "\n";
           out << time_taken << "\n" << sim_finish << "\n" << out_finish << "\n" << endactive << "\n" << startendactive
               << "\n" << maxsimsize << "\n" << steps << "\n";
           out << generation << "\n" << sigma << "\n" << nu << "\n" << maxtime << "\n" << deme_sample << "\n"
               << spec << "\n" << lambda << "\n" << deme << "\n";
           out << desired_specnum << "\n" << sqloutname << "\n" << NR << "\n" << mapvarsin << "\n";
           out.close();
       }
       catch(exception& e)
       {
           cerr << e.what() << endl;
           cerr << "Failed to perform main dump to " << pause_folder << endl;
       }
       try
       {
           // Saving the larger data in single files for simpler reading in.
           // Output the grid object
           ofstream out2;
           file_to_open = pause_folder + "Dump_grid_" + to_string(the_task) + "_" + to_string(the_seed) + ".csv";
           out2.precision(16);
           out2.open(file_to_open.c_str());
           out2 << grid;
           out2.close();
       }
       catch(exception& e)
       {
           cerr << e.what() << endl;
           cerr << "Failed to perform grid dump to " << pause_folder << endl;
       }
       try
       {
           // Output the active object
           ofstream out3;
           file_to_open = pause_folder + "Dump_active_" + to_string(the_task) + "_" + to_string(the_seed) + ".csv";
           out3.precision(16);
           out3.open(file_to_open.c_str());
           out3 << active;
           out3.close();
       }
       catch(exception& e)
       {
           cerr << e.what() << endl;
           cerr << "Failed to perform active dump to " << pause_folder << endl;
       }
       try
       {
           // Output the data object
           ofstream out4;
           file_to_open = pause_folder + "Dump_data_" + to_string(the_task) + "_" + to_string(the_seed) + ".csv";
           out4.precision(16);
           out4.open(file_to_open.c_str());
           out4 << data;
           out4.close();
       }
       catch(exception& e)
       {
           cerr << e.what() << endl;
           cerr << "Failed to perform data dump to " << pause_folder << endl;
       }
       try
       {
           // Output the data object
           ofstream out4;
           file_to_open = pause_folder + "Dump_map_" + to_string(the_task) + "_" + to_string(the_seed) + ".csv";
           out4.precision(16);
           out4.open(file_to_open.c_str());
           out4 << forestmap;
           out4.close();
       }
       catch(exception& e)
       {
           cerr << e.what() << endl;
           cerr << "Failed to perform map dump to " << pause_folder << endl;
       }
       cout << "done!" << endl;
       cout << "SQL dump started" << endl;
       time(&out_finish);
       sqlCreate();
   #ifdef sql_ram
       sqlOutput();
   #endif
       cout << "Data dump complete" << endl;
       time(&sim_end);
       writeTimes();
   }
   
   void Tree::setResumeParameters(string outdir, unsigned long seed, unsigned long task, double new_max_time)
   {
       outdirectory = outdir;
       the_seed = seed;
       the_task = task;
       maxtime = new_max_time;
   }
   
   void Tree::loadMainSave()
   {
       string file_to_open;
       try
       {
           cout << "\rLoading data from temp file...main..." << flush;
           ifstream in1;
           //      char file_to_open[100];
           //      sprintf(file_to_open,"%s/Pause/Data_%i.csv",outdirectory,int(the_task));
           file_to_open = outdirectory + string("/Pause/Dump_main_") + to_string(the_task) + "_" +
                          to_string(the_seed) + string(".csv");
           in1.open(file_to_open);
           // Reading the initial data
           in1 >> enddata >> seeded >> the_seed >> the_task >> autocorrel_file >> bAutocorrel >> bSpec;
           in1 >> finemapinput >> coarsemapinput >> outdirectory >> pristinefinemapinput >> pristinecoarsemapinput;
           //          cout << "test1" << endl;
           //          cout << "pristinemapcoarseinput: " << pristinecoarsemapinput << endl;
           in1 >> dPristine >> dForestTransform >> gridxsize >> gridysize >> finemapxsize >> finemapysize;
           in1 >> finemapxoffset >> finemapyoffset >> coarsemapxsize >> coarsemapysize >> coarsemapxoffset;
           //          cout << "test1" << endl;
           time_t tmp_time;
           in1 >> coarsemapyoffset >> coarsemapscale >> varimport >> tmp_time >> sim_start >> sim_end >> now;
           //          cout << "sim_start: " << sim_start << endl;
           in1 >> time_taken >> sim_finish >> out_finish >> endactive >> startendactive >> maxsimsize >> steps;
           //          cout << "test1" << endl;
           //          cout << "steps: " << steps << endl;
           double tempmaxtime;
           in1 >> generation >> sigma >> nu >> tempmaxtime;
           //          cout << "test1" << endl;
           if(maxtime == 0)
           {
               maxtime = tempmaxtime;
           }
           //          cout << "tempmaxtime: " << tempmaxtime << endl;
           in1 >> deme_sample >> spec >> lambda >> deme;
           //          cout << "deme_sample: " << deme_sample << endl;
           //          cout << "spec: " << spec << endl;
           //          cout << "lambda: " << lambda << endl;
           //          cout << "deme: " << deme << endl;
           //          cout << "teststart" << endl;
           //          cout << "deme: " << deme << endl;
           in1 >> desired_specnum >> sqloutname;
           //          cout << "desired spec_num: " << desired_specnum <<endl;
           //          cout << "sqloutname: " << sqloutname << endl;
           //          string tmp;
           //          getline(in1, tmp);
           //          cout << "tmp: " << tmp << endl;
           in1 >> NR;
           //          cout << "NR1: " << NR << endl;
           in1 >> mapvarsin;
           //          cout << "mapvars: fine: " << mapvarsin.finemapfile << endl;
           //          cout << "mapvars: coarse: " << mapvarsin.coarsemapfile << endl;
           //          cout << "mapvars: sample: " << mapvarsin.samplemaskfile << endl;
           //          cout << mapvarsin.samplemaskfile << endl;
           //          cout << "mapvarsin: " << mapvarsin << endl;
           //          cout << "testend" << endl;
           in1.close();
           // cout << "file closed" << endl;
           try
           {
               if(autocorrel_file == "null")
               {
                   if(bAutocorrel == true)
                   {
                       throw runtime_error("bAutocorrel should not be true");
                   }
               }
               else
               {
                   if(bAutocorrel == false)
                   {
                       throw runtime_error("bAutocorrel should not be false");
                   }
                   vector<string> tmpimport;
                   ConfigOption tmpconfig;
                   tmpconfig.setConfig(autocorrel_file, false);
                   tmpconfig.importConfig(tmpimport);
                   for(unsigned int i = 0; i < tmpimport.size(); i++)
                   {
                       autocorrel_times.push_back(stod(tmpimport[i]));
                       //                  cout << "t_i: " << autocorrel_times[i] << endl;
                   }
               }
           }
           catch(Config_Exception& ce)
           {
               cerr << ce.what() << endl;
           }
       }
       catch(exception& e)
       {
           cerr << e.what() << endl;
           cerr << "Failure to import from " << file_to_open << endl;
       }
   }
   
   void Tree::loadDataSave()
   {
       string file_to_open;
       // Input the data object
       try
       {
           cout << "\rLoading data from temp file...data..." << flush;
           ifstream in4;
           //      sprintf(file_to_open,"%s/Pause/Data_%i_data.csv",outdirectory,int(the_task));
           file_to_open = outdirectory + string("/Pause/Dump_data_") + to_string(the_task) + "_" +
                          to_string(the_seed) + string(".csv");
           in4.open(file_to_open);
           in4 >> data;
           //          cout << data[0] << endl;
           //          cout << data[1] << endl;
           in4.close();
       }
       catch(exception& e)
       {
           cerr << e.what() << endl;
           cerr << "Failure to import from " << file_to_open << endl;
       }
   }
   
   void Tree::loadActiveSave()
   {
       string file_to_open;
       try
       {
           cout << "\rLoading data from temp file...active..." << flush;
           // Input the active object
           ifstream in3;
           //      sprintf(file_to_open,"%s/Pause/Data_%i_active.csv",outdirectory,int(the_task));
           file_to_open = outdirectory + string("/Pause/Dump_active_") + to_string(the_task) + "_" +
                          to_string(the_seed) + string(".csv");
           in3.open(file_to_open);
           in3 >> active;
           //          cout << active[0] << endl;
           //          cout << active[1] << endl;
           in3.close();
       }
       catch(exception& e)
       {
           cerr << e.what() << endl;
           cerr << "Failure to import from " << file_to_open << endl;
       }
   }
   
   void Tree::loadGridSave()
   {
       string file_to_open;
       try
       {
           cout << "\rLoading data from temp file...grid..." << flush;
           // Reading the larger data from individual files.
           // Input the grid object
           ifstream in2;
           //      sprintf(file_to_open,"%s/Pause/Data_%i_grid.csv",outdirectory,int(the_task));
           file_to_open = outdirectory + string("/Pause/Dump_grid_") + to_string(the_task) + "_" +
                          to_string(the_seed) + string(".csv");
           in2.open(file_to_open);
           //          grid.SetSize(gridysize, gridxsize);
           // grid.SetSize(1,400);
           in2 >> grid;
           in2.close();
       }
       catch(exception& e)
       {
           cerr << e.what() << endl;
           cerr << "Failure to import from " << file_to_open << endl;
       }
   }
   
   void Tree::loadMapSave()
   {
       string file_to_open;
       // Input the map object
       try
       {
           cout << "\rLoading data from temp file...map..." << flush;
           ifstream in5;
           //      sprintf(file_to_open,"%s/Pause/Data_%i_data.csv",outdirectory,int(the_task));
           file_to_open = outdirectory + string("/Pause/Dump_map_") + to_string(the_task) + "_" + to_string(the_seed) +
                          string(".csv");
           in5.open(file_to_open);
           in5 >> forestmap;
           in5.close();
       }
       catch(exception& e)
       {
           cerr << e.what() << endl;
           cerr << "Failure to import from " << file_to_open << endl;
       }
   }
   
   void Tree::simResume(bool cont_sim)
   {
       // Start the timer
       time(&start);
       // Only resume the simulation if there is a simulation to resume from.
       if(!cont_sim)
       {
           return;
       }
       // Loads the data from the files into the relevant objects.
       cout << "Resuming simulation..." << endl << "Loading data from temp file..." << flush;
   
       // now load the objects
       loadMainSave();
       loadMapSave();
       setObjectSizes();
       loadActiveSave();
       loadDataSave();
       loadGridSave();
       time(&sim_start);
       cout << "\rLoading data from temp file...done!" << endl;
   }
   
   void Tree::sqlCreate()
   {
       time(&out_finish);
       cout << "Creating SQL database file..." << endl;
       cout << "    Checking for existing folders...." << flush;
       // Create the folder if it doesn't exist
       sqloutname = outdirectory;
       string sqlfolder = outdirectory + "/SQL_data/";
       try
       {
           boost::filesystem::path dir(sqlfolder);
           if(!boost::filesystem::exists(dir))
           {
               cout << "\r    SQL_data folder not found....creating..." << flush;
               if(boost::filesystem::create_directory(sqlfolder))
               {
                   cout << "\r    SQL_data folder created successfully                             " << flush;
               }
               else
               {
                   cout << "\r    SQL_data folder not created successfully                             "
                        << endl;
                   throw Main_Exception("ERROR_SQL_012: SQL folder could not be created. Check write "
                                        "permissions and that the parent folder is accessible.");
               }
           }
           else
           {
               cout << "\r    Checking for existing folders....done!        " << flush;
           }
           // create the empty file, deleting if it exists.
           sqloutname += string("/SQL_data/data_") + to_string(the_task) + "_" + to_string(the_seed) + ".db";
       }
       catch(Main_Exception& me)
       {
           cerr << me.what() << endl;
           sqloutname = string("data_") + to_string(the_task) + "_" + to_string(the_seed) + ".db";
       }
       //      remove(sqloutname.c_str());
       cout << "\r    Generating species list....              " << flush;
       // for outputting the full data from the simulation in to a SQL file.
       sqlite3_stmt* stmt;
       char* sErrMsg;
       int rc = 0;
   // Open a SQL database in memory. This will be written to disk later.
   // A check here can be done to write to disc directly instead to massively reduce RAM consumption
   #ifdef sql_ram
       sqlite3_open(":memory:", &database);
   #endif
   #ifndef sql_ram
       rc = sqlite3_open_v2(sqloutname.c_str(), &database, SQLITE_OPEN_READWRITE | SQLITE_OPEN_CREATE, "unix-dotfile");
   
   #endif
       // Create the command to be executed by adding to the string.
       string all_commands;
       all_commands =
           "CREATE TABLE SPECIES_LIST (ID int PRIMARY KEY NOT NULL, unique_spec INT NOT NULL, xval INT NOT NULL,";
       all_commands += "yval INT NOT NULL, xwrap INT NOT NULL, ywrap INT NOT NULL, tip INT NOT NULL, speciated INT NOT "
                       "NULL, parent INT NOT NULL,existance INT NOT NULL,randnum DOUBLE NOT NULL, gen_alive INT NOT "
                       "NULL,gen_added DOUBLE NOT NULL);";
   
       // Create the table within the SQL database
       rc = sqlite3_exec(database, all_commands.c_str(), NULL, NULL, &sErrMsg);
       if(rc != SQLITE_OK)
       {
   #ifndef sql_ram
           sqlite3_close(database);
           //          cerr << "unix-dotfile not working - attempting default SQL VFS method..." << flush;
           // delete any old database files - this is risky, but there isn't a better way of ensuring that the file
           // actually gets created.
           remove(sqloutname.c_str());
           rc = sqlite3_open(sqloutname.c_str(), &database);
           rc = sqlite3_exec(database, all_commands.c_str(), NULL, NULL, &sErrMsg);
           if(rc == SQLITE_OK)
           {
               //              cerr << "done! Default unix VFS method functional." << endl;
           }
           else
           {
               cerr << "Database file creation failed. Check file system." << endl;
               cerr << "Error code: " << rc << endl;
               exit(-1);
           }
   #endif
           if(rc != SQLITE_OK)
           {
               cerr << "ERROR_SQL_007: Cannot generate in-memory table. Check memory database assignment and SQL "
                       "commands."
                    << endl;
               cerr << "Error code: " << rc << endl;
           }
       }
       // Now create the prepared statement into which we shall insert the values from the table
       all_commands = "INSERT INTO SPECIES_LIST "
                      "(ID,unique_spec,xval,yval,xwrap,ywrap,tip,speciated,parent,existance,randnum,gen_alive,gen_added) "
                      "VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?)";
       sqlite3_prepare_v2(database, all_commands.c_str(), strlen(all_commands.c_str()), &stmt, NULL);
   
       // Start the transaction
       rc = sqlite3_exec(database, "BEGIN TRANSACTION;", NULL, NULL, &sErrMsg);
       if(rc != SQLITE_OK)
       {
           cerr << "ERROR_SQL_008: Cannot start SQL transaction. Check memory database assignment and SQL commands."
                << endl;
       }
       for(unsigned int i = 0; i <= enddata; i++)
       {
           sqlite3_bind_int(stmt, 1, i);
           sqlite3_bind_int(stmt, 2, data[i].getSpeciesID());
           sqlite3_bind_int(stmt, 3, data[i].getXpos());
           sqlite3_bind_int(stmt, 4, data[i].getYpos());
           sqlite3_bind_int(stmt, 5, data[i].getXwrap());
           sqlite3_bind_int(stmt, 6, data[i].getYwrap());
           sqlite3_bind_int(stmt, 7, data[i].isTip());
           sqlite3_bind_int(stmt, 8, data[i].hasSpeciated());
           sqlite3_bind_int(stmt, 9, data[i].getParent());
           sqlite3_bind_int(stmt, 10, data[i].getExistance());
           sqlite3_bind_double(stmt, 11, data[i].getSpecRate());
           sqlite3_bind_int(stmt, 12, data[i].getGenRate());
           sqlite3_bind_double(stmt, 13, data[i].getGeneration());
           sqlite3_step(stmt);
           sqlite3_clear_bindings(stmt);
           sqlite3_reset(stmt);
       }
   
       cout << "\r    Executing SQL commands...." << flush;
       // execute the command and close the connection to the database
       rc = sqlite3_exec(database, "END TRANSACTION;", NULL, NULL, &sErrMsg);
       if(rc != SQLITE_OK)
       {
           cerr << "ERROR_SQL_008: Cannot complete SQL transaction. Check memory database assignment and SQL "
                   "commands. Ensure SQL statements are properly cleared."
                << endl;
           cerr << "Error code: " << rc << endl;
           // try again
           int i = 0;
           while((rc != SQLITE_OK && rc != SQLITE_DONE) && i < 10)
           {
               sleep(1);
               i++;
               rc = sqlite3_exec(database, "END TRANSACTION;", NULL, NULL, &sErrMsg);
               cerr << "Attempt " << i << " failed..." << endl;
               cerr << "ERROR_SQL_008: Cannot complete SQL transaction. Check memory database assignment and SQL "
                       "commands. Ensure SQL statements are properly cleared."
                    << endl;
           }
       }
       // Need to finalise the statement
       rc = sqlite3_finalize(stmt);
       if(rc != SQLITE_OK)
       {
           cerr << "ERROR_SQL_008: Cannot complete SQL transaction. Check memory database assignment and SQL "
                   "commands. Ensure SQL statements are properly cleared."
                << endl;
           cerr << "Error code: " << rc << endl;
       }
       // Vacuum the file so that the file size is reduced (reduces by around 3%)
       rc = sqlite3_exec(database, "VACUUM;", NULL, NULL, &sErrMsg);
       if(rc != SQLITE_OK)
       {
           cerr << "ERROR_SQL_014: Cannot vacuum the database. Error message: " << sErrMsg << endl;
       }
   
       // Now additionally store the simulation parameters (extremely useful data)
       string to_execute = "CREATE TABLE SIMULATION_PARAMETERS (seed INT PRIMARY KEY not null, job_type INT NOT NULL,";
       to_execute += "output_dir TEXT NOT NULL, spec_rate DOUBLE NOT NULL, sigma DOUBLE NOT NULL,nu DOUBLE NOT "
                     "NULL, deme INT NOT NULL, ";
       to_execute += "sample_size DOUBLE NOT NULL, max_time DOUBLE NOT NULL, lambda DOUBLE NOT NULL, min_num_species ";
       to_execute += "INT NOT NULL, forest_change_param DOUBLE NOT NULL, time_since_pristine DOUBLE NOT NULL, ";
       to_execute += "time_config_file TEXT NOT NULL, coarse_map_file TEXT NOT NULL, coarse_map_x INT NOT NULL, "
                     "coarse_map_y INT NOT NULL,";
       to_execute += "coarse_map_x_offset INT NOT NULL, coarse_map_y_offset INT NOT NULL, coarse_map_scale DOUBLE NOT "
                     "NULL, fine_map_file TEXT NOT NULL, fine_map_x INT NOT NULL,";
       to_execute += "fine_map_y INT NOT NULL, fine_map_x_offset INT NOT NULL, fine_map_y_offset INT NOT NULL, ";
       to_execute += "sample_file TEXT NOT NULL, grid_x INT NOT NULL, grid_y INT NOT NULL,";
       to_execute += "pristine_coarse_map TEXT NOT NULL, pristine_fine_map TEXT NOT NULL, sim_complete INT NOT NULL);";
       rc = sqlite3_exec(database, to_execute.c_str(), NULL, NULL, &sErrMsg);
       if(rc != SQLITE_OK)
       {
           cerr << "ERROR_SQL_008: Cannot start SQL transaction. Check memory database assignment and SQL commands."
                << endl;
           cerr << "Error code: " << rc << endl;
       }
       to_execute = "INSERT INTO SIMULATION_PARAMETERS VALUES(" + to_string((long long)the_task) + "," +
                    to_string((long long)the_seed);
       to_execute += ",'" + outdirectory + "'," + boost::lexical_cast<std::string>((long double)spec) + "," +
                     to_string((long double)sigma) + ",";
       to_execute += to_string((long double)nu) + "," + to_string((long long)deme) + ",";
       to_execute += to_string((long double)deme_sample) + "," + to_string((long double)maxtime) + ",";
       to_execute += to_string((long double)lambda) + "," + to_string((long long)desired_specnum) + ",";
       to_execute += to_string((long double)mapvarsin.dForestTransform) + ",";
       to_execute += to_string((long double)mapvarsin.dPristine) + ",'" + mapvarsin.autocorrel_file + "','";
       to_execute += coarsemapinput + "'," + to_string((long long)coarsemapxsize) + ",";
       to_execute += to_string((long long)coarsemapysize) + "," + to_string((long long)coarsemapxoffset) + ",";
       to_execute += to_string((long long)coarsemapyoffset) + "," + to_string((long long)coarsemapscale) + ",'";
       to_execute += finemapinput + "'," + to_string((long long)finemapxsize) + "," + to_string((long long)finemapysize);
       to_execute += "," + to_string((long long)finemapxoffset) + "," + to_string((long long)finemapyoffset) + ",'";
       to_execute += mapvarsin.samplemaskfile + "'," + to_string((long long)gridxsize) + "," +
                     to_string((long long)gridysize) + ",'";
       to_execute += pristinecoarsemapinput + "','" + pristinefinemapinput + "'," + to_string(sim_complete) + ");";
       rc = sqlite3_exec(database, to_execute.c_str(), NULL, NULL, &sErrMsg);
       if(rc != SQLITE_OK)
       {
           cout << to_execute << endl;
           cout << boost::lexical_cast<std::string>((double)spec) << endl;
           cout << spec << endl;
           cerr << "ERROR_SQL_008: Cannot start SQL transaction. Check memory database assignment and SQL commands."
                << endl;
           cerr << "Error code: " << rc << endl;
       }
       cout << "done!" << endl;
   }
   
   void Tree::sqlOutput()
   {
   #ifdef sql_ram
       // open connection to the database file
       remove(sqloutname.c_str());
       cout << "\r    Writing to " << sqloutname << " ....     " << flush;
       int rc =
           sqlite3_open_v2(sqloutname.c_str(), &outdatabase, SQLITE_OPEN_READWRITE | SQLITE_OPEN_CREATE, "unix-dotfile");
       if(rc != SQLITE_OK && rc != SQLITE_DONE)
       {
           int i = 0;
           while((rc != SQLITE_OK && rc != SQLITE_DONE) && i < 10)
           {
               i++;
               sleep(1);
               rc = sqlite3_open_v2(sqloutname.c_str(), &outdatabase, SQLITE_OPEN_READWRITE | SQLITE_OPEN_CREATE,
                                    "unix-dotfile");
               //              cerr << "Attempt " << i << " failed..." << endl;
           }
           // Attempt different opening method if the first fails.
           int j = 0;
           while((rc != SQLITE_OK && rc != SQLITE_DONE) && j < 10)
           {
               j++;
               sleep(1);
               rc = sqlite3_open(sqloutname.c_str(), &outdatabase);
               //              cerr << "Attempt " << i << " failed..." << endl;
           }
           if(rc != SQLITE_OK && rc != SQLITE_DONE)
           {
               cerr << "ERROR_SQL_010: SQLite database file could not be opened. Check the folder exists and you "
                       "have write permissions. (REF1) Error code: "
                    << rc << endl;
               cerr << "Attempted call " << max(i, j) << " times" << endl;
           }
       }
       // create the backup object to write data to the file from memory.
       sqlite3_backup* backupdb;
       backupdb = sqlite3_backup_init(outdatabase, "main", database, "main");
       if(!backupdb)
       {
           cerr << "ERROR_SQL_011: Could not write to the backup database. Check the file exists." << endl;
       }
       // Perform the backup
       rc = sqlite3_backup_step(backupdb, -1);
       if(rc != SQLITE_OK && rc != SQLITE_DONE)
       {
           //          cerr <<  "ERROR_SQL_010: SQLite database file could not be opened. Check the folder
           // exists
           // and
           // you
           // have write permissions. (REF2) Error code: " << rc << endl;
           // try again
           int i = 0;
           while((rc != SQLITE_OK && rc != SQLITE_DONE) && i < 10)
           {
               i++;
               sleep(1);
               rc = sqlite3_backup_step(backupdb, -1);
               //              cerr << "Attempt " << i << " failed..." << endl;
           }
           if(rc != SQLITE_OK && rc != SQLITE_DONE)
           {
               cerr << "ERROR_SQL_010: SQLite database file could not be opened. Check the folder exists and you "
                       "have write permissions. (REF3) Error code: "
                    << rc << endl;
               cerr << "Attempted call " << i << " times" << endl;
           }
       }
       sqlite3_backup_finish(backupdb);
       //      sqlite3_exec(database,"VACUUM;",NULL,NULL,&sErrMsg);
       sqlite3_close(database);
       sqlite3_close(outdatabase);
       cout << "\r    Writing to " << sqloutname << " ....  done!              " << endl;
   #endif
   }
   
   void Tree::applySpecRates(double sr, double t)
   {
       if(!tl.hasImportedData())
       {
           tl.setDatabase(database);
       }
       // cout << "Precount: " << tl.countSpecies() << endl;
       tl.setGeneration(t);
       tl.resetTree();
       tl.internalOption();
       tl.createDatabase(sr);
   
   #ifdef record_space
       tl.recordSpatial();
   #endif
   }
   
   void Tree::applySpecRates(double sr)
   {
       applySpecRates(sr, 0.0);
   }


