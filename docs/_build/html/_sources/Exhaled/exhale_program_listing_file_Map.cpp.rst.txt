.. _program_listing_file_Map.cpp:

Program Listing for File Map.cpp
========================================================================================

- Return to documentation for :ref:`file_Map.cpp`

.. code-block:: cpp

   // This file is part of NECSim project which is released under BSD-3 license.
   // See file **LICENSE.txt** or visit https://opensource.org/licenses/BSD-3-Clause) for full license details
   #include "Map.h"
   #include "Setup.h"
   
   void Map::setDims(Mapvars mapvarsin)
   {
       if(!checksetdim)  // checks to make sure it hasn't been run already.
       {
           mapvars = mapvarsin;
           deme = mapvarsin.deme;
           xdim = mapvarsin.vargridxsize;
           ydim = mapvarsin.vargridysize;
           scale = mapvarsin.varcoarsemapscale;
           nUpdate = 0;
           checksetdim = true;
           dUpdateTime = 0;
           dPristine = mapvarsin.dPristine;
           dForestTransform = mapvarsin.dForestTransform;
       }
       else
       {
           cerr << "ERROR_MAP_001: Dimensions have already been set" << endl;
           return;
       }
       return;
   }
   
   bool Map::checkMapExists()
   {
       for(unsigned int i = 0; i < mapvars.configs.getSectionOptionsSize(); i++)
       {
           string tmppath = mapvars.configs[i].getOption("path");
           if(!doesExistNull(tmppath))
           {
               return (false);
           }
       }
       return (true);
   }
   
   void Map::calcFineMap()
   {
       string fileinput = mapvars.finemapfile;
       long mapxsize = mapvars.varfinemapxsize;
       long mapysize = mapvars.varfinemapysize;
       if(!checksetdim)  // checks that the dimensions have been set.
       {
           throw Map_Exception("ERROR_MAP_002: dimensions not set.");
       }
       // Note that the default "null" type is to have 100% forest cover in every cell.
       Matrix<float> toret;
       toret.SetSize(mapysize, mapxsize);
       fine_map.SetSize(mapysize, mapxsize);
       #ifdef DEBUG
       cerr << "Calculating fine map" << endl;
       #endif
       if(fileinput == "null")
       {
           for(int i = 0; i < mapysize; i++)
           {
               for(int j = 0; j < mapxsize; j++)
               {
                   toret[i][j] = 1.0;
               }
           }
       }
       else  // There is a map to read in.
       {
           toret.import(fileinput);
       }
       #ifdef DEBUG
       cerr << "import complete" << endl;
       // cout << toret << endl;
       #endif
       for(int i = 0; i < mapysize; i++)
       {
           for(int j = 0; j < mapxsize; j++)
           {
               fine_map[i][j] = round(toret[i][j] * deme);
   //          cout << fine_map[j][i] << endl;
           }
       }
       #ifdef DEBUG
       cerr << "modification complete" << endl;
       #endif
       // cout << "deme: " << deme << endl;
       return;
       //*/
   }
   
   void Map::calcPristineFineMap()
   {
   //  cout << "pristine fine map file: " << mapvars.pristinefinemapfile << endl;
       string fileinput = mapvars.pristinefinemapfile;
       long mapxsize = mapvars.varfinemapxsize;
       long mapysize = mapvars.varfinemapysize;
       if(!checksetdim)  // checks that the dimensions have been set.
       {
           throw Map_Exception("ERROR_MAP_002: dimensions not set.");
       }
       // Note that the default "null" type is to have 100% forest cover in every cell.
       Matrix<float> toret;
       toret.SetSize(mapysize, mapxsize);
       pristine_fine_map.SetSize(mapysize, mapxsize);
       if(fileinput == "null")
       {
           for(int i = 0; i < mapxsize; i++)
           {
               for(int j = 0; j < mapysize; j++)
               {
                   toret[j][i] = 1.0;
               }
           }
       }
       else  // There is a map to read in.
       {
           toret.import(fileinput);
       }
       // cout << toret << endl;
       for(int i = 0; i < mapysize; i++)
       {
           for(int j = 0; j < mapxsize; j++)
           {
               pristine_fine_map[i][j] = round(toret[i][j] * deme);
           }
       }
       // cout << "deme: " << deme << endl;
       return;
   }
   
   void Map::calcCoarseMap()
   {
       string fileinput = mapvars.coarsemapfile;
       long mapxsize = mapvars.varcoarsemapxsize;
       long mapysize = mapvars.varcoarsemapysize;
       if(!checksetdim)  // checks that the dimensions have been set.
       {
           throw Map_Exception("ERROR_MAP_003: dimensions not set.");
       }
       // Note that the default "null" type for the coarse type is to have non-forest in every cell.
       Matrix<float> toret;
       toret.SetSize(mapysize, mapxsize);
       coarse_map.SetSize(mapysize, mapxsize);
       if(fileinput == "null")
       {
           for(int i = 0; i < mapxsize; i++)
           {
               for(int j = 0; j < mapysize; j++)
               {
                   toret[j][i] = 0.0;
               }
           }
       }
       else  // There is a map to read in.
       {
           toret.import(fileinput);
       }
       for(int i = 0; i < mapysize; i++)
       {
           for(int j = 0; j < mapxsize; j++)
           {
               coarse_map[i][j] = round(toret[i][j] * deme * scale * scale);
           }
       }
       return;
   }
   
   void Map::calcPristineCoarseMap()
   {
   //  cout << "pristine coarse map file: " << mapvars.pristinecoarsemapfile << endl;
       string fileinput = mapvars.pristinecoarsemapfile;
       long mapxsize = mapvars.varcoarsemapxsize;
       long mapysize = mapvars.varcoarsemapysize;
       if(!checksetdim)  // checks that the dimensions have been set.
       {
           throw Map_Exception("ERROR_MAP_003: dimensions not set.");
       }
       // Note that the default "null" type for the coarse type is to have non-forest in every cell.
       Matrix<float> toret;
       toret.SetSize(mapysize, mapxsize);
       pristine_coarse_map.SetSize(mapysize, mapxsize);
       if(fileinput == "null")
       {
           for(int i = 0; i < mapxsize; i++)
           {
               for(int j = 0; j < mapysize; j++)
               {
                   toret[j][i] = 1.0;
               }
           }
       }
       else  // There is a map to read in.
       {
           toret.import(fileinput);
       }
       for(int i = 0; i < mapysize; i++)
       {
           for(int j = 0; j < mapxsize; j++)
           {
               pristine_coarse_map[i][j] = round(toret[i][j] * deme * scale * scale);
           }
       }
   
       return;
   }
   
   void Map::setTimeVars(double dPristinein, double dForestTransformin)
   {
       dUpdateTime = 0;
       dPristine = dPristinein;
       dForestTransform = dForestTransformin;
   }
   
   void Map::calcOffset()
   {
       if(mapvars.autocorrel_file != "null")
       {
           mapvars.setPristine(0);
       }
   //  cout << mapvars.autocorrel_file << endl;
       if(fine_map.GetCols() == 0 || fine_map.GetRows() == 0)
       {
           throw Map_Exception("ERROR_MAP_004: fine map not set.");
       }
       if(coarse_map.GetCols() == 0 || coarse_map.GetRows() == 0)
       {
           coarse_map.SetSize(fine_map.GetRows(), fine_map.GetCols());
   //      throw Map_Exception("ERROR_MAP_004: coarse map not set.");
       }
       finexoffset = mapvars.varfinemapxoffset;
       fineyoffset = mapvars.varfinemapyoffset;
       coarsexoffset = mapvars.varcoarsemapxoffset;
       coarseyoffset = mapvars.varcoarsemapyoffset;
       scale = mapvars.varcoarsemapscale;
       // this is the location of the top left (or north west) corner of the respective map
       // and the x and y distance from the top left of the grid object that contains the initial lineages.
       finexmin = -finexoffset;
       fineymin = -fineyoffset;
       finexmax = finexmin + (fine_map.GetCols());
       fineymax = fineymin + (fine_map.GetRows());
       coarsexmin = -coarsexoffset - finexoffset;
       coarseymin = -coarseyoffset - fineyoffset;
       coarsexmax = coarsexmin + scale * (coarse_map.GetCols());
       coarseymax = coarseymin + scale * (coarse_map.GetRows());
       lambda = mapvars.lambda;
   #ifdef DEBUG
       cout << "finex: " << finexmin << "," << finexmax << endl;
       cout << "finey: " << fineymin << "," << fineymax << endl;
       cout << "coarsex: " << coarsexmin << "," << coarsexmax << endl;
       cout << "coarsey: " << coarseymin << "," << coarseymax << endl;
       cout << "offsets: "
            << "(" << finexoffset << "," << fineyoffset << ")(" << coarsexoffset << "," << coarseyoffset << ")" << endl;
       cout << "pristine fine file: " << pristine_fine_map << endl;
       cout << "pristine coarse file: " << pristine_coarse_map << endl;
   #endif
       //      cout << "fine variables: " << finexmin << "," << finexmax << endl;
       //      cout << "coarse variabes: " << coarsexmin << "," << coarsexmax << endl;
       if(finexmin < coarsexmin || finexmax > coarsexmax || (finexmax - finexmin) < xdim || (fineymax - fineymin) < ydim)
       {
           throw Map_Fatal_Exception(
               "ERROR_MAP_006: FATAL - fine map extremes outside coarse map or sample grid larger than fine map");
       }
       return;
   }
   
   void Map::validateMaps()
   {
       cout << "\rValidating maps..." << flush;
       if(fine_map.GetCols() == pristine_fine_map.GetCols() && fine_map.GetRows() == pristine_fine_map.GetRows() &&
          coarse_map.GetCols() == pristine_coarse_map.GetCols() && coarse_map.GetRows() == pristine_coarse_map.GetRows())
       {
           cout << "\rValidating maps...map sizes okay" << flush;
       }
       else
       {
           throw Map_Fatal_Exception(
               "ERROR_MAP_009: Map validation failed - modern and pristine maps are not the same dimensions.");
       }
       double dTotal = fine_map.GetCols() + coarse_map.GetCols();
       unsigned long iCounter = 0;
       for(int i = 0; i < fine_map.GetCols(); i++)
       {
           for(int j = 0; j < fine_map.GetRows(); j++)
           {
               if(fine_map[j][i] > pristine_fine_map[j][i])
               {
                   cerr << "fine map: " << fine_map[j][i] << "pristine map: " << pristine_fine_map[j][i]
                        << endl;
                   cerr << "x,y: " << i << "," << j << endl;
                   throw Map_Fatal_Exception("ERROR_MAP_007: Map validation failed - fine map value larger "
                                             "than pristine fine map value.");
               }
           }
           double dPercentComplete = 100 * ((double)(i + iCounter) / dTotal);
           if(i % 1000 == 0)
           {
               cout << "\rValidating maps..." << dPercentComplete << "%                " << flush;
           }
       }
       iCounter = fine_map.GetCols();
       for(int i = 0; i < coarse_map.GetCols(); i++)
       {
           for(int j = 0; j < coarse_map.GetRows(); j++)
           {
               if(coarse_map[j][i] > pristine_coarse_map[j][i])
               {
                   cerr << "coarse map: " << coarse_map[j][i] << " pristine map: " << pristine_coarse_map[j][i]
                        << endl;
                   cerr << "coarse map x+1: " << coarse_map[j][i + 1]
                        << " pristine map: " << pristine_coarse_map[j][i + 1] << endl;
                   cerr << "x,y: " << i << "," << j << endl;
                   throw Map_Fatal_Exception("ERROR_MAP_008: Map validation failed - coarse map value larger "
                                             "than pristine coarse map value.");
               }
           }
           double dPercentComplete = 100 * ((double)(i + iCounter) / dTotal);
           if(i % 1000 == 0)
           {
               cout << "\rValidating maps..." << dPercentComplete << "%                " << flush;
           }
       }
       cout << "\rValidating maps complete                                       " << endl;
   }
   
   void Map::updateMap(double generation)
   {
       // only update the map if the pristine state has not been reached.
       if(!mapvars.bPristine)
       {
           if(mapvars.dPristine < generation)
           {
               fine_map = pristine_fine_map;
               nUpdate++;
               mapvars.setPristine(nUpdate);
               // pristine_fine_map = mapvars.pristinefinemapfile;
               // pristine_coarse_map = mapvars.pristinecoarsemapfile;
               dCurrent = dPristine;
               dPristine = mapvars.dPristine;
               dForestTransform = mapvars.dForestTransform;
               calcPristineCoarseMap();
               calcPristineFineMap();
           }
       }
   }
   
   #ifdef infinite_landscape
   unsigned short Map::getVal(
       const double& x, const double& y, const long& xwrap, const long& ywrap, const double& dCurrentGen)
   {
       return deme;
   }
   #endif
   
   #ifndef infinite_landscape
   unsigned short Map::getVal(
       const double& x, const double& y, const long& xwrap, const long& ywrap, const double& dCurrentGen)
   {
       double currentTime = dCurrentGen - dCurrent;
       double xval, yval;
       xval = x + (xdim * xwrap);  //
       yval = y + (ydim * ywrap);
       //      // return 0 if the requested coordinate is completely outside the map
       if(xval < coarsexmin || xval >= coarsexmax || yval < coarseymin || yval >= coarseymax)
       {
   //                  cout << "OUTSIDE: " << endl;
           return 0;
       }
       if(xval < finexmin || xval >= finexmax || yval < fineymin ||
          yval >= fineymax)  // check if the coordinate comes from the coarse resolution map.
       {
   //                  cout <<"COARSE" << endl;
           //          double tmp;
           // take in to account the fine map offsetting
           xval += finexoffset;
           yval += fineyoffset;
           // take in to account the coarse map offsetting and the increased scale of the larger map.
           xval = floor(double((xval + coarsexoffset) / scale));
           yval = floor(double((yval + coarseyoffset) / scale));
           double retval = 0;
           if(bPristine || pristine_coarse_map[yval][xval] == coarse_map[yval][xval])
           {
               retval = pristine_coarse_map[yval][xval];
           }
           else
           {
               retval = coarse_map[yval][xval] +
                        (dForestTransform *
                         ((pristine_coarse_map[yval][xval] - coarse_map[yval][xval]) / dPristine) * currentTime);
           }
   //          cout << retval << endl;
   //          cout << retval << endl;
   // Note that debug mode will throw an exception if the returned value is less than the pristine state
   #ifdef pristine_mode
           if(retval > pristine_coarse_map[yval][xval])
           {
               string ec =
                   "Returned value greater than pristine value. Check file input. (or disable this error before "
                   "compilation.\n";
               ec += "pristine value: " + to_string((long long)pristine_coarse_map[yval][xval]) +
                     " returned value: " + to_string((long long)retval);
               throw Map_Fatal_Exception(ec);
           }
   #endif
           return floor(retval);
       }
       //      cout << "fine_map val: " << fine_map[yval][xval] << endl;
       // take in to account the fine map offsetting
       // this is done twice to avoid having all the comparisons involve additions.
       xval += finexoffset;
       yval += fineyoffset;
       double retval = 0;
       if(bPristine || pristine_fine_map[yval][xval] == fine_map[yval][xval])
       {
           retval = pristine_fine_map[yval][xval];
       }
       else
       {
   //      cout << pristine_fine_map[yval][xval] << endl;
   //      cout << fine_map[yval][xval] << endl;
           retval = fine_map[yval][xval] +
                    (dForestTransform * ((pristine_fine_map[yval][xval] - fine_map[yval][xval]) / (dPristine)) *
                     currentTime);
       }
   // cout <<fine_map[yval][xval] << "-"<< retval << endl;
   // Note that debug mode will throw an exception if the returned value is less than the pristine state
   #ifdef pristine_mode
       if(retval > pristine_fine_map[yval][xval])
       {
           throw Map_Fatal_Exception("Returned value greater than pristine value. Check file input. (or disable this "
                                     "error before compilation.");
       }
   #endif
       return floor(retval);
   }
   #endif
   unsigned long Map::getInitialCount(double dSample, Datamask& samplemask)
   {
       unsigned long toret;
       toret = 0;
   //  cout << xdim << ", " << ydim << endl;
       for(long i = 0; i < xdim; i++)
       {
           for(long j = 0; j < ydim; j++)
           {
               unsigned long add = 0;
               if(samplemask.getVal(i, j))
               {
                   
                   add = floor(dSample * getVal(i, j, 0, 0, 0));
   //              cout << add << endl;
   //              cout << getVal(i, j, 0, 0, 0) << endl;
               }
               toret += add;
           }
       }
       return toret;
   }
   
   bool Map::checkMap(const double& x, const double& y, const long& xwrap, const long& ywrap, const double generation)
   {
       //       cout << "CHECK: " << getVal(x,y,xwrap,ywrap) << endl;
       if(getVal(x, y, xwrap, ywrap, generation) == 0)
       {
           return false;
       }
       else
       {
           return true;
       }
   }
   
   bool Map::checkFine(const double& x, const double& y, const long& xwrap, const long& ywrap)
   {
       double tmpx, tmpy;
       tmpx = x + xwrap * xdim;
       tmpy = y + ywrap * ydim;
       if(tmpx < finexmin || tmpx >= finexmax || tmpy < fineymin || tmpy >= fineymax)
       {
           return false;
       }
       else
       {
           return true;
       }
   }
   
   void Map::convertCoordinates(double& x, double& y, long& xwrap, long& ywrap)
   {
       //      cout << "CONVERT START: " << x << "," << y << "," << xwrap << "," << ywrap << endl;
       // quick check
       //      bool bCheck = false;
       //      if(x < -1 || y < -1)
       //      {
       //          bCheck = true;
       //          cout << "this is good" << endl;
       //      }
       xwrap += floor(x / xdim);
       ywrap += floor(y / ydim);
       x = x - xwrap * xdim;
       y = y - ywrap * ydim;
       //      if(bCheck)
       //      {
       //          cout << "x,y " << x << "," << y <<endl;
       //          cout << "x,y wrap " << xwrap << "," <<ywrap << endl;
       //
       //      }
       //      cout << "CONVERT END: " << x << "," << y << "," << xwrap << "," << ywrap << endl;
       return;
   }
   
   void Map::runDispersal(const double& dist,
                          const double& angle,
                          long& startx,
                          long& starty,
                          long& startxwrap,
                          long& startywrap,
                          bool& disp_comp,
                          const double& generation)
   {
   //      if(startxwrap < -1 || startywrap < -1)
   //      {
   //          cout << "good1!" << endl;
   //          cout << startxwrap << endl;
   //          cout << startywrap << endl;
   //      }
   // Checks that the start point is not out of matrix - this might have to be disabled to ensure that when updating the
   // map, it doesn't cause problems.
   #ifdef pristine_mode
       if(!checkMap(startx, starty, startxwrap, startywrap, generation))
       {
           disp_comp = true;
           return;
       }
   #endif
   
       // Different calculations for each quadrant to ensure that the dispersal reads the probabilities correctly.
       double newx, newy;
   
       newx = startx + (xdim * startxwrap) + 0.5;
       newy = starty + (ydim * startywrap) + 0.5;
       if(lambda == 1)  // then nothing complicated is required and we can jump straight to the final point.
       {
           newx += double(dist * cos(angle));
           newy += double(dist * sin(angle));
           // cout << "new x,y: " << newx << "," << newy << endl;
       }
       else  // we need to see which deforested patches we pass over
       {
           long boost;
           boost = 1;
           double cur_dist, tot_dist, l;
           cur_dist = 0;
           tot_dist = 0;
           // Four different calculations for the different quadrants.
           if(angle > 7 * M_PI_4 || angle <= M_PI_4)
           {
               // Continue while the dist travelled is less than the dist energy
               while(cur_dist < dist)
               {
                   // Check if the starting position of the loop is in the fine map or not.
                   if(checkFine(newx, newy, 0, 0))
                   {
                       // Keep the standard movement rate
                       boost = 1;
                   }
                   else
                   {
                       // Accellerate the travel speed if the point is outside the fine grid.
                       // Note this means that lineages travelling from outside the fine grid to within the
                       // fine grid may
                       // see 1 grid's worth of approximation, rather than exact values.
                       // This is an acceptable approximation!
                       boost = deme;
                   }
   
                   // Add the value to the new x and y values.
                   newx = newx + boost;
                   newy = newy + boost * tan(angle);
                   // Check if the new point is within forest.
                   if(checkMap(newx, newy, 0, 0, generation))
                   {
                       l = 1;
                   }
                   else
                   {
                       l = lambda;
                   }
                   // Move forward different dists based on the difficulty of moving through forest.
                   cur_dist = cur_dist + l * boost * (1 / cos(angle));
                   tot_dist = tot_dist + boost * (1 / cos(angle));
               }
           }
           else if(angle > 3 * M_PI_4 && angle <= 5 * M_PI_4)
           {
               while(cur_dist < dist)
               {
                   if(checkFine(newx, newy, 0, 0))
                   {
                       boost = 1;
                   }
                   else
                   {
                       boost = deme;
                   }
                   // Add the change to the new x and y values.
                   newx = newx - boost;
                   newy = newy + boost * tan(M_PI - angle);
                   if(checkMap(newx, newy, 0, 0, generation))
                   {
                       l = 1;
                   }
                   else
                   {
                       l = lambda;
                   }
                   cur_dist = cur_dist + boost * l * (1 / cos(M_PI - angle));
                   tot_dist = tot_dist + boost * (1 / cos(M_PI - angle));
               }
           }
           else if(angle > M_PI_4 && angle <= 3 * M_PI_4)
           {
               while(cur_dist < dist)
               {
                   if(checkFine(newx, newy, 0, 0))
                   {
                       boost = 1;
                   }
                   else
                   {
                       boost = deme;
                   }
                   // Add the change to the new x and y values.
                   newx = newx + boost * tan(angle - M_PI_2);
                   newy = newy + boost;
                   if(checkMap(newx, newy, 0, 0, generation))
                   {
                       l = 1;
                   }
                   else
                   {
                       l = lambda;
                   }
                   cur_dist = cur_dist + l * boost / cos(angle - M_PI_2);
                   tot_dist = tot_dist + boost / cos(angle - M_PI_2);
               }
           }
           else if(angle > 5 * M_PI_4 && angle <= 7 * M_PI_4)
           {
               //              cout << "...ang4..." <<  flush;
               while(cur_dist < dist)
               {
                   if(checkFine(newx, newy, 0, 0))
                   {
                       boost = 1;
                   }
                   else
                   {
                       boost = deme;
                   }
                   newx = newx + boost * tan(3 * M_PI_2 - angle);
                   newy = newy - boost;
                   if(checkMap(newx, newy, 0, 0, generation))
                   {
                       l = 1;
                   }
                   else
                   {
                       l = lambda;
                   }
                   cur_dist = cur_dist + l * boost / cos(3 * M_PI_2 - angle);
                   tot_dist = tot_dist + boost / cos(3 * M_PI_2 - angle);
               }
           }
           // Move the point back to get the exact placement
           if(checkMap(newx, newy, 0, 0, generation))
           {
               tot_dist = tot_dist - min(cur_dist - dist, (double(boost) - 0.001));
           }
           else
           {
               disp_comp = true;
           }
           newx = startx + 0.5 + tot_dist * cos(angle);
           newy = starty + 0.5 + tot_dist * sin(angle);
       }
       if(checkMap(newx, newy, 0, 0, generation))
       {
           long newxwrap, newywrap;
           newxwrap = 0;
           newywrap = 0;
           //          cout << "new x,y: " << newx << "," << newy << endl;
           //          cout <<"BEFORE CHECK: " <<endl;
           //          cout << "start " << newxwrap << endl;
           convertCoordinates(newx, newy, newxwrap, newywrap);
           //          cout << "end " << newxwrap << endl;
   
           //          if(newxwrap < -1 || newywrap < -1)
           //          {
           //              cout << "good2!" << endl;
           //              cout << newxwrap << endl;
           //              cout << newywrap << endl;
           //          }
           if(!checkMap(newx, newy, newxwrap, newywrap, generation))
           {
               throw Map_Fatal_Exception(string(
                   "ERROR_MOVE_007: Dispersal attempted to non-forest. Check dispersal function. Forest cover: " +
                   to_string((long long)getVal(newx, newy, newxwrap, newywrap, generation))));
           }
           //          cout << "new x,y: " << newx << "," << newy << endl;
           startx = newx;
           starty = newy;
           startxwrap = newxwrap;
           startywrap = newywrap;
           disp_comp = false;
       }
       else
       {
           // cout << "OUT!" << endl;
           // cout << "x,y : " << newx << "," << newy << endl;
           disp_comp = true;
       }
       //      if(startxwrap < -1 || startywrap < -1)
       //      {
       //          cout << "good2!" << endl;
       //          cout << startxwrap << endl;
       //          cout << startywrap << endl;
       //      }
       return;
   };
   
   void Map::clearMap()
   {
       dCurrent = 0;
       checksetdim = false;
       bPristine = false;
   }
   
   void Map::printVars()
   {
       cout << "fine x limits: " << finexmin << " , " << finexmax << endl;
       cout << "fine y limits: " << fineymin << " , " << fineymax << endl;
       cout << "fine map offset: " << finexoffset << " , " << fineyoffset << endl;
       cout << "coarse x limits: " << coarsexmin << " , " << coarsexmax << endl;
       cout << "coarse y limits: " << coarseymin << " , " << coarseymax << endl;
       cout << "x,y dims: " << xdim << " , " << ydim << endl;
   }


