.. _program_listing_file_main.cpp:

Program Listing for File main.cpp
========================================================================================

- Return to documentation for :ref:`file_main.cpp`

.. code-block:: cpp

   //Copyright: 2015, Samuel Thompson, thompsonsed@gmail.com
   // License: BSD-3
   //All rights reserved.
   //
   //Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
   //
   //1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
   //
   //2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
   //
   //3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.
   
   //THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
   
   //
   #ifdef DEBUG
   #ifndef verbose
   #define verbose
   #endif
   #endif
   #include <stdio.h>
   #include "Setup.h"
   // #define pristine_mode // not required unless you experience problems.
   // This performs a more thorough check after each move operation.
   // Currently, it will also check that the pristine state value is greater than the returned value within every map cell.
   // Note that this may cause problems if the pristine state is not the state with the highest number of individuals.
   
   
   
   /************************************************************
           MAIN ROUTINE AND COMMAND LINE ARG ROUTINES
   
    ************************************************************/
   
   
   
   int main(int argc, char *argv[])
   {
       /*
       // COMMAND LINE ARGUMENTS
       // The argument argc is the number of arguments supplied to the program (automatically generated by c++)
       // The arguments 1 to N are as follows
       // 1: the task_iter used for setting the seed.
       // 2: the sample grid x dimension
       // 3: the sample grid y dimension
       // 4: the fine map file relative path.
       // 5: the fine map x dimension
       // 6: the fine map y dimension
       // 7: the fine map x offset
       // 8 the fine map y offset
       // 9: the coarse map file relative path.
       // 10: the coarse map x dimension
       // 11: the coarse map y dimension
       // 12: the coarse map x offset
       // 13: the coarse map y offset
       // 14: the scale of the coarse map compared to the fine (10 means resolution of coarse map = 10 x resolution of fine map)
       // 15: the output directory
       // 16: the speciation rate.
       // 17: the dispersal distance (sigma).
       // 18: the deme size
       // 19: the deme sample size (as a proportion of deme size)
       // 20: the time to run the simulation (in seconds).
        // 21: lambda - the relative cost of moving through non-forest
       // 22: the_task - for referencing the specific task later on.
       // 23: the minimum number of species the system is known to contain.
       // 24: the pristine fine map file to use
       // 25: the pristine coarse map file to use
       // 26: the rate of forest change from pristine
       // 27: the time (in generations) since the pristine forest was seen.
       // 28: the dispersal L value (the width of the kernel.
       // 29: the sample mask, with binary 1:0 values for areas that we want to sample from. If this is not provided then this will default to mapping the whole area.
       // 30:  the link to the file containing every generation that the list should be expanded. This should be in the format of a list.
       // 31- onwards: speciation rates to apply after the simulation is complete.
         */
   #ifndef verbose
       openLogFile(false);
   #endif
       //freopen("Logs/Log_")
       bool fullmode = false;
       try
       {
           vector<string> comargs;
           try
           {
               // Import the command line arguments and parse the arguments correctly.
               importArgs(argc,argv,comargs);
               fullmode = parseArgs(argc,comargs);
   //          cout << fullmode << endl;
           }
           catch(Main_Exception& me)
           {
               cerr << me.what() << endl;
               exit(-1);
           }
           // Create the tree object which contains the whole simulation
           Tree tree;
           if(comargs[1] == "resuming")
           {
               tree.setResumeParameters(comargs[2], stoi(comargs[3]), stoi(comargs[4]), stod(comargs[5]));
               tree.simResume(true);
           }
           else
           {
               // Add the command line variables to the Mapvars structure.
               try
               {
                   if(fullmode)
                   {
                       checkFolders(comargs[4],comargs[9],comargs[24],comargs[25],comargs[15],comargs[29]);
                   }
                   else
                   {
       //              cout << 'test' << endl;
                       if(comargs[3] == "null")
                       {
                           throw Fatal_Exception("ERROR_MAIN_009: FATAL. Map file cannot be null.");
                       }
                       if(comargs[4] == "null")
                       {
                           throw Fatal_Exception("ERROR_MAIN_009: FATAL. Output folder cannot be null.");
                       }
       //              for(unsigned i = 0; i < comargs.size(); i ++ )
       //              {
       //                  cout << comargs[i] << endl;
       //              }
                       doesExist(comargs[3]);
                       doesExist(comargs[4]);
                       doesExistNull(comargs[12]);
                   }
               }
               catch(Fatal_Exception& fe)
               {
                   cerr << fe.what() << endl;
                   exit(-1);
               }
               long the_seed = stoi(comargs[1]);
   
               // import the command line arguments (or config file parameters) in to the Mapvars object.
               // This object is passed on to the tree object for integration in to the whole simulation.
               tree.setSeed(the_seed); // set the seed - removed the +161 as this can now be incorporated at a higher level, allowing for cleaner control.
               if(fullmode)
               {
                   cout << "INITIALISING...." << endl << "seed: " << the_seed << endl << "Speciation Rate: " << comargs[16]<< endl << "Dispersal (z,L): " << "(" <<comargs[17]<<"," << comargs[28] << ")" <<endl;
               }
               else
               {
                   cout << "INITIALISING...." << endl << "seed: " << the_seed << endl << "Speciation Rate: " << comargs[5]<< endl << "Dispersal (z,L): " << "(" <<comargs[6]<<"," << comargs[7] << ")" <<endl;
               }
               // Setup the simulations.
               tree.setup(comargs,fullmode);
               // Check for previous unfinished simulations with the same seed number.
               bool simCheck = false;
               if(fullmode)
               {
                   simCheck = checkSims(stoi(comargs[22]),the_seed,comargs[15]);
               }
               else
               {
                   simCheck = checkSims(stoi(comargs[2]),the_seed,comargs[4]);
               }
               tree.simResume(simCheck);  //will do nothing if check is false. Otherwise will load the paused simulation into RAM.
               // Run the simulation - the single longest and most important step.
           }
           bool isComplete = tree.runSim();
           if(isComplete)
           {
   //          cout << "size: " << argc << " alt: " << comargs.size() << endl;
               getSR(comargs.size(), comargs,tree);
           }
       }
       catch(Fatal_Exception& fe)
       {
           cerr << fe.what() << endl;
           return -1;
       }
       catch(Map_Fatal_Exception& mfe)
       {
           cerr << mfe.what() << endl;
           return -1;
       }
       catch(const exception &e)
       {
           cerr << e.what() << endl;
       }
   #ifndef verbose
       fclose(stdout);
   #endif
       return 0;
   }


