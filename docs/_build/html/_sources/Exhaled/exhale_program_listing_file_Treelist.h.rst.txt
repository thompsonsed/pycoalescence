.. _program_listing_file_Treelist.h:

Program Listing for File Treelist.h
========================================================================================

- Return to documentation for :ref:`file_Treelist.h`

.. code-block:: cpp

   //This file is part of NECSim project which is released under BSD-3 license.
   //See file **LICENSE.txt** or visit https://opensource.org/licenses/BSD-3-Clause) for full license details.
   // This code is a used to analyse a list of Treenode objects to generate species abundances for a given speciation rate.
   // For use within Coal_sim v3.1+
   // Author: Samuel Thompson
   // Contact: samuel.thompson14@imperial.ac.uk or thompsonsed@gmail.com
   // Version 1.1
   //#include "Treenode.h"
   #ifndef TREELIST
   #define TREELIST
   #include "Treenode.h"
   #include "Matrix.h"
   #include <math.h>
   #include <sqlite3.h>
   #include <cstring>
   #include <cmath>
   #include <stdexcept>
   #include <string>
   # include <boost/filesystem.hpp>
   #include <boost/lexical_cast.hpp>
    #include "CustomExceptions.h"
   
   using namespace std;
   using std::string;
   
   bool checkSpeciation(long double random_number, long double speciation_rate, int number_of_generations)
   ;
   
   // A class containing the fragment limits as x,y coordinates.
   struct Fragment
   {
       // the name for the fragment (for reference purposes)
       string name;
       // coordinates for the extremes of the site
       unsigned long x_east, x_west, y_north, y_south;
       // the number of lineages in the fragment.
       unsigned long num;
       double area;
   };
   
   // Class for creating the sample matrix object for easy referencing
   
   class Samplematrix :  public Matrix<bool>
   {
   private:
       bool bIsNull;
       bool bIsFragment;
       Fragment fragment;
   public:
       Samplematrix()
       {
           bIsFragment = false;
           bIsNull = false;
       }
       
       void setIsNull(bool b)
       {
           bIsNull = b;
       }
       
       bool getIsNull()
       {
           return bIsNull;
       }
       
       bool getTestVal(unsigned int xval, unsigned int yval)
       {
           return matrix[yval][xval];
       }
       
       bool getVal(unsigned int xval, unsigned int yval)
       {
           if(bIsFragment)
           {
               if(fragment.x_west <= xval  && xval <= fragment.x_east && fragment.y_north <= yval  && yval <= fragment.y_south)
               {
   //              cout << "FRAGMENT TRUE" << endl;
   //              cout << "x,y" << xval << ", " << yval << "frag: w,e,n,s: " << fragment.x_west << ", " << fragment.x_east << ", " << fragment.y_north << ", " << fragment.y_south << endl;
                   return true;
               }
               else
               {
   //              cout << "FRAGMENT FALSE" << endl;
                   return false;
               }
           }
           if(bIsNull)
           {
               return true;
           }
           else
           {
               return matrix[yval][xval];
           }
       }
       
        void setFragment(Fragment fragment_in)
        {
               fragment = fragment_in;
   //          cout << "W,E,N,S: " << fragment.x_west << ", " << fragment.x_east << ", " << fragment.y_north << ", " << fragment.y_south << endl;
               bIsFragment = true;
        }
        
        void removeFragment()
        {
            bIsFragment = false;
        }
   };
   
   
   
   
   
   class Treelist
   {
   private:
       bool bMem; // boolean for whether the database is in memory or not.
       bool bFileSet; // boolean for whether the database has been set already.
       sqlite3 * database; // stores the in-memory database connection.
       sqlite3 * outdatabase; // stores the file database connection
       bool bSqlConnection; // true if the data connection has been established.
       Row<Treenode> &nodes; // in older versions this was called list. Changed to avoid confusion with the built-in class.
       Row<unsigned int> rOut;
       double dSpecRate;
       unsigned long iSpecies;
       long double generation; // the time of interest for the simulation
       bool bSample; // checks whether the samplemask has already been imported.
       bool bDataImport; // checks whether the main sim data has been imported.
       string samplemaskfile; // stores the name of the file object for referencing.
       Samplematrix samplemask; // the samplemask object for defining the areas we want to sample from.
       vector<Fragment> fragments; // a vector of fragments for storing each fragment's coordinates.
       // the minimum speciation rate the original simulation was run with (this is read from the database SIMULATION_PARAMETERS table)
       double min_spec_rate; 
       // The dimensions of the sample grid size.
       unsigned long grid_x_size;
       unsigned long grid_y_size;
       
   public:
       Treelist(Row<Treenode>&r):nodes(r)
       {
           bMem = false;
           dSpecRate =0;
           iSpecies =0;
           bSample = false;
           bSqlConnection = false;
           bFileSet = false;
           bDataImport = false;
           generation = 0;
       }
       
       void setList(Row<Treenode> &l);
       
       void setDatabase(sqlite3 * dbin);
       
       bool hasImportedData();
       
       double getMinimumSpeciation();
       
       void importSamplemask(string sSamplemask);
       
       unsigned long countSpecies();
       
       bool doubleCompare(double d1, double d2, double epsilon);
       
       unsigned long calcSpecies(double s);
       
       void calcSpeciesAbundance();
       
       void resetTree();
       
       void detectDimensions(string db);
       
       void openSqlConnection(string inputfile);
       
       void internalOption();
       void importData(string inputfile);
       
       
       void importSimParameters(string file);
       
       void setGeneration(long double generationin)
       ;
       
       void createDatabase(double s);
       
       void createFragmentDatabase(const Fragment &f);
       
       void exportDatabase(string outputfile);
       
       void recordSpatial();
       
       void calcFragments(string fragment_file);
       
       void applyFragments();
   };
   
   #endif


