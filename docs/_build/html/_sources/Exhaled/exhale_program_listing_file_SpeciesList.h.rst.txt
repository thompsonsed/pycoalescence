.. _program_listing_file_SpeciesList.h:

Program Listing for File SpeciesList.h
========================================================================================

- Return to documentation for :ref:`file_SpeciesList.h`

.. code-block:: cpp

   //This file is part of NECSim project which is released under BSD-3 license.
   //See file **LICENSE.txt** or visit https://opensource.org/licenses/BSD-3-Clause) for full license details.
   
   /************************************************************
                       SPECIES LIST OBJECT
    ************************************************************/
    #ifndef SPECIESLIST
    #define SPECIESLIST
    #include <iostream>
   using namespace std;
   class SpeciesList
   {
   private:
       unsigned short list_size,maxsize; // List size and maximum size of the cell (based on percentage cover).
       unsigned long next_active; // For calculating the wrapping, using the next and last system.
       Row<unsigned long> list; // list of the active reference number, with zeros for empty cells.
       unsigned short nwrap; // The number of wrapping (next and last possibilities) that there are.
   public:
       SpeciesList() : list_size(0),maxsize(0),next_active(0),nwrap(0)
       {
           list.SetRowSize(0);
       }
       
       ~SpeciesList()
       {
           
       }
       // Sets the list size to the required length.
       // Note this will delete any species currently stored in the list
   
       // Fill the list with empty 0s.
       void fillList()
       {
           if(maxsize==0)
           {
               return;
           }
           for(unsigned int i = 0;i<maxsize;i++)
           {
               list[i] = 0;
           }
       }
       
       // Standard setters
       void initialise(unsigned short maxsizein)
       {
           maxsize = maxsizein;
           nwrap = 0;
           list_size = 0;
           list.SetRowSize(maxsize);
           return;
       }
       
       // special case if just the maxsize wants to be change, but want to maintain the list variables.
       void setMaxsize(unsigned short maxsizein)
       {
           maxsize = maxsizein;
           return;
       }
       
       void setSpecies(int index, unsigned long new_val)
       {
           if(list[index] == 0)
           {
               cerr << "index: " << index << endl;
               cerr << "list[index]: " <<list[index] << endl;
               cerr << "list.maxsize(): " << maxsize << endl;
               throw runtime_error("ERROR_MOVE_027: List position to be replaced is zero. Check list assignment.");
           }
           list[index] = new_val;
           return;
       }
       
       void setNext(unsigned long n)
       {
           next_active = n;
       }
       
       
       void setNwrap(unsigned short nr)
       {
           nwrap = nr;
       }
       
       unsigned short addSpecies(unsigned long new_spec)
       {
           /*
           list_size ++;
           if(list_size>maxsize)
           {
               list_size --;
               return;
           }
           else
           {
               list[list_size] = new_spec;
           }
            * */
           // Alternative method
           // loop until an empty space is found and place the new species in the empty space.
           if(list_size + 1 > maxsize)
           {
               cerr << "maxsize: " << maxsize << endl;
               throw out_of_range("Could not add species - no empty space");
           }
           for(unsigned short i =0; i<list.size(); i++)
           {
               if(list[i] == 0)
               {
                   list_size++;
                   list[i] = new_spec;
                   return i;
               }
               
           }
           cerr << "maxsize: " << maxsize << endl;
           throw out_of_range("Could not add species - no empty space");
       }
       
       void addSpeciesSilent(unsigned long new_spec)
       {
           /*
           list_size ++;
           if(list_size>maxsize)
           {
               list_size --;
               return;
           }
           else
           {
               list[list_size] = new_spec;
           }
            * */
           // Alternative method
           // loop until an empty space is found and place the new species in the empty space.
           for(unsigned int i =0;i<maxsize;i++)
           {
               if(list[i] == 0)
               {
                   list_size++;
                   list[i] = new_spec;
                   return;
               }
               
           }
           throw out_of_range("Could not add species - no empty space");
       }
       
       void deleteSpecies(int index)
       {
   //      cout << "deleted species index: " << index << " value: " << list[index] << " list size: " << list_size << endl;
           list[index] = 0;
           list_size --;
           
           // alternative version
           /*for(int i = index;i<list_size;i++)
           {
               list[i] = list[i+1];
           }
           list[list_size]=0;
           list_size --;*/
       }
       
       void decreaseNwrap()
       {
           if(nwrap == 0)
           {
               throw runtime_error("Nwrap should never be decreased less than 0");
           }
           else if(nwrap == 1)
           {
               if( next_active != 0)
               {
                   throw runtime_error("Nwrap is being set at 0 when an wrapped lineage is still present");
               }
           }
           nwrap --;
       }
       
       void increaseNwrap()
       {
           nwrap ++;
       }
       
       void changePercentCover(unsigned short newmaxsize) // THIS NEEDS TO BE CHANGED TO TAKE ACCOUNT OF THE NEW REFERENCING METHOD
       {
   //      cout << "1" << endl;
           Row<unsigned long> templist(list);
           maxsize = newmaxsize;
           list.SetRowSize(newmaxsize);
   //      cout << "2" << endl;
   //      cout << "templist.size: " << templist.size() << endl;
   //      cout << "list.size: " << list.size() << endl;
   //      cout << "list_size: " << list_size << endl;
   //      cout << "maxsize: " << maxsize << endl;
   //      cout << "newmaxsize: " << newmaxsize << endl;
   //      cout << "templist[0]: " << templist[0] << endl;
           for(unsigned int i=0;i<newmaxsize;i++)
           {
   //          cout << i << endl;
               if(i<templist.size()) // DOUBLE CHECK THIS LATER
               {
   //              cout << i << endl;
                   list[i] = templist[i];
   //              cout << "assignment done" << endl;
               }
               else
               {
   //              cout << "alt: " << i << endl;
                   list[i] = 0;
               }
           }
           if(list.size() > maxsize)
           {
               cerr << "list.size(): " << list.size() << endl;
               cerr << "maxsize: " << maxsize << endl;
               throw out_of_range("List size not equal to maxsize");
           }
   //      cout << "3" << endl;
           // Alternative method
   //      maxsize = newmaxsize;
       }
       
       unsigned long getRandLineage(NRrand &rand_no)
       {
           double rand_index;
           if(maxsize <= list_size)
           {
               // Then the list size is larger than the actual size. This means we must return a lineage.
               try
               {
                   do
                   {
                       rand_index = rand_no.d01();
                       rand_index *= list.size();
                       //cout << "ref: " << rand_index << ", " << list[round(rand_index)] << endl;
                   } while(list[floor(rand_index)] == 0);
                   //cout << "RETURNING!" << endl;
                   return(list[floor(rand_index)]);
               }
               catch(out_of_range &oor)
               {
                   cerr << oor.what() << endl;
                   throw runtime_error("ERROR_MOVE_001b: Listpos outside maxsize.");
               }
           }
           else
           {
               rand_index =  rand_no.d01();
   //      cout << "rand_index: " << rand_index << endl;
               rand_index  *= maxsize;
           // Dynamically resize the list if required. Otherwise, to save memory, the list will not be resized;
               if(rand_index>=list.size())
               {
       //          cout << "changing: " << endl;
                   changePercentCover(maxsize);
       //          string sam;
       //          cin >> sam;
               }
               #ifdef DEBUG
   //          if(list.size() > 1 || list_size > 1 || maxsize != 1)
   //          {
   //              throw runtime_error("HELP!");
   //          }
               #endif
               // now get the correctly placed lineage (returning 0s when necessary)
               /*int j =0; // this counts the number of 0s we've seen (included)
               int i = 0; // this counts the total number we've passed
               int k =0; // this counts the  number of 0s seen (skipped)
               int zeroes = maxsize - list_size;
               while(i-k < rand_index)
               {
                   i++;
                   // then we need to return a lineage
                   if(list[i] == 0)
                   {
                       if(j < zeroes)
                       {
                           j ++;
                       }
                       else
                       {
                           k++;
                       }
                   }
               }*/
               
               // test new version
               unsigned int i = floor(rand_index);
               
               // REMOVE THIS LATER
               if(rand_index>maxsize)
               {
                   cout << "ERROR IN INDEX" << endl;
                   string sam;
                   cin >> sam;
               }
               return list[i];
           }
       }
       
       unsigned long getSpecies(unsigned short index)
       {
           return list[index];
       }
       
       unsigned long getNext()
       {
           return next_active;
       }
       
       unsigned short getNwrap()
       {
           return nwrap;
       }
       
       int getListsize()
       {
           return list_size;
       }
       
       int getMaxsize()
       {
           return maxsize;
       }
       
       void wipeList()
       {
           fillList();
           next_active=0;
           nwrap =0;
           list_size=0;
       }
       
       friend ostream& operator<<(ostream& os,const SpeciesList& r) 
       {
           //os << m.numRows<<" , "<<m.numCols<<" , "<<endl; 
           os << r.list << ",";
           os << r.list_size << ",";
           os << r.maxsize << ",";
           os << r.next_active << ",";
           os << r.nwrap << ",";
           return os;
       }
       
       friend istream& operator>>(istream& is, SpeciesList& r) 
       {
           char delim;
           //double temp1,temp2;
           //is << m.numRows<<" , "<<m.numCols<<" , "<<endl;
           is >> r.list;
           is >> delim;
           is >> r.list_size;
           is >> delim;
           is >> r.maxsize;
           is >> delim;
           is >> r.next_active;
           is >> delim;
           is >> r.nwrap;
           is >> delim;
           return is;
       }
   };
   
   #endif


