<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>pycoalescence package &#8212; pycoalescence 1.2.6 documentation</title>
    
    <link rel="stylesheet" href="_static/classic.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="_static/collapsible-lists/css/tree_view.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '1.2.6',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/javascript" src="_static/collapsible-lists/js/CollapsibleLists.compressed.js"></script>
    <script type="text/javascript" src="_static/collapsible-lists/js/apply-collapsible-lists.js"></script>
    <link rel="shortcut icon" href="_static/PyCoal_favicon_large.ico"/>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Full API" href="necsim/unabridged_api.html" />
    <link rel="prev" title="Modules" href="modules.html" /> 
  </head>
  <body role="document">
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="necsim/unabridged_api.html" title="Full API"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="modules.html" title="Modules"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">pycoalescence 1.2.6 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="modules.html" accesskey="U">Modules</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="module-pycoalescence">
<span id="pycoalescence-package"></span><h1>pycoalescence package<a class="headerlink" href="#module-pycoalescence" title="Permalink to this headline">¶</a></h1>
<p>pycoalescence provides the facilities for running spatially-explicit neutral coalescence ecological simulations
and performing basic analysis of the simulation outputs. The program requires necsim to function properly.</p>
<div class="contents local topic" id="contents">
<ul class="simple">
<li><a class="reference internal" href="#key-submodules" id="id1">Key submodules</a><ul>
<li><a class="reference internal" href="#module-pycoalescence.simulation" id="id2">simulation module</a></li>
<li><a class="reference internal" href="#module-pycoalescence.coalescence_tree" id="id3">coalescence_tree module</a></li>
</ul>
</li>
<li><a class="reference internal" href="#additional-submodules" id="id4">Additional submodules</a><ul>
<li><a class="reference internal" href="#module-pycoalescence.dispersal_simulation" id="id5">dispersal_simulation module</a></li>
<li><a class="reference internal" href="#module-pycoalescence.fragments" id="id6">fragments module</a></li>
<li><a class="reference internal" href="#module-pycoalescence.fragment_config" id="id7">fragments config module</a></li>
<li><a class="reference internal" href="#module-pycoalescence.helper" id="id8">helper file</a></li>
<li><a class="reference internal" href="#module-pycoalescence.hpc_setup" id="id9">hpc_setup file</a></li>
<li><a class="reference internal" href="#module-pycoalescence.landscape" id="id10">landscape file</a></li>
<li><a class="reference internal" href="#module-pycoalescence.landscape_metrics" id="id11">landscape_metrics file</a></li>
<li><a class="reference internal" href="#module-pycoalescence.map" id="id12">map module</a></li>
<li><a class="reference internal" href="#module-pycoalescence.merger" id="id13">merger module</a></li>
<li><a class="reference internal" href="#module-pycoalescence.patched_landscape" id="id14">patched_landscape module</a></li>
<li><a class="reference internal" href="#module-pycoalescence.setup" id="id15">setup file</a></li>
<li><a class="reference internal" href="#module-pycoalescence.spatial_algorithms" id="id16">spatial_algorithms file</a></li>
<li><a class="reference internal" href="#module-pycoalescence.sqlite_connection" id="id17">sqlite_connection file</a></li>
<li><a class="reference internal" href="#module-pycoalescence.system_operations" id="id18">system_operations file</a></li>
</ul>
</li>
</ul>
</div>
<div class="section" id="key-submodules">
<h2><a class="toc-backref" href="#id1">Key submodules</a><a class="headerlink" href="#key-submodules" title="Permalink to this headline">¶</a></h2>
<p>These are the most important modules for running and analysing spatially-explicit neutral models, and are most likely
to be used directly.</p>
<div class="section" id="module-pycoalescence.simulation">
<span id="simulation-module"></span><h3><a class="toc-backref" href="#id2">simulation module</a><a class="headerlink" href="#module-pycoalescence.simulation" title="Permalink to this headline">¶</a></h3>
<p>Run spatially-explicit neutral simulations on provided landscapes with support for a wide range of scenarios and
parameters. Detailed <a class="reference internal" href="README_pycoalescence.html#performing-simulations"><span class="std std-ref">here</span></a>.</p>
<p>The main class is <a class="reference internal" href="#pycoalescence.simulation.Simulation" title="pycoalescence.simulation.Simulation"><code class="xref py py-class docutils literal"><span class="pre">Simulation</span></code></a>, which contains routines for setting up and running simulations, plus basic tree
generation after simulations have been completed.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">input:</th><td class="field-body"><ul class="first simple">
<li>Simulation parameters (such as dispersal kernel, speciation rate)</li>
<li>Map files representing density over space</li>
<li>[optional] map files representing relative reproductive ability</li>
<li>[optional] map files representing dispersal potential</li>
<li>[optional] historical density map files</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">output:</th><td class="field-body"><ul class="first last simple">
<li>Database containing generated coalescence tree, simulation parameters and basic biodiversity metrics.</li>
<li>If the simulation does not complete, will instead generate a set of Dump_*.csv files for resuming simulations</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="class">
<dt id="pycoalescence.simulation.Simulation">
<em class="property">class </em><code class="descname">Simulation</code><span class="sig-paren">(</span><em>logging_level=30</em>, <em>log_output=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycoalescence/simulation.html#Simulation"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycoalescence.simulation.Simulation" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pycoalescence.landscape.Landscape" title="pycoalescence.landscape.Landscape"><code class="xref py py-class docutils literal"><span class="pre">pycoalescence.landscape.Landscape</span></code></a></p>
<p>A class containing routines to set up and run simulations, including detecting map dimensions from tif files.</p>
<dl class="method">
<dt id="pycoalescence.simulation.Simulation.add_sample_time">
<code class="descname">add_sample_time</code><span class="sig-paren">(</span><em>time</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycoalescence/simulation.html#Simulation.add_sample_time"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycoalescence.simulation.Simulation.add_sample_time" title="Permalink to this definition">¶</a></dt>
<dd><p>Adds an extra sample time to the list of times.</p>
<p>This allows for multiple temporal sample points from within the same simulation.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>time</strong> &#8211; the sample time to add</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pycoalescence.simulation.Simulation.apply_speciation_rates">
<code class="descname">apply_speciation_rates</code><span class="sig-paren">(</span><em>speciation_rates=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycoalescence/simulation.html#Simulation.apply_speciation_rates"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycoalescence.simulation.Simulation.apply_speciation_rates" title="Permalink to this definition">¶</a></dt>
<dd><p>Applies the speciation rates to the coalescence tree and outputs to the database.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>speciation_rates</strong> &#8211; a list of speciation rates to apply</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">None</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pycoalescence.simulation.Simulation.calculate_sql_database">
<code class="descname">calculate_sql_database</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycoalescence/simulation.html#Simulation.calculate_sql_database"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycoalescence.simulation.Simulation.calculate_sql_database" title="Permalink to this definition">¶</a></dt>
<dd><p>Saves the output database location to self.output_database.</p>
</dd></dl>

<dl class="method">
<dt id="pycoalescence.simulation.Simulation.check_maps">
<code class="descname">check_maps</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycoalescence/simulation.html#Simulation.check_maps"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycoalescence.simulation.Simulation.check_maps" title="Permalink to this definition">¶</a></dt>
<dd><p>Checks that the maps all exist and that the file structure makes sense.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first simple">
<li><strong>TypeError</strong> &#8211; if a dispersal map or reproduction map is specified, we must have a fine map specified, but
not a coarse map.</li>
<li><strong>IOError</strong> &#8211; if one of the required maps does not exist</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">None</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pycoalescence.simulation.Simulation.check_sample_map_equals_sample_grid">
<code class="descname">check_sample_map_equals_sample_grid</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycoalescence/simulation.html#Simulation.check_sample_map_equals_sample_grid"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycoalescence.simulation.Simulation.check_sample_map_equals_sample_grid" title="Permalink to this definition">¶</a></dt>
<dd><p>Checks if the grid and sample map are the same size and offset (in which case, future operations can be
simplified).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">true if the grid and sample map dimensions and offsets are equal</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">bool</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pycoalescence.simulation.Simulation.check_simulation_params">
<code class="descname">check_simulation_params</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycoalescence/simulation.html#Simulation.check_simulation_params"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycoalescence.simulation.Simulation.check_simulation_params" title="Permalink to this definition">¶</a></dt>
<dd><p>Checks that simulation parameters have been correctly set and the program is ready for running.
Note that these checks have not been fully tested and are probably unnecessary in a large number of cases.</p>
</dd></dl>

<dl class="method">
<dt id="pycoalescence.simulation.Simulation.check_sql_database">
<code class="descname">check_sql_database</code><span class="sig-paren">(</span><em>expected=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycoalescence/simulation.html#Simulation.check_sql_database"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycoalescence.simulation.Simulation.check_sql_database" title="Permalink to this definition">¶</a></dt>
<dd><p>Checks whether the output database exists. If the existance does not match the expected variable, raises an
error.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first simple">
<li><strong>FileExistsError</strong> &#8211; if the file already exists when it&#8217;s not expected to</li>
<li><strong>FileNotExistsError</strong> &#8211; if the file does not exist when we expect it to</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>expected</strong> &#8211; boolean for expected existance of the output file</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">None</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pycoalescence.simulation.Simulation.count_individuals">
<code class="descname">count_individuals</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycoalescence/simulation.html#Simulation.count_individuals"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycoalescence.simulation.Simulation.count_individuals" title="Permalink to this definition">¶</a></dt>
<dd><p>Estimates the number of individuals to be simulated. This may be inaccurate if using multiple time points and
historical maps.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">a count of the number of individuals to be simulated</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">float</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pycoalescence.simulation.Simulation.create_config">
<code class="descname">create_config</code><span class="sig-paren">(</span><em>output_file=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycoalescence/simulation.html#Simulation.create_config"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycoalescence.simulation.Simulation.create_config" title="Permalink to this definition">¶</a></dt>
<dd><p>Generates the configuration. This will be written out either by providing an output file here, or by calling
write_config();</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>output_file</strong> (<em>str</em>) &#8211; the file to generate the config option. Must be a path to a .txt file.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pycoalescence.simulation.Simulation.create_map_config">
<code class="descname">create_map_config</code><span class="sig-paren">(</span><em>output_file=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycoalescence/simulation.html#Simulation.create_map_config"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycoalescence.simulation.Simulation.create_map_config" title="Permalink to this definition">¶</a></dt>
<dd><p>Generates the map config file from reading the spatial structure of each of the provided files.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>output_file</strong> (<em>str</em>) &#8211; the file to output configuration data to (the map config file)</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pycoalescence.simulation.Simulation.create_temporal_sampling_config">
<code class="descname">create_temporal_sampling_config</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycoalescence/simulation.html#Simulation.create_temporal_sampling_config"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycoalescence.simulation.Simulation.create_temporal_sampling_config" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates the time-sampling config file.</p>
<p>Function is called automatically when creating a config file, and should not be manually called.</p>
</dd></dl>

<dl class="method">
<dt id="pycoalescence.simulation.Simulation.detect_map_dimensions">
<code class="descname">detect_map_dimensions</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycoalescence/simulation.html#Simulation.detect_map_dimensions"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycoalescence.simulation.Simulation.detect_map_dimensions" title="Permalink to this definition">¶</a></dt>
<dd><p>Detects all the map dimensions for the provided files (where possible) and sets the respective values.
This is intended to be run after set_map_files()</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first simple">
<li><strong>TypeError</strong> &#8211; if a dispersal map or reproduction map is specified, we must have a fine map specified, but
not a coarse map.</li>
<li><strong>IOError</strong> &#8211; if one of the required maps does not exist</li>
<li><strong>ValueError</strong> &#8211; if the dimensions of the dispersal map do not make sense when used with the fine map
provided</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">None</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pycoalescence.simulation.Simulation.estimate_ram_usage">
<code class="descname">estimate_ram_usage</code><span class="sig-paren">(</span><em>grid_individuals</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycoalescence/simulation.html#Simulation.estimate_ram_usage"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycoalescence.simulation.Simulation.estimate_ram_usage" title="Permalink to this definition">¶</a></dt>
<dd><p>Estimates the RAM usage for the program with the current parameters.</p>
<p>Note this estimates the upper bound of memory usage and is likely inaccurate, especially for simulations with
multiple time sampling points.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>grid_individuals</strong> &#8211; the number of individuals existing on the grid</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">the estimated RAM usage in bytes</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">float</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pycoalescence.simulation.Simulation.finalise_setup">
<code class="descname">finalise_setup</code><span class="sig-paren">(</span><em>expected=False</em>, <em>ignore_errors=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycoalescence/simulation.html#Simulation.finalise_setup"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycoalescence.simulation.Simulation.finalise_setup" title="Permalink to this definition">¶</a></dt>
<dd><p>Runs all setup routines to provide a complete simulation. Should be called immediately before run_coalescence()
to ensure the simulation setup is complete.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>ignore_errors</strong> &#8211; if true, any FileNotFoundError and FileExistsError raised by checking the output database
are ignored</li>
<li><strong>expected</strong> &#8211; set to true if we expect the output file to exist</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pycoalescence.simulation.Simulation.get_average_density">
<code class="descname">get_average_density</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycoalescence/simulation.html#Simulation.get_average_density"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycoalescence.simulation.Simulation.get_average_density" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the average density across the fine map, subsetted for the sample grid.</p>
</dd></dl>

<dl class="method">
<dt id="pycoalescence.simulation.Simulation.get_optimised_solution">
<code class="descname">get_optimised_solution</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycoalescence/simulation.html#Simulation.get_optimised_solution"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycoalescence.simulation.Simulation.get_optimised_solution" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the optimised solution as a dictionary containing the important optimised variables.
This can be read back in with set_optimised_solution</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">dict containing the important optimised variables</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">dict</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pycoalescence.simulation.Simulation.get_protracted">
<code class="descname">get_protracted</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycoalescence/simulation.html#Simulation.get_protracted"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycoalescence.simulation.Simulation.get_protracted" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets whether the simulation pointed to by this object is a protracted simulation or not.</p>
</dd></dl>

<dl class="method">
<dt id="pycoalescence.simulation.Simulation.get_richness">
<code class="descname">get_richness</code><span class="sig-paren">(</span><em>reference=1</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycoalescence/simulation.html#Simulation.get_richness"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycoalescence.simulation.Simulation.get_richness" title="Permalink to this definition">¶</a></dt>
<dd><p>Calls coal_analyse.get_richness() with the supplied variables.</p>
<p>Requires successful import of coal_analyse and sqlite3.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>speciation_rate</strong> &#8211; the speciation rate to extract system richness from.</li>
<li><strong>time</strong> &#8211; the time to extract system richness from</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">the species richness.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pycoalescence.simulation.Simulation.grid_density_actual">
<code class="descname">grid_density_actual</code><span class="sig-paren">(</span><em>x_off</em>, <em>y_off</em>, <em>x_dim</em>, <em>y_dim</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycoalescence/simulation.html#Simulation.grid_density_actual"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycoalescence.simulation.Simulation.grid_density_actual" title="Permalink to this definition">¶</a></dt>
<dd><p>Counts the density total for a subset of the grid by sampling from the fine map.</p>
<p>Note that for large maps this can take a very long time.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>x_off</strong> &#8211; the x offset of the grid map subset</li>
<li><strong>y_off</strong> &#8211; the y offset of the grid map subset</li>
<li><strong>x_dim</strong> &#8211; the x dimension of the grid map subset</li>
<li><strong>y_dim</strong> &#8211; the y dimension of the grid map subset</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">the total individuals that exist in the subset.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">int</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pycoalescence.simulation.Simulation.grid_density_estimate">
<code class="descname">grid_density_estimate</code><span class="sig-paren">(</span><em>x_off</em>, <em>y_off</em>, <em>x_dim</em>, <em>y_dim</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycoalescence/simulation.html#Simulation.grid_density_estimate"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycoalescence.simulation.Simulation.grid_density_estimate" title="Permalink to this definition">¶</a></dt>
<dd><p>Counts the density total for a subset of the grid by sampling from the fine map</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Note:</th><td class="field-body"><p class="first">This is an approximation (based on the average density of the fine map) and does not produce
a perfect value. This is done for performance reasons. The actual value can be obtained with
grid_density_actual().</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>x_off</strong> &#8211; the x offset of the grid map subset</li>
<li><strong>y_off</strong> &#8211; the y offset of the grid map subset</li>
<li><strong>x_dim</strong> &#8211; the x dimension of the grid map subset</li>
<li><strong>y_dim</strong> &#8211; the y dimension of the grid map subset</li>
</ul>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">an estimate of the total individuals that exist in the subset.</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">int</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pycoalescence.simulation.Simulation.import_fine_map_array">
<code class="descname">import_fine_map_array</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycoalescence/simulation.html#Simulation.import_fine_map_array"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycoalescence.simulation.Simulation.import_fine_map_array" title="Permalink to this definition">¶</a></dt>
<dd><p>Imports the fine map array to the in-memory object, subsetted to the same size as the sample grid.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">None</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pycoalescence.simulation.Simulation.import_sample_map_array">
<code class="descname">import_sample_map_array</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycoalescence/simulation.html#Simulation.import_sample_map_array"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycoalescence.simulation.Simulation.import_sample_map_array" title="Permalink to this definition">¶</a></dt>
<dd><p>Imports the sample map array to the in-memory object.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">None</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pycoalescence.simulation.Simulation.load_config">
<code class="descname">load_config</code><span class="sig-paren">(</span><em>config_file</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycoalescence/simulation.html#Simulation.load_config"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycoalescence.simulation.Simulation.load_config" title="Permalink to this definition">¶</a></dt>
<dd><p>Loads the config file by reading the lines in order.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>config_file</strong> (<em>str</em>) &#8211; the config file to read in.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pycoalescence.simulation.Simulation.optimise_ram">
<code class="descname">optimise_ram</code><span class="sig-paren">(</span><em>ram_limit</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycoalescence/simulation.html#Simulation.optimise_ram"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycoalescence.simulation.Simulation.optimise_ram" title="Permalink to this definition">¶</a></dt>
<dd><p>Optimises the maps for a specific RAM usage.</p>
<p>If ram_limit is None, this function does nothing.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Note:</th><td class="field-body">Assumes that the c++ compiler has sizeof(long) = 8 bytes for calculating space usage.</td>
</tr>
<tr class="field-even field"><th class="field-name">Note:</th><td class="field-body">Only optimises RAM for a square area of the map. For rectangular shapes, will use the shortest length as
a maximum size.</td>
</tr>
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>ram_limit</strong> &#8211; the desired amount of RAM to limit to, in GB</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><strong>MemoryError</strong> &#8211; if the desired simulation cannot be compressed into available RAM</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pycoalescence.simulation.Simulation.persistent_ram_usage">
<code class="descname">persistent_ram_usage</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycoalescence/simulation.html#Simulation.persistent_ram_usage"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycoalescence.simulation.Simulation.persistent_ram_usage" title="Permalink to this definition">¶</a></dt>
<dd><p>This is the persistent RAM usage which cannot be optimised by the program for a particular set of maps
:return: the total persistent RAM usage in bytes</p>
</dd></dl>

<dl class="method">
<dt id="pycoalescence.simulation.Simulation.resume_coalescence">
<code class="descname">resume_coalescence</code><span class="sig-paren">(</span><em>pause_directory</em>, <em>seed</em>, <em>job_type</em>, <em>max_time</em>, <em>out_directory=None</em>, <em>protracted=None</em>, <em>spatial=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycoalescence/simulation.html#Simulation.resume_coalescence"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycoalescence.simulation.Simulation.resume_coalescence" title="Permalink to this definition">¶</a></dt>
<dd><p>Resumes the simulation from the specified directory, looking for the simulation with the specified seed and task
referencing.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>pause_directory</strong> &#8211; the directory to search for the paused simulation</li>
<li><strong>seed</strong> &#8211; the seed of the paused simulation</li>
<li><strong>job_type</strong> &#8211; the task of the paused simulation</li>
<li><strong>max_time</strong> &#8211; the maximum time to run simulations for</li>
<li><strong>out_directory</strong> &#8211; optionally provide an alternative output location. Defaults to same location as</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>pause_directory
:param bool protracted: protractedness of the simulation
:param bool spatial: if the simulation is to be run with spatial complexity</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">None</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pycoalescence.simulation.Simulation.run">
<code class="descname">run</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycoalescence/simulation.html#Simulation.run"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycoalescence.simulation.Simulation.run" title="Permalink to this definition">¶</a></dt>
<dd><p>Convenience function which completes setp, runs the simulation and calculates the coalescence tree for the set
speciation rates in one step.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">None</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pycoalescence.simulation.Simulation.run_checks">
<code class="descname">run_checks</code><span class="sig-paren">(</span><em>expected=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycoalescence/simulation.html#Simulation.run_checks"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycoalescence.simulation.Simulation.run_checks" title="Permalink to this definition">¶</a></dt>
<dd><p>Check that the simulation is correctly set up and that all the required files exist.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>expected</strong> &#8211; set to true if we expect the output file to already exist</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><strong>RuntimeError</strong> &#8211; if previous set-up routines are not complete</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pycoalescence.simulation.Simulation.run_coalescence">
<code class="descname">run_coalescence</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycoalescence/simulation.html#Simulation.run_coalescence"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycoalescence.simulation.Simulation.run_coalescence" title="Permalink to this definition">¶</a></dt>
<dd><p>Attempt to run the simulation with the given simulation set-up.
This is the main routine performing the actual simulation which will take a considerable amount of time.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">True if the simulation completes successfully, False if the simulation pauses.</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">bool</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pycoalescence.simulation.Simulation.run_simple">
<code class="descname">run_simple</code><span class="sig-paren">(</span><em>seed</em>, <em>task</em>, <em>output</em>, <em>alpha</em>, <em>sigma</em>, <em>size</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycoalescence/simulation.html#Simulation.run_simple"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycoalescence.simulation.Simulation.run_simple" title="Permalink to this definition">¶</a></dt>
<dd><p>Runs a simple coalescence simulation on a square infinite landscape with the provided parameters.
This requires a separate compilation of the inf_land version of the coalescence simulator.</p>
<p>Note that this function returns richness=0 for failure to read from the file. It is assumed that there will
be at least one species in the simulation.</p>
<p>Note that the maximum time for this function is set as 10 hours (36000 seconds) and will raise an exception if
the simulation does not complete in this time).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><p class="first"><strong>RuntimeError</strong> &#8211; if the simulation didn&#8217;t complete in time.</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>seed</strong> &#8211; the simulation seed</li>
<li><strong>task</strong> &#8211; the task (for file naming)</li>
<li><strong>output</strong> &#8211; the output directory</li>
<li><strong>alpha</strong> &#8211; the speciation rate</li>
<li><strong>sigma</strong> &#8211; the normal distribution sigma value for dispersal</li>
<li><strong>size</strong> &#8211; the size of the world (so there will be size^2 individuals simulated)</li>
</ul>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">the species richness in the simulation</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pycoalescence.simulation.Simulation.set_config_file">
<code class="descname">set_config_file</code><span class="sig-paren">(</span><em>output_file=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycoalescence/simulation.html#Simulation.set_config_file"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycoalescence.simulation.Simulation.set_config_file" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the config file to the output, over-writing any existing config file that has been stored.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>output_file</strong> &#8211; path to config file to output to</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pycoalescence.simulation.Simulation.set_map_files">
<code class="descname">set_map_files</code><span class="sig-paren">(</span><em>sample_file</em>, <em>fine_file=None</em>, <em>coarse_file=None</em>, <em>historical_fine_file=None</em>, <em>historical_coarse_file=None</em>, <em>dispersal_map=None</em>, <em>reproduction_map=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycoalescence/simulation.html#Simulation.set_map_files"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycoalescence.simulation.Simulation.set_map_files" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the map files (or to null, if none specified). It then calls detect_map_dimensions() to correctly read in
the specified dimensions.</p>
<p>If sample_file is &#8220;null&#8221;, dimension values will remain at 0.
If coarse_file is &#8220;null&#8221;, it will default to the size of fine_file with zero offset.
If the coarse file is &#8220;none&#8221;, it will not be used.
If the historical fine or coarse files are &#8220;none&#8221;, they will not be used.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">the dispersal map should be of dimensions xy by xy where x, y are the fine map dimensions. Dispersal
probabilities should sum to 1 across each row, and each row/column index represents dispersal from the
row index to the column index according to index = x+(y*xdim), where x,y are the coordinates of the
cell and xdim is the x dimension of the fine map. See the
<a class="reference internal" href="#pycoalescence.patched_landscape.PatchedLandscape" title="pycoalescence.patched_landscape.PatchedLandscape"><code class="xref py py-class docutils literal"><span class="pre">PatchedLandscape</span> <span class="pre">class</span></code></a> for routines for
generating these landscapes.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>sample_file</strong> (<em>str</em>) &#8211; the sample map file. Provide &#8220;null&#8221; if on samplemask is required</li>
<li><strong>fine_file</strong> (<em>str</em>) &#8211; the fine map file. Defaults to &#8220;null&#8221; if none provided</li>
<li><strong>coarse_file</strong> (<em>str</em>) &#8211; the coarse map file. Defaults to &#8220;none&#8221; if none provided</li>
<li><strong>historical_fine_file</strong> (<em>str</em>) &#8211; the historical fine map file. Defaults to &#8220;none&#8221; if none provided</li>
<li><strong>historical_coarse_file</strong> (<em>str</em>) &#8211; the historical coarse map file. Defaults to &#8220;none&#8221; if none provided</li>
<li><strong>dispersal_map</strong> (<em>str</em>) &#8211; the dispersal map for reading dispersal values. Default to &#8220;none&#8221; if none provided</li>
<li><strong>reproduction_map</strong> (<em>str</em>) &#8211; a map of relative reproduction probabilities, at the scale of the fine map</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first">None</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">None</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pycoalescence.simulation.Simulation.set_optimised_solution">
<code class="descname">set_optimised_solution</code><span class="sig-paren">(</span><em>dict_in</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycoalescence/simulation.html#Simulation.set_optimised_solution"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycoalescence.simulation.Simulation.set_optimised_solution" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the optimised RAM solution from the variables in the provided dictionary.
This should contain the grid_x_size, grid_y_size, grid_file_name, sample_x_offset and sample_y_offset.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>dict_in</strong> (<em>dict</em>) &#8211; the dictionary containing the optimised RAM solution variables</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">None</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pycoalescence.simulation.Simulation.set_simulation_params">
<code class="descname">set_simulation_params</code><span class="sig-paren">(</span><em>seed</em>, <em>job_type</em>, <em>output_directory</em>, <em>min_speciation_rate</em>, <em>sigma=1.0</em>, <em>tau=1.0</em>, <em>deme=1</em>, <em>sample_size=1.0</em>, <em>max_time=3600</em>, <em>dispersal_method=None</em>, <em>m_prob=0.0</em>, <em>cutoff=0</em>, <em>dispersal_relative_cost=1</em>, <em>min_num_species=1</em>, <em>habitat_change_rate=0.0</em>, <em>gen_since_historical=1</em>, <em>restrict_self=False</em>, <em>landscape_type=False</em>, <em>protracted=False</em>, <em>min_speciation_gen=None</em>, <em>max_speciation_gen=None</em>, <em>spatial=True</em>, <em>uses_spatial_sampling=False</em>, <em>times=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycoalescence/simulation.html#Simulation.set_simulation_params"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycoalescence.simulation.Simulation.set_simulation_params" title="Permalink to this definition">¶</a></dt>
<dd><p>Set all the simulation parameters apart from the map objects.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>seed</strong> (<em>int</em>) &#8211; the unique job number for this simulation set</li>
<li><strong>job_type</strong> (<em>int</em>) &#8211; the job type (used for easy file identification after simulations are complete)</li>
<li><strong>output_directory</strong> (<em>str</em>) &#8211; the output directory to store the SQL database</li>
<li><strong>min_speciation_rate</strong> (<em>float</em>) &#8211; the minimum speciation rate to simulate</li>
<li><strong>sigma</strong> (<em>float</em>) &#8211; the dispersal sigma value</li>
<li><strong>tau</strong> (<em>float</em>) &#8211; the fat-tailed dispersal tau value</li>
<li><strong>deme</strong> (<em>int</em>) &#8211; the deme size (in individuals per cell)</li>
<li><strong>sample_size</strong> (<em>float</em>) &#8211; the sample size of the deme (decimal 0-1)</li>
<li><strong>max_time</strong> (<em>float</em>) &#8211; the maximum allowed simulation time (in seconds)</li>
<li><strong>dispersal_method</strong> (<em>str</em>) &#8211; the dispersal kernel method. Should be one of [normal, fat-tail, norm-uniform]</li>
<li><strong>m_prob</strong> (<em>float</em>) &#8211; the probability of drawing from the uniform dispersal. Only relevant for uniform dispersals</li>
<li><strong>cutoff</strong> (<em>float</em>) &#8211; the maximum value for the uniform dispersal. Only relevant for uniform dispersals.</li>
<li><strong>dispersal_relative_cost</strong> (<em>float</em>) &#8211; the relative cost of travelling through non-habitat (defaults to 1)</li>
<li><strong>min_num_species</strong> (<em>int</em>) &#8211; the minimum number of species known to exist (defaults to 1</li>
<li><strong>habitat_change_rate</strong> (<em>float</em>) &#8211; the rate of habitat change over time</li>
<li><strong>gen_since_historical</strong> (<em>float</em>) &#8211; the time in generations since a historical state was achieved</li>
<li><strong>restrict_self</strong> (<em>bool</em>) &#8211; if true, restricts dispersal from own cell</li>
<li><strong>landscape_type</strong> (<em>bool/str</em>) &#8211; if false or &#8220;closed&#8221;, restricts dispersal to the provided maps, otherwise
can be &#8220;infinite&#8221;, or a tiled landscape using &#8220;tiled_coarse&#8221; or &#8220;tiled_fine&#8221;.</li>
<li><strong>protracted</strong> (<em>bool</em>) &#8211; if true, uses protracted speciation application</li>
<li><strong>min_speciation_gen</strong> (<em>float</em>) &#8211; the minimum amount of time a lineage must exist before speciation occurs.</li>
<li><strong>max_speciation_gen</strong> (<em>float</em>) &#8211; the maximum amount of time a lineage can exist before speciating.</li>
<li><strong>spatial</strong> (<em>bool</em>) &#8211; if true, means that the simulation is spatial</li>
<li><strong>uses_spatial_sampling</strong> (<em>bool</em>) &#8211; if true, the sample mask is interpreted as a proportional sampling mask,
where the number of individuals sampled in the cell is equal to the
density * deme_sample * cell sampling proportion</li>
<li><strong>times</strong> (<em>list</em>) &#8211; list of temporal sampling points to apply (in generations)</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pycoalescence.simulation.Simulation.set_speciation_rates">
<code class="descname">set_speciation_rates</code><span class="sig-paren">(</span><em>speciation_rates</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycoalescence/simulation.html#Simulation.set_speciation_rates"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycoalescence.simulation.Simulation.set_speciation_rates" title="Permalink to this definition">¶</a></dt>
<dd><p>Add speciation rates for analysis at the end of the simulation. This is optional</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>speciation_rates</strong> (<em>list</em>) &#8211; a list of speciation rates to apply at the end of the simulation</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pycoalescence.simulation.Simulation.setupNECSim">
<code class="descname">setupNECSim</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycoalescence/simulation.html#Simulation.setupNECSim"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycoalescence.simulation.Simulation.setupNECSim" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the type of the simulation (spatial/non-spatial, protracted/non-protracted) and sets the c object
appropriately.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">None</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pycoalescence.simulation.Simulation.setup_necsim">
<code class="descname">setup_necsim</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycoalescence/simulation.html#Simulation.setup_necsim"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycoalescence.simulation.Simulation.setup_necsim" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the logging function and the logger object for the necsim object. Enforcing this function is always called
ensures no seg faults occur.</p>
</dd></dl>

<dl class="method">
<dt id="pycoalescence.simulation.Simulation.write_config">
<code class="descname">write_config</code><span class="sig-paren">(</span><em>config_file</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycoalescence/simulation.html#Simulation.write_config"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycoalescence.simulation.Simulation.write_config" title="Permalink to this definition">¶</a></dt>
<dd><p>Writes the config to the config file provided, overwriting any existing config files.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>config_file</strong> &#8211; the config file to write out to</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">None</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-pycoalescence.coalescence_tree">
<span id="coalescence-tree-module"></span><h3><a class="toc-backref" href="#id3">coalescence_tree module</a><a class="headerlink" href="#module-pycoalescence.coalescence_tree" title="Permalink to this headline">¶</a></h3>
<p>Generate the coalescence tree and acquire a number of biodiversity metrics for different parameter sets. Can also be
used to compare against a comparison simulation object. Detailed <a class="reference internal" href="README_landscapes.html#simulate-landscapes"><span class="std std-ref">here</span></a>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">input:</th><td class="field-body"><ul class="first simple">
<li>Completed simulation database from <a class="reference internal" href="#pycoalescence.simulation.Simulation" title="pycoalescence.simulation.Simulation"><code class="xref py py-class docutils literal"><span class="pre">Simulation</span></code></a></li>
<li>Parameters and operations to apply</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">output:</th><td class="field-body"><ul class="first last simple">
<li>A variety of biodiversity metrics, including species richness and abundance distributions, locations of each
species, alpha and beta diversity, plus equivalent fragment biodiversity metrics.</li>
<li>Modifies the simulation database in place.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="class">
<dt id="pycoalescence.coalescence_tree.CoalescenceTree">
<em class="property">class </em><code class="descname">CoalescenceTree</code><span class="sig-paren">(</span><em>database=None</em>, <em>logging_level=30</em>, <em>log_output=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycoalescence/coalescence_tree.html#CoalescenceTree"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycoalescence.coalescence_tree.CoalescenceTree" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">object</span></code></p>
<p>Contains the coalescence tree and performs various calculations of different biodiversity metrics, which are then
stored in the SQLite database.</p>
<p>The general process is</p>
<ul class="simple">
<li>Import the database (<a class="reference internal" href="#pycoalescence.coalescence_tree.CoalescenceTree.set_database" title="pycoalescence.coalescence_tree.CoalescenceTree.set_database"><code class="xref py py-meth docutils literal"><span class="pre">set_database()</span></code></a>) and import the comparison data,
if required (<a class="reference internal" href="#pycoalescence.coalescence_tree.CoalescenceTree.import_comparison_data" title="pycoalescence.coalescence_tree.CoalescenceTree.import_comparison_data"><code class="xref py py-meth docutils literal"><span class="pre">import_comparison_data()</span></code></a>)</li>
<li>Apply additional speciation rates (if required) using <a class="reference internal" href="#pycoalescence.coalescence_tree.CoalescenceTree.set_speciation_params" title="pycoalescence.coalescence_tree.CoalescenceTree.set_speciation_params"><code class="xref py py-meth docutils literal"><span class="pre">set_speciation_params()</span></code></a> and then
<a class="reference internal" href="#pycoalescence.coalescence_tree.CoalescenceTree.apply" title="pycoalescence.coalescence_tree.CoalescenceTree.apply"><code class="xref py py-meth docutils literal"><span class="pre">apply()</span></code></a></li>
<li>Calculate required metrics (such as <a class="reference internal" href="#pycoalescence.coalescence_tree.CoalescenceTree.calculate_fragment_richness" title="pycoalescence.coalescence_tree.CoalescenceTree.calculate_fragment_richness"><code class="xref py py-meth docutils literal"><span class="pre">calculate_fragment_richness()</span></code></a>)</li>
<li>Optionally, calculate the goodness of fit (<a class="reference internal" href="#pycoalescence.coalescence_tree.CoalescenceTree.calculate_goodness_of_fit" title="pycoalescence.coalescence_tree.CoalescenceTree.calculate_goodness_of_fit"><code class="xref py py-meth docutils literal"><span class="pre">calculate_goodness_of_fit()</span></code></a>)</li>
</ul>
<dl class="method">
<dt id="pycoalescence.coalescence_tree.CoalescenceTree.add_multiple_protracted_parameters">
<code class="descname">add_multiple_protracted_parameters</code><span class="sig-paren">(</span><em>min_speciation_gens=None</em>, <em>max_speciation_gens=None</em>, <em>speciation_gens=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycoalescence/coalescence_tree.html#CoalescenceTree.add_multiple_protracted_parameters"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycoalescence.coalescence_tree.CoalescenceTree.add_multiple_protracted_parameters" title="Permalink to this definition">¶</a></dt>
<dd><p>Adds the protracted parameter set, taking an iterable as an input.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Using the keyword arguments, one can supply either a list of tuples for pairs of speciation
generations, or two lists of generations for the min and max, matching in order.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>min_speciation_gens</strong> &#8211; the minimum number of generations required before speciation is permitted. Order
should match that of <code class="xref py py-attr docutils literal"><span class="pre">max_speciation_gens</span></code></li>
<li><strong>max_speciation_gens</strong> &#8211; the maximum number of generations required before speciation is permitted. Order
should match that of <code class="xref py py-attr docutils literal"><span class="pre">min_speciation_gens</span></code></li>
<li><strong>speciation_gens</strong> &#8211; a list of tuples of min/max speciation generations.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pycoalescence.coalescence_tree.CoalescenceTree.add_protracted_parameters">
<code class="descname">add_protracted_parameters</code><span class="sig-paren">(</span><em>min_speciation_gen</em>, <em>max_speciation_gen</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycoalescence/coalescence_tree.html#CoalescenceTree.add_protracted_parameters"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycoalescence.coalescence_tree.CoalescenceTree.add_protracted_parameters" title="Permalink to this definition">¶</a></dt>
<dd><p>Adds the protracted parameter set.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Wipes (0.0, 0.0) from protracted parameters, if it is there alone.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>min_speciation_gen</strong> &#8211; the minimum number of generations required before speciation is permitted</li>
<li><strong>max_speciation_gen</strong> &#8211; the maximum number of generations required before speciation is permitted</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pycoalescence.coalescence_tree.CoalescenceTree.add_time">
<code class="descname">add_time</code><span class="sig-paren">(</span><em>time</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycoalescence/coalescence_tree.html#CoalescenceTree.add_time"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycoalescence.coalescence_tree.CoalescenceTree.add_time" title="Permalink to this definition">¶</a></dt>
<dd><p>Adds the time to the list to be applied.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>time</strong> &#8211; the time to be applied</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pycoalescence.coalescence_tree.CoalescenceTree.add_times">
<code class="descname">add_times</code><span class="sig-paren">(</span><em>times</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycoalescence/coalescence_tree.html#CoalescenceTree.add_times"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycoalescence.coalescence_tree.CoalescenceTree.add_times" title="Permalink to this definition">¶</a></dt>
<dd><p>Adds the list of times to those to be applied.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>times</strong> &#8211; list of times to be applied</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pycoalescence.coalescence_tree.CoalescenceTree.adjust_data">
<code class="descname">adjust_data</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycoalescence/coalescence_tree.html#CoalescenceTree.adjust_data"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycoalescence.coalescence_tree.CoalescenceTree.adjust_data" title="Permalink to this definition">¶</a></dt>
<dd><p>Ensures that the numbers of individuals are equalised between the comparison and simulated datasets, and
modifies the relevant tables with the new data</p>
</dd></dl>

<dl class="method">
<dt id="pycoalescence.coalescence_tree.CoalescenceTree.apply">
<code class="descname">apply</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycoalescence/coalescence_tree.html#CoalescenceTree.apply"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycoalescence.coalescence_tree.CoalescenceTree.apply" title="Permalink to this definition">¶</a></dt>
<dd><p>Generates the cooalescence tree for the set of speciation parameters.
This must be run after the main coalescence simulations are complete.
It will create additional fields and tables in the SQLite database which contains the requested data.</p>
</dd></dl>

<dl class="method">
<dt id="pycoalescence.coalescence_tree.CoalescenceTree.apply_incremental">
<code class="descname">apply_incremental</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycoalescence/coalescence_tree.html#CoalescenceTree.apply_incremental"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycoalescence.coalescence_tree.CoalescenceTree.apply_incremental" title="Permalink to this definition">¶</a></dt>
<dd><p>Generates the coalescence tree for the set of speciation parameters. Does not write changes to the database,
just holds the changes internally.</p>
</dd></dl>

<dl class="method">
<dt id="pycoalescence.coalescence_tree.CoalescenceTree.calculate_alpha_diversity">
<code class="descname">calculate_alpha_diversity</code><span class="sig-paren">(</span><em>output_metrics=True</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycoalescence/coalescence_tree.html#CoalescenceTree.calculate_alpha_diversity"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycoalescence.coalescence_tree.CoalescenceTree.calculate_alpha_diversity" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the system alpha diversity for each set of parameters stored in COMMUNITY_PARAMETERS.
Stores the output in ALPHA_DIVERSITY table.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>output_metrics</strong> (<em>bool</em>) &#8211; output to the BIODIVERSITY_METRICS table</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pycoalescence.coalescence_tree.CoalescenceTree.calculate_beta_diversity">
<code class="descname">calculate_beta_diversity</code><span class="sig-paren">(</span><em>output_metrics=True</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycoalescence/coalescence_tree.html#CoalescenceTree.calculate_beta_diversity"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycoalescence.coalescence_tree.CoalescenceTree.calculate_beta_diversity" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the beta diversity for the system for each speciation parameter set and stores the output in
BETA_DIVERSITY.
Will calculate alpha diversity and species richness tables if they have not already been performed.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>output_metrics</strong> (<em>bool</em>) &#8211; output to the BIODIVERSITY_METRICS table</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pycoalescence.coalescence_tree.CoalescenceTree.calculate_comparison_octaves">
<code class="descname">calculate_comparison_octaves</code><span class="sig-paren">(</span><em>store=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycoalescence/coalescence_tree.html#CoalescenceTree.calculate_comparison_octaves"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycoalescence.coalescence_tree.CoalescenceTree.calculate_comparison_octaves" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the octave classes for the comparison data and for fragments (if required).
If the octaves exist in the FRAGMENT_OCTAVES table in the comparison database, the data will be imported
instead of being re-calculated.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">If store is True, will store an EDITED version of the comparison octaves, such that the number of
individuals is equal between the comparison and simulated data.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>store</strong> &#8211; if True, stores within the comparison database.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pycoalescence.coalescence_tree.CoalescenceTree.calculate_fragment_abundances">
<code class="descname">calculate_fragment_abundances</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycoalescence/coalescence_tree.html#CoalescenceTree.calculate_fragment_abundances"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycoalescence.coalescence_tree.CoalescenceTree.calculate_fragment_abundances" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the fragment abundances, including equalising with the comparison database, if it has already been
set.</p>
<p>Sets fragment_abundances object.</p>
</dd></dl>

<dl class="method">
<dt id="pycoalescence.coalescence_tree.CoalescenceTree.calculate_fragment_octaves">
<code class="descname">calculate_fragment_octaves</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycoalescence/coalescence_tree.html#CoalescenceTree.calculate_fragment_octaves"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycoalescence.coalescence_tree.CoalescenceTree.calculate_fragment_octaves" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the octave classes for each fragment. Outputs the calculated richness into the SQL database within a
FRAGMENT_OCTAVES table</p>
</dd></dl>

<dl class="method">
<dt id="pycoalescence.coalescence_tree.CoalescenceTree.calculate_fragment_richness">
<code class="descname">calculate_fragment_richness</code><span class="sig-paren">(</span><em>output_metrics=True</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycoalescence/coalescence_tree.html#CoalescenceTree.calculate_fragment_richness"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycoalescence.coalescence_tree.CoalescenceTree.calculate_fragment_richness" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the fragment richness and stores it in a new table called FRAGMENT_RICHNESS. Also adds the record to
BIODIVERSITY METRICS for
If the table already exists, it will simply be returned. Each time point and speciation rate combination will be
recorded as a new variable.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>output_metrics</strong> (<em>bool</em>) &#8211; output to the BIODIVERSITY_METRICS table</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pycoalescence.coalescence_tree.CoalescenceTree.calculate_goodness_of_fit">
<code class="descname">calculate_goodness_of_fit</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycoalescence/coalescence_tree.html#CoalescenceTree.calculate_goodness_of_fit"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycoalescence.coalescence_tree.CoalescenceTree.calculate_goodness_of_fit" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the goodness-of-fit measure based on the calculated biodiversity metrics, scaling each metric by the
number of individuals involved in the metric.</p>
<p>This requires that import_comparison_data() has already been successfully run.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This doesn&#8217;t calculate anything for values which have not yet been written to the
BIODIVERSITY_METRICS table. All in-built functions (e.g. calculate_alpha_diversity,
calculate_fragment_richness) write to the BIODIVERSITY_METRICS table automatically, so this is only relevant
for custom functions.</p>
</div>
<p>The resulting value will then be written to the BIODIVERSITY_METRICS table in the SQL database.</p>
</dd></dl>

<dl class="method">
<dt id="pycoalescence.coalescence_tree.CoalescenceTree.calculate_octaves">
<code class="descname">calculate_octaves</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycoalescence/coalescence_tree.html#CoalescenceTree.calculate_octaves"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycoalescence.coalescence_tree.CoalescenceTree.calculate_octaves" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the octave classes for the landscape. Outputs the calculated richness into the SQL database within a
FRAGMENT_OCTAVES table.</p>
</dd></dl>

<dl class="method">
<dt id="pycoalescence.coalescence_tree.CoalescenceTree.calculate_octaves_error">
<code class="descname">calculate_octaves_error</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycoalescence/coalescence_tree.html#CoalescenceTree.calculate_octaves_error"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycoalescence.coalescence_tree.CoalescenceTree.calculate_octaves_error" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the error in octaves classes between the simulated data and the comparison data.
Stores each error value as a new entry in BIODIVERSITY_METRICS under fragment_octaves.
Calculates the error by comparing each octave class and summing the relative difference.
Octaves are then averaged for each fragment.</p>
</dd></dl>

<dl class="method">
<dt id="pycoalescence.coalescence_tree.CoalescenceTree.calculate_richness">
<code class="descname">calculate_richness</code><span class="sig-paren">(</span><em>output_metrics=True</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycoalescence/coalescence_tree.html#CoalescenceTree.calculate_richness"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycoalescence.coalescence_tree.CoalescenceTree.calculate_richness" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the landscape richness from across all fragments and stores result in a new table in
SPECIES_RICHNESS
Stores a separate result for each speciation rate and time.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>output_metrics</strong> (<em>bool</em>) &#8211; output to the BIODIVERSITY_METRICS table</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pycoalescence.coalescence_tree.CoalescenceTree.calculate_species_distance_similarity">
<code class="descname">calculate_species_distance_similarity</code><span class="sig-paren">(</span><em>output_metrics=True</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycoalescence/coalescence_tree.html#CoalescenceTree.calculate_species_distance_similarity"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycoalescence.coalescence_tree.CoalescenceTree.calculate_species_distance_similarity" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the probability two individuals are of the same species as a function of distance.</p>
<p>Stores the mean distance between individuals of the same species in the BIODIVERSITY_METRICS table, and stores
the full data in new table (SPECIES_DISTANCE_SIMILARITY). Distances are binned to the nearest integer.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>output_metrics</strong> &#8211; if true, outputs to the BIODIVERSITY_METRICS table as well, for metric comparison</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Extremely slow for large landscape sizes.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pycoalescence.coalescence_tree.CoalescenceTree.check_biodiversity_table_exists">
<code class="descname">check_biodiversity_table_exists</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycoalescence/coalescence_tree.html#CoalescenceTree.check_biodiversity_table_exists"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycoalescence.coalescence_tree.CoalescenceTree.check_biodiversity_table_exists" title="Permalink to this definition">¶</a></dt>
<dd><p>Checks whether the biodiversity table exists and creates the table if required.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">the max reference value currently existing</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pycoalescence.coalescence_tree.CoalescenceTree.clear_calculations">
<code class="descname">clear_calculations</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycoalescence/coalescence_tree.html#CoalescenceTree.clear_calculations"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycoalescence.coalescence_tree.CoalescenceTree.clear_calculations" title="Permalink to this definition">¶</a></dt>
<dd><p>Removes the BIODIVERSITY_METRICS and FRAGMENT_OCTAVES tables completely.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">that this cannot be undone (other than re-running the calculations).</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pycoalescence.coalescence_tree.CoalescenceTree.dispersal_parameters">
<code class="descname">dispersal_parameters</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycoalescence/coalescence_tree.html#CoalescenceTree.dispersal_parameters"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycoalescence.coalescence_tree.CoalescenceTree.dispersal_parameters" title="Permalink to this definition">¶</a></dt>
<dd><p>Reads the dispersal parameters from the database and returns them.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">a list of the dispersal parameters [sigma, tau, m_probability, cutoff]</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pycoalescence.coalescence_tree.CoalescenceTree.get_all_fragment_abundances">
<code class="descname">get_all_fragment_abundances</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycoalescence/coalescence_tree.html#CoalescenceTree.get_all_fragment_abundances"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycoalescence.coalescence_tree.CoalescenceTree.get_all_fragment_abundances" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the whole table of fragment abundances from the database.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">a list of reference, fragment, species_id, no_individuals</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pycoalescence.coalescence_tree.CoalescenceTree.get_alpha_diversity">
<code class="descname">get_alpha_diversity</code><span class="sig-paren">(</span><em>reference=1</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycoalescence/coalescence_tree.html#CoalescenceTree.get_alpha_diversity"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycoalescence.coalescence_tree.CoalescenceTree.get_alpha_diversity" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the system alpha diversity for the provided community reference parameters.
Alpha diversity is the mean number of species per fragment.
:param reference: the community reference for speciation parameters
:return: the alpha diversity of the system</p>
</dd></dl>

<dl class="method">
<dt id="pycoalescence.coalescence_tree.CoalescenceTree.get_beta_diversity">
<code class="descname">get_beta_diversity</code><span class="sig-paren">(</span><em>reference=1</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycoalescence/coalescence_tree.html#CoalescenceTree.get_beta_diversity"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycoalescence.coalescence_tree.CoalescenceTree.get_beta_diversity" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the system beta diversity for the provided community reference parameters.
Beta diversity is the true beta diversity (gamma / alpha).
:param reference: the community reference for speciation parameters
:return: the beta diversity of the system</p>
</dd></dl>

<dl class="method">
<dt id="pycoalescence.coalescence_tree.CoalescenceTree.get_community_parameters">
<code class="descname">get_community_parameters</code><span class="sig-paren">(</span><em>reference=1</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycoalescence/coalescence_tree.html#CoalescenceTree.get_community_parameters"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycoalescence.coalescence_tree.CoalescenceTree.get_community_parameters" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a dictionary containing the parameters for the calculated community.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>reference</strong> &#8211; the reference key for the calculated parameters. (default is 1)</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">dictionary containing the speciation_rate, time, fragments and metacommunity_reference</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">dict</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pycoalescence.coalescence_tree.CoalescenceTree.get_community_reference">
<code class="descname">get_community_reference</code><span class="sig-paren">(</span><em>speciation_rate</em>, <em>time</em>, <em>fragments</em>, <em>metacommunity_size=0</em>, <em>metacommunity_speciation_rate=0.0</em>, <em>min_speciation_gen=0.0</em>, <em>max_speciation_gen=0.0</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycoalescence/coalescence_tree.html#CoalescenceTree.get_community_reference"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycoalescence.coalescence_tree.CoalescenceTree.get_community_reference" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the community reference associated with the supplied community parameters</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><p class="first"><strong>KeyError</strong> &#8211; if COMMUNITY_PARAMETERS (or METACOMMUNITY_PARAMETERS) does not exist in database or no
reference exists for the supplied parameters</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>speciation_rate</strong> &#8211; the speciation rate of the community</li>
<li><strong>time</strong> &#8211; the time in generations of the community</li>
<li><strong>fragments</strong> &#8211; whether fragments were determined for the community</li>
<li><strong>metacommunity_size</strong> &#8211; the metacommunity size</li>
<li><strong>metacommunity_speciation_rate</strong> &#8211; the metacommunity speciation rate</li>
<li><strong>min_speciation_gen</strong> &#8211; the minimum number of generations required before speciation</li>
<li><strong>max_speciation_gen</strong> &#8211; the maximum number of generations required before speciation</li>
</ul>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">the reference associated with this set of simulation parameters</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pycoalescence.coalescence_tree.CoalescenceTree.get_community_references">
<code class="descname">get_community_references</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycoalescence/coalescence_tree.html#CoalescenceTree.get_community_references"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycoalescence.coalescence_tree.CoalescenceTree.get_community_references" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets a list of all the commuity references already calculated for the simulation.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">list of all calculated community references</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">list</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pycoalescence.coalescence_tree.CoalescenceTree.get_fragment_abundances">
<code class="descname">get_fragment_abundances</code><span class="sig-paren">(</span><em>fragment</em>, <em>reference</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycoalescence/coalescence_tree.html#CoalescenceTree.get_fragment_abundances"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycoalescence.coalescence_tree.CoalescenceTree.get_fragment_abundances" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the species abundances for the supplied fragment and community reference.
:param fragment: the name of the fragment to obtain
:param reference: the reference for speciation parameters to obtain for
:return: a list of species ids and abundances</p>
</dd></dl>

<dl class="method">
<dt id="pycoalescence.coalescence_tree.CoalescenceTree.get_fragment_list">
<code class="descname">get_fragment_list</code><span class="sig-paren">(</span><em>community_reference=1</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycoalescence/coalescence_tree.html#CoalescenceTree.get_fragment_list"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycoalescence.coalescence_tree.CoalescenceTree.get_fragment_list" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a list of all fragments that exist in FRAGMENT_ABUNDANCES.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>community_reference</strong> &#8211; community reference to obtain for (default 1)</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">list all all fragment names</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pycoalescence.coalescence_tree.CoalescenceTree.get_fragment_octaves">
<code class="descname">get_fragment_octaves</code><span class="sig-paren">(</span><em>fragment=None</em>, <em>reference=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycoalescence/coalescence_tree.html#CoalescenceTree.get_fragment_octaves"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycoalescence.coalescence_tree.CoalescenceTree.get_fragment_octaves" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the pre-calculated octave data for the specified fragment, speciation rate and time. If fragment and
speciation_rate are None, returns the entire FRAGMENT_OCTAVES object
This requires self.calculate_fragment_octaves() to have been run successfully at some point previously.</p>
<p>Returns are of form [id, fragment, community_reference, octave class, number of species]</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>fragment</strong> &#8211; the desired fragment (defaults to None)</li>
<li><strong>reference</strong> &#8211; the reference key for the calculated community parameters</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">output from FRAGMENT_OCTAVES for the selected variables</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pycoalescence.coalescence_tree.CoalescenceTree.get_fragment_richness">
<code class="descname">get_fragment_richness</code><span class="sig-paren">(</span><em>fragment=None</em>, <em>reference=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycoalescence/coalescence_tree.html#CoalescenceTree.get_fragment_richness"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycoalescence.coalescence_tree.CoalescenceTree.get_fragment_richness" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the fragment richness for each speciation rate and time for the specified simulation. If the fragment
richness has not yet been calculated, it tries to calculate the fragment richness,</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>fragment</strong> &#8211; the desired fragment (defaults to None)</li>
<li><strong>reference</strong> &#8211; the reference key for the calculated community parameters</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><p class="first">sqlite3.OperationalError if no table FRAGMENT_ABUNDANCES exists</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><p class="first">RuntimeError if no data for the specified fragment, speciation rate and time exists.</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">A list containing the fragment richness, or a value of the fragment richness</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pycoalescence.coalescence_tree.CoalescenceTree.get_goodness_of_fit">
<code class="descname">get_goodness_of_fit</code><span class="sig-paren">(</span><em>reference=1</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycoalescence/coalescence_tree.html#CoalescenceTree.get_goodness_of_fit"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycoalescence.coalescence_tree.CoalescenceTree.get_goodness_of_fit" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the goodness of fit from the file.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>reference</strong> &#8211; the community reference to get from</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">the full output from the SQL query</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">list</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pycoalescence.coalescence_tree.CoalescenceTree.get_goodness_of_fit_fragment_octaves">
<code class="descname">get_goodness_of_fit_fragment_octaves</code><span class="sig-paren">(</span><em>reference=1</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycoalescence/coalescence_tree.html#CoalescenceTree.get_goodness_of_fit_fragment_octaves"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycoalescence.coalescence_tree.CoalescenceTree.get_goodness_of_fit_fragment_octaves" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the goodness of fit for fragment octaves from the file.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><strong>ValueError</strong> &#8211; if BIODIVERSITY_METRICS table does not exist.</td>
</tr>
<tr class="field-even field"><th class="field-name">Parameters:</th><td class="field-body"><strong>reference</strong> &#8211; the community reference number</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">the full output from the SQL query</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">list</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pycoalescence.coalescence_tree.CoalescenceTree.get_goodness_of_fit_fragment_richness">
<code class="descname">get_goodness_of_fit_fragment_richness</code><span class="sig-paren">(</span><em>reference=1</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycoalescence/coalescence_tree.html#CoalescenceTree.get_goodness_of_fit_fragment_richness"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycoalescence.coalescence_tree.CoalescenceTree.get_goodness_of_fit_fragment_richness" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the goodness of fit for fragment richness from the file.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><strong>ValueError</strong> &#8211; if BIODIVERSITY_METRICS table does not exist.</td>
</tr>
<tr class="field-even field"><th class="field-name">Parameters:</th><td class="field-body"><strong>reference</strong> &#8211; the community reference number</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">the full output from the SQL query</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">float</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pycoalescence.coalescence_tree.CoalescenceTree.get_goodness_of_fit_metric">
<code class="descname">get_goodness_of_fit_metric</code><span class="sig-paren">(</span><em>metric</em>, <em>reference=1</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycoalescence/coalescence_tree.html#CoalescenceTree.get_goodness_of_fit_metric"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycoalescence.coalescence_tree.CoalescenceTree.get_goodness_of_fit_metric" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the goodness-of-fit measure for the specified metric and community reference.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>metric</strong> &#8211; the metric goodness of fit has been calculated for to obtain</li>
<li><strong>reference</strong> &#8211; the community reference to fetch fits for</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">the goodness of fit value</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">float</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pycoalescence.coalescence_tree.CoalescenceTree.get_job">
<code class="descname">get_job</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycoalescence/coalescence_tree.html#CoalescenceTree.get_job"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycoalescence.coalescence_tree.CoalescenceTree.get_job" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the job number (the seed) and the job type (the task identifier).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">list containing [seed, job_type (the task identifier)]</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pycoalescence.coalescence_tree.CoalescenceTree.get_landscape_richness">
<code class="descname">get_landscape_richness</code><span class="sig-paren">(</span><em>reference=1</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycoalescence/coalescence_tree.html#CoalescenceTree.get_landscape_richness"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycoalescence.coalescence_tree.CoalescenceTree.get_landscape_richness" title="Permalink to this definition">¶</a></dt>
<dd><p>Reads the landscape richness from the SPECIES_RICHNESS table in the database. Returns the richness for
each speciation rate and time.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This should produce the same result as get_richness(sr, t) with the corresponding sr and t.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Return type of this function changes based on whether speciation rates and times were supplied.
If they were, returns a single integer. Otherwise, returns a list of all species richnesses.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>speciation_rate</strong> &#8211; the required speciation rate (optional)</li>
<li><strong>reference</strong> &#8211; the reference key for the calculated community parameters</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">either a list containing the speciation_rate, time, richness OR (if specific speciation rate and time
provided), the species richness at that time and speciation rate.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">int, list</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pycoalescence.coalescence_tree.CoalescenceTree.get_metacommunity_parameters">
<code class="descname">get_metacommunity_parameters</code><span class="sig-paren">(</span><em>reference=1</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycoalescence/coalescence_tree.html#CoalescenceTree.get_metacommunity_parameters"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycoalescence.coalescence_tree.CoalescenceTree.get_metacommunity_parameters" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a dictionary containing the parameters for the calculated community.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>reference</strong> &#8211; the reference key for the calculated parameters. (default is 1)</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first simple">
<li><strong>sqlite3.OperationalError</strong> &#8211; if the METACOMMUNITY_PARAMETERS table does not exist, or some other sqlite
error occurs</li>
<li><strong>KeyError</strong> &#8211; if the supplied reference does not exist in the METACOMMUNITY_PARAMETERS table</li>
</ul>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">dictionary containing the speciation_rate, time, fragments and metacommunity_reference</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">dict</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pycoalescence.coalescence_tree.CoalescenceTree.get_metacommunity_references">
<code class="descname">get_metacommunity_references</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycoalescence/coalescence_tree.html#CoalescenceTree.get_metacommunity_references"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycoalescence.coalescence_tree.CoalescenceTree.get_metacommunity_references" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets a list of all the metacommuity references already calculated for the simulation.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Returns an empty list and logs an error message if the METACOMMUNITY_PARAMETERS table does not exist.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">list of all calculated metacommunity references</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">list</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pycoalescence.coalescence_tree.CoalescenceTree.get_number_individuals">
<code class="descname">get_number_individuals</code><span class="sig-paren">(</span><em>fragment=None</em>, <em>community_reference=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycoalescence/coalescence_tree.html#CoalescenceTree.get_number_individuals"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycoalescence.coalescence_tree.CoalescenceTree.get_number_individuals" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the number of individuals that exist, either in the provided fragment, or on the whole landscape.
Counts individuals from FRAGMENT_ABUNDANCES or SPECIES_ABUNDANCES, respectively.</p>
<p>If a community reference is provided, only individuals for that time slice will be counted, otherwise a mean is
taken across time slices.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>fragment</strong> &#8211; the name of the fragment to get a count of individuals from</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">the number of individuals that exists in the desired location</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pycoalescence.coalescence_tree.CoalescenceTree.get_octaves">
<code class="descname">get_octaves</code><span class="sig-paren">(</span><em>reference</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycoalescence/coalescence_tree.html#CoalescenceTree.get_octaves"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycoalescence.coalescence_tree.CoalescenceTree.get_octaves" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the pre-calculated octave data for the parameters associated with the supplied reference.
This will call self.calculate_octaves() if it hasn&#8217;t been called previously.</p>
<p>Returns are of form [id, &#8216;whole&#8217;, time, speciation rate, octave class, number of species]</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>reference</strong> &#8211; community reference which contains the parameters of interest</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">output from FRAGMENT_OCTAVES on the whole landscape for the selected variables</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pycoalescence.coalescence_tree.CoalescenceTree.get_parameter_description">
<code class="descname">get_parameter_description</code><span class="sig-paren">(</span><em>key=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycoalescence/coalescence_tree.html#CoalescenceTree.get_parameter_description"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycoalescence.coalescence_tree.CoalescenceTree.get_parameter_description" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the description of the parameter matching the key from those contained in SIMULATION_PARAMETERS</p>
<p>Simply accesses the _parameter_descriptions data stored in parameter_descriptions.json</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">string containing the parameter description or a dict containing all values if no key is supplied</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">str</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pycoalescence.coalescence_tree.CoalescenceTree.get_richness">
<code class="descname">get_richness</code><span class="sig-paren">(</span><em>reference=1</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycoalescence/coalescence_tree.html#CoalescenceTree.get_richness"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycoalescence.coalescence_tree.CoalescenceTree.get_richness" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the system richness for the parameters associated with the supplied community reference.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Richness of 0 is returned if there has been some problem; it is assumed that species richness
will be above 0 for any simulation.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Values generated by this method should be identical to those produced by self.get_landscape_richness()</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>reference</strong> &#8211; community reference which contains the parameters of interest</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">the system species richness</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pycoalescence.coalescence_tree.CoalescenceTree.get_simulation_parameters">
<code class="descname">get_simulation_parameters</code><span class="sig-paren">(</span><em>guild=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycoalescence/coalescence_tree.html#CoalescenceTree.get_simulation_parameters"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycoalescence.coalescence_tree.CoalescenceTree.get_simulation_parameters" title="Permalink to this definition">¶</a></dt>
<dd><p>Reads the simulation parameters from the database and returns them.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">a dictionary mapping names to values for seed, job_type, output_dir, speciation_rate, sigma, L_value, deme,</td>
</tr>
</tbody>
</table>
<p>sample_size, maxtime, dispersal_relative_cost, min_spec, habitat_change_rate, gen_since_historical, time_config,
coarse_map vars, fine map vars, sample_file, gridx, gridy, historical coarse map, historical fine map, sim_complete,
dispersal_method, m_probability, cutoff, landscape_type, protracted, min_speciation_gen, max_speciation_gen,
dispersal_map</p>
</dd></dl>

<dl class="method">
<dt id="pycoalescence.coalescence_tree.CoalescenceTree.get_species_abundances">
<code class="descname">get_species_abundances</code><span class="sig-paren">(</span><em>fragment=None</em>, <em>reference=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycoalescence/coalescence_tree.html#CoalescenceTree.get_species_abundances"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycoalescence.coalescence_tree.CoalescenceTree.get_species_abundances" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the species abundance for a particular fragment, speciation rate and time. If fragment is None, returns the
whole landscape species abundances.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>fragment</strong> &#8211; the fragment to obtain the species abundance of. If None, returns landscape abundances.</li>
<li><strong>speciation_rate</strong> &#8211; speciation rate to obtain abundances for</li>
<li><strong>time</strong> &#8211; the time to obtain abundances for</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">list of species abundances [reference, species ID, speciation rate, number of individuals, generation]</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pycoalescence.coalescence_tree.CoalescenceTree.get_species_distance_similarity">
<code class="descname">get_species_distance_similarity</code><span class="sig-paren">(</span><em>community_reference=1</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycoalescence/coalescence_tree.html#CoalescenceTree.get_species_distance_similarity"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycoalescence.coalescence_tree.CoalescenceTree.get_species_distance_similarity" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the species distance similarity table for the provided community reference.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">list containing the distance, number of similar species with that distance</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pycoalescence.coalescence_tree.CoalescenceTree.get_species_list">
<code class="descname">get_species_list</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycoalescence/coalescence_tree.html#CoalescenceTree.get_species_list"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycoalescence.coalescence_tree.CoalescenceTree.get_species_list" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the entirety of the SPECIES_LIST table, returning a tuple with an entry for each row. This can be used to
construct custom analyses of the coalescence tree.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The species list will be produced in an unprocessed format</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">a list of each coalescence and speciation event, with locations, performed in the simulation</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">tuple</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pycoalescence.coalescence_tree.CoalescenceTree.get_species_locations">
<code class="descname">get_species_locations</code><span class="sig-paren">(</span><em>community_reference=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycoalescence/coalescence_tree.html#CoalescenceTree.get_species_locations"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycoalescence.coalescence_tree.CoalescenceTree.get_species_locations" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the list of species locations after coalescence.</p>
<p>If a community reference is provided, will return just the species for that community reference, otherwise
returns the whole table</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>community_reference</strong> (<em>int</em>) &#8211; community reference number</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">a list of lists containing each row of the SPECIES_LOCATIONS table</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pycoalescence.coalescence_tree.CoalescenceTree.import_comparison_data">
<code class="descname">import_comparison_data</code><span class="sig-paren">(</span><em>filename</em>, <em>ignore_mismatch=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycoalescence/coalescence_tree.html#CoalescenceTree.import_comparison_data"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycoalescence.coalescence_tree.CoalescenceTree.import_comparison_data" title="Permalink to this definition">¶</a></dt>
<dd><p>Imports the SQL database that contains the biodiversity metrics that we want to compare against.</p>
<p>This can either be real data (for comparing simulated data) or other simulated data (for comparing between models).</p>
<p>If the SQL database does not contain the relevant biodiversity metrics, they will be calculated (if possible) or skipped.</p>
<p>The expected form of the database is the same as the BIODIVERSITY_METRICS table, except without any speciation
rates or time references, and a new column containing the number of individuals involved in each metric.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This also equalises the comparison data if ignore_mismatch is not True, so that the number of individuals
is equal between the simulated and comparison datasets.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>filename</strong> (<em>str</em>) &#8211; the file containing the comparison biodiversity metrics.</li>
<li><strong>ignore_mismatch</strong> (<em>bool</em>) &#8211; set to true to ignore abundance mismatches between the comparison and simulated data.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pycoalescence.coalescence_tree.CoalescenceTree.is_completed">
<code class="descname">is_completed</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycoalescence/coalescence_tree.html#CoalescenceTree.is_completed"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycoalescence.coalescence_tree.CoalescenceTree.is_completed" title="Permalink to this definition">¶</a></dt>
<dd><p>Indicates whether the simulation has been performed to completion, or if the simulation has been paused and
needs to be completed before analysis can be performed.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">bool: true if simulation is complete</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pycoalescence.coalescence_tree.CoalescenceTree.is_protracted">
<code class="descname">is_protracted</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycoalescence/coalescence_tree.html#CoalescenceTree.is_protracted"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycoalescence.coalescence_tree.CoalescenceTree.is_protracted" title="Permalink to this definition">¶</a></dt>
<dd><p>Indicates whether the simulation is a protracted simulation or not. This is read from the completed database file.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">boolean, true if the simulation was performed with protracted speciation.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pycoalescence.coalescence_tree.CoalescenceTree.output">
<code class="descname">output</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycoalescence/coalescence_tree.html#CoalescenceTree.output"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycoalescence.coalescence_tree.CoalescenceTree.output" title="Permalink to this definition">¶</a></dt>
<dd><p>Outputs the coalescence trees to the same simulation database object.</p>
</dd></dl>

<dl class="method">
<dt id="pycoalescence.coalescence_tree.CoalescenceTree.sample_fragment_richness">
<code class="descname">sample_fragment_richness</code><span class="sig-paren">(</span><em>fragment</em>, <em>number_of_individuals</em>, <em>community_reference=1</em>, <em>n=1</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycoalescence/coalescence_tree.html#CoalescenceTree.sample_fragment_richness"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycoalescence.coalescence_tree.CoalescenceTree.sample_fragment_richness" title="Permalink to this definition">¶</a></dt>
<dd><p>Samples from the database from FRAGMENT_ABUNDANCES, the desired number of individuals.</p>
<p>Randomly selects the desired number of individuals from the database n times and returns the mean richness for
the random samples.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><p class="first"><strong>IOError</strong> &#8211; if the FRAGMENT_ABUNDANCES table does not exist in the database.</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>fragment</strong> &#8211; the reference of the fragment to aquire the richness for</li>
<li><strong>number_of_individuals</strong> &#8211; the number of individuals to sample</li>
<li><strong>community_reference</strong> &#8211; the reference for the community parameters</li>
<li><strong>n</strong> &#8211; number of times to repeatedly sample</li>
</ul>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">the mean of the richness from the repeats</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">float</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pycoalescence.coalescence_tree.CoalescenceTree.sample_landscape_richness">
<code class="descname">sample_landscape_richness</code><span class="sig-paren">(</span><em>number_of_individuals</em>, <em>n=1</em>, <em>community_reference=1</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycoalescence/coalescence_tree.html#CoalescenceTree.sample_landscape_richness"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycoalescence.coalescence_tree.CoalescenceTree.sample_landscape_richness" title="Permalink to this definition">¶</a></dt>
<dd><p>Samples from the landscape the required number of individuals, returning the mean of the species richnesses
produced.</p>
<p>If number_of_individuals is a dictionary mapping fragment names to numbers sampled, will sample the respective
number from each fragment and return the whole landscape richness.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><p class="first"><strong>KeyError</strong> &#8211; if the dictionary supplied contains more sampled individuals than exist in a fragment, or
if the fragment is not contained within the dictionary.</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>number_of_individuals</strong> (<em>int/dict</em>) &#8211; either an int containing the number of individuals to be sampled, or a
dictionary mapping fragment names to numbers of individuals to be sampled</li>
<li><strong>n</strong> &#8211; the number of repeats to average over</li>
<li><strong>community_reference</strong> &#8211; the community reference to fetch abundances for</li>
</ul>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">the mean of the richness from the repeats for the whole landscape</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">float</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pycoalescence.coalescence_tree.CoalescenceTree.set_c_community">
<code class="descname">set_c_community</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycoalescence/coalescence_tree.html#CoalescenceTree.set_c_community"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycoalescence.coalescence_tree.CoalescenceTree.set_c_community" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the c++ object depending on if a metacommunity is used or not.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">None</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pycoalescence.coalescence_tree.CoalescenceTree.set_database">
<code class="descname">set_database</code><span class="sig-paren">(</span><em>filename</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycoalescence/coalescence_tree.html#CoalescenceTree.set_database"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycoalescence.coalescence_tree.CoalescenceTree.set_database" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the database to the specified file and opens the sqlite connection.</p>
<p>This must be done before any other operations can be performed and the
file must exist.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><strong>IOError</strong> &#8211; if the simulation is not complete, as analysis can only be performed on complete simulations.
However, the database WILL be set before the error is thrown, allowing for analysis of
incomplete simulations if the error is handled correctly.</td>
</tr>
<tr class="field-even field"><th class="field-name">Parameters:</th><td class="field-body"><strong>filename</strong> &#8211; the SQLite database file to import</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pycoalescence.coalescence_tree.CoalescenceTree.set_speciation_params">
<code class="descname">set_speciation_params</code><span class="sig-paren">(</span><em>speciation_rates</em>, <em>record_spatial=False</em>, <em>record_fragments=False</em>, <em>sample_file=None</em>, <em>times=None</em>, <em>protracted_speciation_min=None</em>, <em>protracted_speciation_max=None</em>, <em>metacommunity_size=None</em>, <em>metacommunity_speciation_rate=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycoalescence/coalescence_tree.html#CoalescenceTree.set_speciation_params"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycoalescence.coalescence_tree.CoalescenceTree.set_speciation_params" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the parameters for the application of speciation rates. If no config files or time_config files are provided,
they will be taken from the main coalescence simulation.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>speciation_rates</strong> (<em>list</em>) &#8211; a list of speciation rates to apply</li>
<li><strong>str record_spatial</strong> (<em>bool</em><em>,</em><em></em>) &#8211; a boolean of whether to record spatial data (default=False)</li>
<li><strong>str record_fragments</strong> (<em>bool</em><em>,</em><em></em>) &#8211; either a csv file containing fragment data, or T/F for whether fragments
should be calculated from squares of continuous habitat (default=False)</li>
<li><strong>sample_file</strong> (<em>str</em>) &#8211; a sample tif or csv specifying the sampling mask</li>
<li><strong>times</strong> (<em>list</em>) &#8211; a list of times to apply (should have been run with the original simulation)</li>
<li><strong>protracted_speciation_min</strong> (<em>float</em>) &#8211; the minimum number of generations required for speciation to occur</li>
<li><strong>protracted speciation_max</strong> (<em>float</em>) &#8211; the maximum number of generations before speciation occurs</li>
<li><strong>metacommunity_size</strong> (<em>float</em>) &#8211; the size of the metacommunity to apply</li>
<li><strong>metacommunity_speciation_rate</strong> (<em>float</em>) &#8211; speciation rate for the metacommunity</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">None</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pycoalescence.coalescence_tree.CoalescenceTree.setup">
<code class="descname">setup</code><span class="sig-paren">(</span><em>speciation_program='/Users/samthompson/Documents/PhD/Code/pycoalescence/pycoalescence/build/default/SpeciationCounter'</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycoalescence/coalescence_tree.html#CoalescenceTree.setup"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycoalescence.coalescence_tree.CoalescenceTree.setup" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets up the link to the SpeciationCounter program. Defaults to the build/default/SpeciationCounter
:param speciation_program: optionally provide a path to an alternative SpeciationCounter program.</p>
<div class="deprecated">
<p><span class="versionmodified">Deprecated since version 1.2.4: </span>Deprecated due to movement towards using python API for applying speciation rates.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">None</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pycoalescence.coalescence_tree.CoalescenceTree.wipe_data">
<code class="descname">wipe_data</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycoalescence/coalescence_tree.html#CoalescenceTree.wipe_data"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycoalescence.coalescence_tree.CoalescenceTree.wipe_data" title="Permalink to this definition">¶</a></dt>
<dd><p>Wipes all calculated data apart from the original, unformatted coalescence tree.
The Speciation_Counter program will have to be re-run to perform any analyses.</p>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="pycoalescence.coalescence_tree.collate_fits">
<code class="descname">collate_fits</code><span class="sig-paren">(</span><em>file_dir</em>, <em>filename='Collated_fits.db'</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycoalescence/coalescence_tree.html#collate_fits"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycoalescence.coalescence_tree.collate_fits" title="Permalink to this definition">¶</a></dt>
<dd><p>Collates the goodness of fit values from every file in the specified directory and places them in one new file.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Files with &#8216;collated&#8217; in the name will be ignored.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">If the output file exists, it will be deleted.</p>
</div>
<p>Creates three separate tables in the output file, one for overall goodness of fit, one for fragment richness fits,
and one for fragment octaves fits.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>file_dir</strong> &#8211; the file directory to examine</li>
<li><strong>filename</strong> &#8211; [optional] the output file name.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pycoalescence.coalescence_tree.get_parameter_description">
<code class="descname">get_parameter_description</code><span class="sig-paren">(</span><em>key=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycoalescence/coalescence_tree.html#get_parameter_description"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycoalescence.coalescence_tree.get_parameter_description" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the parameter descriptions for the supplied key. If the key is None, returns all keys.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>key</strong> &#8211; the simulation parameter</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">string containing the parameter description or a dict containing all values if no key is supplied</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pycoalescence.coalescence_tree.scale_simulation_fit">
<code class="descname">scale_simulation_fit</code><span class="sig-paren">(</span><em>simulated_value</em>, <em>actual_value</em>, <em>number_individuals</em>, <em>total_individuals</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycoalescence/coalescence_tree.html#scale_simulation_fit"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycoalescence.coalescence_tree.scale_simulation_fit" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates goodness of fit for the provided values, and scales based on the total number of individuals that exist.
The calculation is 1 - (abs(x - y)/max(x, y)) * n/n_tot for x, y simulated and actual values, n, n_tot for metric and total
number of individuals.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>simulated_value</strong> &#8211; the simulated value of the metric</li>
<li><strong>actual_value</strong> &#8211; the actual value of the metric</li>
<li><strong>number_individuals</strong> &#8211; the number of individuals this metric relates to</li>
<li><strong>total_individuals</strong> &#8211; the total number of individuals across all sites for this metric</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">the scaled fit value</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
</div>
<div class="section" id="additional-submodules">
<h2><a class="toc-backref" href="#id4">Additional submodules</a><a class="headerlink" href="#additional-submodules" title="Permalink to this headline">¶</a></h2>
<p>All additional modules which are required for package functionality, but are unlikely to be used directly.</p>
<div class="section" id="module-pycoalescence.dispersal_simulation">
<span id="dispersal-simulation-module"></span><h3><a class="toc-backref" href="#id5">dispersal_simulation module</a><a class="headerlink" href="#module-pycoalescence.dispersal_simulation" title="Permalink to this headline">¶</a></h3>
<p>Simulate dispersal kernels on landscapes. Detailed <a class="reference internal" href="README_landscapes.html#simulate-landscapes"><span class="std std-ref">here</span></a>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">input:</th><td class="field-body"><ul class="first simple">
<li>Map file to simulate on</li>
<li>Set of dispersal pararameters, including the dispersal kernel, number of repetitions and landscape properties</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">output:</th><td class="field-body"><ul class="first last simple">
<li>Database containing each distance travelled so that metrics can be calculated.</li>
<li>A table is created for mean dispersal distance over a single step or for mean distance travelled.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="class">
<dt id="pycoalescence.dispersal_simulation.DispersalSimulation">
<em class="property">class </em><code class="descname">DispersalSimulation</code><span class="sig-paren">(</span><em>dispersal_db='output.db'</em>, <em>file=None</em>, <em>logging_level=30</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycoalescence/dispersal_simulation.html#DispersalSimulation"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycoalescence.dispersal_simulation.DispersalSimulation" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pycoalescence.landscape.Landscape" title="pycoalescence.landscape.Landscape"><code class="xref py py-class docutils literal"><span class="pre">pycoalescence.landscape.Landscape</span></code></a></p>
<p>Simulates a dispersal kernel upon a tif file to calculate landscape-level dispersal metrics.</p>
<dl class="method">
<dt id="pycoalescence.dispersal_simulation.DispersalSimulation.complete_setup">
<code class="descname">complete_setup</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycoalescence/dispersal_simulation.html#DispersalSimulation.complete_setup"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycoalescence.dispersal_simulation.DispersalSimulation.complete_setup" title="Permalink to this definition">¶</a></dt>
<dd><p>Completes the setup for the dispersal simulation, including importing the map files and setting the historical
maps.</p>
</dd></dl>

<dl class="method">
<dt id="pycoalescence.dispersal_simulation.DispersalSimulation.get_database_parameters">
<code class="descname">get_database_parameters</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycoalescence/dispersal_simulation.html#DispersalSimulation.get_database_parameters"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycoalescence.dispersal_simulation.DispersalSimulation.get_database_parameters" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the dispersal simulation parameters from the dispersal_db</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">the dispersal simulation parameters</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">dict</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pycoalescence.dispersal_simulation.DispersalSimulation.get_database_references">
<code class="descname">get_database_references</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycoalescence/dispersal_simulation.html#DispersalSimulation.get_database_references"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycoalescence.dispersal_simulation.DispersalSimulation.get_database_references" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the references from the database.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">a list of references from the database</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">list</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pycoalescence.dispersal_simulation.DispersalSimulation.get_mean_dispersal">
<code class="descname">get_mean_dispersal</code><span class="sig-paren">(</span><em>database=None</em>, <em>parameter_reference=1</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycoalescence/dispersal_simulation.html#DispersalSimulation.get_mean_dispersal"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycoalescence.dispersal_simulation.DispersalSimulation.get_mean_dispersal" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the mean dispersal for the map if run_mean_dispersal has already been run.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><p class="first">ValueError if dispersal_database is None and so run_mean_dispersal() has not been run</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><p class="first">IOError if the output database does not exist</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>database</strong> (<em>str</em>) &#8211; the database to open</li>
<li><strong>parameter_reference</strong> (<em>int</em>) &#8211; the parameter reference to use (or 1 for default parameter reference).</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">mean dispersal from the database</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pycoalescence.dispersal_simulation.DispersalSimulation.get_mean_distance_travelled">
<code class="descname">get_mean_distance_travelled</code><span class="sig-paren">(</span><em>database=None</em>, <em>parameter_reference=1</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycoalescence/dispersal_simulation.html#DispersalSimulation.get_mean_distance_travelled"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycoalescence.dispersal_simulation.DispersalSimulation.get_mean_distance_travelled" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the mean dispersal for the map if run_mean_dispersal has already been run.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><p class="first">ValueError if dispersal_database is None and so test_average_dispersal() has not been run</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><p class="first">IOError if the output database does not exist</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>database</strong> (<em>str</em>) &#8211; the database to open</li>
<li><strong>parameter_reference</strong> (<em>int</em>) &#8211; the parameter reference to use (or 1 for default parameter reference).</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">mean of dispersal from the database</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pycoalescence.dispersal_simulation.DispersalSimulation.get_stdev_dispersal">
<code class="descname">get_stdev_dispersal</code><span class="sig-paren">(</span><em>database=None</em>, <em>parameter_reference=1</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycoalescence/dispersal_simulation.html#DispersalSimulation.get_stdev_dispersal"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycoalescence.dispersal_simulation.DispersalSimulation.get_stdev_dispersal" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the standard deviation of dispersal for the map if run_mean_dispersal has already been run.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><p class="first">ValueError if dispersal_database is None and so test_average_dispersal() has not been run</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><p class="first">IOError if the output database does not exist</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>database</strong> (<em>str</em>) &#8211; the database to open</li>
<li><strong>parameter_reference</strong> (<em>int</em>) &#8211; the parameter reference to use (or 1 for default parameter reference).</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">standard deviation of dispersal from the database</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pycoalescence.dispersal_simulation.DispersalSimulation.get_stdev_distance_travelled">
<code class="descname">get_stdev_distance_travelled</code><span class="sig-paren">(</span><em>database=None</em>, <em>parameter_reference=1</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycoalescence/dispersal_simulation.html#DispersalSimulation.get_stdev_distance_travelled"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycoalescence.dispersal_simulation.DispersalSimulation.get_stdev_distance_travelled" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the standard deviation of the  distance travelled for the map if run_mean_distance_travelled has already
been run.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><p class="first">ValueError if dispersal_database is None and so test_average_dispersal() has not been run</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><p class="first">IOError if the output database does not exist</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>database</strong> (<em>str</em>) &#8211; the database to open</li>
<li><strong>parameter_reference</strong> (<em>int</em>) &#8211; the parameter reference to use (or 1 for default parameter reference).</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">standard deviation of dispersal from the database</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">float</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pycoalescence.dispersal_simulation.DispersalSimulation.run_mean_dispersal">
<code class="descname">run_mean_dispersal</code><span class="sig-paren">(</span><em>number_repeats=None</em>, <em>seed=None</em>, <em>sequential=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycoalescence/dispersal_simulation.html#DispersalSimulation.run_mean_dispersal"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycoalescence.dispersal_simulation.DispersalSimulation.run_mean_dispersal" title="Permalink to this definition">¶</a></dt>
<dd><p>Tests the dispersal kernel on the provided map, producing a database containing each dispersal distance for
analysis purposes.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">should be equivalent to <a class="reference internal" href="#pycoalescence.dispersal_simulation.DispersalSimulation.run_mean_distance_travelled" title="pycoalescence.dispersal_simulation.DispersalSimulation.run_mean_distance_travelled"><code class="xref py py-func docutils literal"><span class="pre">run_mean_distance_travelled()</span></code></a> with number_steps = 1</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>number_repeats</strong> (<em>int</em>) &#8211; the number of times to iterate on the map</li>
<li><strong>seed</strong> (<em>int</em>) &#8211; the random seed</li>
<li><strong>sequential</strong> (<em>bool</em>) &#8211; if true, runs repeats sequentially</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pycoalescence.dispersal_simulation.DispersalSimulation.run_mean_distance_travelled">
<code class="descname">run_mean_distance_travelled</code><span class="sig-paren">(</span><em>number_repeats=None</em>, <em>number_steps=None</em>, <em>seed=None</em>, <em>sequential=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycoalescence/dispersal_simulation.html#DispersalSimulation.run_mean_distance_travelled"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycoalescence.dispersal_simulation.DispersalSimulation.run_mean_distance_travelled" title="Permalink to this definition">¶</a></dt>
<dd><p>Tests the dispersal kernel on the provided map, producing a database containing the average distance travelled
after number_steps have been moved.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">mean distance travelled with number_steps=1 should be equivalent to running
<a class="reference internal" href="#pycoalescence.dispersal_simulation.DispersalSimulation.run_mean_dispersal" title="pycoalescence.dispersal_simulation.DispersalSimulation.run_mean_dispersal"><code class="xref py py-func docutils literal"><span class="pre">run_mean_dispersal()</span></code></a></p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>number_repeats</strong> (<em>int</em>) &#8211; the number of times to iterate on the map</li>
<li><strong>number_steps</strong> (<em>int</em>) &#8211; the number of steps to take each time before recording the distance travelled</li>
<li><strong>seed</strong> (<em>int</em>) &#8211; the random seed</li>
<li><strong>sequential</strong> (<em>bool</em>) &#8211; if true, runs repeats sequentially</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pycoalescence.dispersal_simulation.DispersalSimulation.set_dispersal_parameters">
<code class="descname">set_dispersal_parameters</code><span class="sig-paren">(</span><em>dispersal_method='normal'</em>, <em>dispersal_file='none'</em>, <em>sigma=1</em>, <em>tau=1</em>, <em>m_prob=1</em>, <em>cutoff=100</em>, <em>dispersal_relative_cost=1</em>, <em>restrict_self=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycoalescence/dispersal_simulation.html#DispersalSimulation.set_dispersal_parameters"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycoalescence.dispersal_simulation.DispersalSimulation.set_dispersal_parameters" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the dispersal parameters.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>dispersal_method</strong> (<em>str</em>) &#8211; the dispersal method to use (&#8220;normal&#8221;, &#8220;fat-tailed&#8221; or &#8220;norm-uniform&#8221;)</li>
<li><strong>dispersal_file</strong> (<em>str</em>) &#8211; path to the dispersal map file, or none.</li>
<li><strong>sigma</strong> (<em>float</em>) &#8211; the sigma value to use for normal and norm-uniform dispersal</li>
<li><strong>tau</strong> (<em>float</em>) &#8211; the tau value to use for fat-tailed dispersal</li>
<li><strong>m_prob</strong> (<em>float</em>) &#8211; the m_prob to use for norm-uniform dispersal</li>
<li><strong>cutoff</strong> (<em>float</em>) &#8211; the cutoff value to use for norm-uniform dispersal</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>:param float dispersal_relative_cost:relative dispersal ability through non-habitat
:param bol restrict_self: if true, self-dispersal is prohibited
:return:</p>
</dd></dl>

<dl class="method">
<dt id="pycoalescence.dispersal_simulation.DispersalSimulation.set_map_files">
<code class="descname">set_map_files</code><span class="sig-paren">(</span><em>fine_file</em>, <em>sample_file='null'</em>, <em>coarse_file=None</em>, <em>historical_fine_file=None</em>, <em>historical_coarse_file=None</em>, <em>deme=1</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycoalescence/dispersal_simulation.html#DispersalSimulation.set_map_files"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycoalescence.dispersal_simulation.DispersalSimulation.set_map_files" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the map files.</p>
<p>Uses a null sampling regime, as the sample file should have no effect.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>fine_file</strong> (<em>str</em>) &#8211; the fine map file. Defaults to &#8220;null&#8221; if none provided</li>
<li><strong>coarse_file</strong> (<em>str</em>) &#8211; the coarse map file. Defaults to &#8220;none&#8221; if none provided</li>
<li><strong>historical_fine_file</strong> (<em>str</em>) &#8211; the historical fine map file. Defaults to &#8220;none&#8221; if none provided</li>
<li><strong>historical_coarse_file</strong> (<em>str</em>) &#8211; the historical coarse map file. Defaults to &#8220;none&#8221; if none provided</li>
<li><strong>deme</strong> (<em>int</em>) &#8211; the number of individuals per cell</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">None</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pycoalescence.dispersal_simulation.DispersalSimulation.set_simulation_parameters">
<code class="descname">set_simulation_parameters</code><span class="sig-paren">(</span><em>number_repeats=None</em>, <em>output_database='output.db'</em>, <em>seed=1</em>, <em>dispersal_method='normal'</em>, <em>landscape_type='closed'</em>, <em>sigma=1</em>, <em>tau=1</em>, <em>m_prob=1</em>, <em>cutoff=100</em>, <em>sequential=False</em>, <em>dispersal_relative_cost=1</em>, <em>restrict_self=False</em>, <em>number_steps=1</em>, <em>dispersal_file='none'</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycoalescence/dispersal_simulation.html#DispersalSimulation.set_simulation_parameters"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycoalescence.dispersal_simulation.DispersalSimulation.set_simulation_parameters" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the simulation parameters for the dispersal simulations.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>number_repeats</strong> (<em>int</em>) &#8211; the number of times to iterate on the map</li>
<li><strong>output_database</strong> (<em>str</em>) &#8211; the path to the output database</li>
<li><strong>seed</strong> (<em>int</em>) &#8211; the random seed</li>
<li><strong>dispersal_method</strong> (<em>str</em>) &#8211; the dispersal method to use (&#8220;normal&#8221;, &#8220;fat-tailed&#8221; or &#8220;norm-uniform&#8221;)</li>
<li><strong>landscape_type</strong> (<em>str</em>) &#8211; the landscape type to use (&#8220;infinite&#8221;, &#8220;tiled&#8221; or &#8220;closed&#8221;)</li>
<li><strong>sigma</strong> (<em>float</em>) &#8211; the sigma value to use for normal and norm-uniform dispersal</li>
<li><strong>tau</strong> (<em>float</em>) &#8211; the tau value to use for fat-tailed dispersal</li>
<li><strong>m_prob</strong> (<em>float</em>) &#8211; the m_prob to use for norm-uniform dispersal</li>
<li><strong>cutoff</strong> (<em>float</em>) &#8211; the cutoff value to use for norm-uniform dispersal</li>
<li><strong>sequential</strong> (<em>bool</em>) &#8211; if true, end locations of one dispersal event are used as the start for the next. Otherwise,</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>a new random cell is chosen
:param float dispersal_relative_cost: relative dispersal ability through non-habitat
:param bool restrict_self: if true, self-dispersal is prohibited
:param list/int number_steps: the number to calculate for mean distance travelled, provided as an int or a list</p>
<blockquote>
<div>of ints</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>dispersal_file</strong> (<em>str</em>) &#8211; path to the dispersal map file, or none.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pycoalescence.dispersal_simulation.DispersalSimulation.update_parameters">
<code class="descname">update_parameters</code><span class="sig-paren">(</span><em>number_repeats=None</em>, <em>number_steps=None</em>, <em>seed=None</em>, <em>dispersal_method=None</em>, <em>dispersal_file=None</em>, <em>sigma=None</em>, <em>tau=None</em>, <em>m_prob=None</em>, <em>cutoff=None</em>, <em>dispersal_relative_cost=None</em>, <em>restrict_self=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycoalescence/dispersal_simulation.html#DispersalSimulation.update_parameters"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycoalescence.dispersal_simulation.DispersalSimulation.update_parameters" title="Permalink to this definition">¶</a></dt>
<dd><p>Provides a convenience function for updating all parameters which can be updated.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>number_repeats</strong> (<em>int</em>) &#8211; the number of repeats to perform the dispersal simulation for</li>
<li><strong>number_steps</strong> (<em>list/int</em>) &#8211; the number of steps to iterate for in calculating the mean distance travelled</li>
<li><strong>seed</strong> (<em>int</em>) &#8211; the random number seed</li>
<li><strong>dispersal_method</strong> (<em>str</em>) &#8211; the method of dispersal</li>
<li><strong>dispersal_file</strong> (<em>str</em>) &#8211; the dispersal file (alternative to dispersal_method)</li>
<li><strong>sigma</strong> (<em>float</em>) &#8211; the sigma dispersal value</li>
<li><strong>tau</strong> (<em>float</em>) &#8211; the tau dispersal value</li>
<li><strong>m_prob</strong> (<em>float</em>) &#8211; the probability of drawing from a uniform distribution</li>
<li><strong>cutoff</strong> (<em>float</em>) &#8211; the maximum value for the uniform distribution</li>
<li><strong>dispersal_relative_cost</strong> (<em>float</em>) &#8211; the relative cost of moving through non-habitat</li>
<li><strong>restrict_self</strong> (<em>bool</em>) &#8211; if true, prohibits dispersal from the same cell</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">None</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-pycoalescence.fragments">
<span id="fragments-module"></span><h3><a class="toc-backref" href="#id6">fragments module</a><a class="headerlink" href="#module-pycoalescence.fragments" title="Permalink to this headline">¶</a></h3>
<p>Generate fragmented landscapes with specific properties. Detailed <a class="reference internal" href="README_landscapes.html#simulate-landscapes"><span class="std std-ref">here</span></a>.</p>
<p>Contains <a class="reference internal" href="#pycoalescence.fragments.FragmentedLandscape" title="pycoalescence.fragments.FragmentedLandscape"><code class="xref py py-class docutils literal"><span class="pre">FragmentedLandscape</span></code></a> for creating a fragmented landscape using hexagonal packing and an even spread of
individuals between fragments. Requires scipy and matplotlib.</p>
<dl class="class">
<dt id="pycoalescence.fragments.Fragment">
<em class="property">class </em><code class="descname">Fragment</code><span class="sig-paren">(</span><em>x=None</em>, <em>y=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycoalescence/fragments.html#Fragment"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycoalescence.fragments.Fragment" title="Permalink to this definition">¶</a></dt>
<dd><p>Simple class containing the centres of fragments for a fragmented landscape</p>
<dl class="method">
<dt id="pycoalescence.fragments.Fragment.place_on_grid">
<code class="descname">place_on_grid</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycoalescence/fragments.html#Fragment.place_on_grid"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycoalescence.fragments.Fragment.place_on_grid" title="Permalink to this definition">¶</a></dt>
<dd><p>Changes the x and y positions to integers (always rounds down).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">None</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pycoalescence.fragments.Fragment.setup">
<code class="descname">setup</code><span class="sig-paren">(</span><em>x</em>, <em>y</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycoalescence/fragments.html#Fragment.setup"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycoalescence.fragments.Fragment.setup" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets up the fragment from the x and y position.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>x</strong> &#8211; the x position of the fragment centre</li>
<li><strong>y</strong> &#8211; the y position of the fragment centre</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">None</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pycoalescence.fragments.FragmentedLandscape">
<em class="property">class </em><code class="descname">FragmentedLandscape</code><span class="sig-paren">(</span><em>number_fragments=None</em>, <em>size=None</em>, <em>total=None</em>, <em>output_file=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycoalescence/fragments.html#FragmentedLandscape"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycoalescence.fragments.FragmentedLandscape" title="Permalink to this definition">¶</a></dt>
<dd><p>Contains hexagonal packing algorithms for spacing clumps evenly on the landscape. Includes a LLoyd&#8217;s smoothing
algorithm for better spacing of fragments.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Fragments will not be distinct units for unfragmented landscapes (with above around 50% habitat cover).</p>
</div>
<dl class="method">
<dt id="pycoalescence.fragments.FragmentedLandscape.create">
<code class="descname">create</code><span class="sig-paren">(</span><em>override_smoothing=None</em>, <em>n=10</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycoalescence/fragments.html#FragmentedLandscape.create"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycoalescence.fragments.FragmentedLandscape.create" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates the landscape, including running the hexagonal packing and smoothing algorithms (if required).</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">smoothing is recommended for any landscape that is doesn&#8217;t contain a square number of fragments.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>override_smoothing</strong> &#8211; if true, overrides the default smoothing settings (enabled for landscapes with fewer
than 100000 fragments.</li>
<li><strong>n</strong> &#8211; the number of iterations to run Lloyd&#8217;s algorithm for</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">None</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pycoalescence.fragments.FragmentedLandscape.fill_grid">
<code class="descname">fill_grid</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycoalescence/fragments.html#FragmentedLandscape.fill_grid"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycoalescence.fragments.FragmentedLandscape.fill_grid" title="Permalink to this definition">¶</a></dt>
<dd><p>Distributes the sizes evenly between the fragments, generating the actual landscape.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">None</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pycoalescence.fragments.FragmentedLandscape.generate">
<code class="descname">generate</code><span class="sig-paren">(</span><em>override_smoothing=None</em>, <em>n=10</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycoalescence/fragments.html#FragmentedLandscape.generate"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycoalescence.fragments.FragmentedLandscape.generate" title="Permalink to this definition">¶</a></dt>
<dd><p>Convenience function for creating fragments in one function. Generates the landscape and writes out to the
output file.</p>
<p>If smoothing is true, will run Lloyd&#8217;s algorithm
after the hexagonal packing algorithm to increase the equality of the spacing.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">smoothing is recommended for any landscape that is doesn&#8217;t contain a square number of fragments.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>override_smoothing</strong> &#8211; if true, overrides the default smoothing settings (enabled for landscapes with fewer
than 100000 fragments.</li>
<li><strong>n</strong> &#8211; the number of iterations to run Lloyd&#8217;s algorithm for</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">None</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pycoalescence.fragments.FragmentedLandscape.place_fragments">
<code class="descname">place_fragments</code><span class="sig-paren">(</span><em>smoothing=True</em>, <em>n=10</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycoalescence/fragments.html#FragmentedLandscape.place_fragments"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycoalescence.fragments.FragmentedLandscape.place_fragments" title="Permalink to this definition">¶</a></dt>
<dd><p>Places the fragments evenly on the landscape. If smoothing is true, will run Lloyd&#8217;s algorithm after the
hexagonal packing algorithm to increase the equality of the spacing.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">smoothing is recommended for any landscape that is doesn&#8217;t contain a square number of fragments.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>smoothing</strong> &#8211; if true, runs Lloyd&#8217;s algorithm after the hexagonal packing</li>
<li><strong>n</strong> &#8211; the number of iterations to run Lloyd&#8217;s algorithm for</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">None</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pycoalescence.fragments.FragmentedLandscape.plot">
<code class="descname">plot</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycoalescence/fragments.html#FragmentedLandscape.plot"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycoalescence.fragments.FragmentedLandscape.plot" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a matplotlib.pyplot.figure object containing an image of the fragmented landscape (with axes removed).</p>
<p>Requires that the fragmented landscape has been created already using <a class="reference internal" href="#pycoalescence.fragments.FragmentedLandscape.create" title="pycoalescence.fragments.FragmentedLandscape.create"><code class="xref py py-meth docutils literal"><span class="pre">create()</span></code></a>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">figure object containing the fragmented landscape.</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">matplotlib.pyplot.figure</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pycoalescence.fragments.FragmentedLandscape.setup">
<code class="descname">setup</code><span class="sig-paren">(</span><em>number_fragments</em>, <em>size</em>, <em>total</em>, <em>output_file</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycoalescence/fragments.html#FragmentedLandscape.setup"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycoalescence.fragments.FragmentedLandscape.setup" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets up the landscape by checking parameters and setting object sizes.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>number_fragments</strong> &#8211; the number of individual fragments to exist on the landscape</li>
<li><strong>size</strong> &#8211; the size of the x and y dimensions of the landscape</li>
<li><strong>total</strong> &#8211; the total number of individuals to place on the landscape</li>
<li><strong>output_file</strong> &#8211; the output tif file to write the output to</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">None</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pycoalescence.fragments.FragmentedLandscape.write_to_raster">
<code class="descname">write_to_raster</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycoalescence/fragments.html#FragmentedLandscape.write_to_raster"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycoalescence.fragments.FragmentedLandscape.write_to_raster" title="Permalink to this definition">¶</a></dt>
<dd><p>Writes the landscape to a tif file.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><strong>FileExistsError</strong> &#8211; if the output file already exists</td>
</tr>
<tr class="field-even field"><th class="field-name">Parameters:</th><td class="field-body"><strong>output_file</strong> &#8211; the path to the tif file to write out to.</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">None</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-pycoalescence.fragment_config">
<span id="fragments-config-module"></span><h3><a class="toc-backref" href="#id7">fragments config module</a><a class="headerlink" href="#module-pycoalescence.fragment_config" title="Permalink to this headline">¶</a></h3>
<p>Generate the fragment config files from a supplied shapefile and a raster file to offset from.</p>
<p>The function <a class="reference internal" href="#pycoalescence.fragment_config.generate_fragment_csv" title="pycoalescence.fragment_config.generate_fragment_csv"><code class="xref py py-func docutils literal"><span class="pre">generate_fragment_csv()</span></code></a> contains the full pipeline to generate the fragment csv.</p>
<dl class="class">
<dt id="pycoalescence.fragment_config.FragmentConfigHandler">
<em class="property">class </em><code class="descname">FragmentConfigHandler</code><a class="reference internal" href="_modules/pycoalescence/fragment_config.html#FragmentConfigHandler"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycoalescence.fragment_config.FragmentConfigHandler" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">object</span></code></p>
<p>Contains routines for calculating the offsets from a config file.</p>
<dl class="method">
<dt id="pycoalescence.fragment_config.FragmentConfigHandler.generate_config">
<code class="descname">generate_config</code><span class="sig-paren">(</span><em>input_shapefile</em>, <em>input_raster</em>, <em>field_name='fragment'</em>, <em>field_area='area'</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycoalescence/fragment_config.html#FragmentConfigHandler.generate_config"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycoalescence.fragment_config.FragmentConfigHandler.generate_config" title="Permalink to this definition">¶</a></dt>
<dd><p>Generates the config file from the shapefile containing the fragments, writing the coordinates of the extent of
each fragment to the output csv. The coordinates are calculated from their relevant position on the input
raster.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>input_shapefile</strong> (<em>str</em>) &#8211; shapefile containing the fragments in a &#8220;fragments&#8221; field, with each defined as a
polygon.</li>
<li><strong>input_raster</strong> (<em>str</em>) &#8211; the raster to calculate the coordinates from</li>
<li><strong>field_name</strong> (<em>str</em>) &#8211; optionally provide a field to extract fragment names from</li>
<li><strong>field_area</strong> (<em>str</em>) &#8211; optionally provide a field to extract fragment areas from (the number of individuals that
exist in the fragment.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pycoalescence.fragment_config.FragmentConfigHandler.write_csv">
<code class="descname">write_csv</code><span class="sig-paren">(</span><em>output_csv</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycoalescence/fragment_config.html#FragmentConfigHandler.write_csv"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycoalescence.fragment_config.FragmentConfigHandler.write_csv" title="Permalink to this definition">¶</a></dt>
<dd><p>Writes the fragments to the output csv.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>output_csv</strong> (<em>str</em>) &#8211; the csv to write the output to</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="pycoalescence.fragment_config.generate_fragment_csv">
<code class="descname">generate_fragment_csv</code><span class="sig-paren">(</span><em>input_shapefile</em>, <em>input_raster</em>, <em>output_csv</em>, <em>field_name='fragment'</em>, <em>field_area='area'</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycoalescence/fragment_config.html#generate_fragment_csv"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycoalescence.fragment_config.generate_fragment_csv" title="Permalink to this definition">¶</a></dt>
<dd><p>Generates the fragment csv from the provided shapefile and raster file. Coordinates for outputted to the csv are
calculated from the extent of each polygon in the shapefile as their relative position on the input raster.</p>
<p>The fragment extents are used solely, so overlapping extents of fragments results in individuals in those areas
appearing in both fragments. Therefore, rectangular fragments alone should be used.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>input_shapefile</strong> &#8211; the shapefile containing polygons defining fragments. Should contain fields of field_name
and field_area</li>
<li><strong>input_raster</strong> &#8211; raster file to calculate the relative coordinates on</li>
<li><strong>output_csv</strong> &#8211; output csv to create</li>
<li><strong>field_name</strong> &#8211; name of the field in the shapefile to acquire fragment names from</li>
<li><strong>field_area</strong> &#8211; name of the field in the shapefile to acquire the number of individuals from</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-pycoalescence.helper">
<span id="helper-file"></span><h3><a class="toc-backref" href="#id8">helper file</a><a class="headerlink" href="#module-pycoalescence.helper" title="Permalink to this headline">¶</a></h3>
<p>Port older simulation outputs to the updated naming conventions. Should not be required by most users.</p>
<dl class="function">
<dt id="pycoalescence.helper.update_parameter_names">
<code class="descname">update_parameter_names</code><span class="sig-paren">(</span><em>database</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycoalescence/helper.html#update_parameter_names"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycoalescence.helper.update_parameter_names" title="Permalink to this definition">¶</a></dt>
<dd><p>Alters the parameters names of SIMULATION_PARAMETERS in the database so that it matches the
updated naming convention.</p>
<p>Provided for back-compatibility with older simulations.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>database</strong> &#8211; the database path to alter the names of</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">None</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">None</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-pycoalescence.hpc_setup">
<span id="hpc-setup-file"></span><h3><a class="toc-backref" href="#id9">hpc_setup file</a><a class="headerlink" href="#module-pycoalescence.hpc_setup" title="Permalink to this headline">¶</a></h3>
<p>Compile <strong>necsim</strong> with a number of intel compiler optimisations for running on high-performance computing systems.</p>
<dl class="function">
<dt id="pycoalescence.hpc_setup.build_hpc">
<code class="descname">build_hpc</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycoalescence/hpc_setup.html#build_hpc"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycoalescence.hpc_setup.build_hpc" title="Permalink to this definition">¶</a></dt>
<dd><p>Compiles NECSim with the <code class="docutils literal"><span class="pre">--with-hpc</span></code> and <code class="docutils literal"><span class="pre">--with-verbose</span></code> flags, which adds extra support for intel compilers
and provides a selection of optimisation flags for high-performance systems.
:return:</p>
</dd></dl>

</div>
<div class="section" id="module-pycoalescence.landscape">
<span id="landscape-file"></span><h3><a class="toc-backref" href="#id10">landscape file</a><a class="headerlink" href="#module-pycoalescence.landscape" title="Permalink to this headline">¶</a></h3>
<p>Generate landscapes and check map file combinations.</p>
<dl class="class">
<dt id="pycoalescence.landscape.Landscape">
<em class="property">class </em><code class="descname">Landscape</code><a class="reference internal" href="_modules/pycoalescence/landscape.html#Landscape"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycoalescence.landscape.Landscape" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates offsets and dimensions of a selection of tif files making up a landscape.</p>
<dl class="method">
<dt id="pycoalescence.landscape.Landscape.add_historical_map">
<code class="descname">add_historical_map</code><span class="sig-paren">(</span><em>fine_map</em>, <em>coarse_map</em>, <em>time</em>, <em>rate</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycoalescence/landscape.html#Landscape.add_historical_map"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycoalescence.landscape.Landscape.add_historical_map" title="Permalink to this definition">¶</a></dt>
<dd><p>Adds an extra map to the list of historical maps.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>fine_map</strong> &#8211; the historical fine map file to add</li>
<li><strong>coarse_map</strong> &#8211; the historical coarse map file to add</li>
<li><strong>time</strong> &#8211; the time to add (when the map is accurate)</li>
<li><strong>rate</strong> &#8211; the rate to add (the rate of habitat change at this time)</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pycoalescence.landscape.Landscape.check_maps">
<code class="descname">check_maps</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycoalescence/landscape.html#Landscape.check_maps"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycoalescence.landscape.Landscape.check_maps" title="Permalink to this definition">¶</a></dt>
<dd><p>Checks that the maps all exist and that the file structure makes sense.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first simple">
<li><strong>TypeError</strong> &#8211; if a dispersal map or reproduction map is specified, we must have a fine map specified, but
not a coarse map.</li>
<li><strong>IOError</strong> &#8211; if one of the required maps does not exist</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">None</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pycoalescence.landscape.Landscape.detect_map_dimensions">
<code class="descname">detect_map_dimensions</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycoalescence/landscape.html#Landscape.detect_map_dimensions"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycoalescence.landscape.Landscape.detect_map_dimensions" title="Permalink to this definition">¶</a></dt>
<dd><p>Detects all the map dimensions for the provided files (where possible) and sets the respective values.
This is intended to be run after set_map_files()</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first simple">
<li><strong>TypeError</strong> &#8211; if a dispersal map or reproduction map is specified, we must have a fine map specified, but
not a coarse map.</li>
<li><strong>IOError</strong> &#8211; if one of the required maps does not exist</li>
<li><strong>ValueError</strong> &#8211; if the dimensions of the dispersal map do not make sense when used with the fine map
provided</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">None</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pycoalescence.landscape.Landscape.set_map">
<code class="descname">set_map</code><span class="sig-paren">(</span><em>map_file</em>, <em>x_size=None</em>, <em>y_size=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycoalescence/landscape.html#Landscape.set_map"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycoalescence.landscape.Landscape.set_map" title="Permalink to this definition">¶</a></dt>
<dd><p>Quick function for setting a single map file for both the sample map and fine map, of dimensions x and y.
Sets the sample file to &#8220;null&#8221; and coarse file and historical files to &#8220;none&#8221;.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>map_file</strong> (<em>str</em>) &#8211; path to the map file</li>
<li><strong>x_size</strong> (<em>int</em>) &#8211; the x dimension, or None to detect automatically from the &#8221;.tif&#8221; file</li>
<li><strong>y_size</strong> (<em>int</em>) &#8211; the y dimension, or None to detect automatically from the &#8221;.tif&#8221; file</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pycoalescence.landscape.Landscape.set_map_files">
<code class="descname">set_map_files</code><span class="sig-paren">(</span><em>sample_file</em>, <em>fine_file=None</em>, <em>coarse_file=None</em>, <em>historical_fine_file=None</em>, <em>historical_coarse_file=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycoalescence/landscape.html#Landscape.set_map_files"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycoalescence.landscape.Landscape.set_map_files" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the map files (or to null, if none specified). It then calls detect_map_dimensions() to correctly read in
the specified dimensions.</p>
<p>If sample_file is &#8220;null&#8221;, dimension values will remain at 0.
If coarse_file is &#8220;null&#8221;, it will default to the size of fine_file with zero offset.
If the coarse file is &#8220;none&#8221;, it will not be used.
If the historical fine or coarse files are &#8220;none&#8221;, they will not be used.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>sample_file</strong> (<em>str</em>) &#8211; the sample map file. Provide &#8220;null&#8221; if on samplemask is required</li>
<li><strong>fine_file</strong> (<em>str</em>) &#8211; the fine map file. Defaults to &#8220;null&#8221; if none provided</li>
<li><strong>coarse_file</strong> (<em>str</em>) &#8211; the coarse map file. Defaults to &#8220;none&#8221; if none provided</li>
<li><strong>historical_fine_file</strong> (<em>str</em>) &#8211; the historical fine map file. Defaults to &#8220;none&#8221; if none provided</li>
<li><strong>historical_coarse_file</strong> (<em>str</em>) &#8211; the historical coarse map file. Defaults to &#8220;none&#8221; if none provided</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first">None</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">None</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pycoalescence.landscape.Landscape.set_map_parameters">
<code class="descname">set_map_parameters</code><span class="sig-paren">(</span><em>sample_file</em>, <em>sample_x</em>, <em>sample_y</em>, <em>fine_file</em>, <em>fine_x</em>, <em>fine_y</em>, <em>fine_x_offset</em>, <em>fine_y_offset</em>, <em>coarse_file</em>, <em>coarse_x</em>, <em>coarse_y</em>, <em>coarse_x_offset</em>, <em>coarse_y_offset</em>, <em>coarse_scale</em>, <em>historical_fine_map</em>, <em>historical_coarse_map</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycoalescence/landscape.html#Landscape.set_map_parameters"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycoalescence.landscape.Landscape.set_map_parameters" title="Permalink to this definition">¶</a></dt>
<dd><p>Set up the map objects with the required parameters. This is required for csv file usage.</p>
<p>Note that this function is not recommended for tif file usage, as it is much simpler to call set_map_files() and
which should automatically calculate map offsets, scaling and dimensions.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>sample_file</strong> &#8211; the sample file to use, which should contain a boolean mask of where to sample</li>
<li><strong>sample_x</strong> &#8211; the x dimension of the sample file</li>
<li><strong>sample_y</strong> &#8211; the y dimension of the sample file</li>
<li><strong>fine_file</strong> &#8211; the fine map file to use (must be equal to or larger than the sample file)</li>
<li><strong>fine_x</strong> &#8211; the x dimension of the fine map file</li>
<li><strong>fine_y</strong> &#8211; the y dimension of the fine map file</li>
<li><strong>fine_x_offset</strong> &#8211; the x offset of the fine map file</li>
<li><strong>fine_y_offset</strong> &#8211; the y offset of the fine map file</li>
<li><strong>coarse_file</strong> &#8211; the coarse map file to use (must be equal to or larger than fine map file)</li>
<li><strong>coarse_x</strong> &#8211; the x dimension of the coarse map file</li>
<li><strong>coarse_y</strong> &#8211; the y dimension of the coarse map file</li>
<li><strong>coarse_x_offset</strong> &#8211; the x offset of the coarse map file at the resolution of the fine map</li>
<li><strong>coarse_y_offset</strong> &#8211; the y offset of the coarse map file at the resoultion of the fine map</li>
<li><strong>coarse_scale</strong> &#8211; the relative scale of the coarse map compared to the fine map (must match x and y scaling)</li>
<li><strong>historical_fine_map</strong> &#8211; the historical fine map file to use (must have dimensions equal to fine map)</li>
<li><strong>historical_coarse_map</strong> &#8211; the historical coarse map file to use (must have dimensions equal to coarse map)</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pycoalescence.landscape.Landscape.sort_historical_maps">
<code class="descname">sort_historical_maps</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycoalescence/landscape.html#Landscape.sort_historical_maps"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycoalescence.landscape.Landscape.sort_historical_maps" title="Permalink to this definition">¶</a></dt>
<dd><p>Sorts the historical maps by time.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-pycoalescence.landscape_metrics">
<span id="landscape-metrics-file"></span><h3><a class="toc-backref" href="#id11">landscape_metrics file</a><a class="headerlink" href="#module-pycoalescence.landscape_metrics" title="Permalink to this headline">¶</a></h3>
<p>Calculates landscape-level metrics, including mean distance to nearest-neighbour for each habitat cell and clumpiness.</p>
<dl class="class">
<dt id="pycoalescence.landscape_metrics.LandscapeMetrics">
<em class="property">class </em><code class="descname">LandscapeMetrics</code><span class="sig-paren">(</span><em>file=None</em>, <em>logging_level=30</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycoalescence/landscape_metrics.html#LandscapeMetrics"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycoalescence.landscape_metrics.LandscapeMetrics" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pycoalescence.map.Map" title="pycoalescence.map.Map"><code class="xref py py-class docutils literal"><span class="pre">pycoalescence.map.Map</span></code></a></p>
<p>Calculates the mean nearest-neighbour for cells across a landscape. See <a class="reference internal" href="README_landscapes.html#landscape-metrics"><span class="std std-ref">here</span></a> for details.</p>
<dl class="method">
<dt id="pycoalescence.landscape_metrics.LandscapeMetrics.get_clumpiness">
<code class="descname">get_clumpiness</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycoalescence/landscape_metrics.html#LandscapeMetrics.get_clumpiness"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycoalescence.landscape_metrics.LandscapeMetrics.get_clumpiness" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the clumpiness metric for the landscape, a measure of how spread out the points are across the
landscape. See <a class="reference internal" href="README_landscapes.html#landscape-metrics-clumpy"><span class="std std-ref">here</span></a> for details.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">the CLUMPY metric</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">float</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pycoalescence.landscape_metrics.LandscapeMetrics.get_mnn">
<code class="descname">get_mnn</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycoalescence/landscape_metrics.html#LandscapeMetrics.get_mnn"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycoalescence.landscape_metrics.LandscapeMetrics.get_mnn" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the mean nearest-neighbour for cells across a landscape. See <a class="reference internal" href="README_landscapes.html#landscape-metrics-mnn"><span class="std std-ref">here</span></a> for
details.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">the mean distance to the nearest neighbour of a cell.</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">float</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-pycoalescence.map">
<span id="map-module"></span><h3><a class="toc-backref" href="#id12">map module</a><a class="headerlink" href="#module-pycoalescence.map" title="Permalink to this headline">¶</a></h3>
<p>Open tif files and detect properties and data using gdal. Detailed <a class="reference internal" href="README_landscapes.html#simulate-landscapes"><span class="std std-ref">here</span></a>.</p>
<dl class="class">
<dt id="pycoalescence.map.Map">
<em class="property">class </em><code class="descname">Map</code><span class="sig-paren">(</span><em>file=None</em>, <em>is_sample=None</em>, <em>logging_level=30</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycoalescence/map.html#Map"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycoalescence.map.Map" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">object</span></code></p>
<p>Contains the file name and the variables associated with this map object.</p>
<p>The internal array of the tif file is stored in self.data, and band 1 of the file can be opened by using
open()</p>
<div class="admonition important">
<p class="first admonition-title">Important</p>
<p class="last">Currently, Map does not support skewed rasters (not north/south).</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Variables:</th><td class="field-body"><strong>data</strong> &#8211; if the map file has been opened, contains the full tif data as a numpy array.</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="pycoalescence.map.Map.calculate_offset">
<code class="descname">calculate_offset</code><span class="sig-paren">(</span><em>file_offset</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycoalescence/map.html#Map.calculate_offset"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycoalescence.map.Map.calculate_offset" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the offset of the map object from the supplied file_offset.</p>
<p>The self map should be the smaller</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>file_offset</strong> (<em>str/Map</em>) &#8211; the path to the file to calculate the offset.
Can also be a Map object with the filename contained.</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><strong>TypeError</strong> &#8211; if the spatial reference systems of the two files do not match</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">the offset x and y (at the resolution of the file_home) in integers</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pycoalescence.map.Map.calculate_scale">
<code class="descname">calculate_scale</code><span class="sig-paren">(</span><em>file_scaled</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycoalescence/map.html#Map.calculate_scale"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycoalescence.map.Map.calculate_scale" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the scale of map object from the supplied file_scaled.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>file_scaled</strong> (<em>str/Map</em>) &#8211; the path to the file to calculate the scale.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">the scale (of the x dimension)</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pycoalescence.map.Map.check_map">
<code class="descname">check_map</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycoalescence/map.html#Map.check_map"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycoalescence.map.Map.check_map" title="Permalink to this definition">¶</a></dt>
<dd><p>Checks that the dimensions for the map have been set and that the map file exists</p>
</dd></dl>

<dl class="method">
<dt id="pycoalescence.map.Map.convert_lat_long">
<code class="descname">convert_lat_long</code><span class="sig-paren">(</span><em>lat</em>, <em>long</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycoalescence/map.html#Map.convert_lat_long"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycoalescence.map.Map.convert_lat_long" title="Permalink to this definition">¶</a></dt>
<dd><p>Converts the input latitude and longitude to x, y coordinates on the Map</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>lat</strong> &#8211; the latitude to obtain the y coordinate of</li>
<li><strong>long</strong> &#8211; the longitude to obtain the x coordinate of</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><p class="first"><strong>IndexError</strong> &#8211; if the provided coordinates are outside the Map object.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">[x, y] coordinates on the Map</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pycoalescence.map.Map.create">
<code class="descname">create</code><span class="sig-paren">(</span><em>file</em>, <em>bands=1</em>, <em>datatype=1</em>, <em>geotransform=None</em>, <em>projection=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycoalescence/map.html#Map.create"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycoalescence.map.Map.create" title="Permalink to this definition">¶</a></dt>
<dd><p>Create the file output and writes the data to the output.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>file</strong> (<em>str</em>) &#8211; the output file to create</li>
<li><strong>bands</strong> (<em>int</em>) &#8211; optionally provide a number of bands to create</li>
<li><strong>geotransform</strong> (<em>tuple</em>) &#8211; optionally provide a geotransform to set for the raster - defaults to (0, 1, 0, 0, 0, -1)</li>
<li><strong>projection</strong> (<em>string</em>) &#8211; optionally provide a projection to set for the raster, in WKT format</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pycoalescence.map.Map.create_copy">
<code class="descname">create_copy</code><span class="sig-paren">(</span><em>dst_file</em>, <em>src_file=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycoalescence/map.html#Map.create_copy"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycoalescence.map.Map.create_copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a file copying projection and other attributes over from the desired copy</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>dst_file</strong> &#8211; existing file to copy attributes from</li>
<li><strong>src_file</strong> &#8211; the output file to create</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pycoalescence.map.Map.get_cached_subset">
<code class="descname">get_cached_subset</code><span class="sig-paren">(</span><em>x_offset</em>, <em>y_offset</em>, <em>x_size</em>, <em>y_size</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycoalescence/map.html#Map.get_cached_subset"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycoalescence.map.Map.get_cached_subset" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets a subset of the map file, BUT rounds all numbers to integers to save RAM and keeps the entire array in
memory to speed up fetches.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>x_offset</strong> &#8211; the x offset from the top left corner of the map</li>
<li><strong>y_offset</strong> &#8211; the y offset from the top left corner of the map</li>
<li><strong>x_size</strong> &#8211; the x size of the subset to obtain</li>
<li><strong>y_size</strong> &#8211; the y size of the subset to obtain</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">a numpy array containing the subsetted data</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pycoalescence.map.Map.get_database">
<code class="descname">get_database</code><span class="sig-paren">(</span><em>file=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycoalescence/map.html#Map.get_database"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycoalescence.map.Map.get_database" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the dataset from the file.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>file</strong> &#8211; path to the file to open</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first simple">
<li><strong>ImportError</strong> &#8211; if the gdal module has not been imported correctly</li>
<li><strong>IOError</strong> &#8211; if the supplied filename is not a tif</li>
<li><strong>IOError</strong> &#8211; if the map does not exist</li>
</ul>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">an opened dataset object</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pycoalescence.map.Map.get_dimensions">
<code class="descname">get_dimensions</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycoalescence/map.html#Map.get_dimensions"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycoalescence.map.Map.get_dimensions" title="Permalink to this definition">¶</a></dt>
<dd><p>Calls read_dimensions() if dimensions have not been read, or reads stored information.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">a list containing [0] x, [1] y, [2] x offset, [3] y offset, [4] x resolution, [5] y resolution,
[6] upper left x, [7] upper left y</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pycoalescence.map.Map.get_dtype">
<code class="descname">get_dtype</code><span class="sig-paren">(</span><em>band_no=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycoalescence/map.html#Map.get_dtype"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycoalescence.map.Map.get_dtype" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the data type of the provided band number</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>band_no</strong> &#8211; band number to obtain the data type of</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">int</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">the gdal data type number in the raster file</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pycoalescence.map.Map.get_extent">
<code class="descname">get_extent</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycoalescence/map.html#Map.get_extent"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycoalescence.map.Map.get_extent" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the left and right x, and lower and upper y values.
:return: list of the left x, right x, upper y, lower y values.
:rtype: list</p>
</dd></dl>

<dl class="method">
<dt id="pycoalescence.map.Map.get_geo_transform">
<code class="descname">get_geo_transform</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycoalescence/map.html#Map.get_geo_transform"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycoalescence.map.Map.get_geo_transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the geotransform of the file.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">list containing the geotransform parameters</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pycoalescence.map.Map.get_no_data">
<code class="descname">get_no_data</code><span class="sig-paren">(</span><em>band_no=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycoalescence/map.html#Map.get_no_data"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycoalescence.map.Map.get_no_data" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the no data value for the tif map.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>band_no</strong> &#8211; the band number to obtain the no data value from</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">the no data value</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">float</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pycoalescence.map.Map.get_projection">
<code class="descname">get_projection</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycoalescence/map.html#Map.get_projection"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycoalescence.map.Map.get_projection" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the projection of the map.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">the projection object of the map in WKT format</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">str</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pycoalescence.map.Map.get_subset">
<code class="descname">get_subset</code><span class="sig-paren">(</span><em>x_offset</em>, <em>y_offset</em>, <em>x_size</em>, <em>y_size</em>, <em>no_data_value=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycoalescence/map.html#Map.get_subset"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycoalescence.map.Map.get_subset" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets a subset of the map file</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>x_offset</strong> &#8211; the x offset from the top left corner of the map</li>
<li><strong>y_offset</strong> &#8211; the y offset from the top left corner of the map</li>
<li><strong>x_size</strong> &#8211; the x size of the subset to obtain</li>
<li><strong>y_size</strong> &#8211; the y size of the subset to obtain</li>
<li><strong>no_data_value</strong> &#8211; optionally provide a value to replace all no data values with.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">a numpy array containing the subsetted data</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pycoalescence.map.Map.get_x_y">
<code class="descname">get_x_y</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycoalescence/map.html#Map.get_x_y"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycoalescence.map.Map.get_x_y" title="Permalink to this definition">¶</a></dt>
<dd><p>Simply returns the x and y dimension of the file.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">the x and y dimensions</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pycoalescence.map.Map.has_equal_dimensions">
<code class="descname">has_equal_dimensions</code><span class="sig-paren">(</span><em>map</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycoalescence/map.html#Map.has_equal_dimensions"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycoalescence.map.Map.has_equal_dimensions" title="Permalink to this definition">¶</a></dt>
<dd><p>Checks if the supplied Map has equal dimensions to this Map.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Dimension matching uses an absolute value (0.0001) for latitude/longitude, and relative value for
pixel resolution. The map sizes must fit perfectly.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>map</strong> (<a class="reference internal" href="#pycoalescence.map.Map" title="pycoalescence.map.Map"><em>Map</em></a>) &#8211; the Map object to check if dimensions match</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">true if the dimensions match, false otherwise</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">bool</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pycoalescence.map.Map.is_within">
<code class="descname">is_within</code><span class="sig-paren">(</span><em>map</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycoalescence/map.html#Map.is_within"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycoalescence.map.Map.is_within" title="Permalink to this definition">¶</a></dt>
<dd><p>Checks if the object is within the provided Map object.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Uses the extents of the raster file for checking location, ignoring any offsetting</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>map</strong> (<a class="reference internal" href="#pycoalescence.map.Map" title="pycoalescence.map.Map"><em>Map</em></a>) &#8211; the Map object to check if this class is within</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">true if this Map is entirely within the supplied Map</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">bool</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pycoalescence.map.Map.map_exists">
<code class="descname">map_exists</code><span class="sig-paren">(</span><em>file=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycoalescence/map.html#Map.map_exists"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycoalescence.map.Map.map_exists" title="Permalink to this definition">¶</a></dt>
<dd><p>Checks if the output (or provided file) exists.</p>
<p>If file is provided, self.file_name is set to file.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>file</strong> &#8211; optionally, the file to check exists</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">true if the output file does exist</td>
</tr>
<tr class="field-odd field"><th class="field-name">Rtype bool:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pycoalescence.map.Map.open">
<code class="descname">open</code><span class="sig-paren">(</span><em>file=None</em>, <em>band_no=1</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycoalescence/map.html#Map.open"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycoalescence.map.Map.open" title="Permalink to this definition">¶</a></dt>
<dd><p>Reads the raster file from memory into the data object.
This allows direct access to the internal numpy array using the data object.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>file</strong> (<em>str</em>) &#8211; path to file to open (or None to use self.file_name</li>
<li><strong>band_no</strong> (<em>int</em>) &#8211; the band number to read from</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">None</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pycoalescence.map.Map.rasterise">
<code class="descname">rasterise</code><span class="sig-paren">(</span><em>shape_file, raster_file=None, x_res=None, y_res=None, output_srs=None, geo_transform=None, field=None, burn_val=[1], data_type=6, attribute_filter=None, x_buffer=1, y_buffer=1, **kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycoalescence/map.html#Map.rasterise"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycoalescence.map.Map.rasterise" title="Permalink to this definition">¶</a></dt>
<dd><p>Rasterises the provided shape file to produce the output raster.</p>
<p>If x_res or y_res are not provided, self.x_res and self.y_res will be used.</p>
<p>If a field is provided, the value in that field will become the value in the raster.</p>
<p>If a geo_transform is provided, it overrides the x_res, y_res, x_buffer and y_buffer.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>shape_file</strong> &#8211; path to the .shp vector file to rasterise, or an ogr.DataSource object contain the shape file</li>
<li><strong>raster_file</strong> &#8211; path to the output raster file (should not already exist)</li>
<li><strong>x_res</strong> &#8211; the x resolution of the output raster</li>
<li><strong>y_res</strong> &#8211; the y resolution of the output raster</li>
<li><strong>output_srs</strong> &#8211; optionally define the output projection of the raster file</li>
<li><strong>geo_transform</strong> &#8211; optionally define the geotransform of the raster file (cannot use resolution or buffer
arguments with this option)</li>
<li><strong>field</strong> &#8211; the field to set as raster values</li>
<li><strong>burn_val</strong> &#8211; the r,g,b value to use if there is no field for the location</li>
<li><strong>data_type</strong> &#8211; the gdal type for output data</li>
<li><strong>attribute_filter</strong> &#8211; optionally provide a filter to extract features by, of the form &#8220;field=fieldval&#8221;</li>
<li><strong>x_buffer</strong> &#8211; number of extra pixels to include at left and right sides</li>
<li><strong>y_buffer</strong> &#8211; number of extra pixels to include at top and bottom</li>
<li><strong>kwargs</strong> &#8211; additional options to provide to gdal.RasterizeLayer</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first simple">
<li><strong>IOError</strong> &#8211; if the shape file does not exist</li>
<li><strong>IOError</strong> &#8211; if the output raster already exists</li>
<li><strong>ValueError</strong> &#8211; if the provided shape_file is not a .shp file</li>
<li><strong>RuntimeError</strong> &#8211; if gdal throws an error during rasterisation</li>
</ul>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">None</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pycoalescence.map.Map.read_dimensions">
<code class="descname">read_dimensions</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycoalescence/map.html#Map.read_dimensions"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycoalescence.map.Map.read_dimensions" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a list containing the geospatial coordinate system for the file.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">a list containing [0] x, [1] y, [2] upper left x, [3] upper left y, [4] x resolution, [5] y resolution</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pycoalescence.map.Map.reproject_raster">
<code class="descname">reproject_raster</code><span class="sig-paren">(</span><em>dest_projection=None</em>, <em>source_file=None</em>, <em>dest_file=None</em>, <em>x_scalar=1.0</em>, <em>y_scalar=1.0</em>, <em>resample_algorithm=0</em>, <em>warp_memory_limit=0.0</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycoalescence/map.html#Map.reproject_raster"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycoalescence.map.Map.reproject_raster" title="Permalink to this definition">¶</a></dt>
<dd><p>Re-writes the file with a new projection.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Writes to an in-memory file (filename_tmp.tif) which then overwrites the original file, unless
dest_file is not None</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>source_projection</strong> &#8211; provide a source projection to reproject from</li>
<li><strong>dest_projection</strong> &#8211; the destination file projection, can only be None if rescaling</li>
<li><strong>source_file</strong> &#8211; optionally provide a file name to reproject. Defaults to self.file_name</li>
<li><strong>dest_file</strong> &#8211; the destination file to output to (if None, overwrites original file)</li>
<li><strong>x_scalar</strong> &#8211; multiplier to change the x resolution by, defaults to 1</li>
<li><strong>y_scalar</strong> &#8211; multiplier to change the y resolution by, defaults to 1</li>
<li><strong>resample_algorithm</strong> &#8211; should be one of the gdal.GRA algorithms</li>
<li><strong>warp_memory_limit</strong> &#8211; optionally provide a memory cache limit (uses default if 0.0)</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pycoalescence.map.Map.set_dimensions">
<code class="descname">set_dimensions</code><span class="sig-paren">(</span><em>file_name=None</em>, <em>x_size=None</em>, <em>y_size=None</em>, <em>x_offset=None</em>, <em>y_offset=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycoalescence/map.html#Map.set_dimensions"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycoalescence.map.Map.set_dimensions" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the dimensions and file for the Map object</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>file_name</strong> (<em>str</em>) &#8211; the location of the map object (a csv or tif file). If None, required that file_name is already provided.</li>
<li><strong>x_size</strong> (<em>int</em>) &#8211; the x dimension</li>
<li><strong>y_size</strong> (<em>int</em>) &#8211; the y dimension</li>
<li><strong>x_offset</strong> (<em>int</em>) &#8211; the x offset from the north-west corner</li>
<li><strong>y_offset</strong> (<em>int</em>) &#8211; the y offset from the north-west corner</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">None</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pycoalescence.map.Map.set_sample">
<code class="descname">set_sample</code><span class="sig-paren">(</span><em>is_sample</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycoalescence/map.html#Map.set_sample"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycoalescence.map.Map.set_sample" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the is_sample attribute to true if this is a sample mask rather than an offset map</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>is_sample</strong> (<em>bool</em>) &#8211; indicates this is a sample mask rather than offset map</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pycoalescence.map.Map.write">
<code class="descname">write</code><span class="sig-paren">(</span><em>file=None</em>, <em>band_no=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycoalescence/map.html#Map.write"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycoalescence.map.Map.write" title="Permalink to this definition">¶</a></dt>
<dd><p>Writes the array in self.data to the output array.
The output file must exist, and the array will be overridden in the band.
Intended for writing changes to the same file the data was read from.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>file</strong> &#8211; the path to the file to write to</li>
<li><strong>band_no</strong> &#8211; the band number to write into</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>:rtype None</p>
</dd></dl>

<dl class="method">
<dt id="pycoalescence.map.Map.zero_offsets">
<code class="descname">zero_offsets</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycoalescence/map.html#Map.zero_offsets"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycoalescence.map.Map.zero_offsets" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the x and y offsets to 0</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-pycoalescence.merger">
<span id="merger-module"></span><h3><a class="toc-backref" href="#id13">merger module</a><a class="headerlink" href="#module-pycoalescence.merger" title="Permalink to this headline">¶</a></h3>
<p>Combine simulation outputs from separate guilds. Detailed <a class="reference internal" href="README_merger.html#merging-simulations"><span class="std std-ref">here</span></a>.</p>
<p><a class="reference internal" href="#pycoalescence.merger.Merger" title="pycoalescence.merger.Merger"><code class="xref py py-class docutils literal"><span class="pre">Merger</span></code></a> will output a single database file, merging the various biodiversity tables into one.</p>
<p>Metrics are also calculated for the entire system, with a guild reference of 0.</p>
<p>All standard routines provided in <code class="xref py py-class docutils literal"><span class="pre">CoalescenceTree</span></code> can then be performed on the
combined database.</p>
<dl class="class">
<dt id="pycoalescence.merger.Merger">
<em class="property">class </em><code class="descname">Merger</code><span class="sig-paren">(</span><em>database=None</em>, <em>logging_level=30</em>, <em>log_output=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycoalescence/merger.html#Merger"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycoalescence.merger.Merger" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pycoalescence.coalescence_tree.CoalescenceTree" title="pycoalescence.coalescence_tree.CoalescenceTree"><code class="xref py py-class docutils literal"><span class="pre">pycoalescence.coalescence_tree.CoalescenceTree</span></code></a></p>
<p>Merges simulation outputs into a single database. Inherits from
<code class="xref py py-class docutils literal"><span class="pre">CoalescenceTree</span></code> to provide all routines in the same object.</p>
<dl class="method">
<dt id="pycoalescence.merger.Merger.add_simulation">
<code class="descname">add_simulation</code><span class="sig-paren">(</span><em>input_simulation</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycoalescence/merger.html#Merger.add_simulation"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycoalescence.merger.Merger.add_simulation" title="Permalink to this definition">¶</a></dt>
<dd><p>Adds a simulation to the list of merged simulations.</p>
<p>This also calls the relevant merges for the tables that exist in the provided database.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>input_simulation</strong> &#8211; either the path to the input simulation, a Coalescence class object, or a CoalescenceTree object
which contains the completed simulation.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">None</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">None</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pycoalescence.merger.Merger.add_simulations">
<code class="descname">add_simulations</code><span class="sig-paren">(</span><em>simulation_list</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycoalescence/merger.html#Merger.add_simulations"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycoalescence.merger.Merger.add_simulations" title="Permalink to this definition">¶</a></dt>
<dd><p>A convenience function that adds each simulation from the list of simulations provided and then writes to the
database.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>simulation_list</strong> &#8211; list of paths to completed simulations</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pycoalescence.merger.Merger.set_database">
<code class="descname">set_database</code><span class="sig-paren">(</span><em>filename</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycoalescence/merger.html#Merger.set_database"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycoalescence.merger.Merger.set_database" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the output database for the merged simulations</p>
<p>Assumes no database currently exists, and will create one.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><strong>IOError</strong> &#8211; if the output database already exists</td>
</tr>
<tr class="field-even field"><th class="field-name">Parameters:</th><td class="field-body"><strong>filename</strong> &#8211; the filename to output merged simulations into</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">None</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pycoalescence.merger.Merger.write">
<code class="descname">write</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycoalescence/merger.html#Merger.write"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycoalescence.merger.Merger.write" title="Permalink to this definition">¶</a></dt>
<dd><p>Writes out all stored simulation parameters to the output database and wipes the in-memory objects.</p>
<p>This should be called after all simulation have been added, or when RAM usage gets too large for large
simulations</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-pycoalescence.patched_landscape">
<span id="patched-landscape-module"></span><h3><a class="toc-backref" href="#id14">patched_landscape module</a><a class="headerlink" href="#module-pycoalescence.patched_landscape" title="Permalink to this headline">¶</a></h3>
<p>Generate landscapes of interconnected patches for simulating within a spatially-explicit neutral model.
Detailed <a class="reference internal" href="README_landscapes.html#generate-landscapes"><span class="std std-ref">here</span></a>.</p>
<p>Dispersal probabilities are defined between different patches, and each patch will be contain n individuals.</p>
<dl class="class">
<dt id="pycoalescence.patched_landscape.Patch">
<em class="property">class </em><code class="descname">Patch</code><span class="sig-paren">(</span><em>id</em>, <em>density</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycoalescence/patched_landscape.html#Patch"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycoalescence.patched_landscape.Patch" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">object</span></code></p>
<p>Contains a single patch, to which the probability of dispersal to every other patch can be added.</p>
<dl class="method">
<dt id="pycoalescence.patched_landscape.Patch.add_patch">
<code class="descname">add_patch</code><span class="sig-paren">(</span><em>patch</em>, <em>probability</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycoalescence/patched_landscape.html#Patch.add_patch"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycoalescence.patched_landscape.Patch.add_patch" title="Permalink to this definition">¶</a></dt>
<dd><p>Adds dispersal from this patch to another patch object with a set probability. The patch should not already
have been added.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The probabilities can be relative, as they can be re-scaled to sum to 1 using
<a class="reference internal" href="#pycoalescence.patched_landscape.Patch.re_scale_probabilities" title="pycoalescence.patched_landscape.Patch.re_scale_probabilities"><code class="xref py py-func docutils literal"><span class="pre">re_scale_probabilities()</span></code></a>.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first simple">
<li><strong>KeyError</strong> &#8211; if the patch already exists in the dispersal probabilities.</li>
<li><strong>ValueError</strong> &#8211; if the dispersal probability is less than 0.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>patch</strong> &#8211; the patch id to disperse to</li>
<li><strong>probability</strong> &#8211; the probability of dispersal</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pycoalescence.patched_landscape.Patch.re_scale_probabilities">
<code class="descname">re_scale_probabilities</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycoalescence/patched_landscape.html#Patch.re_scale_probabilities"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycoalescence.patched_landscape.Patch.re_scale_probabilities" title="Permalink to this definition">¶</a></dt>
<dd><p>Re-scales the probabilities so that they sum to 1. Also checks to make sure dispersal from within this patch
is defined.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><strong>ValueError</strong> &#8211; if the self dispersal probability has not been defined, or the dispersal probabilities do
not sum to &gt; 0.</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pycoalescence.patched_landscape.PatchedLandscape">
<em class="property">class </em><code class="descname">PatchedLandscape</code><span class="sig-paren">(</span><em>output_fine_map</em>, <em>output_dispersal_map</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycoalescence/patched_landscape.html#PatchedLandscape"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycoalescence.patched_landscape.PatchedLandscape" title="Permalink to this definition">¶</a></dt>
<dd><p>Landscape made up of a list of patches with dispersal probabilities to each other.</p>
<dl class="method">
<dt id="pycoalescence.patched_landscape.PatchedLandscape.add_dispersal">
<code class="descname">add_dispersal</code><span class="sig-paren">(</span><em>source_patch</em>, <em>target_patch</em>, <em>dispersal_probability</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycoalescence/patched_landscape.html#PatchedLandscape.add_dispersal"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycoalescence.patched_landscape.PatchedLandscape.add_dispersal" title="Permalink to this definition">¶</a></dt>
<dd><p>Adds a dispersal probability from the source patch to the target patch.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Both the source and target patch should already have been added using <a class="reference internal" href="#pycoalescence.patched_landscape.PatchedLandscape.add_patch" title="pycoalescence.patched_landscape.PatchedLandscape.add_patch"><code class="xref py py-func docutils literal"><span class="pre">add_patch()</span></code></a>.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>source_patch</strong> &#8211; the id of the source patch</li>
<li><strong>target_patch</strong> &#8211; the id of the target patch</li>
<li><strong>dispersal_probability</strong> &#8211; the probability of dispersal from source to target</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pycoalescence.patched_landscape.PatchedLandscape.add_patch">
<code class="descname">add_patch</code><span class="sig-paren">(</span><em>id</em>, <em>density</em>, <em>self_dispersal</em>, <em>dispersal_probabilities=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycoalescence/patched_landscape.html#PatchedLandscape.add_patch"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycoalescence.patched_landscape.PatchedLandscape.add_patch" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a patch with the given parameters.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>id</strong> &#8211; the unique reference for the patch</li>
<li><strong>density</strong> &#8211; the number of individuals that exist in the patch</li>
<li><strong>self_dispersal</strong> &#8211; the relative probability of dispersal from within the same patch</li>
<li><strong>dispersal_probabilities</strong> &#8211; dictionary containing all other patches and their relative dispersal
probabilities</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pycoalescence.patched_landscape.PatchedLandscape.generate_files">
<code class="descname">generate_files</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycoalescence/patched_landscape.html#PatchedLandscape.generate_files"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycoalescence.patched_landscape.PatchedLandscape.generate_files" title="Permalink to this definition">¶</a></dt>
<dd><p>Re-scales the dispersal probabilities and generates the patches landscape files. These include the fine map file
containing the densities and the dispersal probability map.</p>
<p>The fine map file will be dimensions 1xN where N is the number of patches in the landscape.
The dispersal probability map will be dimensions NxN, where dispersal occurs from the y index cell to the x
index cell. Dispersal probabilities are stored as cumulative probabilities.</p>
</dd></dl>

<dl class="method">
<dt id="pycoalescence.patched_landscape.PatchedLandscape.generate_from_matrix">
<code class="descname">generate_from_matrix</code><span class="sig-paren">(</span><em>density_matrix</em>, <em>dispersal_matrix</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycoalescence/patched_landscape.html#PatchedLandscape.generate_from_matrix"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycoalescence.patched_landscape.PatchedLandscape.generate_from_matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Generates the patched landscape from the input matrix and writes out to the files.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Uses a slightly inefficient method of generating the full patched landscape, and then writing back out
to the map files so that full error-checking is included. A more efficient implementation is possible
by simply writing the matrix to file using the <a class="reference internal" href="#pycoalescence.map.Map" title="pycoalescence.map.Map"><code class="xref py py-class docutils literal"><span class="pre">Map</span> <span class="pre">class</span></code></a>.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The generated density map will have dimensions 1 by xy (where x, y are the dimensions of the original
density matrix. However, the dispersal matrix should still be compatible with the original density
matrix as a x by y tif file.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>density_matrix</strong> &#8211; a numpy matrix containing the density probabilities</li>
<li><strong>dispersal_matrix</strong> &#8211; a numpy matrix containing the dispersal probabilities</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pycoalescence.patched_landscape.PatchedLandscape.has_patch">
<code class="descname">has_patch</code><span class="sig-paren">(</span><em>id</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycoalescence/patched_landscape.html#PatchedLandscape.has_patch"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycoalescence.patched_landscape.PatchedLandscape.has_patch" title="Permalink to this definition">¶</a></dt>
<dd><p>Checks if the patches object already contains a patch with the provided id.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>id</strong> &#8211; id to check for in patches</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">true if the patch already exists</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="pycoalescence.patched_landscape.convert_index_to_x_y">
<code class="descname">convert_index_to_x_y</code><span class="sig-paren">(</span><em>index</em>, <em>dim</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycoalescence/patched_landscape.html#convert_index_to_x_y"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycoalescence.patched_landscape.convert_index_to_x_y" title="Permalink to this definition">¶</a></dt>
<dd><p>Converts an index to an x, y coordinate.</p>
<p>Used when mapping from 1-D space to 2-D space.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>index</strong> &#8211; the index to convert from</li>
<li><strong>dim</strong> &#8211; the x dimension of the matrix</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-pycoalescence.setup">
<span id="setup-file"></span><h3><a class="toc-backref" href="#id15">setup file</a><a class="headerlink" href="#module-pycoalescence.setup" title="Permalink to this headline">¶</a></h3>
<p>Compile <strong>necsim</strong> with default or provided compilation options. It is required that this file is run (or the library
compiled manually) before using <strong>pycoalescence</strong>.</p>
<p>Running this file from the command line with <code class="docutils literal"><span class="pre">python</span> <span class="pre">setup.py</span></code> configures the install by detecting system components
and compiles the <code class="docutils literal"><span class="pre">c++</span></code> files, if possible. Command line flags can be provided to setup.py to modify the install
(see <a class="reference internal" href="README_pycoalescence.html#sec-compilation-options"><span class="std std-ref">Compilation Options</span></a> for more information).</p>
<dl class="function">
<dt id="pycoalescence.setup.autoconf">
<code class="descname">autoconf</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycoalescence/setup.html#autoconf"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycoalescence.setup.autoconf" title="Permalink to this definition">¶</a></dt>
<dd><p>Runs the <cite>autoconf</cite> bash function (assuming that autoconf is available) to create the <cite>configure</cite> executable.</p>
</dd></dl>

<dl class="function">
<dt id="pycoalescence.setup.backup_makefile">
<code class="descname">backup_makefile</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycoalescence/setup.html#backup_makefile"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycoalescence.setup.backup_makefile" title="Permalink to this definition">¶</a></dt>
<dd><p>Copies the makefile to a saved folder so that even if the original is overwritten, the last successful
compilation can be recorded.</p>
</dd></dl>

<dl class="function">
<dt id="pycoalescence.setup.clean">
<code class="descname">clean</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycoalescence/setup.html#clean"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycoalescence.setup.clean" title="Permalink to this definition">¶</a></dt>
<dd><p>Runs make clean in the NECSim directory to wipe any previous potential compile attempts.</p>
</dd></dl>

<dl class="function">
<dt id="pycoalescence.setup.configure">
<code class="descname">configure</code><span class="sig-paren">(</span><em>opts=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycoalescence/setup.html#configure"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycoalescence.setup.configure" title="Permalink to this definition">¶</a></dt>
<dd><p>Runs ./configure &#8211;opts with the supplied options. This should create the makefile for compilation, otherwise a
RuntimeError will be thrown.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>opts</strong> &#8211; a list of options to pass to the ./configure call</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pycoalescence.setup.configure_and_compile">
<code class="descname">configure_and_compile</code><span class="sig-paren">(</span><em>argv=[None], logging_level=20</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycoalescence/setup.html#configure_and_compile"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycoalescence.setup.configure_and_compile" title="Permalink to this definition">¶</a></dt>
<dd><p>Calls the configure script, then runs the compilation.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>argv</strong> &#8211; the arguments to pass to configure script</li>
<li><strong>logging_level</strong> &#8211; the logging level to utilise (defaults to INFO).</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">None</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pycoalescence.setup.copy_makefile">
<code class="descname">copy_makefile</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycoalescence/setup.html#copy_makefile"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycoalescence.setup.copy_makefile" title="Permalink to this definition">¶</a></dt>
<dd><p>Copies the backup makefile to the main directory, if it exists.
Throws an IOError if no makefile is found.</p>
</dd></dl>

<dl class="function">
<dt id="pycoalescence.setup.create_default_depend">
<code class="descname">create_default_depend</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycoalescence/setup.html#create_default_depend"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycoalescence.setup.create_default_depend" title="Permalink to this definition">¶</a></dt>
<dd><p>Runs the default makedepend command, outputting dependencies to lib/depends_default.</p>
<p>Used to generate a default dependency file on a system where makedepend exists, for a system where it does not.</p>
</dd></dl>

<dl class="function">
<dt id="pycoalescence.setup.do_compile">
<code class="descname">do_compile</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycoalescence/setup.html#do_compile"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycoalescence.setup.do_compile" title="Permalink to this definition">¶</a></dt>
<dd><p>Compiles the c++ necsim program by running make. This changes the working directory to wherever the module has been
installed for the subprocess call.</p>
</dd></dl>

<dl class="function">
<dt id="pycoalescence.setup.get_build_dir">
<code class="descname">get_build_dir</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycoalescence/setup.html#get_build_dir"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycoalescence.setup.get_build_dir" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the build directory for this python version.
:return: the build directory path for the current python interpreter</p>
</dd></dl>

<dl class="function">
<dt id="pycoalescence.setup.get_compilation_flags">
<code class="descname">get_compilation_flags</code><span class="sig-paren">(</span><em>display_warnings=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycoalescence/setup.html#get_compilation_flags"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycoalescence.setup.get_compilation_flags" title="Permalink to this definition">¶</a></dt>
<dd><p>Generates the compilation flags for passing to ./configure.
:param display_warnings: If true, runs with the -Wall flag for compilation (displaying all warnings). Default is False.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">list of compilation flags.</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">list</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pycoalescence.setup.make_depend">
<code class="descname">make_depend</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycoalescence/setup.html#make_depend"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycoalescence.setup.make_depend" title="Permalink to this definition">¶</a></dt>
<dd><p>Runs make depend in the lib directory to calculate all dependencies for the header and source files.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Fails silently if makedepend is not installed, printing an error to logging.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="pycoalescence.setup.move_executable">
<code class="descname">move_executable</code><span class="sig-paren">(</span><em>directory='/Users/samthompson/Documents/PhD/Code/pycoalescence/pycoalescence/build/default/'</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycoalescence/setup.html#move_executable"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycoalescence.setup.move_executable" title="Permalink to this definition">¶</a></dt>
<dd><p>Moves the executable to the specified directory from within NECSim. Will always look for NECSim relative to the
setup.py (so can be called from another module location).
This allows for multiple compilation options with different versions stored in different folders.</p>
<p>Throws an IOError when the NECSim executable is not found.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>directory</strong> &#8211; the directory to move the NECSim excecutable to.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pycoalescence.setup.move_shared_object_file">
<code class="descname">move_shared_object_file</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycoalescence/setup.html#move_shared_object_file"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycoalescence.setup.move_shared_object_file" title="Permalink to this definition">¶</a></dt>
<dd><p>Moves the shared object (.so) file to the build directory.
:return:</p>
</dd></dl>

<dl class="function">
<dt id="pycoalescence.setup.run_configure">
<code class="descname">run_configure</code><span class="sig-paren">(</span><em>argv=[None], logging_level=20, display_warnings=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycoalescence/setup.html#run_configure"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycoalescence.setup.run_configure" title="Permalink to this definition">¶</a></dt>
<dd><p>Configures the install for compile options provided via the command line, or with default options if no options exist.
Running with <code class="docutils literal"><span class="pre">-help</span></code> or <cite>-h</cite> will display the compilation configurations called from <code class="docutils literal"><span class="pre">./configure</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>argv</strong> &#8211; the arguments to pass to configure script</li>
<li><strong>logging_level</strong> &#8211; the logging level to utilise (defaults to INFO).</li>
<li><strong>display_warnings</strong> &#8211; If true, runs with the -Wall flag for compilation (displaying all warnings). Default is False.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pycoalescence.setup.use_default_depends">
<code class="descname">use_default_depends</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycoalescence/setup.html#use_default_depends"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycoalescence.setup.use_default_depends" title="Permalink to this definition">¶</a></dt>
<dd><p>Uses the default dependencies, copying all contents of depends_default to the end of Makefile.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Zero error-checking is done here as the Makefiles should not change, and the depends_default file should
be created using create_default_depend()</p>
</div>
</dd></dl>

</div>
<div class="section" id="module-pycoalescence.spatial_algorithms">
<span id="spatial-algorithms-file"></span><h3><a class="toc-backref" href="#id16">spatial_algorithms file</a><a class="headerlink" href="#module-pycoalescence.spatial_algorithms" title="Permalink to this headline">¶</a></h3>
<p>Simple spatial algorithms required for package functionality.</p>
<p>Algorithms include generation of Voronoi diagrams and spacing points on a landscape using Lloyd&#8217;s algorithm.</p>
<dl class="function">
<dt id="pycoalescence.spatial_algorithms.archimedes_spiral">
<code class="descname">archimedes_spiral</code><span class="sig-paren">(</span><em>centre_x</em>, <em>centre_y</em>, <em>radius</em>, <em>theta</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycoalescence/spatial_algorithms.html#archimedes_spiral"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycoalescence.spatial_algorithms.archimedes_spiral" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the x, y coordinates on a spiral, given a radius and theta</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>centre_x</strong> (<em>int</em>) &#8211; the x coordinate of the centre of the spiral</li>
<li><strong>centre_y</strong> (<em>int</em>) &#8211; the y coordinate of the centre of the spiral</li>
<li><strong>radius</strong> (<em>float</em>) &#8211; the distance from the centre of the spiral</li>
<li><strong>theta</strong> (<em>float</em>) &#8211; the angle of rotation</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">tuple of x and y coordinates</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">tuple</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pycoalescence.spatial_algorithms.calculate_centre_of_mass">
<code class="descname">calculate_centre_of_mass</code><span class="sig-paren">(</span><em>points_list</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycoalescence/spatial_algorithms.html#calculate_centre_of_mass"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycoalescence.spatial_algorithms.calculate_centre_of_mass" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the centre of mass for the non-intersecting polygon defined by points_list.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">the centre of mass will be incorrect for intersecting polygons.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">it is assumed that points_list defines, in order, the vertices of the polygon. The last
point is assumed to connect to the first point.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>points_list</strong> &#8211; a list of x, y points defining the non-intersecting polygon</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">the x,y centre of mass</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pycoalescence.spatial_algorithms.calculate_distance_between">
<code class="descname">calculate_distance_between</code><span class="sig-paren">(</span><em>x1</em>, <em>y1</em>, <em>x2</em>, <em>y2</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycoalescence/spatial_algorithms.html#calculate_distance_between"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycoalescence.spatial_algorithms.calculate_distance_between" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the distance between the points (x1, y1) and (x2, y2)</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Returns the absolute value</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>x1</strong> &#8211; x coordinate of the first point</li>
<li><strong>y1</strong> &#8211; y coordinate of the first point</li>
<li><strong>x2</strong> &#8211; x coordinate of the second point</li>
<li><strong>y2</strong> &#8211; y coordinate of the second point</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">the absolute distance between the points</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pycoalescence.spatial_algorithms.convert_coordinates">
<code class="descname">convert_coordinates</code><span class="sig-paren">(</span><em>x</em>, <em>y</em>, <em>input_srs</em>, <em>output_srs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycoalescence/spatial_algorithms.html#convert_coordinates"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycoalescence.spatial_algorithms.convert_coordinates" title="Permalink to this definition">¶</a></dt>
<dd><p>Converts the coordinates from the input srs to the output srs.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>x</strong> &#8211; the x coordinate to transform</li>
<li><strong>y</strong> &#8211; the y coordinate to transform</li>
<li><strong>input_srs</strong> &#8211; the input srs to transform from</li>
<li><strong>output_srs</strong> &#8211; the output srs to transform to</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first">list</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">transformed [x, y] coordinates</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pycoalescence.spatial_algorithms.estimate_sigma_from_distance">
<code class="descname">estimate_sigma_from_distance</code><span class="sig-paren">(</span><em>distance</em>, <em>n</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycoalescence/spatial_algorithms.html#estimate_sigma_from_distance"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycoalescence.spatial_algorithms.estimate_sigma_from_distance" title="Permalink to this definition">¶</a></dt>
<dd><p>Estimates the sigma value from a rayleigh distribution (2-d normal) from a total distance travelled in n steps.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>distance</strong> (<em>float</em>) &#8211; the total distance travelled</li>
<li><strong>n</strong> (<em>int</em>) &#8211; the number of steps</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">an estimation of the sigma value required to generate the distance travelled in n steps</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pycoalescence.spatial_algorithms.lloyds_algorithm">
<code class="descname">lloyds_algorithm</code><span class="sig-paren">(</span><em>points_list</em>, <em>maxima</em>, <em>n=7</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycoalescence/spatial_algorithms.html#lloyds_algorithm"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycoalescence.spatial_algorithms.lloyds_algorithm" title="Permalink to this definition">¶</a></dt>
<dd><p>Equally spaces the points in the given landscape defined by (0, x_max), (0, y_max) using Lloyd&#8217;s algorithm.</p>
<p>Algorthim is:</p>
<ul class="simple">
<li>Reflect the points at x=0, x=x_max, y=0 and y=y_max to make boundaries of the Voronoi diagram on the original</li>
</ul>
<blockquote>
<div>set of points have finite edges</div></blockquote>
<ul class="simple">
<li>Define the Voronoi diagram separating the points</li>
<li>Find the centres of the regions of the voronoi diagram for our original set of points</li>
<li>Move the our points to the centres of their voronoi regions</li>
<li>Repeat n times (for convergence)</li>
<li>Edits the points_list to contain the equally-spaced points</li>
</ul>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">all points are assumed to be in the range x in (0, x_max) and y in (0, y_max)</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>points_list</strong> &#8211; a list of points to be equally spaced in the landscape</li>
<li><strong>maxima</strong> &#8211; the maximum size of the landscape to space out within</li>
<li><strong>n</strong> &#8211; the number of iterations to perform Lloyd&#8217;s algorthim for.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>:return list containing the new point centres.</p>
</dd></dl>

<dl class="function">
<dt id="pycoalescence.spatial_algorithms.reflect_dimensions">
<code class="descname">reflect_dimensions</code><span class="sig-paren">(</span><em>points</em>, <em>maximums</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycoalescence/spatial_algorithms.html#reflect_dimensions"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycoalescence.spatial_algorithms.reflect_dimensions" title="Permalink to this definition">¶</a></dt>
<dd><p>Reflects the provided points across x=0, y=0, x=x_max and y=y_max (essentially tiling the
polygon 4 times, around the original polygon).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>points</strong> (<em>list</em>) &#8211; a list of 2-d points to reflect</li>
<li><strong>maximums</strong> (<em>tuple</em>) &#8211; tuple containing the x and y maximums</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">a list of reflected points</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-pycoalescence.sqlite_connection">
<span id="sqlite-connection-file"></span><h3><a class="toc-backref" href="#id17">sqlite_connection file</a><a class="headerlink" href="#module-pycoalescence.sqlite_connection" title="Permalink to this headline">¶</a></h3>
<p>Safely open, close and fetch data from an sqlite connection.</p>
<p><a class="reference internal" href="#pycoalescence.sqlite_connection.SQLiteConnection" title="pycoalescence.sqlite_connection.SQLiteConnection"><code class="xref py py-class docutils literal"><span class="pre">SQLiteConnection</span></code></a> contains context management for opening sql connections, plus basic functionality for
detecting existence and structure of databases.</p>
<dl class="class">
<dt id="pycoalescence.sqlite_connection.SQLiteConnection">
<em class="property">class </em><code class="descname">SQLiteConnection</code><span class="sig-paren">(</span><em>filename</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycoalescence/sqlite_connection.html#SQLiteConnection"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycoalescence.sqlite_connection.SQLiteConnection" title="Permalink to this definition">¶</a></dt>
<dd><p>Class containing context management for opening sqlite3 connections. The file name provided can either be a string
containing the path to the file, or an sqlite3.Connection object, which will NOT be closed on destruction. This
provides two points of entry to the system with the same interface.</p>
</dd></dl>

<dl class="function">
<dt id="pycoalescence.sqlite_connection.check_sql_column_exists">
<code class="descname">check_sql_column_exists</code><span class="sig-paren">(</span><em>database</em>, <em>table_name</em>, <em>column_name</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycoalescence/sqlite_connection.html#check_sql_column_exists"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycoalescence.sqlite_connection.check_sql_column_exists" title="Permalink to this definition">¶</a></dt>
<dd><p>Checks if the column exists in the database.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>database</strong> &#8211; the database to check existence in</li>
<li><strong>table_name</strong> &#8211; the table name to check within</li>
<li><strong>column_name</strong> &#8211; the column name to check for</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">true if the column exists.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">bool</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pycoalescence.sqlite_connection.check_sql_table_exist">
<code class="descname">check_sql_table_exist</code><span class="sig-paren">(</span><em>database</em>, <em>table_name</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycoalescence/sqlite_connection.html#check_sql_table_exist"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycoalescence.sqlite_connection.check_sql_table_exist" title="Permalink to this definition">¶</a></dt>
<dd><p>Checks that the supplied table exists in the supplied database.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>database</strong> &#8211; the database to check existence in</li>
<li><strong>table_name</strong> &#8211; the table name to check for</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">boolean of whether the table exists</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">bool</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pycoalescence.sqlite_connection.fetch_table_from_sql">
<code class="descname">fetch_table_from_sql</code><span class="sig-paren">(</span><em>database</em>, <em>table_name</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycoalescence/sqlite_connection.html#fetch_table_from_sql"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycoalescence.sqlite_connection.fetch_table_from_sql" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a list of the data contained by the provided table in the database.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><p class="first"><strong>sqlite3.OperationalError</strong> &#8211; if the table is not contained in the database (protects SQL injections).</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>database</strong> &#8211; the database to obtain from</li>
<li><strong>table_name</strong> &#8211; the table name to fetch data from</li>
</ul>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">a list of lists, containing all data within the provided table in the database</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pycoalescence.sqlite_connection.sql_get_max_from_column">
<code class="descname">sql_get_max_from_column</code><span class="sig-paren">(</span><em>database</em>, <em>table_name</em>, <em>column_name</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycoalescence/sqlite_connection.html#sql_get_max_from_column"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycoalescence.sqlite_connection.sql_get_max_from_column" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the maximum value from the specified column.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>database</strong> &#8211; the database to fetch from</li>
<li><strong>table_name</strong> &#8211; the table name to attain</li>
<li><strong>column_name</strong> &#8211; </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-pycoalescence.system_operations">
<span id="system-operations-file"></span><h3><a class="toc-backref" href="#id18">system_operations file</a><a class="headerlink" href="#module-pycoalescence.system_operations" title="Permalink to this headline">¶</a></h3>
<p>Basic system-level operations required for package functionality, including subprocess calls, logging methods and file
management.</p>
<p>The functions are contained here as they are required by many different modules. Note that logging will not raise an
exception if there has been no call to set_logging_method()</p>
<dl class="function">
<dt id="pycoalescence.system_operations.cantor_pairing">
<code class="descname">cantor_pairing</code><span class="sig-paren">(</span><em>x1</em>, <em>x2</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycoalescence/system_operations.html#cantor_pairing"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycoalescence.system_operations.cantor_pairing" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a unique integer from the two provided positive integers.</p>
<p>Maps ZxZ -&gt; N, so only relevant for positive numbers.
For any A and B, generates C such that no D and E produce C unless D=A and B=E.</p>
<p>Assigns consecutive numbers to points along diagonals of a plane</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>x1</strong> &#8211; the first number</li>
<li><strong>x2</strong> &#8211; the second number</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">a unique reference combining the two integers</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pycoalescence.system_operations.check_file_exists">
<code class="descname">check_file_exists</code><span class="sig-paren">(</span><em>file_name</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycoalescence/system_operations.html#check_file_exists"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycoalescence.system_operations.check_file_exists" title="Permalink to this definition">¶</a></dt>
<dd><p>Checks that the specified filename exists, if it is not &#8220;null&#8221; or &#8220;none&#8221;.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>file_name</strong> &#8211; file path to check for</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">None</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">IOError if no file exists</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pycoalescence.system_operations.check_parent">
<code class="descname">check_parent</code><span class="sig-paren">(</span><em>file_path</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycoalescence/system_operations.html#check_parent"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycoalescence.system_operations.check_parent" title="Permalink to this definition">¶</a></dt>
<dd><p>Checks if the parent file exists, and creates it if it doesn&#8217;t.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">if file_path is a directory, it will be created</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>file_path</strong> &#8211; the file or directory to check if the parent exists</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">None</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pycoalescence.system_operations.create_logger">
<code class="descname">create_logger</code><span class="sig-paren">(</span><em>logger</em>, <em>file=None</em>, <em>logging_level=30</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycoalescence/system_operations.html#create_logger"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycoalescence.system_operations.create_logger" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a logger object to be assigned to NECSim sims and dispersal tests.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>logger</strong> &#8211; the logger to alter</li>
<li><strong>file</strong> &#8211; the file to write out to, defaults to None, writing to terminal</li>
<li><strong>logging_level</strong> &#8211; the logging level to write out at (defaults to INFO)</li>
<li><strong>kwargs</strong> &#8211; optionally provide additional arguments for logging to</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pycoalescence.system_operations.elegant_pairing">
<code class="descname">elegant_pairing</code><span class="sig-paren">(</span><em>x1</em>, <em>x2</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycoalescence/system_operations.html#elegant_pairing"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycoalescence.system_operations.elegant_pairing" title="Permalink to this definition">¶</a></dt>
<dd><p>A more elegant version of cantor pairing, which allows for storing of a greater number of digits without
experiencing integer overflow issues.</p>
<p>Cantor pairing assigns consecutive numbers to points along diagonals of a plane</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>x1</strong> &#8211; the first number</li>
<li><strong>x2</strong> &#8211; the second number</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">a unique reference combining the two integers.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pycoalescence.system_operations.execute">
<code class="descname">execute</code><span class="sig-paren">(</span><em>cmd</em>, <em>silent=False</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycoalescence/system_operations.html#execute"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycoalescence.system_operations.execute" title="Permalink to this definition">¶</a></dt>
<dd><p>Calls the command using subprocess and yields the running output for printing to terminal. Any errors produced by
subprocess call will be redirected to logging.warning() after the subprocess call is complete.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>cmd</strong> &#8211; the command to execute using subprocess.Popen()</li>
<li><strong>silent</strong> &#8211; if true, does not log any warnings</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>:return a line from the execution output</p>
</dd></dl>

<dl class="function">
<dt id="pycoalescence.system_operations.execute_log_info">
<code class="descname">execute_log_info</code><span class="sig-paren">(</span><em>cmd</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycoalescence/system_operations.html#execute_log_info"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycoalescence.system_operations.execute_log_info" title="Permalink to this definition">¶</a></dt>
<dd><p>Calls execute() with the supplied command and keyword arguments, and redirects stdout to the logging object.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>cmd</strong> &#8211; the command to execute using subprocess.Popen()</li>
<li><strong>kwargs</strong> &#8211; keyword arguments to be passed to subprocess.Popen()</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">None</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pycoalescence.system_operations.execute_silent">
<code class="descname">execute_silent</code><span class="sig-paren">(</span><em>cmd</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycoalescence/system_operations.html#execute_silent"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycoalescence.system_operations.execute_silent" title="Permalink to this definition">¶</a></dt>
<dd><p>Calls execute() silently with the supplied command and keyword arguments.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">If this function fails, no error will be thrown due to its silent nature, unless a full failure occurs.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>cmd</strong> &#8211; the command to execute using subprocess.Popen()</li>
<li><strong>kwargs</strong> &#8211; keyword arguments to be passed to subprocess.Popen()</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">None</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pycoalescence.system_operations.isclose">
<code class="descname">isclose</code><span class="sig-paren">(</span><em>a</em>, <em>b</em>, <em>rel_tol=1e-09</em>, <em>abs_tol=0.0</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycoalescence/system_operations.html#isclose"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycoalescence.system_operations.isclose" title="Permalink to this definition">¶</a></dt>
<dd><p>Checks if the two floats are close.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>a</strong> (<em>float</em>) &#8211; value 1</li>
<li><strong>b</strong> (<em>float</em>) &#8211; value 2</li>
<li><strong>rel_tol</strong> (<em>float</em>) &#8211; percentage relative to larger value</li>
<li><strong>abs_tol</strong> (<em>float</em>) &#8211; absolute value for similarity</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">true for significantly different a and b, false otherwise</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pycoalescence.system_operations.set_logging_method">
<code class="descname">set_logging_method</code><span class="sig-paren">(</span><em>logging_level=20</em>, <em>output=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycoalescence/system_operations.html#set_logging_method"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycoalescence.system_operations.set_logging_method" title="Permalink to this definition">¶</a></dt>
<dd><p>Initiates the logging process.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>logging_level</strong> &#8211; the detail in logging output: can be one
of logging.INFO (default), logging.WARNING, logging.DEBUG, logging.ERROR or logging.CRITICAL</li>
<li><strong>output</strong> &#8211; the output logfile (or None to redirect to terminal via stdout)</li>
<li><strong>kwargs</strong> &#8211; additional arguments to pass to the logging.basicConfig() call</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">None</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pycoalescence.system_operations.write_to_log">
<code class="descname">write_to_log</code><span class="sig-paren">(</span><em>i</em>, <em>message</em>, <em>logger</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycoalescence/system_operations.html#write_to_log"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycoalescence.system_operations.write_to_log" title="Permalink to this definition">¶</a></dt>
<dd><p>Writes the message to the provided logger, at the provided level.</p>
<p>This is used by NECSim to access to logging module more easily.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>i</strong> (<em>int</em>) &#8211; the level to log at (10: debug, 20: info, 30: warning, 40: error, 50: critical)</li>
<li><strong>message</strong> (<em>str</em>) &#8211; the message to write to the logger.</li>
<li><strong>logger</strong> (<em>logging.Logger</em>) &#8211; </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">None</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="index.html">
              <img class="logo" src="_static/PyCoal_logo.png" alt="Logo"/>
            </a></p>
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">pycoalescence package</a><ul>
<li><a class="reference internal" href="#key-submodules">Key submodules</a><ul>
<li><a class="reference internal" href="#module-pycoalescence.simulation">simulation module</a></li>
<li><a class="reference internal" href="#module-pycoalescence.coalescence_tree">coalescence_tree module</a></li>
</ul>
</li>
<li><a class="reference internal" href="#additional-submodules">Additional submodules</a><ul>
<li><a class="reference internal" href="#module-pycoalescence.dispersal_simulation">dispersal_simulation module</a></li>
<li><a class="reference internal" href="#module-pycoalescence.fragments">fragments module</a></li>
<li><a class="reference internal" href="#module-pycoalescence.fragment_config">fragments config module</a></li>
<li><a class="reference internal" href="#module-pycoalescence.helper">helper file</a></li>
<li><a class="reference internal" href="#module-pycoalescence.hpc_setup">hpc_setup file</a></li>
<li><a class="reference internal" href="#module-pycoalescence.landscape">landscape file</a></li>
<li><a class="reference internal" href="#module-pycoalescence.landscape_metrics">landscape_metrics file</a></li>
<li><a class="reference internal" href="#module-pycoalescence.map">map module</a></li>
<li><a class="reference internal" href="#module-pycoalescence.merger">merger module</a></li>
<li><a class="reference internal" href="#module-pycoalescence.patched_landscape">patched_landscape module</a></li>
<li><a class="reference internal" href="#module-pycoalescence.setup">setup file</a></li>
<li><a class="reference internal" href="#module-pycoalescence.spatial_algorithms">spatial_algorithms file</a></li>
<li><a class="reference internal" href="#module-pycoalescence.sqlite_connection">sqlite_connection file</a></li>
<li><a class="reference internal" href="#module-pycoalescence.system_operations">system_operations file</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="modules.html"
                        title="previous chapter">Modules</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="necsim/unabridged_api.html"
                        title="next chapter">Full API</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/pycoalescence.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="Go" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="necsim/unabridged_api.html" title="Full API"
             >next</a> |</li>
        <li class="right" >
          <a href="modules.html" title="Modules"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">pycoalescence 1.2.6 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="modules.html" >Modules</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright Copyright 2016, pycoalescence.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.5.2.
    </div>
  </body>
</html>