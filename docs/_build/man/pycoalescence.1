.\" Man page generated from reStructuredText.
.
.TH "PYCOALESCENCE" "1" "Feb 16, 2018" "1.2.5" "pycoalescence"
.SH NAME
pycoalescence \- pycoalescence Documentation
.
.nr rst2man-indent-level 0
.
.de1 rstReportMargin
\\$1 \\n[an-margin]
level \\n[rst2man-indent-level]
level margin: \\n[rst2man-indent\\n[rst2man-indent-level]]
-
\\n[rst2man-indent0]
\\n[rst2man-indent1]
\\n[rst2man-indent2]
..
.de1 INDENT
.\" .rstReportMargin pre:
. RS \\$1
. nr rst2man-indent\\n[rst2man-indent-level] \\n[an-margin]
. nr rst2man-indent-level +1
.\" .rstReportMargin post:
..
.de UNINDENT
. RE
.\" indent \\n[an-margin]
.\" old: \\n[rst2man-indent\\n[rst2man-indent-level]]
.nr rst2man-indent-level -1
.\" new: \\n[rst2man-indent\\n[rst2man-indent-level]]
.in \\n[rst2man-indent\\n[rst2man-indent-level]]u
..
.sp
pycoalescence is a python package for running and analysing spatially\-explicit neutral ecology simulations efficiently and easily.
Input your maps and output a simulated landscape of individuals.
.sp
There are two parts to this project. Models are run in necsim, built in \fBc++\fP,
using coalescence methods. Most users will not need to use this tool directly.
pycoalescence is an API for necsim that aids setting up, running and
analysing models.
.SH PYCOALESCENCE
.SS Introduction
.sp
\fBpycoalescence\fP is a python module for the spatially\-explicit coalescence neutral simulator, described
here\&. \fBpycoalescence\fP provides a pythonic interface for setting up, running and analysing
spatially\-explicit neutral simulations. It allows for a swift and clean creation management of simulations.
.SS Features
.sp
A large number of performance\-enhancing features have been implemented, as well as support for a wide number of
scenarios. These include:
.INDENT 0.0
.IP \(bu 2
Coalescence methods for excellent performance.
.IP \(bu 2
Full output of community structure, with species IDs generated for every individual.
.IP \(bu 2
Full spatial modelling, using a dispersal kernel to simulate spatial dynamics.
.IP \(bu 2
Multiple sampling points, both spatially and temporally.
.IP \(bu 2
Simulate in a region much larger than the sample area.
.IP \(bu 2
Output of a variety of biodiversity metrics, including species richness, species abundances, beta\-diversity and
locations of lineages.
.IP \(bu 2
Scalability \- support for simulations of tens or hundreds of millions of individuals in a single simulation.
.UNINDENT
.SS Getting started
.INDENT 0.0
.IP \(bu 2
\fI\%Installation\fP
.IP \(bu 2
\fI\%Performing simulations\fP
.IP \(bu 2
\fI\%Post\-simulation analysis\fP
.IP \(bu 2
\fI\%Extended analysis\fP
.IP \(bu 2
\fI\%Testing install\fP
.UNINDENT
.SS Installation
.sp
Currently, only macOS and linux\-based operating systems are supported. Windows compatibility will likely be added at a
later date.
.SS Method
.sp
Before attempting installation, make sure the \fI\%prerequisites are installed\fP\&. There are a few options for installation.
.INDENT 0.0
.IP \(bu 2
Use in\-built installation \fB[recommended]\fP
.INDENT 2.0
.INDENT 3.5
.INDENT 0.0
.IP \(bu 2
Simply run \fBpython setup.py\fP from the terminal.
.IP \(bu 2
You can also run \fBpython setup.py [opts]\fP where \fB[opts]\fP are
your required compilation flags (see  \fI\%Compilation Options\fP). On some systems this requires that \fBautoconf\fP and
\fBautotools\fP are installed on your computer.
.UNINDENT
.UNINDENT
.UNINDENT
.IP \(bu 2
Use \fBsetup.py\fP to customise options and install locations. The procedure is the same
as exists in \fBmain()\fP\&.
.INDENT 2.0
.INDENT 3.5
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
from pycoalescence import setup
# Replace with desired install options
setup.run_configure(["\-\-with\-hpc", "\-\-with\-verbose"])
# This compiles the c++ code in the lib folder to lib/obj for .o files the package directory
# and build/sharedpy2 or build/sharedpy3 for .so files (depending on python version)
setup.do_compile()
.ft P
.fi
.UNINDENT
.UNINDENT
.UNINDENT
.UNINDENT
.IP \(bu 2
Run \fB\&./configure\fP and \fBmake\fP yourself.
.INDENT 2.0
.INDENT 3.5
If you require additional compilation options, run \fB\&./configure\fP with your options from the lib/ directory. Then
run \fBmake\fP and check that installation is complete. The shared object file should be moved into the \fIbuild/sharedpyx\fP
directory, where \fIx\fP is the major python version number (2 or 3).
.UNINDENT
.UNINDENT
.IP \(bu 2
Custom compilation
.INDENT 2.0
.INDENT 3.5
Compile the c++ files yourself with the required defines and copy the executable to the required directory.
.UNINDENT
.UNINDENT
.UNINDENT
.sp
For HPC use, running \fBpython hpc_setup.py\fP (see \fBhpc_setup\fP) will perform
compilation for an HPC using the intel compiler and copy the executable to "../../Code" relative to pycoalescence.
.sp
\fBWARNING:\fP
.INDENT 0.0
.INDENT 3.5
Additional steps may have to be taken to ensure availability of the correct packages on HPC systems. Check
with your HPC administrator for details.
.UNINDENT
.UNINDENT
.sp
\fBNOTE:\fP
.INDENT 0.0
.INDENT 3.5
Separate compiles of the program are usually required for each python installation and virtual environment.
This can cause complications for certain IDEs. If you encounter problems, it is recommended that you run
\fBsetup.py\fP from within you IDE.
.UNINDENT
.UNINDENT
.SS Compilation Options
.sp
These are the possible flags which can be provided during installation as options in \fBpython setup.py [opts]\fP\&.
.TS
center;
|l|l|.
_
T{
Option
T}	T{
Description
T}
_
T{
\-\-with\-debug
T}	T{
Adds additional debugging information, including writing all messages to a log file.
T}
_
T{
\-\-with\-gdal=DIR
T}	T{
Define a gdal library at DIR
T}
_
T{
\-\-with\-hpc
T}	T{
Compile ready for HPC, using intel\(aqs icpc compilation and a variety of optimisation flags.
T}
_
T{
\-\-with\-boost=DIR
T}	T{
Define a boost library at DIR
T}
_
.TE
.SS Performing simulations
.SS Setting up simulations
.sp
There are two methods for providing configuration options in pycoalescence. Both require the same initial procedure.
The recommended method is:
.INDENT 0.0
.IP 1. 3
Specify simulation parameters
.INDENT 3.0
.IP \(bu 2
Set simulation parameters using \fBset_simulation_params()\fP
to set the job number, task number, output directory and other key simulation variables.
.IP \(bu 2
Set the map variables by one of the following:
.INDENT 3.0
.IP a. 3
\fBset_map_parameters()\fP to input file paths and dimensions
.IP b. 3
\fBset_map_files()\fP to set the map file paths. This
calls \fBdetect_map_dimensions()\fP to automatically
detect file offsets and dimensions.
.UNINDENT
.sp
\fBTIP:\fP
.INDENT 3.0
.INDENT 3.5
Check \fI\%Limitations of simulation variables\fP for important information on restrictions on simulation
inputs.
.UNINDENT
.UNINDENT
.sp
\fBNOTE:\fP
.INDENT 3.0
.INDENT 3.5
\fBdetect_map_dimensions()\fP requires
that the files are in \fB\&.tif\fP formats so that file dimensions can be read. If input files are csv format,
method a) should be used.
.UNINDENT
.UNINDENT
.sp
\fBNOTE:\fP
.INDENT 3.0
.INDENT 3.5
One can specify either "null" or "none" map types; "null" creates a map at the specified
size, whereas "none" creates hard boundaries without any in\-memory map object created at all. However,
the dimensions of these files must be manually supplied.
.UNINDENT
.UNINDENT
.IP \(bu 2
Optionally, also run \fBset_speciation_rates()\fP
to set a list of speciation rates to apply at the end of the simulation.
.UNINDENT
.IP 2. 3
Finalise setup
.INDENT 3.0
.IP \(bu 2
Run \fBfinalise_setup()\fP to check that simulations are
setup, generate the command to be passed to necsim and create any required config files.
.UNINDENT
.IP 3. 3
Run simulations
.INDENT 3.0
.IP \(bu 2
Finally, start the simulation using \fBrun_coalescence()\fP
.UNINDENT
.UNINDENT
.SS Custom Configuration Files
.sp
Although not recommended for most use\-cases, it is possible to manually create a configuration file, instead of relying on
\fBfinalise_setup()\fP to do it for you. This may be useful if
you want to store the setup file in a particular place. The process is outlined below. There are two general configuration
files, which as default are mainconf_*job_num*_*seed*.txt and the other as timeconf_*job_num*_*seed*.txt.
.INDENT 0.0
.IP 1. 3
Add a temporal sampling configuration file
If you require sampling at points other than the present day, these can be specified in another configuration file.
.INDENT 3.0
.IP \(bu 2
Add temporal sampling points using \fBadd_sample_time()\fP
Multiple sample points can be added.
.IP \(bu 2
Create the temporal sampling config file (\fBcreate_temporal_sampling_config()\fP)
.UNINDENT
.IP 2. 3
Generate the main config file
Run \fBcreate_config()\fP to generate the main config file.
.sp
\fBNOTE:\fP
.INDENT 3.0
.INDENT 3.5
If you wish to use multiple map files or multiple temporal samples and wish to use a main config file as well,
you must call
\fBcreate_config()\fP \fBafter\fP both
\fBcreate_map_config()\fP and
\fBcreate_temporal_sampling_config()\fP
.UNINDENT
.UNINDENT
.sp
\fBWARNING:\fP
.INDENT 3.0
.INDENT 3.5
It is possible to use temporal config files without using a main config file. However,
if you want map or main options in config file, you \fBmust\fP use all config options (main config and temporal config).
.UNINDENT
.UNINDENT
.IP 3. 3
Add map configuration options
If you require multiple map files at different points in time, you shall need to create a configuration (.txt or .cfg)
file to make these options accessible to the program.
.sp
These configuration options appear in the main configuration file under various headings.
.INDENT 3.0
.IP \(bu 2
First add the pristine map options using \fBadd_pristine_map()\fP
This can be performed multiple times to add several maps.
.IP \(bu 2
Add the options to the configuration file (\fBcreate_map_config()\fP)
.UNINDENT
.UNINDENT
.sp
\fBNOTE:\fP
.INDENT 0.0
.INDENT 3.5
See \fI\%Glossary\fP for definitions of \fI\%sample map\fP, \fI\%fine map\fP and \fI\%coarse map\fP\&.
.UNINDENT
.UNINDENT
.SS Examples
.sp
A simple simulation
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
from pycoalescence import Simulation
# Set logging level to "info" (from logging module)
c = Simulation(logging_level=20)
# set the main simulation parameters \- use default values for other keyword arguments
c.set_simulation_params(seed=1, job_type=1, output_directory="output", min_speciation_rate=0.1,
                        sigma=4, tau=4, deme=10, sample_size=0.1, max_time=1)
# Optionally add a set of speciation rates to apply at the end of the simulation
c.set_speciation_rates([0.1, 0.2, 0.3])
# set the map parameters \- null means the map will be generated with 100% cover everywhere (no file input).
c.set_map_parameters(sample_file = "null", sample_x = 100, sample_y=100,
                     fine_file = "null", fine_x = 200, fine_y = 200, fine_x_offset = 50, fine_y_offset = 50,
                     coarse_file = "null", coarse_x = 1000, coarse_y = 1000,
                     coarse_x_offset = 100, coarse_y_offset = 100, coarse_scale = 10,
                     pristine_fine_map = "null", pristine_coarse_map = "null")
# complete setup and run simulation
c.finalise_setup()
c.run_coalescence()
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
A more complex example using config files, multiple temporal sampling points and detection of map dimensions from the
inputted map files.
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
from pycoalescence import Simulation
c = Simulation()
# set the main simulation parameters
c.set_simulation_params(seed=1, job_type=1, output_directory="output", min_speciation_rate=0.1,
                        sigma=4, tau=4, deme=1, sample_size=0.1
                        max_time=100, dispersal_method="normal", m_prob=0.0, cutoff=0, dispersal_relative_cost=1,
                        min_num_species=1, forest_change_rate=0.2,
                        pristine_forest_time=200, time_config_file="null", restrict_self=False,
                        infinite_landscape=False)
# Add a set of speciation rates to be applied at the end of the simulation
c.set_speciation_rates([0.2, 0.3, 0.4])
# set the map files
c.set_map_files(sample_file="null", fine_file="path/to/fine.tif", coarse_file="path/to/coarse.tif")
# add sample times
c.add_sample_time(0.0)
c.add_sample_time(1.0)
# add pristine maps
c.add_pristine_map(fine_map="path/to/pristinefine1.tif", coarse_map="path/to/pristinecoarse1.tif", time=1, rate=0.5)
# create configuration files, run the checks and finalise the simulation
c.finalise_setup()
# run the simulation
c.run_coalescence()
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
\fBNOTE:\fP
.INDENT 0.0
.INDENT 3.5
necsim can also be run directly using command line arguments (see
Introduction to necsim).
.UNINDENT
.UNINDENT
.sp
Example configuration file
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
[sample_grid]
path = /Data/Maps/maskmap.tif
x = 486
y = 517
mask = /Data/Maps/maskmap.tif

[fine_map]
path = /Data/Maps/finemap.tif
x = 34000
y = 28000
x_off = 17155
y_off = 11178

[coarse_map]
path = /Data/Maps/coarsemap.tif
x = 24000
y = 20000
x_off = 10320
y_off = 7200
scale = 10.0

[pristine_fine0]
path = none
number = 0
time = 200
rate = 0

[pristine_coarse0]
path = none
number = 0
time = 200
rate = 0

[pristine_fine1]
path = none
number = 1
time = 200
rate = 0

[pristine_coarse1]
path = none
number = 1
time = 200
rate = 0

[dispersal]
method = norm\-uniform
m_probability = 1e\-10
cutoff = 0
restrict_self = 0
infinite_landscape = 0

[main]
seed = 1
job_type = 2
map_config = output/mainconf_2_1.txt
output_directory = output/
min_spec_rate = 1e\-05
sigma = 0.5
tau = 2
deme = 10
sample_size = 0.1
max_time = 2000
dispersal_relative_cost = 1
time_config = null
min_species = 1
.ft P
.fi
.UNINDENT
.UNINDENT
.SS Dispersal Kernels
.sp
Three different dispersal functions are currently supported, which take some combination of the \fIsigma\fP (\sigma)
, \fItau\fP (\tau ), \fIm_prob\fP (m ) and \fIcutoff\fP (c ) dispersal parameters. You only need to provide
the required parameters for each dispersal method; any additional parameters provided will be ignored.
.INDENT 0.0
.IP \(bu 2
.INDENT 2.0
.TP
.B Normal distribution (the default)
This requires \sigma only (the standard deviation). The outputted dispersal kernel in two dimensions
will follow a Rayleigh distribution for dispersal distance, N(r)
.UNINDENT
.IP \(bu 2
.INDENT 2.0
.TP
.B Fat\-tailed distribution
This requires both \sigma and \tau\&. Importantly, for our fat\-tailed dispersal kernel, F(r),
\lim{\tau \to \inf} = N(r)\&. Within this dispersal kernel, there is an increased chance of long\-distance
dispersal (but lower than the normal\-uniform dispersal kernel).
.UNINDENT
.IP \(bu 2
.INDENT 2.0
.TP
.B Normal\-uniform distribution
This requires \sigma, m and c . Here, we pick with probability 1-m from a normal
distribution with standard deviation \sigma, and probability m from a uniform distribution. This
uniform distribution picks a random distance equally between 0 and c, the maximal dispersal distance. For
very large c, extremely long distance dispersal is possible.
.UNINDENT
.UNINDENT
.sp
\fBpycoalescence\fP also has the ability to simulate a dispersal kernel on a landscape. For more information about that
process, see here
.SS Limitations of simulation variables
.sp
\fBIMPORTANT:\fP
.INDENT 0.0
.INDENT 3.5
This section contains key information about the simulation inputs. Please read carefully to minimise any
unnecessary bugs.
.UNINDENT
.UNINDENT
.sp
Certain simulation variables have limitations, depending on the method of setting up the simulation.
.INDENT 0.0
.IP \(bu 2
Map variables set up using \fBset_map_parameters()\fP
.INDENT 2.0
.INDENT 3.5
.INDENT 0.0
.IP \(bu 2
Sample map dimensions must be smaller than fine map dimensions.
.IP \(bu 2
Fine map dimensions must be smaller than coarse map dimensions (supplied at the resolution of the fine map files).
.IP \(bu 2
Dimensions of pristine fine and coarse maps must match their respective current map dimensions.
.IP \(bu 2
All offsets must maintain the smaller map within the larger map
.IP \(bu 2
If any files are supplied as \(aqnull\(aq, map sizes must still be provided. This is important for sample map size, but
should be corrected in a future update for coarse map files.
.UNINDENT
.UNINDENT
.UNINDENT
.IP \(bu 2
Map files (and variables) set using \fBset_map_files()\fP
.INDENT 2.0
.INDENT 3.5
.INDENT 0.0
.IP \(bu 2
In addition to the above conditions being true, the files must all be georeferenced, so that coarse and fine map
dimensions will be read correctly.
.UNINDENT
.sp
\fBHINT:\fP
.INDENT 0.0
.INDENT 3.5
Use a GIS program (such as ArcGIS or QGIS) for manipulation of map files to
ensure georeferencing is preserved.
.UNINDENT
.UNINDENT
.INDENT 0.0
.IP \(bu 2
If the samplemask map is "null", the program will read the dimensions from the fine map and choose that as the
area to sample entirely over. Supplying "null" will therefore sample the entirety of the fine map.
.UNINDENT
.sp
\fBHINT:\fP
.INDENT 0.0
.INDENT 3.5
Scalings and offsets between maps should also work correctly, but if problems are encountered, try manually
specifying offsets and dimensions to identify any problems.
.UNINDENT
.UNINDENT
.UNINDENT
.UNINDENT
.UNINDENT
.sp
An example of how the map files are related is shown below. Black arrows indicate the offsets for the fine map (in the x
and y dimensions) and purple arrows indicate the offsets for the coarse map.
[image: Example sample map, fine map and coarse map]
[image]
.SS Infinite Landscapes
.sp
Simulations can also be run on infinite landscapes. Set \fBinfinite_landscapes=opt\fP in
\fBset_simulation_params()\fP where \fIopt\fP is one of the
following:
.INDENT 0.0
.IP \(bu 2
.INDENT 2.0
.TP
.B "closed" (default)
Run without infinite landscapes, with closed boundaries to the coarse map.
.UNINDENT
.IP \(bu 2
.INDENT 2.0
.TP
.B "infinite"
Run with a pristine infinite landscape outside of the coares map boundaries.
.UNINDENT
.IP \(bu 2
.INDENT 2.0
.TP
.B "tiled_coarse"
Tile the coarse map infinitely in all dimensions.
.UNINDENT
.IP \(bu 2
.INDENT 2.0
.TP
.B "tiled_fine"
Tile the fine map infinitely in all dimensions.
.UNINDENT
.UNINDENT
.SS Optimising Simulations
.sp
\fBoptimise_ram()\fP exists for reducing the RAM requirements of
a simulation. Running the function with a specific RAM limit, in GB, should choose a sample map size and offsets to
minimise the in\-memory object sizes. This may have a minor impact on simulation speed, but this is likely negligible.
After the function is run, the \fBSimulation class\fP should have re\-defined
the grid x and y dimensions to be the largest size possible to simulate for the required memory. The sample map offsets
from the grid are then also stored, such that the grid encompasses the area with the highest number of individuals.
.sp
\fBoptimise_ram()\fP may take some time to run. However, for a
single set of simulations with the same RAM limit, this function should only need to be completed once. Getting and
setting the optimised solution is therefore possible with
\fBget_optimised_solution()\fP and
\fBset_optimised_solution()\fP\&. The whole procedure is
outlined below.
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
# Detect the RAM\-optimised solution
>> sim1.optimise_ram()
# Get the optimised solution for Simulation object sim1
>> sim1.get_optimised_solution()
{\(aqgrid_file_name\(aq: \(aqset\(aq,
\(aqgrid_x_size\(aq: 5134,
\(aqgrid_y_size\(aq: 5134,
\(aqsample_x_offset\(aq: 8208,
\(aqsample_y_offset\(aq: 14877}
# Now set the optimised solution for Simulation object sim2
>> sim2.set_optimised_solution({\(aqgrid_file_name\(aq: \(aqset\(aq,
                              \(aqgrid_x_size\(aq: 5134,
                              \(aqgrid_y_size\(aq: 5134,
                              \(aqsample_x_offset\(aq: 8208,
                              \(aqsample_y_offset\(aq: 14877})
.ft P
.fi
.UNINDENT
.UNINDENT
.SS Post\-simulation analysis
.sp
Once simulations are complete, necsim\(aqs applying speciation rates functionality
can be used to apply additional speciation rates to the coalescence tree. A simple way of applying additional simulation
rates is provided within the \fBCoalescenceTree class\fP\&.
.sp
The two functions for this routine are
.INDENT 0.0
.IP \(bu 2
\fBset_speciation_params()\fP which takes as
.UNINDENT
.INDENT 0.0
.INDENT 3.5
arguments
.INDENT 0.0
.INDENT 3.5
.INDENT 0.0
.IP \(bu 2
the SQL database file containing a finished simulation
.IP \(bu 2
T/F of recording full spatial data
.IP \(bu 2
either a csv file containing fragment data, or T/F for whether
fragments should be calculated from squares of continuous habitat.
* list of speciation rates to apply
.IP \(bu 2
[optional] a sample file to specify certain cells to sample from
.IP \(bu 2
[optional] a config file containing the temporal sampling points
desired.
.UNINDENT
.UNINDENT
.UNINDENT
.UNINDENT
.UNINDENT
.INDENT 0.0
.IP \(bu 2
\fBapply_speciation()\fP performs the analysis. This can be extremely
RAM and time\-intensive for simulations of a large number of individuals. The calculations will
be stored in extra tables within the same SQL file as originally
specified.
.UNINDENT
.sp
The procedure for applying additional speciation rates to an existing database is
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
from pycoalescence import CoalescenceTree
t = CoalescenceTree()
speciation_rates = [0.1, 0.2 ,0.3]
t.set_database("output/SQL_data/data_1_1.db")
t.set_speciation_params("T", "null", speciation_rates)
t.apply_speciation()
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
The \fBCoalescenceTree class\fP object can also be set up from a
\fBSimulation class\fP object as:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
from pycoalescence import Simulation, CoalescenceTree
sim = Simulation()
# ... set up simulation here, then run
# Now import our completed simulation without needing to run t.set_database("filepath")
t = CoalescenceTree(sim)
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
A few biodiversity metrics can then be obtained directly from the database using built\-in functions, relieving the user
of having to generate these manually. These include
.INDENT 0.0
.IP \(bu 2
species richness, using \fBget_richness()\fP
.IP \(bu 2
species abundances, using \fBget_species_abundances()\fP
.IP \(bu 2
species octave (2^n) classes for generating species abundance distributions,
using \fBget_octaves()\fP
.UNINDENT
.sp
\fBNOTE:\fP
.INDENT 0.0
.INDENT 3.5
The above functions require supplying a speciation rate and time, otherwise will output data for all
speciation rates and times.
.UNINDENT
.UNINDENT
.sp
\fBTIP:\fP
.INDENT 0.0
.INDENT 3.5
Equivalent functions also exist for obtaining individual fragment biodiversity metrics.
.UNINDENT
.UNINDENT
.sp
\fBTIP:\fP
.INDENT 0.0
.INDENT 3.5
The entire list of species can be outputted using
\fBget_species_list\fP\&. This may be useful for scenarios
where it is desirable to calculate custom biodiversity metrics.
.UNINDENT
.UNINDENT
.SS Extended analysis
.sp
The \fBcoal_analyse\fP module can be used for more extensive simulation analysis, such
as comparing simulated landscapes to real data and calculating goodness of fits.
.sp
The general procedure for using this module involves a few functions, all contained in the
\fBCoalescenceTree class\fP\&.
.INDENT 0.0
.IP \(bu 2
\fBset_database()\fP generates the link to the SQL database, which
should be an output from a \fBnecsim\fP simulation (probably run using the
\fBSimulation class\fP\&.
.IP \(bu 2
\fBimport_comparison_data()\fP reads an SQL database which
contains real data to compare to the simulation output. The comparison data should contain the following tables:
.INDENT 2.0
.IP \(bu 2
BIODIVERSITY_ METRICS, containing \fIonly\fP "metric", "fragment", "value" and "number_of_individuals" columns.
The metric can be "fragment_richness" or any other metric created by your own functions which exists also in
the simulated data.
.IP \(bu 2
SPECIES_ABUNDANCES containing \fIat least\fP "SpeciesID", "Abund".
.UNINDENT
.UNINDENT
.sp
Additionally, one can provide the following if comparisons between fragments are required:
.INDENT 0.0
.INDENT 3.5
.INDENT 0.0
.IP \(bu 2
FRAGMENT_ABUNDANCES containing \fIat least\fP "Plot", "Mnemonic" and "Abund".
.IP \(bu 2
FRAGMENT_OCTAVES containing \fIat least\fP "fragment", "octave", "num_species". This can also be calculated from
FRAGMENT_ABUNDANCES using \fBcalculate_comparison_octaves()\fP
.UNINDENT
.UNINDENT
.UNINDENT
.SS Testing install
.sp
The system install can be tested by running \fBtest_install.py\fP from the command line
(\fBpython test_install.py\fP) which requires that \fBpython setup.py\fP has been successfully run previously.
.SS Prerequisites
.SS Essential
.INDENT 0.0
.IP \(bu 2
Python version 2 >= 2.7.9 or 3 >= 3.4.1
.IP \(bu 2
C++ compiler (such as GNU g++) with C++11 support.
.IP \(bu 2
The SQLite library available \fI\%here\fP\&. Require both \fBc++\fP and \fBpython\fP installations.
.IP \(bu 2
The Boost library for C++ available \fI\%here\fP\&.
.IP \(bu 2
Numerical python (\fBnumpy\fP) package.
.UNINDENT
.sp
\fBTIP:\fP
.INDENT 0.0
.INDENT 3.5
Most packages, including their c++ libraries, can be installed using \fIpip install package_name\fP on most UNIX
systems.
.UNINDENT
.UNINDENT
.SS Recommended
.INDENT 0.0
.IP \(bu 2
The gdal library for both python and C++ (\fI\%available here\fP). This is \fBESSENTIAL\fP if you wish
to use .tif files for necsim\&.  It allows reading parameter information from .tif files
(using \fBdetect_map_dimensions()\fP). Both the python
package and \fBc++\fP binaries are required; installation differs between systems, so view the gdal documentation for more
help installing gdal properly.
.IP \(bu 2
The fast\-cpp\-csv\-parser by Ben Strasser, available
\fI\%here\fP\&. This provides much faster csv read and write capabilities
and is probably essential for larger\-scale simulations, but not necessary if your simulations are small. The folder
\fIfast\-cpp\-csv\-parser/\fP should be in the same directory as your \fBnecsim\fP C++ header files (the lib/necsim directory).
.UNINDENT
.sp
\fBNOTE:\fP
.INDENT 0.0
.INDENT 3.5
Running \fBconfigure\fP (or \fBpython setup.py\fP) will detect system components, including \fBsqlite3\fP, \fBboost\fP,
\fBgdal\fP and \fBfast\-cpp\-csv\-parser\fP and set the correct compilation flags.
.UNINDENT
.UNINDENT
.SS Glossary
.INDENT 0.0
.TP
.B grid
Used to refer to the simulation area that is stored in memory as a matrix, for quick referencing. If no RAM
optimisations have been performed, this will be the same as the sample map. If also no sample map is used, this
will be the same as the fine map.
.TP
.B sample map
The map file containing the points to be sampled from. This is the most zoomed in level of the simulation, and
should encompass all starting locations of lineages.
.TP
.B fine map
The map file at a higher resolution (the same as the sample grid) which covers the area lineages are most likely
to move to, or where a higher spatial resolution is considered important.
.TP
.B coarse map
The map file at a lower resolution (specified by the scale) which covers a larger area than the fine map. This is
to allow lineages to move far from their starting positions if required.
.TP
.B pristine map
A historic map containing population densities at those times. Both fine and coarse pristine maps can be declared
and multiple sets of pristine maps can be declared at unique times.
.UNINDENT
.SS Version
.sp
Version 1.2.5
.SS Contacts
.sp
Author: Samuel Thompson
.sp
Contact: \fI\%samuelthompson14@imperial.ac.uk\fP \- \fI\%thompsonsed@gmail.com\fP
.sp
Institution: Imperial College London and National University of
Singapore
.sp
This project is released under BSD\-3 See file
\fBLICENSE.txt\fP or go to
\fI\%here\fP for full license
details.
.SH NECIM
.sp
\fBA Neutral Ecology Coalescence Simulator\fP
.SS Introduction
.sp
Provided here is a set of tools for running and analysing backwards\-time (coalescent) neutral models in ecology. necsim
is a generic spatial coalescence simulator for neutral systems.
It applies the model to maps for the supplied parameters and outputs information for each
individual to a SQL database.
.sp
Functionality is also provided for applying varying speciation rates to
outputs of \fBnecsim\fP for analysis after simulations are complete. This
enables the main simulation to be run with the \fIminimum\fP speciation rate
required and afterwards analysis can be completed using different
speciation rates. The same functionality is also provided within \fBnecsim\fP for application of speciation rates immediately
after simulations are complete.
.sp
\fBIMPORTANT:\fP
.INDENT 0.0
.INDENT 3.5
The recommended method of installing the program and running simulations is to use the
pycoalescence module\&.
.UNINDENT
.UNINDENT
.SS A Note on the Neutral Theory of Ecology
.sp
Neutral theory in ecology refers to the idea that individuals can be modelled as ecologically identical entities,
undergoing dispersal, drift and speciation without niche effects or other competitive elements.
.sp
Whilst obviously not realistic, the patterns produced by such models can often give a surprisingly accurate portrayal of
real\-world systems. For more information on the topic, please see \fI\%[Hubbell2001]\fP\&.
.SS Instructions
.SS Compiling the program
.sp
For compilation, there are several provided options:
.INDENT 0.0
.IP \(bu 2
Compilation can be handled within pycoalescence by running \fBpython setup.py\fP\&. \fBThis is the recommended option.\fP
.IP \(bu 2
Alternatively, compilation can be completed with additional options using make. The steps are outlined below
.INDENT 2.0
.INDENT 3.5
.INDENT 0.0
.IP \(bu 2
You might need to first run \fBautoconf\fP from within the \fBnecsim\fP directory to generate the configure executable.
.IP \(bu 2
Run \fB\&./configure\fP (located within the \fBnecsim\fP directory). Provide additional compilation flags if necessary (detailed below).
.IP \(bu 2
Run \fBmake all\fP to create the executable.
.IP \(bu 2
[Optional] Move the executable (called necsim) to the \fIbuild/Default\fP directory in \fBpycoalescence\fP\&.
.UNINDENT
.UNINDENT
.UNINDENT
.IP \(bu 2
If you require compilation outside of the pycoalescence module, make use of the the file \fBMakefile\fP located in
\fBMakefiles/SimpleCompile\fP\&. This can be modified and run using \fBmake\fP to generate the executable.
.UNINDENT
.sp
\fBNOTE:\fP
.INDENT 0.0
.INDENT 3.5
If you want to also compile the module for integrating with python, provide the python library (PYTHON_LIB) and
python include directories (PYTHON_INCLUDE) as command line flags to \fB\&./configure\fP\&. You must then run This is
not recommended, and it is advised you use the install proceedure outlined here\&.
.UNINDENT
.UNINDENT
.sp
\fBWARNING:\fP
.INDENT 0.0
.INDENT 3.5
Compilation on High\-performance clusters will likely require an icc compiler and custom linking to the
required libraries.
.UNINDENT
.UNINDENT
.sp
See the Requirements section for a full list of the necessary
prerequisites.
.SS Requirements
.INDENT 0.0
.IP \(bu 2
The SQLite library available \fI\%here\fP\&.
.IP \(bu 2
The Boost library available \fI\%here\fP\&.
.IP \(bu 2
C++ compiler (such as GNU g++) with C++11 support.
.IP \(bu 2
Access to the relevant folders for Default simulations (see FAQS).
.UNINDENT
.sp
Recommended, but not essential:
.INDENT 0.0
.IP \(bu 2
gdal library available \fI\%here\fP: provides reading of tif files.
.IP \(bu 2
.INDENT 2.0
.TP
.B The fast\-cpp\-csv\-parser by Ben Strasser, available
\fI\%here\fP: provides much faster csv read and write capabilities.
.UNINDENT
.UNINDENT
.SS Compiler Options
.sp
Recognised compiler options include:
.TS
center;
|l|l|.
_
T{
Option
T}	T{
Description
T}
_
T{
\-\-with\-debug
T}	T{
Adds additional debugging information to a log file in /logs
T}
_
T{
\-\-with\-gdal=DIR
T}	T{
Define a gdal library at DIR
T}
_
T{
\-\-with\-hpc
T}	T{
Compile ready for HPC, using intel\(aqs icpc compilation and a variety of optimisation flags.
T}
_
T{
\-\-with\-boost=DIR
T}	T{
Define a boost library at DIR
T}
_
.TE
.sp
Additional c++ compilation flags can be specified by \fBCPPFLAGS=opts\fP for additional library paths or compilation options as required.
.sp
Note that gdal and fast\-cpp\-csv\-parser availability will be automatically detected and included in the compilation if possible.
.SS Running simulations
.sp
As of version 3.1 and above, the routine relies on
supplying command line arguments (see below) for all the major
simulation variables. Alternatively, supplying a config .txt file and
using the command line arguments \fB\&./necsim \-c /path/to/config.txt\fP
can be used for parsing command line arguments from the text file.
.SS Command Line Arguments
.sp
Deprecated since version This: method of supplying simulation parameters is not recommended and is provided for backwards\-compatibility only.
Support will be dropped completely in a future release.

.sp
The following command line arguments are required. This list can be
accessed by running \fB“./necsim \-h”\fP or \fB\&./necsim \-help\fP
.sp
As of version 3.6 and above, the command line options to be specified are:
.INDENT 0.0
.IP 1. 4
the seed for the simulation.
.IP 2. 4
the simulation task (for file reference).
.IP 3. 4
the map config file.
.IP 4. 4
the output directory.
.IP 5. 4
the minimum speciation rate.
.IP 6. 4
the dispersal z_fat value.
.IP 7. 4
the dispersal L value.
.IP 8. 4
the deme size.
.IP 9. 4
the deme sample size.
.IP 10. 4
the maximum simulation time (in seconds).
.IP 11. 4
the lambda value for moving through non\-habitat.
.IP 12. 4
the temporal sampling file containing generation
values for sampling points in time (null for only sampling the
present)
.IP 13. 4
the minimum number of species known to exist. (Currently has no
effect).
.IP 14. 4
(and onwards) speciation rates to apply after simulation.
.UNINDENT
.sp
In this format, the map config file and temporal sampling file are as described in \fI\%Config Files\fP\&.
.sp
Alternatively, by specifying the \-f flag, (full mode) as the first
argument, the program can read in pre\-3.6 command line arguments, which
are as followed.
.INDENT 0.0
.IP 1. 4
the task_iter used for setting the seed.
.IP 2. 4
the sample grid x dimension
.IP 3. 4
the sample grid y dimension
.IP 4. 4
the fine map file relative path.
.IP 5. 4
the fine map x dimension
.IP 6. 4
the fine map y dimension
.IP 7. 4
the fine map x offset
.IP 8. 4
the fine map y offset
.IP 9. 4
the coarse map file relative path.
.IP 10. 4
the coarse map x dimension
.IP 11. 4
the coarse map y dimension
.IP 12. 4
the coarse map x offset
.IP 13. 4
the coarse map y offset
.IP 14. 4
the scale of the coarse map compared to the fine (10 means
resolution of coarse map = 10 x resolution of fine map)
.IP 15. 4
the output directory
.IP 16. 4
the speciation rate.
.IP 17. 4
the dispersal sigma value.
.IP 18. 4
the deme size
.IP 19. 4
the deme sample size (as a proportion of deme size)
.IP 20. 4
the time to run the simulation (in seconds).
.IP 21. 4
lambda \- the relative cost of moving through non\-forest
.IP 22. 4
the_task \- for referencing the specific task later on.
.IP 23. 4
the minimum number of species the system is known to contain.
.IP 24. 4
the pristine fine map file to use
.IP 25. 4
the pristine coarse map file to use
.IP 26. 4
the rate of forest change from pristine
.IP 27. 4
the time (in generations) since the pristine forest was seen.
.IP 28. 4
the dispersal tau value (the width of the fat\-tailed kernel).
.IP 29. 4
the sample mask, with binary 1:0 values for areas that we want to
sample from. If this is not provided then this will default to
mapping the whole area.
.IP 30. 4
the link to the file containing every generation that the list
should be expanded. This should be in the format of a list.
.IP 31. 4
(and onwards) \- speciation rates to apply after the simulation is
complete.
.UNINDENT
.sp
\fBWARNING:\fP
.INDENT 0.0
.INDENT 3.5
This method of running simulations is provided for legacy purposes only, and is no longer recommended. For
increase functionality, use the condensed command\-line format, or switch to using config files.
.UNINDENT
.UNINDENT
.SS Config Files
.sp
There are two separate config files which are used when setting up simulations.
.INDENT 0.0
.IP \(bu 2
.INDENT 2.0
.TP
.B \fI\%main simulation config file\fP
Contains the main simulation parameters, including dispersal parameters, speciation rates, sampling information and
file referencing information. It also includes the paths to the other config files, which must be specified if the
main simulation config is used.
Contains the map parameters, including paths to the relevant map files, map dimensions, offsets and scaling. This
option cannot be null (map dimensions at least must be specified).
.UNINDENT
.IP \(bu 2
.INDENT 2.0
.TP
.B \fI\%time config file\fP
Contains the temporal sampling points, in generations. If this is \(aqnull\(aq, sampling will automatically occur only
at the present (generation time=0)
.UNINDENT
.UNINDENT
.sp
When running the simulation using config files, the path to the \fI\%main simulation config file\fP should be specified, e.g
\fB\&./necsim \-c /path/to/main/config.txt\fP\&.
.SS Main Config File
.sp
The configuration containing the majority of the simulation set up, outside of map dimensions. An example file is shown
below. This file can be automatically generated by \fBcreate_config()\fP
in pycoalescence. An example of this configuration is given below:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
[main]
seed = 6
job_type = 6
map_config = output/mapconf.txt
output_directory = output
min_spec_rate = 0.5
sigma = 4
tau = 4
deme = 1
sample_size = 0.1
max_time = 1
lambda = 1
time_config = output/tempconf.txt
min_species = 1

[spec_rates]
spec_rate1  = 0.6
spec_rate2  = 0.8
.ft P
.fi
.UNINDENT
.UNINDENT
.SS Map Config Options
.sp
The map options contain the information for setting up all maps required by the simulation. This involves maps at all
times and at all scales. An example is given below.
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
[sample_grid]
path = null
x = 13
y = 13
mask = null

[fine_map]
path = sample/SA_sample_fine.tif
x = 13
y = 13
x_off = 0
y_off = 0

[coarse_map]
path = sample/SA_sample_coarse.tif
x = 35
y = 41
x_off = 11
y_off = 14
scale = 1.0

[pristine_fine0]
path = sample/SA_sample_fine_pristine1.tif
number = 0
time = 1
rate = 0.5

[pristine_coarse0]
path = sample/SA_sample_coarse_pristine1.tif
number = 0
time = 1
rate = 0.5

[pristine_fine1]
path = sample/SA_sample_fine_pristine2.tif
number = 1
time = 4
rate = 0.7

[pristine_coarse1]
path = sample/SA_sample_coarse_pristine2.tif
number = 1
time = 4
rate = 0.7
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
\fBNOTE:\fP
.INDENT 0.0
.INDENT 3.5
The rates and times between the pairs of pristine fine maps and pristine coarse maps must match up. Without matching
values here, there could be undetermined errors, or coarse map values being ignored.
.UNINDENT
.UNINDENT
.sp
\fBNOTE:\fP
.INDENT 0.0
.INDENT 3.5
Pristine maps assume the same dimensions as their respective present\-day equivalents.
.UNINDENT
.UNINDENT
.sp
\fBNOTE:\fP
.INDENT 0.0
.INDENT 3.5
In older versions of this program these options were contained in a separate file. However, as of 1.2.4 map and main
simulation options are contained in the same file.
.UNINDENT
.UNINDENT
.SS Time Config File
.sp
The temporal sampling config file (referred to as "time config file") specifies times, in generations, when a full
sample according to the sample map should be taken again. An example of this file is given below.
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
[main]
time0 = 0.0
time1 = 1.0
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
\fBNOTE:\fP
.INDENT 0.0
.INDENT 3.5
For each speciation rate, all biodiversity measures (such as species\(aq abundances and species\(aq richness) will be
calculated for each time supplied separately.
.UNINDENT
.UNINDENT
.SS Default parameters
.sp
To run the program with the default parameters for testing purposes, run
with the command line arguments \-d or \-dl (for the larger default run).
Note that this will require access to the following folders relative to
the path of the program for storing the outputs to the default runs:
.sp
\fB\&./Default\fP
.sp
\fB\&./Default/SQL_data/\fP
.SS Outputs
.sp
Upon successful completion of a simulation, the two files are created.
.INDENT 0.0
.IP \(bu 2
A csv file is created called \fIData_{the_task}_{the_seed}.csv\fP where the_seed and the_task are the values provided
in simulation set\-up. This contains basic simulation information for quick reference.
.IP \(bu 2
an SQLite database file in the output directory in a folder called \fISQL_data\fP\&.
This database contains all important simulation data over several tables, which can be accessed
using a program like \fI\%DB Browser for SQLite\fP or Microsoft Access.
Alternatively, most programming languages have an SQLite interface
(\fI\%RSQlite\fP,
\fI\%python sqlite3\fP)
.UNINDENT
.sp
The tables in the SQLite database are
\- SIMULATION_PARAMETERS
.INDENT 0.0
.INDENT 3.5
contains the parameters the simulation was performed with for referencing later.
.UNINDENT
.UNINDENT
.INDENT 0.0
.IP \(bu 2
SPECIES_LIST
.INDENT 2.0
.INDENT 3.5
contains the locations of every coalescence event. This is used by SpeciationCounter to reconstruct the coalescence
tree for application of speciation rates after simulations are complete.
.UNINDENT
.UNINDENT
.IP \(bu 2
SPECIES_ABUNDANCES
.INDENT 2.0
.INDENT 3.5
contains the species abundance distributions for each speciation rate and time point that has been specified.
.UNINDENT
.UNINDENT
.IP \(bu 2
SPECIES_LOCATIONS [optional]
.INDENT 2.0
.INDENT 3.5
contains the x, y coordinates of every individual at each time point and for every specified speciation rate,
along with species ID numbers.
.UNINDENT
.UNINDENT
.IP \(bu 2
FRAGMENT_ABUNDANCES [optional]
.INDENT 2.0
.INDENT 3.5
contains the species abundance distributions for each habitat fragment, either specified by the fragment csv file,
or detected from squares across the map.
.UNINDENT
.UNINDENT
.UNINDENT
.sp
Additional information can be found in \fI\%SpeciationCounter\fP regarding the optional database tables.
.SS SpeciationCounter
.sp
SpeciationCounter provides a method for applying additional speciation rates to outputs from necsim, without having to
re\-run the entire simulation. SpeciationCounter works by reconstructing the coalescence tree, checking at each point if
an additional speciation rate has occured. As such, SpeciationCounter can only apply speciation rates higher than the
initial speciation rate the program was run with.
.SS Applying Speciation Rates
.sp
Run \fB\&./SpeciationCounter\fP with the following command\-line options:
.INDENT 0.0
.IP 1. 3
path to the SQLite database file (this is the output of a \fBnecsim\fP simulation).
.IP 2. 3
T/F for recording spatial data. If true, the SPECIES_LOCATIONS table will be created (see \fI\%Outputs\fP\&.)
.IP 3. 3
a sample mask to use for the data. Species\(aq identities for the individuals will only be calculated from locations
specified by a 1 in the sample mask (0 otherwise). Use "null" to record all locations.
.IP 4. 3
a \fI\%time config file\fP specifying temporal sampling locations.
.IP 5. 3
T/F for calculating fragment species abundances individually. If true, the FRAGMENT_ABUNDANCES table will be created
containing the species abundances for each fragment calculated as a square of continuous habitat. Alternatively, can
specify a csv file that contains the fragment information in the following format. All x, y coordinates are given on
the sample grid size specified at simulation run\-time.
.INDENT 3.0
.INDENT 3.5
.sp
.nf
.ft C
fragment_name1, x_min, y_min, x_max, y_max, number_of_individuals
fragment_name2, x_min, y_min, x_max, y_max, number_of_individuals
\&...
.ft P
.fi
.UNINDENT
.UNINDENT
.IP 6. 3
A speciation rate to apply. Can list multiple speciation rates by supplying arguments 7 onwards.
.UNINDENT
.SS Debugging
.sp
Most errors will return an error code in the form “ERROR_NAME_XXX:
Description” a list of which can be found in ERROR_REF.txt.
.SS Brief Class Descriptions
.sp
A brief description of the important classes is given below. Some
classes also contain customised exceptions for better tracing of error
handling.
.INDENT 0.0
.IP \(bu 2
The \fBTree\fP class
.INDENT 2.0
.IP \(bu 2
The most important class!
.IP \(bu 2
Contains the main setup, run and data output routines.
.IP \(bu 2
\fBsetup()\fP imports the data files from csv (if necessary) and creates
the in\-memory objects for the storing of the coalescence tree and
the spatial grid of active lineages. Setup time mostly depends on
the size of the csv file being imported.
.IP \(bu 2
Run continually loops over sucessive coalesence, move or
speciation events until all individuals have speciated or
coalesced. This is where the majority of the simulation time will
be, and is mostly dependent on the number of individuals,
speciation rate and size of the spatial grid.
.IP \(bu 2
At the end of the simulation, the sqlCreate() routine will
generate the in\-memory SQLite database for storing the coalescent
tree. It can run multiple times if multiple speciation rates are
required. \fBoutputData()\fP will then be called to create a small csv
file containing important information, and output the SQLite
database to file if required.
.UNINDENT
.IP \(bu 2
The \fBTreeNode\fP class
.INDENT 2.0
.IP \(bu 2
Contains a single record of a node on the phylogenetic tree, to be
used in reassembling the tree structure at the end of the
simulation.
.UNINDENT
.IP \(bu 2
The \fBDataPoint\fP class
.INDENT 2.0
.IP \(bu 2
Contains a single record of the location of a lineage.
.UNINDENT
.IP \(bu 2
The \fBNRrand\fP class
.INDENT 2.0
.IP \(bu 2
Contains the random number generator, as written by James
Rosindell (\fI\%j.rosindell@imperial.ac.uk\fP).
.UNINDENT
.IP \(bu 2
The \fBMap\fP class
.INDENT 2.0
.IP \(bu 2
Contains the routines for importing and calling values from the
map objects.
.IP \(bu 2
The \fBgetVal()\fP and \fBrunDispersal()\fP functions can be modified
to produce altered dispersal behaviour, or alterations to the
structure of the \fBRow\fP
.UNINDENT
.IP \(bu 2
The \fBMatrix\fP and \fBRow\fP classes
.INDENT 2.0
.IP \(bu 2
Based on code written by James Rosindell
(\fI\%j.rosindell@imperial.ac.uk\fP).
.IP \(bu 2
Handles indexing of the 2D object plus importing values from a csv
file.
.UNINDENT
.IP \(bu 2
The \fBSpeciesList\fP class
.INDENT 2.0
.IP \(bu 2
Contains the list of individuals, for application in a matrix, to
essentially create a 3D array.
.IP \(bu 2
Handles the positioning of individuals in space within a grid
cell.
.UNINDENT
.IP \(bu 2
The \fBConfigOption\fP class
.INDENT 2.0
.IP \(bu 2
Contains basic functions for importing command line arguments from
a config file, providing an alternative way of setting up
simulations.
.UNINDENT
.IP \(bu 2
The \fBTreeList\fP class
.INDENT 2.0
.IP \(bu 2
Provides the routines for applying different speciation rates to a
phylogenetic tree, to be used either immediately after simulation
within \fBnecsim\fP, or at a later time using \fI\%SpeciationCounter\fP
.UNINDENT
.UNINDENT
.SS Known Bugs
.INDENT 0.0
.IP \(bu 2
Simulations run until completion, rather than aiming for a desired
number of species. This is an intentional change. Functions related
to this functionality remain but are deprecated.
.IP \(bu 2
In SpeciationCounter, only continuous rectangular fragments are
properly calculated. Other shapes must be calculated by
post\-processing.
.IP \(bu 2
In SpeciationCounter, 3 fragments instead of 2 will be calculated for
certain adjacent rectangular patches.
.UNINDENT
.SS FAQS (WIP)
.INDENT 0.0
.IP \(bu 2
\fBWhy doesn’t the default simulation output anything?\fP
.INDENT 2.0
.IP \(bu 2
Check that the program has access to the folders relative to the
program at \fIDefault/\fP
.UNINDENT
.IP \(bu 2
\fBWhy can’t I compile the program?\fP
.INDENT 2.0
.IP \(bu 2
This could be due to a number of reasons, most likely that you
haven’t compiled with access to the lsqlite3 or boost packages.
Installation and compilation differs across different systems; for
most UNIX systems, compiling with the linker arguments \-lsqlite3
\-lboost_filesystem and \-lboost_system will solve problems with
the compiler not finding the sqlite or boost header file.
.IP \(bu 2
Another option could be the potential lack of access to the
fast\-cpp\-csv\-parser by Ben Strasser, available
\fI\%here\fP\&. If
use_csv has been defined at the head of the file, try without
use_csv or download the csv parser and locate the folder within
your working directory at compilation.
.UNINDENT
.IP \(bu 2
\fBEvery time the program runs I get error code XXX.\fP
.INDENT 2.0
.IP \(bu 2
Check the ERROR_REF.txt file for descriptions of the files. Try compiling with the \fIDEBUG\fP precursor to gain
more information on the problem. It is most likely a problem with
the set up of the map data (error checking is not yet properly
implemented here).
.UNINDENT
.UNINDENT
.SS Version
.sp
Version 1.2.5
.SS Contacts
.sp
Author: \fBSamuel Thompson\fP
.sp
Contact: \fI\%samuelthompson14@imperial.ac.uk\fP \- \fI\%thompsonsed@gmail.com\fP
.sp
Institution: Imperial College London and National University of
Singapore
.sp
Based heavily on code by \fBJames Rosindell\fP
.sp
Contact: \fI\%j.rosindell@imperial.ac.uk\fP
.sp
Institution: Imperial College London
.SS Licence
.sp
This project is released under BSD\-3 See file
\fBLICENSE.txt\fP or go to
\fI\%here\fP for full license
details.
.sp
You are free to modify and distribute the code for any non\-commercial purpose.
.SS Class Hierarchy
.SS File Hierarchy
.SS Full API
.SS Namespace std
.sp
STL namespace.
.SS Struct CommunityParameters
.INDENT 0.0
.IP \(bu 2
Defined in file_necsim_Community.h
.UNINDENT
.SS Struct Documentation
.INDENT 0.0
.TP
.B struct CommunityParameters 
A struct for containing pairs of previous calculations to make sure that aren\(aqt repeated. 
Public Functions.INDENT 7.0
.TP
.B CommunityParameters() 
.UNINDENT
.INDENT 7.0
.TP
.B CommunityParameters(unsigned long \fIreference_in\fP, long double \fIspeciation_rate_in\fP, long double \fItime_in\fP, bool \fIfragment_in\fP, unsigned long \fImetacommunity_reference_in\fP) 
Constructor for CommunityParameters, for storing a pairs of previous calculations, requiring a speciation rate and a time. Overloaded version with setup routines. 
.sp
.INDENT 7.0
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fBreference_in\fP: the reference to set for this CommunityParameters set 
.IP \(bu 2
\fBspeciation_rate_in\fP: the speciation rate of the previous calculation 
.IP \(bu 2
\fBtime_in\fP: the time of the previous calculation 
.IP \(bu 2
\fBfragment_in\fP: bool of whether fragments were used in the previous calculation 
.IP \(bu 2
\fBmetacommunity_reference_in\fP: the metacommunity reference, or 0 for no metacommunity 
.UNINDENT
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B void setup(unsigned long \fIreference_in\fP, long double \fIspeciation_rate_in\fP, long double \fItime_in\fP, bool \fIfragment_in\fP, unsigned long \fImetacommunity_reference_in\fP) 
Sets up the CommunityParameters object. 
.sp
.INDENT 7.0
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fBreference_in\fP: the reference to set for this CommunityParameters set 
.IP \(bu 2
\fBspeciation_rate_in\fP: the speciation rate of the previous calculation 
.IP \(bu 2
\fBtime_in\fP: the time of the previous calculation 
.IP \(bu 2
\fBfragment_in\fP: bool of whether fragments were used in the previous calculation 
.IP \(bu 2
\fBmetacommunity_reference_in\fP: the metacommunity reference, or 0 for no metacommunity 
.UNINDENT
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B bool compare(long double \fIspeciation_rate_in\fP, long double \fItime_in\fP, bool \fIfragment_in\fP, unsigned long \fImetacommunity_reference_in\fP) 
Compare these set of parameters with the input set. If they match, return true, otherwise return false. 
.sp
.INDENT 7.0
.TP
\fBReturn\fP

.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fBspeciation_rate_in\fP: speciation rate to compare with stored community parameter 
.IP \(bu 2
\fBtime_in\fP: time to compare with stored community parameter 
.IP \(bu 2
\fBfragment_in\fP: if fragments are being used on this database 
.IP \(bu 2
\fBmetacommunity_reference_in\fP: metacommunity reference to compare with stored community parameter 
.UNINDENT
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B bool compare(long double \fIspeciation_rate_in\fP, long double \fItime_in\fP, unsigned long \fImetacommunity_reference_in\fP) 
Compare these set of parameters with the input set. If they match, return true, otherwise return false Overloaded version ignoring the fragments parameter. 
.sp
.INDENT 7.0
.TP
\fBReturn\fP

.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fBspeciation_rate_in\fP: speciation rate to compare with stored community parameter 
.IP \(bu 2
\fBtime_in\fP: time to compare with stored community parameter 
.IP \(bu 2
\fBmetacommunity_reference_in\fP: metacommunity reference to compare with stored community parameter 
.UNINDENT
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B bool compare(unsigned long \fIreference_in\fP) 
Checks if the supplied reference is the same in the community parameter. 
.sp
.INDENT 7.0
.TP
\fBReturn\fP

.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fBreference_in\fP: 
.UNINDENT
.UNINDENT

.UNINDENT
Public Members.INDENT 7.0
.TP
.B unsigned long reference 
.UNINDENT
.INDENT 7.0
.TP
.B long double speciation_rate 
.UNINDENT
.INDENT 7.0
.TP
.B long double time 
.UNINDENT
.INDENT 7.0
.TP
.B bool fragment 
.UNINDENT
.INDENT 7.0
.TP
.B unsigned long metacommunity_reference 
.UNINDENT
.INDENT 7.0
.TP
.B bool updated 
.UNINDENT
.UNINDENT
.SS Struct ConfigException
.INDENT 0.0
.IP \(bu 2
Defined in file_necsim_CustomExceptions.h
.UNINDENT
.SS Inheritance Relationships
.SS Base Type
.INDENT 0.0
.IP \(bu 2
\fBpublic FatalException\fP (struct_FatalException)
.UNINDENT
.SS Struct Documentation
.INDENT 0.0
.TP
.B struct ConfigException 
A structure for all exceptions thrown within config processes. 
.sp
Inherits from FatalException
Public Functions.INDENT 7.0
.TP
.B ConfigException() 
.UNINDENT
.INDENT 7.0
.TP
.B ConfigException(string \fImsg\fP) 
.UNINDENT
.UNINDENT
.SS Struct FatalException
.INDENT 0.0
.IP \(bu 2
Defined in file_necsim_CustomExceptions.h
.UNINDENT
.SS Inheritance Relationships
.SS Base Type
.INDENT 0.0
.IP \(bu 2
\fBpublic std::runtime_error\fP
.UNINDENT
.SS Derived Types
.INDENT 0.0
.IP \(bu 2
\fBpublic ConfigException\fP (struct_ConfigException)
.IP \(bu 2
\fBpublic SpeciesException\fP (struct_SpeciesException)
.UNINDENT
.SS Struct Documentation
.INDENT 0.0
.TP
.B struct FatalException 
This is called any time a fatal exception is called and the program is unwound and ended. 
.sp
Inherits from std::runtime_error
.sp
Subclassed by ConfigException, SpeciesException
Public Functions.INDENT 7.0
.TP
.B FatalException() 
.UNINDENT
.INDENT 7.0
.TP
.B FatalException(string \fImsg\fP) 
.UNINDENT
.UNINDENT
.SS Struct Fragment
.INDENT 0.0
.IP \(bu 2
Defined in file_necsim_Community.h
.UNINDENT
.SS Struct Documentation
.INDENT 0.0
.TP
.B struct Fragment 
Contains the information needed for defining a fragment. Fragments can be detected from the Samplematrix object (which only detects rectangular fragments), or (preferably) is read from an input file. Currently all fragments must be rectangular, although they can be larger than the intended shape if necesssary. 
Public Members.INDENT 7.0
.TP
.B string name 
.UNINDENT
.INDENT 7.0
.TP
.B long x_east 
.UNINDENT
.INDENT 7.0
.TP
.B long x_west 
.UNINDENT
.INDENT 7.0
.TP
.B long y_north 
.UNINDENT
.INDENT 7.0
.TP
.B long y_south 
.UNINDENT
.INDENT 7.0
.TP
.B unsigned long num 
.UNINDENT
.INDENT 7.0
.TP
.B double area 
.UNINDENT
.UNINDENT
.SS Struct MetacommunitiesArray
.INDENT 0.0
.IP \(bu 2
Defined in file_necsim_Community.h
.UNINDENT
.SS Struct Documentation
.INDENT 0.0
.TP
.B struct MetacommunitiesArray 
Contains an array of MetacommunityParameters that have been applied to the coalescence tree. 
Public Functions.INDENT 7.0
.TP
.B void pushBack(unsigned long \fIreference\fP, long double \fIspeciation_rate\fP, unsigned long \fImetacommunity_size\fP) 
Adds an extra CommunityParameters object to the calc_array vector with the supplied variables. 
.sp
.INDENT 7.0
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fBreference\fP: the reference for this set of metacommunity parameters 
.IP \(bu 2
\fBspeciation_rate\fP: the speciation rate used in generation of the metacommunity 
.IP \(bu 2
\fBmetacommunity_size\fP: the size of the metacommunity used 
.UNINDENT
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B void pushBack(MetacommunityParameters \fItmp_param\fP) 
Adds the provided PastMetacommunityParameters object to the calc_array vector. 
.sp
.INDENT 7.0
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fBtmp_param\fP: the set of metacommunity parameters to add 
.UNINDENT
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B unsigned long addNew(long double \fIspeciation_rate\fP, unsigned long \fImetacommunity_size\fP) 
Adds a new metacommunities calculation paremeters reference, with a new unique reference. 
.sp
.INDENT 7.0
.TP
\fBReturn\fP
the new reference number, which should be unique 
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fBspeciation_rate\fP: the speciation rate of the new calculation 
.IP \(bu 2
\fBmetacommunity_size\fP: the size of the metacommunity in the new calculation 
.UNINDENT
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B bool hasPair(long double \fIspeciation_rate\fP, unsigned long \fImetacommunity_size\fP) 
Checks whether the calculation with the supplied variables has already been performed. 
.sp
.INDENT 7.0
.TP
\fBReturn\fP
true if the reference exists in past metacommunity parameters 
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fBspeciation_rate\fP: the speciation rate to check for 
.IP \(bu 2
\fBmetacommunity_size\fP: the size of metacommunity to check for 
.UNINDENT
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B bool hasPair(unsigned long \fIreference\fP) 
Checks whether the calculation with the supplied reference has already been performed. Overloaded version for checking references. 
.sp
.INDENT 7.0
.TP
\fBReturn\fP
true if the reference exists in past metacommunity parameters 
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fBreference\fP: the reference to check for in past metacommunity parameters 
.UNINDENT
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B unsigned long getReference(long double \fIspeciation_rate\fP, unsigned long \fImetacommunity_size\fP) 
Gets the metacommunity reference for the provided parameters, or returns 0 if it doesn\(aqt exist. 
.sp
.INDENT 7.0
.TP
\fBReturn\fP
the metacommunity reference number, or 0 if it doesn\(aqt exist 
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fBspeciation_rate\fP: the metacommunity speciation rate to obtain for 
.IP \(bu 2
\fBmetacommunity_size\fP: the metacommunity size to apply for 
.IP \(bu 2
\fBfragment\fP: bool for checking if fragments were used 
.UNINDENT
.UNINDENT

.UNINDENT
Public Members.INDENT 7.0
.TP
.B vector<MetacommunityParameters> calc_array 
.UNINDENT
.UNINDENT
.SS Struct MetacommunityParameters
.INDENT 0.0
.IP \(bu 2
Defined in file_necsim_Community.h
.UNINDENT
.SS Struct Documentation
.INDENT 0.0
.TP
.B struct MetacommunityParameters 
Contains a set of metacommunity parameters that have been applied, or are to be applied, to the coalescence tree. 
Public Functions.INDENT 7.0
.TP
.B MetacommunityParameters(unsigned long \fIreference_in\fP, long double \fIspeciation_rate_in\fP, unsigned long \fImetacommunity_size_in\fP) 
Constructor for MetacommunityParameters, storing a previously applied metacommunity. 
.sp
.INDENT 7.0
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fBreference_in\fP: the metacommunity reference number 
.IP \(bu 2
\fBspeciation_rate_in\fP: the speciation rate used for metacommunity generation 
.IP \(bu 2
\fBmetacommunity_size_in\fP: size of the tested metacommunity 
.UNINDENT
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B bool compare(long double \fIspeciation_rate_in\fP, unsigned long \fImetacommunity_size_in\fP) 
Compare these set of parameters with the input set. If they match, return true, otherwise return false. 
.sp
.INDENT 7.0
.TP
\fBReturn\fP

.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fBspeciation_rate_in\fP: speciation rate to compare with stored community parameter 
.IP \(bu 2
\fBmetacommunity_size_in\fP: size of the tested metacommunity 
.UNINDENT
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B bool compare(unsigned long \fIreference_in\fP) 
Checks if the supplied reference is the same in the metacommunity reference. 
.sp
.INDENT 7.0
.TP
\fBReturn\fP

.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fBreference_in\fP: the reference to check against 
.UNINDENT
.UNINDENT

.UNINDENT
Public Members.INDENT 7.0
.TP
.B unsigned long reference 
.UNINDENT
.INDENT 7.0
.TP
.B unsigned long metacommunity_size 
.UNINDENT
.INDENT 7.0
.TP
.B long double speciation_rate 
.UNINDENT
.UNINDENT
.SS Struct module_state
.INDENT 0.0
.IP \(bu 2
Defined in file_applyspecmodule.h
.UNINDENT
.SS Struct Documentation
.INDENT 0.0
.TP
.B struct module_state 
Public Members.INDENT 7.0
.TP
.B PyObject *error 
.UNINDENT
.UNINDENT
.SS Struct SectionOption
.INDENT 0.0
.IP \(bu 2
Defined in file_necsim_ConfigFileParser.h
.UNINDENT
.SS Struct Documentation
.INDENT 0.0
.TP
.B struct SectionOption 
A simple container for importing options from a config file. 
Public Functions.INDENT 7.0
.TP
.B SectionOption() 
Default constructor for SectionOption\&. 
.UNINDENT
.INDENT 7.0
.TP
.B string getOption(string \fIrefval\fP) 
Returns the value for the provided reference from within the key. 
.sp
.INDENT 7.0
.TP
\fBReturn\fP
the requested value as a string. Returns string "null" if no reference is found. 
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fBrefval\fP: the reference to obtain the value of 
.UNINDENT
.UNINDENT

.UNINDENT
Public Members.INDENT 7.0
.TP
.B string section 
.UNINDENT
.INDENT 7.0
.TP
.B vector<string> val 
.UNINDENT
.INDENT 7.0
.TP
.B vector<string> refs 
.UNINDENT
Friends.INDENT 7.0
.TP
.B ostream &operator<<(ostream &\fIos\fP, const SectionOption &\fIk\fP) 
Overloading the << operator for outputting to the output stream. 
.sp
.INDENT 7.0
.TP
\fBReturn\fP
os the output stream. 
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fBos\fP: the output stream. 
.IP \(bu 2
\fBk\fP: the KeyOption object. 
.UNINDENT
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B istream &operator>>(istream &\fIis\fP, SectionOption &\fIk\fP) 
Overloading the >> operator for inputting from an input stream. 
.sp
.INDENT 7.0
.TP
\fBReturn\fP
is the input stream 
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fBis\fP: the input stream 
.IP \(bu 2
\fBk\fP: the KeyOption object 
.UNINDENT
.UNINDENT

.UNINDENT
.UNINDENT
.SS Struct SimParameters
.INDENT 0.0
.IP \(bu 2
Defined in file_necsim_SimParameters.h
.UNINDENT
.SS Struct Documentation
.INDENT 0.0
.TP
.B struct SimParameters 
Stores and imports the variables required by the Map object. Used to setting the Map variables in a more elegant way. 
Public Functions.INDENT 7.0
.TP
.B SimParameters() 
Default constructor. 
.UNINDENT
.INDENT 7.0
.TP
.B void importParameters(ConfigOption *\fIconfigOption\fP) 
Links to the provided ConfigOption\&. Assumes that the parameters have already been parsed from the config file. 
.sp
.INDENT 7.0
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fBconfigOption\fP: the pointer to the parsed ConfigOption object 
.UNINDENT
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B void importParameters(const string &\fIconf_in\fP) 
Imports the spatial variables from a path to the config file.. 
.sp
.INDENT 7.0
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fBconfig_in\fP: string of the path to the config file 
.UNINDENT
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B void importParameters() 
Main import of parameters from the config file option. 
.UNINDENT
.INDENT 7.0
.TP
.B void setKeyParameters(const long long &\fItask_in\fP, const long long &\fIseed_in\fP, const string &\fIoutput_directory_in\fP, const unsigned long &\fImax_time_in\fP, unsigned long \fIdesired_specnum_in\fP, const string &\fItimes_file_in\fP) 
Sets the main simulation parameters. 
.sp
.INDENT 7.0
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fBtask_in\fP: the task reference number, used for file referencing 
.IP \(bu 2
\fBseed_in\fP: the seed to set random number generation 
.IP \(bu 2
\fBoutput_directory_in\fP: the output directory 
.IP \(bu 2
\fBmax_time_in\fP: the maximum time to simulate for 
.IP \(bu 2
\fBdesired_specnum_in\fP: the desired number of species to aim towards (currently not functional) 
.IP \(bu 2
\fBtimes_file_in\fP: the file containing a list of temporal sampling points 
.UNINDENT
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B void setSpeciationParameters(const long double &\fIspec_in\fP, bool \fIis_protracted_in\fP, const double &\fImin_speciation_gen_in\fP, const double &\fImax_speciation_gen_in\fP) 
Sets the speciation parameters for the simulation. 
.sp
.INDENT 7.0
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fBspec_in\fP: the speciation rate to use 
.IP \(bu 2
\fBis_protracted_in\fP: if true, simulates as a protracted simulation 
.IP \(bu 2
\fBmin_speciation_gen_in\fP: the minimum speciation generation for protracted simulations 
.IP \(bu 2
\fBmax_speciation_gen_in\fP: the maximum speciation generation for protracted simulations 
.UNINDENT
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B void setDispersalParameters(const string &\fIdispersal_method_in\fP, const double &\fIsigma_in\fP, const double &\fItau_in\fP, const double &\fIm_prob_in\fP, const double &\fIcutoff_in\fP, const double &\fIdispersal_relative_cost_in\fP, bool \fIrestrict_self_in\fP, const string &\fIlandscape_type_in\fP, const string &\fIdispersal_file_in\fP, const string &\fIreproduction_file_in\fP) 
Sets the dispersal parameters for the simulation. 
.sp
.INDENT 7.0
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fBdispersal_method_in\fP: the method of individuals dispersing (normal, fat\-tailed or norm\-uniform) 
.IP \(bu 2
\fBsigma_in\fP: the sigma value for a normal distribution 
.IP \(bu 2
\fBtau_in\fP: the tau value for the fat\-tailed distribution 
.IP \(bu 2
\fBm_prob_in\fP: the probability of uniform dispersal for the norm\-uniform distribution 
.IP \(bu 2
\fBcutoff_in\fP: the maximum dispersal distance for the uniform distribution 
.IP \(bu 2
\fBdispersal_relative_cost_in\fP: the relative cost of dispersing through non\-forest 
.IP \(bu 2
\fBrestrict_self_in\fP: if true, prevents dispersal from the same cell 
.IP \(bu 2
\fBlandscape_type_in\fP: the landscape type (infinite, tiled or closed) 
.IP \(bu 2
\fBdispersal_file_in\fP: a map of dispersal probabilities 
.IP \(bu 2
\fBreproduction_file_in\fP: a map of reproduction probabilities 
.UNINDENT
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B void setPristineMapParameters(const string &\fIpristine_fine_file_map_in\fP, const string &\fIpristine_coarse_map_file_in\fP, const double &\fIgen_since_pristine_in\fP, const double &\fIhabitat_change_rate_in\fP) 
Sets the pristine map parameters for the simulation. 
.sp
.INDENT 7.0
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fBpristine_fine_file_map_in\fP: the fine resolution pristine file 
.IP \(bu 2
\fBpristine_coarse_map_file_in\fP: the coarse resolution pristine file 
.IP \(bu 2
\fBgen_since_pristine_in\fP: the number of generations since the pristine state was achieved 
.IP \(bu 2
\fBhabitat_change_rate_in\fP: the rate of habitat change towards the pristine state 
.UNINDENT
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B void setMapParameters(const string &\fIfine_map_file_in\fP, const string &\fIcoarse_map_file_in\fP, const string &\fIsample_mask_file_in\fP, const unsigned long &\fIgrid_x_size_in\fP, const unsigned long &\fIgrid_y_size_in\fP, const unsigned long &\fIsample_x_size_in\fP, const unsigned long &\fIsample_y_size_in\fP, const unsigned long &\fIsample_x_offset_in\fP, const unsigned long &\fIsample_y_offset_in\fP, const unsigned long &\fIfine_map_x_size_in\fP, const unsigned long &\fIfine_map_y_size_in\fP, const unsigned long &\fIfine_map_x_offset_in\fP, const unsigned long &\fIfine_map_y_offset_in\fP, const unsigned long &\fIcoarse_map_x_size_in\fP, const unsigned long &\fIcoarse_map_y_size_in\fP, const unsigned long &\fIcoarse_map_x_offset_in\fP, const unsigned long &\fIcoarse_map_y_offset_in\fP, const unsigned long &\fIcoarse_map_scale_in\fP, const unsigned long &\fIdeme_in\fP, const double &\fIdeme_sample_in\fP, bool \fIuses_spatial_sampling_in\fP) 
Sets the map parameters for the simulation. 
.sp
.INDENT 7.0
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fBfine_map_file_in\fP: the fine resolution density map 
.IP \(bu 2
\fBcoarse_map_file_in\fP: the coarse resolution density map 
.IP \(bu 2
\fBsample_mask_file_in\fP: the spatial sampling mask 
.IP \(bu 2
\fBgrid_x_size_in\fP: the x dimension of the grid 
.IP \(bu 2
\fBgrid_y_size_in\fP: the y dimension of the grid 
.IP \(bu 2
\fBsample_x_size_in\fP: the x dimension of the sample mask 
.IP \(bu 2
\fBsample_y_size_in\fP: the y dimension of the sample mask 
.IP \(bu 2
\fBsample_x_offset_in\fP: the x offset of the sample mask from the grid 
.IP \(bu 2
\fBsample_y_offset_in\fP: the y offset of the sample mask from the grid 
.IP \(bu 2
\fBfine_map_x_size_in\fP: the x dimension of the fine map 
.IP \(bu 2
\fBfine_map_y_size_in\fP: the y dimension of the fine map 
.IP \(bu 2
\fBfine_map_x_offset_in\fP: the x offset of the fine map from the sample mask 
.IP \(bu 2
\fBfine_map_y_offset_in\fP: the y offset of the fine map from the sample mask 
.IP \(bu 2
\fBcoarse_map_x_size_in\fP: the x dimension of the coarse map 
.IP \(bu 2
\fBcoarse_map_y_size_in\fP: the y dimension of the coarse map 
.IP \(bu 2
\fBcoarse_map_x_offset_in\fP: the x offset of the coarse map from the fine map 
.IP \(bu 2
\fBcoarse_map_y_offset_in\fP: the y offset of the coarse map from the fine map 
.IP \(bu 2
\fBcoarse_map_scale_in\fP: the scale of the coarse map compared to the fine map 
.IP \(bu 2
\fBdeme_in\fP: the number of individuals per cell 
.IP \(bu 2
\fBdeme_sample_in\fP: the proportion of individuals to sample from each cell 
.IP \(bu 2
\fBuses_spatial_sampling_in\fP: if the sample mask denotes differing spatial sampling proportions 
.UNINDENT
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B bool setPristine(unsigned int \fIn\fP) 
Alters the pristine parameters to the configuration matching the input number. If no configuration option exists for this number, bPristine will be set to true. 
.sp
.INDENT 7.0
.TP
\fBReturn\fP
bool true if we need to re\-import the maps (i.e. the pristine maps have changed between updates) 
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fBn\fP: the pristine map number to check. 
.UNINDENT
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B void printVars() 
Prints selected important variables to the terminal. 
.UNINDENT
.INDENT 7.0
.TP
.B void setMetacommunityParameters(const unsigned long &\fImetacommunity_size\fP, const double &\fIspeciation_rate\fP, const unsigned long &\fIseed\fP, const unsigned long &\fIjob\fP) 
.UNINDENT
Public Members.INDENT 7.0
.TP
.B string fine_map_file 
.UNINDENT
.INDENT 7.0
.TP
.B string coarse_map_file 
.UNINDENT
.INDENT 7.0
.TP
.B string output_directory 
.UNINDENT
.INDENT 7.0
.TP
.B string pristine_fine_map_file 
.UNINDENT
.INDENT 7.0
.TP
.B string pristine_coarse_map_file 
.UNINDENT
.INDENT 7.0
.TP
.B string sample_mask_file 
.UNINDENT
.INDENT 7.0
.TP
.B long long the_task = {} 
.UNINDENT
.INDENT 7.0
.TP
.B long long the_seed = {} 
.UNINDENT
.INDENT 7.0
.TP
.B unsigned long grid_x_size = {} 
.UNINDENT
.INDENT 7.0
.TP
.B unsigned long grid_y_size = {} 
.UNINDENT
.INDENT 7.0
.TP
.B unsigned long sample_x_size = {} 
.UNINDENT
.INDENT 7.0
.TP
.B unsigned long sample_y_size = {} 
.UNINDENT
.INDENT 7.0
.TP
.B unsigned long sample_x_offset = {} 
.UNINDENT
.INDENT 7.0
.TP
.B unsigned long sample_y_offset = {} 
.UNINDENT
.INDENT 7.0
.TP
.B unsigned long fine_map_x_size = {} 
.UNINDENT
.INDENT 7.0
.TP
.B unsigned long fine_map_y_size = {} 
.UNINDENT
.INDENT 7.0
.TP
.B unsigned long fine_map_x_offset = {} 
.UNINDENT
.INDENT 7.0
.TP
.B unsigned long fine_map_y_offset = {} 
.UNINDENT
.INDENT 7.0
.TP
.B unsigned long coarse_map_x_size = {} 
.UNINDENT
.INDENT 7.0
.TP
.B unsigned long coarse_map_y_size = {} 
.UNINDENT
.INDENT 7.0
.TP
.B unsigned long coarse_map_x_offset = {} 
.UNINDENT
.INDENT 7.0
.TP
.B unsigned long coarse_map_y_offset = {} 
.UNINDENT
.INDENT 7.0
.TP
.B unsigned long coarse_map_scale = {} 
.UNINDENT
.INDENT 7.0
.TP
.B unsigned long desired_specnum = {} 
.UNINDENT
.INDENT 7.0
.TP
.B double dispersal_relative_cost = {} 
.UNINDENT
.INDENT 7.0
.TP
.B unsigned long deme = {} 
.UNINDENT
.INDENT 7.0
.TP
.B double deme_sample = {} 
.UNINDENT
.INDENT 7.0
.TP
.B long double spec = {} 
.UNINDENT
.INDENT 7.0
.TP
.B double sigma = {} 
.UNINDENT
.INDENT 7.0
.TP
.B unsigned long max_time = {} 
.UNINDENT
.INDENT 7.0
.TP
.B double gen_since_pristine = {} 
.UNINDENT
.INDENT 7.0
.TP
.B double habitat_change_rate = {} 
.UNINDENT
.INDENT 7.0
.TP
.B double tau = {} 
.UNINDENT
.INDENT 7.0
.TP
.B string dispersal_method 
.UNINDENT
.INDENT 7.0
.TP
.B double m_prob = {} 
.UNINDENT
.INDENT 7.0
.TP
.B double cutoff = {} 
.UNINDENT
.INDENT 7.0
.TP
.B bool restrict_self = {} 
.UNINDENT
.INDENT 7.0
.TP
.B string times_file 
.UNINDENT
.INDENT 7.0
.TP
.B ConfigOption configs 
.UNINDENT
.INDENT 7.0
.TP
.B bool is_pristine = {} 
.UNINDENT
.INDENT 7.0
.TP
.B bool uses_spatial_sampling = {} 
.UNINDENT
.INDENT 7.0
.TP
.B string landscape_type 
.UNINDENT
.INDENT 7.0
.TP
.B bool is_protracted = {} 
.UNINDENT
.INDENT 7.0
.TP
.B double min_speciation_gen = {} 
.UNINDENT
.INDENT 7.0
.TP
.B double max_speciation_gen = {} 
.UNINDENT
.INDENT 7.0
.TP
.B string dispersal_file 
.UNINDENT
.INDENT 7.0
.TP
.B string reproduction_file 
.UNINDENT
Friends.INDENT 7.0
.TP
.B ostream &operator<<(ostream &\fIos\fP, const SimParameters &\fIm\fP) 
Overloading the << operator for outputting to the output stream. 
.sp
.INDENT 7.0
.TP
\fBReturn\fP
os the output stream. 
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fBos\fP: the output stream. 
.IP \(bu 2
\fBm\fP: the SimParameters object. 
.UNINDENT
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B istream &operator>>(istream &\fIis\fP, SimParameters &\fIm\fP) 
Overloading the >> operator for inputting from an input stream. 
.sp
.INDENT 7.0
.TP
\fBReturn\fP
is the input stream 
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fBis\fP: the input stream 
.IP \(bu 2
\fBm\fP: the mapvars object 
.UNINDENT
.UNINDENT

.UNINDENT
.UNINDENT
.SS Struct SpeciesException
.INDENT 0.0
.IP \(bu 2
Defined in file_necsim_CustomExceptions.h
.UNINDENT
.SS Inheritance Relationships
.SS Base Type
.INDENT 0.0
.IP \(bu 2
\fBpublic FatalException\fP (struct_FatalException)
.UNINDENT
.SS Struct Documentation
.INDENT 0.0
.TP
.B struct SpeciesException 
An exception thrown whenever a non\-fatal Species exception is thrown. 
.sp
Inherits from FatalException
Public Functions.INDENT 7.0
.TP
.B SpeciesException() 
Throws a runtime_error with a custom message indicating source. 
.UNINDENT
.INDENT 7.0
.TP
.B SpeciesException(string \fImsg\fP) 
Overloaded runtime_error call which provides error message parsing. 
.sp
.INDENT 7.0
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fBmsg\fP: the message to be passed to the runtime_error 
.UNINDENT
.UNINDENT

.UNINDENT
.UNINDENT
.SS Class Cell
.INDENT 0.0
.IP \(bu 2
Defined in file_necsim_SimulateDispersal.h
.UNINDENT
.SS Class Documentation
.INDENT 0.0
.TP
.B class Cell 
Simple structure containing the x and y positions of a cell. 
Public Functions.INDENT 7.0
.TP
.B Cell &operator=(Cell const &\fIc\fP) 
Overloading equality operator. 
.sp
.INDENT 7.0
.TP
\fBReturn\fP
the cell with the new values 
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fBc\fP: the Cell containing the values to overload 
.UNINDENT
.UNINDENT

.UNINDENT
Public Members.INDENT 7.0
.TP
.B long x 
.UNINDENT
.INDENT 7.0
.TP
.B long y 
.UNINDENT
.UNINDENT
.SS Class CommunitiesArray
.INDENT 0.0
.IP \(bu 2
Defined in file_necsim_Community.h
.UNINDENT
.SS Class Documentation
.INDENT 0.0
.TP
.B class CommunitiesArray 
A structure for containing an array of previous calculation information, including which fragments have been already calculated for. 
Public Functions.INDENT 7.0
.TP
.B void pushBack(unsigned long \fIreference\fP, long double \fIspeciation_rate\fP, long double \fItime\fP, bool \fIfragment\fP, unsigned long \fImetacommunity_reference\fP) 
Adds an extra CommunityParameters object to the calc_array vector with the supplied variables. 
.sp
.INDENT 7.0
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fBreference\fP: the reference for this set of community parameters 
.IP \(bu 2
\fBspeciation_rate\fP: the speciation rate of the past calculation 
.IP \(bu 2
\fBtime\fP: the time of the past calculation 
.IP \(bu 2
\fBfragment\fP: bool of whether fragments were used in the past calculation 
.IP \(bu 2
\fBmetacommunity_reference\fP: reference for the metacommunity parameters, or 0 if no metacommunity 
.UNINDENT
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B void pushBack(CommunityParameters \fItmp_param\fP) 
Adds the provided CommunityParameters object to the calc_array vector. 
.sp
.INDENT 7.0
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fBtmp_param\fP: the set of community parameters to add 
.UNINDENT
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B CommunityParameters &addNew(long double \fIspeciation_rate\fP, long double \fItime\fP, bool \fIfragment\fP, unsigned long \fImetacommunity_reference\fP) 
Adds a new communities calculation paremeters reference, with a new unique reference. 
.sp
.INDENT 7.0
.TP
\fBReturn\fP
reference to the new CommunityParameters object added 
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fBspeciation_rate\fP: the speciation rate of the new calculation 
.IP \(bu 2
\fBtime\fP: the time used in the new calculation 
.IP \(bu 2
\fBfragment\fP: true if fragments were used in the new calculation 
.UNINDENT
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B bool hasPair(long double \fIspeciation_rate\fP, double \fItime\fP, bool \fIfragment\fP, unsigned long \fImetacommunity_reference\fP) 
Checks whether the calculation with the supplied variables has already been performed. 
.sp
.INDENT 7.0
.TP
\fBNote\fP

.TP
\fBReturn\fP
true if the reference exists in past community parameters 
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fBspeciation_rate\fP: the speciation rate to check for 
.IP \(bu 2
\fBtime\fP: the time to check for 
.IP \(bu 2
\fBfragment\fP: bool for checking if fragments were used 
.UNINDENT
.UNINDENT

.UNINDENT
Public Members.INDENT 7.0
.TP
.B vector<CommunityParameters> calc_array 
.UNINDENT
.UNINDENT
.SS Class Community
.INDENT 0.0
.IP \(bu 2
Defined in file_necsim_Community.h
.UNINDENT
.SS Inheritance Relationships
.SS Derived Type
.INDENT 0.0
.IP \(bu 2
\fBpublic Metacommunity\fP (class_Metacommunity)
.UNINDENT
.SS Class Documentation
.INDENT 0.0
.TP
.B class Community 
A class to contain the tree object lineages and reconstructing the coalescence tree. Contains functions for calculating the number of species for a given speciation rate, outputting spatial data and generating species abundance distributions. Requires a link to the SQLite database from simulation output, and produces results within the same database file. 
.sp
Subclassed by Metacommunity
Public Functions.INDENT 7.0
.TP
.B Community(Row<TreeNode> *\fIr\fP) 
Contructor for the community linking to Treenode list. 
.sp
.INDENT 7.0
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fBr\fP: Row of TreeNode objects to link to. 
.UNINDENT
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B Community() 
Default constructor. 
.UNINDENT
.INDENT 7.0
.TP
.B ~Community() 
Default destructor. 
.UNINDENT
.INDENT 7.0
.TP
.B void setList(Row<TreeNode> *\fIl\fP) 
Set the nodes object to the input Row of Treenode objects. 
.sp
.INDENT 7.0
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fBl\fP: the Row of Treenode objects to link to. 
.UNINDENT
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B void setDatabase(sqlite3 *\fIdbin\fP) 
Sets the database object for the sqlite functions. 
.sp
.INDENT 7.0
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fBdbin\fP: the sqlite3 input database. 
.UNINDENT
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B bool hasImportedData() 
Get the boolean of whether the data has been imported yet. 
.sp
.INDENT 7.0
.TP
\fBReturn\fP
true if database has been imported. 
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B long double getMinimumSpeciation() 
Get the minimum speciation rate the simulation was originally run with. This value is read in from the SIMULATION_PARAMETERS table in the database file. 
.sp
.INDENT 7.0
.TP
\fBReturn\fP
the minimum speciation rate. 
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B void importSamplemask(string \fIsSamplemask\fP) 
Imports the samplemask if it hasn\(aqt already been imported. 
.sp
.INDENT 7.0
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fBsSamplemask\fP: the path to the samplemask file. 
.UNINDENT
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B unsigned long countSpecies() 
Counts the number of species that have speciated currently on the tree. 
.sp
.INDENT 7.0
.TP
\fBReturn\fP
the number of species 
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B unsigned long calcSpecies() 
Calculate the number of species in the list for the parameters in the current_community_parameters object. This is the main function which reconstructs the coalescence tree. Each Treenode object will end having its existence value set correctly after a call to this function. 
.sp
.INDENT 7.0
.TP
\fBReturn\fP
the number of species present. 
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B void addSpecies(unsigned long &\fIspecies_count\fP, TreeNode *\fItreenode\fP, set<unsigned long> &\fIspecies_list\fP) 
Speciates TreeNode and updates the species count. 
.sp
For systems which are not using a metacommunity, this function will just perform basic speciation.
.sp
.INDENT 7.0
.TP
\fBNote\fP
species_list is not updated in unless the function is overridden for metacommunity application. 
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fBspecies_count\fP: the total number of species currently in the community 
.IP \(bu 2
\fBtreenode\fP: pointer to the TreeNode object for this lineage 
.IP \(bu 2
\fBspecies_list\fP: the set of all species ids. 
.UNINDENT
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B void calcSpeciesAbundance() 
Calculates the species abundance of the dataset. The species abundances will be with rOut after a call do this function. If a samplemask has been applied, only lineages which originally existed in the samplemask will be counted. 
.UNINDENT
.INDENT 7.0
.TP
.B void resetTree() 
Resets the entire tree. Sets existance to false, speciation to false and removes any species ID. 
.UNINDENT
.INDENT 7.0
.TP
.B void detectDimensions(string \fIdb\fP) 
This function detects the maximum x and y values of the sql database. This allows for the dimensions before opening the map file. 
.sp
.INDENT 7.0
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fBdb\fP: the path to the input database to read from. 
.UNINDENT
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B void openSqlConnection(string \fIinputfile\fP) 
Opens the connection to the sql database file Note that this imports the database to memory, so functionality should be changed for extremely large database files. 
.sp
.INDENT 7.0
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fBinputfile\fP: the sql database output from a NECSim simulation. 
.UNINDENT
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B void setInternalDatabase() 
Opens a connection to an in\-memory database. This will eventually be written to the output file. 
.UNINDENT
.INDENT 7.0
.TP
.B void internalOption() 
Internally sets the file referencing, data import and sql connection flags to true, for allowing checks to pass from internal object creation (so no external files are needed) 
.UNINDENT
.INDENT 7.0
.TP
.B void importData(string \fIinputfile\fP) 
Imports the data from the desired SQL database object into the array. 
.sp
.INDENT 7.0
.TP
\fBNote\fP
Opens the sql connection if it has not already been opened. 
.TP
\fBNote\fP
If nodes is not of length 0, this function does nothing. This is so that any in\-memory data is not overwritten. 
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fBinputfile\fP: the path to the input SQLite database. 
.UNINDENT
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B void importSimParameters(string \fIfile\fP) 
Imports the simulation parameters by reading the SIMULATION_PARAMETERS table in the provided file. This imports the grid_x_size, grid_y_size (which should also be the sample map dimensions) and the minimum speciation rate. 
.sp
.INDENT 7.0
.TP
\fBNote\fP
Opens the sql connection if it has not already been opened.
.TP
\fBNote\fP
If bDataImport has already been set, no operation is performed.
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fBfile\fP: the sqlite database simulation output which will be used for coalescence tree generation. 
.UNINDENT
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B void getMaxSpeciesAbundancesID() 
Gets the maximum species abundance ID from the database and stores it in the max_species_id variable. 
.sp
.INDENT 7.0
.TP
\fBNote\fP
Does not check for SPECIES_ABUNDANCES existence and will throw an error if it cannot access it 
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B Row<unsigned long> *getCumulativeAbundances() 
Changes the rOut object so that values represent cummulative species abundances. 
.sp
Allows binary sort on rOut (much faster) and the previous rOut value can be obtained by value = rOut[i] \- rOut[i\-1] .INDENT 7.0
.TP
\fBReturn\fP
pointer to sorted Row of species abundances 
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B Row<unsigned long> getRowOut() 
Returns the row_out object, which should contain species abundances or cumulative abundances. 
.sp
.INDENT 7.0
.TP
\fBNote\fP
Does not recalculate species abundances, so if getCumulativeAbundances has been called, will return the cumulative species abundances instead. 
.TP
\fBNote\fP
Returns a copy, so could cause problems for extremely large simulations with immense numbers of species. 
.TP
\fBReturn\fP
row_out, the species abundances, or the cumulative abundances if getCumulativeAbundances has been called 
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B unsigned long getSpeciesNumber() 
Gets the number of species in the most recent calculation. 
.sp
.INDENT 7.0
.TP
\fBReturn\fP
the number of species in the most recent calculation 
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B void getMaxFragmentAbundancesID() 
Gets the maximum fragment abundance ID from the database and stores it in the max_fragment_id variable. 
.sp
.INDENT 7.0
.TP
\fBNote\fP
Does not check for FRAGMENT_ABUNDANCES existence and will throw an error if it cannot access it 
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B void getMaxSpeciesLocationsID() 
Gets the maximum species locations ID from the database and stores it in the max_locations_id variable. 
.sp
.INDENT 7.0
.TP
\fBNote\fP
Does not check for SPECIES_LOCATIONS existence and will throw an error if it cannot access it 
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B void setProtractedParameters(double \fImax_speciation_gen_in\fP) 
Sets the protracted parameters for application of protracted speciation. 
.sp
.INDENT 7.0
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fBmax_speciation_gen\fP: the maximum number of generations a lineage can exist for before speciating 
.UNINDENT
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B void setProtractedParameters(const double &\fImax_speciation_gen_in\fP, const double &\fImix_speciation_gen_in\fP) 
Sets the protracted parameters for application of protracted speciation. 
.sp
This overloaded version is for setting protracted parameters before a full simulation has been outputted (i.e. immediately after completion of the simulation).
.sp
.INDENT 7.0
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fBmax_speciation_gen_in\fP: the maximum number of generations a lineage can exist for before speciating 
.IP \(bu 2
\fBmin_speciation_gen_in\fP: the minimum number of generations a lineage must exist before speciating. 
.UNINDENT
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B void overrideProtractedParameters(const double &\fImin_speciation_gen_in\fP, const double &\fImax_speciation_gen_in\fP) 
.UNINDENT
.INDENT 7.0
.TP
.B void setProtracted(bool \fIprotracted_in\fP) 
Sets the protracted boolean to the input. 
.sp
.INDENT 7.0
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fBprotracted_in\fP: the protracted boolean to set 
.UNINDENT
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B void createDatabase() 
Creates a new table in the database file and outputs the database object to the same file as the input file. Calculates the community structure for the set of community parameters in current_community_parameters. 
.sp
The new SPECIES_ABUNDANCES table contains the species abundance distribution for the whole samplemask. A similar tabe FRAGMENT_ABUNDANCES is generated by createFragmentDatabase() if specified via the command line parameters. 
.UNINDENT
.INDENT 7.0
.TP
.B void generateCoalescenceTree() 
Calls calcSpecies and calcSpeciesAbundances to generate the coalescence tree and calculate species abundances. 
.UNINDENT
.INDENT 7.0
.TP
.B void outputSpeciesAbundances() 
Outputs the species abundances into the database. 
.UNINDENT
.INDENT 7.0
.TP
.B bool checkCalculationsPerformed(long double \fIspeciation_rate\fP, double \fItime\fP, bool \fIfragments\fP, unsigned long \fImetacommunity_size\fP, long double \fImetacommunity_speciation_rate\fP) 
Checks if calculations with the given set of parameters has already been performed. 
.sp
.INDENT 7.0
.TP
\fBReturn\fP

.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fBspeciation_rate\fP: the speciation rate to check for 
.IP \(bu 2
\fBtime\fP: the time to check for 
.IP \(bu 2
\fBfragments\fP: if true, checks fragments have been used 
.IP \(bu 2
\fBmetacommunity_size\fP: the metacommunity size to check for 
.IP \(bu 2
\fBmetacommunity_speciation_rate\fP: the metacommunity speciation rate to check for 
.UNINDENT
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B void addCalculationPerformed(long double \fIspeciation_rate\fP, double \fItime\fP, bool \fIfragments\fP, unsigned long \fImetacommunity_size\fP, long double \fImetacommunity_speciation_rate\fP) 
Adds a performed calculation to the lists of calculations. Also sets the current_community_parameters pointer to the set of parameters to be applied. 
.sp
.INDENT 7.0
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fBspeciation_rate\fP: the speciation rate of the performed calculation 
.IP \(bu 2
\fBtime\fP: the time of the performed calculation 
.IP \(bu 2
\fBfragments\fP: if true, fragments were used 
.IP \(bu 2
\fBmetacommunity_size\fP: the metacommunity size of the performed calculation 
.IP \(bu 2
\fBmetacommunity_speciation_rate\fP: the metacommunity speciation rate of the performed calculation 
.UNINDENT
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B void createFragmentDatabase(const Fragment &\fIf\fP) 
Creates a new table in the database file and outputs the database object to the same file as the input file. Essentially creates a species abundance distribution (as in createDatabase()), but for the specified fragment within the samplemask. 
.sp
.INDENT 7.0
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fBf\fP: the Fragment to sample from. 
.UNINDENT
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B void exportDatabase() 
Output the database from memory to the database file. Most of the time, it is desirable for the outputfile to be the same path as the input file and will write to the same object. 
.sp
.INDENT 7.0
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fBoutputfile\fP: the path to the output file. 
.UNINDENT
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B bool checkSpeciesLocationsReference() 
Checks for the current CommunityParameters reference in the SPECIES_LOCATIONS table. 
.sp
.INDENT 7.0
.TP
\fBReturn\fP
true if the reference exists in the SPECIES_LOCATIONS table 
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B bool checkSpeciesAbundancesReference() 
Checks for the current CommunityParameters reference in the SPECIES_ABUNDANCES table. 
.sp
.INDENT 7.0
.TP
\fBReturn\fP
return true if the reference exists in the SPECIES_LOCATIONS table 
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B void recordSpatial() 
Record the full spatial data. Creates a new table, SPECIES_LOCATIONS containing every species and their parameters. This allows for more in\-depth analysis to be performed if necessary. 
.UNINDENT
.INDENT 7.0
.TP
.B void calcFragments(string \fIfragment_file\fP) 
Calculates the limits of each fragment in the sample map and adds it to the vector of fragments. If the fragment_file is null, then the program will attempt to calculate fragments from the map. 
.sp
.INDENT 7.0
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fBfragment_file\fP: the fragment file to read from. 
.UNINDENT
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B void applyFragments() 
Calculate species abundances for each fragment, and call createFragmentDatabase() for each Fragment\&. 
.UNINDENT
.INDENT 7.0
.TP
.B void getPreviousCalcs() 
Gets the previous calculations that have already been performed. 
.UNINDENT
.INDENT 7.0
.TP
.B vector<unsigned long> getUniqueCommunityRefs() 
Gets the unique community references from the SQL database. 
.sp
.INDENT 7.0
.TP
\fBReturn\fP
a vector containing the unique references 
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B vector<unsigned long> getUniqueMetacommunityRefs() 
Gets the unique metacommunity reference from the SQL database. 
.sp
.INDENT 7.0
.TP
\fBReturn\fP
a vector containing the unique references 
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B void writeNewCommunityParameters() 
Write all performed calculations to the output database. 
.UNINDENT
.INDENT 7.0
.TP
.B void writeNewMetacommuntyParameters() 
Write all performed calculations to the output database. 
.UNINDENT
.INDENT 7.0
.TP
.B void updateCommunityParameters() 
Updates the fragments tag on those simulations which now have had fragments added. 
.UNINDENT
.INDENT 7.0
.TP
.B void writeSpeciationRates() 
Prints speciation rates to terminal. 
.UNINDENT
.INDENT 7.0
.TP
.B void calculateTree() 
Calculates the coalescence tree for each set of parameters in speciation_parameters;. 
.UNINDENT
.INDENT 7.0
.TP
.B void output() 
Outputs the data to the SQL database. 
.sp
.INDENT 7.0
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fBfile_name\fP: the path to the sql database to output to 
.UNINDENT
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B void printEndTimes(time_t \fItStart\fP, time_t \fItEnd\fP) 
Prints the application times. 
.sp
.INDENT 7.0
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fBtStart\fP: the start time 
.IP \(bu 2
\fBtEnd\fP: the end time 
.UNINDENT
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B void apply(SpecSimParameters *\fIsp\fP) 
Apply the given speciation parameters to the coalescence tree. Overridden for metacommunity application. 
.sp
.INDENT 7.0
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fBsp\fP: speciation parameters to apply, including speciation rate, times and spatial sampling procedure 
.UNINDENT
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B void doApplication(SpecSimParameters *\fIsp\fP) 
Creates the coalescence tree for the given speciation parameters. 
.sp
.INDENT 7.0
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fBsp\fP: speciation parameters to apply, including speciation rate, times and spatial sampling procedure 
.UNINDENT
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B void doApplication(SpecSimParameters *\fIsp\fP, Row<TreeNode> *\fIdata\fP) 
Creates the coalescence tree for the given speciation parameters. 
.sp
.INDENT 7.0
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fBsp\fP: speciation parameters to apply, including speciation rate, times and spatial sampling procedure 
.IP \(bu 2
\fBdata\fP: the Row of TreeNodes that contains the coalescence tree. 
.UNINDENT
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B void doApplicationInternal(SpecSimParameters *\fIsp\fP, Row<TreeNode> *\fIdata\fP) 
Creates the coalescence tree for the given speciation parameters, using internal file referencing to avoid any actual file creation. 
.sp
.INDENT 7.0
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fBsp\fP: speciation parameters to apply, including speciation rate, times and spatial sampling procedure 
.IP \(bu 2
\fBdata\fP: the Row of TreeNodes that contains the coalescence tree. 
.UNINDENT
.UNINDENT

.UNINDENT
Protected Attributes.INDENT 7.0
.TP
.B bool bMem 
.UNINDENT
.INDENT 7.0
.TP
.B bool bFileSet 
.UNINDENT
.INDENT 7.0
.TP
.B sqlite3 *database 
.UNINDENT
.INDENT 7.0
.TP
.B sqlite3 *outdatabase 
.UNINDENT
.INDENT 7.0
.TP
.B bool bSqlConnection 
.UNINDENT
.INDENT 7.0
.TP
.B Row<TreeNode> *nodes 
.UNINDENT
.INDENT 7.0
.TP
.B Row<unsigned long> row_out 
.UNINDENT
.INDENT 7.0
.TP
.B unsigned long iSpecies 
.UNINDENT
.INDENT 7.0
.TP
.B bool bSample 
.UNINDENT
.INDENT 7.0
.TP
.B bool bDataImport 
.UNINDENT
.INDENT 7.0
.TP
.B Samplematrix samplemask 
.UNINDENT
.INDENT 7.0
.TP
.B vector<Fragment> fragments 
.UNINDENT
.INDENT 7.0
.TP
.B CommunityParameters *current_community_parameters 
.UNINDENT
.INDENT 7.0
.TP
.B long double min_spec_rate 
.UNINDENT
.INDENT 7.0
.TP
.B unsigned long grid_x_size 
.UNINDENT
.INDENT 7.0
.TP
.B unsigned long grid_y_size 
.UNINDENT
.INDENT 7.0
.TP
.B unsigned long samplemask_x_size 
.UNINDENT
.INDENT 7.0
.TP
.B unsigned long samplemask_y_size 
.UNINDENT
.INDENT 7.0
.TP
.B unsigned long samplemask_x_offset 
.UNINDENT
.INDENT 7.0
.TP
.B unsigned long samplemask_y_offset 
.UNINDENT
.INDENT 7.0
.TP
.B CommunitiesArray past_communities 
.UNINDENT
.INDENT 7.0
.TP
.B MetacommunitiesArray past_metacommunities 
.UNINDENT
.INDENT 7.0
.TP
.B bool protracted 
.UNINDENT
.INDENT 7.0
.TP
.B double min_speciation_gen 
.UNINDENT
.INDENT 7.0
.TP
.B double max_speciation_gen 
.UNINDENT
.INDENT 7.0
.TP
.B double applied_min_speciation_gen 
.UNINDENT
.INDENT 7.0
.TP
.B double applied_max_speciation_gen 
.UNINDENT
.INDENT 7.0
.TP
.B unsigned long max_species_id 
.UNINDENT
.INDENT 7.0
.TP
.B unsigned long max_fragment_id 
.UNINDENT
.INDENT 7.0
.TP
.B unsigned long max_locations_id 
.UNINDENT
.INDENT 7.0
.TP
.B SpecSimParameters *spec_sim_parameters 
.UNINDENT
.UNINDENT
.SS Class ConfigOption
.INDENT 0.0
.IP \(bu 2
Defined in file_necsim_ConfigFileParser.h
.UNINDENT
.SS Class Documentation
.INDENT 0.0
.TP
.B class ConfigOption 
Config option class to store and import options from a file. 
Public Functions.INDENT 7.0
.TP
.B ConfigOption() 
default construtor for ConfigOption 
.UNINDENT
.INDENT 7.0
.TP
.B void setConfig(const string &\fIfile\fP, bool \fImain\fP, bool \fIfull_parse\fP = false) 
Sets the config file the specified string. A boolean is also provided, set equal to true if this is the main command line import. This causes the deletion of the first few command line options after import. 
.sp
.INDENT 7.0
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fBfile\fP: the target config file (in .txt format). 
.IP \(bu 2
\fBmain\fP: boolean of if this is the main command line import. 
.IP \(bu 2
\fBfull_parse\fP: sets bFullParse to provided value 
.UNINDENT
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B void parseConfig() 
Reads a config file of a specific configuration. Each line must be a set of values related to the object determined by ref=\(aqobject\(aq. Each key must have the form key=value, which will be read as a string into a KeyOption structure. 
.UNINDENT
.INDENT 7.0
.TP
.B vector<SectionOption> getSectionOptions() 
Returns the vector of key options imported from the file. 
.sp
.INDENT 7.0
.TP
\fBReturn\fP
vector of key options 
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B void setSectionOption(string \fIsection\fP, string \fIreference\fP, string \fIvalue\fP) 
Sets the section option with the provided section, key and value. 
.sp
.INDENT 7.0
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fBsection\fP: the section name 
.IP \(bu 2
\fBreference\fP: the reference key for the parameter 
.IP \(bu 2
\fBvalue\fP: the value of the key 
.UNINDENT
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B SectionOption operator[](int \fIindex\fP) 
Gets the SectionOption at the provided index. 
.sp
.INDENT 7.0
.TP
\fBReturn\fP
the section option at the index 
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fBindex\fP: the index of the SectionOption to obtain, must be less than configs.size() 
.UNINDENT
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B unsigned int getSectionOptionsSize() 
Gets the size of the key options vector. 
.sp
.INDENT 7.0
.TP
\fBReturn\fP
the size of the configuration vector. 
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B vector<string> getSections() 
Gets the sections contained in the SectionOptions object. 
.sp
.INDENT 7.0
.TP
\fBReturn\fP
A vector of the section names. 
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B bool hasSection(const string &\fIsec\fP) 
Checks whether the config option has the specified section. 
.sp
.INDENT 7.0
.TP
\fBReturn\fP
true if the section has been found 
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fBsec\fP: the section name to check for 
.UNINDENT
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B vector<string> getSectionValues(string \fIsec\fP) 
Gets all values within a section. 
.sp
Throws a Config_Exception if the section is not found. .INDENT 7.0
.TP
\fBReturn\fP
a vector of the section\(aqs values. 
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fBsec\fP: the section to find values for 
.UNINDENT
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B string getSectionOptions(string \fIsection\fP, string \fIref\fP) 
Returns a specific value for a particular key options and reference. 
.sp
.INDENT 7.0
.TP
\fBReturn\fP
the string at the correct place in KeyOptions.val 
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fBsection\fP: the section to match 
.IP \(bu 2
\fBref\fP: the reference to match 
.UNINDENT
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B string getSectionOptions(string \fIsection\fP, string \fIref\fP, string \fIdef\fP) 
Returns a specific value for a particular key options and reference. This overloaded version of the function returns the default value def when no match is found. 
.sp
.INDENT 7.0
.TP
\fBReturn\fP
the string at the correct place in KeyOptions.val 
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fBsection\fP: the section to match 
.IP \(bu 2
\fBref\fP: the reference to match 
.IP \(bu 2
\fBdef\fP: the default value to return if no match is found 
.UNINDENT
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B int importConfig(vector<string> &\fIcomargs\fP) 
Imports the parameters from the config file and returns an integer of the number of arguments. 
.sp
.INDENT 7.0
.TP
\fBReturn\fP
a count of the number of arguments (should also be the size of comargs). 
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fBcomargs\fP: a vector of command line arguments to import to from file. 
.UNINDENT
.UNINDENT

.UNINDENT
Friends.INDENT 7.0
.TP
.B ostream &operator<<(ostream &\fIos\fP, const ConfigOption &\fIc\fP) 
Overloading the << operator for outputting to the output stream. 
.sp
.INDENT 7.0
.TP
\fBReturn\fP
os the output stream. 
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fBos\fP: the output stream. 
.IP \(bu 2
\fBc\fP: the ConfigOption object. 
.UNINDENT
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B istream &operator>>(istream &\fIis\fP, ConfigOption &\fIc\fP) 
Overloading the >> operator for inputting from an input stream. Note that the config file must still exist for re\-inport and parsing. 
.sp
.INDENT 7.0
.TP
\fBReturn\fP
is the input stream 
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fBis\fP: the input stream 
.IP \(bu 2
\fBc\fP: the ConfigOption object 
.UNINDENT
.UNINDENT

.UNINDENT
.UNINDENT
.SS Class DataMask
.INDENT 0.0
.IP \(bu 2
Defined in file_necsim_DataMask.h
.UNINDENT
.SS Inheritance Relationships
.SS Derived Type
.INDENT 0.0
.IP \(bu 2
\fBpublic Samplematrix\fP (class_Samplematrix)
.UNINDENT
.SS Class Documentation
.INDENT 0.0
.TP
.B class DataMask 
Contains the DataMask object, a Matrix of booleans describing the spatial sampling pattern. 
.sp
Subclassed by Samplematrix
Public Functions.INDENT 7.0
.TP
.B DataMask() 
The DataMask constructor. 
.sp
Exact grid for determining sampling proportion. 
.UNINDENT
.INDENT 7.0
.TP
.B ~DataMask() 
.UNINDENT
.INDENT 7.0
.TP
.B bool getDefault() 
Returns if the simulation is using the a null samplemask, and therefore does not need to store the full sample grid in memory. 
.sp
.INDENT 7.0
.TP
\fBReturn\fP
true if using a null samplemask 
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B bool setup(const string &\fIsample_mask_file\fP, const unsigned long &\fIx_in\fP, const unsigned long &\fIy_in\fP, const unsigned long &\fImask_x_in\fP, const unsigned long &\fImask_y_in\fP, const unsigned long &\fIx_offset_in\fP, const unsigned long &\fIy_offset_in\fP) 
Sets the parameters for the datamask, including the dimensions of the map, the offsets from the grid and the dimensions of the grid itself for recalculating coordinates. 
.sp
.INDENT 7.0
.TP
\fBReturn\fP
true if using a "null" samplemask 
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fBsample_mask_file\fP: the file to import the samplemask from (or "null") 
.IP \(bu 2
\fBx_in\fP: x dimension of the grid 
.IP \(bu 2
\fBy_in\fP: y dimension of the grid 
.IP \(bu 2
\fBmask_x_in\fP: x dimension of the sample mask 
.IP \(bu 2
\fBmask_y_in\fP: y dimension of the sample mask 
.IP \(bu 2
\fBx_offset_in\fP: x offset of the sample mask from the grid 
.IP \(bu 2
\fBy_offset_in\fP: y offset of the sample mask from the grid 
.UNINDENT
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B void importBooleanMask(unsigned long \fIxdim\fP, unsigned long \fIydim\fP, unsigned long \fImask_xdim\fP, unsigned long \fImask_ydim\fP, unsigned long \fIxoffset\fP, unsigned long \fIyoffset\fP, string \fIinputfile\fP) 
Imports the sample mask as a boolean mask and sets the relevant sample mask dimensions. 
.sp
.INDENT 7.0
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fBxdim\fP: the x dimension of the grid area 
.IP \(bu 2
\fBydim\fP: the y dimension of the grid area 
.IP \(bu 2
\fBmask_xdim\fP: the x dimension of the sample map file 
.IP \(bu 2
\fBmask_ydim\fP: the y dimension of the sample map file 
.IP \(bu 2
\fBxoffset\fP: the x offset of the grid area from the sample map file 
.IP \(bu 2
\fByoffset\fP: the y offset of the grid area from the sample map file 
.IP \(bu 2
\fBinputfile\fP: the path to the sample map file 
.UNINDENT
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B void doImport() 
Imports the boolean map object. 
.UNINDENT
.INDENT 7.0
.TP
.B void importSampleMask(SimParameters &\fImapvarin\fP) 
Imports the specified file for the sampling percentage within each cell. 
.sp
The map should consist of floating points representing the relative sampling rates in each cell. Note that the actual sampling proportion is equal to the cell value multiplied by global deme sampling proportion. .INDENT 7.0
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fBmapvarin\fP: the SimParameters object containing the samplemask file location and dimensions 
.UNINDENT
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B bool getVal(const long &\fIx\fP, const long &\fIy\fP, const long &\fIxwrap\fP, const long &\fIywrap\fP) 
Calculates the matrix value at the provided x, y location. If everywhere is sampled, simply returns true, as no sample_mask will be stored in memory. This is to save RAM where possible. 
.sp
.INDENT 7.0
.TP
\fBReturn\fP
the sample_mask value at x,y (or true if the file was "null") 
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fBx\fP: the x position on the grid 
.IP \(bu 2
\fBy\fP: the y position on the grid 
.IP \(bu 2
\fBxval\fP: the number of x wraps 
.IP \(bu 2
\fByval\fP: the number of y wraps 
.UNINDENT
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B double getNullProportion(const long &\fIx\fP, const long &\fIy\fP, const long &\fIxwrap\fP, const long &\fIywrap\fP) 
Separate return function for always returning 1.0 as density value. 
.sp
.INDENT 7.0
.TP
\fBReturn\fP
the sample_mask_exact value at (x, y) 
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fBx\fP: the x position on the grid 
.IP \(bu 2
\fBy\fP: the y position on the grid 
.IP \(bu 2
\fBxwrap\fP: the number of x wraps around the map 
.IP \(bu 2
\fBywrap\fP: the number of y wraps around the map 
.UNINDENT
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B double getBoolProportion(const long &\fIx\fP, const long &\fIy\fP, const long &\fIxwrap\fP, const long &\fIywrap\fP) 
Returns the exact value from the spatial sampling map, for calculating the proportion of individuals to be sampled in each cell. 
.sp
.INDENT 7.0
.TP
\fBNote\fP
this function assumes that the file is not "null" and the exact sampling mask has been imported. No error checks on these conditions are performed except in debugging mode. 
.TP
\fBReturn\fP
the sample_mask_exact value at (x, y) 
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fBx\fP: the x position on the grid 
.IP \(bu 2
\fBy\fP: the y position on the grid 
.IP \(bu 2
\fBxwrap\fP: the number of x wraps around the map 
.IP \(bu 2
\fBywrap\fP: the number of y wraps around the map 
.UNINDENT
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B double getSampleProportion(const long &\fIx\fP, const long &\fIy\fP, const long &\fIxwrap\fP, const long &\fIywrap\fP) 
Returns the exact value from the spatial sampling map, for calculating the proportion of individuals to be sampled in each cell. 
.sp
.INDENT 7.0
.TP
\fBNote\fP
this function assumes that the file is not "null" and the exact sampling mask has been imported. No error checks on these conditions are performed except in debugging mode. 
.TP
\fBReturn\fP
the sample_mask_exact value at (x, y) 
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fBx\fP: the x position on the grid 
.IP \(bu 2
\fBy\fP: the y position on the grid 
.IP \(bu 2
\fBxwrap\fP: the number of x wraps around the map 
.IP \(bu 2
\fBywrap\fP: the number of y wraps around the map 
.UNINDENT
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B double getExactValue(const long &\fIx\fP, const long &\fIy\fP, const long &\fIxwrap\fP, const long &\fIywrap\fP) 
Returns the exact value from the spatial sampling map, as returned by the pointer function. 
.sp
.INDENT 7.0
.TP
\fBReturn\fP
the sample_mask_exact value at (x, y) 
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fBx\fP: the x position on the grid 
.IP \(bu 2
\fBy\fP: the y position on the grid 
.IP \(bu 2
\fBxwrap\fP: the number of x wraps around the map 
.IP \(bu 2
\fBywrap\fP: the number of y wraps around the map 
.UNINDENT
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B void convertBoolean(Map &\fImap1\fP, const double &\fIdeme_sampling\fP, const double &\fIgeneration\fP) 
Converts the spatial map into the boolean grid required for continued simulation. This is done so that the faster boolean accesses are possible. 
.sp
.INDENT 7.0
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fBmap1\fP: the map object to obtain density values from 
.IP \(bu 2
\fBdeme_sampling\fP: the proportion of individuals to sample 
.IP \(bu 2
\fBgeneration\fP: the generation individuals are added at 
.UNINDENT
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B void clearSpatialMask() 
Removes the spatial mask from memory. This should be performed if no more map expansions are required. 
.UNINDENT
.INDENT 7.0
.TP
.B void recalculate_coordinates(long &\fIx\fP, long &\fIy\fP, long &\fIx_wrap\fP, long &\fIy_wrap\fP) 
Converts the coordinates back into the grid format. Changes the values in the provided variables to be correct. 
.sp
.INDENT 7.0
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fBx\fP: the x value to convert 
.IP \(bu 2
\fBy\fP: the y value to convert 
.IP \(bu 2
\fBx_wrap\fP: the xwrap variable to place the value into 
.IP \(bu 2
\fBy_wrap\fP: the ywrap variable to place the value into 
.UNINDENT
.UNINDENT

.UNINDENT
Public Members.INDENT 7.0
.TP
.B Matrix<bool> sample_mask 
.UNINDENT
.INDENT 7.0
.TP
.B Matrix<double> sample_mask_exact 
A binary grid telling whether or not the cell should be sampled. 
.UNINDENT
Protected Types.INDENT 7.0
.TP
.B typedef double (DataMask::*fptr)(const long &x, const long &y, const long &xwrap, const long &ywrap) 
.UNINDENT
Protected Attributes.INDENT 7.0
.TP
.B string inputfile 
.UNINDENT
.INDENT 7.0
.TP
.B bool bDefault 
.UNINDENT
.INDENT 7.0
.TP
.B unsigned long x_offset 
.UNINDENT
.INDENT 7.0
.TP
.B unsigned long y_offset 
.UNINDENT
.INDENT 7.0
.TP
.B unsigned long x_dim 
.UNINDENT
.INDENT 7.0
.TP
.B unsigned long y_dim 
.UNINDENT
.INDENT 7.0
.TP
.B unsigned long mask_x_dim 
.UNINDENT
.INDENT 7.0
.TP
.B unsigned long mask_y_dim 
.UNINDENT
.INDENT 7.0
.TP
.B fptr getProportionfptr 
.UNINDENT
.UNINDENT
.SS Class DataPoint
.INDENT 0.0
.IP \(bu 2
Defined in file_necsim_DataPoint.h
.UNINDENT
.SS Class Documentation
.INDENT 0.0
.TP
.B class DataPoint 
A data object used in coalescence simulations for calculating the output. Data from this object is outputted to an SQLite database after simulations are complete. 
Public Functions.INDENT 7.0
.TP
.B DataPoint() 
Standard constructor. 
.UNINDENT
.INDENT 7.0
.TP
.B ~DataPoint() 
Standard destructor. 
.UNINDENT
.INDENT 7.0
.TP
.B void setup(unsigned long \fIx\fP, unsigned long \fIy\fP, long \fIxwrap_in\fP, long \fIywrap_in\fP, unsigned long \fIreference_in\fP, unsigned long \fIlist_position_in\fP, double \fImin_max_in\fP) 
Setup of lineage data with any information that\(aqs wanted. Note that nwrap is set to 0 in this routine. 
.sp
.INDENT 7.0
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fBx\fP: the x position on the grid 
.IP \(bu 2
\fBy\fP: the y position on the grid 
.IP \(bu 2
\fBxwrap_in\fP: the number of wraps of the location on the grid in the x direction 
.IP \(bu 2
\fBywrap_in\fP: the number of wraps of the location on the grid in the y direction 
.IP \(bu 2
\fBreference_in\fP: the position in the TreeNode reference object 
.IP \(bu 2
\fBlist_position_in\fP: the position within the SpeciesList object at the relevant x,y position 
.IP \(bu 2
\fBmin_max_in\fP: the input maximum minimum speciation rate required for speciation to have occured 
.UNINDENT
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B void setup(unsigned long \fIreference_in\fP, unsigned long \fIlist_position_in\fP, double \fImin_max_in\fP) 
Setup of lineage data with any information that\(aqs wanted. 
.sp
.INDENT 7.0
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fBreference_in\fP: the reference point for the TreeNode reference object 
.IP \(bu 2
\fBlist_position_in\fP: the list position of this lineage in SpeciesList object 
.IP \(bu 2
\fBmin_max_in\fP: the input maximum minimum speciation rate required for speciation to have occured 
.UNINDENT
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B void setup(DataPoint \fIdatin\fP) 
Copy constructor from another Datapoint object. 
.sp
.INDENT 7.0
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fBdatin\fP: a Datapoint object to copy the data from. 
.UNINDENT
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B void setReference(unsigned long \fIz\fP) 
Sets the mpos (the position within the Row of TreeNode objects.). 
.sp
.INDENT 7.0
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fBz\fP: the desired mpos. 
.UNINDENT
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B void setNext(unsigned long \fIx\fP) 
Set the next link in the linked list. 
.sp
.INDENT 7.0
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fBx\fP: the next Datapoint object. 
.UNINDENT
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B void setListPosition(unsigned long \fIl\fP) 
Sets the list position within the SpeciesList object. 
.sp
.INDENT 7.0
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fBl\fP: the input list position. 
.UNINDENT
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B void setNwrap(unsigned long \fIn\fP) 
Sets the number of wraps from the first SpeciesList wrapped lineage. If and only if this is 0, the lineage is within the main grid (i.e xwrap and ywrap should be 0). 
.sp
.INDENT 7.0
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fBn\fP: the desired nwrap. 
.UNINDENT
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B void setMinmax(double \fId\fP) 
Sets the minmax variable. This is the minimum maximum speciation rate required for speciation to have occured on this branch. 
.sp
.INDENT 7.0
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fBd\fP: the minmax to set. 
.UNINDENT
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B unsigned long getXpos() 
Get the x position. 
.sp
.INDENT 7.0
.TP
\fBReturn\fP
the xpos. 
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B unsigned long getYpos() 
Get the y position. 
.sp
.INDENT 7.0
.TP
\fBReturn\fP
the ypos. 
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B long getXwrap() 
Get the x wrapping. 
.sp
.INDENT 7.0
.TP
\fBReturn\fP
the xwrap. 
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B long getYwrap() 
Get the y wrapping. 
.sp
.INDENT 7.0
.TP
\fBReturn\fP
the ywrap. 
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B unsigned long getReference() 
Get the reference position variable. 
.sp
.INDENT 7.0
.TP
\fBReturn\fP
the mpos. 
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B unsigned long getNext() 
Gets the next element linked to this DataPoint\&. 
.sp
.INDENT 7.0
.TP
\fBReturn\fP
the reference of the next individual in the linked list 
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B unsigned long getListpos() 
Gets the list position with the SpeciesList object at the relevant x,y position. 
.sp
.INDENT 7.0
.TP
\fBReturn\fP
the listpos. 
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B unsigned long getNwrap() 
Get the position in the linked list from the SpeciesList object. If this is 0, indicates the lineage lies on the original grid, and xwrap and ywrap should be 0. 
.sp
.INDENT 7.0
.TP
\fBReturn\fP
the nwrap. 
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B double getMinmax() 
Get the maximum minimum speciation rate required for speciation to have occured on this branch. 
.sp
.INDENT 7.0
.TP
\fBReturn\fP
the minmax. 
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B void decreaseNwrap() 
Decreases the nwrap by 1 (to a minimum of 0). 
.UNINDENT
.INDENT 7.0
.TP
.B void setEndpoint(long \fIx\fP, long \fIy\fP, long \fIxwrapin\fP, long \fIywrapin\fP) 
Sets the position in space. 
.sp
.INDENT 7.0
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fBx\fP: the x position. 
.IP \(bu 2
\fBy\fP: the y position. 
.IP \(bu 2
\fBxwrapin\fP: the number of wraps in the x direction. 
.IP \(bu 2
\fBywrapin\fP: the number of wraps in the y direction. 
.UNINDENT
.UNINDENT

.UNINDENT
Friends.INDENT 7.0
.TP
.B ostream &operator<<(ostream &\fIos\fP, const DataPoint &\fId\fP) 
An operator for piping the variables of the Datapoint object to the output stream. 
.sp
.INDENT 7.0
.TP
\fBReturn\fP
returns the output stream at the end. 
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fBos\fP: the output stream. 
.IP \(bu 2
\fBd\fP: the Datapoint object to output. 
.UNINDENT
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B istream &operator>>(istream &\fIis\fP, DataPoint &\fId\fP) 
An operator for piping the variables in to the Datapoint object from the input stream. 
.sp
.INDENT 7.0
.TP
\fBReturn\fP
returns the input stream at the end. 
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fBis\fP: the input stream 
.IP \(bu 2
\fBd\fP: the Datapoint object to input to. 
.UNINDENT
.UNINDENT

.UNINDENT
.UNINDENT
.SS Class DispersalCoordinator
.INDENT 0.0
.IP \(bu 2
Defined in file_necsim_DispersalCoordinator.h
.UNINDENT
.SS Class Documentation
.INDENT 0.0
.TP
.B class DispersalCoordinator 
Class for generating dispersal distances and provide routines for reading dispersal distance maps as a unwound map\-of\-maps. This class also handles reading density maps for rejection sampling. 
.sp
It requires linking to a density map, random number generator and a generation counter from the Tree class.
.sp
Note that no element of this object is recorded during a paused simulation, as all objects pointed to are stored elsewhere and behaviours are recalculated upon simulation resume. 
Public Functions.INDENT 7.0
.TP
.B DispersalCoordinator() 
.UNINDENT
.INDENT 7.0
.TP
.B ~DispersalCoordinator() 
.UNINDENT
.INDENT 7.0
.TP
.B void setRandomNumber(NRrand *\fINR_ptr\fP) 
Sets the random number pointer to an NRrand instance. 
.sp
.INDENT 7.0
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fBNR_ptr\fP: the random number object to set to 
.UNINDENT
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B void setHabitatMap(Map *\fImap_ptr\fP) 
Sets the pointer to the Map object. 
.sp
.INDENT 7.0
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fBmap_ptr\fP: pointer to a Map object 
.UNINDENT
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B void setGenerationPtr(double *\fIgeneration_ptr\fP) 
Sets the generation pointer to the provided double. 
.sp
.INDENT 7.0
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fBgeneration_ptr\fP: pointer to the generation double 
.UNINDENT
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B void setDispersal(const string &\fIdispersal_method\fP, const string &\fIdispersal_file\fP, const unsigned long \fIdispersal_x\fP, const unsigned long \fIdispersal_y\fP, const double &\fIm_probin\fP, const double &\fIcutoffin\fP, const double &\fIsigmain\fP, const double &\fItauin\fP, const bool &\fIrestrict_self\fP) 
Sets the dispersal method and parameters. 
.sp
.INDENT 7.0
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fBdispersal_method\fP: string containing the dispersal type. Can be one of [normal, fat\-tail, norm\-uniform] 
.IP \(bu 2
\fBdispersal_file\fP: string containing the dispersal file, or "none" if using dispersal kernel 
.IP \(bu 2
\fBm_probin\fP: the probability of drawing from the uniform distribution. Only relevant for uniform dispersals 
.IP \(bu 2
\fBcutoffin\fP: the maximum value to be drawn from the uniform dispersal. Only relevant for uniform dispersals 
.IP \(bu 2
\fBsigmain\fP: the fatness of the fat\-tailed dispersal kernel 
.IP \(bu 2
\fBtauin\fP: the width of the fat\-tailed dispersal kernel 
.IP \(bu 2
\fBrestrict_self\fP: if true, denies possibility that dispersal comes from the same cell as the parent 
.UNINDENT
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B void disperseNullDispersalMap(Step &\fIthis_step\fP) 
Picks a random cell from the whole map and stores the value in the step object. 
.sp
.INDENT 7.0
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fBthis_step\fP: the step object to store end points in 
.UNINDENT
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B void disperseDispersalMap(Step &\fIthis_step\fP) 
Picks a random dispersal distance from the dispersal map. 
.sp
.INDENT 7.0
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fBthis_step\fP: the step object to store end points in 
.UNINDENT
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B void calculateCellCoordinates(Step &\fIthis_step\fP, const unsigned long &\fIcol_ref\fP) 
Calculates the new coordinates for a column reference. This includes converting between the fine map and sample map. New coordinates are saved in this_step. 
.sp
.INDENT 7.0
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fBthis_step\fP: the step to save new coordinates in. 
.IP \(bu 2
\fBcol_ref\fP: the column reference for 
.UNINDENT
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B unsigned long calculateCellReference(Step &\fIthis_step\fP) 
Calculates the cell reference for a particular coordinate. 
.sp
The formula for this calculation is x + (y * xdim) where xdim is the dimensions of the fine map, and x and y are the coordinates for the fine map
.sp
.INDENT 7.0
.TP
\fBReturn\fP
the cell reference from the dispersal_prob_map which corresponds to the required cell 
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fBthis_step\fP: the step object containing the x, y location, and x,y wrapping 
.UNINDENT
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B void disperseDensityMap(Step &\fIthis_step\fP) 
Calls the dispersal kernel from the supplied dispersal distribution. 
.sp
.INDENT 7.0
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fBthis_step\fP: the step object to store end points in 
.UNINDENT
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B void setEndPointFptr(const bool &\fIrestrict_self\fP) 
Sets the end point function pointer correctly, based on whether it is restricted or not. 
.sp
.INDENT 7.0
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fBrestrict_self\fP: if true, denies possibility that dispersal comes from the same cell as the parent 
.UNINDENT
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B bool checkEndPoint(const unsigned long &\fIdensity\fP, long &\fIoldx\fP, long &\fIoldy\fP, long &\fIoldxwrap\fP, long &\fIoldywrap\fP, const long &\fIstartx\fP, const long &\fIstarty\fP, const long &\fIstartxwrap\fP, const long &\fIstartywrap\fP) 
Check the end point for the given coordinates and density. 
.sp
.INDENT 7.0
.TP
\fBReturn\fP
true if the end point passes the density and restricted checks 
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fBdensity\fP: the density at the end point \- avoids an extra call to Map::getVal() 
.IP \(bu 2
\fBoldx\fP: the old x position 
.IP \(bu 2
\fBoldy\fP: the old y position 
.IP \(bu 2
\fBoldxwrap\fP: the old x wrap 
.IP \(bu 2
\fBoldywrap\fP: the old y wrap 
.IP \(bu 2
\fBstartx\fP: the starting x position 
.IP \(bu 2
\fBstarty\fP: the starting y position 
.IP \(bu 2
\fBstartxwrap\fP: the starting x wrap 
.IP \(bu 2
\fBstartywrap\fP: the ending y wrap 
.UNINDENT
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B bool checkEndPointDensity(const unsigned long &\fIdensity\fP, long &\fIoldx\fP, long &\fIoldy\fP, long &\fIoldxwrap\fP, long &\fIoldywrap\fP, const long &\fIstartx\fP, const long &\fIstarty\fP, const long &\fIstartxwrap\fP, const long &\fIstartywrap\fP) 
Check the end point for the given coordinates and density. 
.sp
.INDENT 7.0
.TP
\fBReturn\fP
true if the end point passes the density and restricted checks 
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fBdensity\fP: the density at the end point \- avoids an extra call to Map::getVal() 
.IP \(bu 2
\fBoldx\fP: the old x position 
.IP \(bu 2
\fBoldy\fP: the old y position 
.IP \(bu 2
\fBoldxwrap\fP: the old x wrap 
.IP \(bu 2
\fBoldywrap\fP: the old y wrap 
.IP \(bu 2
\fBstartx\fP: the starting x position 
.IP \(bu 2
\fBstarty\fP: the starting y position 
.IP \(bu 2
\fBstartxwrap\fP: the starting x wrap 
.IP \(bu 2
\fBstartywrap\fP: the ending y wrap 
.UNINDENT
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B bool checkEndPointRestricted(const unsigned long &\fIdensity\fP, long &\fIoldx\fP, long &\fIoldy\fP, long &\fIoldxwrap\fP, long &\fIoldywrap\fP, const long &\fIstartx\fP, const long &\fIstarty\fP, const long &\fIstartxwrap\fP, const long &\fIstartywrap\fP) 
Check the end point for the given coordinates and density. 
.sp
.INDENT 7.0
.TP
\fBReturn\fP
true if the end point passes the density and restricted checks 
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fBdensity\fP: the density at the end point \- avoids an extra call to Map::getVal() 
.IP \(bu 2
\fBoldx\fP: the old x position 
.IP \(bu 2
\fBoldy\fP: the old y position 
.IP \(bu 2
\fBoldxwrap\fP: the old x wrap 
.IP \(bu 2
\fBoldywrap\fP: the old y wrap 
.IP \(bu 2
\fBstartx\fP: the starting x position 
.IP \(bu 2
\fBstarty\fP: the starting y position 
.IP \(bu 2
\fBstartxwrap\fP: the starting x wrap 
.IP \(bu 2
\fBstartywrap\fP: the ending y wrap 
.UNINDENT
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B void disperse(Step &\fIthis_step\fP) 
Performs the dispersal routine using the Step object to read starting positions and record the end positions. 
.sp
.INDENT 7.0
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fBthis_step\fP: the Step object for reading starting position and storing output distances and angles 
.UNINDENT
.UNINDENT

.UNINDENT
Protected Types.INDENT 7.0
.TP
.B typedef void (DispersalCoordinator::*dispersal_fptr)(Step &this_step) 
.UNINDENT
.INDENT 7.0
.TP
.B typedef bool (DispersalCoordinator::*end_fptr)(const unsigned long &density, long &oldx, long &oldy, long &oldxwrap, long &oldywrap, const long &startx, const long &starty, const long &startxwrap, const long &startywrap) 
.UNINDENT
Protected Attributes.INDENT 7.0
.TP
.B Matrix<double> dispersal_prob_map 
.UNINDENT
.INDENT 7.0
.TP
.B NRrand *NR 
.UNINDENT
.INDENT 7.0
.TP
.B Map *habitat_map 
.UNINDENT
.INDENT 7.0
.TP
.B double *generation 
.UNINDENT
.INDENT 7.0
.TP
.B dispersal_fptr doDispersal 
.UNINDENT
.INDENT 7.0
.TP
.B end_fptr checkEndPointFptr 
.UNINDENT
.INDENT 7.0
.TP
.B unsigned long xdim 
.UNINDENT
.UNINDENT
.SS Class LogFile
.INDENT 0.0
.IP \(bu 2
Defined in file_necsim_LogFile.h
.UNINDENT
.SS Class Documentation
.INDENT 0.0
.TP
.B class LogFile 
Contains routines for writing to log files. 
Public Functions.INDENT 7.0
.TP
.B LogFile() 
Default constructor. 
.UNINDENT
.INDENT 7.0
.TP
.B LogFile(const string &\fIfile_name_in\fP) 
Constructor taking location of a log file. 
.sp
.INDENT 7.0
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fBfile_name_in\fP: the path to the log file to open 
.UNINDENT
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B ~LogFile() 
Default destructor, including writing closure out to log file. 
.UNINDENT
.INDENT 7.0
.TP
.B void init(const string &\fIfile_name_in\fP) 
.UNINDENT
.INDENT 7.0
.TP
.B void write(const int &\fIlevel\fP, string \fImessage\fP) 
Writes the message out to the logfile at the specified logging level. 
.sp
.INDENT 7.0
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fBlevel\fP: the level of logging severity 
.IP \(bu 2
\fBmessage\fP: the message to write out 
.UNINDENT
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B void write(const int &\fIlevel\fP, stringstream &\fImessage\fP) 
Writes the message out to the logfile at the specified logging level. 
.sp
.INDENT 7.0
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fBlevel\fP: the level of logging severity 
.IP \(bu 2
\fBmessage\fP: the message to write out 
.UNINDENT
.UNINDENT

.UNINDENT
Protected Functions.INDENT 7.0
.TP
.B LogFile(const LogFile&) 
.UNINDENT
.INDENT 7.0
.TP
.B LogFile &operator=(const LogFile&) 
.UNINDENT
Protected Attributes.INDENT 7.0
.TP
.B ofstream output_stream 
.UNINDENT
.INDENT 7.0
.TP
.B string file_name 
.UNINDENT
.INDENT 7.0
.TP
.B map<int, string> levels_map 
.UNINDENT
.UNINDENT
.SS Class Map
.INDENT 0.0
.IP \(bu 2
Defined in file_necsim_Map.h
.UNINDENT
.SS Class Documentation
.INDENT 0.0
.TP
.B class Map 
Contains all maps and provides the functions for accessing a grid cell in the correct temporal and spacial location. 
.sp
The function runDispersal() also provides the move routine, provided two alternative methods for moving individuals. Contains routines for easy setting up and switching between the different coordinate systems required. Set the map parameters with setDims(), import the map files with calcFineMap(), calcCoarseMap() etc, then set up the landscape type using setLandscape() and setPristine()\&. Usage is then by runDispersal() for running a dispersal kernel on the landscape, and then getVal() to obtain the density at the desired coordinates. All coordinates should be given in reference to the simulation grid, and offsets for the fine and coarse map are calculated automatically. 
Public Functions.INDENT 7.0
.TP
.B Map() 
The default constructor. 
.UNINDENT
.INDENT 7.0
.TP
.B unsigned long getHabitatMax() 
Gets the maximum habitat value from any map. 
.sp
.INDENT 7.0
.TP
\fBReturn\fP
the maximum habitat value 
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B void setDims(SimParameters \fImapvarsin\fP) 
Sets the dimensions of the grid, the area where the species are initially sampled from. This function must be run before any of the calc map functions to allow for the correct deme allocation. 
.sp
.INDENT 7.0
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fBmapvarsin\fP: the SimParameters object containing the map variables to import 
.UNINDENT
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B bool checkMapExists() 
.UNINDENT
.INDENT 7.0
.TP
.B void calcFineMap() 
Imports the fine map object from file and calculates the correct values at each point. Without a map to input, the fine map will simply be a matrix of 1s. 
.UNINDENT
.INDENT 7.0
.TP
.B void calcPristineFineMap() 
Imports the pristine fine map object from file and calculates the correct values at each point. Without a map to input, the pristine fine map will simply be a matrix of 1s. This has the potential to be changed easily in future versions. 
.UNINDENT
.INDENT 7.0
.TP
.B void calcCoarseMap() 
Imports the coarse map object from file and calculates the correct values at each point. Without a map to input, the coarse map will simply be a matrix of 1s. This has the potential to be changed easily in future versions. 
.UNINDENT
.INDENT 7.0
.TP
.B void calcPristineCoarseMap() 
Imports the pristine coarse map object from file and calculates the correct values at each point. Without a map to input, the pristine coarse map will simply be a matrix of 1s. This has the potential to be changed easily in future versions. 
.UNINDENT
.INDENT 7.0
.TP
.B void setTimeVars(double \fIgen_since_pristine_in\fP, double \fIhabitat_change_rate_in\fP) 
Sets the time variables. 
.sp
.INDENT 7.0
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fBgen_since_pristine_in\fP: the time (in generations) since a pristine habitat state was achieved. 
.IP \(bu 2
\fBhabitat_change_rate_in\fP: the rate of transform of the habitat up until the pristine time. A value of 0.2 would mean 20% of the change occurs linearlly up until the pristine time and the remaining 80% occurs in a jump to the pristine state. 
.UNINDENT
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B void calcOffset() 
Calculates the offset and extremeties of the fine map. 
.sp
Note that setting dispersal_relative_cost to a value other than 1 can massively increase simulation time. 
.UNINDENT
.INDENT 7.0
.TP
.B void validateMaps() 
Checks that the map file sizes are correct and that each value on the fragmented maps is less than the pristine maps. This should be disabled in simulations where habitat sizes are expected to shrink as well as grow. 
.UNINDENT
.INDENT 7.0
.TP
.B void updateMap(double \fIgeneration\fP) 
Updates the maps to the newer map. 
.UNINDENT
.INDENT 7.0
.TP
.B bool isPristine() 
Gets the pristine boolean. 
.sp
.INDENT 7.0
.TP
\fBReturn\fP
the pristine map state. 
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B void setPristine(const bool &\fIbPristinein\fP) 
Sets the pristine state of the system. 
.sp
.INDENT 7.0
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fBbPristinein\fP: the pristine state. 
.UNINDENT
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B double getPristine() 
Get the pristine map time. 
.sp
.INDENT 7.0
.TP
\fBReturn\fP
double the pristine map time 
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B string getLandscapeType() 
.UNINDENT
.INDENT 7.0
.TP
.B void checkPristine(double \fIgeneration\fP) 
Checks if the pristine state has been reached. 
.sp
If there are no pristine maps, this function will do nothing. .INDENT 7.0
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fBgeneration\fP: the time to check at. 
.UNINDENT
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B void setLandscape(string \fIis_infinite\fP) 
Sets the landscape functions to either infinite or finite. 
.sp
.INDENT 7.0
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fBis_infinite\fP: a string of either closed, infinite, tiled_fine or tiled_coarse, corresponding to the relevant landscape type. 
.UNINDENT
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B unsigned long getVal(const double &\fIx\fP, const double &\fIy\fP, const long &\fIxwrap\fP, const long &\fIywrap\fP, const double &\fIcurrent_generation\fP) 
Gets the value at a particular coordinate from the correct map. Takes in to account temporal and spatial referencing. This version involves a call to the function pointer, *getValFunc, so that the correct call to either getValFinite() or getValInfinite is made. 
.sp
.INDENT 7.0
.TP
\fBReturn\fP
the value on the correct map at the correct space. 
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fBx\fP: the x position on the grid. 
.IP \(bu 2
\fBy\fP: the y position on the grid. 
.IP \(bu 2
\fBxwrap\fP: the number of wraps in the x dimension.. 
.IP \(bu 2
\fBywrap\fP: the number of wraps in the y dimension.. 
.IP \(bu 2
\fBcurrent_generation\fP: the current generation time. 
.UNINDENT
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B unsigned long getValCoarse(const double &\fIxval\fP, const double &\fIyval\fP, const double &\fIcurrent_generation\fP) 
Gets the value from the coarse maps, including linear interpolating between the pristine and present maps. 
.sp
.INDENT 7.0
.TP
\fBReturn\fP
the value of the map at the given coordinates and time 
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fBxval\fP: the x coordinate 
.IP \(bu 2
\fByval\fP: the y coordinate 
.IP \(bu 2
\fBcurrent_generation\fP: the current generation timer 
.UNINDENT
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B unsigned long getValFine(const double &\fIxval\fP, const double &\fIyval\fP, const double &\fIcurrent_generation\fP) 
Gets the value from the fine maps, including linear interpolating between the pristine and present maps. 
.sp
.INDENT 7.0
.TP
\fBReturn\fP
the value of the map at the given coordinates and time 
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fBxval\fP: the x coordinate 
.IP \(bu 2
\fByval\fP: the y coordinate 
.IP \(bu 2
\fBcurrent_generation\fP: the current generation timer 
.UNINDENT
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B unsigned long getValFinite(const double &\fIx\fP, const double &\fIy\fP, const long &\fIxwrap\fP, const long &\fIywrap\fP, const double &\fIcurrent_generation\fP) 
Gets the value at a particular coordinate from the correct map. Takes in to account temporal and spatial referencing. This version assumes finite landscape. 
.sp
.INDENT 7.0
.TP
\fBReturn\fP
the value on the correct map at the correct space. 
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fBx\fP: the x position on the grid. 
.IP \(bu 2
\fBy\fP: the y position on the grid. 
.IP \(bu 2
\fBxwrap\fP: the number of wraps in the x dimension.. 
.IP \(bu 2
\fBywrap\fP: the number of wraps in the y dimension.. 
.IP \(bu 2
\fBcurrent_generation\fP: the current generation time. 
.UNINDENT
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B unsigned long getValInfinite(const double &\fIx\fP, const double &\fIy\fP, const long &\fIxwrap\fP, const long &\fIywrap\fP, const double &\fIcurrent_generation\fP) 
Gets the value at a particular coordinate from the correct map. Takes in to account temporal and spatial referencing. This version assumes an infinite landscape. 
.sp
.INDENT 7.0
.TP
\fBReturn\fP
the value on the correct map at the correct space. 
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fBx\fP: the x position on the grid. 
.IP \(bu 2
\fBy\fP: the y position on the grid. 
.IP \(bu 2
\fBxwrap\fP: the number of wraps in the x dimension.. 
.IP \(bu 2
\fBywrap\fP: the number of wraps in the y dimension.. 
.IP \(bu 2
\fBcurrent_generation\fP: the current generation time. 
.UNINDENT
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B unsigned long getValCoarseTiled(const double &\fIx\fP, const double &\fIy\fP, const long &\fIxwrap\fP, const long &\fIywrap\fP, const double &\fIcurrent_generation\fP) 
Gets the value at a particular coordinate from the correct map. Takes in to account temporal and spatial referencing. This version assumes an infinite landscape of tiled coarse maps. 
.sp
.INDENT 7.0
.TP
\fBReturn\fP
the value on the correct map at the correct space. 
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fBx\fP: the x position on the grid. 
.IP \(bu 2
\fBy\fP: the y position on the grid. 
.IP \(bu 2
\fBxwrap\fP: the number of wraps in the x dimension.. 
.IP \(bu 2
\fBywrap\fP: the number of wraps in the y dimension.. 
.IP \(bu 2
\fBcurrent_generation\fP: the current generation time. 
.UNINDENT
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B unsigned long getValFineTiled(const double &\fIx\fP, const double &\fIy\fP, const long &\fIxwrap\fP, const long &\fIywrap\fP, const double &\fIcurrent_generation\fP) 
Gets the value at a particular coordinate from the correct map. Takes in to account temporal and spatial referencing. This version assumes an infinite landscape of tiled fine maps. 
.sp
.INDENT 7.0
.TP
\fBReturn\fP
the value on the correct map at the correct space. 
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fBx\fP: the x position on the grid. 
.IP \(bu 2
\fBy\fP: the y position on the grid. 
.IP \(bu 2
\fBxwrap\fP: the number of wraps in the x dimension.. 
.IP \(bu 2
\fBywrap\fP: the number of wraps in the y dimension.. 
.IP \(bu 2
\fBcurrent_generation\fP: the current generation time. 
.UNINDENT
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B unsigned long convertSampleXToFineX(const unsigned long &\fIx\fP, const long &\fIxwrap\fP) 
Gets the x position on the fine map, given an x and x wrapping. 
.sp
Note that this function will not check if the value is actually within bounds of the fine map, and an error will likely be thrown by the matrix referencing if this is the case. .INDENT 7.0
.TP
\fBReturn\fP
the x location on the fine map 
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fBx\fP: the x coordinate on the sample mask 
.IP \(bu 2
\fBxwrap\fP: the x wrapping of the sample mask. 
.UNINDENT
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B unsigned long convertSampleYToFineY(const unsigned long &\fIy\fP, const long &\fIywrap\fP) 
Gets the y position on the fine map, given a y and y wrapping. 
.sp
Note that this function will not check if the value is actually within bounds of the fine map, and an error will likely be thrown by the matrix referencing if this is the case. .INDENT 7.0
.TP
\fBReturn\fP
the y location on the fine map 
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fBy\fP: the y coordinate on the sample mask 
.IP \(bu 2
\fBywrap\fP: the y wrapping of the sample mask. 
.UNINDENT
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B void convertFineToSample(long &\fIx\fP, long &\fIxwrap\fP, long &\fIy\fP, long &\fIywrap\fP) 
Converts the fine map coordinates to the sample grid coordinates. Main conversion is in a call to convertCoordinates, but also makes sure the returned types are long integers. 
.sp
.INDENT 7.0
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fBx\fP: the x coordinate to modify 
.IP \(bu 2
\fBxwrap\fP: the x wrapping to modify 
.IP \(bu 2
\fBy\fP: the y coordinate to modify 
.IP \(bu 2
\fBywrap\fP: the y wrapping to modify 
.UNINDENT
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B unsigned long getInitialCount(double \fIdSample\fP, DataMask &\fIsamplemask\fP) 
Counts the number of spaces available in the initial species space. Requires the samplemask to check the sampling area. 
.sp
.INDENT 7.0
.TP
\fBReturn\fP
the total number of individuals predicted to initially exist on the map. 
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fBdSample\fP: the sample proportion (from 0 to 1). 
.IP \(bu 2
\fBsamplemask\fP: the DataMask object to sample from. 
.UNINDENT
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B SimParameters getSimParameters() 
Gets the mapvars object for referencing simulation parameters. 
.sp
.INDENT 7.0
.TP
\fBReturn\fP

.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B bool checkMap(const double &\fIx\fP, const double &\fIy\fP, const long &\fIxwrap\fP, const long &\fIywrap\fP, const double \fIgeneration\fP) 
Checks whether the point is habitat or non\-habitat. 
.sp
.INDENT 7.0
.TP
\fBReturn\fP
a boolean of whether the map is habitat or non\-habitat. 
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fBx\fP: the x position on the grid. 
.IP \(bu 2
\fBy\fP: the y position on the grid. 
.IP \(bu 2
\fBxwrap\fP: the number of wraps in the x dimension. 
.IP \(bu 2
\fBywrap\fP: the number of wraps in the y dimension. 
.IP \(bu 2
\fBgeneration\fP: the current generation time. 
.UNINDENT
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B bool checkFine(const double &\fIx\fP, const double &\fIy\fP, const long &\fIxwrap\fP, const long &\fIywrap\fP) 
Checks whether the point comes from the fine grid. 
.sp
.INDENT 7.0
.TP
\fBReturn\fP
a boolean of whether the location is on the fine map. 
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fBx\fP: the x position. 
.IP \(bu 2
\fBy\fP: the y position. 
.IP \(bu 2
\fBxwrap\fP: the number of wraps in the x dimension. 
.IP \(bu 2
\fBywrap\fP: the number of wraps in the y dimension. 
.UNINDENT
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B void convertCoordinates(double &\fIx\fP, double &\fIy\fP, long &\fIxwrap\fP, long &\fIywrap\fP) 
Converts the coordinates to within the original grid, altering the xwrap and ywrap consequently. 
.sp
.INDENT 7.0
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fBx\fP: the x position. 
.IP \(bu 2
\fBy\fP: the y position. 
.IP \(bu 2
\fBxwrap\fP: the number of wraps in the x dimension. 
.IP \(bu 2
\fBywrap\fP: the number of wraps in the y dimension. 
.UNINDENT
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B unsigned long runDispersal(const double &\fIdist\fP, const double &\fIangle\fP, long &\fIstartx\fP, long &\fIstarty\fP, long &\fIstartxwrap\fP, long &\fIstartywrap\fP, bool &\fIdisp_comp\fP, const double &\fIgeneration\fP) 
The function that actually performs the dispersal. It is included here for easier programming and efficiency as the function doesn\(aqt need to perform all the checks until the edge of the fine grid. 
.sp
.INDENT 7.0
.TP
\fBReturn\fP
the density value at the end dispersal point 
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fBdist\fP: the distance travelled (or "distance energy" if dispersal_relative_cost is not 1). 
.IP \(bu 2
\fBangle\fP: the angle of movement. 
.IP \(bu 2
\fBstartx\fP: the start x position. 
.IP \(bu 2
\fBstarty\fP: the start y position. 
.IP \(bu 2
\fBstartxwrap\fP: the start number of wraps in the x dimension. 
.IP \(bu 2
\fBstartywrap\fP: the start number of wraps in the y dimension. 
.IP \(bu 2
\fBdisp_comp\fP: a boolean of whether the dispersal was complete or not. This value is returned true if dispersal is to habitat, false otherwise. 
.IP \(bu 2
\fBgeneration\fP: the time in generations since the start of the simulation. 
.UNINDENT
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B string printVars() 
Prints some selected Map variables to the terminal. 
.sp
.INDENT 7.0
.TP
\fBReturn\fP
the string containing the map variables to print 
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B void clearMap() 
Wipes the map of all variables. Only really useful for testing purposes. 
.UNINDENT
.INDENT 7.0
.TP
.B void recalculateHabitatMax() 
Recalculates the habitat map maximum by checking the maximums for each of the relevant map files (fine, coarse and pristines). 
.UNINDENT
Protected Types.INDENT 7.0
.TP
.B typedef unsigned long (Map::*fptr)(const double &x, const double &y, const long &xwrap, const long &ywrap, const double &dCurrentGen) 
.UNINDENT
Protected Attributes.INDENT 7.0
.TP
.B Matrix<uint32_t> fine_map 
.UNINDENT
.INDENT 7.0
.TP
.B Matrix<uint32_t> pristine_fine_map 
.UNINDENT
.INDENT 7.0
.TP
.B Matrix<uint32_t> coarse_map 
.UNINDENT
.INDENT 7.0
.TP
.B Matrix<uint32_t> pristine_coarse_map 
.UNINDENT
.INDENT 7.0
.TP
.B SimParameters mapvars 
.UNINDENT
.INDENT 7.0
.TP
.B long fine_x_min 
.UNINDENT
.INDENT 7.0
.TP
.B long fine_y_min 
.UNINDENT
.INDENT 7.0
.TP
.B long coarse_x_min 
.UNINDENT
.INDENT 7.0
.TP
.B long coarse_y_min 
.UNINDENT
.INDENT 7.0
.TP
.B long fine_x_max 
.UNINDENT
.INDENT 7.0
.TP
.B long fine_y_max 
.UNINDENT
.INDENT 7.0
.TP
.B long coarse_x_max 
.UNINDENT
.INDENT 7.0
.TP
.B long coarse_y_max 
.UNINDENT
.INDENT 7.0
.TP
.B long fine_x_offset 
.UNINDENT
.INDENT 7.0
.TP
.B long fine_y_offset 
.UNINDENT
.INDENT 7.0
.TP
.B long coarse_x_offset 
.UNINDENT
.INDENT 7.0
.TP
.B long coarse_y_offset 
.UNINDENT
.INDENT 7.0
.TP
.B unsigned long scale = {} 
.UNINDENT
.INDENT 7.0
.TP
.B long x_dim 
.UNINDENT
.INDENT 7.0
.TP
.B long y_dim 
.UNINDENT
.INDENT 7.0
.TP
.B unsigned long deme = {} 
.UNINDENT
.INDENT 7.0
.TP
.B bool check_set_dim 
.UNINDENT
.INDENT 7.0
.TP
.B double dispersal_relative_cost = {} 
.UNINDENT
.INDENT 7.0
.TP
.B double update_time 
.UNINDENT
.INDENT 7.0
.TP
.B double habitat_change_rate 
.UNINDENT
.INDENT 7.0
.TP
.B double gen_since_pristine 
.UNINDENT
.INDENT 7.0
.TP
.B double current_map_time 
.UNINDENT
.INDENT 7.0
.TP
.B bool is_pristine 
.UNINDENT
.INDENT 7.0
.TP
.B bool has_pristine 
.UNINDENT
.INDENT 7.0
.TP
.B unsigned long habitat_max 
.UNINDENT
.INDENT 7.0
.TP
.B unsigned long fine_max 
.UNINDENT
.INDENT 7.0
.TP
.B unsigned long coarse_max 
.UNINDENT
.INDENT 7.0
.TP
.B unsigned long pristine_fine_max 
.UNINDENT
.INDENT 7.0
.TP
.B unsigned long pristine_coarse_max 
.UNINDENT
.INDENT 7.0
.TP
.B string landscape_type 
.UNINDENT
.INDENT 7.0
.TP
.B string NextMap 
.UNINDENT
.INDENT 7.0
.TP
.B bool bCoarse 
.UNINDENT
.INDENT 7.0
.TP
.B unsigned int nUpdate = {} 
.UNINDENT
.INDENT 7.0
.TP
.B fptr getValFunc 
.UNINDENT
Friends.INDENT 7.0
.TP
.B ostream &operator<<(ostream &\fIos\fP, const Map &\fIr\fP) 
Operator for outputting the Map object variables to an output stream. This is used for storing the Map object to file. 
.sp
.INDENT 7.0
.TP
\fBReturn\fP
the output stream. 
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fBos\fP: the output stream. 
.IP \(bu 2
\fBr\fP: the Map object to output. 
.UNINDENT
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B istream &operator>>(istream &\fIis\fP, Map &\fIr\fP) 
Operator for inputting the Map object variables from an input stream. This is used for reading the Map object from file. 
.sp
.INDENT 7.0
.TP
\fBReturn\fP
the input stream. 
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fBis\fP: the input stream. 
.IP \(bu 2
\fBr\fP: the Map object to input to. 
.UNINDENT
.UNINDENT

.UNINDENT
.UNINDENT
.SS Template Class Matrix
.INDENT 0.0
.IP \(bu 2
Defined in file_necsim_Matrix.h
.UNINDENT
.SS Class Documentation
.INDENT 0.0
.TP
.B template <class \fIT\fP>
.TP
.B class Matrix 
A class containing the Matrix object, set up as an array of Row objects. Includes basic operations, as well as the importCsv() function for more advanced reading from file. 
Public Functions.INDENT 7.0
.TP
.B Matrix(unsigned long \fIrows\fP = 0, unsigned long \fIcols\fP = 0) 
The standard constructor. 
.sp
.INDENT 7.0
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fBrows\fP: optionally provide the number of rows. 
.IP \(bu 2
\fBcols\fP: optionally provide the number of columns. 
.UNINDENT
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B Matrix(const Matrix &\fIm\fP) 
The copy constructor. 
.sp
.INDENT 7.0
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fBm\fP: a Matrix object to copy from. 
.UNINDENT
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B ~Matrix() 
The destructor. 
.UNINDENT
.INDENT 7.0
.TP
.B void SetSize(unsigned long \fIrows\fP, unsigned long \fIcols\fP) 
Sets the matrix size. Similar concept to that for Rows. 
.sp
.INDENT 7.0
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fBrows\fP: the number of rows. 
.IP \(bu 2
\fBcols\fP: the number of columns. 
.UNINDENT
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B unsigned long GetCols() const 
Getter for the number of columns. 
.sp
.INDENT 7.0
.TP
\fBReturn\fP
the number of columns. 
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B unsigned long GetRows() const 
Getter for the number of rows. 
.sp
.INDENT 7.0
.TP
\fBReturn\fP
the number of rows. 
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B Row<T> &operator[](unsigned long \fIindex\fP) 
Overoads the [] operator for Matrix\&. Allows referencing of a value i,j using Matrix[i][j]. Includes error checking for if the indices are out of range of the matrix. Note that this functionality has been altered since the original file generation. 
.sp
.INDENT 7.0
.TP
\fBReturn\fP
the matrix row object. 
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fBindex\fP: the row number to get the value from. 
.UNINDENT
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B Matrix &operator=(const Matrix &\fIm\fP) 
Overloading the = operator. 
.sp
.INDENT 7.0
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fBm\fP: the matrix to copy from. 
.UNINDENT
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B const Matrix operator+(const Matrix &\fIm\fP) 
Overloading the + operator. 
.sp
.INDENT 7.0
.TP
\fBReturn\fP
the matrix object which is the sum of the two matrices. 
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fBm\fP: the matrix to add to this matrix. 
.UNINDENT
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B const Matrix operator\-(const Matrix &\fIm\fP) 
Overloading the \- operator. 
.sp
.INDENT 7.0
.TP
\fBReturn\fP
the matrix object which is the subtraction of the two matrices. 
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fBm\fP: the matrix to subtract from this matrix. 
.UNINDENT
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B Matrix &operator+=(const Matrix &\fIm\fP) 
Overloading the += operator so that the new object is written to the current object. 
.sp
.INDENT 7.0
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fBm\fP: the Matrix object to add to this matrix. 
.UNINDENT
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B Matrix &operator\-=(const Matrix &\fIm\fP) 
Overloading the \-= operator so that the new object is written to the current object. 
.sp
.INDENT 7.0
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fBm\fP: the Matrix object to subtract from this matrix. 
.UNINDENT
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B const Matrix operator*(const double \fIs\fP) 
Overloading the * operator for scaling. 
.sp
.INDENT 7.0
.TP
\fBReturn\fP
the scaled matrix. 
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fBs\fP: the constant to scale the matrix by. 
.UNINDENT
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B const Matrix operator*(Matrix &\fIm\fP) 
Overloading the * operator for matrix multiplication. Multiplies each value in the matrix with its corresponding value in the other matrix. 
.sp
.INDENT 7.0
.TP
\fBReturn\fP
the product of each ith,jth value of the matrix. 
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fBm\fP: the matrix to multiply with 
.UNINDENT
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B void setValue(const unsigned long &\fIx\fP, const unsigned long &\fIy\fP, const char *\fIvalue\fP) 
Sets the value at the specified indices, including handling type conversion from char to the template class. 
.sp
.INDENT 7.0
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fBx\fP: the x index. 
.IP \(bu 2
\fBy\fP: the y index. 
.IP \(bu 2
\fBvalue\fP: the value to set 
.UNINDENT
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B void import(const string &\fIfilename\fP) 
Imports the matrix from either a csv or tif file. Calls either importCsv() or importTif() dependent on the provided file type. 
.sp
.INDENT 7.0
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fBfilename\fP: the file to import. 
.UNINDENT
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B void importCsv(const string &\fIfilename\fP) 
Imports the matrix from a tif file using the gdal library functions. Currently supports importing from. 
.sp
.INDENT 7.0
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fBfilename\fP: the path to the file to import. Imports the matrix from a csv file using the fast\-csv\-parser method. 
.IP \(bu 2
\fBfilename\fP: the path to the file to import. Imports the matrix from a csv file using the standard, slower method. 
.UNINDENT
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fBfilename\fP: the path to the file to import. 
.UNINDENT
.UNINDENT

.UNINDENT
Protected Attributes.INDENT 7.0
.TP
.B unsigned long numCols = {} 
.UNINDENT
.INDENT 7.0
.TP
.B unsigned long numRows = {} 
.UNINDENT
.INDENT 7.0
.TP
.B Row<T> *matrix 
.UNINDENT
Friends.INDENT 7.0
.TP
.B ostream &operator<<(ostream &\fIos\fP, const Matrix &\fIm\fP) 
Overloading the << operator for outputting to an output stream. This can be used for writing to console or storing to file. 
.sp
.INDENT 7.0
.TP
\fBReturn\fP
the output stream. 
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fBos\fP: the output stream. 
.IP \(bu 2
\fBm\fP: the matrix to output. 
.UNINDENT
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B istream &operator>>(istream &\fIis\fP, Matrix &\fIm\fP) 
Overloading the >> operator for inputting from an input stream. This can be used for writing to console or storing to file. 
.sp
.INDENT 7.0
.TP
\fBReturn\fP
the input stream. 
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fBis\fP: the input stream. 
.IP \(bu 2
\fBm\fP: the matrix to input to. 
.UNINDENT
.UNINDENT

.UNINDENT
.UNINDENT
.SS Class Metacommunity
.INDENT 0.0
.IP \(bu 2
Defined in file_necsim_Metacommunity.h
.UNINDENT
.SS Inheritance Relationships
.SS Base Type
.INDENT 0.0
.IP \(bu 2
\fBpublic Community\fP (class_Community)
.UNINDENT
.SS Class Documentation
.INDENT 0.0
.TP
.B class Metacommunity 
Generates a metacommunity using spatially\-implicit neutral simulations, which is used to draw individuals from a community. 
.sp
Inherits from Community
Public Functions.INDENT 7.0
.TP
.B Metacommunity() 
.UNINDENT
.INDENT 7.0
.TP
.B ~Metacommunity() 
.UNINDENT
.INDENT 7.0
.TP
.B void setCommunityParameters(unsigned long \fIcommunity_size_in\fP, long double \fIspeciation_rate_in\fP, string \fIdatabase_name_in\fP) 
Sets the parameters for the metacommunity. 
.sp
.INDENT 7.0
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fBcommunity_size_in\fP: the number of individuals in the metacommunity 
.IP \(bu 2
\fBspeciation_rate_in\fP: the speciation rate to use for metacommunity creation 
.IP \(bu 2
\fBdatabase_name_in\fP: the path to the database to store the metacommunity in 
.UNINDENT
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B void checkSimulationParameters() 
Gets the seed and the task from the SIMULATION_PARAMETERS database and stores them in the relevant variables. 
.sp
.INDENT 7.0
.TP
\fBNote\fP
Should only be called once, and will have no effect if called multiple times. 
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B void addSpecies(unsigned long &\fIspecies_count\fP, TreeNode *\fItree_node\fP, set<unsigned long> &\fIspecies_list\fP) 
Speciates TreeNode and updates the species count, including adding to the set of species ids, if a new species has been selected from the metacommunity. 
.sp
.INDENT 7.0
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fBspecies_count\fP: the total number of species currently in the community 
.IP \(bu 2
\fBtree_node\fP: pointer to the TreeNode object for this lineage 
.IP \(bu 2
\fBspecies_list\fP: the set of all species ids. 
.UNINDENT
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B void createMetacommunityNSENeutralModel() 
Creates the metacommunity in memory using a non\-spatially_explicit neutral model, which is run using the Tree class. 
.UNINDENT
.INDENT 7.0
.TP
.B unsigned long selectLineageFromMetacommunity() 
Selects a random lineage from the metacommunity (rOut), which should be a cumulative sum of species abundances. Performs a binary search on rOut. 
.sp
.INDENT 7.0
.TP
\fBReturn\fP
the species id for the lineage 
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B void apply(SpecSimParameters *\fIsp\fP) 
Applies the speciation parameters to the completed simulation, including running the spatially\-implicit for the metacommunity structure. 
.sp
.INDENT 7.0
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fBsp\fP: the speciation parameters to apply 
.UNINDENT
.UNINDENT

.UNINDENT
Protected Attributes.INDENT 7.0
.TP
.B unsigned long community_size 
.UNINDENT
.INDENT 7.0
.TP
.B long double speciation_rate 
.UNINDENT
.INDENT 7.0
.TP
.B unsigned long seed 
.UNINDENT
.INDENT 7.0
.TP
.B unsigned long task 
.UNINDENT
.INDENT 7.0
.TP
.B bool parameters_checked 
.UNINDENT
.INDENT 7.0
.TP
.B Row<unsigned long> *metacommunity_cumulative_abundances 
.UNINDENT
.INDENT 7.0
.TP
.B NRrand random 
.UNINDENT
.INDENT 7.0
.TP
.B Tree metacommunity_tree 
.UNINDENT
.UNINDENT
.SS Class NRrand
.INDENT 0.0
.IP \(bu 2
Defined in file_necsim_NRrand.h
.UNINDENT
.SS Class Documentation
.INDENT 0.0
.TP
.B class NRrand 
Contains the functions for random number generation. 
Public Functions.INDENT 7.0
.TP
.B NRrand() 
Standard constructor. 
.UNINDENT
.INDENT 7.0
.TP
.B void setSeed(long \fIseed\fP) 
Sets the seed to the given input. Is only seeded if the seed hasn\(aqt already been provided. 
.sp
.INDENT 7.0
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fBseed\fP: the input seed. 
.UNINDENT
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B double d01() 
The random number generator. Uses Schrage\(aqs method and a shuffle table to generate the output. 
.sp
.INDENT 7.0
.TP
\fBReturn\fP
the random number (a double between 0 and 1). 
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B unsigned long i0(unsigned long \fImax\fP) 
Generates a random number uniformly from 0 to the maximum value provided. 
.sp
.INDENT 7.0
.TP
\fBReturn\fP
an integer of the produced random number. 
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fBmax\fP: the maximum number. 
.UNINDENT
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B double norm() 
Generates a normally distributed number Uses the standard normal distribution from a Box\-Muller transform. 
.sp
.INDENT 7.0
.TP
\fBReturn\fP
the random number from a normal distribution. 
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B double norm2D() 
Returns a 2 dimensional call from a normal distribution, giving a distance in cartesian space This way is slightly inefficient for normal distributions, but it\(aqs kept this way to make the Map::runDispersal() function applicable with any dispersal type. 
.sp
.INDENT 7.0
.TP
\fBReturn\fP
dispersal distance of a normal distribution 
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B void setDispersalParams(const double \fIsigmain\fP, const double \fItauin\fP) 
Sets the dispersal parameters, avoiding requirement to provide these numbers each function call. This is only relevant for fat\-tailed dispersal calls. 
.sp
.INDENT 7.0
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fBsigmain\fP: the fatness of the fat\-tailed dispersal kernel. 
.IP \(bu 2
\fBtauin\fP: the width of the fat\-tailed dispersal kernel. 
.UNINDENT
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B double fattail(double \fIz\fP) 
Call from the fat\-tailed dispersal kernel with the provided sigma. 
.sp
.INDENT 7.0
.TP
\fBReturn\fP
a random number drawn from the fat\-tailed dispersal kernel. 
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fBz\fP: the desired sigma. 
.UNINDENT
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B double fattail() 
Call from fat\-tailed dispersal kernel. This function requires setDispersalParams() has already been called. 
.sp
.INDENT 7.0
.TP
\fBReturn\fP
a random number drawn from the fat\-tailed dispersal kernel. 
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B double fattail_old() 
Old version of the function call reparameterised for different nu and sigma. 
.sp
.INDENT 7.0
.TP
\fBReturn\fP
a random number drawn from the fat\-tailed dispersal kernel. 
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B double direction() 
Generates a direction in radians. 
.sp
.INDENT 7.0
.TP
\fBReturn\fP
the direction in radians 
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B bool event(double \fIevent_probability\fP) 
For a given event probability, returns the probability that the event has occured. 
.sp
.INDENT 7.0
.TP
\fBReturn\fP
whether or not the event has occured. 
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fBevent_probability\fP: the event probability. 
.UNINDENT
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B double normUniform() 
Normal distribution, with percentage chance to choose a uniform distribution instead. 
.sp
.INDENT 7.0
.TP
\fBNote\fP
This function will not produce the same output as norm() for the same parameters, even with a zero chance of picking from the uniform distribution (due to random number draws). 
.TP
\fBReturn\fP
normally (or uniformly) distributed number 
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B double uniformUniform() 
Two uniform distributions, the first between 0 and 0.1*cutoff, and the second between 0.9*cutoff and cutoff. Selects from both distributions equally. 
.sp
.INDENT 7.0
.TP
\fBNote\fP
The mean for this function should be identical to a uniform distribution between 0 and cutoff. 
.TP
\fBReturn\fP
uniformly distributed number 
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B void setDispersalMethod(const string &\fIdispersal_method\fP, const double &\fIm_probin\fP, const double &\fIcutoffin\fP) 
Sets the dispersal method by creating the link between dispersalFunction() and the correct dispersal character. 
.sp
.INDENT 7.0
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fBdispersal_method\fP: string containing the dispersal type. Can be one of [normal, fat\-tail, norm\-uniform] 
.IP \(bu 2
\fBm_probin\fP: the probability of drawing from the uniform distribution. Only relevant for uniform dispersals. 
.IP \(bu 2
\fBcutoffin\fP: the maximum value to be drawn from the uniform dispersal. Only relevant for uniform dispersals. 
.UNINDENT
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B double dispersal() 
Runs the dispersal with the allocated dispersal function. 
.sp
.INDENT 7.0
.TP
\fBNote\fP
This function will never return a value larger than the size of LONG_MAX to avoid issues of converting doubles to integers. For dispersal distance within coalescence simulations, this is seemed a reasonable assumption, but may cause issues if code is re\-used in later projects.
.TP
\fBReturn\fP
distance the dispersal distance 
.UNINDENT

.UNINDENT
Friends.INDENT 7.0
.TP
.B ostream &operator<<(ostream &\fIos\fP, const NRrand &\fIr\fP) 
Outputs the NRrand object to the output stream. Used for saving the object to file. 
.sp
.INDENT 7.0
.TP
\fBReturn\fP
the output stream. 
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fBos\fP: the output stream. 
.IP \(bu 2
\fBr\fP: the NRrand object to output. 
.UNINDENT
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B istream &operator>>(istream &\fIis\fP, NRrand &\fIr\fP) 
Inputs the NRrand object from the input stream. Used for reading the NRrand object from a file. 
.sp
.INDENT 7.0
.TP
\fBReturn\fP
the input stream. 
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fBis\fP: the input stream. 
.IP \(bu 2
\fBr\fP: the NRrand object to input to. 
.UNINDENT
.UNINDENT

.UNINDENT
.UNINDENT
.SS Class ProtractedSpatialTree
.INDENT 0.0
.IP \(bu 2
Defined in file_necsim_ProtractedSpatialTree.h
.UNINDENT
.SS Inheritance Relationships
.SS Base Types
.INDENT 0.0
.IP \(bu 2
\fBpublic SpatialTree\fP (class_SpatialTree)
.IP \(bu 2
\fBpublic ProtractedTree\fP (class_ProtractedTree)
.UNINDENT
.SS Class Documentation
.INDENT 0.0
.TP
.B class ProtractedSpatialTree 
Inherits from SpatialTree, ProtractedTree
.UNINDENT
.SS Class ProtractedTree
.INDENT 0.0
.IP \(bu 2
Defined in file_necsim_ProtractedTree.h
.UNINDENT
.SS Inheritance Relationships
.SS Base Type
.INDENT 0.0
.IP \(bu 2
\fBpublic Tree\fP (class_Tree)
.UNINDENT
.SS Derived Type
.INDENT 0.0
.IP \(bu 2
\fBpublic ProtractedSpatialTree\fP (class_ProtractedSpatialTree)
.UNINDENT
.SS Class Documentation
.INDENT 0.0
.TP
.B class ProtractedTree 
.INDENT 7.0
.TP
\fBAuthor\fP
Sam Thompson 
.TP
\fBDate\fP
10/07/2017 
.UNINDENT

.sp
Inherits from Tree
.sp
Subclassed by ProtractedSpatialTree
Public Functions.INDENT 7.0
.TP
.B ProtractedTree() 
.UNINDENT
.INDENT 7.0
.TP
.B bool calcSpeciation(const long double &\fIrandom_number\fP, const long double &\fIspeciation_rate\fP, const unsigned long &\fIno_generations\fP) 
Calculates the speciation probability from the random number, speciation rate and number of generations a lineage has existed for. 
.sp
.INDENT 7.0
.TP
\fBReturn\fP
if true, speciation has occured 
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fBrandom_number\fP: the generated random number from 0\-1 
.IP \(bu 2
\fBspeciation_rate\fP: the speciation rate to be applied 
.IP \(bu 2
\fBno_generations\fP: the number of generations a lineage has existed for 
.UNINDENT
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B void speciateLineage(const unsigned long &\fIdata_position\fP) 
Performs the actual speciation. Includes handling of speciated lineages under protracted conditions. 
.sp
.INDENT 7.0
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fBdata_position\fP: the position in the array of TreeNodes for this lineage 
.UNINDENT
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B bool getProtracted() 
Gets the protractedness of the simulation. Overridden by protracted child classes. 
.sp
.INDENT 7.0
.TP
\fBReturn\fP

.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B void setProtractedVariables(double \fIspeciation_gen_min\fP, double \fIspeciation_gen_max\fP) 
Sets the protracted variables. 
.sp
.INDENT 7.0
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fBspeciation_gen_min\fP: the minimum number of generations to have passed before speciation is allowed 
.IP \(bu 2
\fBspeciation_gen_max\fP: the maximum number of generations a lineage can exist for before it is speciated. 
.UNINDENT
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B string getProtractedVariables() 
Gets the protracted variables and returns them as a single, newline separated string. 
.sp
.INDENT 7.0
.TP
\fBReturn\fP
string containing the protracted variables, separated by newlines. 
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B double getProtractedGenerationMin() 
Gets the minimum number of generations a lineage must exist. 
.sp
.INDENT 7.0
.TP
\fBReturn\fP
double the number of generations a lineage must exist 
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B double getProtractedGenerationMax() 
Gets the maximum number of generations a lineage can exist. 
.sp
.INDENT 7.0
.TP
\fBReturn\fP
double the number of generations a lineage must exist 
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B string protractedVarsToString() 
Outputs the protracted variables to a string. 
.sp
This function is intended to be overridden by derived classes. It is intended the output is used for writing to SQL databases.
.sp
.INDENT 7.0
.TP
\fBReturn\fP
string containing a list of the protracted speciation variables. 
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B void applySpecRate(double \fIsr\fP, double \fIt\fP) 
Applies the given speciation rate to the tree. 
.sp
.INDENT 7.0
.TP
\fBNote\fP
Currently this just copies code from the version in tree, which is not ideal, but this avoids creating an extra function.
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fBsr\fP: the required speciation rate 
.UNINDENT
.UNINDENT

.UNINDENT
.UNINDENT
.SS Class ReproductionMap
.INDENT 0.0
.IP \(bu 2
Defined in file_necsim_ReproductionMap.h
.UNINDENT
.SS Class Documentation
.INDENT 0.0
.TP
.B class ReproductionMap 
Contains the routines for importing the reproduction map and getting a cell value from the map. 
Public Functions.INDENT 7.0
.TP
.B ReproductionMap() 
.UNINDENT
.INDENT 7.0
.TP
.B void import(string \fIfile_name\fP, unsigned long \fIsize_x\fP, unsigned long \fIsize_y\fP) 
Imports the map file from the given path Requires the dimensions to be identical as the fine map file dimensions. 
.sp
.INDENT 7.0
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fBfile_name\fP: the path to the reproduction map to import 
.IP \(bu 2
\fBsize_x\fP: the x dimensions of the map file 
.IP \(bu 2
\fBsize_y\fP: the y dimensions of the map file 
.UNINDENT
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B void setReproductionFunction() 
Correctly sets the reproduction function to either rejectionSampleNull or rejectionSample depending on if a reproduction map is used or not. 
.UNINDENT
.INDENT 7.0
.TP
.B void setOffsets(const unsigned long &\fIx_offset\fP, const unsigned long &\fIy_offset\fP, const unsigned long &\fIxdim\fP, const unsigned long &\fIydim\fP) 
Sets the offsets for the reproduction map from the sample grid. 
.sp
.INDENT 7.0
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fBx_offset\fP: the x offset from the sample grid 
.IP \(bu 2
\fBy_offset\fP: the y offset from the sample grid 
.IP \(bu 2
\fBxdim\fP: the x dimension of the sample grid 
.IP \(bu 2
\fBydim\fP: the y dimension of the sample grid 
.UNINDENT
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B bool rejectionSampleNull(NRrand &\fIrandom_number\fP, const unsigned long &\fIx\fP, const unsigned long &\fIy\fP, const long &\fIxwrap\fP, const long &\fIywrap\fP) 
Returns true for all cell values Function to be pointed to in cases where there is no reproduction map. 
.sp
.INDENT 7.0
.TP
\fBReturn\fP
true always 
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fBrandom_number\fP: random number object to pass forward 
.IP \(bu 2
\fBx\fP: x coordinate of the lineage on the sample grid 
.IP \(bu 2
\fBy\fP: y coordinate of the lineage on the sample grid 
.IP \(bu 2
\fBxwrap\fP: x wrapping of the lineage 
.IP \(bu 2
\fBywrap\fP: y wrapping of the lineage 
.UNINDENT
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B bool rejectionSample(NRrand &\fIrandom_number\fP, const unsigned long &\fIx\fP, const unsigned long &\fIy\fP, const long &\fIxwrap\fP, const long &\fIywrap\fP) 
Returns true for all cell values Function to be pointed to in cases where there is no reproduction map. 
.sp
.INDENT 7.0
.TP
\fBReturn\fP
true always 
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fBrandom_number\fP: random number object to pass forward 
.IP \(bu 2
\fBx\fP: x coordinate of the lineage on the sample grid 
.IP \(bu 2
\fBy\fP: y coordinate of the lineage on the sample grid 
.IP \(bu 2
\fBxwrap\fP: x wrapping of the lineage 
.IP \(bu 2
\fBywrap\fP: y wrapping of the lineage 
.UNINDENT
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B double getVal(const unsigned long &\fIx\fP, const unsigned long &\fIy\fP, const long &\fIxwrap\fP, const long &\fIywrap\fP) 
Gets the value of the reproduction map at that location. 
.sp
.INDENT 7.0
.TP
\fBReturn\fP
value of the reproduction map at the required location 
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fBx\fP: x coordinate of the lineage on the sample grid 
.IP \(bu 2
\fBy\fP: y coordinate of the lineage on the sample grid 
.IP \(bu 2
\fBxwrap\fP: x wrapping of the lineage 
.IP \(bu 2
\fBywrap\fP: y wrapping of the lineage 
.UNINDENT
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B bool hasReproduced(NRrand &\fIrandom_number\fP, const unsigned long &\fIx\fP, const unsigned long &\fIy\fP, const long &\fIxwrap\fP, const long &\fIywrap\fP) 
.INDENT 7.0
.TP
\fBReturn\fP
value of the reproduction map at the required location 
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fBrandom_number\fP: random number object to draw from 
.IP \(bu 2
\fBx\fP: x coordinate of the lineage on the sample grid 
.IP \(bu 2
\fBy\fP: y coordinate of the lineage on the sample grid 
.IP \(bu 2
\fBxwrap\fP: x wrapping of the lineage 
.IP \(bu 2
\fBywrap\fP: y wrapping of the lineage 
.UNINDENT
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B Row<double> operator[](long \fIindex\fP) 
Operator [] for getting values directly from the reproduction map. 
.sp
.INDENT 7.0
.TP
\fBReturn\fP
the row present at that index 
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fBindex\fP: the index to get the row of 
.UNINDENT
.UNINDENT

.UNINDENT
Protected Types.INDENT 7.0
.TP
.B typedef bool (ReproductionMap::*rep_ptr)(NRrand &random_no, const unsigned long &x, const unsigned long &y, const long &xwrap, const long &ywrap) 
.UNINDENT
Protected Attributes.INDENT 7.0
.TP
.B Matrix<double> reproduction_map 
.UNINDENT
.INDENT 7.0
.TP
.B string map_file 
.UNINDENT
.INDENT 7.0
.TP
.B double max_val 
.UNINDENT
.INDENT 7.0
.TP
.B bool null_map 
.UNINDENT
.INDENT 7.0
.TP
.B unsigned long offset_x 
.UNINDENT
.INDENT 7.0
.TP
.B unsigned long offset_y 
.UNINDENT
.INDENT 7.0
.TP
.B unsigned long x_dim 
.UNINDENT
.INDENT 7.0
.TP
.B unsigned long y_dim 
.UNINDENT
.INDENT 7.0
.TP
.B rep_ptr reproductionMapChecker_fptr 
.UNINDENT
Friends.INDENT 7.0
.TP
.B ostream &operator<<(ostream &\fIos\fP, ReproductionMap &\fIr\fP) 
Operator for outputting to an ostream. 
.sp
.INDENT 7.0
.TP
\fBReturn\fP
the os object 
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fBos\fP: the ostream to output to 
.IP \(bu 2
\fBr\fP: the ReproductionMap to read from 
.UNINDENT
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B istream &operator>>(istream &\fIis\fP, ReproductionMap &\fIr\fP) 
Operator for inputting from an istream. 
.sp
.INDENT 7.0
.TP
\fBReturn\fP
the is object 
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fBis\fP: the istream to input from 
.IP \(bu 2
\fBr\fP: the ReproductionMap to input to 
.UNINDENT
.UNINDENT

.UNINDENT
.UNINDENT
.SS Template Class Row
.INDENT 0.0
.IP \(bu 2
Defined in file_necsim_Matrix.h
.UNINDENT
.SS Class Documentation
.INDENT 0.0
.TP
.B template <class \fIT\fP>
.TP
.B class Row 
Contains a template Row class and basic operations. Uses an array to store the row. 
Public Functions.INDENT 7.0
.TP
.B Row(unsigned long \fIcols\fP = 0) 
Standard constructor. 
.sp
.INDENT 7.0
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fBcols\fP: optionally provide the number of rows to initiate with. 
.UNINDENT
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B ~Row() 
Standard destructor. 
.UNINDENT
.INDENT 7.0
.TP
.B Row(const Row &\fIr\fP) 
Copy constructor. 
.sp
.INDENT 7.0
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fBr\fP: the Row object to copy from. 
.UNINDENT
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B void setSize(unsigned long \fIn\fP) 
Setter for the row size. 
.sp
.INDENT 7.0
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fBn\fP: the number of rows to initiate with. SetRowSize() deletes any old data, and allocates space for new data, unless we set the number of columns to 0, in which case it merely deletes the data. This lets us use this function for construction, destruction, and dynamic modification in one method. 
.UNINDENT
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B void resize(unsigned long \fIn\fP) 
Changes the size of the array. 
.sp
.INDENT 7.0
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fBn\fP: the new size to change to. Note that no checks are performed that the new row size is larger than the old row size. Thus is this function is used to shrink the row size, a bad_alloc error will likely be thrown. 
.UNINDENT
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B unsigned long size() 
Getter for the size of the array. 
.sp
.INDENT 7.0
.TP
\fBReturn\fP
the number of columns. 
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B T &operator[](unsigned long \fIcolumn\fP) 
Overloading the [] operator to allow for simple referencing. 
.sp
.INDENT 7.0
.TP
\fBReturn\fP
the value in the specified column. Note that different versions deal with values outside of (0,numCols) in different ways. 
.TP
\fBNote\fP
updated to throw an out_of_range exception if the column is out of the row range. 
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fBcolumn\fP: the column to get the value from. 
.UNINDENT
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B Row &operator=(const Row &\fIr\fP) 
Overloading the = operator to allow for copying data across. 
.sp
.INDENT 7.0
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fBr\fP: the Row object to copy data from. 
.UNINDENT
.UNINDENT

.UNINDENT
Friends.INDENT 7.0
.TP
.B ostream &operator<<(ostream &\fIos\fP, const Row &\fIr\fP) 
Overloading the << operator for outputting to the output stream. 
.sp
.INDENT 7.0
.TP
\fBReturn\fP
os the output stream. 
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fBos\fP: the output stream. 
.IP \(bu 2
\fBr\fP: the Row object to output from. 
.UNINDENT
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B istream &operator>>(istream &\fIis\fP, Row &\fIr\fP) 
Overloading the << operator for inputting from an input stream. 
.sp
.INDENT 7.0
.TP
\fBReturn\fP
the input stream. 
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fBis\fP: the input stream. 
.IP \(bu 2
\fBr\fP: the Row object to input to. 
.UNINDENT
.UNINDENT

.UNINDENT
.UNINDENT
.SS Class Samplematrix
.INDENT 0.0
.IP \(bu 2
Defined in file_necsim_Community.h
.UNINDENT
.SS Inheritance Relationships
.SS Base Type
.INDENT 0.0
.IP \(bu 2
\fBpublic DataMask\fP (class_DataMask)
.UNINDENT
.SS Class Documentation
.INDENT 0.0
.TP
.B class Samplematrix 
A child of the Matrix class as booleans. Used for determining where to sample species from. 
.sp
Inherits from DataMask
Public Functions.INDENT 7.0
.TP
.B Samplematrix() 
Inherit construction from the Matrix class, but also set the booleans. 
.UNINDENT
.INDENT 7.0
.TP
.B bool getTestVal(unsigned long \fIxval\fP, unsigned long \fIyval\fP, long \fIxwrap\fP, long \fIywrap\fP) 
Returns the value at the x,y position. This is used for testing purposes only. 
.sp
.INDENT 7.0
.TP
\fBReturn\fP
the value at x,y. 
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fBxval\fP: the x coordinate. 
.IP \(bu 2
\fByval\fP: the y coordinate 
.IP \(bu 2
\fBxwrap\fP: the x wrapping 
.IP \(bu 2
\fBywrap\fP: the y wrapping 
.UNINDENT
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B bool getMaskVal(unsigned long \fIx1\fP, unsigned long \fIy1\fP, long \fIx_wrap\fP, long \fIy_wrap\fP) 
Returns the value at the x,y position, with the given x and y wrap. Also checks whether or not the map is set to null, or whether the value comes from within a fragment. 
.sp
.INDENT 7.0
.TP
\fBReturn\fP
the value at x,y. 
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fBx1\fP: the x coordinate. 
.IP \(bu 2
\fBy1\fP: the y coordinate 
.UNINDENT
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B void setFragment(Fragment &\fIfragment_in\fP) 
Set the fragment for the samplemask to some calculated fragment. This can be set multiple times. 
.sp
.INDENT 7.0
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fBfragment_in\fP: the Fragment to set the samplemask to. 
.UNINDENT
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B void removeFragment() 
Removes the fragment. 
.UNINDENT
.UNINDENT
.SS Class SimulateDispersal
.INDENT 0.0
.IP \(bu 2
Defined in file_necsim_SimulateDispersal.h
.UNINDENT
.SS Class Documentation
.INDENT 0.0
.TP
.B class SimulateDispersal 
Contains routines for importing a density map file, running a dispersal kernel n times on a landscape and record the dispersal distances. 
Public Functions.INDENT 7.0
.TP
.B SimulateDispersal() 
.UNINDENT
.INDENT 7.0
.TP
.B ~SimulateDispersal() 
.UNINDENT
.INDENT 7.0
.TP
.B void setSequential(bool \fIbSequential\fP) 
Sets the is_sequential flag. 
.sp
.INDENT 7.0
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fBbSequential\fP: if true, dispersal events are selected using the end point of the last dispersal distance for the start of the next move event 
.UNINDENT
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B void setSizes(unsigned long \fIx\fP, unsigned long \fIy\fP) 
Sets the sizes of the density map. 
.sp
.INDENT 7.0
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fBx\fP: the x dimension (number of columns) in the density map 
.IP \(bu 2
\fBy\fP: the y dimension (number of rows) in the density map 
.UNINDENT
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B void importMaps(string \fImap_file\fP) 
Import the map from the prescribed file. 
.sp
.INDENT 7.0
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fBmap_file\fP: the map file to import from 
.UNINDENT
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B void setSeed(unsigned long \fIs\fP) 
Sets the seed for the random number generator. 
.sp
.INDENT 7.0
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fBs\fP: the seed 
.UNINDENT
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B void setDispersalParameters(string \fIdispersal_method_in\fP, double \fIsigma_in\fP, double \fItau_in\fP, double \fIm_prob_in\fP, double \fIcutoff_in\fP, string \fIlandscape_type\fP) 
Sets the dispersal parameters. 
.sp
.INDENT 7.0
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fBdispersal_method_in\fP: the dispersal method (e.g. "normal") 
.IP \(bu 2
\fBsigma_in\fP: the sigma value for normal and fat\-tailed dispersals 
.IP \(bu 2
\fBtau_in\fP: the nu value for fat\-tailed dispersals 
.IP \(bu 2
\fBm_prob_in\fP: the m_prob for norm\-uniform dispersals 
.IP \(bu 2
\fBcutoff_in\fP: the maximum dispersal distance for norm\-uniform dispersal 
.IP \(bu 2
\fBlandscape_type\fP: string containing the landscape type (one of "closed", "tiled" or "infinite"). 
.UNINDENT
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B void setLandscapeType(string \fIlandscape_type\fP) 
.UNINDENT
.INDENT 7.0
.TP
.B void setOutputDatabase(string \fIout_database\fP) 
Sets the output database for writing results to. 
.sp
.INDENT 7.0
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fBout_database\fP: path to the output database 
.UNINDENT
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B void setNumberRepeats(unsigned long \fIn\fP) 
Sets the number of repeats to run the dispersal kernel for. 
.sp
.INDENT 7.0
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fBn\fP: the number of repeats 
.UNINDENT
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B void setNumberSteps(unsigned long \fIs\fP) 
Sets the number of steps to run each repeat of the dispersal kernel for when recording mean distance travelled. 
.sp
.INDENT 7.0
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fBs\fP: the number of steps 
.UNINDENT
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B void storeCellList() 
Calculates the list of cells to choose randomly from. 
.UNINDENT
.INDENT 7.0
.TP
.B const Cell &getRandomCell() 
Gets a random cell from the list of cells. 
.sp
.INDENT 7.0
.TP
\fBReturn\fP
a Cell object reference containing the x and y positions to choose from 
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B void calculateNewPosition(const double &\fIdist\fP, const double &\fIangle\fP, const Cell &\fIstart_cell\fP, Cell &\fIend_cell\fP) 
Calculates the new position from the start cell based on the distance and angle moved. Stores the new x and y location in the end cell. 
.sp
.INDENT 7.0
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fBdist\fP: the distance to move 
.IP \(bu 2
\fBangle\fP: the direction from the start cell to move 
.IP \(bu 2
\fBstart_cell\fP: the cell containing the start x and y position 
.IP \(bu 2
\fBend_cell\fP: the cell to contain the end x and y position 
.UNINDENT
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B bool getEndPointInfinite(const double &\fIdist\fP, const double &\fIangle\fP, const Cell &\fIthis_cell\fP, Cell &\fIend_cell\fP) 
Checks the density is greater than 0 a given distance from the start point on an infinite null landscape. 
.sp
This also takes into account the rejection sampling of density based on the maximal density value from the map.
.sp
.INDENT 7.0
.TP
\fBReturn\fP
true if the point has a density > 0, otherwise generates a random number between 0 and the max size and if it is > the density, return true, false otherwise. 
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fBdist\fP: the distance of dispersal 
.IP \(bu 2
\fBangle\fP: the angle of dispersal 
.IP \(bu 2
\fBthis_cell\fP: Cell containing the x and y coordinates of the starting position 
.IP \(bu 2
\fBend_cell\fP: Cell to store the end point in 
.UNINDENT
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B bool getEndPointTiled(const double &\fIdist\fP, const double &\fIangle\fP, const Cell &\fIthis_cell\fP, Cell &\fIend_cell\fP) 
Checks the density is greater than 0 a given distance from the start point on an infinite tiled landscape. 
.sp
This also takes into account the rejection sampling of density based on the maximal density value from the map.
.sp
.INDENT 7.0
.TP
\fBReturn\fP
true if the point has a density > 0, otherwise generates a random number between 0 and the max size and if it is > the density, return true, false otherwise. 
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fBdist\fP: the distance of dispersal 
.IP \(bu 2
\fBangle\fP: the angle of dispersal 
.IP \(bu 2
\fBthis_cell\fP: Cell containing the x and y coordinates of the starting position 
.IP \(bu 2
\fBend_cell\fP: Cell to store the end point in
.UNINDENT
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B bool getEndPointClosed(const double &\fIdist\fP, const double &\fIangle\fP, const Cell &\fIthis_cell\fP, Cell &\fIend_cell\fP) 
Checks the density a given distance from the start point on an closed landscape. 
.sp
This also takes into account the rejection sampling of density based on the maximal density value from the map.
.sp
.INDENT 7.0
.TP
\fBReturn\fP
true if the point has a density > 0, otherwise generates a random number between 0 and the max size and if it is > the density, return true, false otherwise. 
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fBdist\fP: the distance of dispersal 
.IP \(bu 2
\fBangle\fP: the angle of dispersal 
.IP \(bu 2
\fBthis_cell\fP: Cell containing the x and y coordinates of the starting position 
.IP \(bu 2
\fBend_cell\fP: Cell to store the end point in
.UNINDENT
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B bool getEndPoint(const double &\fIdist\fP, const double &\fIangle\fP, const Cell &\fIthis_cell\fP, Cell &\fIend_cell\fP) 
Checks the density a given distance from the start point, calling the relevant landscape function. 
.sp
This also takes into account the rejection sampling of density based on the maximal density value from the map.
.sp
.INDENT 7.0
.TP
\fBReturn\fP
true if the point has a density > 0, otherwise generates a random number between 0 and the max size and if it is > the density, return true, false otherwise. 
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fBdist\fP: the distance of dispersal 
.IP \(bu 2
\fBangle\fP: the angle of dispersal 
.IP \(bu 2
\fBthis_cell\fP: Cell containing the x and y coordinates of the starting position 
.IP \(bu 2
\fBend_cell\fP: Cell to store the end point in
.UNINDENT
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B void runMeanDispersalDistance() 
Simulates the dispersal kernel for the set parameters, storing the mean dispersal distance. 
.UNINDENT
.INDENT 7.0
.TP
.B void runMeanDistanceTravelled() 
Simulates the dispersal kernel for the set parameters, storing the mean distance travelled. 
.UNINDENT
.INDENT 7.0
.TP
.B void writeDatabase(string \fItable_name\fP) 
Writes out the distances to the SQL database. 
.sp
.INDENT 7.0
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fBtable_name\fP: the name of the table to output to, either \(aqDISPERSAL_DISTANCE\(aq or \(aqDISTANCES_TRAVELLED\(aq 
.UNINDENT
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B void writeParameters(string \fItable_name\fP) 
Writes the simulation parameters to the output SQL database. 
.sp
.INDENT 7.0
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fBtable_name\fP: the name of the table to output to, either \(aqDISPERSAL_DISTANCE\(aq or \(aqDISTANCES_TRAVELLED\(aq 
.UNINDENT
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B void checkMaxParameterReference() 
Gets the maximum parameter reference from the output SQL database and saves val + 1 to parameter_reference Assumes that the database exists. 
.UNINDENT
.INDENT 7.0
.TP
.B unsigned long checkMaxIdNumber(string \fItable_name\fP) 
Gets the maximum id number from the output SQL database and returns val + 1 Assumes that the database exists. 
.sp
.INDENT 7.0
.TP
\fBNote\fP
this function does not check for SQL injection attacks and should not be used with variable function names. 
.TP
\fBReturn\fP
the maximum id + 1 from the given table 
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fBtable_name\fP: the name of the table to check for max(id) in 
.UNINDENT
.UNINDENT

.UNINDENT
Protected Types.INDENT 7.0
.TP
.B typedef bool (SimulateDispersal::*landscape_fptr)(const double &dist, const double &angle, const Cell &this_cell, Cell &end_cell) 
.UNINDENT
Protected Attributes.INDENT 7.0
.TP
.B Matrix<uint32_t> density_map 
.UNINDENT
.INDENT 7.0
.TP
.B bool has_set_size 
.UNINDENT
.INDENT 7.0
.TP
.B NRrand random 
.UNINDENT
.INDENT 7.0
.TP
.B string map_name 
.UNINDENT
.INDENT 7.0
.TP
.B unsigned long seed 
.UNINDENT
.INDENT 7.0
.TP
.B string dispersal_method 
.UNINDENT
.INDENT 7.0
.TP
.B double sigma 
.UNINDENT
.INDENT 7.0
.TP
.B double tau 
.UNINDENT
.INDENT 7.0
.TP
.B double m_prob 
.UNINDENT
.INDENT 7.0
.TP
.B double cutoff 
.UNINDENT
.INDENT 7.0
.TP
.B sqlite3 *database 
.UNINDENT
.INDENT 7.0
.TP
.B vector<double> distances 
.UNINDENT
.INDENT 7.0
.TP
.B vector<Cell> cells 
.UNINDENT
.INDENT 7.0
.TP
.B unsigned long num_repeats 
.UNINDENT
.INDENT 7.0
.TP
.B unsigned long num_steps 
.UNINDENT
.INDENT 7.0
.TP
.B unsigned long max_density 
.UNINDENT
.INDENT 7.0
.TP
.B bool is_sequential 
.UNINDENT
.INDENT 7.0
.TP
.B unsigned long parameter_reference 
.UNINDENT
.INDENT 7.0
.TP
.B landscape_fptr getValFptr 
.UNINDENT
.UNINDENT
.SS Class SpatialTree
.INDENT 0.0
.IP \(bu 2
Defined in file_necsim_SpatialTree.h
.UNINDENT
.SS Inheritance Relationships
.SS Base Type
.INDENT 0.0
.IP \(bu 2
\fBpublic Tree\fP (class_Tree)
.UNINDENT
.SS Derived Type
.INDENT 0.0
.IP \(bu 2
\fBpublic ProtractedSpatialTree\fP (class_ProtractedSpatialTree)
.UNINDENT
.SS Class Documentation
.INDENT 0.0
.TP
.B class SpatialTree 
Represents the output phylogenetic tree, when run on a spatially\-explicit landscape. 
.sp
Contains all functions for running simulations, outputting data and calculating coalescence tree structure. 
.sp
Inherits from Tree
.sp
Subclassed by ProtractedSpatialTree
Public Functions.INDENT 7.0
.TP
.B SpatialTree() 
The constructor for the tree object. 
.sp
Sets all uninitiated variables to false, except log_all. log_all should be changed to false if minimal text output during simulations is desired. 
.UNINDENT
.INDENT 7.0
.TP
.B ~SpatialTree() 
.UNINDENT
.INDENT 7.0
.TP
.B void importSimulationVariables(const string &\fIconfigfile\fP) 
Imports the simulation variables from the config file. 
.sp
Also checks for paused simulations and file existence. .INDENT 7.0
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fBconfigfile\fP: a vector containing the configfile to import from 
.UNINDENT
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B void parseArgs(vector<string> &\fIcomargs\fP) 
Parses the command line arguments and saves the flags in Tree for fullmode, resuming and other important variables. 
.sp
.INDENT 7.0
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fBcomargs\fP: 
.UNINDENT
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B void checkFolders() 
Checks that the folders exist and the files required for the simulation also exist. 
.UNINDENT
.INDENT 7.0
.TP
.B void setParameters() 
Sets the map object with the correct variables, taking the SimParameters structure defined elsewhere for the parameters. 
.sp
Requires that parameters have already been imported into the SimParameters
.sp
This function can only be run once, otherwise a Main_Exception will be thrown 
.UNINDENT
.INDENT 7.0
.TP
.B void importMaps() 
Imports the maps into the forestmap object. 
.sp
The simulation variables should have already been imported by setParameters(), otherwise a Fatal_Exception will be thrown. 
.UNINDENT
.INDENT 7.0
.TP
.B void importReproductionMap() 
Imports the reproduction map from file. 
.UNINDENT
.INDENT 7.0
.TP
.B unsigned long getInitialCount() 
Counts the number of individuals that exist on the spatial grid. 
.sp
.INDENT 7.0
.TP
\fBReturn\fP
the number of individuals that will be initially simulated 
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B void setupDispersalCoordinator() 
Sets up the dispersal coordinator by linking to the correct functions and choosing the appropriate dispersal method. 
.UNINDENT
.INDENT 7.0
.TP
.B void setup() 
Contains the setup routines for a spatial landscape. It also checks for paused simulations and imports data if necessary from paused files. importMaps() is called for importing the map files. 
.sp

.UNINDENT
.INDENT 7.0
.TP
.B unsigned long fillObjects(const unsigned long &\fIinitial_count\fP) 
Fill the active, data and grid objects with the starting lineages. 
.sp
.INDENT 7.0
.TP
\fBReturn\fP
the number of lineages added (for validation purposes) 
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fBinitial_count\fP: the number of individuals expected to exist 
.UNINDENT
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B unsigned long getIndividualsSampled(const long &\fIx\fP, const long &\fIy\fP, const long &\fIx_wrap\fP, const long &\fIy_wrap\fP, const double &\fIcurrent_gen\fP) 
Gets the number of individuals to be sampled at the particular point and time. Round the number down to the nearest whole number for numbers of individuals. 
.sp
.INDENT 7.0
.TP
\fBReturn\fP
the number of individuals to sample at this location. 
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fBx\fP: the x location for individuals to be sampled 
.IP \(bu 2
\fBy\fP: the y location for individuals to be sampled 
.IP \(bu 2
\fBx_wrap\fP: the number of x wraps for the cell 
.IP \(bu 2
\fBy_wrap\fP: the number of y wraps for the cell 
.IP \(bu 2
\fBcurrent_gen\fP: the current generation timer 
.UNINDENT
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B void removeOldPosition(const unsigned long &\fIchosen\fP) 
Removes the old position within active by checking any wrapping and removing connections. 
.sp
The function also corrects the linked list to identify the correct nwrap for every wrapped lineage in that space.
.sp
.INDENT 7.0
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fBchosen\fP: the desired active reference to remove from the grid. 
.UNINDENT
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B void calcMove() 
Calculate the move, given a start x,y coordinates and wrapping. 
.sp
The provided parameters will be altered to contain the new values so no record of the old variables remains after function running. Current dispersal methods use a fattailed dispersal. 
.UNINDENT
.INDENT 7.0
.TP
.B long double calcMinMax(const unsigned long &\fIcurrent\fP) 
Calculates the minmax for a given branch. 
.sp
Calculates the speciation rate required for speciation to have occured on this branch.
.sp
.INDENT 7.0
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fBcurrent\fP: the current active reference to perform calculations over. 
.UNINDENT
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B void calcNewPos(bool &\fIcoal\fP, const unsigned long &\fIchosen\fP, unsigned long &\fIcoalchosen\fP, const long &\fIoldx\fP, const long &\fIoldy\fP, const long &\fIoldxwrap\fP, const long &\fIoldywrap\fP) 
Calculates the new position, checking whether coalescence has occured and with which lineage. 
.sp
This involves correct handling of checking wrapped lineages (outside the original grid). The probability of coalescence is also calculated.
.sp
.INDENT 7.0
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fBcoal\fP: boolean for whether coalescence occured or not 
.IP \(bu 2
\fBchosen\fP: the chosen lineage 
.IP \(bu 2
\fBcoalchosen\fP: the lineaged that is coalescing (if required) 
.IP \(bu 2
\fBoldx\fP: the old x position 
.IP \(bu 2
\fBoldy\fP: the old y position 
.IP \(bu 2
\fBoldxwrap\fP: the old x wrapping 
.IP \(bu 2
\fBoldywrap\fP: the old y wrapping 
.UNINDENT
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B void switchPositions(const unsigned long &\fIchosen\fP) 
Switches the chosen position with the endactive position. 
.sp
.INDENT 7.0
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fBchosen\fP: the chosen lineage to switch with endactive. 
.UNINDENT
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B void calcNextStep() 
Calculates the next step for the simulation. 
.UNINDENT
.INDENT 7.0
.TP
.B unsigned long estSpecnum() 
Estimates the species number from the second largest minimum speciation rate remaining in active. 
.sp
This allows for halting of the simulation once this threshold has been reached. However, the function is not currently in use as calculating the coalescence tree is very computionally intensive. 
.UNINDENT
.INDENT 7.0
.TP
.B void incrementGeneration() 
Increments the generation counter and step references, then updates the map for any changes to habitat cover. 
.UNINDENT
.INDENT 7.0
.TP
.B void updateStepCoalescenceVariables() 
Updates the coalescence variables in the step object. 
.UNINDENT
.INDENT 7.0
.TP
.B void addLineages(double \fIgeneration_in\fP) 
Expands the map, generating the new lineages where necessary. 
.sp
The samplemask provided is used for expansion. Any empty spaces are filled with a new lineage. Lineages which have not moved are changed to tips, with a new data entry so that original and new generations are recorded.
.sp
.INDENT 7.0
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fBgeneration_in\fP: the generation that the expansion is occuring at. This is used in recording the new tips 
.UNINDENT
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B string simulationParametersSqlInsertion() 
Creates a string containing the SQL insertion statement for the simulation parameters. 
.sp
.INDENT 7.0
.TP
\fBReturn\fP
string containing the SQL insertion statement 
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B void simPause() 
Pause the simulation and dump data from memory. 
.UNINDENT
.INDENT 7.0
.TP
.B void dumpMap(string \fIpause_folder\fP) 
Saves the map object to file. 
.sp
.INDENT 7.0
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fBpause_folder\fP: the folder to save files into 
.UNINDENT
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B void simResume() 
Resumes the simulation from a previous state. 
.sp
Reads in the parameters and objects from file and re\-starts the simulation. 
.UNINDENT
.INDENT 7.0
.TP
.B void loadGridSave() 
Loads the grid from the save file into memory. 
.UNINDENT
.INDENT 7.0
.TP
.B void loadMapSave() 
Loads the map from the save file into memory. 
.UNINDENT
.INDENT 7.0
.TP
.B void verifyReproductionMap() 
Checks that the reproduction map makes sense with the fine density map. 
.UNINDENT
.INDENT 7.0
.TP
.B void addWrappedLineage(unsigned long \fInumstart\fP, long \fIx\fP, long \fIy\fP) 
Adds the lineage to the correct point in the linked list of active lineages. 
.sp
.INDENT 7.0
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fBnumstart\fP: the active position to add 
.IP \(bu 2
\fBx\fP: the x position of the lineage 
.IP \(bu 2
\fBy\fP: the y position of the lineage 
.UNINDENT
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B unsigned long countCellExpansion(const long &\fIx\fP, const long &\fIy\fP, const long &\fIxwrap\fP, const long &\fIywrap\fP, const double &\fIgenerationin\fP, const bool &\fImake_tips\fP) 
Counts the number of lineages at a particular location that need to be added, after making the correct number of those that already exist into tips. 
.sp
.INDENT 7.0
.TP
\fBReturn\fP
the number of new lineages that need to be added. 
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fBx\fP: the x coordinate of the location of interest 
.IP \(bu 2
\fBy\fP: the y coordinate of the location of interest 
.IP \(bu 2
\fBxwrap\fP: the x wrapping of the location 
.IP \(bu 2
\fBywrap\fP: the y wrapping of the location 
.IP \(bu 2
\fBgenerationin\fP: the generation to assign to new tips 
.IP \(bu 2
\fBmake_tips\fP: if true, stores the tips as well as counting them 
.UNINDENT
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B void expandCell(long \fIx\fP, long \fIy\fP, long \fIx_wrap\fP, long \fIy_wrap\fP, double \fIgeneration_in\fP, unsigned long \fIadd\fP) 
Expands the cell at the desired location by adding the supplied number of lineages. 
.sp
This takes into account wrapping to correctly add the right number
.sp
.INDENT 7.0
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fBx\fP: the x coordinate to add at 
.IP \(bu 2
\fBy\fP: the y coordinate to add at 
.IP \(bu 2
\fBx_wrap\fP: the x wrapping to add at 
.IP \(bu 2
\fBy_wrap\fP: the y wrapping to add at 
.IP \(bu 2
\fBgeneration_in\fP: the generation to set the new lineages to 
.IP \(bu 2
\fBadd\fP: the total number of lineages to add at this location 
.UNINDENT
.UNINDENT

.UNINDENT
Protected Attributes.INDENT 7.0
.TP
.B DispersalCoordinator dispersal_coordinator 
.UNINDENT
.INDENT 7.0
.TP
.B ReproductionMap rep_map 
.UNINDENT
.INDENT 7.0
.TP
.B string fine_map_input 
.UNINDENT
.INDENT 7.0
.TP
.B string coarse_map_input 
.UNINDENT
.INDENT 7.0
.TP
.B string pristine_fine_map_input 
.UNINDENT
.INDENT 7.0
.TP
.B string pristine_coarse_map_input 
.UNINDENT
.INDENT 7.0
.TP
.B double gen_since_pristine 
.UNINDENT
.INDENT 7.0
.TP
.B double habitat_change_rate 
.UNINDENT
.INDENT 7.0
.TP
.B unsigned long grid_x_size 
.UNINDENT
.INDENT 7.0
.TP
.B unsigned long grid_y_size 
.UNINDENT
.INDENT 7.0
.TP
.B long fine_map_x_size 
.UNINDENT
.INDENT 7.0
.TP
.B long fine_map_y_size 
.UNINDENT
.INDENT 7.0
.TP
.B long fine_map_x_offset 
.UNINDENT
.INDENT 7.0
.TP
.B long fine_map_y_offset 
.UNINDENT
.INDENT 7.0
.TP
.B long coarse_map_x_size 
.UNINDENT
.INDENT 7.0
.TP
.B long coarse_map_y_size 
.UNINDENT
.INDENT 7.0
.TP
.B long coarse_map_x_offset 
.UNINDENT
.INDENT 7.0
.TP
.B long coarse_map_y_offset 
.UNINDENT
.INDENT 7.0
.TP
.B long coarse_map_scale 
.UNINDENT
.INDENT 7.0
.TP
.B Map habitat_map 
.UNINDENT
.INDENT 7.0
.TP
.B Matrix<SpeciesList> grid 
.UNINDENT
.INDENT 7.0
.TP
.B double sigma 
.UNINDENT
.INDENT 7.0
.TP
.B double tau 
.UNINDENT
.INDENT 7.0
.TP
.B double dispersal_relative_cost 
.UNINDENT
.INDENT 7.0
.TP
.B unsigned long desired_specnum 
.UNINDENT
.INDENT 7.0
.TP
.B DataMask samplegrid 
.UNINDENT
.UNINDENT
.SS Class SpeciationCommands
.INDENT 0.0
.IP \(bu 2
Defined in file_necsim_SpeciationCommands.h
.UNINDENT
.SS Class Documentation
.INDENT 0.0
.TP
.B class SpeciationCommands 
Routines for parsing command\-line arguments to apply speciation rates to a necsim output post\-simulation. 
Public Functions.INDENT 7.0
.TP
.B SpeciationCommands() 
Default constructor for SpeciationCommands class. 
.UNINDENT
.INDENT 7.0
.TP
.B void parseArgs() 
Run the command line arguments check. Writes arguments to the SpecSimParameters object. 
.sp
.INDENT 7.0
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fBargc\fP: the number of arguments. 
.IP \(bu 2
\fBcomargs\fP: a vector filled with the command line arguments 
.UNINDENT
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B int applyFromComargs(int \fIargc_in\fP, char **\fIargv\fP) 
Runs the main program including parsing command line arguments and running the main analyses. 
.sp
.INDENT 7.0
.TP
\fBReturn\fP

.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fBargc\fP: the number of command line arguments 
.IP \(bu 2
\fBargv\fP: the array of command line arguments 
.UNINDENT
.UNINDENT

.UNINDENT
.UNINDENT
.SS Class SpeciesList
.INDENT 0.0
.IP \(bu 2
Defined in file_necsim_SpeciesList.h
.UNINDENT
.SS Class Documentation
.INDENT 0.0
.TP
.B class SpeciesList 
Contains a list of the species that exist at one location. The Row object, list, contains the active reference number, for looking up the lineage in a Row of Datapoint objects. Also contains the functions for correctly generating coalescence probabilities and list management. 
.sp
Note that the maximum size of the list is constrained by the maximum size of unsigned long. Any simulation requiring more individuals per cell than this will unlikely finish in any reasonable time anyway. 
Public Functions.INDENT 7.0
.TP
.B SpeciesList() 
Default constructor. 
.UNINDENT
.INDENT 7.0
.TP
.B ~SpeciesList() 
Default destructor. 
.UNINDENT
.INDENT 7.0
.TP
.B void fillList() 
Fills the list with 0, up to the specified maximum size. 
.UNINDENT
.INDENT 7.0
.TP
.B void initialise(unsigned long \fImaxsizein\fP) 
Initialises the list to the specified size. 
.sp
.INDENT 7.0
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fBmaxsizein\fP: the maximum list size. 
.UNINDENT
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B void setMaxsize(unsigned long \fImaxsizein\fP) 
Sets the maxsize without altering the actual size of list. 
.sp
.INDENT 7.0
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fBmaxsizein\fP: The new maximum size to set. 
.UNINDENT
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B void setSpecies(unsigned long \fIindex\fP, unsigned long \fInew_val\fP) 
Set specific entry to a particular species reference number. 
.sp

This version throws an error if the space is empty. .INDENT 7.0
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fBindex\fP: the location in list of the species. 
.IP \(bu 2
\fBnew_val\fP: the new species reference to set list[index] to.
.UNINDENT
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B void setSpeciesEmpty(int \fIindex\fP, unsigned long \fInew_val\fP) 
Set specific entry to a particular species reference number. 
.sp

Note this version will throw a runtime_error if the space is not empty .INDENT 7.0
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fBindex\fP: the location in list of the species 
.IP \(bu 2
\fBnew_val\fP: the new species reference to set list[index] to
.UNINDENT
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B void setNext(unsigned long \fIn\fP) 
Set the next active lineage (for wrapping purposes). 
.sp
.INDENT 7.0
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fBn\fP: the lineage to set as the first wrapped lineage. 
.UNINDENT
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B void setNwrap(unsigned long \fInr\fP) 
Set the number of wrapping lineages. 
.sp
.INDENT 7.0
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fBnr\fP: the number of wrapped lineages. 
.UNINDENT
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B unsigned long addSpecies(unsigned long \fInew_spec\fP) 
Add a new species to the first empty place and return the position of the lineage. 
.sp
.INDENT 7.0
.TP
\fBReturn\fP
the location the species has been added to. 
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fBnew_spec\fP: the new species reference to place in the first empty space. 
.UNINDENT
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B void addSpeciesSilent(unsigned long \fInew_spec\fP) 
Add a new species to the first empty place. Essentially a version of addSpecies() without returning the species location. 
.sp
.INDENT 7.0
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fBnew_spec\fP: the new species reference to place in the first empty space. 
.UNINDENT
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B void deleteSpecies(unsigned long \fIindex\fP) 
Removes the species at the specified index. The species number will be replaced with 0, indicating no species present. 
.sp
Older versions of this function re\-shuffled the list so that all species came at the top. .INDENT 7.0
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fBindex\fP: the index of the species to remove from the list. 
.UNINDENT
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B void decreaseNwrap() 
Decreases the nwrap by one. 
.sp
Indicates the number of species wrapped at the location of this SpeciesList object has decreased by one. 
.UNINDENT
.INDENT 7.0
.TP
.B void increaseListSize() 
Increases the list size by one. 
.UNINDENT
.INDENT 7.0
.TP
.B void increaseNwrap() 
Increases the nwrap by one. 
.sp
Indicates the number of species wrapped at the location of this SpeciesList object has increased by one. 
.UNINDENT
.INDENT 7.0
.TP
.B void changePercentCover(unsigned long \fInewmaxsize\fP) 
Changes the maximum size of the SpeciesList\&. Creates a new list object with all the species in the correct place from the old list object and zeros everywhere else. 
.sp
.INDENT 7.0
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fBnewmaxsize\fP: the new maximum size to be applied. 
.UNINDENT
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B unsigned long getRandLineage(NRrand &\fIrand_no\fP) 
Get a random species reference number from all the potential entries. Updated alternative version returns any entry, including empty cells, giving the probability of coalescence as well. 
.sp
.INDENT 7.0
.TP
\fBReturn\fP
the reference of the random lineage. 0 indicates an empty space. 
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fBrand_no\fP: the random number object to pass (for maintaining the same seed throughout simulations). 
.UNINDENT
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B unsigned long getSpecies(unsigned long \fIindex\fP) 
Get the species reference number from a particular entry. 
.sp
.INDENT 7.0
.TP
\fBReturn\fP
the species reference at the specified location. 
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fBindex\fP: the location of the species to reference. 
.UNINDENT
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B unsigned long getNext() 
Get the next_active variable. 
.sp
.INDENT 7.0
.TP
\fBReturn\fP
the next linked species reference. 
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B unsigned long getNwrap() 
Getter for the nwrap. 
.sp
.INDENT 7.0
.TP
\fBReturn\fP
the number of wrapped lineages currently at this grid cell. 
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B unsigned long getListsize() 
Getter for the list size. 
.sp
.INDENT 7.0
.TP
\fBReturn\fP
the number of lineages currently directly within the SpeciesList\&. 
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B unsigned long getMaxsize() 
Getter for the maximum size of the SpeciesList object. 
.sp
.INDENT 7.0
.TP
\fBReturn\fP
the maximum number of lineages that can exist currently. 
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B void wipeList() 
Empties the list of any data and fills the list with zeros. 
.UNINDENT
Friends.INDENT 7.0
.TP
.B ostream &operator<<(ostream &\fIos\fP, const SpeciesList &\fIr\fP) 
Outputs the SpeciesList object to an output stream. Allows for piping to the terminal or writing the object to a file. 
.sp
.INDENT 7.0
.TP
\fBReturn\fP
the output stream. 
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fBos\fP: the output stream. 
.IP \(bu 2
\fBr\fP: the SpeciesList object to output. 
.UNINDENT
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B istream &operator>>(istream &\fIis\fP, SpeciesList &\fIr\fP) 
Inputs the SpeciesList object from an input stream. Allows for reading data from a file or string stream. 
.sp
.INDENT 7.0
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fBis\fP: the input stream. 
.IP \(bu 2
\fBr\fP: the SpeciesList object to input to. 
.UNINDENT
.UNINDENT

.UNINDENT
.UNINDENT
.SS Class SpecSimParameters
.INDENT 0.0
.IP \(bu 2
Defined in file_necsim_SpecSimParameters.h
.UNINDENT
.SS Class Documentation
.INDENT 0.0
.TP
.B class SpecSimParameters 
Contains the simulation parameters that are read from the command line. 
Public Functions.INDENT 7.0
.TP
.B void setup(string \fIfile_in\fP, bool \fIuse_spatial_in\fP, string \fIsample_file\fP, string \fItime_config\fP, string \fIuse_fragments_in\fP, vector<double> \fIspeciation_rates\fP, double \fImin_speciation_gen_in\fP, double \fImax_speciation_gen_in\fP) 
Sets the application arguments for the inputs. Intended for use with the applyspecmodule for integration with python. 
.sp
.INDENT 7.0
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fBfile_in\fP: the database to apply speciation rates to 
.IP \(bu 2
\fBuse_spatial_in\fP: if true, record full spatial data 
.IP \(bu 2
\fBsample_file\fP: the sample file to select lineages from the map 
.IP \(bu 2
\fBtime_config\fP: the time config file to use 
.IP \(bu 2
\fBuse_fragments_in\fP: fragment file, or "T"/"F" for automatic detection/no detection 
.IP \(bu 2
\fBspeciation_rates\fP: the speciation rates to apply 
.IP \(bu 2
\fBmin_speciation_gen_in\fP: the minimum generation rate for speciation in protracted simulations 
.IP \(bu 2
\fBmax_speciation_gen_in\fP: the maximum generation rate for speciation in protracted simulations 
.UNINDENT
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B void setup(string \fIfile_in\fP, bool \fIuse_spatial_in\fP, string \fIsample_file\fP, string \fItime_config\fP, string \fIuse_fragments_in\fP, vector<double> \fIspeciation_rates\fP, double \fImin_speciation_gen_in\fP, double \fImax_speciation_gen_in\fP, unsigned long \fImetacommunity_size_in\fP, double \fImetacommunity_speciation_rate_in\fP) 
Sets the application arguments for the inputs. Intended for use with the applyspecmodule for integration with python. 
.sp
.INDENT 7.0
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fBfile_in\fP: the database to apply speciation rates to 
.IP \(bu 2
\fBuse_spatial_in\fP: if true, record full spatial data 
.IP \(bu 2
\fBsample_file\fP: the sample file to select lineages from the map 
.IP \(bu 2
\fBtime_config\fP: the time config file to use 
.IP \(bu 2
\fBuse_fragments_in\fP: fragment file, or "T"/"F" for automatic detection/no detection 
.IP \(bu 2
\fBspeciation_rates\fP: the speciation rates to apply 
.IP \(bu 2
\fBmin_speciation_gen_in\fP: the minimum generation rate for speciation in protracted simulations 
.IP \(bu 2
\fBmax_speciation_gen_in\fP: the maximum generation rate for speciation in protracted simulations 
.IP \(bu 2
\fBmetacommunity_size_in\fP: 
.IP \(bu 2
\fBmetacommunity_speciation_rate_in\fP: 
.UNINDENT
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B void importTimeConfig() 
Import the time config file, if there is one. 
.UNINDENT
Public Members.INDENT 7.0
.TP
.B bool use_spatial 
.UNINDENT
.INDENT 7.0
.TP
.B bool bMultiRun 
.UNINDENT
.INDENT 7.0
.TP
.B bool use_fragments 
.UNINDENT
.INDENT 7.0
.TP
.B string filename 
.UNINDENT
.INDENT 7.0
.TP
.B vector<double> all_speciation_rates 
.UNINDENT
.INDENT 7.0
.TP
.B string samplemask 
.UNINDENT
.INDENT 7.0
.TP
.B string times_file 
.UNINDENT
.INDENT 7.0
.TP
.B vector<double> all_times 
.UNINDENT
.INDENT 7.0
.TP
.B string fragment_config_file 
.UNINDENT
.INDENT 7.0
.TP
.B double min_speciation_gen 
.UNINDENT
.INDENT 7.0
.TP
.B double max_speciation_gen 
.UNINDENT
.INDENT 7.0
.TP
.B unsigned long metacommunity_size 
.UNINDENT
.INDENT 7.0
.TP
.B double metacommunity_speciation_rate 
.UNINDENT
.UNINDENT
.SS Class Step
.INDENT 0.0
.IP \(bu 2
Defined in file_necsim_Step.h
.UNINDENT
.SS Class Documentation
.INDENT 0.0
.TP
.B class Step 
Stores the elements associated with a single step in a coalescence simulation. 
.sp
This object should only contain transient variables that are used within a single simulation step and therefore should not be important for pausing/resuming simulations. 
Public Functions.INDENT 7.0
.TP
.B Step() 
Step constructor. 
.sp
.INDENT 7.0
.TP
\fBReturn\fP

.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B void wipeData() 
Removes all stored data from the step. This should be run at the start of a single coalescence step. 
.UNINDENT
Public Members.INDENT 7.0
.TP
.B unsigned long chosen 
.UNINDENT
.INDENT 7.0
.TP
.B unsigned long coalchosen 
.UNINDENT
.INDENT 7.0
.TP
.B long oldx 
.UNINDENT
.INDENT 7.0
.TP
.B long oldy 
.UNINDENT
.INDENT 7.0
.TP
.B long oldxwrap 
.UNINDENT
.INDENT 7.0
.TP
.B long oldywrap 
.UNINDENT
.INDENT 7.0
.TP
.B bool coal 
.UNINDENT
.INDENT 7.0
.TP
.B bool bContinueSim 
.UNINDENT
.INDENT 7.0
.TP
.B unsigned int time_reference 
.UNINDENT
.INDENT 7.0
.TP
.B double distance 
.UNINDENT
.INDENT 7.0
.TP
.B double angle 
.UNINDENT
.UNINDENT
.SS Class Tree
.INDENT 0.0
.IP \(bu 2
Defined in file_necsim_Tree.h
.UNINDENT
.SS Inheritance Relationships
.SS Derived Types
.INDENT 0.0
.IP \(bu 2
\fBpublic ProtractedTree\fP (class_ProtractedTree)
.IP \(bu 2
\fBpublic SpatialTree\fP (class_SpatialTree)
.UNINDENT
.SS Class Documentation
.INDENT 0.0
.TP
.B class Tree 
Main simulation class for performing a non\-spatial neutral simulation and generating the phylogenetic tree of the individuals. 
.sp
Subclassed by ProtractedTree, SpatialTree
Public Functions.INDENT 7.0
.TP
.B Tree() 
.UNINDENT
.INDENT 7.0
.TP
.B virtual ~Tree() 
.UNINDENT
.INDENT 7.0
.TP
.B void importSimulationVariables(const string &\fIconfigfile\fP) 
Import the simulation variables from the command line structure. 
.sp
This function parses the simulation variables, imports them (from either the command line or a config file), checks that the input files exist and checks for any paused simulations. The flags are then set correctly, meaning that setup() and runSim() can be run immediately afterwards.
.sp
.INDENT 7.0
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fBcomargs\fP: a vector of strings, containing the command\-line arguments 
.UNINDENT
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B void internalSetup(const SimParameters &\fIsim_parameters_in\fP) 
Sets up the simulation parameters from the one provided. 
.sp
Intended for usage with metacommunity application. No output directory is expected. .INDENT 7.0
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fBsim_parameters_in\fP: the simulation parameters to set up the simulation with 
.UNINDENT
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B bool checkOutputDirectory() 
Asserts that the output directory is not null and exists. If it doesn\(aqt exist, it attempts to create it. 
.sp
.INDENT 7.0
.TP
\fBReturn\fP
true if output creates successfully 
.TP
\fBExceptions\fP
.INDENT 7.0
.IP \(bu 2
\fBFatal_Exception\fP: if the output directory creation fails 
.UNINDENT
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B void checkSims() 
Checks for existing paused simulations to resume from Sets bPaused if there are. 
.sp
This version uses the default values read from the config file. 
.UNINDENT
.INDENT 7.0
.TP
.B void checkSims(string \fIoutput_dir\fP, long \fIseed\fP, long \fItask\fP) 
Checks for existing paused simulations to resume from. 
.sp
Sets bPaused if there are.
.sp
This version uses the values supplied to the function directly
.sp
.INDENT 7.0
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fBoutput_dir\fP: the output directory to check for 
.IP \(bu 2
\fBseed\fP: the seed for paused sims 
.IP \(bu 2
\fBtask\fP: the task for paused sims 
.UNINDENT
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B void setParameters() 
Move the parameters from the sim_parameters object to their relevant parameters. 
.UNINDENT
.INDENT 7.0
.TP
.B void setProtractedVariables(double \fIspeciation_gen_min\fP, double \fIspeciation_gen_max\fP) 
Sets the protracted variables. 
.sp
.INDENT 7.0
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fBspeciation_gen_min\fP: the minimum number of generations to have passed before speciation is allowed 
.IP \(bu 2
\fBspeciation_gen_max\fP: the maximum number of generations a lineage can exist for before it is speciated. 
.UNINDENT
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B bool hasPaused() 
Gets the has_paused variable for resuming sims. 
.sp
.INDENT 7.0
.TP
\fBReturn\fP
if the simulation has paused 
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B vector<double> getTemporalSampling() 
Gets the map autocorrel times. 
.UNINDENT
.INDENT 7.0
.TP
.B long long getSeed() 
Getter for the simulation seed. 
.sp
.INDENT 7.0
.TP
\fBReturn\fP
Returns the seeds 
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B void setSeed(long long \fIseed_in\fP) 
Sets the simulation seed for the random number generator. 
.sp
This function should only be called once.
.sp
The seed is set within the NR object. This will be fixed for the simulation and is only performed once.
.sp
.INDENT 7.0
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fBseed_in\fP: the desired seed to set for the simulation 
.UNINDENT
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B unsigned long getInitialCount() 
Gets the initial number of individuals. 
.sp
.INDENT 7.0
.TP
\fBReturn\fP
the number of initial individuals to simulate 
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B unsigned long setObjectSizes() 
Sets the sizes of grid, active and data, based on the number of individuals counted from the samplemask. 
.sp
.INDENT 7.0
.TP
\fBReturn\fP
a count of the number of individuals that exist in the simulation 
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B void setup() 
The setup function for generating the simulation objects. 
.sp
The simulation parameters are set from comargs using setParameters()\&. Generates and fills the active and grid objects as well as importing all the maps from the supplied files. 
.UNINDENT
.INDENT 7.0
.TP
.B void setInitialValues() 
Sets the starting values for required parameters. 
.UNINDENT
.INDENT 7.0
.TP
.B void setSimStartVariables() 
Sets the variables at the start of a simulation for temporary data. 
.sp
This is not the main set\-up routine, which creates the permanent data structures including maps, the coalescence tree and active lineage listings. 
.UNINDENT
.INDENT 7.0
.TP
.B void printSetup() 
Prints the statement for the setup initiation. 
.sp
This is stored in a separate function so that it can be called in isolation by child classes. 
.UNINDENT
.INDENT 7.0
.TP
.B void setTimes() 
Sets the temporal sampling points from the time config file. 
.UNINDENT
.INDENT 7.0
.TP
.B void determineSpeciationRates() 
Determines the speciation rates to apply and then applies them to the coalescence tree post\-simulation. 
.sp
Detects speciation rates from the config files supplied. 
.UNINDENT
.INDENT 7.0
.TP
.B void generateObjects() 
Assigns the objects sizes in memory and fills with the starting lineages. 
.UNINDENT
.INDENT 7.0
.TP
.B unsigned long fillObjects(const unsigned long &\fIinitial_count\fP) 
Fills the active and data objects with the starting lineages. 
.sp
.INDENT 7.0
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fBinitial_count\fP: the number of individuals expected to exist 
.UNINDENT
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B bool runSimulation() 
Run the entire simulation given the start conditions already defined by setup() 
.sp
Setup is assumed to have been run already. This function is the main function containing the main loop of the simulation. At the end of the simulation, returns true if the simulation is complete, false otherwise. 
.UNINDENT
.INDENT 7.0
.TP
.B void writeSimStartToConsole() 
Writes to the console that the simulation is beginning. 
.UNINDENT
.INDENT 7.0
.TP
.B void writeStepToConsole() 
Write the step counter to console. This function should only be called in debugging mode. 
.UNINDENT
.INDENT 7.0
.TP
.B void incrementGeneration() 
Increments the generation counter and step references. 
.UNINDENT
.INDENT 7.0
.TP
.B void chooseRandomLineage() 
Chooses a random lineage from active. 
.sp
The index of the random lineage is stored in this_step, as chosen. Also records the required variables for the step process, like x, y position. 
.UNINDENT
.INDENT 7.0
.TP
.B void updateStepCoalescenceVariables() 
Updates the coalescence variables in the step object. 
.UNINDENT
.INDENT 7.0
.TP
.B void speciation(const unsigned long &\fIchosen\fP) 
Speciation to supplied lineage. 
.sp
Also calls the removeOldPos() and switchPositions() functions for removing the lineage out of active reference. .INDENT 7.0
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fBchosen\fP: 
.UNINDENT
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B void speciateLineage(const unsigned long &\fIdata_position\fP) 
Performs the actual speciation. 
.sp
.INDENT 7.0
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fBdata_position\fP: the position in the array of TreeNodes for this lineage 
.UNINDENT
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B void removeOldPosition(const unsigned long &\fIchosen\fP) 
Removes the old position within active. 
.sp
.INDENT 7.0
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fBchosen\fP: the desired active reference to remove from the grid. 
.UNINDENT
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B void switchPositions(const unsigned long &\fIchosen\fP) 
Switches the chosen position with the endactive position. 
.sp
.INDENT 7.0
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fBchosen\fP: the chosen lineage to switch with endactive. 
.UNINDENT
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B void calcNextStep() 
Calculates the next step for the simulation. 
.UNINDENT
.INDENT 7.0
.TP
.B bool calcSpeciation(const long double &\fIrandom_number\fP, const long double &\fIspeciation_rate\fP, const unsigned long &\fIno_generations\fP) 
Calculates the speciation probability from the random number, speciation rate and number of generations a lineage has existed for. 
.sp
.INDENT 7.0
.TP
\fBReturn\fP
if true, speciation has occured 
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fBrandom_number\fP: the generated random number from 0\-1 
.IP \(bu 2
\fBspeciation_rate\fP: the speciation rate to be applied 
.IP \(bu 2
\fBno_generations\fP: the number of generations a lineage has existed for 
.UNINDENT
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B void coalescenceEvent(const unsigned long &\fIchosen\fP, unsigned long &\fIcoalchosen\fP) 
Perform the coalescence between lineages. Once coalesced, lineages are removed from the active scope. 
.sp
.INDENT 7.0
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fBchosen\fP: the chosen lineage for coalescence 
.IP \(bu 2
\fBcoalchosen\fP: the target lineage for coalscence 
.UNINDENT
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B void checkTimeUpdate() 
Checks if the number of lineages should be expanded at another sample point. 
.UNINDENT
.INDENT 7.0
.TP
.B void addLineages(double \fIgeneration_in\fP) 
Adds the required lineages at the generation time. 
.sp
.INDENT 7.0
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fBgeneration_in\fP: the generation to add lineages at 
.UNINDENT
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B void checkSimSize(unsigned long \fIreq_data\fP, unsigned long \fIreq_active\fP) 
Checks the size of the main active and data objects is large enough. 
.sp
.INDENT 7.0
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fBreq_data\fP: the required data object size 
.IP \(bu 2
\fBreq_active\fP: the required active object size 
.UNINDENT
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B void makeTip(const unsigned long &\fItmp_active\fP, const double &\fIgeneration_in\fP) 
Sets the active reference to a tip, if it isn\(aqt one already. Otherwise, creates a new tip for the new generation time. 
.sp
.INDENT 7.0
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fBtmp_active\fP: the reference in active 
.IP \(bu 2
\fBgeneration_in\fP: the generation to set for the new lineage 
.UNINDENT
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B void convertTip(unsigned long \fIi\fP, double \fIgenerationin\fP) 
Creates a new reference in data containing the tip with a new generation counter. 
.sp
.INDENT 7.0
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fBi\fP: the reference in active of the lineage to make a tip 
.IP \(bu 2
\fBgenerationin\fP: the generation to make the lineage a tip at 
.UNINDENT
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B bool stopSimulation() 
Finalises the simulation, and performs the correct tasks depending if the sim has been paused or finished. 
.sp
.INDENT 7.0
.TP
\fBReturn\fP

.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B void applySpecRate(long double \fIsr\fP, double \fIt\fP) 
Applies the given speciation rate to the tree. 
.sp
.INDENT 7.0
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fBsr\fP: the required speciation rate 
.IP \(bu 2
\fBt\fP: the required time of speciation 
.UNINDENT
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B void applySpecRateInternal(long double \fIsr\fP, double \fIt\fP) 
Applies the given speciation rate to the tree, but does not output to a file. Instead returns a pointer to the nodes object. 
.sp
.INDENT 7.0
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fBsr\fP: the required speciation rate 
.IP \(bu 2
\fBt\fP: the required time of speciation 
.UNINDENT
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B Row<unsigned long> *getCumulativeAbundances() 
Gets the sorted cumulative species abundances from the contained TreeList. 
.sp
For use with metacommunity applications .INDENT 7.0
.TP
\fBReturn\fP
row of cumulative species abundances 
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B void setupTreeGeneration(long double \fIsr\fP, double \fIt\fP) 
Sets up the generation of the tree object. 
.sp
.INDENT 7.0
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fBsr\fP: the required speciation rate 
.IP \(bu 2
\fBt\fP: the required time of speciation 
.UNINDENT
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B void applySpecRate(long double \fIsr\fP) 
Overloaded version of applySpecRates for the default generation (0.0). 
.sp
.INDENT 7.0
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fBsr\fP: the speciation rate to apply to the tree 
.UNINDENT
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B void applyMultipleRates() 
Applies multiple speciation rates to the coalescence tree, ignoring repeated speciation rates. 
.sp
Speciation rates are read from the speciation_rates object, which should have already been calculated. 
.UNINDENT
.INDENT 7.0
.TP
.B bool getProtracted() 
Gets the protractedness of the simulation. Overridden by protracted child classes. 
.sp
.INDENT 7.0
.TP
\fBReturn\fP

.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B string getProtractedVariables() 
Gets the protracted variables and returns them as a single, newline separated string. This method is intended to be overridden in derived classes. 
.sp
.INDENT 7.0
.TP
\fBReturn\fP
string containing the protracted variables, separated by newlines. 
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B double getProtractedGenerationMin() 
Gets the minimum number of generations a lineage must exist. 
.sp
Without overriding this function, should always return 0.0. .INDENT 7.0
.TP
\fBReturn\fP
double the number of generations a lineage must exist 
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B double getProtractedGenerationMax() 
Gets the maximum number of generations a lineage can exist. 
.sp
Without overriding this function, should always return 0.0 (no maximum).
.sp
.INDENT 7.0
.TP
\fBReturn\fP
double the number of generations a lineage must exist 
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B void sqlOutput() 
Copy the in\-memory database to file. 
.sp
This function should not be called if the database is already opened on disc, and won\(aqt do anything if it is. 
.UNINDENT
.INDENT 7.0
.TP
.B void outputData() 
Outputs important simulation data to a csv file. Overloaded version which automatically calls sortData() if no species richness is provided. 
.UNINDENT
.INDENT 7.0
.TP
.B void outputData(unsigned long \fIspecies_richness\fP) 
Outputs important simulation data to a csv file. This function will likely be remove in future versions as all simulation output is now contained in an SQLite database. 
.sp
.INDENT 7.0
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fBspecies_richness\fP: the species richness of the tree with the minimum speciation rate. Outputted into the csv file 
.UNINDENT
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B unsigned long sortData() 
Sort and process the species list so that the useful information can be extracted from it. 
.UNINDENT
.INDENT 7.0
.TP
.B void writeTimes() 
Writes the times to the terminal for simulation information. 
.UNINDENT
.INDENT 7.0
.TP
.B void sqlCreate() 
Generates the SQL database file from the full simulation data. This allows for greater analysis of the data after completion of the simulation. 
.UNINDENT
.INDENT 7.0
.TP
.B void sqlCreateSimulationParameters() 
Creates the SIMULATION_PARAMETERS table in the SQL database. 
.UNINDENT
.INDENT 7.0
.TP
.B string simulationParametersSqlInsertion() 
Creates a string containing the SQL insertion statement for the simulation parameters. 
.sp
.INDENT 7.0
.TP
\fBReturn\fP
string containing the SQL insertion statement 
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B string protractedVarsToString() 
Outputs the protracted variables to a string. 
.sp
This function is intended to be overridden by derived classes. It is intended the output is used for writing to SQL databases.
.sp
.INDENT 7.0
.TP
\fBReturn\fP
string containing a list of the protracted speciation variables. 
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B void simPause() 
Pause the simulation and dump data from memory. 
.UNINDENT
.INDENT 7.0
.TP
.B string initiatePause() 
Checks the output folder exists and initiates the pause. 
.UNINDENT
.INDENT 7.0
.TP
.B void dumpMain(string \fIpause_folder\fP) 
Saves the main simulation variables to file. 
.sp
.INDENT 7.0
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fBpause_folder\fP: the folder to save files into 
.UNINDENT
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B void dumpActive(string \fIpause_folder\fP) 
Saves the active object to file. 
.sp
.INDENT 7.0
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fBpause_folder\fP: the folder to save files into 
.UNINDENT
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B void dumpData(string \fIpause_folder\fP) 
Saves the data object to file. 
.sp
.INDENT 7.0
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fBpause_folder\fP: the folder to save files into 
.UNINDENT
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B void completePause() 
Completes the pause routine and outputs the sql dump. 
.UNINDENT
.INDENT 7.0
.TP
.B void setResumeParameters(string \fIpausedir\fP, string \fIoutdir\fP, unsigned long \fIseed\fP, unsigned long \fItask\fP, unsigned long \fInew_max_time\fP) 
Sets the resume variables so that the simulation can be resumed. 
.sp
The pause directory can be the same as the output directory if it is desirable to save to the same location.
.sp
.INDENT 7.0
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fBpausedir\fP: the directory containing the pause folder for resuming the simulation 
.IP \(bu 2
\fBoutdir\fP: the directory to write simulation output to 
.IP \(bu 2
\fBseed\fP: the simulation seed 
.IP \(bu 2
\fBtask\fP: the simulation task 
.IP \(bu 2
\fBnew_max_time\fP: the maximum simulation time to run for in seconds (0 keeps old simulation max time) 
.UNINDENT
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B void setResumeParameters() 
Sets the resume variables to the defaults. 
.UNINDENT
.INDENT 7.0
.TP
.B void loadMainSave() 
Loads the main simulation parameters from the save file into memory. 
.UNINDENT
.INDENT 7.0
.TP
.B void loadDataSave() 
Loads the data object from the save file into memory. 
.UNINDENT
.INDENT 7.0
.TP
.B void loadActiveSave() 
Loads the active object from the save file into memory. 
.UNINDENT
.INDENT 7.0
.TP
.B void initiateResume() 
Checks for resuming and prints to the terminal. 
.UNINDENT
.INDENT 7.0
.TP
.B void simResume() 
Resumes the simulation from a previous state. 
.sp
Reads in the parameters and objects from file and re\-starts the simulation. 
.UNINDENT
Protected Attributes.INDENT 7.0
.TP
.B Row<TreeNode> data 
.UNINDENT
.INDENT 7.0
.TP
.B unsigned long enddata 
.UNINDENT
.INDENT 7.0
.TP
.B SimParameters sim_parameters 
.UNINDENT
.INDENT 7.0
.TP
.B NRrand NR 
.UNINDENT
.INDENT 7.0
.TP
.B vector<long double> speciation_rates 
.UNINDENT
.INDENT 7.0
.TP
.B bool seeded 
.UNINDENT
.INDENT 7.0
.TP
.B long long the_seed 
.UNINDENT
.INDENT 7.0
.TP
.B long long the_task 
.UNINDENT
.INDENT 7.0
.TP
.B string times_file 
.UNINDENT
.INDENT 7.0
.TP
.B vector<double> reference_times 
.UNINDENT
.INDENT 7.0
.TP
.B bool has_times_file 
.UNINDENT
.INDENT 7.0
.TP
.B time_t start 
.UNINDENT
.INDENT 7.0
.TP
.B time_t sim_start 
.UNINDENT
.INDENT 7.0
.TP
.B time_t sim_end 
.UNINDENT
.INDENT 7.0
.TP
.B time_t now 
.UNINDENT
.INDENT 7.0
.TP
.B time_t sim_finish 
.UNINDENT
.INDENT 7.0
.TP
.B time_t out_finish 
.UNINDENT
.INDENT 7.0
.TP
.B time_t time_taken 
.UNINDENT
.INDENT 7.0
.TP
.B Row<DataPoint> active 
.UNINDENT
.INDENT 7.0
.TP
.B unsigned long endactive 
.UNINDENT
.INDENT 7.0
.TP
.B unsigned long startendactive 
.UNINDENT
.INDENT 7.0
.TP
.B unsigned long maxsimsize 
.UNINDENT
.INDENT 7.0
.TP
.B Community community 
.UNINDENT
.INDENT 7.0
.TP
.B long steps 
.UNINDENT
.INDENT 7.0
.TP
.B unsigned long maxtime 
.UNINDENT
.INDENT 7.0
.TP
.B double generation 
.UNINDENT
.INDENT 7.0
.TP
.B long deme 
.UNINDENT
.INDENT 7.0
.TP
.B double deme_sample 
.UNINDENT
.INDENT 7.0
.TP
.B long double spec 
.UNINDENT
.INDENT 7.0
.TP
.B string out_directory 
.UNINDENT
.INDENT 7.0
.TP
.B sqlite3 *database 
.UNINDENT
.INDENT 7.0
.TP
.B bool sim_complete 
.UNINDENT
.INDENT 7.0
.TP
.B bool has_imported_vars 
.UNINDENT
.INDENT 7.0
.TP
.B sqlite3 *outdatabase 
.UNINDENT
.INDENT 7.0
.TP
.B Step this_step 
.UNINDENT
.INDENT 7.0
.TP
.B string sqloutname 
.UNINDENT
.INDENT 7.0
.TP
.B bool bFullmode 
.UNINDENT
.INDENT 7.0
.TP
.B bool bResume 
.UNINDENT
.INDENT 7.0
.TP
.B bool bConfig 
.UNINDENT
.INDENT 7.0
.TP
.B bool has_paused 
.UNINDENT
.INDENT 7.0
.TP
.B bool has_imported_pause 
.UNINDENT
.INDENT 7.0
.TP
.B bool bIsProtracted 
.UNINDENT
.INDENT 7.0
.TP
.B string pause_sim_directory 
.UNINDENT
.UNINDENT
.SS Class TreeNode
.INDENT 0.0
.IP \(bu 2
Defined in file_necsim_TreeNode.h
.UNINDENT
.SS Class Documentation
.INDENT 0.0
.TP
.B class TreeNode 
The TreeNode class that acts as a data storage object for the phylogenetic tree. 
.sp
Also contains all the necessary routines for changes to a lineage\(aqs attributes, called by TreeList objects when generating new coalescence trees. 
Public Functions.INDENT 7.0
.TP
.B TreeNode() 
The default constructor. 
.UNINDENT
.INDENT 7.0
.TP
.B ~TreeNode() 
The default destructor. 
.UNINDENT
.INDENT 7.0
.TP
.B void setup(bool \fIz\fP, unsigned long \fIxp\fP, unsigned long \fIyp\fP, long \fIxi\fP, long \fIyi\fP) 
Sets up variables with initial conditions. 
.sp
.INDENT 7.0
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fBz\fP: whether this lineage is a tip or not (represents the end of a tree). 
.IP \(bu 2
\fBxp\fP: the x position on the grid. 
.IP \(bu 2
\fByp\fP: the y position on the grid. 
.IP \(bu 2
\fBxi\fP: the number of wraps in the x dimension. 
.IP \(bu 2
\fByi\fP: the number of wraps in the y dimension. 
.UNINDENT
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B void setup(bool \fIz\fP) 
Sets up variables with initial conditions. 
.sp
.INDENT 7.0
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fBz\fP: whether this lineage is a tip or not (represents the end of a tree) 
.UNINDENT
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B void setup(const bool &\fIis_tip\fP, const long &\fIxp\fP, const long &\fIyp\fP, const long &\fIxi\fP, const long &\fIyi\fP, const long double &\fIgeneration\fP) 
Overloaded setup() function, additionally taking a generation time point. 
.sp
Used when creating lineages after the start of the simulation, when the generation is not 0. .INDENT 7.0
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fBis_tip\fP: whether this lineage is a tip or not (represents the end of a tree). 
.IP \(bu 2
\fBxp\fP: the x position on the grid. 
.IP \(bu 2
\fByp\fP: the y position on the grid. 
.IP \(bu 2
\fBxi\fP: the number of wraps in the x dimension. 
.IP \(bu 2
\fByi\fP: the number of wraps in the y dimension. 
.IP \(bu 2
\fBgeneration\fP: the current generation at creation time. 
.UNINDENT
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B void setExistence(bool \fIb\fP) 
Setter for the existence of the lineage. 
.sp
.INDENT 7.0
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fBb\fP: existence boolean. 
.UNINDENT
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B void setParent(unsigned long \fIx\fP) 
Setter for the parent reference. 
.sp
.INDENT 7.0
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fBx\fP: a reference for the parent location. 
.UNINDENT
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B void qReset() 
Resets the lineage. Remove any species ID, existence and speciation record. 
.UNINDENT
.INDENT 7.0
.TP
.B void setPosition(long \fIx\fP, long \fIy\fP, long \fIxw\fP, long \fIyw\fP) 
Set a new position for the lineage. 
.sp
.INDENT 7.0
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fBx\fP: the x position on the grid. 
.IP \(bu 2
\fBy\fP: the y position on the grid. 
.IP \(bu 2
\fBxw\fP: the number of wraps in the x dimension. 
.IP \(bu 2
\fByw\fP: the number of wraps in the y dimension. 
.UNINDENT
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B void setSpec(long double \fId\fP) 
Setter for the randomly generated number (from NRrand.d0()) for the speciation probability for this lineage. 
.sp
.INDENT 7.0
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fBd\fP: the speciation probability. 
.UNINDENT
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B void setGenerationRate(unsigned long \fIg\fP) 
Setter for the number of generations this lineage has existed for. 
.sp
.INDENT 7.0
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fBg\fP: the number of generations that the lineage has existed. 
.UNINDENT
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B void setGeneration(long double \fId\fP) 
Setter for the birth generation timer for the lineage. 
.sp
Note that moves that don\(aqt involve coalescence do not create a new Treenode object, and therefore the generation_added does not get updated. However, coalescence events will cause a new Treenode object creation. The lineage birth generation is generally only important for calculating the age of tips. .INDENT 7.0
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fBd\fP: 
.UNINDENT
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B void setSpeciation(bool \fIs\fP) 
Setter for the speciation boolean. 
.sp
.INDENT 7.0
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fBs\fP: the speciation boolean. 
.UNINDENT
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B void burnSpecies(unsigned long \fIidin\fP) 
Setter for the species ID. Once set to something other than 0, this cannot be changed with a call to qReset() or resetSpecies()\&. 
.sp
.INDENT 7.0
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fBidin\fP: the species ID. 
.UNINDENT
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B void setTip(bool \fIb\fP) 
Setter for the tip boolean. 
.sp
.INDENT 7.0
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fBb\fP: the tip boolean. 
.UNINDENT
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B void resetSpecies() 
Reset the species ID to 0. 
.UNINDENT
.INDENT 7.0
.TP
.B void increaseGen() 
Increases the generation counter by one. 
.UNINDENT
.INDENT 7.0
.TP
.B bool getExistence() 
Getter for the existence boolean. 
.sp
.INDENT 7.0
.TP
\fBReturn\fP
the existence boolean. 
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B bool isTip() 
Getter for the tip boolean. 
.sp
.INDENT 7.0
.TP
\fBReturn\fP
the tip boolean. 
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B unsigned long getParent() 
Getter for the parent location. 
.sp
.INDENT 7.0
.TP
\fBReturn\fP
the parent reference. 
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B unsigned long getXpos() 
Getter for the x position. 
.sp
.INDENT 7.0
.TP
\fBReturn\fP
the x position. 
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B unsigned long getYpos() 
Getter for the y position. 
.sp
.INDENT 7.0
.TP
\fBReturn\fP
the y position. 
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B long getXwrap() 
Getter for the number of times the lineage is wrapped in the x dimension. 
.sp
.INDENT 7.0
.TP
\fBReturn\fP
the number of times the lineage is wrapped in the x dimension. 
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B long getYwrap() 
Getter for the number of times the lineage is wrapped in the y dimension. 
.sp
.INDENT 7.0
.TP
\fBReturn\fP
the number of times the lineage is wrapped in the y dimension. 
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B bool hasSpeciated() 
Getter for the speciation boolean. 
.sp
.INDENT 7.0
.TP
\fBReturn\fP
the speciation boolean. 
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B unsigned long getSpeciesID() 
Getter for the species ID. 
.sp
.INDENT 7.0
.TP
\fBReturn\fP
the species ID. 
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B long double getSpecRate() 
Getter for the randomly generated speciation probability. 
.sp
.INDENT 7.0
.TP
\fBReturn\fP
the speciation probability. 
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B unsigned long getGenRate() 
Getter for the number of generations the lineage has existed. 
.sp
.INDENT 7.0
.TP
\fBReturn\fP
the number of generations of existence. 
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B long double getGeneration() 
Getter for the generation the lineage was created. 
.sp
.INDENT 7.0
.TP
\fBReturn\fP
the generation counter the lineage was created. 
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B void speciate() 
Sets the speciation boolean to true. 
.UNINDENT
.INDENT 7.0
.TP
.B TreeNode &operator=(const TreeNode &\fIt\fP) 
Overloading the equality operator for TreeNodes .INDENT 7.0
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fBt\fP: the input TreeNode 
.UNINDENT
.UNINDENT

.UNINDENT
Friends.INDENT 7.0
.TP
.B ostream &operator<<(ostream &\fIos\fP, const TreeNode &\fIt\fP) 
Overloading the << operator for outputting a Treenode object to an output stream. 
.sp
.INDENT 7.0
.TP
\fBReturn\fP
the output stream. 
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fBos\fP: the output stream. 
.IP \(bu 2
\fBt\fP: a Treenode object to output. 
.UNINDENT
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B istream &operator>>(istream &\fIis\fP, TreeNode &\fIt\fP) 
Overloading the >> operator for inputting the Treenode object from an input stream. 
.sp
.INDENT 7.0
.TP
\fBReturn\fP
the input stream. 
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fBis\fP: the input stream. 
.IP \(bu 2
\fBt\fP: a Treenode object to input to. 
.UNINDENT
.UNINDENT

.UNINDENT
.UNINDENT
.SS Function apply
.INDENT 0.0
.IP \(bu 2
Defined in file_applyspecmodule.cpp
.UNINDENT
.SS Function Documentation
.sp
\fBWARNING:\fP
.INDENT 0.0
.INDENT 3.5
doxygenfunction: Unable to resolve multiple matches for function "apply" with arguments () in doxygen xml output for project "necsim" from directory: ../docs/necsim_doc/xml/.
Potential matches:

.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
\- void Community::apply(SpecSimParameters *)
\- void Metacommunity::apply(SpecSimParameters *)
.ft P
.fi
.UNINDENT
.UNINDENT
.UNINDENT
.UNINDENT
.SS Function cantorPairing
.INDENT 0.0
.IP \(bu 2
Defined in file_necsim_Filesystem.h
.UNINDENT
.SS Function Documentation
.INDENT 0.0
.TP
.B unsigned long cantorPairing(unsigned long \fIx1\fP, unsigned long \fIx2\fP) 
Generates a unique ID for the pair of provided parameters. 
.sp
Maps ZxZ \-> N, so only relevant for positive numbers. For any A and B, generates C such that no D and E produce C unless D=A and B=E.
.sp

.sp
.INDENT 7.0
.TP
\fBReturn\fP
a unique reference for the two provided integers 
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fBx1\fP: the first integer reference 
.IP \(bu 2
\fBx2\fP: the second integer reference 
.UNINDENT
.UNINDENT

.UNINDENT
.SS Function checkSpeciation
.INDENT 0.0
.IP \(bu 2
Defined in file_necsim_Community.h
.UNINDENT
.SS Function Documentation
.INDENT 0.0
.TP
.B bool checkSpeciation(const long double &\fIrandom_number\fP, const long double &\fIspeciation_rate\fP, const unsigned long &\fIno_generations\fP) 
Checks whether speciation has occured for the provided parameters. Provided here for ease of use when bug\-fixing. 
.sp
.INDENT 7.0
.TP
\fBReturn\fP
bool the speciation state of the lineage 
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fBrandom_number\fP: the random number associated with a lineage 
.IP \(bu 2
\fBspeciation_rate\fP: the global speciation rate 
.IP \(bu 2
\fBnumber_of_generations\fP: the number of generations the lineage has existed 
.UNINDENT
.UNINDENT

.UNINDENT
.SS Function createCommunity
.INDENT 0.0
.IP \(bu 2
Defined in file_applyspecmodule.cpp
.UNINDENT
.SS Function Documentation
.sp
\fBWARNING:\fP
.INDENT 0.0
.INDENT 3.5
doxygenfunction: Cannot find function "createCommunity" in doxygen xml output for project "necsim" from directory: ../docs/necsim_doc/xml/
.UNINDENT
.UNINDENT
.SS Function createParent
.INDENT 0.0
.IP \(bu 2
Defined in file_necsim_Filesystem.h
.UNINDENT
.SS Function Documentation
.INDENT 0.0
.TP
.B void createParent(const string &\fIfile\fP) 
Checks that parent folder to the supplied file exists, and if it doesn\(aqt creates it. 
.sp
.INDENT 7.0
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fBfile\fP: the file path to check for 
.UNINDENT
.UNINDENT

.UNINDENT
.SS Function distanceBetween
.INDENT 0.0
.IP \(bu 2
Defined in file_necsim_SimulateDispersal.h
.UNINDENT
.SS Function Documentation
.INDENT 0.0
.TP
.B double distanceBetween(Cell &\fIc1\fP, Cell &\fIc2\fP) 
Calculates the distance between two cells. 
.sp
.INDENT 7.0
.TP
\fBReturn\fP
the distance between the two points 
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fBc1\fP: Cell containing one point 
.IP \(bu 2
\fBc2\fP: Cell containing second point 
.UNINDENT
.UNINDENT

.UNINDENT
.SS Function doesExist
.INDENT 0.0
.IP \(bu 2
Defined in file_necsim_Filesystem.h
.UNINDENT
.SS Function Documentation
.INDENT 0.0
.TP
.B bool doesExist(string \fItestfile\fP) 
Checks the existance of a file on the hard drive. 
.sp
.INDENT 7.0
.TP
\fBReturn\fP
if true, file exists 
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fBtestfile\fP: the file to examine 
.UNINDENT
.UNINDENT

.UNINDENT
.SS Function doesExistNull
.INDENT 0.0
.IP \(bu 2
Defined in file_necsim_Filesystem.h
.UNINDENT
.SS Function Documentation
.INDENT 0.0
.TP
.B bool doesExistNull(string \fItestfile\fP) 
Checks for the existance of a file, but returns true if the file name is \(aqnull\(aq. Note: this function just calls doesExist()\&. 
.sp
.INDENT 7.0
.TP
\fBReturn\fP
if true, file exists (or is null). 
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fBtestfile\fP: the file to examine 
.UNINDENT
.UNINDENT

.UNINDENT
.SS Function doubleCompare
.INDENT 0.0
.IP \(bu 2
Defined in file_necsim_Community.h
.UNINDENT
.SS Function Documentation
.sp
\fBWARNING:\fP
.INDENT 0.0
.INDENT 3.5
doxygenfunction: Unable to resolve multiple matches for function "doubleCompare" with arguments () in doxygen xml output for project "necsim" from directory: ../docs/necsim_doc/xml/.
Potential matches:

.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
\- bool doubleCompare(double, double, double)
\- bool doubleCompare(long double, long double, double)
\- bool doubleCompare(long double, long double, long double)
.ft P
.fi
.UNINDENT
.UNINDENT
.UNINDENT
.UNINDENT
.SS Function getConfigFileFromCmdArgs
.INDENT 0.0
.IP \(bu 2
Defined in file_necsim_SimulationTemplates.h
.UNINDENT
.SS Function Documentation
.INDENT 0.0
.TP
.B const string &getConfigFileFromCmdArgs(const vector<string> &\fIcom_args\fP) 
Gets the [2] element from the vector (which should contain the config file from command\-line arguments. 
.sp
.INDENT 7.0
.TP
\fBReturn\fP
the string at the [2] position containing the path to the config file 
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fBcom_args\fP: the vector of command\-line arguments 
.UNINDENT
.UNINDENT

.UNINDENT
.SS Function getDefaultLogFile
.INDENT 0.0
.IP \(bu 2
Defined in file_necsim_LogFile.h
.UNINDENT
.SS Function Documentation
.INDENT 0.0
.TP
.B string getDefaultLogFile() 
Gets the default log file path. Stored at log/DDMMYYYY_HHMMSS.log where DDMMYYYY_HHMMSS are replaced by the current date and time. 
.sp
.INDENT 7.0
.TP
\fBReturn\fP
location of the default logging position. 
.UNINDENT

.UNINDENT
.SS Function getTime
.INDENT 0.0
.IP \(bu 2
Defined in file_necsim_LogFile.cpp
.UNINDENT
.SS Function Documentation
.sp
\fBWARNING:\fP
.INDENT 0.0
.INDENT 3.5
doxygenfunction: Cannot find function "getTime" in doxygen xml output for project "necsim" from directory: ../docs/necsim_doc/xml/
.UNINDENT
.UNINDENT
.SS Function getUniqueFileName
.INDENT 0.0
.IP \(bu 2
Defined in file_necsim_LogFile.h
.UNINDENT
.SS Function Documentation
.INDENT 0.0
.TP
.B void getUniqueFileName(string &\fIbasic_string\fP) 
Modifies the file name so that it doesn\(aqt point to an existing file. 
.sp
.INDENT 7.0
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fBbasic_string\fP: the file name to modify 
.UNINDENT
.UNINDENT

.UNINDENT
.SS Function importArgs
.INDENT 0.0
.IP \(bu 2
Defined in file_necsim_ConfigFileParser.h
.UNINDENT
.SS Function Documentation
.INDENT 0.0
.TP
.B void importArgs(const unsigned int &\fIargc\fP, char *\fIargv\fP[], vector<string> &\fIcomargs\fP) 
Import the command line arguments in to the vector for future processing. Arguments will be placed in the vector comargs. 
.sp
.INDENT 7.0
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fBargc\fP: the number of arguments. 
.IP \(bu 2
\fBargv\fP: a point to the array of arguments in raw character form. 
.IP \(bu 2
\fBcomargs\fP: a vector of the command\-line arguments to be filled. 
.UNINDENT
.UNINDENT

.UNINDENT
.SS Function initapplyspecmodule
.INDENT 0.0
.IP \(bu 2
Defined in file_applyspecmodule.h
.UNINDENT
.SS Function Documentation
.INDENT 0.0
.TP
.B PyMODINIT_FUNC initapplyspecmodule(void) 
.UNINDENT
.SS Function initdispersalmodule
.INDENT 0.0
.IP \(bu 2
Defined in file_dispersalmodule.h
.UNINDENT
.SS Function Documentation
.INDENT 0.0
.TP
.B PyMODINIT_FUNC initdispersalmodule(void) 
.UNINDENT
.SS Function initnecsimmodule
.INDENT 0.0
.IP \(bu 2
Defined in file_necsimmodule.h
.UNINDENT
.SS Function Documentation
.INDENT 0.0
.TP
.B PyMODINIT_FUNC initnecsimmodule(void) 
.UNINDENT
.SS Function main
.INDENT 0.0
.IP \(bu 2
Defined in file_SpeciationCounter.cpp
.UNINDENT
.SS Function Documentation
.sp
\fBWARNING:\fP
.INDENT 0.0
.INDENT 3.5
doxygenfunction: Cannot find function "main" in doxygen xml output for project "necsim" from directory: ../docs/necsim_doc/xml/
.UNINDENT
.UNINDENT
.SS Function openLogFile
.INDENT 0.0
.IP \(bu 2
Defined in file_necsim_Setup.cpp
.UNINDENT
.SS Function Documentation
.sp
\fBWARNING:\fP
.INDENT 0.0
.INDENT 3.5
doxygenfunction: Cannot find function "openLogFile" in doxygen xml output for project "necsim" from directory: ../docs/necsim_doc/xml/
.UNINDENT
.UNINDENT
.SS Function openSQLiteDatabase
.INDENT 0.0
.IP \(bu 2
Defined in file_necsim_Filesystem.h
.UNINDENT
.SS Function Documentation
.INDENT 0.0
.TP
.B void openSQLiteDatabase(const string &\fIdatabase_name\fP, sqlite3 *&\fIdatabase\fP) 
Safely opens a connection to the provided SQLite database. 
.sp
Adds type safety for usage on different filesystems. .INDENT 7.0
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fBdatabase_name\fP: 
.IP \(bu 2
\fBdatabase\fP: 
.UNINDENT
.UNINDENT

.UNINDENT
.SS Function operator<<
.INDENT 0.0
.IP \(bu 2
Defined in file_necsim_TreeNode.cpp
.UNINDENT
.SS Function Documentation
.sp
\fBWARNING:\fP
.INDENT 0.0
.INDENT 3.5
doxygenfunction: Cannot find function "operator<<" in doxygen xml output for project "necsim" from directory: ../docs/necsim_doc/xml/
.UNINDENT
.UNINDENT
.SS Function operator>>
.INDENT 0.0
.IP \(bu 2
Defined in file_necsim_TreeNode.cpp
.UNINDENT
.SS Function Documentation
.sp
\fBWARNING:\fP
.INDENT 0.0
.INDENT 3.5
doxygenfunction: Cannot find function "operator>>" in doxygen xml output for project "necsim" from directory: ../docs/necsim_doc/xml/
.UNINDENT
.UNINDENT
.SS Function removeComOption
.INDENT 0.0
.IP \(bu 2
Defined in file_necsim_Setup.h
.UNINDENT
.SS Function Documentation
.INDENT 0.0
.TP
.B void removeComOption(unsigned long &\fIargc\fP, vector<string> &\fIcomargs\fP) 
Removes the command line options supplied, leaving just a clean vector with the correct data in. 
.UNINDENT
.SS Function resume_simulation
.INDENT 0.0
.IP \(bu 2
Defined in file_necsimmodule.cpp
.UNINDENT
.SS Function Documentation
.sp
\fBWARNING:\fP
.INDENT 0.0
.INDENT 3.5
doxygenfunction: Cannot find function "resume_simulation" in doxygen xml output for project "necsim" from directory: ../docs/necsim_doc/xml/
.UNINDENT
.UNINDENT
.SS Function run_simulation
.INDENT 0.0
.IP \(bu 2
Defined in file_necsimmodule.cpp
.UNINDENT
.SS Function Documentation
.sp
\fBWARNING:\fP
.INDENT 0.0
.INDENT 3.5
doxygenfunction: Cannot find function "run_simulation" in doxygen xml output for project "necsim" from directory: ../docs/necsim_doc/xml/
.UNINDENT
.UNINDENT
.SS Function runAsDefault
.INDENT 0.0
.IP \(bu 2
Defined in file_necsim_Setup.h
.UNINDENT
.SS Function Documentation
.INDENT 0.0
.TP
.B void runAsDefault(vector<string> &\fIcomargs\fP) 
Sets up the command\-line arguments for default parameters. 
.sp
This is intended for testing purposes only. .INDENT 7.0
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fBcomargs\fP: a vector of command\-line arguments for putting the parameters into. 
.UNINDENT
.UNINDENT

.UNINDENT
.SS Function runLarge
.INDENT 0.0
.IP \(bu 2
Defined in file_necsim_Setup.h
.UNINDENT
.SS Function Documentation
.INDENT 0.0
.TP
.B void runLarge(vector<string> &\fIcomargs\fP) 
Sets up the command\-line arguments for larger\-scale default parameters. 
.sp
This is intended for testing purposes only. .INDENT 7.0
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fBcomargs\fP: a vector of command\-line arguments for putting the parameters into. 
.UNINDENT
.UNINDENT

.UNINDENT
.SS Function runMain
.INDENT 0.0
.IP \(bu 2
Defined in file_necsim_SimulationTemplates.h
.UNINDENT
.SS Function Documentation
.INDENT 0.0
.TP
.B template <class T>
.TP
.B void runMain(const string &\fIconfig_file\fP) 
Template class for running simulations from all Tree types. 
.sp
.INDENT 7.0
.TP
\fBTemplate Parameters\fP
.INDENT 7.0
.IP \(bu 2
\fBT\fP: the class (either Tree, or a child of Tree) of the simulation 
.UNINDENT
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fBconfig_file\fP: the config file to read simulation parameters from 
.UNINDENT
.UNINDENT

.UNINDENT
.SS Function runXL
.INDENT 0.0
.IP \(bu 2
Defined in file_necsim_Setup.h
.UNINDENT
.SS Function Documentation
.INDENT 0.0
.TP
.B void runXL(vector<string> &\fIcomargs\fP) 
Sets up the command\-line arguments for default very large scale parameters. 
.sp
This is intended for testing purposes only. .INDENT 7.0
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fBcomargs\fP: a vector of command\-line arguments for putting the parameters into. 
.UNINDENT
.UNINDENT

.UNINDENT
.SS Function set_log_function
.INDENT 0.0
.IP \(bu 2
Defined in file_PyLogging.h
.UNINDENT
.SS Function Documentation
.INDENT 0.0
.TP
.B PyObject *set_log_function(PyObject *\fIdummy\fP, PyObject *\fIargs\fP) 
Sets the logging function to the provided specification. 
.sp
.INDENT 7.0
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fBdummy\fP: the dummy object 
.IP \(bu 2
\fBargs\fP: the args provided (should be one callable logging function) 
.UNINDENT
.UNINDENT

.UNINDENT
.SS Function set_logger
.INDENT 0.0
.IP \(bu 2
Defined in file_PyLogging.h
.UNINDENT
.SS Function Documentation
.INDENT 0.0
.TP
.B PyObject *set_logger(PyObject *\fIself\fP, PyObject *\fIargs\fP) 
Sets the logger to the inputted object Saves the logger in loggingmodule. 
.sp
.INDENT 7.0
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fBself\fP: required for python objects 
.IP \(bu 2
\fBargs\fP: the logger to link for error outputting 
.UNINDENT
.UNINDENT

.UNINDENT
.SS Function test_mean_dispersal
.INDENT 0.0
.IP \(bu 2
Defined in file_dispersalmodule.cpp
.UNINDENT
.SS Function Documentation
.sp
\fBWARNING:\fP
.INDENT 0.0
.INDENT 3.5
doxygenfunction: Cannot find function "test_mean_dispersal" in doxygen xml output for project "necsim" from directory: ../docs/necsim_doc/xml/
.UNINDENT
.UNINDENT
.SS Function test_mean_distance_travelled
.INDENT 0.0
.IP \(bu 2
Defined in file_dispersalmodule.cpp
.UNINDENT
.SS Function Documentation
.sp
\fBWARNING:\fP
.INDENT 0.0
.INDENT 3.5
doxygenfunction: Cannot find function "test_mean_distance_travelled" in doxygen xml output for project "necsim" from directory: ../docs/necsim_doc/xml/
.UNINDENT
.UNINDENT
.SS Function write_log
.INDENT 0.0
.IP \(bu 2
Defined in file_PyLogging.h
.UNINDENT
.SS Function Documentation
.sp
\fBWARNING:\fP
.INDENT 0.0
.INDENT 3.5
doxygenfunction: Unable to resolve multiple matches for function "write_log" with arguments () in doxygen xml output for project "necsim" from directory: ../docs/necsim_doc/xml/.
Potential matches:

.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
\- void write_log(int, char *)
\- void write_log(int, string)
.ft P
.fi
.UNINDENT
.UNINDENT
.UNINDENT
.UNINDENT
.SS Function writeCritical
.INDENT 0.0
.IP \(bu 2
Defined in file_PyLogging.cpp
.UNINDENT
.SS Function Documentation
.sp
\fBWARNING:\fP
.INDENT 0.0
.INDENT 3.5
doxygenfunction: Cannot find function "writeCritical" in doxygen xml output for project "necsim" from directory: ../docs/necsim_doc/xml/
.UNINDENT
.UNINDENT
.SS Function writeError
.INDENT 0.0
.IP \(bu 2
Defined in file_PyLogging.cpp
.UNINDENT
.SS Function Documentation
.sp
\fBWARNING:\fP
.INDENT 0.0
.INDENT 3.5
doxygenfunction: Cannot find function "writeError" in doxygen xml output for project "necsim" from directory: ../docs/necsim_doc/xml/
.UNINDENT
.UNINDENT
.SS Function writeInfo
.INDENT 0.0
.IP \(bu 2
Defined in file_PyLogging.cpp
.UNINDENT
.SS Function Documentation
.sp
\fBWARNING:\fP
.INDENT 0.0
.INDENT 3.5
doxygenfunction: Cannot find function "writeInfo" in doxygen xml output for project "necsim" from directory: ../docs/necsim_doc/xml/
.UNINDENT
.UNINDENT
.SS Function writeWarning
.INDENT 0.0
.IP \(bu 2
Defined in file_PyLogging.cpp
.UNINDENT
.SS Function Documentation
.sp
\fBWARNING:\fP
.INDENT 0.0
.INDENT 3.5
doxygenfunction: Cannot find function "writeWarning" in doxygen xml output for project "necsim" from directory: ../docs/necsim_doc/xml/
.UNINDENT
.UNINDENT
.SS Variable _state
.INDENT 0.0
.IP \(bu 2
Defined in file_necsimmodule.h
.UNINDENT
.SS Variable Documentation
.INDENT 0.0
.TP
.B struct module_state _state 
.UNINDENT
.SS Variable ApplySpeciationError
.INDENT 0.0
.IP \(bu 2
Defined in file_applyspecmodule.h
.UNINDENT
.SS Variable Documentation
.INDENT 0.0
.TP
.B PyObject *ApplySpeciationError 
A python error container for all dispersal run\-time errors. 
.UNINDENT
.SS Variable ApplySpecMethods
.INDENT 0.0
.IP \(bu 2
Defined in file_applyspecmodule.cpp
.UNINDENT
.SS Variable Documentation
.sp
\fBWARNING:\fP
.INDENT 0.0
.INDENT 3.5
doxygenvariable: Cannot find variable "ApplySpecMethods" in doxygen xml output for project "necsim" from directory: ../docs/necsim_doc/xml/
.UNINDENT
.UNINDENT
.SS Variable call_logging
.INDENT 0.0
.IP \(bu 2
Defined in file_PyLogging.h
.UNINDENT
.SS Variable Documentation
.INDENT 0.0
.TP
.B PyObject *call_logging = nullptr 
.UNINDENT
.SS Variable DispersalError
.INDENT 0.0
.IP \(bu 2
Defined in file_dispersalmodule.h
.UNINDENT
.SS Variable Documentation
.INDENT 0.0
.TP
.B PyObject *DispersalError 
A python error container for all dispersal run\-time errors. 
.UNINDENT
.SS Variable DispersalMethods
.INDENT 0.0
.IP \(bu 2
Defined in file_dispersalmodule.cpp
.UNINDENT
.SS Variable Documentation
.sp
\fBWARNING:\fP
.INDENT 0.0
.INDENT 3.5
doxygenvariable: Cannot find variable "DispersalMethods" in doxygen xml output for project "necsim" from directory: ../docs/necsim_doc/xml/
.UNINDENT
.UNINDENT
.SS Variable gdal_data_sizes
.INDENT 0.0
.IP \(bu 2
Defined in file_necsim_Matrix.h
.UNINDENT
.SS Variable Documentation
.INDENT 0.0
.TP
.B const int gdal_data_sizes[] = {0, 8, 16, 16, 32, 32, 32, 64} 
.UNINDENT
.SS Variable gstate
.INDENT 0.0
.IP \(bu 2
Defined in file_PyLogging.h
.UNINDENT
.SS Variable Documentation
.INDENT 0.0
.TP
.B PyGILState_STATE gstate 
.UNINDENT
.SS Variable log_name
.INDENT 0.0
.IP \(bu 2
Defined in file_necsim_Setup.h
.UNINDENT
.SS Variable Documentation
.INDENT 0.0
.TP
.B string log_name 
.UNINDENT
.SS Variable log_set
.INDENT 0.0
.IP \(bu 2
Defined in file_PyLogging.h
.UNINDENT
.SS Variable Documentation
.INDENT 0.0
.TP
.B bool log_set 
.UNINDENT
.SS Variable logger
.INDENT 0.0
.IP \(bu 2
Defined in file_PyLogging.h
.UNINDENT
.SS Variable Documentation
.INDENT 0.0
.TP
.B PyObject *logger 
A python object container for the logger object for outputting using python\(aqs logging module. 
.UNINDENT
.SS Variable logger_set
.INDENT 0.0
.IP \(bu 2
Defined in file_PyLogging.h
.UNINDENT
.SS Variable Documentation
.INDENT 0.0
.TP
.B bool logger_set 
.UNINDENT
.SS Variable loggingmodule
.INDENT 0.0
.IP \(bu 2
Defined in file_PyLogging.h
.UNINDENT
.SS Variable Documentation
.INDENT 0.0
.TP
.B PyObject *loggingmodule 
.UNINDENT
.SS Variable NECSimError
.INDENT 0.0
.IP \(bu 2
Defined in file_necsimmodule.h
.UNINDENT
.SS Variable Documentation
.INDENT 0.0
.TP
.B PyObject *NECSimError 
A python error container for all run\-time errors. 
.UNINDENT
.SS Variable NECSimMethods
.INDENT 0.0
.IP \(bu 2
Defined in file_necsimmodule.cpp
.UNINDENT
.SS Variable Documentation
.sp
\fBWARNING:\fP
.INDENT 0.0
.INDENT 3.5
doxygenvariable: Cannot find variable "NECSimMethods" in doxygen xml output for project "necsim" from directory: ../docs/necsim_doc/xml/
.UNINDENT
.UNINDENT
.SS Variable saved_stdout
.INDENT 0.0
.IP \(bu 2
Defined in file_necsim_Setup.h
.UNINDENT
.SS Variable Documentation
.INDENT 0.0
.TP
.B int saved_stdout 
.UNINDENT
.SS Define AM
.INDENT 0.0
.IP \(bu 2
Defined in file_necsim_NRrand.h
.UNINDENT
.SS Define Documentation
.INDENT 0.0
.TP
.B AM
.UNINDENT
.SS Define APPLY_SPEC_IMPORT
.INDENT 0.0
.IP \(bu 2
Defined in file_applyspecmodule.h
.UNINDENT
.SS Define Documentation
.INDENT 0.0
.TP
.B APPLY_SPEC_IMPORT
.UNINDENT
.SS Define DISPERSAL_IMPORT
.INDENT 0.0
.IP \(bu 2
Defined in file_dispersalmodule.h
.UNINDENT
.SS Define Documentation
.INDENT 0.0
.TP
.B DISPERSAL_IMPORT
.UNINDENT
.SS Define EPS
.INDENT 0.0
.IP \(bu 2
Defined in file_necsim_NRrand.h
.UNINDENT
.SS Define Documentation
.INDENT 0.0
.TP
.B EPS
.UNINDENT
.SS Define GETSTATE
.INDENT 0.0
.IP \(bu 2
Defined in file_necsimmodule.h
.UNINDENT
.SS Define Documentation
.INDENT 0.0
.TP
.B GETSTATE(m)
.UNINDENT
.SS Define IA1
.INDENT 0.0
.IP \(bu 2
Defined in file_necsim_NRrand.h
.UNINDENT
.SS Define Documentation
.INDENT 0.0
.TP
.B IA1
.UNINDENT
.SS Define IA2
.INDENT 0.0
.IP \(bu 2
Defined in file_necsim_NRrand.h
.UNINDENT
.SS Define Documentation
.INDENT 0.0
.TP
.B IA2
.UNINDENT
.SS Define IM1
.INDENT 0.0
.IP \(bu 2
Defined in file_necsim_NRrand.h
.UNINDENT
.SS Define Documentation
.INDENT 0.0
.TP
.B IM1
.UNINDENT
.SS Define IM2
.INDENT 0.0
.IP \(bu 2
Defined in file_necsim_NRrand.h
.UNINDENT
.SS Define Documentation
.INDENT 0.0
.TP
.B IM2
.UNINDENT
.SS Define IMM1
.INDENT 0.0
.IP \(bu 2
Defined in file_necsim_NRrand.h
.UNINDENT
.SS Define Documentation
.INDENT 0.0
.TP
.B IMM1
.UNINDENT
.SS Define INITERROR
.INDENT 0.0
.IP \(bu 2
Defined in file_necsimmodule.h
.UNINDENT
.SS Define Documentation
.INDENT 0.0
.TP
.B INITERROR
.UNINDENT
.SS Define IQ1
.INDENT 0.0
.IP \(bu 2
Defined in file_necsim_NRrand.h
.UNINDENT
.SS Define Documentation
.INDENT 0.0
.TP
.B IQ1
.UNINDENT
.SS Define IQ2
.INDENT 0.0
.IP \(bu 2
Defined in file_necsim_NRrand.h
.UNINDENT
.SS Define Documentation
.INDENT 0.0
.TP
.B IQ2
.UNINDENT
.SS Define IR1
.INDENT 0.0
.IP \(bu 2
Defined in file_necsim_NRrand.h
.UNINDENT
.SS Define Documentation
.INDENT 0.0
.TP
.B IR1
.UNINDENT
.SS Define IR2
.INDENT 0.0
.IP \(bu 2
Defined in file_necsim_NRrand.h
.UNINDENT
.SS Define Documentation
.INDENT 0.0
.TP
.B IR2
.UNINDENT
.SS Define LOGNAME_FORMAT
.INDENT 0.0
.IP \(bu 2
Defined in file_necsim_LogFile.h
.UNINDENT
.SS Define Documentation
.INDENT 0.0
.TP
.B LOGNAME_FORMAT
.UNINDENT
.SS Define NDIV
.INDENT 0.0
.IP \(bu 2
Defined in file_necsim_NRrand.h
.UNINDENT
.SS Define Documentation
.INDENT 0.0
.TP
.B NDIV
.UNINDENT
.SS Define NTAB
.INDENT 0.0
.IP \(bu 2
Defined in file_necsim_NRrand.h
.UNINDENT
.SS Define Documentation
.INDENT 0.0
.TP
.B NTAB
.UNINDENT
.SS Define null
.INDENT 0.0
.IP \(bu 2
Defined in file_necsim_Matrix.h
.UNINDENT
.SS Define Documentation
.INDENT 0.0
.TP
.B null
.UNINDENT
.SS Define PYTHON_COMPILE
.INDENT 0.0
.IP \(bu 2
Defined in file_PyLogging.cpp
.UNINDENT
.SS Define Documentation
.INDENT 0.0
.TP
.B PYTHON_COMPILE
.UNINDENT
.SS Define RNMX
.INDENT 0.0
.IP \(bu 2
Defined in file_necsim_NRrand.h
.UNINDENT
.SS Define Documentation
.INDENT 0.0
.TP
.B RNMX
.UNINDENT
.SS Define SPECIATIONCOUNTER_PROTRACTEDSPATIALTREE_H
.INDENT 0.0
.IP \(bu 2
Defined in file_necsim_ProtractedSpatialTree.h
.UNINDENT
.SS Define Documentation
.INDENT 0.0
.TP
.B SPECIATIONCOUNTER_PROTRACTEDSPATIALTREE_H
.UNINDENT
.SS Define sql_ram
.INDENT 0.0
.IP \(bu 2
Defined in file_necsim_Tree.h
.UNINDENT
.SS Define Documentation
.INDENT 0.0
.TP
.B sql_ram
Macro for using the fast\-cpp\-csv\-parser from Ben Strasser (available from \fI\%https://github.com/ben\-strasser/fast\-cpp\-csv\-parser\fP). This enables much faster csv reading, but can cause problems on systems where this module is not fully tested.
.sp
Macro to compile using RAM for storage of the active SQL database. Without this, the database will be written directly to disc (which is slower, but an option if RAM requirements get too huge). For HPC systems, it is recommended to use this option as write speeds are generally fast and large simulations don\(aqt have a linear increase in the SQL database size (at least in RAM). 
.UNINDENT
.SS Directory necsim
.SS Files
.INDENT 0.0
.IP \(bu 2
file_necsim_Community.cpp
.IP \(bu 2
file_necsim_Community.h
.IP \(bu 2
file_necsim_ConfigFileParser.cpp
.IP \(bu 2
file_necsim_ConfigFileParser.h
.IP \(bu 2
file_necsim_CustomExceptions.h
.IP \(bu 2
file_necsim_DataMask.cpp
.IP \(bu 2
file_necsim_DataMask.h
.IP \(bu 2
file_necsim_DataPoint.cpp
.IP \(bu 2
file_necsim_DataPoint.h
.IP \(bu 2
file_necsim_DispersalCoordinator.cpp
.IP \(bu 2
file_necsim_DispersalCoordinator.h
.IP \(bu 2
file_necsim_Filesystem.cpp
.IP \(bu 2
file_necsim_Filesystem.h
.IP \(bu 2
file_necsim_LicenseHeader.h
.IP \(bu 2
file_necsim_LogFile.cpp
.IP \(bu 2
file_necsim_LogFile.h
.IP \(bu 2
file_necsim_Logging.cpp
.IP \(bu 2
file_necsim_Logging.h
.IP \(bu 2
file_necsim_main.cpp
.IP \(bu 2
file_necsim_Map.cpp
.IP \(bu 2
file_necsim_Map.h
.IP \(bu 2
file_necsim_Matrix.h
.IP \(bu 2
file_necsim_Metacommunity.cpp
.IP \(bu 2
file_necsim_Metacommunity.h
.IP \(bu 2
file_necsim_NRrand.h
.IP \(bu 2
file_necsim_ProtractedSpatialTree.h
.IP \(bu 2
file_necsim_ProtractedTree.cpp
.IP \(bu 2
file_necsim_ProtractedTree.h
.IP \(bu 2
file_necsim_README.md
.IP \(bu 2
file_necsim_ReproductionMap.cpp
.IP \(bu 2
file_necsim_ReproductionMap.h
.IP \(bu 2
file_necsim_Setup.cpp
.IP \(bu 2
file_necsim_Setup.h
.IP \(bu 2
file_necsim_SimParameters.h
.IP \(bu 2
file_necsim_SimulateDispersal.cpp
.IP \(bu 2
file_necsim_SimulateDispersal.h
.IP \(bu 2
file_necsim_SimulationTemplates.h
.IP \(bu 2
file_necsim_SpatialTree.cpp
.IP \(bu 2
file_necsim_SpatialTree.h
.IP \(bu 2
file_necsim_SpeciationCommands.cpp
.IP \(bu 2
file_necsim_SpeciationCommands.h
.IP \(bu 2
file_necsim_SpeciesList.cpp
.IP \(bu 2
file_necsim_SpeciesList.h
.IP \(bu 2
file_necsim_SpecSimParameters.h
.IP \(bu 2
file_necsim_Step.h
.IP \(bu 2
file_necsim_Tree.cpp
.IP \(bu 2
file_necsim_Tree.h
.IP \(bu 2
file_necsim_TreeNode.cpp
.IP \(bu 2
file_necsim_TreeNode.h
.UNINDENT
.SS File applyspecmodule.cpp
.sp
Contains the module for python integration for additional applying speciation rates after a simulation is completed.
.SS Contents
.INDENT 0.0
.IP \(bu 2
\fI\%Definition (applyspecmodule.cpp)\fP
.IP \(bu 2
\fI\%Detailed Description\fP
.IP \(bu 2
\fI\%Includes\fP
.IP \(bu 2
\fI\%Functions\fP
.IP \(bu 2
\fI\%Defines\fP
.IP \(bu 2
\fI\%Variables\fP
.UNINDENT
.SS Definition (\fBapplyspecmodule.cpp\fP)
.SS Program Listing for File applyspecmodule.cpp
.INDENT 0.0
.IP \(bu 2
Return to documentation for file_applyspecmodule.cpp
.UNINDENT
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
// This file is part of NECSim project which is released under BSD\-3 license.
// See file **LICENSE.txt** or visit https://opensource.org/licenses/BSD\-3\-Clause) for full license details.

#ifndef PYTHON_COMPILE
#define PYTHON_COMPILE
#endif
#include <Python.h>
#include <vector>
#include <string>
#include <cstring>
#include <unistd.h>
#include <signal.h>

#include "applyspecmodule.h"
#include "PyLogging.h"
#include "necsim/Community.h"
#include "necsim/Metacommunity.h"

PyObject * loggingmodule;
PyGILState_STATE gstate;
bool log_set = false;
bool logger_set = false;
PyObject * logger;

template<class T> void createCommunity(string database_str, bool use_spatial, string sample_file,
                                       string time_config_file, string fragment_file, vector<double> & speciation_rates,
                                       double min_speciation_gen, double max_speciation_gen,
                                       unsigned long metacommunity_size, double metacommunity_speciation_rate)
{
    T community;
    SpecSimParameters speciation_parameters;
    speciation_parameters.setup(database_str, use_spatial, sample_file, time_config_file,
                                fragment_file, speciation_rates, min_speciation_gen, max_speciation_gen,
                                metacommunity_size, metacommunity_speciation_rate);
    community.apply(&speciation_parameters);
}

static PyObject * apply(PyObject * self, PyObject * args)
{
    char * database;
    int record_spatial;
    char * sample_file;
    char * time_config_file;
    char * fragment_file;
    double min_spec_gen = 0.0;
    double max_spec_gen = 0.0;
    unsigned long metacommunity_size = 0;
    double metacommunity_speciation_rate = 0.0;
    PyObject *pList;
    PyObject *pItem;
    Py_ssize_t n;
    if (!PyArg_ParseTuple(args, "sisssO!|ddkd", &database, &record_spatial, &sample_file, &time_config_file,
                          &fragment_file, &PyList_Type, &pList, &min_spec_gen,
                          &max_spec_gen, &metacommunity_size, &metacommunity_speciation_rate))
    {
        return NULL;
    }
#ifdef DEBUG
    if(metacommunity_size == 0)
    {
        writeLog(10, "Metacommunity size not set.");
    }
    else
    {
        writeLog(10, "Metacommunity size: " + to_string(metacommunity_size));
    }
#endif // DEBUG
    if(max_spec_gen > 0.0 && min_spec_gen >= max_spec_gen)
    {
        PyErr_SetString(PyExc_TypeError, "Minimum protracted speciation generation must be less than maximum.");
    }
    else
    {
        min_spec_gen=0.0;
        max_spec_gen=0.0;
    }
    // Convert all our variables to the relevant form
    string database_str = database;
    bool use_spatial = record_spatial;
    string sample_file_str = sample_file;
    string time_config_file_str = time_config_file;
    string fragment_file_str = fragment_file;

    n = PyList_Size(pList);
    vector<double> spec_rates;
    for (int i=0; i<n; i++)
    {
        pItem = PyList_GetItem(pList, i);
        if(!PyFloat_Check(pItem))
        {
            PyErr_SetString(PyExc_TypeError, "Speciation rates must be floats.");
            return NULL;
        }
        double tmpspec = PyFloat_AS_DOUBLE(pItem);
        spec_rates.push_back(tmpspec);
    }
    // Now run the actual simulation
    try
    {
        if(metacommunity_size == 0)
        {
            Py_INCREF(logger);
            createCommunity<Community>(database_str, use_spatial, sample_file_str, time_config_file_str,
                                       fragment_file_str, spec_rates, min_spec_gen, max_spec_gen,
                                       metacommunity_size, metacommunity_speciation_rate);
            Py_DECREF(logger);
        }
        else
        {
            Py_INCREF(logger);
            createCommunity<Metacommunity>(database_str, use_spatial, sample_file_str, time_config_file_str,
                                       fragment_file_str, spec_rates, min_spec_gen, max_spec_gen,
                                       metacommunity_size, metacommunity_speciation_rate);
            Py_DECREF(logger);
        }
    }
    catch(exception &e)
    {
        Py_DECREF(logger);
        PyErr_SetString(ApplySpeciationError, e.what());
        return NULL;
    }
    Py_RETURN_NONE;
}

static PyMethodDef ApplySpecMethods[] =
{
    {"apply", apply, METH_VARARGS, "Applies the new speciation rate(s) to the coalescence tree."},
    {"set_log_function", set_log_function, METH_VARARGS, "calls logging"},
    {"set_logger", set_logger, METH_VARARGS, "Sets the logger to use"},
    {NULL, NULL, 0 , NULL}
};

// Conditional compilation for python >= 3.0 (changed how python integration worked)
#if PY_MAJOR_VERSION >= 3
static int applyspec_traverse(PyObject *m, visitproc visit, void *arg)
{
    Py_VISIT(GETSTATE(m)\->error);
    return 0;
}

static int applyspec_clear(PyObject *m)
{
    Py_CLEAR(GETSTATE(m)\->error);
    return 0;
}

#endif


#if PY_MAJOR_VERSION >= 3
static struct PyModuleDef moduledef =
{
    PyModuleDef_HEAD_INIT,
    "applyspecmodule",
    NULL,
    sizeof(struct module_state),
    ApplySpecMethods,
    NULL,
    applyspec_traverse,
    applyspec_clear,
    NULL
};


#define INITERROR return NULL

PyMODINIT_FUNC
PyInit_applyspecmodule(void)
#else
#define INITERROR return

PyMODINIT_FUNC
initapplyspecmodule(void)
#endif
{
    PyObject *module;
    #if PY_MAJOR_VERSION>=3
    module = PyModule_Create(&moduledef);
    #else
    module = Py_InitModule("applyspecmodule", ApplySpecMethods);
    #endif
    if(module == NULL)
    {
        INITERROR;
    }
    // Threading support
    if(!PyEval_ThreadsInitialized())
    {
        PyEval_InitThreads();

    }
    ApplySpeciationError = PyErr_NewException((char*)"applyspec.Error", NULL, NULL);
    Py_INCREF(ApplySpeciationError);
    PyModule_AddObject(module, "ApplySpecError", ApplySpeciationError);
    #if PY_MAJOR_VERSION >= 3
    return module;
    #endif
}
.ft P
.fi
.UNINDENT
.UNINDENT
.SS Detailed Description
.sp
Samuel Thompson
01/08/2017
BSD\-3 Licence. Requires command line parameters and generates a data object from them. Contact: \fI\%samuel.thompson14@imperial.ac.uk\fP or \fI\%thompsonsed@gmail.com\fP
.SS Includes
.INDENT 0.0
.IP \(bu 2
\fB/Users/samthompson/Documents/PhD/Code/pycoalescence/pycoalescence/lib/necsim/Community.h\fP
.IP \(bu 2
\fB/Users/samthompson/Documents/PhD/Code/pycoalescence/pycoalescence/lib/necsim/ConfigFileParser.h\fP
.IP \(bu 2
\fB/Users/samthompson/Documents/PhD/Code/pycoalescence/pycoalescence/lib/necsim/CustomExceptions.h\fP
.IP \(bu 2
\fB/Users/samthompson/Documents/PhD/Code/pycoalescence/pycoalescence/lib/necsim/DataMask.h\fP
.IP \(bu 2
\fB/Users/samthompson/Documents/PhD/Code/pycoalescence/pycoalescence/lib/necsim/DataPoint.h\fP
.IP \(bu 2
\fB/Users/samthompson/Documents/PhD/Code/pycoalescence/pycoalescence/lib/necsim/Filesystem.h\fP
.IP \(bu 2
\fB/Users/samthompson/Documents/PhD/Code/pycoalescence/pycoalescence/lib/necsim/LogFile.h\fP
.IP \(bu 2
\fB/Users/samthompson/Documents/PhD/Code/pycoalescence/pycoalescence/lib/necsim/Logging.h\fP
.IP \(bu 2
\fB/Users/samthompson/Documents/PhD/Code/pycoalescence/pycoalescence/lib/necsim/Matrix.h\fP
.IP \(bu 2
\fB/Users/samthompson/Documents/PhD/Code/pycoalescence/pycoalescence/lib/necsim/NRrand.h\fP
.IP \(bu 2
\fB/Users/samthompson/Documents/PhD/Code/pycoalescence/pycoalescence/lib/necsim/SimParameters.h\fP
.IP \(bu 2
\fB/Users/samthompson/Documents/PhD/Code/pycoalescence/pycoalescence/lib/necsim/SpecSimParameters.h\fP
.IP \(bu 2
\fB/Users/samthompson/Documents/PhD/Code/pycoalescence/pycoalescence/lib/necsim/Step.h\fP
.IP \(bu 2
\fB/Users/samthompson/Documents/PhD/Code/pycoalescence/pycoalescence/lib/necsim/Tree.h\fP
.IP \(bu 2
\fB/Users/samthompson/Documents/PhD/Code/pycoalescence/pycoalescence/lib/necsim/TreeNode.h\fP
.IP \(bu 2
\fBPyLogging.h\fP (file_PyLogging.h)
.IP \(bu 2
\fBPython.h\fP
.IP \(bu 2
\fBalgorithm\fP
.IP \(bu 2
\fBapplyspecmodule.h\fP (file_applyspecmodule.h)
.IP \(bu 2
\fBboost/filesystem.hpp\fP
.IP \(bu 2
\fBboost/lexical_cast.hpp\fP
.IP \(bu 2
\fBcctype\fP
.IP \(bu 2
\fBclimits\fP
.IP \(bu 2
\fBcmath\fP
.IP \(bu 2
\fBcstdint\fP
.IP \(bu 2
\fBcstdio\fP
.IP \(bu 2
\fBcstdlib\fP
.IP \(bu 2
\fBcstring\fP
.IP \(bu 2
\fBctime\fP
.IP \(bu 2
\fBfstream\fP
.IP \(bu 2
\fBiomanip\fP
.IP \(bu 2
\fBiostream\fP
.IP \(bu 2
\fBmap\fP
.IP \(bu 2
\fBnecsim/Community.h\fP (file_necsim_Community.h)
.IP \(bu 2
\fBnecsim/Metacommunity.h\fP (file_necsim_Metacommunity.h)
.IP \(bu 2
\fBset\fP
.IP \(bu 2
\fBsignal.h\fP
.IP \(bu 2
\fBsqlite3.h\fP
.IP \(bu 2
\fBsstream\fP
.IP \(bu 2
\fBstdexcept\fP
.IP \(bu 2
\fBstring\fP
.IP \(bu 2
\fBunistd.h\fP
.IP \(bu 2
\fBvector\fP
.UNINDENT
.SS Functions
.INDENT 0.0
.IP \(bu 2
function_apply
.IP \(bu 2
function_createCommunity
.IP \(bu 2
function_initapplyspecmodule
.UNINDENT
.SS Defines
.INDENT 0.0
.IP \(bu 2
define_INITERROR
.IP \(bu 2
define_PYTHON_COMPILE
.UNINDENT
.SS Variables
.INDENT 0.0
.IP \(bu 2
variable_ApplySpecMethods
.IP \(bu 2
variable_gstate
.IP \(bu 2
variable_log_set
.IP \(bu 2
variable_logger
.IP \(bu 2
variable_logger_set
.IP \(bu 2
variable_loggingmodule
.UNINDENT
.SS File applyspecmodule.h
.sp
Contains the module for python integration for additional applying speciation rates after a simulation is completed.
.SS Contents
.INDENT 0.0
.IP \(bu 2
\fI\%Definition (applyspecmodule.h)\fP
.IP \(bu 2
\fI\%Detailed Description\fP
.IP \(bu 2
\fI\%Includes\fP
.IP \(bu 2
\fI\%Included By\fP
.IP \(bu 2
\fI\%Classes\fP
.IP \(bu 2
\fI\%Functions\fP
.IP \(bu 2
\fI\%Defines\fP
.IP \(bu 2
\fI\%Variables\fP
.UNINDENT
.SS Definition (\fBapplyspecmodule.h\fP)
.SS Program Listing for File applyspecmodule.h
.INDENT 0.0
.IP \(bu 2
Return to documentation for file_applyspecmodule.h
.UNINDENT
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
// This file is part of NECSim project which is released under BSD\-3 license.
// See file **LICENSE.txt** or visit https://opensource.org/licenses/BSD\-3\-Clause) for full license details.

#include <Python.h>
#ifndef PYTHON_COMPILE
#define PYTHON_COMPILE
#endif
#include <vector>
#include <string>


#ifndef APPLY_SPEC_IMPORT
#define APPLY_SPEC_IMPORT
using namespace std;
struct module_state
{
    PyObject *error;
};

#if PY_MAJOR_VERSION >= 3
#define GETSTATE(m) ((struct module_state*)PyModule_GetState(m))
#else
#define GETSTATE(m) (&_state)
static struct module_state _state;
#endif

static PyObject *ApplySpeciationError;

// Conditional compilation for python >= 3.0 (changed how python integration worked)
#if PY_MAJOR_VERSION >= 3
#define INITERROR return NULL

PyMODINIT_FUNC
PyInit_applyspecmodule(void)
#else
#define INITERROR return

PyMODINIT_FUNC
initapplyspecmodule(void)
#endif
;
#endif
.ft P
.fi
.UNINDENT
.UNINDENT
.SS Detailed Description
.sp
Samuel Thompson
01/08/2017
BSD\-3 Licence. Requires command line parameters and generates a data object from them. Contact: \fI\%samuel.thompson14@imperial.ac.uk\fP or \fI\%thompsonsed@gmail.com\fP
.SS Includes
.INDENT 0.0
.IP \(bu 2
\fBPython.h\fP
.IP \(bu 2
\fBstring\fP
.IP \(bu 2
\fBvector\fP
.UNINDENT
.SS Included By
.INDENT 0.0
.IP \(bu 2
file_applyspecmodule.cpp
.UNINDENT
.SS Classes
.INDENT 0.0
.IP \(bu 2
struct_module_state
.UNINDENT
.SS Functions
.INDENT 0.0
.IP \(bu 2
function_initapplyspecmodule
.UNINDENT
.SS Defines
.INDENT 0.0
.IP \(bu 2
define_APPLY_SPEC_IMPORT
.IP \(bu 2
define_GETSTATE
.IP \(bu 2
define_INITERROR
.UNINDENT
.SS Variables
.INDENT 0.0
.IP \(bu 2
variable__state
.IP \(bu 2
variable_ApplySpeciationError
.UNINDENT
.SS File Community.cpp
.sp
Contains the class_Community class implementation, which is used for reconstructing the coalescence tree after simulations are complete.
.SS Contents
.INDENT 0.0
.IP \(bu 2
\fI\%Definition (necsim/Community.cpp)\fP
.IP \(bu 2
\fI\%Detailed Description\fP
.IP \(bu 2
\fI\%Includes\fP
.IP \(bu 2
\fI\%Functions\fP
.UNINDENT
.SS Definition (\fBnecsim/Community.cpp\fP)
.SS Program Listing for File Community.cpp
.INDENT 0.0
.IP \(bu 2
Return to documentation for file_necsim_Community.cpp
.UNINDENT
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
// This file is part of NECSim project which is released under BSD\-3 license.
// See file **LICENSE.txt** or visit https://opensource.org/licenses/BSD\-3\-Clause) for full license details.

//#define use_csv
#include <algorithm>
#include <set>
#include <unordered_map>
#include "Community.h"
#include "Filesystem.h"

bool checkSpeciation(const long double &random_number, const long double &speciation_rate,
                     const unsigned long &no_generations)
{
    // bool result1, result2, result3, result4;
    long double res = 1.0 \- pow(double(1.0 \- speciation_rate), double(no_generations));
    if(random_number <= res)
    {
        return (true);
    }
    return (false);

}
bool doubleCompare(double d1, double d2, double epsilon)
{
    return (abs(float(d1 \- d2)) < epsilon);
}

bool doubleCompare(long double d1, long double d2, long double epsilon)
{
    return abs((d1 \- d2)) < epsilon;
}

bool doubleCompare(long double d1, long double d2, double epsilon)
{
    return abs((d1 \- d2)) < epsilon;
}


CommunityParameters::CommunityParameters(unsigned long reference_in, long double speciation_rate_in,
                                         long double time_in, bool fragment_in,
                                         unsigned long metacommunity_reference_in)
{
    setup(reference_in, speciation_rate_in, time_in, fragment_in, metacommunity_reference_in);
}

void CommunityParameters::setup(unsigned long reference_in, long double speciation_rate_in, long double time_in,
                                bool fragment_in, unsigned long metacommunity_reference_in)
{
    time = time_in;
    speciation_rate = speciation_rate_in;
    fragment = fragment_in;
    reference = reference_in;
    metacommunity_reference = metacommunity_reference_in;
    updated = false;
}

bool CommunityParameters::compare(long double speciation_rate_in, long double time_in, bool fragment_in,
                                  unsigned long metacommunity_reference_in)
{
    if(doubleCompare(double(time_in), double(0.0), 0.00001))
    {
#ifdef DEBUG
        stringstream os;
        os << "Detected generation at t=0.0." << endl;
        writeLog(10, os);
#endif // DEBUG
        return doubleCompare(speciation_rate, speciation_rate_in, speciation_rate * 0.000001) &&
                fragment == fragment_in && metacommunity_reference == metacommunity_reference_in;
    }
    return doubleCompare(speciation_rate, speciation_rate_in, speciation_rate * 0.000001) &&
           doubleCompare(time, time_in, time * 0.0001) && fragment == fragment_in &&
           metacommunity_reference == metacommunity_reference_in;
}

bool CommunityParameters::compare(long double speciation_rate_in, long double time_in,
                                  unsigned long metacommunity_reference_in)
{
    return doubleCompare(speciation_rate, speciation_rate_in, speciation_rate * 0.000001) &&
           doubleCompare(time, time_in, 0.0001) && metacommunity_reference == metacommunity_reference_in;
}

bool CommunityParameters::compare(unsigned long reference_in)
{
    return reference == reference_in;
}

void CommunitiesArray::pushBack(unsigned long reference, long double speciation_rate, long double time, bool fragment,
                                unsigned long metacommunity_reference)
{
    CommunityParameters tmp_param(reference, speciation_rate, time, fragment, metacommunity_reference);
    calc_array.push_back(tmp_param);
}

void CommunitiesArray::pushBack(CommunityParameters tmp_param)
{
    calc_array.push_back(tmp_param);
}

CommunityParameters &CommunitiesArray::addNew(long double speciation_rate, long double time, bool fragment,
                                              unsigned long metacommunity_reference)
{
    unsigned long max_reference = 1;
    for(auto &i : calc_array)
    {
        if(i.compare(speciation_rate, time, metacommunity_reference))
        {
            if(i.fragment == fragment || !fragment)
            {
                throw FatalException("Tried to get reference for non\-unique parameter set in communities. "
                                             "Please report this bug.");
            }
            else
            {
                i.fragment = true;
                i.updated = true;
                return i;
            }
        }
        else
        {
            if(i.reference >= max_reference)
            {
                max_reference = i.reference + 1;
            }
        }
    }
    CommunityParameters tmp_param(max_reference, speciation_rate, time, fragment, metacommunity_reference);
    calc_array.push_back(tmp_param);
    return calc_array.back();
}

bool CommunitiesArray::hasPair(long double speciation_rate, double time, bool fragment,
                               unsigned long metacommunity_reference)
{
    for(auto &i : calc_array)
    {
        if(i.compare(speciation_rate, time, fragment, metacommunity_reference))
        {
            return true;
        }
    }
    return false;
}

MetacommunityParameters::MetacommunityParameters(unsigned long reference_in, long double speciation_rate_in,
                                                 unsigned long metacommunity_size_in)
{
    metacommunity_size = metacommunity_size_in;
    speciation_rate = speciation_rate_in;
    reference = reference_in;
}

bool MetacommunityParameters::compare(long double speciation_rate_in, unsigned long metacommunity_size_in)
{
    return doubleCompare(speciation_rate, speciation_rate_in, speciation_rate * 0.000001) &&
           metacommunity_size == metacommunity_size_in;
}

bool MetacommunityParameters::compare(unsigned long reference_in)
{
    return reference == reference_in;
}

void
MetacommunitiesArray::pushBack(unsigned long reference, long double speciation_rate, unsigned long metacommunity_size)
{
    MetacommunityParameters tmp_param(reference, speciation_rate, metacommunity_size);
    calc_array.push_back(tmp_param);
}

void MetacommunitiesArray::pushBack(MetacommunityParameters tmp_param)
{
    calc_array.push_back(tmp_param);
}

unsigned long MetacommunitiesArray::addNew(long double speciation_rate, unsigned long metacommunity_size)
{
    unsigned long max_reference = 1;
    for(auto &i : calc_array)
    {
        if(i.compare(speciation_rate, metacommunity_size))
        {

            throw FatalException("Tried to get reference for non\-unique parameter set in metacommunities. "
                                         "Please report this bug.");
        }
        else
        {
            if(i.reference >= max_reference)
            {
                max_reference = i.reference + 1;
            }
        }
    }
    MetacommunityParameters tmp_param(max_reference, speciation_rate, metacommunity_size);
    calc_array.push_back(tmp_param);
    return max_reference;
}

bool MetacommunitiesArray::hasPair(long double speciation_rate, unsigned long metacommunity_size)
{
    for(auto &i : calc_array)
    {
        if(i.compare(speciation_rate, metacommunity_size))
        {
            return true;
        }
    }
    return false;
}

bool MetacommunitiesArray::hasPair(unsigned long reference)
{
    for(auto &i : calc_array)
    {
        if(i.compare(reference))
        {
            return true;
        }
    }
    return false;
}

unsigned long MetacommunitiesArray::getReference(long double speciation_rate, unsigned long metacommunity_size)
{
    if(metacommunity_size == 0)
    {
        return 0;
    }
    for(auto &i : calc_array)
    {
        if(i.compare(speciation_rate, metacommunity_size))
        {
            return i.reference;
        }
    }
    return 0;
}

Samplematrix::Samplematrix()
{
    bIsFragment = false;
    bIsNull = false;
}

bool Samplematrix::getTestVal(unsigned long xval, unsigned long yval, long xwrap, long ywrap)
{
    return getVal(xval, yval, xwrap, ywrap);
}

bool Samplematrix::getMaskVal(unsigned long x1, unsigned long y1, long x_wrap, long y_wrap)
{
    if(bIsFragment)
    {
        long x, y;
        x = x1 + (x_wrap * x_dim) + x_offset;
        y = y1 + (y_wrap * y_dim) + y_offset;
        return fragment.x_west <= x && x <= fragment.x_east && fragment.y_north <= y &&
               y <= fragment.y_south;
    }
    if(bIsNull)
    {
        return true;
    }
    return getVal(x1, y1, x_wrap, y_wrap);
}

void Samplematrix::setFragment(Fragment &fragment_in)
{
    fragment = fragment_in;
//          os << "W,E,N,S: " << fragment.x_west << ", " << fragment.x_east << ", " << fragment.y_north << ", " << fragment.y_south << endl;
    bIsFragment = true;
}

void Samplematrix::removeFragment()
{
    bIsFragment = false;
}

void Community::setList(Row<TreeNode> *l)
{
    nodes = l;
}

void Community::setDatabase(sqlite3 *dbin)
{
    if(!bFileSet)
    {
        database = dbin;
    }
    else
    {
        throw SpeciesException("ERROR_SPEC_002: Attempt to set database \- database link has already been set");
    }
    bFileSet = true;  // this just specifies that the database has been created in memory.
}

bool Community::hasImportedData()
{
    return bDataImport;
}

long double Community::getMinimumSpeciation()
{
    return min_spec_rate;
}

void Community::importSamplemask(string sSamplemask)
{
    // Check that the sim data has been imported.
    if(!bDataImport)
    {
        throw SpeciesException(
                "ERROR_SPEC_003: Attempt to importSpatialParameters samplemask object before simulation parameters: dimensions not known");
    }
    // Check that the main data has been imported already, otherwise the dimensions of the samplemask will not be correct
    if(!bSample)
    {
        stringstream os;
        if(sSamplemask != "null")
        {
            samplemask.importBooleanMask(grid_x_size, grid_y_size, samplemask_x_size, samplemask_y_size,
                                         samplemask_x_offset, samplemask_y_offset, sSamplemask);
            unsigned long total = 0;
            for(unsigned long i = 0; i < samplemask.sample_mask.GetCols(); i++)
            {
                for(unsigned long j = 0; j < samplemask.sample_mask.GetRows(); j++)
                {
                    if(samplemask.sample_mask[j][i])
                    {
                        total++;
                    }
                }
            }
            os << "Sampling " << total << " cells." << endl;
        }
        else
        {
            samplemask.importBooleanMask(grid_x_size, grid_y_size, samplemask_x_size, samplemask_y_size,
                                         samplemask_x_offset, samplemask_y_offset, sSamplemask);
#ifdef DEBUG
            os << "Sampling all areas." << endl;
#endif
        }
        writeInfo(os.str());
        bSample = true;
    }
}

unsigned long Community::countSpecies()
{
    unsigned int precount = 0;
    for(unsigned long i = 1; i < nodes\->size(); i++)
    {
        if((*nodes)[i].hasSpeciated())
        {
            precount++;
        }
    }
    return precount;
}

unsigned long Community::calcSpecies()
{
    resetTree();
    if(!bSample)
    {
#ifdef DEBUG
        writeInfo("No samplemask imported. Defaulting to null.\en");
#endif
        importSamplemask("null");
    }
    //      os << "listsize: " << nodes\->size() << endl;
    unsigned long iSpecCount = 0;  // start at 2 because the last species has been burnt already.
    // check that tips exist within the spatial and temporal frame of interest.
#ifdef DEBUG
    writeLog(10, "Assigning tips.");
#endif // DEBUG
    for(unsigned long i = 1; i < nodes\->size(); i++)
    {
        TreeNode *this_node = &(*nodes)[i];
#ifdef DEBUG
        if((*nodes)[i].getParent() >= nodes\->size())
        {
            writeLog(50, "i: " + to_string(i));
            this_node\->logLineageInformation(50);
            writeLog(50, "size: " + to_string(nodes\->size()));
            throw SpeciesException("ERROR_SQL_017: The parent is outside the size of the the data object. Bug "
                                           "in expansion of data structures or object set up likely.");
        }
#endif //DEBUG
        this_node\->setExistence(this_node\->isTip() && samplemask.getMaskVal(this_node\->getXpos(), this_node\->getYpos(),
                                                                            this_node\->getXwrap(),
                                                                            this_node\->getYwrap()) &&
                                doubleCompare(this_node\->getGeneration(), current_community_parameters\->time, 0.0001));
        // Calculate if speciation occured at any point in the lineage\(aqs branch
        if(protracted)
        {
            long double lineage_age = this_node\->getGeneration() + this_node\->getGenRate();
            if(lineage_age >= applied_min_speciation_gen)
            {
                if(checkSpeciation(this_node\->getSpecRate(), current_community_parameters\->speciation_rate,
                                   this_node\->getGenRate()))
                {
                    this_node\->speciate();
                }
                if(lineage_age >= applied_max_speciation_gen)
                {
                    this_node\->speciate();
                }
            }
        }
        else
        {
            if(checkSpeciation(this_node\->getSpecRate(), current_community_parameters\->speciation_rate,
                               this_node\->getGenRate()))
            {
                this_node\->speciate();
            }
        }
    }

#ifdef DEBUG
    writeLog(10, "Calculating lineage existence.");
#endif // DEBUG
    // now continue looping to calculate species identities for lineages given the new speciation probabilities.
    bool bSorter = true;
    while(bSorter)
    {
        bSorter = false;
        for(unsigned long i = 1; i < nodes\->size(); i++)
        {
            TreeNode *this_node = &(*nodes)[i];
            // check if any parents exist
            if(!(*nodes)[this_node\->getParent()].getExistence() && this_node\->getExistence() &&
               !this_node\->hasSpeciated())
            {
                bSorter = true;
                (*nodes)[this_node\->getParent()].setExistence(true);
            }
        }
    }
#ifdef DEBUG
    writeLog(10, "Speciating lineages.");
#endif // DEBUG
    iSpecCount = 0;
    set<unsigned long> species_list;
    // Now loop again, creating a new species for each species that actually exists.
    for(unsigned long i = 1; i < nodes\->size(); i++)
    {
        TreeNode *this_node = &(*nodes)[i];
        if(this_node\->getExistence() && this_node\->hasSpeciated())
        {
            addSpecies(iSpecCount, this_node, species_list);
        }
    }
    // Compress the species IDs so that the we have full mapping of species_ids to integers in range 0:n
    // Only do so if the numbers do not match initially
#ifdef DEBUG
    writeLog(10, "Counting species.");
#endif // DEBUG
    if(!species_list.empty() && iSpecCount != *species_list.rbegin())
    {
        unsigned long tmp_species_count = 0;
        unordered_map<unsigned long, unsigned long> ids_map;
        ids_map.reserve(iSpecCount);
        for(unsigned long i = 1; i < nodes\->size(); i ++)
        {
            TreeNode *this_node = &(*nodes)[i];
            if(this_node\->hasSpeciated() && this_node\->getExistence())
            {
                auto map_id = ids_map.find(this_node\->getSpeciesID());
                if(map_id == ids_map.end())
                {
                    tmp_species_count ++;
                    this_node\->resetSpecies();
                    this_node\->burnSpecies(tmp_species_count);
                    ids_map.emplace(this_node\->getSpeciesID(), tmp_species_count);
                }
                else
                {
                    this_node\->resetSpecies();
                    this_node\->burnSpecies(map_id\->second);
                }
            }
        }
        iSpecCount = tmp_species_count;
    }
    else
    {
        iSpecCount = 0;
        for(unsigned long i = 0; i < nodes\->size(); i++)
        {
            TreeNode *this_node = &(*nodes)[i];
            // count all speciation events, not just the ones that exist!
            if(this_node\->hasSpeciated() && this_node\->getExistence() && this_node\->getSpeciesID() != 0)
            {
                iSpecCount++;
            }
        }
    }
    // now loop to correctly assign each species id
    bool loopon = true;
    bool error_printed = false;
#ifdef DEBUG
    writeLog(10, "Generating species IDs.");
#endif // DEBUG
    while(loopon)
    {
        loopon = false;
        // if we start at the end of the loop and work backwards, we should remove some of the repeat
        // speciation events.
        for(unsigned long i = (nodes\->size()) \- 1; i > 0; i\-\-)
        {
            TreeNode *this_node = &(*nodes)[i];
            //              os << i << endl;
            if(this_node\->getSpeciesID() == 0 && this_node\->getExistence())
            {
                loopon = true;
                this_node\->burnSpecies((*nodes)[this_node\->getParent()].getSpeciesID());
#ifdef DEBUG
                if((*nodes)[this_node\->getParent()].getSpeciesID() == 0 &&
                   doubleCompare(this_node\->getGeneration(), current_community_parameters\->time, 0.001))
                {

                    if(!error_printed)
                    {
                        stringstream ss;
                        ss << "Potential parent ID error in " << i << " \- incomplete simulation likely." << endl;
                        writeCritical(ss.str());
                        writeLog(50, "Lineage information:");
                        this_node\->logLineageInformation(50);
                        writeLog(50, "Parent information:");
                        (*nodes)[this_node\->getParent()].logLineageInformation(50);
                        error_printed = true;
                        break;
                    }
                }
#endif

            }
        }
        if(error_printed)
        {
            throw FatalException("Parent ID error when calculating coalescence tree.");
        }
    }
    // count the number of species that have been created
#ifdef DEBUG
    writeLog(10, "Completed tree creation.");
#endif // DEBUG
    iSpecies = iSpecCount;
    //      os << "iSpecies: " << iSpecies << endl;
    return iSpecCount;
}

void Community::addSpecies(unsigned long &species_count, TreeNode *tree_node, set<unsigned long> &species_list)
{
    species_count++;
    tree_node\->burnSpecies(species_count);
}

void Community::calcSpeciesAbundance()
{
    row_out.setSize(iSpecies + 1);
    //      os << "iSpecies: " << iSpecies << endl;
    for(unsigned long i = 0; i < row_out.size(); i++)
    {
        row_out[i] = 0;
    }
    for(unsigned long i = 1; i < nodes\->size(); i++)
    {
        TreeNode *this_node = &(*nodes)[i];
        if(this_node\->isTip() &&
           doubleCompare(this_node\->getGeneration(), current_community_parameters\->time, 0.0001) &&
           this_node\->getExistence())
        {
#ifdef DEBUG
            if(this_node\->getSpeciesID() >= row_out.size())
            {
                throw out_of_range("Node index out of range of abundances size. Please report this bug.");
            }
#endif // DEBUG
            // The line that counts the number of individuals
            row_out[this_node\->getSpeciesID()]++;
#ifdef DEBUG
            if(!samplemask.getMaskVal(this_node\->getXpos(), this_node\->getYpos(),
                                      this_node\->getXwrap(), this_node\->getYwrap()) &&
               doubleCompare(this_node\->getGeneration(), current_community_parameters\->time, 0.0001))
            {
                stringstream ss;
                ss << "x,y " << (*nodes)[i].getXpos() << ", " << (*nodes)[i].getYpos() << endl;
                ss << "tip: " << (*nodes)[i].isTip() << " Existance: " << (*nodes)[i].getExistence()
                     << " samplemask: " << samplemask.getMaskVal(this_node\->getXpos(), this_node\->getYpos(),
                                                                 this_node\->getXwrap(), this_node\->getYwrap()) << endl;
                ss
                        << "ERROR_SQL_005: Tip doesn\(aqt exist. Something went wrong either in the importSpatialParameters or "
                                "main simulation running."
                        << endl;
                writeWarning(ss.str());

            }
            if(this_node\->getSpeciesID() == 0 && samplemask.getMaskVal(this_node\->getXpos(), this_node\->getYpos(),
                                                                       this_node\->getXwrap(), this_node\->getYwrap()) &&
               doubleCompare(this_node\->getGeneration(), current_community_parameters\->time, 0.0001))
            {
                stringstream ss;
                ss << "x,y " << this_node\->getXpos() << ", " << this_node\->getYpos() << endl;
                ss << "generation (point,required): " << this_node\->getGeneration() << ", "
                   << current_community_parameters\->time << endl;
                TreeNode *p_node = &(*nodes)[this_node\->getParent()];
                ss << "samplemasktest: " << samplemask.getTestVal(this_node\->getXpos(), this_node\->getYpos(),
                                                                  this_node\->getXwrap(), this_node\->getYwrap()) << endl;
                ss << "samplemask: " << samplemask.getVal(this_node\->getXpos(), this_node\->getYpos(),
                                                          this_node\->getXwrap(), this_node\->getYwrap()) << endl;
                ss << "parent (tip, exists, generations): " << p_node\->isTip() << ", "
                   << p_node\->getExistence() << ", " << p_node\->getGeneration() << endl;
                ss << "species id zero \- i: " << i << " parent: " << p_node\->getParent()
                   << " speciation_probability: " << p_node\->getSpecRate() << "has speciated: " << p_node\->hasSpeciated()
                   << endl;
                writeCritical(ss.str());
                throw runtime_error("Fatal, exiting program.");
            }
#endif
        }
    }
}

void Community::resetTree()
{
    for(unsigned long i = 0; i < nodes\->size(); i++)
    {
        (*nodes)[i].qReset();
    }
}

void Community::detectDimensions(string db)
{
    sqlite3 *tmpdb;
    int rc = sqlite3_open_v2(db.c_str(), &tmpdb, SQLITE_OPEN_READWRITE, "unix\-dotfile");
    string to_exec = "SELECT MAX(xval),MAX(yval) FROM SPECIES_LIST;";
    sqlite3_stmt *stmt;
    rc = sqlite3_prepare_v2(tmpdb, to_exec.c_str(), strlen(to_exec.c_str()), &stmt, NULL);
    unsigned long xvalmax, yvalmax;
    rc = sqlite3_step(stmt);
    xvalmax = static_cast<unsigned long>(sqlite3_column_int(stmt, 0) + 1);
    yvalmax = static_cast<unsigned long>(sqlite3_column_int(stmt, 1) + 1);
    samplemask.sample_mask.SetSize(xvalmax, yvalmax);
    // close the old statement
    rc = sqlite3_finalize(stmt);
    if(rc != SQLITE_OK && rc != SQLITE_DONE)
    {
        cerr << "rc: " << rc << endl;
        throw SpeciesException("Could not detect dimensions");
    }
}

void Community::openSqlConnection(string inputfile)
{
    // open the database objects
    sqlite3_backup *backupdb;
    // open one db in memory and one from the file.
    try
    {
        openSQLiteDatabase(":memory:", database);
        openSQLiteDatabase(inputfile, outdatabase);
        bMem = true;
        // copy the db from file into memory.
        backupdb = sqlite3_backup_init(database, "main", outdatabase, "main");
        int rc = sqlite3_backup_step(backupdb, \-1);

        if(rc != SQLITE_DONE && rc != SQLITE_OK)
        {
            sqlite3_close(outdatabase);
            sqlite3_open(inputfile.c_str(), &outdatabase);
            backupdb = sqlite3_backup_init(database, "main", outdatabase, "main");
        }
        rc = sqlite3_backup_finish(backupdb);
        //          os << "rc: " << rc << endl;
        if(rc != SQLITE_DONE && rc != SQLITE_OK)
        {
            sqlite3_close(database);
            sqlite3_close(outdatabase);
            throw SpeciesException("ERROR_SQL_002: FATAL. Source file cannot be opened.");
        }
        sqlite3_close(outdatabase);
    }
    catch(FatalException &fe)
    {
        writeWarning("Can\(aqt open in\-memory database. Writing to file instead (this will be slower).\en");
        bMem = false;
        sqlite3_close(database);
        int rc = sqlite3_open_v2(inputfile.c_str(), &database, SQLITE_OPEN_READWRITE, "unix\-dotfile");
        // Revert to different VFS file opening method if the backup hasn\(aqt started properly.
        // Two different versions will be attempted before an error will be thrown.
        // A different way of assigning the VFS method and opening the file correctly could be implemented later.
        // Currently "unix\-dotfile" works for HPC runs and "unix" works for PC runs.
        if(rc != SQLITE_OK)
        {
            throw SpeciesException("ERROR_SQL_002: FATAL. Source file cannot be opened. Error: " + string(fe.what()) +
                                   " and " + to_string(rc));
        }
    }
    bSqlConnection = true;
}

void Community::setInternalDatabase()
{
    {
        openSQLiteDatabase(":memory:", database);
        internalOption();
    }
}

void Community::internalOption()
{
    bDataImport = true;
    bSqlConnection = true;
    bFileSet = true;
}

void Community::importData(string inputfile)
{
    if(!bSqlConnection)
    {
        openSqlConnection(inputfile);
    }
    if(!bDataImport)
    {
        importSimParameters(inputfile);
    }
    if(nodes\->size() != 0)
    {
        return;
    }
    writeInfo("Beginning data import...");
    // The sql statement to store the sql statement message object
    sqlite3_stmt *stmt;

    // Now find out the max size of the list, so we have a count to work from
    string count_command = "SELECT COUNT(*) FROM SPECIES_LIST;";
    sqlite3_prepare_v2(database, count_command.c_str(), static_cast<int>(strlen(count_command.c_str())), &stmt,
                       nullptr);
    unsigned long datasize;
    // skip first row (should be blank)
    sqlite3_step(stmt);
    datasize = static_cast<unsigned long>(sqlite3_column_int(stmt, 0));
    //      os << "datasize: " << datasize << endl;
    // close the old statement
    sqlite3_finalize(stmt);

    // Create db query
    string all_commands = "SELECT * FROM SPECIES_LIST;";
    sqlite3_prepare_v2(database, all_commands.c_str(), static_cast<int>(strlen(all_commands.c_str())), &stmt, nullptr);
    nodes\->setSize(datasize + 1);
    // Check that the file opened correctly.
    sqlite3_step(stmt);
    // Copy the data across to the TreeNode data structure.
    // For storing the number of ignored lineages so this can be subtracted off the parent number.
    unsigned long ignored_lineages = 0;
#ifdef DEBUG
    bool has_printed_error = false;
#endif
    for(unsigned long i = 1; i <= datasize; i++)
    {
        auto species_id = static_cast<unsigned long>(sqlite3_column_int(stmt, 1));
        //      os << species_id << endl;
        long xval = sqlite3_column_int(stmt, 2);
        long yval = sqlite3_column_int(stmt, 3);
        long xwrap = sqlite3_column_int(stmt, 4);
        long ywrap = sqlite3_column_int(stmt, 5);
        auto tip = bool(sqlite3_column_int(stmt, 6));
        auto speciation = bool(sqlite3_column_int(stmt, 7));
        auto parent = static_cast<unsigned long>(sqlite3_column_int(stmt, 8));
        auto iGen = static_cast<unsigned long>(sqlite3_column_int(stmt, 11));
        auto existence = bool(sqlite3_column_int(stmt, 9));
        double dSpec = sqlite3_column_double(stmt, 10);
        long double generationin = sqlite3_column_double(stmt, 12);
        //          os << xval << ", " << yval << endl;
        // ignored lineages are now not ignored!
        // TODO fix this properly and check functionality
//      if(tip && !samplemask.getVal(xval, yval) && generationin > generation && false)
//      {
//          ignored_lineages++;
//          sqlite3_step(stmt);
//      }
//      else
//      {
        // the \-1 is to ensure that the list includes all lineages, but fills the output from the beginning
        unsigned long index = i \- 1 \- ignored_lineages;
        (*nodes)[index].setup(tip, xval, yval, xwrap, ywrap, generationin);
        (*nodes)[index].burnSpecies(species_id);
        (*nodes)[index].setSpec(dSpec);
        (*nodes)[index].setExistence(existence);
        (*nodes)[index].setGenerationRate(iGen);
        (*nodes)[index].setParent(parent \- ignored_lineages);
        if(index == parent && parent != 0)
        {
            cerr << " i: " << index << " parent: " << parent << endl;
            cerr << "ERROR_SQL_001: Import failed as parent is self. Check importSpatialParameters function." << endl;
        }
        (*nodes)[index].setSpeciation(speciation);
        sqlite3_step(stmt);
#ifdef DEBUG
        if(parent < index && !speciation)
        {
            if(!has_printed_error)
            {
                stringstream ss;
                ss << "parent: " << parent << " index: " << index << endl;
                ss << "Parent before index error. Check program." << endl;
                has_printed_error = true;
                writeWarning(ss.str());
            }
        }
#endif
//      }
    }
    // Now we need to blank all objects
    sqlite3_finalize(stmt);
    // Now read the useful information from the SIMULATION_PARAMETERS table
    writeInfo("\erBeginning data import...done\en");
}

void Community::getMaxSpeciesAbundancesID()
{
    if(!bSqlConnection)
    {
        throw FatalException("Attempted to get from sql database without opening database connection.");
    }
    if(max_species_id == 0)
    {
        sqlite3_stmt *stmt;
        // Now find out the max size of the list, so we have a count to work from
        string count_command = "SELECT MAX(ID) FROM SPECIES_ABUNDANCES;";
        sqlite3_prepare_v2(database, count_command.c_str(), static_cast<int>(strlen(count_command.c_str())), &stmt,
                           nullptr);
        sqlite3_step(stmt);
        max_species_id = static_cast<unsigned long>(sqlite3_column_int(stmt, 0)) + 1;
        // close the old statement
        sqlite3_finalize(stmt);
    }
}

Row<unsigned long> * Community::getCumulativeAbundances()
{
    unsigned long total = 0;
    for(unsigned long i = 0; i < row_out.size(); i ++)
    {
        total += row_out[i];
        row_out[i] = total;
    }
    return &row_out;
}

Row<unsigned long> Community::getRowOut()
{
    return row_out;
}

unsigned long Community::getSpeciesNumber()
{
    return iSpecies;
}
void Community::getMaxSpeciesLocationsID()
{
    if(!bSqlConnection)
    {
        throw FatalException("Attempted to get from sql database without opening database connection.");
    }
    if(max_locations_id == 0)
    {
        sqlite3_stmt *stmt;
        // Now find out the max size of the list, so we have a count to work from
        string count_command = "SELECT MAX(ID) FROM SPECIES_LOCATIONS;";
        sqlite3_prepare_v2(database, count_command.c_str(), static_cast<int>(strlen(count_command.c_str())), &stmt,
                           nullptr);
        sqlite3_step(stmt);
        max_locations_id = static_cast<unsigned long>(sqlite3_column_int(stmt, 0)) + 1;
        // close the old statement
        sqlite3_finalize(stmt);
    }
}

void Community::getMaxFragmentAbundancesID()
{
    if(!bSqlConnection)
    {
        throw FatalException("Attempted to get from sql database without opening database connection.");
    }
    if(max_fragment_id == 0)
    {
        sqlite3_stmt *stmt;
        // Now find out the max size of the list, so we have a count to work from
        string count_command = "SELECT MAX(ID) FROM FRAGMENT_ABUNDANCES;";
        sqlite3_prepare_v2(database, count_command.c_str(), static_cast<int>(strlen(count_command.c_str())), &stmt,
                           nullptr);
        sqlite3_step(stmt);
        max_fragment_id = static_cast<unsigned long>(sqlite3_column_int(stmt, 0)) + 1;
        // close the old statement
        sqlite3_finalize(stmt);
    }
}

void Community::createDatabase()
{
    generateCoalescenceTree();
    stringstream os;
    os << "Generating new SQL table for speciation rate " << current_community_parameters\->speciation_rate
       << "..." << flush;
    writeInfo(os.str());
    string table_command = "CREATE TABLE IF NOT EXISTS SPECIES_ABUNDANCES (ID int PRIMARY KEY NOT NULL, "
            "species_id INT NOT NULL, no_individuals INT NOT "
            "NULL, community_reference INT NOT NULL);";
    int rc = sqlite3_exec(database, table_command.c_str(), nullptr, nullptr, nullptr);
    if(rc != SQLITE_OK)
    {
        throw SpeciesException("ERROR_SQL_002b: Could not create SPECIES_ABUNDANCES table.");
    }
    getMaxSpeciesAbundancesID();
    outputSpeciesAbundances();
}

void Community::generateCoalescenceTree()
{
    writeInfo("Calculating tree structure...");
    // Search through past speciation rates
    if(current_community_parameters\->speciation_rate < min_spec_rate)
    {
        if(doubleCompare(current_community_parameters\->speciation_rate, min_spec_rate, min_spec_rate * 0.000001))
        {
            current_community_parameters\->speciation_rate = min_spec_rate;
        }
        else
        {
            stringstream ss;
            ss << "ERROR_SQL_018: Speciation rate of " << current_community_parameters\->speciation_rate;
            ss << " is less than the minimum possible (" << min_spec_rate << ". Skipping." << endl;
            throw SpeciesException(ss.str());
        }
    }
    unsigned long nspec = calcSpecies();
    calcSpeciesAbundance();
    stringstream os;
    os << "done!" << endl;
    os << "Number of species: " << nspec << endl;
    writeInfo(os.str());
    os.str("");
}

void Community::outputSpeciesAbundances()
{
    // Only write to SPECIES_ABUNDANCES if the speciation rate has not already been applied
    if(!current_community_parameters\->updated)
    {
//#ifdef DEBUG
        if(checkSpeciesAbundancesReference())
        {
            stringstream ss;
            ss << "Duplicate insertion of " << current_community_parameters\->reference << "into SPECIES_ABUNDANCES.";
            ss << endl;
            writeWarning(ss.str());
            return;
        }
//#endif // DEBUG
        sqlite3_stmt *stmt;
        string table_command = "INSERT INTO SPECIES_ABUNDANCES (ID, species_id, "
                "no_individuals, community_reference) VALUES (?,?,?,?);";
        sqlite3_prepare_v2(database, table_command.c_str(), static_cast<int>(strlen(table_command.c_str())), &stmt,
                           nullptr);

        // Start the transaction
        sqlite3_exec(database, "BEGIN TRANSACTION;", nullptr, nullptr, nullptr);
        for(unsigned long i = 0; i < row_out.size(); i++)
        {
            // only do all the export itself if the value of i is not 0
            // if(row_out[i] != 0)
            //{

            // fixed precision problem \- lexical cast allows for printing of very small doubles.
            sqlite3_bind_int(stmt, 1, static_cast<int>(max_species_id++));
            sqlite3_bind_int(stmt, 2, static_cast<int>(i));
            sqlite3_bind_int(stmt, 3, row_out[i]);
            sqlite3_bind_int(stmt, 4, static_cast<int>(current_community_parameters\->reference));
            int step = sqlite3_step(stmt);
            // makes sure the while loop doesn\(aqt go forever.
            time_t start_check, end_check;
            time(&start_check);
            time(&end_check);
            while(step != SQLITE_DONE && (end_check \- start_check) < 1)
            {
                step = sqlite3_step(stmt);
                time(&end_check);
            }
            if(step != SQLITE_DONE)
            {
                stringstream os;
                os << "SQLITE error code: " << step << endl;
                os << "ERROR_SQL_004d: Could not insert into database. Check destination file has not "
                        "been moved or deleted and that an entry doesn\(aqt already exist with the same ID."
                   << endl;
                os << sqlite3_errmsg(database) << endl;
                sqlite3_clear_bindings(stmt);
                sqlite3_reset(stmt);
                throw FatalException(os.str());
            }
            sqlite3_clear_bindings(stmt);
            sqlite3_reset(stmt);

        }
        // execute the command and close the connection to the database
        int rc1 = sqlite3_exec(database, "END TRANSACTION;", nullptr, nullptr, nullptr);
        // Need to finalise the statement
        int rc2 = sqlite3_finalize(stmt);
        if(rc1 != SQLITE_OK || rc2 != SQLITE_OK)
        {
            cerr << "ERROR_SQL_013: Could not complete SQL transaction. Check memory database assignment and "
                    "SQL commands. Ensure SQL statements are properly cleared and that you are not attempting "
                    "to insert repeat IDs into the database."
                 << endl;
        }
        else
        {
            stringstream ss;
            ss << "\erGenerating new SQL table for speciation rate " << current_community_parameters\->speciation_rate
               << "...done!" << endl;
            writeInfo(ss.str());
        }
    }
    else
    {
        stringstream ss;
        ss << "parameters already applied, not outputting SPECIES_ABUNDANCES table..." << endl;
        writeInfo(ss.str());
    }
}

bool Community::checkCalculationsPerformed(long double speciation_rate, double time, bool fragments,
                                          unsigned long metacommunity_size, long double metacommunity_speciation_rate)
{
    auto metacommunity_reference = past_metacommunities.getReference(metacommunity_speciation_rate, metacommunity_size);
    if(metacommunity_reference == 0 &&  metacommunity_size != 0)
    {
        return false;
    }
    bool has_pair = past_communities.hasPair(speciation_rate, time, fragments,
                                             metacommunity_reference);
#ifdef DEBUG
    stringstream os;
    os << "Checking for calculations with sr=" << speciation_rate << ", t=" << time;
    os << " and ref: " << past_metacommunities.getReference(metacommunity_speciation_rate,
                                                            metacommunity_size) << ": " << has_pair << endl;
    writeLog(10, os);
#endif // DEBUG
    if(fragments && past_communities.hasPair(speciation_rate, time, false, metacommunity_reference))
    {
        return false;

    }
    if(!fragments && past_communities.hasPair(speciation_rate, time, true, metacommunity_reference))
    {
        return true;
    }
//  if(past_communities.hasPair(speciation_rate, time, !fragments,
//                              past_metacommunities.getReference(metacommunity_speciation_rate, metacommunity_size)))
//  {
//      return !fragments || has_pair;
//  }
    return has_pair;
}

void Community::createFragmentDatabase(const Fragment &f)
{
    //      os << "Generating new SQL table for speciation rate " << s << "..." << flush;
    string table_command = "CREATE TABLE IF NOT EXISTS FRAGMENT_ABUNDANCES (ID int PRIMARY KEY NOT NULL, fragment "
            "TEXT NOT NULL, area DOUBLE NOT NULL, size INT NOT NULL,  species_id INT NOT NULL, "
            "no_individuals INT NOT NULL, community_reference int NOT NULL);";
    sqlite3_exec(database, table_command.c_str(), nullptr, nullptr, nullptr);
    getMaxFragmentAbundancesID();
    sqlite3_stmt *stmt;
    table_command = "INSERT INTO FRAGMENT_ABUNDANCES (ID, fragment, area, size, species_id, "
            "no_individuals, community_reference) VALUES (?,?,?,?,?,?,?);";
    sqlite3_prepare_v2(database, table_command.c_str(), static_cast<int>(strlen(table_command.c_str())), &stmt,
                       nullptr);

    // Start the transaction
    sqlite3_exec(database, "BEGIN TRANSACTION;", nullptr, nullptr, nullptr);
    for(unsigned long i = 0; i < row_out.size(); i++)
    {
        if(row_out[i] != 0)
        {
            // fixed precision problem \- lexical cast allows for printing of very small doubles.
            sqlite3_bind_int(stmt, 1, static_cast<int>(max_fragment_id++));
            sqlite3_bind_text(stmt, 2, f.name.c_str(), \-1, SQLITE_STATIC);
            sqlite3_bind_double(stmt, 3, f.area);
            sqlite3_bind_int(stmt, 4, static_cast<int>(f.num));
            sqlite3_bind_int(stmt, 5, static_cast<int>(i));
            sqlite3_bind_int(stmt, 6, row_out[i]);
            sqlite3_bind_int(stmt, 7, static_cast<int>(current_community_parameters\->reference));
            int step = sqlite3_step(stmt);
            // makes sure the while loop doesn\(aqt go forever.
            time_t start_check, end_check;
            time(&start_check);
            time(&end_check);
            while(step != SQLITE_DONE && (end_check \- start_check) < 10)
            {
                step = sqlite3_step(stmt);
                time(&end_check);
            }
            if(step != SQLITE_DONE)
            {
                stringstream ss;
                ss << "SQLITE error code: " << step << endl;
                cerr << "ERROR_SQL_004e: Could not insert into database. Check destination file has not "
                        "been moved or deleted and that an entry doesn\(aqt already exist with the same ID."
                     << endl;
                ss << sqlite3_errmsg(database) << endl;
                writeWarning(ss.str());
                sqlite3_clear_bindings(stmt);
                sqlite3_reset(stmt);
                break;
            }
            sqlite3_clear_bindings(stmt);
            sqlite3_reset(stmt);
        }
    }
    // execute the command and close the connection to the database
    int rc1 = sqlite3_exec(database, "END TRANSACTION;", nullptr, nullptr, nullptr);
    // Need to finalise the statement
    int rc2 = sqlite3_finalize(stmt);
    if(rc1 != SQLITE_OK || rc2 != SQLITE_OK)
    {
        cerr << "ERROR_SQL_013: Could not complete SQL transaction. Check memory database assignment and SQL "
                "commands. Ensure SQL statements are properly cleared and that you are not attempting to insert "
                "repeat IDs into the database."
             << endl;
    }
}

void Community::exportDatabase()
{
    if(bMem)
    {
        stringstream ss;
        stringstream os;
        os << "Writing out to " << spec_sim_parameters\->filename << "..." << flush;
        // Now write the database to the file object.
        sqlite3 *outdatabase2;
        writeInfo(os.str());
        int rc = sqlite3_open_v2(spec_sim_parameters\->filename.c_str(), &outdatabase2, SQLITE_OPEN_READWRITE, "unix\-dotfile");
        // check that the connection to file has opened correctly
        if(rc != SQLITE_OK && rc != SQLITE_DONE)
        {
            // attempt other output method
            sqlite3_close(outdatabase2);
            rc = sqlite3_open(spec_sim_parameters\->filename.c_str(), &outdatabase2);
            if(rc != SQLITE_OK && rc != SQLITE_DONE)
            {
                ss << "ERROR_SQL_016: Connection to output database cannot be opened. Check write access "
                        "on output folder. Error code: "
                     << rc << "." << endl;
                throw FatalException(ss.str());
            }
        }

        // create the backup object to write data to the file from memory.

        sqlite3_backup *backupdb;
        backupdb = sqlite3_backup_init(outdatabase2, "main", database, "main");
        if(!backupdb)
        {
            ss << "ERROR_SQL_003: Could not backup to SQL database. Check destination file has not been "
                    "moved or deleted."
                 << endl;
            throw FatalException(ss.str());
        }
        // Perform the backup
        rc = sqlite3_backup_step(backupdb, \-1);
        if(rc != SQLITE_OK && rc != SQLITE_DONE)
        {
            ss << "ERROR_SQL_016: Connection to output database cannot be opened. Check write access on "
                    "output folder. Error code: "
                 << rc << "." << endl;
            throw FatalException(ss.str());
        }
        rc = sqlite3_backup_finish(backupdb);
        if(rc != SQLITE_OK && rc != SQLITE_DONE)
        {
            ss << "ERROR_SQL_016: Connection to output database cannot be opened. Check write access on "
                    "output folder. Error code: "
                 << rc << "." << endl;
            throw FatalException(ss.str());
        }
        sqlite3_close(outdatabase2);
        sqlite3_close(database);
        writeInfo("done!\en");
    }
    else
    {
        sqlite3_close(database);
    }
}

bool Community::checkSpeciesLocationsReference()
{
    if(!bSqlConnection)
    {
        throw FatalException("Attempted to get from sql database without opening database connection.");
    }

    sqlite3_stmt *stmt;
    // Now find out the max size of the list, so we have a count to work from
    string count_command = "SELECT COUNT(*) FROM SPECIES_LOCATIONS WHERE community_reference == ";
    count_command += to_string(current_community_parameters\->reference) + ";";
    sqlite3_prepare_v2(database, count_command.c_str(), static_cast<int>(strlen(count_command.c_str())), &stmt,
                       nullptr);
    sqlite3_step(stmt);
    int tmp_val = sqlite3_column_int(stmt, 0);
    // close the old statement
    sqlite3_finalize(stmt);
    return tmp_val > 0;
}

bool Community::checkSpeciesAbundancesReference()
{
    if(!bSqlConnection)
    {
        throw FatalException("Attempted to get from sql database without opening database connection.");
    }

    sqlite3_stmt *stmt;
    // Now find out the max size of the list, so we have a count to work from
    string count_command = "SELECT COUNT(*) FROM SPECIES_ABUNDANCES WHERE community_reference = ";
    count_command += to_string(current_community_parameters\->reference) + ";";
    sqlite3_prepare_v2(database, count_command.c_str(), static_cast<int>(strlen(count_command.c_str())), &stmt,
                       nullptr);
    sqlite3_step(stmt);
    int tmp_val = sqlite3_column_int(stmt, 0);
    // close the old statement
    sqlite3_finalize(stmt);
    return tmp_val > 0;
}

void Community::recordSpatial()
{
//  os << "Recording spatial data for speciation rate " << current_community_parameters\->speciation_rate << "..." << flush;
    string table_command = "CREATE TABLE IF NOT EXISTS SPECIES_LOCATIONS (ID int PRIMARY KEY NOT NULL, species_id INT "
            "NOT NULL, x INT NOT NULL, y INT NOT NULL, community_reference INT NOT NULL);";
    sqlite3_exec(database, table_command.c_str(), nullptr, nullptr, nullptr);
    getMaxSpeciesLocationsID();
    sqlite3_stmt *stmt;
    // Checks that the SPECIES_LOCATIONS table doesn\(aqt already have a reference in matching the current reference
    if(current_community_parameters\->updated)
    {
        if(checkSpeciesLocationsReference())
        {
            return;
        }
    }
    table_command = "INSERT INTO SPECIES_LOCATIONS (ID,species_id, x, y, community_reference) VALUES (?,?,?,?,?);";

    sqlite3_prepare_v2(database, table_command.c_str(), static_cast<int>(strlen(table_command.c_str())), &stmt,
                       nullptr);
    //      os << "test1" << endl;
    // Start the transaction
    sqlite3_exec(database, "BEGIN TRANSACTION;", nullptr, nullptr, nullptr);
    // Make sure only the tips which we want to check are recorded
    //      os << "nodes\->size(): " << nodes\->size() << endl;
    for(unsigned long i = 1; i < nodes\->size(); i++)
    {
        TreeNode *this_node = &(*nodes)[i];
        //          os << nodes[i].getExistence() << endl;
        if(this_node\->isTip() &&
           this_node\->getExistence() && doubleCompare(static_cast<double>(this_node\->getGeneration()),
                                                      static_cast<double>(current_community_parameters\->time), 0.0001))
        {
            if(samplemask.getMaskVal(this_node\->getXpos(), this_node\->getYpos(),
                                     this_node\->getXwrap(), this_node\->getYwrap()))
            {
                long x = this_node\->getXpos();
                long y = this_node\->getYpos();
                long xwrap = this_node\->getXwrap();
                long ywrap = this_node\->getYwrap();
                long xval = x + (xwrap * grid_x_size) + samplemask_x_offset;
                long yval = y + (ywrap * grid_y_size) + samplemask_y_offset;
                sqlite3_bind_int(stmt, 1, static_cast<int>(max_locations_id++));
                sqlite3_bind_int(stmt, 2, static_cast<int>(this_node\->getSpeciesID()));
                sqlite3_bind_int(stmt, 3, static_cast<int>(xval));
                sqlite3_bind_int(stmt, 4, static_cast<int>(yval));
                sqlite3_bind_int(stmt, 5, static_cast<int>(current_community_parameters\->reference));
                int step = sqlite3_step(stmt);
                // makes sure the while loop doesn\(aqt go forever.
                time_t start_check, end_check;
                time(&start_check);
                time(&end_check);
                while(step != SQLITE_DONE && (end_check \- start_check) < 10 && step != SQLITE_OK)
                {
                    step = sqlite3_step(stmt);
                    time(&end_check);
                }
                if(step != SQLITE_DONE)
                {
                    stringstream ss;
                    ss << "SQLITE error code: " << step << endl;
                    ss << "ERROR_SQL_004f: Could not insert into database. Check destination file has not "
                            "been moved or deleted and that an entry doesn\(aqt already exist with the same ID."
                       << endl;
                    ss << sqlite3_errmsg(database) << endl;
                    writeWarning(ss.str());
                    break;
                }
                sqlite3_clear_bindings(stmt);
                sqlite3_reset(stmt);
            }
        }
    }
    // execute the command and close the connection to the database
    int rc1 = sqlite3_exec(database, "END TRANSACTION;", nullptr, nullptr, nullptr);
    // Need to finalise the statement
    int rc2 = sqlite3_finalize(stmt);
    if(rc1 != SQLITE_OK || rc2 != SQLITE_OK)
    {
        cerr << "ERROR_SQL_013: Could not complete SQL transaction. Check memory database assignment and SQL "
                "commands. Ensure SQL statements are properly cleared and that you are not attempting to insert "
                "repeat IDs into the database."
             << endl;
    }
}

void Community::calcFragments(string fragment_file)
{
    // Loop over every grid cell in the samplemask to determine if it is the start (top left corner) of a fragment.
    // Note that fragment detection only works for squares and rectangles. Adjacent squares and rectangles will be
    // treated as separate fragments if they are different sizes.
    // Downwards shapes are prioritised (i.e. a vertical rectangle on top of a horizontal rectangle will produce 3
    // fragments instead of two \- this is a known bug).
    if(fragment_file == "null")
    {
        unsigned long fragment_number = 0;
        for(unsigned long i = 0; i < samplemask.sample_mask.GetCols(); i++)
        {
            for(unsigned long j = 0; j < samplemask.sample_mask.GetRows(); j++)
            {
                bool in_fragment = false;
                // Make sure is isn\(aqt on the top or left edge
                if(samplemask.sample_mask[j][i])
                {
                    if(i > 0 && j > 0)
                    {
                        // Perform the check
                        in_fragment = !(samplemask.sample_mask[j][i \- 1] || samplemask.sample_mask[j \- 1][i]);
                    }
                        // if it is on an edge, we need to check the fragment
                    else
                    {
                        // if it is on the left edge we need to check above it \- if there is forest
                        // there, it is not a fragment.
                        if(i == 0 && j > 0)
                        {
                            if(!samplemask.sample_mask[j \- 1][i])
                            {
                                in_fragment = true;
                            }
                        }
                            // if it is on the top edge, need to check to the left of it \-  if there is
                            // forest there, it is not a fragment.
                        else if(j == 0 && i > 0)
                        {
                            if(!samplemask.sample_mask[j][i \- 1])
                            {
                                in_fragment = true;
                            }
                        }
                        else if(i == 0 && j == 0)
                        {
                            in_fragment = true;
                        }
                    }
                }
                if(in_fragment)
                {
                    // Now move along the x and y axis (separately) until we hit a non\-forest patch.
                    // This marks the edge of the fragment and the value is recorded.
                    bool x_continue = true;
                    bool y_continue = true;
                    unsigned long x, y;
                    x = i;
                    y = j;
                    fragment_number++;
                    // Also need to check that fragments that lie partly next to each other aren\(aqt
                    // counted twice.
                    // So count along the x axis until we hit non\-habitat. Then count down the y axis
                    // checking both extremes of the square for non\-habitat.
                    // Perform a check on the x axis to make sure that the square above is empty, as
                    // fragments give priority in a downwards motion.
                    while(x_continue)
                    {
                        x++;
                        if(samplemask.sample_mask[j][x])
                        {
                            // Check we\(aqre not on top edge of the map.
                            if(j > 0)
                            {
                                // if the cell above is non\-fragment then we don\(aqt need to
                                // continue (downwards fragments get priority).
                                if(samplemask.sample_mask[j \- 1][x])
                                {
                                    x_continue = true;
                                }
                                else
                                {
                                    x_continue = false;
                                }
                            }
                            else
                            {
                                x_continue = true;
                            }
                        }
                        else
                        {
                            x_continue = false;
                        }
                    }
                    while(y_continue)
                    {
                        y++;
                        // Make sure both extremes of the rectangle are still within patch.
                        if(samplemask.sample_mask[y][i] && samplemask.sample_mask[y][i \- 1])
                        {
                            y_continue = true;
                        }
                        else
                        {
                            y_continue = false;
                        }
                    }
                    // Create the fragment to add.
                    Fragment to_add;
                    to_add.name = to_string((long long) fragment_number);
                    to_add.x_west = i;
                    to_add.x_east = x \- 1;
                    to_add.y_north = j;
                    to_add.y_south = y \- 1;
                    // calculate the square area of the plot and record it.
                    to_add.area = (x \- i) * (y \- j);
                    // Now store the size of the fragment in the vector.
                    fragments.push_back(to_add);
                }
            }
        }
    }
    else
    {
#ifdef use_csv
        stringstream os;
        os << "Importing fragments from " << fragment_file << endl;
        writeInfo(os.str());
        // There is a config file to import \- here we use a specific piece of importSpatialParameters code to parse the csv file.
        // first count the number of lines
        int number_of_lines = 0;
        string line;
        ifstream fragment_configs(fragment_file);
        while(getline(fragment_configs, line))
        {
            number_of_lines++;
        }
        //          os << "Number of lines in text file: " << number_of_lines << endl;
        fragment_configs.close();
        io::LineReader in(fragment_file);
        // Keep track of whether we\(aqve printed to terminal or not.
        bool bPrint = false;
        fragments.resize(number_of_lines);
//      os << "size: "  << fragments.capacity() << endl;
        for(int i = 0; i < number_of_lines; i++)
        {

            //              os << i << endl;
            char *line = in.next_line();
//          os << line << endl;
            if(line == nullptr)
            {
                if(!bPrint)
                {
                    cerr << "Input dimensions incorrect \- read past end of file." << endl;
                    bPrint = true;
                }
                break;
            }
            else
            {
                char *dToken;
                dToken = strtok(line, ",");
                for(int j = 0; j < 6; j++)
                {
                    //                      os << j << endl;
                    if(dToken == nullptr)
                    {
                        if(!bPrint)
                        {
                            cerr << "Input dimensions incorrect \- read past end of file."
                                 << endl;
                            bPrint = true;
                        }
                        break;
                    }
                    else
                    {
                        //                          os << "\-" << endl;
                        switch(j)
                        {
                            case 0:
                                fragments[i].name = string(dToken);
                                break;
                            case 1:
                                fragments[i].x_west = atoi(dToken);
                                break;
                            case 2:
                                fragments[i].y_north = atoi(dToken);
                                break;
                            case 3:
                                fragments[i].x_east = atoi(dToken);
                                break;
                            case 4:
                                fragments[i].y_south = atoi(dToken);
                                break;
                            case 5:
                                fragments[i].area = atof(dToken);
                                break;
                        }
                        dToken = strtok(NULL, ",");
                    }
                }
            }
        }
#endif
#ifndef use_csv
        cerr << "Cannot importSpatialParameters fragments from " << fragment_file << " without fast\-cpp\-csv\-parser." << endl;
        cerr << "Make sure the program has been compiled with \-D use_csv." << endl;
#endif
    }
//  os << "Completed fragmentation analysis: " << fragments.size() << " fragments identified." << endl;
}

void Community::applyFragments()
{
    // For each fragment in the vector, perform the analysis and record the data in to a new data object, which will
    // then be outputted to an SQL file.
    for(unsigned int i = 0; i < fragments.size(); i++)
    {
        stringstream os;
        os << "\erApplying fragments... " << (i + 1) << "/" << fragments.size() << "      " << flush;
        writeInfo(os.str());
        // Set the new samplemask to the fragment
        samplemask.setFragment(fragments[i]);
        // Now filter only those lineages which exist in the fragments.
        // We also want to count the number of individuals that actually exist
        unsigned long iSpecCount = 0;
        for(unsigned long j = 0; j < nodes\->size(); j++)
        {
            TreeNode *this_node = &(*nodes)[j];
            if(this_node\->isTip() && samplemask.getMaskVal(this_node\->getXpos(), this_node\->getYpos(),
                                                           this_node\->getXwrap(), this_node\->getYwrap()) &&
               doubleCompare(this_node\->getGeneration(), current_community_parameters\->time, 0.0001))
            {
                // if they exist exactly in the generation of interest.
                this_node\->setExistence(true);
                iSpecCount++;
            }
            else if(this_node\->isTip())
            {
                this_node\->setExistence(false);
            }
        }
        fragments[i].num = iSpecCount;
        // Now calculate the species abundance. This will create a vector with lots of zeros in it. However, the
        // database creation will filter these out.
        calcSpeciesAbundance();
        createFragmentDatabase(fragments[i]);
        //          os << "done!" << endl;
    }
    samplemask.removeFragment();
    writeInfo("done!\en");
}

void Community::importSimParameters(string file)
{
    if(bDataImport)
    {
        return;
    }
    if(!bSqlConnection)
    {
#ifdef DEBUG
        stringstream os;
        os << "opening connection..." << flush;
#endif
        openSqlConnection(file);
#ifdef DEBUG
        os << "done!" << endl;
        writeInfo(os.str());
#endif
    }
    try
    {
#ifdef DEBUG
        stringstream os;
        os << "Reading parameters..." << flush;
#endif
        sqlite3_stmt *stmt2;
        string sql_parameters = "SELECT speciation_rate, grid_x, grid_y, protracted, min_speciation_gen, max_speciation_gen, "
                "sample_x_offset, sample_y_offset, sample_x, sample_y  FROM SIMULATION_PARAMETERS;";
        int rc = sqlite3_prepare_v2(database, sql_parameters.c_str(), static_cast<int>(strlen(sql_parameters.c_str())),
                                    &stmt2, nullptr);
        if(rc != SQLITE_DONE && rc != SQLITE_OK)
        {
            stringstream ss;
            ss << "ERROR_SQL_020: FATAL. Could not open simulation parameters in " << file << ". Error code: ";
            ss << sqlite3_errmsg(database);
            sqlite3_close(outdatabase);
            sqlite3_close(database);
            throw SpeciesException(ss.str());
        }
        sqlite3_step(stmt2);
        min_spec_rate = sqlite3_column_double(stmt2, 0);
        grid_x_size = static_cast<unsigned long>(sqlite3_column_int(stmt2, 1));
        grid_y_size = static_cast<unsigned long>(sqlite3_column_int(stmt2, 2));
        protracted = bool(sqlite3_column_int(stmt2, 3));
        min_speciation_gen = sqlite3_column_double(stmt2, 4);
        max_speciation_gen = sqlite3_column_double(stmt2, 5);
        samplemask_x_offset = static_cast<unsigned long>(sqlite3_column_int(stmt2, 6));
        samplemask_y_offset = static_cast<unsigned long>(sqlite3_column_int(stmt2, 7));
        samplemask_x_size = static_cast<unsigned long>(sqlite3_column_int(stmt2, 8));
        samplemask_y_size = static_cast<unsigned long>(sqlite3_column_int(stmt2, 9));
        if(protracted)
        {
            if(max_speciation_gen == 0.0)
            {
                throw SpeciesException("Protracted speciation does not make sense when maximum speciation gen is 0.0.");
            }
            if(min_speciation_gen > max_speciation_gen)
            {
                throw SpeciesException("Cannot have simulation with minimum speciation generation less than maximum!");
            }
        }
        sqlite3_step(stmt2);
        sqlite3_finalize(stmt2);
#ifdef DEBUG
        os << "done!" << endl;
        writeInfo(os.str());
#endif
    }
    catch(exception &er)
    {
        throw SpeciesException(er.what());
    }
    bDataImport = true;
}

void Community::setProtractedParameters(double max_speciation_gen_in)
{
    if(max_speciation_gen_in > max_speciation_gen)
    {
        throw SpeciesException(
                "Maximum protracted speciation generation is higher than original value for simulation.");
    }
    else
    {
        applied_max_speciation_gen = max_speciation_gen_in;
        protracted = true;
    }
}

void Community::setProtractedParameters(const double &min_speciation_gen_in, const double &max_speciation_gen_in)
{
    applied_max_speciation_gen = max_speciation_gen_in;
    applied_min_speciation_gen = min_speciation_gen_in;
    if(min_speciation_gen > 0 && max_speciation_gen > 0 &&
            (applied_min_speciation_gen > min_speciation_gen || applied_max_speciation_gen > max_speciation_gen))
    {
#ifdef DEBUG
        writeLog(50, "Applied speciation parameters: " + to_string(applied_min_speciation_gen) + ", " +
                to_string(applied_max_speciation_gen));
        writeLog(50, "Simulated speciation parameters: " + to_string(min_speciation_gen_in) + ", " +
                     to_string(max_speciation_gen_in));
#endif // DEBUG
        throw SpeciesException("Cannot use protracted parameters with minimum > simulated minimum or "
                                       "maximum > simulated maximums.");
    }
}

void Community::overrideProtractedParameters(const double &min_speciation_gen_in, const double &max_speciation_gen_in)
{
    min_speciation_gen = min_speciation_gen_in;
    max_speciation_gen = max_speciation_gen_in;
    applied_max_speciation_gen = max_speciation_gen_in;
    applied_min_speciation_gen = min_speciation_gen_in;;
}

void Community::setProtracted(bool protracted_in)
{
    protracted = protracted_in;
}


void Community::getPreviousCalcs()
{
    // Read the community parameters and store them in the relevant objects
    sqlite3_stmt *stmt1;
    string call1 = "select count(type) from sqlite_master where type=\(aqtable\(aq and name=\(aqCOMMUNITY_PARAMETERS\(aq";
    int rc = sqlite3_prepare_v2(database, call1.c_str(), static_cast<int>(strlen(call1.c_str())), &stmt1, nullptr);
    if(rc != SQLITE_DONE && rc != SQLITE_OK)
    {
        sqlite3_close(outdatabase);
        sqlite3_close(database);
        throw SpeciesException("ERROR_SQL_020: FATAL. Could not check for COMMUNITY_PARAMETERS table. Error code: " +
                               to_string(rc));
        //              exit(EXIT_FAILURE);
    }
    sqlite3_step(stmt1);
    auto has_community_parameters = static_cast<bool>(sqlite3_column_int(stmt1, 0));
    sqlite3_step(stmt1);
    sqlite3_finalize(stmt1);
    // Read the speciation rates from the community_parameters table
    if(has_community_parameters)
    {
        sqlite3_stmt *stmt2;
        string call2 = "SELECT reference, speciation_rate, time, fragments, metacommunity_reference FROM ";
        call2 += "COMMUNITY_PARAMETERS";
        rc = sqlite3_prepare_v2(database, call2.c_str(), static_cast<int>(strlen(call2.c_str())), &stmt2,
                                nullptr);
        if(rc != SQLITE_DONE && rc != SQLITE_OK)
        {
            sqlite3_close(outdatabase);
            sqlite3_close(database);
            throw SpeciesException("ERROR_SQL_020: FATAL. Could not detect COMMUNITY_PARAMETERS table. Error code: " +
                                   to_string(rc));
        }
        rc = sqlite3_step(stmt2);
        while(rc == SQLITE_ROW)
        {
            auto row_val = sqlite3_column_int(stmt2, 0);
            if(row_val == 0)
            {
                writeWarning("Reference of 0 found in community parameters in database, skipping...\en");
            }
            else
            {
                past_communities.pushBack(static_cast<unsigned long>(row_val),
                                          sqlite3_column_double(stmt2, 1),
                                          sqlite3_column_double(stmt2, 2),
                                          bool(sqlite3_column_int(stmt2, 3)),
                                          static_cast<unsigned long>(sqlite3_column_int(stmt2, 4)));
            }
            rc = sqlite3_step(stmt2);
        }
        if(rc != SQLITE_OK && rc != SQLITE_DONE)
        {
            stringstream ss;
            ss << "ERROR_SQL_020b: FATAL. Could not read community parameters." << endl;
            ss << "Code: " << rc << endl << "Errmsg: ";
            ss << sqlite3_errmsg(database) << endl;
            sqlite3_clear_bindings(stmt2);
            sqlite3_reset(stmt2);
            throw SpeciesException(ss.str());
        }
        sqlite3_finalize(stmt2);
    }
    // And the same for metacommunity parameters
    sqlite3_stmt *stmt3;
    string call3 = "select count(type) from sqlite_master where type=\(aqtable\(aq and name=\(aqMETACOMMUNITY_PARAMETERS\(aq";
    rc = sqlite3_prepare_v2(database, call3.c_str(), static_cast<int>(strlen(call3.c_str())), &stmt3, nullptr);
    if(rc != SQLITE_DONE && rc != SQLITE_OK)
    {
        sqlite3_close(outdatabase);
        sqlite3_close(database);
        throw SpeciesException(
                "ERROR_SQL_020: FATAL. Could not check for METACOMMUNITY_PARAMETERS table. Error code: " +
                to_string(rc));
    }
    sqlite3_step(stmt3);
    has_community_parameters = static_cast<bool>(sqlite3_column_int(stmt3, 0));
    sqlite3_step(stmt3);
    sqlite3_finalize(stmt3);
    // Read the speciation rates from the community_parameters table
    if(has_community_parameters)
    {
        sqlite3_stmt *stmt4;
        string call4 = "SELECT reference, speciation_rate, metacommunity_size FROM ";
        call4 += "METACOMMUNITY_PARAMETERS";
        rc = sqlite3_prepare_v2(database, call4.c_str(), static_cast<int>(strlen(call4.c_str())), &stmt4,
                                nullptr);
        if(rc != SQLITE_DONE && rc != SQLITE_OK)
        {
            sqlite3_close(outdatabase);
            sqlite3_close(database);
            throw SpeciesException(
                    "ERROR_SQL_020: FATAL. Could not detect METACOMMUNITY_PARAMETERS table. Error code: " +
                    to_string(rc));
        }
        rc = sqlite3_step(stmt4);
        while(rc == SQLITE_ROW)
        {
            past_metacommunities.pushBack(static_cast<unsigned long>(sqlite3_column_int(stmt4, 0)),
                                          sqlite3_column_double(stmt4, 1),
                                          static_cast<unsigned long>(sqlite3_column_int(stmt4, 2)));
            rc = sqlite3_step(stmt4);
        }
        if(rc != SQLITE_OK && rc != SQLITE_DONE)
        {
            stringstream ss;
            ss << "ERROR_SQL_020: FATAL. Could not read metacommunity parameters." << endl;
            ss << "Code: " << rc << endl << "Errmsg: ";
            ss << sqlite3_errmsg(database) << endl;
            sqlite3_clear_bindings(stmt4);
            sqlite3_reset(stmt4);
            throw SpeciesException(ss.str());
        }
        sqlite3_step(stmt4);
        sqlite3_finalize(stmt4);
    }
}

void Community::addCalculationPerformed(long double speciation_rate, double time, bool fragments,
                                       unsigned long metacommunity_size, long double metacommunity_speciation_rate)
{
    auto meta_reference = past_metacommunities.getReference(metacommunity_speciation_rate,
                                                            metacommunity_size);
    if(meta_reference == 0 && metacommunity_size != 0)
    {
        meta_reference = past_metacommunities.addNew(metacommunity_speciation_rate, metacommunity_size);
    }
    else
    {
        meta_reference = 0;
    }
    current_community_parameters = &past_communities.addNew(speciation_rate, time, fragments, meta_reference);
#ifdef DEBUG
    for(auto &i : past_communities.calc_array)
    {
        if(doubleCompare(i.time, current_community_parameters\->time, 0.00001) &&
            doubleCompare(i.speciation_rate, current_community_parameters\->speciation_rate,
                          i.speciation_rate*0.00001) &&
                i.metacommunity_reference == current_community_parameters\->metacommunity_reference &&
                i.reference != current_community_parameters\->reference)
        {
            throw FatalException("Communities are identical, but references differ! Please report this bug.");
        }
    }
#endif // DEBUG
}

vector<unsigned long> Community::getUniqueCommunityRefs()
{
    vector<unsigned long> unique_community_refs;
    // Read the community parameters and store them in the relevant objects
    sqlite3_stmt *stmt1;
    string call1 = "select count(type) from sqlite_master where type=\(aqtable\(aq and name=\(aqCOMMUNITY_PARAMETERS\(aq";
    int rc = sqlite3_prepare_v2(database, call1.c_str(), static_cast<int>(strlen(call1.c_str())), &stmt1, nullptr);
    if(rc != SQLITE_DONE && rc != SQLITE_OK)
    {
        sqlite3_close(outdatabase);
        sqlite3_close(database);
        throw SpeciesException("ERROR_SQL_020: FATAL. Could not check for COMMUNITY_PARAMETERS table. Error code: " +
                               to_string(rc));
        //              exit(EXIT_FAILURE);
    }
    sqlite3_step(stmt1);
    auto has_community_parameters = static_cast<bool>(sqlite3_column_int(stmt1, 0));
    sqlite3_step(stmt1);
    sqlite3_finalize(stmt1);
    // Read the speciation rates from the community_parameters table
    if(has_community_parameters)
    {
        sqlite3_stmt *stmt2;
        string call2 = "SELECT DISTINCT(reference) FROM COMMUNITY_PARAMETERS";
        rc = sqlite3_prepare_v2(database, call2.c_str(), static_cast<int>(strlen(call2.c_str())), &stmt2,
                                nullptr);
        if(rc != SQLITE_DONE && rc != SQLITE_OK)
        {
            sqlite3_close(outdatabase);
            sqlite3_close(database);
            throw SpeciesException("ERROR_SQL_020: FATAL. Could not detect COMMUNITY_PARAMETERS table. Error code: " +
                                   to_string(rc));
        }
        rc = sqlite3_step(stmt2);
        while(rc != SQLITE_DONE)
        {
            unique_community_refs.push_back(static_cast<unsigned long>(sqlite3_column_int(stmt2, 0)));
            rc = sqlite3_step(stmt2);
            if(rc > 10000)
            {
                throw SpeciesException("ERROR_SQL_020: FATAL. Could not read speciation rates.");
            }
        }
        sqlite3_step(stmt2);
        sqlite3_finalize(stmt2);
    }
    return unique_community_refs;
}

vector<unsigned long> Community::getUniqueMetacommunityRefs()
{
    vector<unsigned long> unique_metacommunity_refs;
    // Read the community parameters and store them in the relevant objects
    sqlite3_stmt *stmt1;
    string call1 = "select count(type) from sqlite_master where type=\(aqtable\(aq and name=\(aqMETACOMMUNITY_PARAMETERS\(aq";
    int rc = sqlite3_prepare_v2(database, call1.c_str(), static_cast<int>(strlen(call1.c_str())), &stmt1, nullptr);
    if(rc != SQLITE_DONE && rc != SQLITE_OK)
    {
        sqlite3_close(outdatabase);
        sqlite3_close(database);
        throw SpeciesException(
                "ERROR_SQL_020: FATAL. Could not check for METACOMMUNITY_PARAMETERS table. Error code: " +
                to_string(rc));
    }
    sqlite3_step(stmt1);
    auto has_metacommunity_parameters = static_cast<bool>(sqlite3_column_int(stmt1, 0));
    sqlite3_step(stmt1);
    sqlite3_finalize(stmt1);
    // Read the speciation rates from the community_parameters table
    if(has_metacommunity_parameters)
    {
        sqlite3_stmt *stmt2;
        string call2 = "SELECT DISTINCT(reference) FROM METACOMMUNITY_PARAMETERS";
        rc = sqlite3_prepare_v2(database, call2.c_str(), static_cast<int>(strlen(call2.c_str())), &stmt2,
                                nullptr);
        if(rc != SQLITE_DONE && rc != SQLITE_OK)
        {
            sqlite3_close(outdatabase);
            sqlite3_close(database);
            throw SpeciesException(
                    "ERROR_SQL_020: FATAL. Could not detect METACOMMUNITY_PARAMETERS table. Error code: " +
                    to_string(rc));
        }
        rc = sqlite3_step(stmt2);
        while(rc != SQLITE_DONE)
        {
            unique_metacommunity_refs.push_back(static_cast<unsigned long>(sqlite3_column_int(stmt2, 0)));
            rc = sqlite3_step(stmt2);
            if(rc > 10000)
            {
                throw SpeciesException("ERROR_SQL_020: FATAL. Could not read speciation rates.");
            }
        }
        sqlite3_step(stmt2);
        sqlite3_finalize(stmt2);
    }
    return unique_metacommunity_refs;
}

void Community::writeNewCommunityParameters()
{
    // Find new community parameters to add
    auto unique_community_refs = getUniqueCommunityRefs();
    CommunitiesArray communities_to_write;
    for(auto &community_param : past_communities.calc_array)
    {
        if(find(unique_community_refs.begin(),
                unique_community_refs.end(), community_param.reference) == unique_community_refs.end())
        {
            communities_to_write.pushBack(community_param);
            unique_community_refs.push_back(community_param.reference);
        }
    }
    if(!communities_to_write.calc_array.empty())
    {
        // Create the table if it doesn\(aqt exist
        string table_command = "CREATE TABLE IF NOT EXISTS COMMUNITY_PARAMETERS (reference INT PRIMARY KEY NOT NULL,"
                " speciation_rate DOUBLE NOT NULL, time DOUBLE NOT NULL, fragments INT NOT NULL, "
                "metacommunity_reference INT);";
        sqlite3_exec(database, table_command.c_str(), nullptr, nullptr, nullptr);
        sqlite3_stmt *stmt;
        table_command = "INSERT INTO COMMUNITY_PARAMETERS (reference, speciation_rate, time, fragments,"
                " metacommunity_reference) VALUES (?,?,?,?,?);";
        sqlite3_prepare_v2(database, table_command.c_str(), static_cast<int>(strlen(table_command.c_str())), &stmt,
                           nullptr);
        // Then add the required elements
        sqlite3_exec(database, "BEGIN TRANSACTION;", nullptr, nullptr, nullptr);
        for(auto &item : communities_to_write.calc_array)
        {
            if(item.reference == 0)
            {
                continue;
            }
            sqlite3_bind_int(stmt, 1, static_cast<int>(item.reference));
            sqlite3_bind_double(stmt, 2, static_cast<double>(item.speciation_rate));
            sqlite3_bind_double(stmt, 3, static_cast<double>(item.time));
            sqlite3_bind_int(stmt, 4, static_cast<int>(item.fragment));
            sqlite3_bind_int(stmt, 5, static_cast<int>(item.metacommunity_reference));
            time_t start_check, end_check;
            time(&start_check);
            time(&end_check);
            int step = sqlite3_step(stmt);
            while(step != SQLITE_DONE && (end_check \- start_check) < 10 && step != SQLITE_OK)
            {
                step = sqlite3_step(stmt);
                time(&end_check);
            }
            if(step != SQLITE_DONE)
            {
                stringstream ss;
                ss << "SQLITE error code: " << step << endl;
                ss << sqlite3_errmsg(database) << endl;
                ss << "ERROR_SQL_004a: Could not insert into database. Check destination file has not "
                        "been moved or deleted and that an entry doesn\(aqt already exist with the same ID."
                   << endl;
                sqlite3_clear_bindings(stmt);
                sqlite3_reset(stmt);
                writeWarning(ss.str());
                break;
            }
            sqlite3_clear_bindings(stmt);
            sqlite3_reset(stmt);
        }
        int rc1 = sqlite3_exec(database, "END TRANSACTION;", nullptr, nullptr, nullptr);
        // Need to finalise the statement
        int rc2 = sqlite3_finalize(stmt);
        if(rc1 != SQLITE_OK || rc2 != SQLITE_OK)
        {
            stringstream ss;
            ss << "ERROR_SQL_013: Could not complete SQL transaction. Check memory database assignment and SQL "
                    "commands. Please report this bug." << endl;
            writeWarning(ss.str());
        }
    }
}

void Community::writeNewMetacommuntyParameters()
{
    auto unique_metacommunity_refs = getUniqueMetacommunityRefs();
    MetacommunitiesArray metacommunities_to_write;
    if(unique_metacommunity_refs.empty())
    {
        for(auto &community_param : past_metacommunities.calc_array)
        {
            metacommunities_to_write.pushBack(community_param);
        }
    }
    else
    {
        for(auto &community_param : past_metacommunities.calc_array)
        {
            if(find(unique_metacommunity_refs.begin(),
                    unique_metacommunity_refs.end(), community_param.reference) == unique_metacommunity_refs.end())
            {
                metacommunities_to_write.pushBack(community_param);
                unique_metacommunity_refs.push_back(community_param.reference);
            }
        }
    }
    if(!metacommunities_to_write.calc_array.empty())
    {
        // Create the table if it doesn\(aqt exist
        string table_command = "CREATE TABLE IF NOT EXISTS METACOMMUNITY_PARAMETERS (reference INT PRIMARY KEY NOT NULL,"
                " speciation_rate DOUBLE NOT NULL, metacommunity_size DOUBLE NOT NULL);";
        sqlite3_exec(database, table_command.c_str(), nullptr, nullptr, nullptr);
        sqlite3_stmt *stmt;
        table_command = "INSERT INTO METACOMMUNITY_PARAMETERS (reference, speciation_rate, metacommunity_size"
                ") VALUES (?,?,?);";
        sqlite3_prepare_v2(database, table_command.c_str(), static_cast<int>(strlen(table_command.c_str())), &stmt,
                           nullptr);
        // Then add the required elements
        sqlite3_exec(database, "BEGIN TRANSACTION;", nullptr, nullptr, nullptr);
        for(auto &item : metacommunities_to_write.calc_array)
        {
            if(item.reference == 0)
            {
                continue;
            }
            sqlite3_bind_int(stmt, 1, static_cast<int>(item.reference));
            sqlite3_bind_double(stmt, 2, static_cast<double>(item.speciation_rate));
            sqlite3_bind_int(stmt, 3, static_cast<int>(item.metacommunity_size));
            time_t start_check, end_check;
            time(&start_check);
            time(&end_check);
            int step = sqlite3_step(stmt);
            while(step != SQLITE_DONE && (end_check \- start_check) < 10 && step != SQLITE_OK)
            {
                step = sqlite3_step(stmt);
                time(&end_check);
            }
            if(step != SQLITE_DONE)
            {
#ifdef DEBUG
                stringstream ss;
                ss << "SQLITE error code: " << step << endl;
                ss << "Metacommunity reference: " << item.reference << endl;
                ss << "Speciation rate: " << item.speciation_rate << ", metacommunity size: " << item.metacommunity_size << endl;
                ss << sqlite3_errmsg(database) << endl;
                writeLog(10, ss);
#endif // DEBUG
                throw SpeciesException("ERROR_SQL_004b: Could not insert into database. Check destination file has not "
                                               "been moved or deleted and that an entry doesn\(aqt already exist with the"
                                               " same ID.");
            }
            sqlite3_clear_bindings(stmt);
            sqlite3_reset(stmt);
        }
        int rc1 = sqlite3_exec(database, "END TRANSACTION;", nullptr, nullptr, nullptr);
        // Need to finalise the statement
        int rc2 = sqlite3_finalize(stmt);
        if(rc1 != SQLITE_OK || rc2 != SQLITE_OK)
        {
            stringstream ss;
            ss << "ERROR_SQL_013: Could not complete SQL transaction. Check memory database assignment and SQL "
                    "commands. Please report this bug." << endl;
            ss << sqlite3_errmsg(database) << endl;
            writeWarning(ss.str());
        }
    }
}

void Community::updateCommunityParameters()
{
    for(auto parameter : past_communities.calc_array)
    {
        if(parameter.updated)
        {
            if(!bSqlConnection)
            {
                throw FatalException("Attempted to update sql database without opening database connection.");
            }

            // Now find out the max size of the list, so we have a count to work from
            string count_command = "UPDATE COMMUNITY_PARAMETERS SET fragments = 1 WHERE reference = ";
            count_command += to_string(parameter.reference) + ";";
            int rc = sqlite3_exec(database, count_command.c_str(), nullptr, nullptr, nullptr);
            // Need to finalise the statement
            if(rc != SQLITE_OK && rc != SQLITE_DONE)
            {
                stringstream ss;
                ss << "ERROR_SQL_013: Could not update sql database. Check file write access. ";
                ss << "Otherwise, please report this bug." << endl;
                ss << sqlite3_errmsg(database) << endl;
                writeWarning(ss.str());
            }
        }
    }
}


void Community::writeSpeciationRates()
{
    stringstream os;
    os << "***************************" << endl;
    os << "STARTING CALCULATIONS" << endl;
    os << "Input file is " << spec_sim_parameters\->filename << endl;
    sort(spec_sim_parameters\->all_speciation_rates.begin(), spec_sim_parameters\->all_speciation_rates.end());
    if(!spec_sim_parameters\->bMultiRun)
    {
        os << "Speciation rate is " << spec_sim_parameters\->all_speciation_rates[0] << endl;
    }
    else
    {
        os << "Speciation rates are: " << flush;
        for(unsigned int i = 0; i < spec_sim_parameters\->all_speciation_rates.size(); i++)
        {
            os << spec_sim_parameters\->all_speciation_rates[i] << flush;
            if(i + 1 == spec_sim_parameters\->all_speciation_rates.size())
            {
                os << "." << endl;
            }
            else
            {
                os << ", " << flush;
            }
        }
    }
    writeInfo(os.str());
}

void Community::calculateTree()
{
    stringstream os;
    for(auto sr : spec_sim_parameters\->all_speciation_rates)
    {
        os << "Calculating speciation rate " << sr << endl;
        writeInfo(os.str());
        os.str("");
        for(auto time : spec_sim_parameters\->all_times)
        {
            os.str("");
            os << "Calculating generation " << time << "\en";
            writeInfo(os.str());
            resetTree();
            if(!checkCalculationsPerformed(sr, time, spec_sim_parameters\->use_fragments,
                                           spec_sim_parameters\->metacommunity_size,
                                           spec_sim_parameters\->metacommunity_speciation_rate))
            {
                addCalculationPerformed(sr, time, spec_sim_parameters\->use_fragments,
                                        spec_sim_parameters\->metacommunity_size,
                                        spec_sim_parameters\->metacommunity_speciation_rate);
                createDatabase();
                if(spec_sim_parameters\->use_spatial)
                {
                    recordSpatial();
                }
                if(spec_sim_parameters\->use_fragments)
                {
                    applyFragments();
                }
            }
            else
            {
                os.str("");
                os << "calculation already performed for " << sr << " at time " << time << endl;
                writeInfo(os.str());
            }
        }
    }
}

void Community::output()
{
    writeNewCommunityParameters();
    writeNewMetacommuntyParameters();
    updateCommunityParameters();
    exportDatabase();
}

void Community::printEndTimes(time_t tStart, time_t tEnd)
{
    time(&tEnd);
    stringstream os;
    os << "Calculations complete." << endl;
    os << "Time taken was " << floor((tEnd \- tStart) / 3600) << " hours "
       << (floor((tEnd \- tStart) / 60) \- 60 * floor((tEnd \- tStart) / 3600)) << " minutes " << (tEnd \- tStart) % 60
       << " seconds" << endl;
    writeInfo(os.str());
}

void Community::apply(SpecSimParameters *sp)
{
    time_t tStart{};
    time_t tEnd{};
    // Start the clock
    time(&tStart);
    // First print the variables
    doApplication(sp);
    output();
    printEndTimes(tStart, tEnd);
}

void Community::doApplication(SpecSimParameters *sp)
{
    Row<TreeNode> data;
    doApplication(sp, &data);
}

void Community::doApplication(SpecSimParameters *sp, Row<TreeNode> *data)
{
    spec_sim_parameters = sp;
    writeSpeciationRates();
    // Set up the objects
    setList(data);
    importSimParameters(sp\->filename);
    setProtractedParameters(sp\->min_speciation_gen, sp\->max_speciation_gen);
    importSamplemask(sp\->samplemask);
    importData(sp\->filename);
    getPreviousCalcs();
    if(sp\->use_fragments)
    {
        calcFragments(sp\->fragment_config_file);
    }
    calculateTree();
}

void Community::doApplicationInternal(SpecSimParameters *sp, Row<TreeNode> *data)
{
    setInternalDatabase();
    doApplication(sp, data);

}
.ft P
.fi
.UNINDENT
.UNINDENT
.SS Detailed Description
.sp
Samuel Thompson
BSD\-3 Licence.
.SS Includes
.INDENT 0.0
.IP \(bu 2
\fBCommunity.h\fP (file_necsim_Community.h)
.IP \(bu 2
\fBFilesystem.h\fP (file_necsim_Filesystem.h)
.IP \(bu 2
\fBalgorithm\fP
.IP \(bu 2
\fBset\fP
.IP \(bu 2
\fBunordered_map\fP
.UNINDENT
.SS Functions
.INDENT 0.0
.IP \(bu 2
function_checkSpeciation
.IP \(bu 2
function_doubleCompare
.IP \(bu 2
function_doubleCompare
.IP \(bu 2
function_doubleCompare
.UNINDENT
.SS File Community.h
.sp
Contains the class_Community object, which is used for reconstructing the coalescence tree after simulations are complete.
.SS Contents
.INDENT 0.0
.IP \(bu 2
\fI\%Definition (necsim/Community.h)\fP
.IP \(bu 2
\fI\%Detailed Description\fP
.IP \(bu 2
\fI\%Includes\fP
.IP \(bu 2
\fI\%Included By\fP
.IP \(bu 2
\fI\%Classes\fP
.IP \(bu 2
\fI\%Functions\fP
.UNINDENT
.SS Definition (\fBnecsim/Community.h\fP)
.SS Program Listing for File Community.h
.INDENT 0.0
.IP \(bu 2
Return to documentation for file_necsim_Community.h
.UNINDENT
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
//This file is part of NECSim project which is released under BSD\-3 license.
//See file **LICENSE.txt** or visit https://opensource.org/licenses/BSD\-3\-Clause) for full license details.
#ifndef TREELIST
#define TREELIST

#include <cmath>
#include <sqlite3.h>
#include <cstring>
#include <cmath>
#include <stdexcept>
#include <string>
# include <boost/filesystem.hpp>
#include <boost/lexical_cast.hpp>
#include <set>

#include "TreeNode.h"
#include "Matrix.h"
#include "DataMask.h"
#include "SpecSimParameters.h"

using namespace std;
using std::string;

bool checkSpeciation(const long double &random_number, const long double &speciation_rate,
                     const unsigned long &no_generations);

bool doubleCompare(double d1, double d2, double epsilon);

bool doubleCompare(long double d1, long double d2, long double epsilon);

bool doubleCompare(long double d1, long double d2, double epsilon);

struct CommunityParameters
{
    unsigned long reference;
    long double speciation_rate;
    long double time;
    bool fragment;
    unsigned long metacommunity_reference; // will be 0 if no metacommunity used.
    bool updated; // set to true if the fragment reference needs updating in the database

    CommunityParameters()
    {
        reference = 0;
        speciation_rate = 0.0;
        time = 0.0;
        fragment = false;
        metacommunity_reference = 0;
        updated = false;
    }

    CommunityParameters(unsigned long reference_in, long double speciation_rate_in, long double time_in,
                        bool fragment_in, unsigned long metacommunity_reference_in);

    void setup(unsigned long reference_in, long double speciation_rate_in, long double time_in,
               bool fragment_in, unsigned long metacommunity_reference_in);

    bool compare(long double speciation_rate_in, long double time_in, bool fragment_in,
                 unsigned long metacommunity_reference_in);

    bool compare(long double speciation_rate_in, long double time_in, unsigned long metacommunity_reference_in);

    bool compare(unsigned long reference_in);
};

struct CommunitiesArray
{
    vector<CommunityParameters> calc_array;

    void pushBack(unsigned long reference, long double speciation_rate, long double time, bool fragment,
                  unsigned long metacommunity_reference);

    void pushBack(CommunityParameters tmp_param);

    CommunityParameters &addNew(long double speciation_rate, long double time, bool fragment,
                                unsigned long metacommunity_reference);

    bool hasPair(long double speciation_rate, double time, bool fragment, unsigned long metacommunity_reference);

};

struct MetacommunityParameters
{
    unsigned long reference;
    unsigned long metacommunity_size;
    long double speciation_rate;

    MetacommunityParameters(unsigned long reference_in, long double speciation_rate_in,
                            unsigned long metacommunity_size_in);

    bool compare(long double speciation_rate_in, unsigned long metacommunity_size_in);

    bool compare(unsigned long reference_in);
};

struct MetacommunitiesArray
{
    vector<MetacommunityParameters> calc_array;

    void pushBack(unsigned long reference, long double speciation_rate, unsigned long metacommunity_size);

    void pushBack(MetacommunityParameters tmp_param);

    unsigned long addNew(long double speciation_rate, unsigned long metacommunity_size);

    bool hasPair(long double speciation_rate, unsigned long metacommunity_size);

    bool hasPair(unsigned long reference);

    unsigned long getReference(long double speciation_rate, unsigned long metacommunity_size);
};


struct Fragment
{
    // the name for the fragment (for reference purposes)
    string name;
    // coordinates for the extremes of the site
    long x_east, x_west, y_north, y_south;
    // the number of lineages in the fragment.
    unsigned long num;
    double area;
};


class Samplematrix : public DataMask
{
private:
    bool bIsNull;
    bool bIsFragment;
    Fragment fragment;
public:
    Samplematrix();

//  /**
//   * @brief Returns the value at the x,y position.
//   * This is used for testing purposes only.
//   * @param xval the x coordinate.
//   * @param yval the y coordinate
//   * @param xwrap the x wrapping
//   * @param ywrap the y wrapping
//   * @return the value at x,y.
//   */
    bool getTestVal(unsigned long xval, unsigned long yval, long xwrap, long ywrap);

    bool getMaskVal(unsigned long x1, unsigned long y1, long x_wrap, long y_wrap);

    void setFragment(Fragment &fragment_in);

    void removeFragment();
};

class Community
{
protected:
    bool bMem; // boolean for whether the database is in memory or not.
    bool bFileSet; // boolean for whether the database has been set already.
    sqlite3 *database; // stores the in\-memory database connection.
    sqlite3 *outdatabase; // stores the file database connection
    bool bSqlConnection; // true if the data connection has been established.
    Row<TreeNode> *nodes; // in older versions this was called list. Changed to avoid confusion with the built\-in class.
    Row<unsigned long> row_out;
    unsigned long iSpecies;
    bool bSample; // checks whether the samplemask has already been imported.
    bool bDataImport; // checks whether the main sim data has been imported.
    Samplematrix samplemask; // the samplemask object for defining the areas we want to sample from.
    vector<Fragment> fragments; // a vector of fragments for storing each fragment\(aqs coordinates.
    CommunityParameters *current_community_parameters;
    // the minimum speciation rate the original simulation was run with (this is read from the database SIMULATION_PARAMETERS table)
    long double min_spec_rate;
    // The dimensions of the sample grid size.
    unsigned long grid_x_size, grid_y_size;
    // The dimensions of the original sample map file
    unsigned long samplemask_x_size, samplemask_y_size, samplemask_x_offset, samplemask_y_offset;
    // Vector containing past speciation rates
    CommunitiesArray past_communities;
    MetacommunitiesArray past_metacommunities;
    // Protracted speciation parameters
    bool protracted;
    double min_speciation_gen, max_speciation_gen, applied_min_speciation_gen, applied_max_speciation_gen;
    unsigned long max_species_id, max_fragment_id, max_locations_id;
    // Does not need to be stored during simulation pause
    SpecSimParameters *spec_sim_parameters;
public:

    Community(Row<TreeNode> *r) : nodes(r)
    {
        bMem = false;
        iSpecies = 0;
        bSample = false;
        bSqlConnection = false;
        bFileSet = false;
        bDataImport = false;
        min_speciation_gen = 0.0;
        max_speciation_gen = 0.0;
        applied_max_speciation_gen = 0.0;
        protracted = false;
        current_community_parameters = nullptr;
        max_species_id = 0;
        max_locations_id = 0;

    }

    Community()
    {
        bMem = false;
        iSpecies = 0;
        bSample = false;
        bSqlConnection = false;
        bFileSet = false;
        bDataImport = false;
        min_speciation_gen = 0.0;
        max_speciation_gen = 0.0;
        applied_max_speciation_gen = 0.0;
        protracted = false;
        current_community_parameters = nullptr;
        max_species_id = 0;
        max_locations_id = 0;
    }

    ~Community()
    {
        nodes = nullptr;
    }

    void setList(Row<TreeNode> *l);

    void setDatabase(sqlite3 *dbin);

    bool hasImportedData();

    long double getMinimumSpeciation();

    void importSamplemask(string sSamplemask);

    unsigned long countSpecies();

    unsigned long calcSpecies();

    virtual void addSpecies(unsigned long &species_count, TreeNode *treenode, set<unsigned long> &species_list);

    void calcSpeciesAbundance();

    virtual void resetTree();

    void detectDimensions(string db);

    void openSqlConnection(string inputfile);
    void setInternalDatabase();

    void internalOption();

    void importData(string inputfile);

    void importSimParameters(string file);

    void getMaxSpeciesAbundancesID();

    Row<unsigned long> * getCumulativeAbundances();

    Row<unsigned long> getRowOut();

    unsigned long getSpeciesNumber();

    void getMaxFragmentAbundancesID();

    void getMaxSpeciesLocationsID();

    void setProtractedParameters(double max_speciation_gen_in);

    void setProtractedParameters(const double &max_speciation_gen_in, const double &mix_speciation_gen_in);

    void overrideProtractedParameters(const double &min_speciation_gen_in, const double &max_speciation_gen_in);

    void setProtracted(bool protracted_in);

    void createDatabase();

    void generateCoalescenceTree();

    void outputSpeciesAbundances();

    bool checkCalculationsPerformed(long double speciation_rate, double time, bool fragments,
                                    unsigned long metacommunity_size, long double metacommunity_speciation_rate);

    void addCalculationPerformed(long double speciation_rate, double time, bool fragments,
                                 unsigned long metacommunity_size, long double metacommunity_speciation_rate);

    void createFragmentDatabase(const Fragment &f);

    void exportDatabase();

    bool checkSpeciesLocationsReference();

    bool checkSpeciesAbundancesReference();

    void recordSpatial();

    void calcFragments(string fragment_file);

    void applyFragments();

    void getPreviousCalcs();

    vector<unsigned long> getUniqueCommunityRefs();

    vector<unsigned long> getUniqueMetacommunityRefs();

    void writeNewCommunityParameters();

    void writeNewMetacommuntyParameters();


    void updateCommunityParameters();

    void writeSpeciationRates();

    void calculateTree();

    void output();

    void printEndTimes(time_t tStart, time_t tEnd);

    virtual void apply(SpecSimParameters *sp);

    void doApplication(SpecSimParameters *sp);

    void doApplication(SpecSimParameters *sp, Row<TreeNode> *data);

    void doApplicationInternal(SpecSimParameters *sp, Row<TreeNode> *data);

};

#endif
.ft P
.fi
.UNINDENT
.UNINDENT
.SS Detailed Description
.sp
Samuel Thompson
31/08/16
BSD\-3 Licence.
.SS Includes
.INDENT 0.0
.IP \(bu 2
\fBDataMask.h\fP (file_necsim_DataMask.h)
.IP \(bu 2
\fBMatrix.h\fP (file_necsim_Matrix.h)
.IP \(bu 2
\fBSpecSimParameters.h\fP (file_necsim_SpecSimParameters.h)
.IP \(bu 2
\fBTreeNode.h\fP (file_necsim_TreeNode.h)
.IP \(bu 2
\fBboost/filesystem.hpp\fP
.IP \(bu 2
\fBboost/lexical_cast.hpp\fP
.IP \(bu 2
\fBcmath\fP
.IP \(bu 2
\fBcstring\fP
.IP \(bu 2
\fBset\fP
.IP \(bu 2
\fBsqlite3.h\fP
.IP \(bu 2
\fBstdexcept\fP
.IP \(bu 2
\fBstring\fP
.UNINDENT
.SS Included By
.INDENT 0.0
.IP \(bu 2
file_necsim_Community.cpp
.IP \(bu 2
file_necsim_Tree.h
.IP \(bu 2
file_necsim_SpatialTree.h
.IP \(bu 2
file_necsim_Metacommunity.h
.IP \(bu 2
file_necsim_SimulateDispersal.cpp
.IP \(bu 2
file_necsim_SpeciationCommands.h
.UNINDENT
.SS Classes
.INDENT 0.0
.IP \(bu 2
struct_CommunityParameters
.IP \(bu 2
struct_Fragment
.IP \(bu 2
struct_MetacommunitiesArray
.IP \(bu 2
struct_MetacommunityParameters
.IP \(bu 2
class_CommunitiesArray
.IP \(bu 2
class_Community
.IP \(bu 2
class_Samplematrix
.UNINDENT
.SS Functions
.INDENT 0.0
.IP \(bu 2
function_checkSpeciation
.IP \(bu 2
function_doubleCompare
.IP \(bu 2
function_doubleCompare
.IP \(bu 2
function_doubleCompare
.UNINDENT
.SS File ConfigFileParser.cpp
.sp
Contains implementation of the file_necsim_ConfigFileParser.h functions.
.SS Contents
.INDENT 0.0
.IP \(bu 2
\fI\%Definition (necsim/ConfigFileParser.cpp)\fP
.IP \(bu 2
\fI\%Detailed Description\fP
.IP \(bu 2
\fI\%Includes\fP
.IP \(bu 2
\fI\%Functions\fP
.UNINDENT
.SS Definition (\fBnecsim/ConfigFileParser.cpp\fP)
.SS Program Listing for File ConfigFileParser.cpp
.INDENT 0.0
.IP \(bu 2
Return to documentation for file_necsim_ConfigFileParser.cpp
.UNINDENT
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
//This file is part of NECSim project which is released under BSD\-3 license.
//See file **LICENSE.txt** or visit https://opensource.org/licenses/BSD\-3\-Clause) for full license details.
//
#include "ConfigFileParser.h"
#include "CustomExceptions.h"
#include "Logging.h"

void importArgs(const unsigned int &argc, char *argv[], vector<string> &comargs)
{
    for(unsigned int i = 0; i < argc; i++)
    {
        comargs.emplace_back(argv[i]);
    }
    // check size is correct
    if(comargs.size() != argc)
    {
        cerr << "ERROR_MAIN_010: Incorrect command line parsing." << endl;
    }
}

string SectionOption::getOption(string refval)
{
    for(unsigned int i = 0; i < refs.size(); i++)
    {
        if(refs[i] == refval)
        {
            return (val[i]);
        }
    }
#ifdef DEBUG
    stringstream ss;
        ss << "Reference " << refval << " not found in keyoption." << endl;
    writeInfo(ss.str());
#endif
    return ("null");
}

ostream &operator<<(ostream &os, const SectionOption &k)
{
    os << k.section << "\en" << k.val.size() << "\en" << k.refs.size() << "\en";
    for(const auto &i : k.val)
    {
        os << i << "\en";
    }
    for(const auto &ref : k.refs)
    {
        os << ref << "\en";
    }
    return os;
}

istream &operator>>(istream &is, SectionOption &k)
{
    // os << m.numRows<<" , "<<m.numCols<<" , "<<endl;
    unsigned int valsize, refsize;
    is >> k.section >> valsize >> refsize;
    is.ignore();
    string tmp;
    for(unsigned int i = 0; i < valsize; i++)
    {
        getline(is, tmp);
        k.val.push_back(tmp);
    }
    for(unsigned int i = 0; i < refsize; i++)
    {
        getline(is, tmp);
        k.refs.push_back(tmp);
    }
    return is;
}

void ConfigOption::setConfig(const string &file, bool main, bool full_parse)
{
    if(!bConfig)
    {
        bMain = main;
        configfile = file;
        bConfig = true;
        bFullParse = full_parse;
    }
    else
    {
        throw ConfigException("Attempt to set config file twice.");
    }
}

void ConfigOption::parseConfig()
{
    ifstream is_file;
    try
    {
        is_file.open(configfile);
    }
    catch(...)
    {
        throw ConfigException(
                "ERROR_CONF_004c: Could not open the config file. Check file exists and is readable.");
    }
    if(!is_file.fail() || !is_file.good())
    {
        string line;
        // Get the first line of the file.
        while(getline(is_file, line))
        {
//              os << line << endl;
            istringstream is_line(line);
            string key;
            string val;
            // Skip all whitespace
            is_line >> skipws;
            // start a new section
            if(line[0] == \(aq[\(aq)
            {
                SectionOption tempSections;
                // get the section name
                string section;
                if(getline(is_line, section, \(aq]\(aq))
                {
                    section = section.erase(0, 1);
                    tempSections.section = section;
//                      os << section << endl;
                }
                // read each line
                while(getline(is_file, line))
                {
                    // end the section when a new one starts.
                    if(line[0] == \(aq[\(aq || line.size() == 0)
                    {
                        break;
                    }
                    istringstream is_line2(line); // update the input\-line stream
                    if(getline(is_line2, key, \(aq=\(aq))
                    {

                        key.erase(std::remove(key.begin(), key.end(), \(aq \(aq), key.end());
                        is_line2 >> skipws;
                    }
                    if(!is_line2)
                    {
//                          os << is_line2 << endl;
                        throw ConfigException("ERROR_CONF_001: Read error in config file.");
                    }
                    if(getline(is_line2, val))
                    {
//                          This line has been removed to allow for white spaces in file names and paths
//                          val.erase(std::remove(val.begin(), val.end(), \(aq \(aq), val.end());
                        while(val[0] == \(aq \(aq)
                        {
                            val.erase(val.begin(), val.begin() + 1);
                        }

                    }
                    if(!is_line2)
                    {
                        throw ConfigException("ERROR_CONF_001: Read error in config file.");
                    }
                    tempSections.refs.push_back(key);
                    tempSections.val.push_back(val);
                }
                configs.push_back(tempSections);
            }
        }
    }
    else
    {
        throw ConfigException(
                "ERROR_CONF_004b: Could not open the config file " + configfile +
                ". Check file exists and is readable.");
    }
    if(is_file.eof())
    {
        is_file.close();
    }
    else
    {
        throw ConfigException("ERROR_CONF_002: End of file not reached. Check input file formating.");
    }
}

vector<SectionOption> ConfigOption::getSectionOptions()
{
    return configs;
}

void ConfigOption::setSectionOption(string section, string reference, string value)
{
    SectionOption *section_option = nullptr;
    for(auto &option : configs)
    {
        if(option.section == section)
        {
            section_option = &option;
            break;
        }
    }
    if(!section_option)
    {
        SectionOption tmp;
        tmp.section = section;
        configs.emplace_back(tmp);
        section_option = &configs.back();
    }
    section_option\->refs.emplace_back(reference);
    section_option\->val.emplace_back(value);
}

SectionOption ConfigOption::operator[](int index)
{
    return configs[index];
}

unsigned int ConfigOption::getSectionOptionsSize()
{
    return configs.size();
}

vector<string> ConfigOption::getSections()
{
    vector<string> toret;
    for(auto &config : configs)
    {
        toret.push_back(config.section);
    }
    return toret;
}

bool ConfigOption::hasSection(const string &sec)
{
    for(auto &config : configs)
    {
        if(config.section == sec)
        {
            return (true);
        }
    }
    return false;
}

vector<string> ConfigOption::getSectionValues(string sec)
{
    for(auto &config : configs)
    {
        if(config.section == sec)
        {
            return (config.val);
        }
    }
    throw ConfigException("Section not found in config file: " + sec);
}

string ConfigOption::getSectionOptions(string section, string ref)
{
    for(auto &config : configs)
    {
        if(config.section == section)
        {
            for(unsigned int j = 0; j < config.refs.size(); j++)
            {
                if(config.refs[j] == ref)
                {
                    return (config.val[j]);
                }
            }
        }
    }
#ifdef DEBUG
    writeWarning("No reference found for " + section + ", ");
#endif
    return "null";
}

string ConfigOption::getSectionOptions(string section, string ref, string def)
{
    for(auto &config : configs)
    {
        if(config.section == section)
        {
            for(unsigned int j = 0; j < config.refs.size(); j++)
            {
                if(config.refs[j] == ref)
                {
                    return (config.val[j]);
                }
            }
        }
    }
    return def;
}

int ConfigOption::importConfig(vector<string> &comargs)
{
    // Check that the previous arguments have already been imported.
    if(bMain)
    {
        if(comargs.size() != 3)
        {
            throw ConfigException(
                    "ERROR_CONF_003: Number of command line arguments not correct before importSpatialParameters.");
        }
    }
    ifstream is_file;
    try
    {
        is_file.open(configfile);
    }
    catch(...)
    {
        throw ConfigException(
                "ERROR_CONF_004a: Could not open the config file. Check file exists and is readable.");
    }
    if(!is_file.fail())
    {
        string line;
        while(getline(is_file, line))
        {
            istringstream is_line(line);
            string key;
            is_line >> skipws;
            if(line[0] == \(aq[\(aq)
            {
                continue;
            }
            if(getline(is_line, key, \(aq=\(aq))
            {
                // Could implement proper data parsing based on the key object.
                is_line >> skipws;
                string value;
                if(getline(is_line, value))
                {
                    value.erase(std::remove(value.begin(), value.end(), \(aq \(aq), value.end());
                    if(!is_line)
                    {
                        stringstream os;
                        os << value << endl;
                        writeWarning(os.str());
                        throw ConfigException("ERROR_CONF_001: Read error in config file.");
                    }
                    auto *tmp = new char[value.length() + 1];
                    strcpy(tmp, value.c_str());
                    comargs.emplace_back(tmp);
                }
            }
        }
    }
    else
    {
        throw ConfigException(
                "ERROR_CONF_004d: Could not open the config file. Check file exists and is readable.");
    }
    if(is_file.eof())
    {
        is_file.close();
    }
    else
    {
        throw ConfigException("ERROR_CONF_002: End of file not reached. Check input file formating.");
    }
    if(bMain)
    {
        // remove the file name from the command line arguments to maintain the vector format.
        comargs.erase(comargs.begin() + 2);
    }
    return comargs.size();
}

ostream &operator<<(ostream &os, const ConfigOption &c)
{
    os << c.configfile << "\en" << c.bConfig << "\en" << c.bMain << "\en" << c.bFullParse << "\en" << c.configs.size()
       << "\en";
    for(const auto &config : c.configs)
    {
        os << config;
    }
    return os;
}

istream &operator>>(istream &is, ConfigOption &c)
{
    unsigned int configsize;
    is.ignore();
    getline(is, c.configfile);
    is >> c.bConfig >> c.bMain >> c.bFullParse >> configsize;
    SectionOption tmpoption;
    if(configsize > 10000)
    {
        throw runtime_error("Config size extremely large, check file: " + to_string(configsize));
    }
    if(configsize > 0)
    {
        for(unsigned int i = 0; i < configsize; i++)
        {
            is >> tmpoption;
            c.configs.push_back(tmpoption);
        }
    }
//      os << "end config" << endl;
    return is;
}
.ft P
.fi
.UNINDENT
.UNINDENT
.SS Detailed Description
.sp
Sam Thompson
31/08/2016
Contact: \fI\%samuel.thompson14@imperial.ac.uk\fP or \fI\%thompsonsed@gmail.com\fP BSD\-3 Licence.
.SS Includes
.INDENT 0.0
.IP \(bu 2
\fBConfigFileParser.h\fP (file_necsim_ConfigFileParser.h)
.IP \(bu 2
\fBCustomExceptions.h\fP (file_necsim_CustomExceptions.h)
.IP \(bu 2
\fBLogging.h\fP (file_necsim_Logging.h)
.UNINDENT
.SS Functions
.INDENT 0.0
.IP \(bu 2
function_importArgs
.IP \(bu 2
function_operator_LT__LT
.IP \(bu 2
function_operator_LT__LT
.IP \(bu 2
function_operator_GT__GT
.IP \(bu 2
function_operator_GT__GT
.UNINDENT
.SS File ConfigFileParser.h
.sp
class_ConfigOption and struct_SectionOption classes for importing command line parameters from a config text file, originally designed for usage within coalescence simulations on a cluster.
.SS Contents
.INDENT 0.0
.IP \(bu 2
\fI\%Definition (necsim/ConfigFileParser.h)\fP
.IP \(bu 2
\fI\%Detailed Description\fP
.IP \(bu 2
\fI\%Includes\fP
.IP \(bu 2
\fI\%Included By\fP
.IP \(bu 2
\fI\%Classes\fP
.IP \(bu 2
\fI\%Functions\fP
.UNINDENT
.SS Definition (\fBnecsim/ConfigFileParser.h\fP)
.SS Program Listing for File ConfigFileParser.h
.INDENT 0.0
.IP \(bu 2
Return to documentation for file_necsim_ConfigFileParser.h
.UNINDENT
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
// This file is part of NECSim project which is released under BSD\-3 license.
// See file **LICENSE.txt** or visit https://opensource.org/licenses/BSD\-3\-Clause) for full license details.
//
#ifndef CONFIGCLASS
#define CONFIGCLASS

/************************************************************
                                                                                                                                                                                                INCLUDES
 ************************************************************/
#include <string>
#include <iostream>
#include <sstream>
#include <fstream>
#include <stdexcept>
#include <vector>
#include <cstring>
#include <unistd.h>
#include <cmath>
#include <cctype>
#include <algorithm>


using namespace std;
using std::string;

void importArgs(const unsigned int &argc, char *argv[], vector<string> &comargs);

//

struct SectionOption
{
    string section;
    vector<string> val;
    vector<string> refs;

    SectionOption()
    {
        section = "nullSectionOption";
    }

    string getOption(string refval);

    friend ostream &operator<<(ostream &os, const SectionOption &k);

    friend istream &operator>>(istream &is, SectionOption &k);
};

class ConfigOption
{
private:
    string configfile;
    bool bConfig;
    bool bMain;  // is true if this is the main command line importSpatialParameters (and therefore we want to delete the first few
    // command line options)
    bool bFullParse;  // if this is true, each KeyOption structure will be returned after each read.
    vector<SectionOption> configs;  // all config data if full parse is true.
public:
    ConfigOption()
    {
        bConfig = false;
        configfile = "none";
        bMain = false;
        bFullParse = false;
    }

    void setConfig(const string &file, bool main, bool full_parse = false);

    void parseConfig();

    vector<SectionOption> getSectionOptions();

    void setSectionOption(string section, string reference, string value);

    SectionOption operator[](int index);

    unsigned int getSectionOptionsSize();

    vector<string> getSections();

    bool hasSection(const string &sec);

    vector<string> getSectionValues(string sec);

    string getSectionOptions(string section, string ref);

    string getSectionOptions(string section, string ref, string def);

    int importConfig(vector<string> &comargs);

    friend ostream &operator<<(ostream &os, const ConfigOption &c);

    friend istream &operator>>(istream &is, ConfigOption &c);
};

#endif
.ft P
.fi
.UNINDENT
.UNINDENT
.SS Detailed Description
.sp
Sam Thompson
31/08/2016
Contact: \fI\%samuel.thompson14@imperial.ac.uk\fP or \fI\%thompsonsed@gmail.com\fP BSD\-3 Licence.
.SS Includes
.INDENT 0.0
.IP \(bu 2
\fBalgorithm\fP
.IP \(bu 2
\fBcctype\fP
.IP \(bu 2
\fBcmath\fP
.IP \(bu 2
\fBcstring\fP
.IP \(bu 2
\fBfstream\fP
.IP \(bu 2
\fBiostream\fP
.IP \(bu 2
\fBsstream\fP
.IP \(bu 2
\fBstdexcept\fP
.IP \(bu 2
\fBstring\fP
.IP \(bu 2
\fBunistd.h\fP
.IP \(bu 2
\fBvector\fP
.UNINDENT
.SS Included By
.INDENT 0.0
.IP \(bu 2
file_necsim_SimParameters.h
.IP \(bu 2
file_necsim_ConfigFileParser.cpp
.UNINDENT
.SS Classes
.INDENT 0.0
.IP \(bu 2
struct_SectionOption
.IP \(bu 2
class_ConfigOption
.UNINDENT
.SS Functions
.INDENT 0.0
.IP \(bu 2
function_importArgs
.UNINDENT
.SS File CustomExceptions.h
.sp
Contains the various exceptions used by NECSim.
.SS Contents
.INDENT 0.0
.IP \(bu 2
\fI\%Definition (necsim/CustomExceptions.h)\fP
.IP \(bu 2
\fI\%Detailed Description\fP
.IP \(bu 2
\fI\%Includes\fP
.IP \(bu 2
\fI\%Included By\fP
.IP \(bu 2
\fI\%Classes\fP
.UNINDENT
.SS Definition (\fBnecsim/CustomExceptions.h\fP)
.SS Program Listing for File CustomExceptions.h
.INDENT 0.0
.IP \(bu 2
Return to documentation for file_necsim_CustomExceptions.h
.UNINDENT
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
//This file is part of NECSim project which is released under BSD\-3 license.
//See file **LICENSE.txt** or visit https://opensource.org/licenses/BSD\-3\-Clause) for full license details.
// Author: Samuel Thompson
// Contact: samuel.thompson14@imperial.ac.uk or thompsonsed@gmail.com
#ifndef EXCEPTION
#define EXCEPTION

#include <stdexcept>
#include "Logging.h"

using namespace std;


struct FatalException : public runtime_error
{
    FatalException() : runtime_error("Fatal exception thrown at run time, quitting program. "){}

    explicit FatalException(string msg) : runtime_error(msg)
    {
#ifdef DEBUG
        writeLog(50, msg);
#endif //DEBUG
    }
};

struct ConfigException : public FatalException
{
    ConfigException() : FatalException("Exception thrown at run time in config: "){}

    explicit ConfigException(string msg) : FatalException(msg){}
};


struct SpeciesException : public FatalException
{
    SpeciesException() : FatalException("Exception thrown at run time in SpeciationCounter: "){}

    explicit SpeciesException(string msg) : FatalException(msg){}
};

#endif
.ft P
.fi
.UNINDENT
.UNINDENT
.SS Detailed Description
.sp
Samuel Thompson
BSD\-3 Licence.
.SS Includes
.INDENT 0.0
.IP \(bu 2
\fBLogging.h\fP (file_necsim_Logging.h)
.IP \(bu 2
\fBstdexcept\fP
.UNINDENT
.SS Included By
.INDENT 0.0
.IP \(bu 2
file_necsim_LogFile.h
.IP \(bu 2
file_necsim_ConfigFileParser.cpp
.IP \(bu 2
file_necsim_DispersalCoordinator.cpp
.IP \(bu 2
file_necsim_Filesystem.cpp
.IP \(bu 2
file_necsim_Tree.h
.IP \(bu 2
file_necsim_SimulationTemplates.h
.IP \(bu 2
file_necsim_Map.cpp
.IP \(bu 2
file_necsim_SimulateDispersal.cpp
.UNINDENT
.SS Classes
.INDENT 0.0
.IP \(bu 2
struct_ConfigException
.IP \(bu 2
struct_FatalException
.IP \(bu 2
struct_SpeciesException
.UNINDENT
.SS File DataMask.cpp
.sp
Contains the class_DataMask class for describing the spatial sampling pattern on a landscape.
.SS Contents
.INDENT 0.0
.IP \(bu 2
\fI\%Definition (necsim/DataMask.cpp)\fP
.IP \(bu 2
\fI\%Detailed Description\fP
.IP \(bu 2
\fI\%Includes\fP
.UNINDENT
.SS Definition (\fBnecsim/DataMask.cpp\fP)
.SS Program Listing for File DataMask.cpp
.INDENT 0.0
.IP \(bu 2
Return to documentation for file_necsim_DataMask.cpp
.UNINDENT
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
#include "DataMask.h"
#include "Map.h"
#include "Logging.h"

DataMask::DataMask()
{
    bDefault = true;
    x_dim = 0;
    y_dim = 0;
    x_offset = 0;
    y_offset = 0;
    mask_x_dim = 0;
    mask_y_dim = 0;
    getProportionfptr = &DataMask::getBoolProportion;
}

bool DataMask::getDefault()
{
    return bDefault;
}

bool DataMask::setup(const string &sample_mask_file, const unsigned long &x_in, const unsigned long &y_in,
                     const unsigned long &mask_x_in, const unsigned long &mask_y_in,
                     const unsigned long &x_offset_in, const unsigned long &y_offset_in)
{
#ifdef DEBUG
    if((x_in > mask_x_in || y_in > mask_y_in) && !bDefault)
    {
        writeLog(50, "Grid size: " + to_string(x_in) + ", " + to_string(y_in));
        writeLog(50, "Sample mask size: " + to_string(mask_x_in) + ", " + to_string(mask_y_in));
        throw FatalException("Datamask dimensions do not make sense");
    }
#endif // DEBUG
    inputfile = sample_mask_file;
    x_dim = x_in;
    y_dim = y_in;
    mask_x_dim = mask_x_in;
    mask_y_dim  = mask_y_in;
    x_offset = x_offset_in;
    y_offset = y_offset_in;
    if(inputfile == "null" || inputfile == "none")
    {
        bDefault = true;
    }
    else
    {
        bDefault = false;
    }
    return bDefault;
}

void DataMask::importBooleanMask(unsigned long xdim, unsigned long ydim, unsigned long mask_xdim,
                                 unsigned long mask_ydim,
                                 unsigned long xoffset, unsigned long yoffset, string inputfile)
{
    if(!setup(inputfile, xdim, ydim, mask_xdim, mask_ydim, xoffset, yoffset))
    {
        doImport();
    }
}
void DataMask::doImport()
{
    sample_mask.SetSize(mask_y_dim, mask_x_dim);
    sample_mask.import(inputfile);
    getProportionfptr = &DataMask::getBoolProportion;

}

void DataMask::importSampleMask(SimParameters &mapvarin)
{
    if(!setup(mapvarin.sample_mask_file, mapvarin.grid_x_size, mapvarin.grid_y_size,
             mapvarin.sample_x_size, mapvarin.sample_y_size, mapvarin.sample_x_offset, mapvarin.sample_y_offset))
    {
        if(mapvarin.uses_spatial_sampling)
        {
#ifdef DEBUG
            writeLog(10, "Using spatial sampling.");
            writeLog(10, "Mask dimensions: " + to_string(mask_x_dim) + ", " + to_string(mask_y_dim));
#endif // DEBUG
            sample_mask_exact.SetSize(mask_y_dim, mask_x_dim);
            sample_mask_exact.import(inputfile);
            getProportionfptr = &DataMask::getSampleProportion;
        }
        else
        {
            doImport();
        }
    }
    else
    {
        if(mapvarin.uses_spatial_sampling)
        {
            // This could perhaps be a warning, but I\(aqd prefer to have the warning/prohibit potential in python
            // and throw a full exception here.
            throw FatalException("Cannot use a spatial sampling routine when the map file is null.");
        }
        getProportionfptr = &DataMask::getNullProportion;
    }
}

bool DataMask::getVal(const long &x, const long &y, const long &xwrap, const long &ywrap)
{
    long xval = x + (xwrap * x_dim) + x_offset;
    long yval = y + (ywrap * y_dim) + y_offset;
    if(bDefault)
    {
        return true;
    }
#ifdef DEBUG
    if(xval < 0 || xval >= (long) mask_x_dim || yval < 0 || yval >= (long) mask_y_dim)
    {
        stringstream ss;
        ss << "Get value on samplemask requested for non index." << endl;
        ss << "x, y: " << x << ", " << y << endl;
        ss << "dimensions x,y: " << mask_x_dim << ", " << mask_y_dim << endl;
        ss << "x, y wrap: " << xwrap << ", " << ywrap << endl;
        ss << "xval, yval: " << xval << ", " << yval << endl;
        ss << "offsets x, y: " << x_offset << ", " << y_offset << endl;
        writeLog(50, ss);
        ss.str("Get value on samplemask requested for non index.");
        throw out_of_range(ss.str());
    }
#endif
    return sample_mask[yval][xval];
}


double DataMask::getNullProportion(const long &x, const long &y, const long &xwrap, const long &ywrap)
{
    return 1.0;
}

double DataMask::getBoolProportion(const long &x, const long &y, const long &xwrap, const long &ywrap)
{

    if(getVal(x, y, xwrap, ywrap))
    {
        return 1.0;
    }
    else
    {
        return 0.0;
    }
}

double DataMask::getSampleProportion(const long &x, const long &y, const long &xwrap, const long &ywrap)
{
#ifdef DEBUG
    if(bDefault || sample_mask_exact.GetCols() == 0)
    {
        throw out_of_range("Cannot get the exact value from a samplemask if we are using a null mask, or the "
                                   "exact samplemask has not been properly imported.");
    }
#endif // DEBUG
    long xval = x + (xwrap * x_dim) + x_offset;
    long yval = y + (ywrap * y_dim) + y_offset;
    return sample_mask_exact[yval][xval];
}

double DataMask::getExactValue(const long &x, const long &y, const long &xwrap, const long &ywrap)
{
    return (this\->*getProportionfptr)(x, y, xwrap, ywrap);
}

void DataMask::convertBoolean(Map &map1, const double &deme_sampling, const double &generation)
{
    // Clear the old boolean object and set the new size
    sample_mask.SetSize(y_dim, x_dim);
    for(unsigned long y = 0; y < y_dim; y++)
    {
        for(unsigned long x = 0; x < x_dim; x++)
        {
            long tmp_x = x;
            long tmp_y = y;
            long tmp_xwrap = 0;
            long tmp_ywrap = 0;
            recalculate_coordinates(tmp_x, tmp_y, tmp_xwrap, tmp_ywrap);
            double density = map1.getVal(tmp_x, tmp_y, tmp_xwrap, tmp_ywrap, generation) * deme_sampling;
            sample_mask[y][x] = density >= 1.0;
        }
    }
}

void DataMask::clearSpatialMask()
{
    sample_mask_exact.SetSize(0, 0);
}

void DataMask::recalculate_coordinates(long &x, long &y, long &x_wrap, long &y_wrap)
{
    if(!bDefault)
    {
        x_wrap = (long)((floor((x \- (double) x_offset) / (double) x_dim)));
        y_wrap = (long)((floor((y \- (double) y_offset) / (double) y_dim)));
        x += \-x_offset \- (x_wrap * x_dim);
        y += \-y_offset \- (y_wrap * y_dim);
    }
}
.ft P
.fi
.UNINDENT
.UNINDENT
.SS Detailed Description
.sp
Samuel Thompson
BSD\-3 Licence.
.SS Includes
.INDENT 0.0
.IP \(bu 2
\fBDataMask.h\fP (file_necsim_DataMask.h)
.IP \(bu 2
\fBLogging.h\fP (file_necsim_Logging.h)
.IP \(bu 2
\fBMap.h\fP (file_necsim_Map.h)
.UNINDENT
.SS File DataMask.h
.sp
Contains class_DataMask for describing the spatial sampling pattern on a landscape.
.SS Contents
.INDENT 0.0
.IP \(bu 2
\fI\%Definition (necsim/DataMask.h)\fP
.IP \(bu 2
\fI\%Detailed Description\fP
.IP \(bu 2
\fI\%Includes\fP
.IP \(bu 2
\fI\%Included By\fP
.IP \(bu 2
\fI\%Classes\fP
.UNINDENT
.SS Definition (\fBnecsim/DataMask.h\fP)
.SS Program Listing for File DataMask.h
.INDENT 0.0
.IP \(bu 2
Return to documentation for file_necsim_DataMask.h
.UNINDENT
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
// This file is part of NECSim project which is released under BSD\-3 license.
// See file **LICENSE.txt** or visit https://opensource.org/licenses/BSD\-3\-Clause) for full license details.


#ifndef SPECIATIONCOUNTER_DataMask_H
#define SPECIATIONCOUNTER_DataMask_H

// Forward declaration of map
class Map;

#include <string>

#include "Matrix.h"
#include "SimParameters.h"


// Class which contains the DataMask object, telling us where to sample from within the habitat map.
class DataMask
{
protected:
    // the file to read in from
    string inputfile;
    bool bDefault;
    unsigned long x_offset, y_offset;
    // Stores the size of the grid which is stored as a full species list
    unsigned long x_dim, y_dim;
    // Stores the size of the samplemask from which spatially sampling is read
    unsigned long mask_x_dim, mask_y_dim;
    // Function pointer for obtaining the proportional sampling from the sample mask.
    typedef double (DataMask::*fptr)(const long &x, const long &y, const long &xwrap, const long &ywrap);
    fptr getProportionfptr;
public:
    Matrix<bool> sample_mask;
    // Stores the exact values from the input tif file.
    Matrix<double> sample_mask_exact;
    DataMask();

    ~DataMask() = default;

    bool getDefault();

    bool setup(const string &sample_mask_file, const unsigned long &x_in, const unsigned long &y_in,
               const unsigned long &mask_x_in, const unsigned long &mask_y_in,
               const unsigned long &x_offset_in, const unsigned long &y_offset_in);

    void importBooleanMask(unsigned long xdim, unsigned long ydim, unsigned long mask_xdim, unsigned long mask_ydim,
                           unsigned long xoffset, unsigned long yoffset, string inputfile);

    void doImport();

    void importSampleMask(SimParameters &mapvarin);


    bool getVal(const long &x, const long &y, const long &xwrap, const long &ywrap);

    double getNullProportion(const long &x, const long &y, const long &xwrap, const long &ywrap);

    double getBoolProportion(const long &x, const long &y, const long &xwrap, const long &ywrap);

    double getSampleProportion(const long &x, const long &y, const long &xwrap, const long &ywrap);

    double getExactValue(const long &x, const long &y, const long &xwrap, const long &ywrap);

    void convertBoolean(Map &map1, const double &deme_sampling, const double &generation);

    void clearSpatialMask();

    void recalculate_coordinates(long &x, long &y, long &x_wrap, long &y_wrap);
};


#endif //SPECIATIONCOUNTER_DataMask_H
.ft P
.fi
.UNINDENT
.UNINDENT
.SS Detailed Description
.sp
Samuel Thompson
BSD\-3 Licence.
.SS Includes
.INDENT 0.0
.IP \(bu 2
\fBMatrix.h\fP (file_necsim_Matrix.h)
.IP \(bu 2
\fBSimParameters.h\fP (file_necsim_SimParameters.h)
.IP \(bu 2
\fBstring\fP
.UNINDENT
.SS Included By
.INDENT 0.0
.IP \(bu 2
file_necsim_Community.h
.IP \(bu 2
file_necsim_DataMask.cpp
.IP \(bu 2
file_necsim_Map.h
.UNINDENT
.SS Classes
.INDENT 0.0
.IP \(bu 2
class_DataMask
.UNINDENT
.SS File DataPoint.cpp
.sp
Contains the Datapoint class for storing objects during simulation run time.
.SS Contents
.INDENT 0.0
.IP \(bu 2
\fI\%Definition (necsim/DataPoint.cpp)\fP
.IP \(bu 2
\fI\%Detailed Description\fP
.IP \(bu 2
\fI\%Includes\fP
.IP \(bu 2
\fI\%Functions\fP
.UNINDENT
.SS Definition (\fBnecsim/DataPoint.cpp\fP)
.SS Program Listing for File DataPoint.cpp
.INDENT 0.0
.IP \(bu 2
Return to documentation for file_necsim_DataPoint.cpp
.UNINDENT
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
//This file is part of NECSim project which is released under BSD\-3 license.
//See file **LICENSE.txt** or visit https://opensource.org/licenses/BSD\-3\-Clause) for full license details.
#include "DataPoint.h"

void DataPoint::setup(unsigned long x, unsigned long y, long xwrap_in, long ywrap_in, unsigned long reference_in,
                      unsigned long list_position_in, double min_max_in)
{
    xpos = x;
    ypos = y;
    xwrap = xwrap_in;
    ywrap = ywrap_in;
    next_lineage = 0;
    reference = reference_in;
    list_position = list_position_in;
    nwrap = 0;
    min_max = min_max_in;
}

void DataPoint::setup(unsigned long reference_in, unsigned long list_position_in, double min_max_in)
{
    setup(0, 0, 0, 0, reference_in, list_position_in, min_max_in);
}

void DataPoint::setup(DataPoint datin)
{
    xpos = datin.getXpos();
    ypos = datin.getYpos();
    xwrap = datin.getXwrap();
    ywrap = datin.getYwrap();
    next_lineage = datin.getNext();
//      last = datin.get_last(); // removed as of version 3.1
    reference = datin.getReference();
    list_position = datin.getListpos();
    nwrap = datin.getNwrap();
    min_max = datin.getMinmax();
}

void DataPoint::setReference(unsigned long z)
{
    reference = z;
}

void DataPoint::setNext(unsigned long x)
{
    next_lineage = x;
}

void DataPoint::setListPosition(unsigned long l)
{
    list_position = l;
}

void DataPoint::setNwrap(unsigned long n)
{
    nwrap = n;
}

void DataPoint::setMinmax(double d)
{
    min_max = d;
}

unsigned long DataPoint::getXpos()
{
    return xpos;
}

unsigned long DataPoint::getYpos()
{
    return ypos;
}

long DataPoint::getXwrap()
{
    return xwrap;
}

long DataPoint::getYwrap()
{
    return ywrap;
}

unsigned long DataPoint::getReference()
{
    return reference;
}

unsigned long DataPoint::getNext()
{
    return next_lineage;
}

unsigned long DataPoint::getListpos()
{
    return list_position;
}

unsigned long DataPoint::getNwrap()
{
    return nwrap;
}

double DataPoint::getMinmax()
{
    return min_max;
}

void DataPoint::decreaseNwrap()
{
    try
    {
        if(nwrap==0)
        {
            throw out_of_range("ERROR_DATA_001: Trying to decrease  nwrap less than 0.");
        }
        else
        {
            nwrap \-\-;
        }
    }
    catch(out_of_range& oor)
    {
        cerr << oor.what() << endl;
    }
}

void DataPoint::setEndpoint(long x, long y, long xwrapin, long ywrapin)
{
    xpos = x;
    ypos = y;
    xwrap = xwrapin;
    ywrap = ywrapin;
}

ostream &operator<<(ostream &os, const DataPoint &d)
{
    os << d.xpos << "," << d.ypos  << "," << d.xwrap << "," << d.ywrap << "," << d.next_lineage << "," << d.reference << "," << d.list_position << "," << d.nwrap<< ",";
    os << d.min_max << "\en";
    return os;
}

istream &operator>>(istream &is, DataPoint &d)
{
    //os << m.numRows<<" , "<<m.numCols<<" , "<<endl;
    char delim;
    //os << "datapoint" << endl;
    is >> d.xpos >> delim >> d.ypos  >> delim >> d.xwrap >> delim >> d.ywrap >> delim >> d.next_lineage >> delim >> d.reference >> delim >> d.list_position >> delim >> d.nwrap>> delim;
    is >> d.min_max;
    return is;
}
.ft P
.fi
.UNINDENT
.UNINDENT
.SS Detailed Description
.sp
Samuel Thompson
30/08/2016
BSD\-3 Licence. This class is only used during simulation runs and is not outputted to a database. A template_class_Row of Datapoint objects is utilised by the main class_Tree objects.
.SS Includes
.INDENT 0.0
.IP \(bu 2
\fBDataPoint.h\fP (file_necsim_DataPoint.h)
.UNINDENT
.SS Functions
.INDENT 0.0
.IP \(bu 2
function_operator_LT__LT
.IP \(bu 2
function_operator_GT__GT
.UNINDENT
.SS File DataPoint.h
.sp
Contains the class_DataPoint class for storing objects during simulation run time.
.SS Contents
.INDENT 0.0
.IP \(bu 2
\fI\%Definition (necsim/DataPoint.h)\fP
.IP \(bu 2
\fI\%Detailed Description\fP
.IP \(bu 2
\fI\%Includes\fP
.IP \(bu 2
\fI\%Included By\fP
.IP \(bu 2
\fI\%Classes\fP
.UNINDENT
.SS Definition (\fBnecsim/DataPoint.h\fP)
.SS Program Listing for File DataPoint.h
.INDENT 0.0
.IP \(bu 2
Return to documentation for file_necsim_DataPoint.h
.UNINDENT
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
//This file is part of NECSim project which is released under BSD\-3 license.
//See file **LICENSE.txt** or visit https://opensource.org/licenses/BSD\-3\-Clause) for full license details.
#ifndef DATAPOINT_H
#define DATAPOINT_H

#include <iostream>
#include "Logging.h"

using namespace std;
class DataPoint
{

private:
    // x position
    unsigned long xpos;
    // y position
    unsigned long ypos;
    // number of wraps of x around the torus
    long xwrap;
    // number of wraps of y around the torus
    long ywrap;
    // the next individual in the loop of those that have the same xypos
    unsigned long next_lineage;
    // points to the position in output of this lineage
    unsigned long reference;
    // points to the position in the SpeciesList file.
    unsigned long list_position;
    // the reference number within the linked list of wrapped lineages
    unsigned long nwrap;
    // the max\-min number
    double min_max;
public:

    DataPoint() : xpos(0),ypos(0),xwrap(0),ywrap(0),next_lineage(0),reference(0),list_position(0),nwrap(0),min_max(0)
    {

    }

    ~DataPoint() = default;

    void setup(unsigned long x , unsigned long y , long xwrap_in, long ywrap_in, unsigned long reference_in,
               unsigned long list_position_in, double min_max_in);

    void setup(unsigned long reference_in, unsigned long list_position_in, double min_max_in);
    void setup(DataPoint datin);


    void setReference(unsigned long z);
    void setNext(unsigned long x);

    void setListPosition(unsigned long l);
    void setNwrap(unsigned long n);

    void setMinmax(double d);


    unsigned long getXpos();

    unsigned long getYpos();

    long getXwrap();

    long getYwrap();

    unsigned long getReference();

    unsigned long getNext();

    unsigned long getListpos();

    unsigned long getNwrap();

    double getMinmax();

    void decreaseNwrap();

    void setEndpoint(long x, long y, long xwrapin, long ywrapin);

    friend ostream& operator<<(ostream& os, const DataPoint& d);

    friend istream& operator>>(istream& is, DataPoint& d);

#ifdef DEBUG
    void logActive(const int &level)
    {
        writeLog(50, "x, y, (x wrap, y wrap): " + to_string(xpos) + ", " + to_string(ypos) + ", (" +
                to_string(xwrap) + ", " + to_string(ywrap) + ")");
        writeLog(50, "Lineage next: " + to_string(next_lineage));
        writeLog(50, "Reference: " + to_string(reference));
        writeLog(50, "List position: " + to_string(list_position));
        writeLog(50, "Number in wrapped lineages: " + to_string(nwrap));
        writeLog(50, "Minimum maximum: " + to_string(min_max));
    }
#endif // DEBUG
};

#endif // DATAPOINT_H
.ft P
.fi
.UNINDENT
.UNINDENT
.SS Detailed Description
.sp
Samuel Thompson
30/08/2016
BSD\-3 Licence. This class is only used during simulation runs and is not outputted to a database. A template_class_Row of class_DataPoint objects is utilised by the main class_Tree objects.
.SS Includes
.INDENT 0.0
.IP \(bu 2
\fBLogging.h\fP (file_necsim_Logging.h)
.IP \(bu 2
\fBiostream\fP
.UNINDENT
.SS Included By
.INDENT 0.0
.IP \(bu 2
file_necsim_DataPoint.cpp
.IP \(bu 2
file_necsim_Tree.h
.IP \(bu 2
file_necsim_SpatialTree.h
.UNINDENT
.SS Classes
.INDENT 0.0
.IP \(bu 2
class_DataPoint
.UNINDENT
.SS File DispersalCoordinator.cpp
.sp
Contains the class_DispersalCoordinator, which contains all routines related to dispersal including utilisation of density maps and dispersal probability maps.
.SS Contents
.INDENT 0.0
.IP \(bu 2
\fI\%Definition (necsim/DispersalCoordinator.cpp)\fP
.IP \(bu 2
\fI\%Detailed Description\fP
.IP \(bu 2
\fI\%Includes\fP
.UNINDENT
.SS Definition (\fBnecsim/DispersalCoordinator.cpp\fP)
.SS Program Listing for File DispersalCoordinator.cpp
.INDENT 0.0
.IP \(bu 2
Return to documentation for file_necsim_DispersalCoordinator.cpp
.UNINDENT
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
//This file is part of NECSim project which is released under BSD\-3 license.
//See file **LICENSE.txt** or visit https://opensource.org/licenses/BSD\-3\-Clause) for full license details.

#include "DispersalCoordinator.h"
#include "CustomExceptions.h"

DispersalCoordinator::DispersalCoordinator()
{
}

DispersalCoordinator::~DispersalCoordinator()
{

}

void DispersalCoordinator::setRandomNumber(NRrand * NR_ptr)
{
    NR = NR_ptr;
}


void DispersalCoordinator::setHabitatMap(Map *map_ptr)
{
    habitat_map = map_ptr;
    xdim = habitat_map\->getSimParameters().fine_map_x_size;
}

void DispersalCoordinator::setGenerationPtr(double * generation_ptr)
{
    generation = generation_ptr;
}


void DispersalCoordinator::setDispersal(const string &dispersal_method, const string &dispersal_file,
                              const unsigned long dispersal_x, const unsigned long dispersal_y,
                              const double &m_probin, const double &cutoffin,
                              const double &sigmain, const double &tauin, const bool &restrict_self)
{
    // Open our file connection
    if(dispersal_file == "none")
    {
        setEndPointFptr(restrict_self);
        NR\->setDispersalParams(sigmain, tauin);
        NR\->setDispersalMethod(dispersal_method, m_probin, cutoffin);
        doDispersal = &DispersalCoordinator::disperseDensityMap;
    }
    else if(dispersal_file == "null")
    {
        doDispersal = &DispersalCoordinator::disperseNullDispersalMap;
    }
    else
    {
        doDispersal = &DispersalCoordinator::disperseDispersalMap;
        // Check file existance
        ifstream infile(dispersal_file);
        if(!infile.good())
        {
            string msg = "Could not access dispersal map file " + dispersal_file + ". Check file exists and is readable.";
            throw FatalException(msg);
        }
        infile.close();
        dispersal_prob_map.SetSize(dispersal_x * dispersal_y, dispersal_x * dispersal_y);
        dispersal_prob_map.import(dispersal_file);
    }
}

void DispersalCoordinator::disperseNullDispersalMap(Step &this_step)
{
    // Pick a random cell \- that\(aqs all we need
    this_step.oldx = floor(NR\->d01()*(xdim\-1));
    this_step.oldy = floor(NR\->d01()*(xdim \- 1));
}

void DispersalCoordinator::disperseDispersalMap(Step &this_step)
{
    // Generate random number 0\-1
    double random_no = NR\->d01();
    // Now find the cell with that value
    // Now we get the cell reference
    unsigned long row_ref = calculateCellReference(this_step);
    // Interval bisection on the cells to get the dispersal value
    unsigned long min_col = 0;
    unsigned long max_col = dispersal_prob_map.GetCols() \- 1;
    while(max_col \- min_col > 1)
    {
        unsigned long to_check = floor(double(max_col\-min_col)/2.0) + min_col;
        if(dispersal_prob_map[row_ref][to_check] > random_no)
        {
            min_col = to_check;
        }
        else
        {
            max_col = to_check;
        }
    }
    // Now get the coordinates of our cell reference
    calculateCellCoordinates(this_step, max_col);
}

void DispersalCoordinator::calculateCellCoordinates(Step & this_step, const unsigned long &col_ref)
{
    this_step.oldx = long(floor(fmod(double(col_ref), xdim)));
    this_step.oldy = long(floor(double(col_ref)/xdim));
    this_step.oldxwrap = 0;
    this_step.oldywrap = 0;
    // Convert back to sample map
    habitat_map\->convertFineToSample(this_step.oldx, this_step.oldxwrap, this_step.oldy, this_step.oldywrap);

}

unsigned long DispersalCoordinator::calculateCellReference(Step &this_step)
{
    unsigned long x = habitat_map\->convertSampleXToFineX(this_step.oldx, this_step.oldxwrap);
    unsigned long y = habitat_map\->convertSampleYToFineY(this_step.oldy, this_step.oldywrap);
    return x + (y * xdim);
}

void DispersalCoordinator::disperseDensityMap(Step &this_step)
{
    bool fail;
    fail = true;
    // Store the starting positions
    long startx, starty, startxwrap, startywrap;
    startx = this_step.oldx;
    starty = this_step.oldy;
    startxwrap = this_step.oldxwrap;
    startywrap = this_step.oldywrap;
    // keep looping until we reach a viable place to move from.
    // Store the density in the end location.
    unsigned long density;
    double dist, angle;
    while(fail)
    {
        angle = NR\->direction();
        dist = NR\->dispersal();
        density = habitat_map\->runDispersal(dist, angle, this_step.oldx,
                                          this_step.oldy, this_step.oldxwrap, this_step.oldywrap, fail, *generation);
        if(!fail)
        {
            fail = !checkEndPoint(density, this_step.oldx, this_step.oldy, this_step.oldxwrap, this_step.oldywrap,
                                  startx, starty, startxwrap, startywrap);
        }
        // Discard the dispersal event a percentage of the time, based on the maximum value of the habitat map.
        // This is to correctly mimic less\-dense cells having a lower likelihood of being the parent to the cell.

#ifdef DEBUG
        if(habitat_map\->getVal(this_step.oldx, this_step.oldy, this_step.oldxwrap, this_step.oldywrap, *generation) == 0 &&
            !fail)
        {
            stringstream ss;
            ss << "x,y: " << this_step.oldx << "," << this_step.oldy;
            ss << " x,y wrap: " << this_step.oldxwrap << "," << this_step.oldywrap << "Habitat cover: ";
            ss << habitat_map\->getVal(this_step.oldx, this_step.oldy, this_step.oldxwrap,
                                      this_step.oldywrap, *generation) << endl;
            writeLog(50, ss);
            throw FatalException("ERROR_MOVE_007: Dispersal attempted to non\-habitat. Check dispersal function.");
        }
#endif
    }
}

void DispersalCoordinator::setEndPointFptr(const bool &restrict_self)
{
    if(restrict_self)
    {
        checkEndPointFptr = &DispersalCoordinator::checkEndPointRestricted;
    }
    else
    {
        checkEndPointFptr = &DispersalCoordinator::checkEndPointDensity;
    }
}


bool DispersalCoordinator::checkEndPoint(const unsigned long & density, long &oldx, long &oldy,
                                         long &oldxwrap, long &oldywrap, const long &startx, const long &starty,
                                         const long &startxwrap, const long &startywrap)
{
    return (this\->*checkEndPointFptr)(density, oldx, oldy, oldxwrap, oldywrap, startx, starty, startxwrap, startywrap);
}

bool DispersalCoordinator::checkEndPointDensity(const unsigned long &density, long &oldx, long &oldy,
                                                long &oldxwrap, long &oldywrap, const long &startx, const long &starty,
                                                const long &startxwrap, const long &startywrap)
{
    if((double(density) / double(habitat_map\->getHabitatMax())) <
       NR\->d01())
    {
        oldx = startx;
        oldy = starty;
        oldxwrap = startxwrap;
        oldywrap = startywrap;
        return false;
    }
    return true;
}

bool DispersalCoordinator::checkEndPointRestricted(const unsigned long &density, long &oldx, long &oldy, long &oldxwrap, long &oldywrap, const long &startx, const long &starty,
                              const long &startxwrap, const long &startywrap)
{
    if(startx == oldx && starty == oldy && startxwrap == oldxwrap && startywrap == oldywrap)
    {
        return false;
    }
    return checkEndPointDensity(density, oldx, oldy, oldxwrap, oldywrap, startx, starty, startxwrap, startywrap);
}

void DispersalCoordinator::disperse(Step &this_step)
{
    (this\->*doDispersal)(this_step);
}
.ft P
.fi
.UNINDENT
.UNINDENT
.SS Detailed Description
.sp
Samuel Thompson
07/08/2017
BSD\-3 Licence.
.SS Includes
.INDENT 0.0
.IP \(bu 2
\fBCustomExceptions.h\fP (file_necsim_CustomExceptions.h)
.IP \(bu 2
\fBDispersalCoordinator.h\fP (file_necsim_DispersalCoordinator.h)
.UNINDENT
.SS File DispersalCoordinator.h
.sp
Contains the class_DispersalCoordinator, which contains all routines related to dispersal including utilisation of density maps and dispersal probability maps.
.SS Contents
.INDENT 0.0
.IP \(bu 2
\fI\%Definition (necsim/DispersalCoordinator.h)\fP
.IP \(bu 2
\fI\%Detailed Description\fP
.IP \(bu 2
\fI\%Includes\fP
.IP \(bu 2
\fI\%Included By\fP
.IP \(bu 2
\fI\%Classes\fP
.UNINDENT
.SS Definition (\fBnecsim/DispersalCoordinator.h\fP)
.SS Program Listing for File DispersalCoordinator.h
.INDENT 0.0
.IP \(bu 2
Return to documentation for file_necsim_DispersalCoordinator.h
.UNINDENT
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
//This file is part of NECSim project which is released under BSD\-3 license.
//See file **LICENSE.txt** or visit https://opensource.org/licenses/BSD\-3\-Clause) for full license details.

#ifndef DISPERSALCOORDINATOR_H
#define DISPERSALCOORDINATOR_H

#include <cstring>
#include <cstdio>
#include <iostream>
#include <fstream>
#include <stdexcept>
#include <cmath>

#include "NRrand.h"
#include "Matrix.h"
#include "Step.h"
#include "Map.h"

class DispersalCoordinator
{
protected:

    // Our map of dispersal probabilities (if required)
    // This will contain cummulative probabilities across rows
    Matrix<double> dispersal_prob_map;
    // Our random number generator for dispersal distances
    // This is a pointer so that the random number generator is the same
    // across the program.

    NRrand * NR;
    // Pointer to the habitat map object for getting density values.
    Map * habitat_map;
    // Pointer to the generation counter for the simulation
    double * generation;

    // function ptr for our getDispersal function
    typedef void (DispersalCoordinator::*dispersal_fptr)(Step &this_step);
    dispersal_fptr doDispersal;

    // Function pointer for end checks
    typedef bool (DispersalCoordinator::*end_fptr)(const unsigned long &density, long &oldx, long &oldy, long &oldxwrap,
                                         long &oldywrap, const long &startx, const long &starty,
                                         const long &startxwrap, const long &startywrap);
    // once setup will contain the end check function to use for this simulation.
    end_fptr checkEndPointFptr;
    unsigned long xdim;

public:
    DispersalCoordinator();

    ~DispersalCoordinator();

    void setRandomNumber(NRrand * NR_ptr);

    void setHabitatMap(Map *map_ptr);

    void setGenerationPtr(double * generation_ptr);


    void setDispersal(const string &dispersal_method, const string &dispersal_file,
                      const unsigned long dispersal_x, const unsigned long dispersal_y,
                      const double &m_probin, const double &cutoffin,
                      const double &sigmain, const double &tauin, const bool &restrict_self);

    void disperseNullDispersalMap(Step &this_step);

    void disperseDispersalMap(Step &this_step);


    void calculateCellCoordinates(Step & this_step, const unsigned long &col_ref);

    unsigned long calculateCellReference(Step &this_step);

    void disperseDensityMap(Step &this_step);

    void setEndPointFptr(const bool &restrict_self);

    bool checkEndPoint(const unsigned long & density, long &oldx, long &oldy, long &oldxwrap, long &oldywrap,
                        const long &startx, const long &starty, const long &startxwrap, const long &startywrap);


    bool checkEndPointDensity(const unsigned long &density, long &oldx, long &oldy, long &oldxwrap, long &oldywrap,
                               const long &startx, const long &starty, const long &startxwrap, const long &startywrap);


    bool checkEndPointRestricted(const unsigned long &density, long &oldx, long &oldy, long &oldxwrap, long &oldywrap,
                                  const long &startx, const long &starty, const long &startxwrap, const long &startywrap);


    void disperse(Step &this_step);

};

#endif // DISPERSAL_H
.ft P
.fi
.UNINDENT
.UNINDENT
.SS Detailed Description
.sp
Samuel Thompson
07/08/2017
BSD\-3 Licence.
.SS Includes
.INDENT 0.0
.IP \(bu 2
\fBMap.h\fP (file_necsim_Map.h)
.IP \(bu 2
\fBMatrix.h\fP (file_necsim_Matrix.h)
.IP \(bu 2
\fBNRrand.h\fP (file_necsim_NRrand.h)
.IP \(bu 2
\fBStep.h\fP (file_necsim_Step.h)
.IP \(bu 2
\fBcmath\fP
.IP \(bu 2
\fBcstdio\fP
.IP \(bu 2
\fBcstring\fP
.IP \(bu 2
\fBfstream\fP
.IP \(bu 2
\fBiostream\fP
.IP \(bu 2
\fBstdexcept\fP
.UNINDENT
.SS Included By
.INDENT 0.0
.IP \(bu 2
file_necsim_DispersalCoordinator.cpp
.IP \(bu 2
file_necsim_SpatialTree.h
.UNINDENT
.SS Classes
.INDENT 0.0
.IP \(bu 2
class_DispersalCoordinator
.UNINDENT
.SS File dispersalmodule.cpp
.sp
Contains the functions for testing dispersal methods using efficient c++ routines.
.SS Contents
.INDENT 0.0
.IP \(bu 2
\fI\%Definition (dispersalmodule.cpp)\fP
.IP \(bu 2
\fI\%Detailed Description\fP
.IP \(bu 2
\fI\%Includes\fP
.IP \(bu 2
\fI\%Functions\fP
.IP \(bu 2
\fI\%Defines\fP
.IP \(bu 2
\fI\%Variables\fP
.UNINDENT
.SS Definition (\fBdispersalmodule.cpp\fP)
.SS Program Listing for File dispersalmodule.cpp
.INDENT 0.0
.IP \(bu 2
Return to documentation for file_dispersalmodule.cpp
.UNINDENT
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
// This file is part of NECSim project which is released under BSD\-3 license.
// See file **LICENSE.txt** or visit https://opensource.org/licenses/BSD\-3\-Clause) for full license details
#ifndef PYTHON_COMPILE
#define PYTHON_COMPILE
#endif
#include <Python.h>
#include <vector>
#include <string>
#include "dispersalmodule.h"
#include "PyLogging.h"
#include "necsim/SimulateDispersal.h"

PyObject * loggingmodule;
PyGILState_STATE gstate;
bool log_set = false;
bool logger_set = false;
PyObject * logger;

static PyObject * test_mean_dispersal(PyObject *self, PyObject *args)
{
    char * output_database;
    char * map_file;
    char * dispersal_method;
    char * landscape_type;
    int map_x, map_y;
    double sigma, tau, m_prob, cutoff;
    int num_repeats, seed, is_sequential;

    // parse arguments
    if(!PyArg_ParseTuple(args, "ssssddddiiiii", &output_database, &map_file, &dispersal_method, &landscape_type,
                         &sigma, &tau, &m_prob, &cutoff, &num_repeats, &seed, &map_x, &map_y, &is_sequential))
    {
        return nullptr;
    }
    try
    {
        Py_INCREF(logger);
        SimulateDispersal disp_sim;
        disp_sim.setDispersalParameters(dispersal_method, sigma, tau, m_prob, cutoff, landscape_type);
        disp_sim.setSequential(bool(is_sequential));
        disp_sim.setOutputDatabase(output_database);
        disp_sim.setSeed(static_cast<unsigned long>(seed));
        disp_sim.setNumberRepeats(static_cast<unsigned long>(num_repeats));
        disp_sim.setSizes(static_cast<unsigned long>(map_x), static_cast<unsigned long>(map_y));
        disp_sim.importMaps(map_file);
        disp_sim.runMeanDispersalDistance();
        disp_sim.writeDatabase("DISPERSAL_DISTANCES");
        Py_DECREF(logger);
    }
    catch(exception &e)
    {
        Py_DECREF(logger);
        PyErr_SetString(DispersalError, e.what());
        return nullptr;
    }
    Py_RETURN_NONE;
}
static PyObject * test_mean_distance_travelled(PyObject *self, PyObject *args)
{
    char * output_database;
    char * map_file;
    char * dispersal_method;
    char * landscape_type;
    int map_x, map_y;
    double sigma, tau, m_prob, cutoff;
    int num_repeats, seed, num_steps;

    // parse arguments
    if(!PyArg_ParseTuple(args, "ssssddddiiiii", &output_database, &map_file, &dispersal_method, &landscape_type,
                         &sigma, &tau, &m_prob, &cutoff, &num_repeats, &num_steps, &seed, &map_x, &map_y))
    {
        return nullptr;
    }
    try
    {
        Py_INCREF(logger);
        SimulateDispersal disp_sim;
        disp_sim.setDispersalParameters(dispersal_method, sigma, tau, m_prob, cutoff, landscape_type);
        disp_sim.setOutputDatabase(output_database);
        disp_sim.setSeed(static_cast<unsigned long>(seed));
        disp_sim.setNumberRepeats(static_cast<unsigned long>(num_repeats));
        disp_sim.setNumberSteps(static_cast<unsigned long>(num_steps));
        disp_sim.setSizes(static_cast<unsigned long>(map_x), static_cast<unsigned long>(map_y));
        disp_sim.importMaps(map_file);
        disp_sim.runMeanDistanceTravelled();
        disp_sim.writeDatabase("DISTANCES_TRAVELLED");
        Py_DECREF(logger);
    }
    catch(exception &e)
    {
#ifdef DEBUG
        writeLog(50, e.what());
#endif // DEBUG
        Py_DECREF(logger);
        PyErr_SetString(DispersalError, e.what());
        return nullptr;
    }
    Py_RETURN_NONE;
}


static PyMethodDef DispersalMethods[] =
{
    {"test_mean_dispersal", test_mean_dispersal, METH_VARARGS,
     "Simulates the dispersal function on the provided map, recording the mean dispersal distance."},
    {"test_mean_distance_travelled", test_mean_distance_travelled, METH_VARARGS,
     "Simulates the dispersal function on the provided map,"
             " recording the mean distance travelled in the number of steps."},
    {"set_log_function", set_log_function, METH_VARARGS, "calls logging"},
    {"set_logger", set_logger, METH_VARARGS, "Sets the logger to use"},
    {nullptr, nullptr, 0 , nullptr}
};

// Conditional compilation for python >= 3.0 (changed how python integration worked)
#if PY_MAJOR_VERSION >= 3
static int dispersal_traverse(PyObject *m, visitproc visit, void *arg)
{
    Py_VISIT(GETSTATE(m)\->error);
    return 0;
}

static int dispersal_clear(PyObject *m)
{
    Py_CLEAR(GETSTATE(m)\->error);
    return 0;
}

#endif


#if PY_MAJOR_VERSION >= 3
static struct PyModuleDef moduledef =
{
    PyModuleDef_HEAD_INIT,
    "dispersalmodule",
    nullptr,
    sizeof(struct module_state),
    DispersalMethods,
    nullptr,
    dispersal_traverse,
    dispersal_clear,
    nullptr
};


#define INITERROR return NULL

PyMODINIT_FUNC
PyInit_dispersalmodule(void)
#else
#define INITERROR return

PyMODINIT_FUNC
initdispersalmodule(void)
#endif
{
    PyObject *module;
    #if PY_MAJOR_VERSION>=3
    module = PyModule_Create(&moduledef);
    #else
    module = Py_InitModule("dispersalmodule", DispersalMethods);
    #endif
    if(module == nullptr)
    {
        INITERROR;
    }
    // Threading support
    if(!PyEval_ThreadsInitialized())
    {
        PyEval_InitThreads();

    }
    DispersalError = PyErr_NewException((char*)"dispersal.Error", nullptr, nullptr);
    Py_INCREF(DispersalError);
    PyModule_AddObject(module, "DispersalError", DispersalError);
    #if PY_MAJOR_VERSION >= 3
    return module;
    #endif
}
.ft P
.fi
.UNINDENT
.UNINDENT
.SS Detailed Description
.sp
Samuel Thompson
BSD\-3 Licence.
.SS Includes
.INDENT 0.0
.IP \(bu 2
\fB/Users/samthompson/Documents/PhD/Code/pycoalescence/pycoalescence/lib/necsim/Matrix.h\fP
.IP \(bu 2
\fB/Users/samthompson/Documents/PhD/Code/pycoalescence/pycoalescence/lib/necsim/NRrand.h\fP
.IP \(bu 2
\fBPyLogging.h\fP (file_PyLogging.h)
.IP \(bu 2
\fBPython.h\fP
.IP \(bu 2
\fBcmath\fP
.IP \(bu 2
\fBdispersalmodule.h\fP (file_dispersalmodule.h)
.IP \(bu 2
\fBfstream\fP
.IP \(bu 2
\fBiostream\fP
.IP \(bu 2
\fBnecsim/SimulateDispersal.h\fP (file_necsim_SimulateDispersal.h)
.IP \(bu 2
\fBsqlite3.h\fP
.IP \(bu 2
\fBstdexcept\fP
.IP \(bu 2
\fBstdio.h\fP
.IP \(bu 2
\fBstring\fP
.IP \(bu 2
\fBvector\fP
.UNINDENT
.SS Functions
.INDENT 0.0
.IP \(bu 2
function_initdispersalmodule
.IP \(bu 2
function_test_mean_dispersal
.IP \(bu 2
function_test_mean_distance_travelled
.UNINDENT
.SS Defines
.INDENT 0.0
.IP \(bu 2
define_INITERROR
.IP \(bu 2
define_PYTHON_COMPILE
.UNINDENT
.SS Variables
.INDENT 0.0
.IP \(bu 2
variable_DispersalMethods
.IP \(bu 2
variable_gstate
.IP \(bu 2
variable_log_set
.IP \(bu 2
variable_logger
.IP \(bu 2
variable_logger_set
.IP \(bu 2
variable_loggingmodule
.UNINDENT
.SS File dispersalmodule.h
.sp
Contains the functions for testing dispersal methods using efficient c++ routines.
.SS Contents
.INDENT 0.0
.IP \(bu 2
\fI\%Definition (dispersalmodule.h)\fP
.IP \(bu 2
\fI\%Detailed Description\fP
.IP \(bu 2
\fI\%Includes\fP
.IP \(bu 2
\fI\%Included By\fP
.IP \(bu 2
\fI\%Classes\fP
.IP \(bu 2
\fI\%Functions\fP
.IP \(bu 2
\fI\%Defines\fP
.IP \(bu 2
\fI\%Variables\fP
.UNINDENT
.SS Definition (\fBdispersalmodule.h\fP)
.SS Program Listing for File dispersalmodule.h
.INDENT 0.0
.IP \(bu 2
Return to documentation for file_dispersalmodule.h
.UNINDENT
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
// This file is part of NECSim project which is released under BSD\-3 license.
// See file **LICENSE.txt** or visit https://opensource.org/licenses/BSD\-3\-Clause) for full license details
#include <Python.h>
#ifndef PYTHON_COMPILE
#define PYTHON_COMPILE
#endif
#include <vector>
#include <string>



#ifndef DISPERSAL_IMPORT
#define DISPERSAL_IMPORT
using namespace std;
struct module_state
{
    PyObject *error;
};

#if PY_MAJOR_VERSION >= 3
#define GETSTATE(m) ((struct module_state*)PyModule_GetState(m))
#else
#define GETSTATE(m) (&_state)
static struct module_state _state;
#endif

static PyObject *DispersalError;

// Conditional compilation for python >= 3.0 (changed how python integration worked)
#if PY_MAJOR_VERSION >= 3
#define INITERROR return NULL

PyMODINIT_FUNC
PyInit_dispersalmodule(void)
#else
#define INITERROR return

PyMODINIT_FUNC
initdispersalmodule(void)
#endif
;
#endif
.ft P
.fi
.UNINDENT
.UNINDENT
.SS Detailed Description
.sp
Samuel Thompson
BSD\-3 Licence.
.SS Includes
.INDENT 0.0
.IP \(bu 2
\fBPython.h\fP
.IP \(bu 2
\fBstring\fP
.IP \(bu 2
\fBvector\fP
.UNINDENT
.SS Included By
.INDENT 0.0
.IP \(bu 2
file_dispersalmodule.cpp
.UNINDENT
.SS Classes
.INDENT 0.0
.IP \(bu 2
struct_module_state
.UNINDENT
.SS Functions
.INDENT 0.0
.IP \(bu 2
function_initdispersalmodule
.UNINDENT
.SS Defines
.INDENT 0.0
.IP \(bu 2
define_DISPERSAL_IMPORT
.IP \(bu 2
define_GETSTATE
.IP \(bu 2
define_INITERROR
.UNINDENT
.SS Variables
.INDENT 0.0
.IP \(bu 2
variable__state
.IP \(bu 2
variable_DispersalError
.UNINDENT
.SS File Filesystem.cpp
.sp
Contains routines for checking files and folder exist, opening sqlite databases safely, with support for various virtual filesystems, and checking parents of a file exist.
.SS Contents
.INDENT 0.0
.IP \(bu 2
\fI\%Definition (necsim/Filesystem.cpp)\fP
.IP \(bu 2
\fI\%Detailed Description\fP
.IP \(bu 2
\fI\%Includes\fP
.IP \(bu 2
\fI\%Functions\fP
.UNINDENT
.SS Definition (\fBnecsim/Filesystem.cpp\fP)
.SS Program Listing for File Filesystem.cpp
.INDENT 0.0
.IP \(bu 2
Return to documentation for file_necsim_Filesystem.cpp
.UNINDENT
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
// This file is part of NECSim project which is released under BSD\-3 license.
// See file **LICENSE.txt** or visit https://opensource.org/licenses/BSD\-3\-Clause) for full license details.

#include <string>
#include <sstream>
#include <zconf.h>
#include <boost/filesystem.hpp>
#include "Filesystem.h"
#include "CustomExceptions.h"
#include "Logging.h"

void openSQLiteDatabase(const string &database_name, sqlite3 * &database)
{
    int rc;
    if(database_name == ":memory:")
    {
        rc = sqlite3_open(":memory:", &database);
        if(rc != SQLITE_OK && rc != SQLITE_DONE)
        {
            stringstream ss;
            ss << "Could not connect to in\-memory database. Error: " << rc << endl;
            ss << " (" << sqlite3_errmsg(database) << ")" << endl;
            throw FatalException(ss.str());
        }
    }
    rc = sqlite3_open_v2(database_name.c_str(), &database, SQLITE_OPEN_READWRITE | SQLITE_OPEN_CREATE, "unix\-dotfile");
    if(rc != SQLITE_OK && rc != SQLITE_DONE)
    {
        int i = 0;
        while((rc != SQLITE_OK && rc != SQLITE_DONE) && i < 10)
        {
            i++;
            sleep(1);
            rc = sqlite3_open_v2(database_name.c_str(), &database, SQLITE_OPEN_READWRITE | SQLITE_OPEN_CREATE,
                                 "unix\-dotfile");
        }
        // Attempt different opening method if the first fails.
        int j = 0;
        while((rc != SQLITE_OK && rc != SQLITE_DONE) && j < 10)
        {
            j++;
            sleep(1);
            rc = sqlite3_open(database_name.c_str(), &database);
        }
        if(rc != SQLITE_OK && rc != SQLITE_DONE)
        {
            stringstream ss;
            ss << "ERROR_SQL_010: SQLite database file could not be opened. Check the folder exists and you "
                    "have write permissions. (REF1) Error code: "
                 << rc << endl;
            ss << " Attempted call " << max(i, j) << " times" << endl;
            throw FatalException(ss.str());
        }
    }
}

void createParent(const string &file)
{
    boost::filesystem::path file_path(file);
    if(!boost::filesystem::exists(file_path.parent_path()))
    {
        if(!boost::filesystem::create_directories(file_path.parent_path()))
        {
            throw FatalException("Cannot create parent folder for " + file);
        }
    }
}



bool doesExist(string testfile)
{
    if(boost::filesystem::exists(testfile))
    {
        stringstream os;
        os << "\erChecking folder existance..." << testfile << " exists!               " << endl;
        writeInfo(os.str());
        return true;
    }
    else
    {
        throw runtime_error(string("ERROR_MAIN_008: FATAL. Input or output folder does not exist: " + testfile + "."));
    }
}

bool doesExistNull(string testfile)
{
    return testfile == "null" || testfile == "none" || doesExist(testfile);
}

unsigned long cantorPairing(unsigned long x1, unsigned long x2)
{
    return ((x1 + x2) * (x1 + x2 + 1)/2) + x2;
}
.ft P
.fi
.UNINDENT
.UNINDENT
.SS Detailed Description
.sp
Samuel Thompson
19/07/2017
BSD\-3 Licence. Contact: \fI\%samuel.thompson14@imperial.ac.uk\fP or \fI\%thompsonsed@gmail.com\fP
.SS Includes
.INDENT 0.0
.IP \(bu 2
\fBCustomExceptions.h\fP (file_necsim_CustomExceptions.h)
.IP \(bu 2
\fBFilesystem.h\fP (file_necsim_Filesystem.h)
.IP \(bu 2
\fBLogging.h\fP (file_necsim_Logging.h)
.IP \(bu 2
\fBboost/filesystem.hpp\fP
.IP \(bu 2
\fBsstream\fP
.IP \(bu 2
\fBstring\fP
.IP \(bu 2
\fBzconf.h\fP
.UNINDENT
.SS Functions
.INDENT 0.0
.IP \(bu 2
function_cantorPairing
.IP \(bu 2
function_createParent
.IP \(bu 2
function_doesExist
.IP \(bu 2
function_doesExistNull
.IP \(bu 2
function_openSQLiteDatabase
.UNINDENT
.SS File Filesystem.h
.sp
Contains routines for checking files and folder exist, opening sqlite databases safely, with support for various virtual filesystems, and checking parents of a file exist.
.SS Contents
.INDENT 0.0
.IP \(bu 2
\fI\%Definition (necsim/Filesystem.h)\fP
.IP \(bu 2
\fI\%Detailed Description\fP
.IP \(bu 2
\fI\%Includes\fP
.IP \(bu 2
\fI\%Included By\fP
.IP \(bu 2
\fI\%Functions\fP
.UNINDENT
.SS Definition (\fBnecsim/Filesystem.h\fP)
.SS Program Listing for File Filesystem.h
.INDENT 0.0
.IP \(bu 2
Return to documentation for file_necsim_Filesystem.h
.UNINDENT
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
// This file is part of NECSim project which is released under BSD\-3 license.
// See file **LICENSE.txt** or visit https://opensource.org/licenses/BSD\-3\-Clause) for full license details.

#include <sqlite3.h>
#include <string>

#ifndef SPECIATIONCOUNTER_FILESYSTEM_H
#define SPECIATIONCOUNTER_FILESYSTEM_H

using namespace std;

void openSQLiteDatabase(const string &database_name, sqlite3 *& database);

void createParent(const string &file);


bool doesExist(string testfile);

bool doesExistNull(string testfile);

unsigned long cantorPairing(unsigned long x1, unsigned long x2);

#endif //SPECIATIONCOUNTER_FILESYSTEM_H
.ft P
.fi
.UNINDENT
.UNINDENT
.SS Detailed Description
.sp
Samuel Thompson
19/07/2017
BSD\-3 Licence. Contact: \fI\%samuel.thompson14@imperial.ac.uk\fP or \fI\%thompsonsed@gmail.com\fP
.SS Includes
.INDENT 0.0
.IP \(bu 2
\fBsqlite3.h\fP
.IP \(bu 2
\fBstring\fP
.UNINDENT
.SS Included By
.INDENT 0.0
.IP \(bu 2
file_necsim_Community.cpp
.IP \(bu 2
file_necsim_Filesystem.cpp
.IP \(bu 2
file_necsim_LogFile.cpp
.IP \(bu 2
file_necsim_Tree.h
.IP \(bu 2
file_necsim_Map.cpp
.IP \(bu 2
file_necsim_SimulateDispersal.cpp
.UNINDENT
.SS Functions
.INDENT 0.0
.IP \(bu 2
function_cantorPairing
.IP \(bu 2
function_createParent
.IP \(bu 2
function_doesExist
.IP \(bu 2
function_doesExistNull
.IP \(bu 2
function_openSQLiteDatabase
.UNINDENT
.SS File LicenseHeader.h
.SS Contents
.INDENT 0.0
.IP \(bu 2
\fI\%Definition (necsim/LicenseHeader.h)\fP
.UNINDENT
.SS Definition (\fBnecsim/LicenseHeader.h\fP)
.SS Program Listing for File LicenseHeader.h
.INDENT 0.0
.IP \(bu 2
Return to documentation for file_necsim_LicenseHeader.h
.UNINDENT
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
//This file is part of Coalescence_Sim project which is released under BSD\-3 license.
//See file **LICENSE.txt** or visit https://opensource.org/licenses/BSD\-3\-Clause) for full license details.
.ft P
.fi
.UNINDENT
.UNINDENT
.SS File LogFile.cpp
.sp
Contains a class for logging to a logfile, including reporting level and timestamps.
.SS Contents
.INDENT 0.0
.IP \(bu 2
\fI\%Definition (necsim/LogFile.cpp)\fP
.IP \(bu 2
\fI\%Detailed Description\fP
.IP \(bu 2
\fI\%Includes\fP
.IP \(bu 2
\fI\%Functions\fP
.UNINDENT
.SS Definition (\fBnecsim/LogFile.cpp\fP)
.SS Program Listing for File LogFile.cpp
.INDENT 0.0
.IP \(bu 2
Return to documentation for file_necsim_LogFile.cpp
.UNINDENT
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
// This file is part of NECSim project which is released under BSD\-3 license.
// See file **LICENSE.txt** or visit https://opensource.org/licenses/BSD\-3\-Clause) for full license details.
#include <sstream>
#include <iomanip>
#include <boost/filesystem.hpp>
#include "LogFile.h"
#include "Filesystem.h"

string getTime()
{
#ifdef DEBUG
    auto t = time(nullptr);
    auto tm = *localtime(&t);
    stringstream ss;
    ss << put_time(&tm, LOGNAME_FORMAT);
    return ss.str();
#endif
    return string("");
}

string getDefaultLogFile()
{
    time_t now = time(0);
    static char name[30];
    strftime(name, sizeof(name), LOGNAME_FORMAT, localtime(&now));
    string out = "log/" + string(name) + ".log";
    return out;
}

void getUniqueFileName(string &basic_string)
{
    boost::filesystem::path file_path(basic_string);
    const string file_name = basic_string.substr(0, basic_string.find(\(aq.\(aq));
    const string file_extension = basic_string.substr(basic_string.find(\(aq.\(aq));
    unsigned long iterator = 0;
    while(boost::filesystem::exists(file_path) && iterator < 10000000)
    {
        if(iterator > 10000000)
        {
            basic_string = file_name + file_extension;
            throw FatalException("Could not create unique file name after 10000000 tries.");
        }
        basic_string = file_name + "_" + to_string(iterator) + file_extension; // NOLINT
        file_path = boost::filesystem::path(basic_string);
        iterator ++;
    }
}
LogFile::LogFile()
{
    init(getDefaultLogFile());
}

LogFile::LogFile(const string &file_name_in)
{
    init(file_name_in);
}


LogFile::~LogFile()
{

    output_stream << getTime() << " LOGGING ENDED" << endl;
    output_stream.close();
}


void LogFile::init(const string &file_name_in)
{
    createParent(file_name_in);
    file_name = file_name_in;
    getUniqueFileName(file_name);
    output_stream.open(file_name);
    if(!output_stream)
    {
        throw FatalException("Could not create log file at " + file_name_in + ".");
    }
    levels_map[0] = "noneset";
    levels_map[10] = "debug";
    levels_map[20] = "info";
    levels_map[30] = "warning";
    levels_map[40] = "error";
    levels_map[50] = "critical";
    output_stream << getTime() << " LOGGING STARTED" << endl;
}

void LogFile::write(const int &level, string message)
{
    if(levels_map.count(level) == 0)
    {
        throw FatalException("Logging level must be one of 0, 10, 20, 30, 40 or 50.");
    }
    output_stream << getTime() << " ";
    replace(message.begin(), message.end(), \(aq\en\(aq, \(aq \(aq);
    output_stream << levels_map[level] << ": " << message << endl;

}

void LogFile::write(const int &level, stringstream &message)
{
    write(level, message.str());
}
.ft P
.fi
.UNINDENT
.UNINDENT
.SS Detailed Description
.sp
Sam Thompson
BSD\-3 Licence.
.SS Includes
.INDENT 0.0
.IP \(bu 2
\fBFilesystem.h\fP (file_necsim_Filesystem.h)
.IP \(bu 2
\fBLogFile.h\fP (file_necsim_LogFile.h)
.IP \(bu 2
\fBboost/filesystem.hpp\fP
.IP \(bu 2
\fBiomanip\fP
.IP \(bu 2
\fBsstream\fP
.UNINDENT
.SS Functions
.INDENT 0.0
.IP \(bu 2
function_getDefaultLogFile
.IP \(bu 2
function_getTime
.IP \(bu 2
function_getUniqueFileName
.UNINDENT
.SS File LogFile.h
.sp
Contains a class for logging to a logfile, including reporting level and timestamps.
.SS Contents
.INDENT 0.0
.IP \(bu 2
\fI\%Definition (necsim/LogFile.h)\fP
.IP \(bu 2
\fI\%Detailed Description\fP
.IP \(bu 2
\fI\%Includes\fP
.IP \(bu 2
\fI\%Included By\fP
.IP \(bu 2
\fI\%Classes\fP
.IP \(bu 2
\fI\%Functions\fP
.IP \(bu 2
\fI\%Defines\fP
.UNINDENT
.SS Definition (\fBnecsim/LogFile.h\fP)
.SS Program Listing for File LogFile.h
.INDENT 0.0
.IP \(bu 2
Return to documentation for file_necsim_LogFile.h
.UNINDENT
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
// This file is part of NECSim project which is released under BSD\-3 license.
// See file **LICENSE.txt** or visit https://opensource.org/licenses/BSD\-3\-Clause) for full license details.
#ifndef LOGFILE_H
#define LOGFILE_H

#include <cstring>
#include <fstream>
#include <ctime>
#include <map>
#include "CustomExceptions.h"
#define LOGNAME_FORMAT "%d%m%Y_%H%M%S"

using namespace std;
string getDefaultLogFile();

void getUniqueFileName(string &basic_string);

class LogFile
{
protected:
    // output stream to log file
    ofstream output_stream;
    // log file name
    string file_name;
    // mapping integer levels to logging level
    map<int, string> levels_map;
    // Makes the class non\-copyable as we don\(aqt want to copy file streams
    LogFile(const LogFile&) = delete;
    LogFile& operator=(const LogFile&) = delete;
public:
    LogFile();

    explicit LogFile(const string &file_name_in);
    ~LogFile();

    void init(const string &file_name_in);

    void write(const int &level, string message);

    void write(const int &level, stringstream &message);
};


#endif //LOGFILE_H
.ft P
.fi
.UNINDENT
.UNINDENT
.SS Detailed Description
.sp
Sam Thompson
BSD\-3 Licence.
.SS Includes
.INDENT 0.0
.IP \(bu 2
\fBCustomExceptions.h\fP (file_necsim_CustomExceptions.h)
.IP \(bu 2
\fBcstring\fP
.IP \(bu 2
\fBctime\fP
.IP \(bu 2
\fBfstream\fP
.IP \(bu 2
\fBmap\fP
.UNINDENT
.SS Included By
.INDENT 0.0
.IP \(bu 2
file_necsim_Logging.h
.IP \(bu 2
file_necsim_LogFile.cpp
.UNINDENT
.SS Classes
.INDENT 0.0
.IP \(bu 2
class_LogFile
.UNINDENT
.SS Functions
.INDENT 0.0
.IP \(bu 2
function_getDefaultLogFile
.IP \(bu 2
function_getUniqueFileName
.UNINDENT
.SS Defines
.INDENT 0.0
.IP \(bu 2
define_LOGNAME_FORMAT
.UNINDENT
.SS File Logging.cpp
.sp
Routines for writing to cout. Intended to be overloaded for pythonic versions with the logging module.
.SS Contents
.INDENT 0.0
.IP \(bu 2
\fI\%Definition (necsim/Logging.cpp)\fP
.IP \(bu 2
\fI\%Detailed Description\fP
.IP \(bu 2
\fI\%Includes\fP
.IP \(bu 2
\fI\%Functions\fP
.UNINDENT
.SS Definition (\fBnecsim/Logging.cpp\fP)
.SS Program Listing for File Logging.cpp
.INDENT 0.0
.IP \(bu 2
Return to documentation for file_necsim_Logging.cpp
.UNINDENT
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
// This file is part of NECSim project which is released under BSD\-3 license.
// See file **LICENSE.txt** or visit https://opensource.org/licenses/BSD\-3\-Clause) for full license details.
#include <sstream>
#include "Logging.h"


using namespace std;

void writeInfo(string message)
{
#ifdef DEBUG
    writeLog(10, message);
#endif // DEBUG
    cout << message << flush;
}

void writeWarning(string message)
{
#ifdef DEBUG
    writeLog(20, message);
#endif // DEBUG
    cerr << message << flush;
}

void writeError(string message)
{
#ifdef DEBUG
    writeLog(30, message);
#endif // DEBUG
    cerr << message << flush;
}

void writeCritical(string message)
{
#ifdef DEBUG
    writeLog(40, message);
#endif // DEBUG
    cerr << message << flush;
}

#ifdef DEBUG
void writeLog(const int &level, string message)
{
    static LogFile logfile;
    logfile.write(level, std::move(message));
}

void writeLog(const int &level, stringstream &message)
{
    writeLog(level, message.str());
}

#endif // DEBUG
.ft P
.fi
.UNINDENT
.UNINDENT
.SS Detailed Description
.sp
Sam Thompson
BSD\-3 Licence.
.SS Includes
.INDENT 0.0
.IP \(bu 2
\fBLogging.h\fP (file_necsim_Logging.h)
.IP \(bu 2
\fBsstream\fP
.UNINDENT
.SS Functions
.INDENT 0.0
.IP \(bu 2
function_writeCritical
.IP \(bu 2
function_writeError
.IP \(bu 2
function_writeInfo
.IP \(bu 2
function_writeWarning
.UNINDENT
.SS File Logging.h
.sp
Routines for writing to cout. Intended to be overloaded for pythonic versions with the logging module.
.SS Contents
.INDENT 0.0
.IP \(bu 2
\fI\%Definition (necsim/Logging.h)\fP
.IP \(bu 2
\fI\%Detailed Description\fP
.IP \(bu 2
\fI\%Includes\fP
.IP \(bu 2
\fI\%Included By\fP
.UNINDENT
.SS Definition (\fBnecsim/Logging.h\fP)
.SS Program Listing for File Logging.h
.INDENT 0.0
.IP \(bu 2
Return to documentation for file_necsim_Logging.h
.UNINDENT
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
// This file is part of NECSim project which is released under BSD\-3 license.
// See file **LICENSE.txt** or visit https://opensource.org/licenses/BSD\-3\-Clause) for full license details.
#include <string>
#include <iostream>
#include <cstdio>
#include <stdexcept>
#include "LogFile.h"

using namespace std;
#ifndef LOGGING_IMPORT
#define LOGGING_IMPORT

void writeInfo(string message);

void writeWarning(string message);

void writeError(string message);

void writeCritical(string message);


#ifdef DEBUG

void writeLog(const int &level, string message);

void writeLog(const int &level, stringstream &message);
#endif
#endif
.ft P
.fi
.UNINDENT
.UNINDENT
.SS Detailed Description
.sp
Sam Thompson
BSD\-3 Licence.
.SS Includes
.INDENT 0.0
.IP \(bu 2
\fBLogFile.h\fP (file_necsim_LogFile.h)
.IP \(bu 2
\fBcstdio\fP
.IP \(bu 2
\fBiostream\fP
.IP \(bu 2
\fBstdexcept\fP
.IP \(bu 2
\fBstring\fP
.UNINDENT
.SS Included By
.INDENT 0.0
.IP \(bu 2
file_necsim_TreeNode.h
.IP \(bu 2
file_necsim_CustomExceptions.h
.IP \(bu 2
file_necsim_Matrix.h
.IP \(bu 2
file_necsim_SimParameters.h
.IP \(bu 2
file_necsim_ConfigFileParser.cpp
.IP \(bu 2
file_necsim_DataMask.cpp
.IP \(bu 2
file_necsim_DataPoint.h
.IP \(bu 2
file_necsim_NRrand.h
.IP \(bu 2
file_necsim_Filesystem.cpp
.IP \(bu 2
file_necsim_Logging.cpp
.IP \(bu 2
file_necsim_SpatialTree.h
.IP \(bu 2
file_necsim_SimulationTemplates.h
.IP \(bu 2
file_necsim_Setup.cpp
.IP \(bu 2
file_necsim_TreeNode.cpp
.UNINDENT
.SS File main.cpp
.sp
A generic simulator for spatially explicit coalescence models suitable for HPC applications. It contains all functions for running large\-scale simulations backwards in time using coalescence techniques. Outputs include an SQLite database containing spatial and temporal information about tracked lineages, and allow for rebuilding of the coalescence tree. Currently, a fat\-tailed dispersal kernel or normal distribution can be used for dispersal processes.
.SS Contents
.INDENT 0.0
.IP \(bu 2
\fI\%Definition (necsim/main.cpp)\fP
.IP \(bu 2
\fI\%Detailed Description\fP
.IP \(bu 2
\fI\%Includes\fP
.IP \(bu 2
\fI\%Functions\fP
.UNINDENT
.SS Definition (\fBnecsim/main.cpp\fP)
.SS Program Listing for File main.cpp
.INDENT 0.0
.IP \(bu 2
Return to documentation for file_necsim_main.cpp
.UNINDENT
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
// This file is part of NECSim project which is released under BSD\-3 license.
// See file **LICENSE.txt** or visit https://opensource.org/licenses/BSD\-3\-Clause) for full license details.
#ifdef DEBUG
#ifndef verbose
#define verbose
#endif
#endif

#include "SpatialTree.h"
#include "SimulationTemplates.h"

// #define pristine_mode // not required unless you experience problems.
// This performs a more thorough check after each move operation.
// Currently, it will also check that the pristine state value is greater than the returned value within every map cell.
// Note that this may cause problems if the pristine state is not the state with the highest number of individuals.



/************************************************************
        MAIN ROUTINE AND COMMAND LINE ARG ROUTINES

 ************************************************************/



int main(int argc, char *argv[])
{
    vector<string> comargs;
    importArgs(static_cast<const unsigned int &>(argc), argv, comargs);
    const string &config_file = getConfigFileFromCmdArgs(comargs);
    runMain<SpatialTree>(config_file);
    return 0;
}
.ft P
.fi
.UNINDENT
.UNINDENT
.SS Detailed Description
.sp
Run with \-h to see full input options.
Outputs include
.INDENT 0.0
.IP \(bu 2
habitat map file(s)
.IP \(bu 2
species richness and species abundances for the supplied minimum speciation rate.
.IP \(bu 2
SQL database containing full spatial data. This can be later analysed by the Speciation_Counter program for applying higher speciation rates.
.UNINDENT
.sp
Contact: \fI\%samuel.thompson14@imperial.ac.uk\fP or \fI\%thompsonsed@gmail.com\fP
Based heavily on code written by James Rosindell
Contact: \fI\%j.rosindell@imperial.ac.uk\fP
Samuel Thompson
BSD\-3 Licence.
.SS Includes
.INDENT 0.0
.IP \(bu 2
\fBSimulationTemplates.h\fP (file_necsim_SimulationTemplates.h)
.IP \(bu 2
\fBSpatialTree.h\fP (file_necsim_ProtractedSpatialTree.h)
.UNINDENT
.SS Functions
.INDENT 0.0
.IP \(bu 2
function_main
.UNINDENT
.SS File Map.cpp
.sp
Contains the class_Map class implementation for easy referencing of the respective coarse and fine map within the same coordinate system.
.SS Contents
.INDENT 0.0
.IP \(bu 2
\fI\%Definition (necsim/Map.cpp)\fP
.IP \(bu 2
\fI\%Detailed Description\fP
.IP \(bu 2
\fI\%Includes\fP
.UNINDENT
.SS Definition (\fBnecsim/Map.cpp\fP)
.SS Program Listing for File Map.cpp
.INDENT 0.0
.IP \(bu 2
Return to documentation for file_necsim_Map.cpp
.UNINDENT
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
// This file is part of NECSim project which is released under BSD\-3 license.
// See file **LICENSE.txt** or visit https://opensource.org/licenses/BSD\-3\-Clause) for full license details
#include "Map.h"
#include "Filesystem.h"
#include "CustomExceptions.h"

void Map::setDims(SimParameters mapvarsin)
{
    if(!check_set_dim)  // checks to make sure it hasn\(aqt been run already.
    {
        mapvars = mapvarsin;
        deme = mapvarsin.deme;
        x_dim = mapvarsin.grid_x_size;
        y_dim = mapvarsin.grid_y_size;
        scale = mapvarsin.coarse_map_scale;
        nUpdate = 0;
        check_set_dim = true;
        update_time = 0;
        gen_since_pristine = mapvarsin.gen_since_pristine;
        if(gen_since_pristine == 0)
        {
            gen_since_pristine = 0.000000000000000001;
        }
        habitat_change_rate = mapvarsin.habitat_change_rate;
        landscape_type = mapvarsin.landscape_type;
    }
    else
    {
        cerr << "ERROR_MAP_001: Dimensions have already been set" << endl;
        return;
    }
    return;
}

bool Map::checkMapExists()
{
    for(unsigned int i = 0; i < mapvars.configs.getSectionOptionsSize(); i++)
    {
        string tmppath = mapvars.configs[i].getOption("path");
        if(!doesExistNull(tmppath))
        {
            return (false);
        }
    }
    return (true);
}

void Map::calcFineMap()
{
    string fileinput = mapvars.fine_map_file;
    unsigned long mapxsize = mapvars.fine_map_x_size;
    unsigned long mapysize = mapvars.fine_map_y_size;
    if(!check_set_dim)  // checks that the dimensions have been set.
    {
        throw FatalException("ERROR_MAP_002: dimensions not set.");
    }
    // Note that the default "null" type is to have 100% forest cover in every cell.
    #ifndef SIZE_LIMIT
    if(mapxsize > 1000000 || mapysize > 1000000)
    {
        throw runtime_error("Extremely large map sizes set for " + fileinput + ": " + to_string(mapxsize) + ", " + to_string(mapysize) + "\en");
    }
    #endif
    Matrix<float> toret;
    toret.SetSize(mapysize, mapxsize);
    fine_map.SetSize(mapysize, mapxsize);
#ifdef DEBUG
    writeInfo("Calculating fine map");
#endif
    if(fileinput == "null")
    {
        for(unsigned long i = 0; i < mapysize; i++)
        {
            for(unsigned long j = 0; j < mapxsize; j++)
            {
                toret[i][j] = 1.0;
            }
        }
    }
    else  // There is a map to read in.
    {
        toret.import(fileinput);
    }
#ifdef DEBUG
    writeInfo("import complete");
#endif
    fine_max = 0;

    for(unsigned long i = 0; i < mapysize; i++)
    {
        for(unsigned long j = 0; j < mapxsize; j++)
        {
            fine_map[i][j] = (unsigned long)(max((double)round(toret[i][j] * deme), 0.0));
            if(fine_map[i][j] > fine_max)
            {
                fine_max = fine_map[i][j];
            }
        }
    }
}

void Map::calcPristineFineMap()
{
    string fileinput = mapvars.pristine_fine_map_file;
    unsigned long mapxsize = mapvars.fine_map_x_size;
    unsigned long mapysize = mapvars.fine_map_y_size;
    if(!check_set_dim)  // checks that the dimensions have been set.
    {
        throw FatalException("ERROR_MAP_002: dimensions not set.");
    }
    #ifndef SIZE_LIMIT
    if(mapxsize > 1000000 || mapysize > 1000000)
    {
        throw runtime_error("Extremely large map sizes set for " + fileinput + ": " + to_string(mapxsize) + ", " + to_string(mapysize) + "\en");
    }
    #endif
    // Note that the default "null" type is to have 100% forest cover in every cell.
    Matrix<float> toret;
    has_pristine = true;
    pristine_fine_max = 0;
    if(fileinput == "null")
    {
        toret.SetSize(mapysize, mapxsize);
        pristine_fine_map.SetSize(mapysize, mapxsize);
        for(unsigned long i = 0; i < mapxsize; i++)
        {
            for(unsigned long j = 0; j < mapysize; j++)
            {
                toret[j][i] = 1.0;
            }
        }
    }
    else if(fileinput == "none")
    {
        has_pristine = false;
    }
    else  // There is a map to read in.
    {
        toret.SetSize(mapysize, mapxsize);
        pristine_fine_map.SetSize(mapysize, mapxsize);
        toret.import(fileinput);
    }
    // os << toret << endl;
    if(has_pristine)
    {
        for(unsigned long i = 0; i < mapysize; i++)
        {
            for(unsigned long j = 0; j < mapxsize; j++)
            {
                pristine_fine_map[i][j] = (unsigned long)(max((double)round(toret[i][j] * deme), 0.0));
                if(pristine_fine_map[i][j] > pristine_fine_max)
                {
                    pristine_fine_max = pristine_fine_map[i][j];
                }
            }
        }
    }
    return;
}

void Map::calcCoarseMap()
{
    string fileinput = mapvars.coarse_map_file;
    unsigned long mapxsize = mapvars.coarse_map_x_size;
    unsigned long mapysize = mapvars.coarse_map_y_size;
    if(!check_set_dim)  // checks that the dimensions have been set.
    {
        throw FatalException("ERROR_MAP_003: dimensions not set.");
    }
    #ifndef SIZE_LIMIT
    if(mapxsize > 1000000 || mapysize > 1000000)
    {
        throw runtime_error("Extremely large map sizes set for " + fileinput + ": " + to_string(mapxsize) + ", " + to_string(mapysize) + "\en");
    }
    #endif
    // Note that the default "null" type for the coarse type is to have a density of 1 in every cell. "none" defaults to no
    // pristine map
    Matrix<float> toret;
    bCoarse = true;
    coarse_max = 0;
    if(fileinput == "null")
    {
        toret.SetSize(mapysize, mapxsize);
        coarse_map.SetSize(mapysize, mapxsize);
        for(unsigned long i = 0; i < mapxsize; i++)
        {
            for(unsigned long j = 0; j < mapysize; j++)
            {
                toret[j][i] = 1.0;
            }
        }
    }
    else if(fileinput == "none")
    {
        bCoarse = false;
    }
    else  // There is a map to read in.
    {
        toret.SetSize(mapysize, mapxsize);
        coarse_map.SetSize(mapysize, mapxsize);
        toret.import(fileinput);
    }
    if(bCoarse)
    {
        for(unsigned long i = 0; i < mapysize; i++)
        {
            for(unsigned long j = 0; j < mapxsize; j++)
            {
                coarse_map[i][j] = (unsigned long)(max((double)round(toret[i][j] * deme), 0.0));
                if(coarse_map[i][j] > coarse_max)
                {
                    coarse_max = coarse_map[i][j];
                }
            }
        }
    }
    return;
}

void Map::calcPristineCoarseMap()
{
    //  os << "pristine coarse map file: " << mapvars.pristine_coarse_map_file << endl;
    string fileinput = mapvars.pristine_coarse_map_file;
    unsigned long mapxsize = mapvars.coarse_map_x_size;
    unsigned long mapysize = mapvars.coarse_map_y_size;
    if(!check_set_dim)  // checks that the dimensions have been set.
    {
        throw FatalException("ERROR_MAP_003: dimensions not set.");
    }
    #ifndef SIZE_LIMIT
    if(mapxsize > 1000000 || mapysize > 1000000)
    {
        throw runtime_error("Extremely large map sizes set for " + fileinput + ": " + to_string(mapxsize) + ", " + to_string(mapysize) + "\en");
    }
    #endif
    // Note that the default "null" type for the coarse type is to have non\-forest in every cell.
    Matrix<float> toret;
    pristine_coarse_max = 0;
    if(bCoarse)
    {
        if(fileinput == "null")
        {
            toret.SetSize(mapysize, mapxsize);
            pristine_coarse_map.SetSize(mapysize, mapxsize);
            for(unsigned long i = 0; i < mapxsize; i++)
            {
                for(unsigned long j = 0; j < mapysize; j++)
                {
                    toret[j][i] = 1.0;
                }
            }
        }
        else if(fileinput == "none")
        {
            has_pristine = false;
        }
        else  // There is a map to read in.
        {
            toret.SetSize(mapysize, mapxsize);
            pristine_coarse_map.SetSize(mapysize, mapxsize);
            toret.import(fileinput);
        }
    }
    if(bCoarse && has_pristine)
    {
        for(unsigned long i = 0; i < mapysize; i++)
        {
            for(unsigned long j = 0; j < mapxsize; j++)
            {
                pristine_coarse_map[i][j] = (unsigned long)(max((double)round(toret[i][j] * deme), 0.0));
                if(pristine_coarse_map[i][j] > pristine_coarse_max)
                {
                    pristine_coarse_max = pristine_coarse_map[i][j];
                }
            }
        }
    }
    return;
}

void Map::setTimeVars(double gen_since_pristine_in, double habitat_change_rate_in)
{
    update_time = 0;
    gen_since_pristine = gen_since_pristine_in;
    habitat_change_rate = habitat_change_rate_in;
}

void Map::calcOffset()
{
    if(mapvars.times_file != "null")
    {
        mapvars.setPristine(0);
    }
    //  os << mapvars.times_file << endl;
    if(fine_map.GetCols() == 0 || fine_map.GetRows() == 0)
    {
        throw FatalException("ERROR_MAP_004: fine map not set.");
    }
    if(coarse_map.GetCols() == 0 || coarse_map.GetRows() == 0)
    {
        if(bCoarse)
        {
            coarse_map.SetSize(fine_map.GetRows(), fine_map.GetCols());
        }
        //      throw FatalException("ERROR_MAP_004: coarse map not set.");
    }
    fine_x_offset = mapvars.fine_map_x_offset + mapvars.sample_x_offset;
    fine_y_offset = mapvars.fine_map_y_offset + mapvars.sample_y_offset;
    coarse_x_offset = mapvars.coarse_map_x_offset;
    coarse_y_offset = mapvars.coarse_map_y_offset;
    scale = mapvars.coarse_map_scale;
    // this is the location of the top left (or north west) corner of the respective map
    // and the x and y distance from the top left of the grid object that contains the initial lineages.
    fine_x_min = \-fine_x_offset;
    fine_y_min = \-fine_y_offset;
    fine_x_max = fine_x_min + (fine_map.GetCols());
    fine_y_max = fine_y_min + (fine_map.GetRows());
    if(bCoarse) // Check if there is a coarse map
    {
        coarse_x_min = \-coarse_x_offset \- fine_x_offset;
        coarse_y_min = \-coarse_y_offset \- fine_y_offset;
        coarse_x_max = coarse_x_min + scale * (coarse_map.GetCols());
        coarse_y_max = coarse_y_min + scale * (coarse_map.GetRows());
    }
    else // Just set the offsets to the same as the fine map
    {
        coarse_x_min = fine_x_min;
        coarse_y_min = fine_y_min;
        coarse_x_max = fine_x_max;
        coarse_y_max = fine_y_max;
        scale = 1;
    }
    dispersal_relative_cost = mapvars.dispersal_relative_cost;
#ifdef DEBUG
    stringstream os;
    os << "finex: " << fine_x_min << "," << fine_x_max << endl;
    os << "finey: " << fine_y_min << "," << fine_y_max << endl;
    os << "coarsex: " << coarse_x_min << "," << coarse_x_max << endl;
    os << "coarsey: " << coarse_y_min << "," << coarse_y_max << endl;
    os << "offsets: "
         << "(" << fine_x_offset << "," << fine_y_offset << ")(" << coarse_x_offset << "," << coarse_y_offset << ")" << endl;
    os << "pristine fine file: " << pristine_fine_map << endl;
    os << "pristine coarse file: " << pristine_coarse_map << endl;
    writeInfo(os.str());
#endif
    //      os << "fine variables: " << finexmin << "," << fine_x_max << endl;
    //      os << "coarse variabes: " << coarse_x_min << "," << coarse_x_max << endl;
    if(fine_x_min < coarse_x_min || fine_x_max > coarse_x_max || (fine_x_max \- fine_x_min) < x_dim || (fine_y_max \- fine_y_min) < y_dim)
    {
        throw FatalException(
            "ERROR_MAP_006: FATAL \- fine map extremes outside coarse map or sample grid larger than fine map");
    }
    return;
}

void Map::validateMaps()
{
    stringstream os;
    os << "\erValidating maps..." << flush;
    double dTotal = fine_map.GetCols() + coarse_map.GetCols();
    unsigned long iCounter = 0;
    if(has_pristine)
    {
        if(fine_map.GetCols() == pristine_fine_map.GetCols() && fine_map.GetRows() == pristine_fine_map.GetRows() &&
           coarse_map.GetCols() == pristine_coarse_map.GetCols() && coarse_map.GetRows() == pristine_coarse_map.GetRows())
        {
            os << "\erValidating maps...map sizes okay" << flush;
            writeInfo(os.str());
        }
        else
        {
            throw FatalException(
                    "ERROR_MAP_009: Map validation failed \- modern and pristine maps are not the same dimensions.");
        }
        for(unsigned long i = 0; i < fine_map.GetCols(); i++)
        {
            for(unsigned long j = 0; j < fine_map.GetRows(); j++)
            {
                if(fine_map[j][i] > pristine_fine_map[j][i])
                {
#ifdef DEBUG
                    stringstream ss;
                    ss << "fine map: " << fine_map[j][i] << " pristine map: " << pristine_fine_map[j][i];
                    ss << " x,y: " << i << "," << j << endl;
                    writeLog(50, ss);
#endif //DEBUG
                    throw FatalException("ERROR_MAP_007: Map validation failed \- fine map value larger "
                                              "than pristine fine map value.");
                }
            }
            double dPercentComplete = 100 * ((double)(i + iCounter) / dTotal);
            if(i % 1000 == 0)
            {
                os.str("");
                os << "\erValidating maps..." << dPercentComplete << "%                " << flush;
                writeInfo(os.str());
            }
        }
    }
    iCounter = fine_map.GetCols();
    if(has_pristine)
    {
        for(unsigned long i = 0; i < coarse_map.GetCols(); i++)
        {
            for(unsigned long j = 0; j < coarse_map.GetRows(); j++)
            {
                if(coarse_map[j][i] > pristine_coarse_map[j][i])
                {
#ifdef DEBUG
                    stringstream ss;
                    ss << "coarse map: " << coarse_map[j][i] << " pristine map: " << pristine_coarse_map[j][i];
                    ss << " coarse map x+1: " << coarse_map[j][i + 1]
                         << " pristine map: " << pristine_coarse_map[j][i + 1];
                    ss << " x,y: " << i << "," << j;
                    writeLog(50, ss);
#endif // DEBUG
                    throw FatalException("ERROR_MAP_008: Map validation failed \- coarse map value larger "
                                              "than pristine coarse map value.");
                }
            }
            double dPercentComplete = 100 * ((double)(i + iCounter) / dTotal);
            if(i % 1000 == 0)
            {
                os.str("");
                os << "\erValidating maps..." << dPercentComplete << "%                " << flush;
                writeInfo(os.str());
            }
        }

    }
    os.str("");
    os << "\erValidating maps complete                                       " << endl;
    writeInfo(os.str());
}

void Map::updateMap(double generation)
{
    // only update the map if the pristine state has not been reached.
    if(!mapvars.is_pristine && has_pristine)
    {
        if(mapvars.gen_since_pristine < generation)
        {
            // Only update the map if the maps have actually changed
            if(mapvars.setPristine(nUpdate+1))
            {
                nUpdate++;
                // pristine_fine_map = mapvars.pristine_fine_map_file;
                // pristine_coarse_map = mapvars.pristine_coarse_map_file;
                current_map_time = gen_since_pristine;
                gen_since_pristine = mapvars.gen_since_pristine;
                if(gen_since_pristine == 0)
                {
                    gen_since_pristine = 0.000000000000000001;
                }
                habitat_change_rate = mapvars.habitat_change_rate;
                fine_max = pristine_fine_max;
                fine_map = pristine_fine_map;
                coarse_max = pristine_coarse_max;
                coarse_map = pristine_coarse_map;
                calcPristineCoarseMap();
                calcPristineFineMap();
                if(has_pristine)
                {
                    is_pristine = mapvars.is_pristine;
                }
                recalculateHabitatMax();


            }
        }
    }
}

void Map::setLandscape(string landscape_type)
{
    if(landscape_type == "infinite")
    {
        writeInfo("Setting infinite landscape.\en");
        getValFunc = &Map::getValInfinite;
    }
    else if(landscape_type == "tiled_coarse")
    {
        writeInfo("Setting tiled coarse infinite landscape.\en");
        getValFunc = &Map::getValCoarseTiled;
    }
    else if(landscape_type == "tiled_fine")
    {
        writeInfo("Setting tiled fine infinite landscape.\en");
        getValFunc = &Map::getValFineTiled;
    }
    else if(landscape_type == "closed")
    {
        getValFunc = &Map::getValFinite;
    }
    else
    {
        throw FatalException("Provided landscape type is not a valid option: " + landscape_type);
    }
}

unsigned long Map::getVal(const double& x, const double& y,
                          const long& xwrap, const long& ywrap, const double& current_generation)
{
    return (this\->*getValFunc)(x, y, xwrap, ywrap, current_generation);
}

unsigned long Map::getValInfinite(
    const double& x, const double& y, const long& xwrap, const long& ywrap, const double& current_generation)
{
    double xval, yval;
    xval = x + (x_dim * xwrap);  //
    yval = y + (y_dim * ywrap);
    //      // return 0 if the requested coordinate is completely outside the map
    if(xval < coarse_x_min || xval >= coarse_x_max || yval < coarse_y_min || yval >= coarse_y_max)
    {
        return deme;
    }
    return getValFinite(x, y, xwrap, ywrap, current_generation);
}

unsigned long Map::getValCoarseTiled(
    const double& x, const double& y, const long& xwrap, const long& ywrap, const double& current_generation)
{
    double newx = fmod(x + (xwrap * x_dim) + fine_x_offset + coarse_x_offset, coarse_map.GetCols());
    double newy = fmod(y + (ywrap * y_dim) + fine_x_offset + coarse_x_offset, coarse_map.GetRows());
    if(newx < 0)
    {
        newx += coarse_map.GetCols();
    }
    if(newy < 0)
    {
        newy += coarse_map.GetRows();
    }
    return getValCoarse(newx, newy, current_generation);
}

unsigned long Map::getValFineTiled(
    const double& x, const double& y, const long& xwrap, const long& ywrap, const double& current_generation)
{

    double newx = fmod(x + (xwrap * x_dim) + fine_x_offset, fine_map.GetCols());
    double newy = fmod(y + (ywrap * y_dim) + fine_y_offset, fine_map.GetRows());
    // Now adjust for incorrect wrapping behaviour of fmod
    if(newx < 0)
    {
        newx += fine_map.GetCols();
    }
    if(newy < 0)
    {
        newy += fine_map.GetRows();
    }
#ifdef DEBUG
    if(newx >= fine_map.GetCols() || newx < 0 || newy >= fine_map.GetRows() || newy < 0)
    {
        stringstream ss;
        ss << "Fine map indexing out of range of fine map." << endl;
        ss << "x, y: " << newx << ", " << newy << endl;
        ss << "cols, rows: " << fine_map.GetCols() << ", " << fine_map.GetRows() << endl;
        throw out_of_range(ss.str());
    }
#endif
    return getValFine(newx, newy, current_generation);
}

unsigned long Map::getValCoarse(const double &xval, const double &yval, const double &current_generation)
{
    unsigned long retval = 0;
    if(has_pristine)
    {
        if(is_pristine || pristine_coarse_map[yval][xval] == coarse_map[yval][xval])
        {
            return pristine_coarse_map[yval][xval];
        }
        else
        {
            double currentTime = current_generation \- current_map_time;
            retval = (unsigned long)floor(coarse_map[yval][xval] +
                                           (habitat_change_rate *
                                            ((pristine_coarse_map[yval][xval] \- coarse_map[yval][xval]) /
                                                    (gen_since_pristine\-current_map_time)) * currentTime));
        }
    }
    else
    {
        return coarse_map[yval][xval];
    }
#ifdef pristine_mode
    if(retval > pristine_coarse_map[yval][xval])
        {
            string ec =
                "Returned value greater than pristine value. Check file input. (or disable this error before "
                "compilation.\en";
            ec += "pristine value: " + to_string((long long)pristine_coarse_map[yval][xval]) +
                  " returned value: " + to_string((long long)retval);
            throw FatalException(ec);
        }
// Note that debug mode will throw an exception if the returned value is less than the pristine state

#endif
    return retval;
}

unsigned long Map::getValFine(const double&xval, const double &yval, const double& current_generation)
{
    unsigned long retval = 0;
    if(has_pristine)
    {
        if(is_pristine || pristine_fine_map[yval][xval] == fine_map[yval][xval])
        {
            retval = pristine_fine_map[yval][xval];
        }
        else
        {
            double currentTime = current_generation \- current_map_time;
            retval = (unsigned long)floor(fine_map[yval][xval] +
                                           (habitat_change_rate * ((pristine_fine_map[yval][xval] \- fine_map[yval][xval]) /
                                                   (gen_since_pristine\-current_map_time)) * currentTime));
        }
    }
    else
    {
        return fine_map[yval][xval];
    }
// os <<fine_map[yval][xval] << "\-"<< retval << endl;
// Note that debug mode will throw an exception if the returned value is less than the pristine state
#ifdef pristine_mode
    if(has_pristine)
    {
        if(retval > pristine_fine_map[yval][xval])
        {
            throw FatalException("Returned value greater than pristine value. Check file input. (or disable this "
                                      "error before compilation.");
        }
    }
#endif
    return retval;
}

unsigned long Map::getValFinite(
    const double& x, const double& y, const long& xwrap, const long& ywrap, const double& current_generation)
{

    double xval, yval;
    xval = x + (x_dim * xwrap);  //
    yval = y + (y_dim * ywrap);
    //      // return 0 if the requested coordinate is completely outside the map
    if(xval < coarse_x_min || xval >= coarse_x_max || yval < coarse_y_min || yval >= coarse_y_max)
    {
        return 0;
    }
    if((xval < fine_x_min || xval >= fine_x_max || yval < fine_y_min ||
       yval >= fine_y_max) && bCoarse)  // check if the coordinate comes from the coarse resolution map.
    {
        // take in to account the fine map offsetting
        xval += fine_x_offset;
        yval += fine_y_offset;
        // take in to account the coarse map offsetting and the increased scale of the larger map.
        xval = floor((xval + coarse_x_offset) / scale);
        yval = floor((yval + coarse_y_offset) / scale);
        return getValCoarse(xval, yval, current_generation);
    }
    // take in to account the fine map offsetting
    // this is done twice to avoid having all the comparisons involve additions.
    xval += fine_x_offset;
    yval += fine_y_offset;
    return getValFine(xval, yval, current_generation);

}

unsigned long Map::convertSampleXToFineX(const unsigned long &x, const long &xwrap)
{
    return x + fine_x_offset + (xwrap * x_dim);
}

unsigned long Map::convertSampleYToFineY(const unsigned long &y, const long &ywrap)
{
    return y + fine_y_offset + (ywrap * y_dim);
}

void Map::convertFineToSample(long & x, long & xwrap, long &y, long &ywrap)
{
    auto tmpx = double(x);
    auto tmpy = double(y);
    convertCoordinates(tmpx, tmpy, xwrap, ywrap);
    x = floor(tmpx);
    y = floor(tmpy);
}


unsigned long Map::getInitialCount(double dSample, DataMask& samplemask)
{
    unsigned long toret;
    toret = 0;
    long x, y;
    long xwrap, ywrap;
    unsigned long max_x, max_y;
    if(samplemask.getDefault())
    {
        max_x = fine_map.GetCols();
        max_y = fine_map.GetRows();
    }
    else
    {
        max_x = samplemask.sample_mask.GetCols();
        max_y = samplemask.sample_mask.GetRows();
    }
    for(unsigned long i = 0; i < max_x; i++)
    {
        for(unsigned long j = 0; j < max_y; j++)
        {
            x = i;
            y = j;
            xwrap = 0;
            ywrap = 0;
            samplemask.recalculate_coordinates(x, y, xwrap, ywrap);
            toret += (unsigned long) (max(floor(dSample * (getVal(x, y, xwrap, ywrap, 0)) *
                                                samplemask.getExactValue(x, y, xwrap, ywrap)), 0.0));
        }
    }
    return toret;
}

SimParameters Map::getSimParameters()
{
    return mapvars;
}

bool Map::checkMap(const double& x, const double& y, const long& xwrap, const long& ywrap, const double generation)
{
    return getVal(x, y, xwrap, ywrap, generation) != 0;
}

bool Map::checkFine(const double& x, const double& y, const long& xwrap, const long& ywrap)
{
    double tmpx, tmpy;
    tmpx = x + xwrap * x_dim;
    tmpy = y + ywrap * y_dim;
    return !(tmpx < fine_x_min || tmpx >= fine_x_max || tmpy < fine_y_min || tmpy >= fine_y_max);
}

void Map::convertCoordinates(double& x, double& y, long& xwrap, long& ywrap)
{
    xwrap += floor(x / x_dim);
    ywrap += floor(y / y_dim);
    x = x \- xwrap * x_dim;
    y = y \- ywrap * y_dim;
}

unsigned long Map::runDispersal(const double& dist,
                       const double& angle,
                       long& startx,
                       long& starty,
                       long& startxwrap,
                       long& startywrap,
                       bool& disp_comp,
                       const double& generation)
{
// Checks that the start point is not out of matrix \- this might have to be disabled to ensure that when updating the
// map, it doesn\(aqt cause problems.
#ifdef pristine_mode
    if(!checkMap(startx, starty, startxwrap, startywrap, generation))
    {
        disp_comp = true;
        return;
    }
#endif

    // Different calculations for each quadrant to ensure that the dispersal reads the probabilities correctly.
    double newx, newy;
    newx = startx + (x_dim * startxwrap) + 0.5;
    newy = starty + (y_dim * startywrap) + 0.5;
    if(dispersal_relative_cost ==1)
    {
        // then nothing complicated is required and we can jump straight to the final point.
        newx += dist * cos(angle);
        newy += dist * sin(angle);
    }
    else  // we need to see which deforested patches we pass over
    {
        long boost;
        boost = 1;
        double cur_dist, tot_dist, l;
        cur_dist = 0;
        tot_dist = 0;
        // Four different calculations for the different quadrants.
        if(angle > 7 * M_PI_4 || angle <= M_PI_4)
        {
            // Continue while the dist travelled is less than the dist energy
            while(cur_dist < dist)
            {
                // Check if the starting position of the loop is in the fine map or not.
                if(checkFine(newx, newy, 0, 0))
                {
                    // Keep the standard movement rate
                    boost = 1;
                }
                else
                {
                    // Accellerate the travel speed if the point is outside the fine grid.
                    // Note this means that lineages travelling from outside the fine grid to within the
                    // fine grid may
                    // see 1 grid\(aqs worth of approximation, rather than exact values.
                    // This is an acceptable approximation!
                    boost = deme;
                }

                // Add the value to the new x and y values.
                newx = newx + boost;
                newy = newy + boost * tan(angle);
                // Check if the new point is within forest.
                if(checkMap(newx, newy, 0, 0, generation))
                {
                    l = 1;
                }
                else
                {
                    l = dispersal_relative_cost;
                }
                // Move forward different dists based on the difficulty of moving through forest.
                cur_dist = cur_dist + l * boost * (1 / cos(angle));
                tot_dist = tot_dist + boost * (1 / cos(angle));
            }
        }
        else if(angle > 3 * M_PI_4 && angle <= 5 * M_PI_4)
        {
            while(cur_dist < dist)
            {
                if(checkFine(newx, newy, 0, 0))
                {
                    boost = 1;
                }
                else
                {
                    boost = deme;
                }
                // Add the change to the new x and y values.
                newx = newx \- boost;
                newy = newy + boost * tan(M_PI \- angle);
                if(checkMap(newx, newy, 0, 0, generation))
                {
                    l = 1;
                }
                else
                {
                    l = dispersal_relative_cost;
                }
                cur_dist = cur_dist + boost * l * (1 / cos(M_PI \- angle));
                tot_dist = tot_dist + boost * (1 / cos(M_PI \- angle));
            }
        }
        else if(angle > M_PI_4 && angle <= 3 * M_PI_4)
        {
            while(cur_dist < dist)
            {
                if(checkFine(newx, newy, 0, 0))
                {
                    boost = 1;
                }
                else
                {
                    boost = deme;
                }
                // Add the change to the new x and y values.
                newx = newx + boost * tan(angle \- M_PI_2);
                newy = newy + boost;
                if(checkMap(newx, newy, 0, 0, generation))
                {
                    l = 1;
                }
                else
                {
                    l = dispersal_relative_cost;
                }
                cur_dist = cur_dist + l * boost / cos(angle \- M_PI_2);
                tot_dist = tot_dist + boost / cos(angle \- M_PI_2);
            }
        }
        else if(angle > 5 * M_PI_4 && angle <= 7 * M_PI_4)
        {
            //              os << "...ang4..." <<  flush;
            while(cur_dist < dist)
            {
                if(checkFine(newx, newy, 0, 0))
                {
                    boost = 1;
                }
                else
                {
                    boost = deme;
                }
                newx = newx + boost * tan(3 * M_PI_2 \- angle);
                newy = newy \- boost;
                if(checkMap(newx, newy, 0, 0, generation))
                {
                    l = 1;
                }
                else
                {
                    l = dispersal_relative_cost;
                }
                cur_dist = cur_dist + l * boost / cos(3 * M_PI_2 \- angle);
                tot_dist = tot_dist + boost / cos(3 * M_PI_2 \- angle);
            }
        }
        // Move the point back to get the exact placement
        if(checkMap(newx, newy, 0, 0, generation))
        {
            tot_dist = tot_dist \- min(cur_dist \- dist, (double(boost) \- 0.001));
        }
        else
        {
            disp_comp = true;
        }
        newx = startx + 0.5 + tot_dist * cos(angle);
        newy = starty + 0.5 + tot_dist * sin(angle);
    }
    unsigned long ret = getVal(newx, newy, 0, 0, generation);
    if(ret >0)
    {
        long newxwrap, newywrap;
        newxwrap = 0;
        newywrap = 0;
        convertCoordinates(newx, newy, newxwrap, newywrap);
#ifdef DEBUG
        if(!checkMap(newx, newy, newxwrap, newywrap, generation))
        {
            throw FatalException(string(
                "ERROR_MOVE_007: Dispersal attempted to non\-forest. Check dispersal function. Forest cover: " +
                to_string((long long)getVal(newx, newy, newxwrap, newywrap, generation))));
        }
#endif
        startx = newx;
        starty = newy;
        startxwrap = newxwrap;
        startywrap = newywrap;
        disp_comp = false;
    }
    return ret;
};

void Map::clearMap()
{
    current_map_time = 0;
    check_set_dim = false;
    is_pristine = false;
}

string Map::printVars()
{
    stringstream os;
    os << "fine x limits: " << fine_x_min << " , " << fine_x_max << endl;
    os << "fine y limits: " << fine_y_min << " , " << fine_y_max << endl;
    os << "fine map offset: " << fine_x_offset << " , " << fine_y_offset << endl;
    os << "coarse x limits: " << coarse_x_min << " , " << coarse_x_max << endl;
    os << "coarse y limits: " << coarse_y_min << " , " << coarse_y_max << endl;
    os << "x,y dims: " << x_dim << " , " << y_dim << endl;
    return os.str();
}

unsigned long Map::getHabitatMax()
{
    return habitat_max;
}

void Map::recalculateHabitatMax()
{
    habitat_max = 0;
    if(is_pristine && has_pristine)
    {
        if(habitat_max < pristine_fine_max)
        {
            habitat_max = pristine_fine_max;
        }
        if(habitat_max < pristine_coarse_max)
        {
            habitat_max = pristine_coarse_max;
        }
    }
    else
    {
        if(habitat_max < fine_max)
        {
            habitat_max = fine_max;
        }
        if(habitat_max < coarse_max)
        {
            habitat_max = coarse_max;
        }
        if(habitat_max < pristine_fine_max)
        {
            habitat_max = pristine_fine_max;
        }
        if(habitat_max < pristine_coarse_max)
        {
            habitat_max = pristine_coarse_max;
        }
    }
#ifdef DEBUG
    if(habitat_max > 10000)
    {
        stringstream ss;
        writeLog(10, "habitat_max may be unreasonably large: " + to_string(habitat_max));
        ss << "fine, coarse, pfine, pcoarse: " << fine_max << ", " << coarse_max;
        ss << ", " << pristine_fine_max << ", " << pristine_coarse_max << endl;
    }
#endif
}
.ft P
.fi
.UNINDENT
.UNINDENT
.SS Detailed Description
.sp
Samuel Thompson
BSD\-3 Licence.
.SS Includes
.INDENT 0.0
.IP \(bu 2
\fBCustomExceptions.h\fP (file_necsim_CustomExceptions.h)
.IP \(bu 2
\fBFilesystem.h\fP (file_necsim_Filesystem.h)
.IP \(bu 2
\fBMap.h\fP (file_necsim_Map.h)
.UNINDENT
.SS File Map.h
.sp
Contains the class_Map object for easy referencing of the respective coarse and fine map within the same coordinate system.
.SS Contents
.INDENT 0.0
.IP \(bu 2
\fI\%Definition (necsim/Map.h)\fP
.IP \(bu 2
\fI\%Detailed Description\fP
.IP \(bu 2
\fI\%Includes\fP
.IP \(bu 2
\fI\%Included By\fP
.IP \(bu 2
\fI\%Classes\fP
.UNINDENT
.SS Definition (\fBnecsim/Map.h\fP)
.SS Program Listing for File Map.h
.INDENT 0.0
.IP \(bu 2
Return to documentation for file_necsim_Map.h
.UNINDENT
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
//This file is part of NECSim project which is released under BSD\-3 license.
//See file **LICENSE.txt** or visit https://opensource.org/licenses/BSD\-3\-Clause) for full license details
#ifndef MAP
#define MAP

# include <string>
# include <stdio.h>
#include <vector>
# include <iostream>
# include <fstream>
# include <math.h>
# include <stdexcept>
# include <boost/filesystem.hpp>

#include "Matrix.h"
#include "DataMask.h"
#include "SimParameters.h"

using namespace std;

// Object containing both the maps (the coarse and fine version) and routines for easy setting up and switching between
// the different coordinate systems.
class Map
{
protected:
    // The map files which are read in (or generated if running with "null" as the map file".
    // Pristine maps are meant for before any deforestation occured, whereas the other maps are intended for modern day maps.
    // A linear transformation from modern to pristine maps is used, approaching the habitat_change_rate variable times the difference between the pristine and modern maps.
    // Once the gen_since_pristine number of generations has been reached, the map will jump to the pristine condition.
    // the finer grid for the area around the sample area.
    Matrix<uint32_t> fine_map;
    // the pristine finer map.
    Matrix<uint32_t> pristine_fine_map;
    // the coarser grid for the wider zone.
    Matrix<uint32_t> coarse_map;
    // the pristine coarser map.
    Matrix<uint32_t> pristine_coarse_map;
    // for importing and storing the simulation set\-up options.
    SimParameters mapvars;
    // the minimum values for each dimension for offsetting.
    long fine_x_min, fine_y_min, coarse_x_min, coarse_y_min;
    // the maximum values for each dimension for offsetting.
    long fine_x_max, fine_y_max, coarse_x_max, coarse_y_max;
    // the offsetting of the map in FINE map units.
    long fine_x_offset, fine_y_offset, coarse_x_offset, coarse_y_offset;
    // the scale of the coarse map compared with the smaller map.
    unsigned long scale{};
    // the length of the grid where the species start.
    long x_dim;
    // the height of the grid where the species start.
    long y_dim;
    unsigned long deme{};
    // for checking that the dimensions have been set before attempting to importSpatialParameters the maps.
    bool check_set_dim;
    // for setting the movement cost through forest.
    double dispersal_relative_cost{};
    // the last time the map was updated, in generations.
    double update_time;
    // the rate at which the habitat transforms from the modern forest map to the pristine habitat map.
    // A value of 1 will give a smooth curve from the present day to pristine habitat.
    double habitat_change_rate;
    // the number of generations at which point the habitat becomes entirely pristine.
    double gen_since_pristine;
    // the time the current map was updated.
    double current_map_time;
    // checks whether the simulation has already been set to the pristine state.
    bool is_pristine;
    // flag of whether the simulation has a pristine state or not.
    bool has_pristine;
    // the maximum value for habitat
    unsigned long habitat_max;
    // the maximum value on the fine map file
    unsigned long fine_max;
    // the maximum value on the coarse map file
    unsigned long coarse_max;
    // the maximum value on the pristine fine map file
    unsigned long pristine_fine_max;
    // the maximum value on the pristine coarse map file
    unsigned long pristine_coarse_max;
    // if true, dispersal is possible from anywhere, only the fine map spatial structure is preserved
    string landscape_type;
    string NextMap;
    // If this is false, there is no coarse map defined, so ignore the boundaries.
    bool bCoarse;
    // the number of updates to have occured.
    unsigned int nUpdate{};
    // Typedef for single application of the infinite landscape verses bounded landscape.
    typedef unsigned long (Map::*fptr)(const double &x, const double &y, const long &xwrap, const long &ywrap,
                                       const double &dCurrentGen);

    fptr getValFunc;
public:
    Map()
    {
        check_set_dim = false; // sets the check to false.
        is_pristine = false;
        current_map_time = 0;
        habitat_max = 1;
        getValFunc = nullptr;
        bCoarse = false;
        has_pristine = false;
        landscape_type = "closed";
        fine_max = 0;
        coarse_max = 0;
        pristine_fine_max = 0;
        pristine_coarse_max = 0;
    }

    unsigned long getHabitatMax();

    void setDims(SimParameters mapvarsin);

    bool checkMapExists();

    /********************************************
     * CALC MAP FUNCTIONS
     ********************************************/

    void calcFineMap();

    void calcPristineFineMap();

    void calcCoarseMap();

    void calcPristineCoarseMap();

    void setTimeVars(double gen_since_pristine_in, double habitat_change_rate_in);


    void calcOffset();
    /********************************************
     * VALIDATE MAPS
     ********************************************/

    void validateMaps();

    /********************************************
     * CHANGE MAP FUNCTIONS
     ********************************************/

    void updateMap(double generation);

    bool isPristine()
    {
        if(has_pristine)
        {
            return is_pristine;
        }
        return true;
    }

    void setPristine(const bool &bPristinein)
    {
        is_pristine = bPristinein;
    }

    double getPristine()
    {
        return gen_since_pristine;
    }

    string getLandscapeType()
    {
        return landscape_type;
    }

    void checkPristine(double generation)
    {
        if(has_pristine)
        {
            if(generation >= gen_since_pristine)
            {
                is_pristine = true;
            }
        }
    }
    //
    /********************************************
     * GET VAL FUNCTIONS
     ********************************************/


    // Function for getting the val at a particular coordinate from either the coarse or fine map
    // altered to use the current generation as well to determine the value.


    void setLandscape(string is_infinite);

    unsigned long getVal(const double &x, const double &y,
                         const long &xwrap, const long &ywrap, const double &current_generation);

    unsigned long getValCoarse(const double &xval, const double &yval, const double &current_generation);

    unsigned long getValFine(const double &xval, const double &yval, const double &current_generation);

    unsigned long
    getValFinite(const double &x, const double &y, const long &xwrap, const long &ywrap, const double &current_generation);


    unsigned long
    getValInfinite(const double &x, const double &y, const long &xwrap, const long &ywrap, const double &current_generation);


    unsigned long getValCoarseTiled(const double &x, const double &y, const long &xwrap, const long &ywrap,
                                    const double &current_generation);


    unsigned long getValFineTiled(const double &x, const double &y, const long &xwrap, const long &ywrap,
                                  const double &current_generation);

    unsigned long convertSampleXToFineX(const unsigned long &x, const long &xwrap);

    unsigned long convertSampleYToFineY(const unsigned long &y, const long &ywrap);

    void convertFineToSample(long &x, long &xwrap, long &y, long &ywrap);


    unsigned long getInitialCount(double dSample, DataMask &samplemask);

    SimParameters getSimParameters();

    /********************************************
     * CHECK MAP FUNCTIONS
     ********************************************/
    bool checkMap(const double &x, const double &y, const long &xwrap, const long &ywrap, const double generation);


    bool checkFine(const double &x, const double &y, const long &xwrap, const long &ywrap);


    void convertCoordinates(double &x, double &y, long &xwrap, long &ywrap);

    unsigned long runDispersal(const double &dist, const double &angle, long &startx, long &starty, long &startxwrap,
                               long &startywrap, bool &disp_comp, const double &generation);


    friend ostream &operator<<(ostream &os, const Map &r)
    {
        os << r.mapvars << "\en" << r.fine_x_min << "\en" << r.fine_x_max << "\en" << r.coarse_x_min << "\en" << r.coarse_x_max;
        os << "\en" << r.fine_y_min << "\en" << r.fine_y_max << "\en" << r.coarse_y_min << "\en" << r.coarse_y_max << "\en";
        os << r.fine_x_offset << "\en" << r.fine_y_offset << "\en" << r.coarse_x_offset << "\en" << r.coarse_y_offset << "\en";
        os << r.scale << "\en" << r.x_dim << "\en" << r.y_dim << "\en" << r.deme << "\en" << r.check_set_dim << "\en"
           << r.dispersal_relative_cost << "\en";
        os << r.update_time << "\en" << r.habitat_change_rate << "\en" << r.gen_since_pristine << "\en" << r.current_map_time << "\en"
           << r.is_pristine << "\en";
        os << r.NextMap << "\en" << r.nUpdate << "\en" << r.landscape_type << "\en" << r.fine_max << "\en"
           << r.coarse_max << "\en";
        os << r.pristine_fine_max << "\en" << r.pristine_coarse_max << "\en" << r.habitat_max << "\en"
           << r.bCoarse << "\en" << r.has_pristine << "\en";
        return os;
    }

    friend istream &operator>>(istream &is, Map &r)
    {
        is >> r.mapvars >> r.fine_x_min;
        is >> r.fine_x_max >> r.coarse_x_min;
        is >> r.coarse_x_max >> r.fine_y_min >> r.fine_y_max;
        is >> r.coarse_y_min >> r.coarse_y_max;
        is >> r.fine_x_offset >> r.fine_y_offset >> r.coarse_x_offset >> r.coarse_y_offset >> r.scale >> r.x_dim >> r.y_dim
           >> r.deme >> r.check_set_dim >> r.dispersal_relative_cost;
        is >> r.update_time >> r.habitat_change_rate >> r.gen_since_pristine >> r.current_map_time >> r.is_pristine;
        getline(is, r.NextMap);
        is >> r.nUpdate;
        is >> r.landscape_type;
        is >> r.fine_max >> r.coarse_max;
        is >> r.pristine_fine_max >> r.pristine_coarse_max;
        is >> r.habitat_max >> r.bCoarse >> r.has_pristine;
        r.setLandscape(r.mapvars.landscape_type);
        r.calcFineMap();
        r.calcCoarseMap();
        r.calcPristineFineMap();
        r.calcPristineCoarseMap();
        r.recalculateHabitatMax();
        return is;
    }

    string printVars();

    void clearMap();

    void recalculateHabitatMax();

};

#endif // MAP
.ft P
.fi
.UNINDENT
.UNINDENT
.SS Detailed Description
.sp
Samuel Thompson
31/08/16
BSD\-3 Licence.
.SS Includes
.INDENT 0.0
.IP \(bu 2
\fBDataMask.h\fP (file_necsim_DataMask.h)
.IP \(bu 2
\fBMatrix.h\fP (file_necsim_Matrix.h)
.IP \(bu 2
\fBSimParameters.h\fP (file_necsim_SimParameters.h)
.IP \(bu 2
\fBboost/filesystem.hpp\fP
.IP \(bu 2
\fBfstream\fP
.IP \(bu 2
\fBiostream\fP
.IP \(bu 2
\fBmath.h\fP
.IP \(bu 2
\fBstdexcept\fP
.IP \(bu 2
\fBstdio.h\fP
.IP \(bu 2
\fBstring\fP
.IP \(bu 2
\fBvector\fP
.UNINDENT
.SS Included By
.INDENT 0.0
.IP \(bu 2
file_necsim_DataMask.cpp
.IP \(bu 2
file_necsim_DispersalCoordinator.h
.IP \(bu 2
file_necsim_SpatialTree.h
.IP \(bu 2
file_necsim_Map.cpp
.UNINDENT
.SS Classes
.INDENT 0.0
.IP \(bu 2
class_Map
.UNINDENT
.SS File Matrix.h
.sp
Contains a template for a matrix with all the basic matrix operations overloaded.
.SS Contents
.INDENT 0.0
.IP \(bu 2
\fI\%Definition (necsim/Matrix.h)\fP
.IP \(bu 2
\fI\%Detailed Description\fP
.IP \(bu 2
\fI\%Includes\fP
.IP \(bu 2
\fI\%Included By\fP
.IP \(bu 2
\fI\%Classes\fP
.IP \(bu 2
\fI\%Defines\fP
.IP \(bu 2
\fI\%Variables\fP
.UNINDENT
.SS Definition (\fBnecsim/Matrix.h\fP)
.SS Program Listing for File Matrix.h
.INDENT 0.0
.IP \(bu 2
Return to documentation for file_necsim_Matrix.h
.UNINDENT
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
#ifndef MATRIX
# define MATRIX
# define null 0
# include <cstdio>
#include <iostream>
#include <sstream>
#include <fstream>
#include <cstdlib>
#include <cstring>
#include <stdexcept>

#ifdef use_csv
#include<cmath>
#include <stdexcept>
#include "fast\-cpp\-csv\-parser/csv.h"
#endif
#ifdef with_gdal

#include <gdal_priv.h>
#include <cpl_conv.h> // for CPLMalloc()

#endif

#include <cstdint>
#include "Logging.h"

using namespace std;

// Array of data sizes for importing tif files.
const int gdal_data_sizes[] = {0, 8, 16, 16, 32, 32, 32, 64};

template<class T>
class Row
{
private:
    // stores the number of columns in the row
    unsigned long numCols{};
    // an array to store the row
    T *row;
public:

    explicit Row(unsigned long cols = 0) : row(nullptr)
    {
        setSize(cols);
    }

    ~Row()
    {
        if(row)
        {
            delete[] row;
        }
    }

    Row(const Row &r) : row(0)
    {
        setSize(r.numCols);
        // Change to standard copy
        copy(&r.row[0], &r.row[numCols], row);
    }


    void setSize(unsigned long n)
    {
        if(row)
        {
            delete[] row;
        }
        if(n > 0)
        {
            row = new T[n];
        }
        else
        {
            row = 0;
        }
        numCols = n;
    }

    void resize(unsigned long n)
    {
        auto t = new T[n];
        for(unsigned long i = 0; i < numCols; i++)
        {
            t[i] = row[i];
        }
        delete[] row;
        row = move(t);
        numCols = n;
    }

    unsigned long size()
    {
        return numCols;
    }

    T &operator[](unsigned long column)
    {
        // assert(column<numCols);
        // check we are within bounds
#ifdef DEBUG
        if(column < 0 || column >= numCols)
        {
            string err =
                    "ERROR_MAIN_013b: Tried to call an indices that was out of range of the row. Check row size definition. numCols: " +
                    to_string((long long) numCols) + " index: " + to_string((long long) column);
            throw out_of_range(err);
        }
#endif
        column = column % numCols;
        return row[column];
    }

    Row &operator=(const Row &r)
    {
        setSize(r.numCols);
        for(unsigned long i = 0; i < numCols; i++)
        {
            row[i] = r.row[i];
        }
        return *this;
    }

    friend ostream &operator<<(ostream &os, const Row &r)
    {
        os << r.numCols << ",";
        for(unsigned long c = 0; c < r.numCols; c++)
        {
            os << r.row[c] << ",";
        }
        return os;
    }

    friend istream &operator>>(istream &is, Row &r)
    {
        char delim;
        int n;
        is >> n;
        r.setSize(n);
        is >> delim;
        for(unsigned long c = 0; c < r.numCols; c++)
        {
            is >> r.row[c];
            is >> delim;
        }
        return is;
    }
};


template<class T>
class Matrix
{

protected:

    // number of rows and columns
    unsigned long numCols{}, numRows{};
    // a matrix is an array of rows
    Row<T> *matrix;

public:

    explicit Matrix(unsigned long rows = 0, unsigned long cols = 0) : matrix(null)
    {
        SetSize(rows, cols);
    }

    Matrix(const Matrix &m) : matrix(null)
    {
        SetSize(m.numRows, m.numCols);
        copy(&m.matrix[0][0], &m.matrix[numRows][numCols], matrix);
    }

    ~Matrix()
    {
        if(matrix)
        {
            delete[] matrix;
        }
    }

    void SetSize(unsigned long rows, unsigned long cols)
    {
        if(matrix)
        {
            delete[]matrix;
        }
        if(cols > 0 && rows > 0)
        {
            matrix = new Row<T>[rows];
            for(unsigned long i = 0; i < rows; i++)
            {
                matrix[i].setSize(cols);
            }
        }
        else
        {
            matrix = null;
        }
        numCols = cols;
        numRows = rows;
    }

    unsigned long GetCols() const
    {
        return numCols;
    }

    unsigned long GetRows() const
    {
        return numRows;
    }

    Row<T> &operator[](unsigned long index)
    {
#ifdef DEBUG
        if(index < 0 || index >= numRows)
        {
            string err =
                    "ERROR_MAIN_013: Tried to call an indices that was out of range of the matrix. Check matrix size definition. numRows: " +
                    to_string((long long) numRows) + " index: " + to_string((long long) index);
            throw out_of_range(err);
        }
#endif
        index = index % numRows;
        return matrix[index];
    }

    Matrix &operator=(const Matrix &m)
    {
        SetSize(m.numRows, m.numCols);
        for(unsigned long r = 0; r < numRows; r++)
        {
            matrix[r] = Row<T>(m.matrix[r]);
        }
        return *this;
    }


    const Matrix operator+(const Matrix &m)
    {
        //Since addition creates a new matrix, we don\(aqt want to return a reference, but an actual matrix object.
        unsigned long newnumcols, newnumrows;
        if(numCols > m.numCols)
        {
            newnumcols = m.numCols;
        }
        else
        {
            newnumcols = numCols;
        }
        if(numRows > m.numRows)
        {
            newnumrows = m.numRows;
        }
        else
        {
            newnumrows = numRows;
        }

        Matrix result(newnumrows, newnumcols);
        for(unsigned long r = 0; r < newnumrows; r++)
        {
            for(unsigned long c = 0; c < newnumcols; c++)
            {
                result[r][c] = matrix[r][c] + m.matrix[r][c];
            }
        }
        return result;
    }

    const Matrix operator\-(const Matrix &m)
    {
        unsigned long newnumcols, newnumrows;
        if(numCols > m.numCols)
        {
            newnumcols = m.numCols;
        }
        else
        {
            newnumcols = numCols;
        }
        if(numRows > m.numRows)
        {
            newnumrows = m.numRows;
        }
        else
        {
            newnumrows = numRows;
        }
        Matrix result(newnumrows, newnumcols);
        for(unsigned long r = 0; r < newnumrows; r++)
        {
            for(unsigned long c = 0; c < newnumcols; c++)
            {
                result[r][c] = matrix[r][c] \- m.matrix[r][c];
            }
        }
        return result;
    }

    Matrix &operator+=(const Matrix &m)
    {
        unsigned long newnumcols, newnumrows;
        if(numCols > m.numCols)
        {
            newnumcols = m.numCols;
        }
        else
        {
            newnumcols = numCols;
        }
        if(numRows > m.numRows)
        {
            newnumrows = m.numRows;
        }
        else
        {
            newnumrows = numRows;
        }
        for(unsigned long r = 0; r < newnumrows; r++)
        {
            for(unsigned long c = 0; c < newnumcols; c++)
            {
                matrix[r][c] += m.matrix[r][c];
            }
        }
        return *this;
    }


    Matrix &operator\-=(const Matrix &m)
    {
        unsigned long newnumcols, newnumrows;
        if(numCols > m.numCols)
        {
            newnumcols = m.numCols;
        }
        else
        {
            newnumcols = numCols;
        }
        if(numRows > m.numRows)
        {
            newnumrows = m.numRows;
        }
        else
        {
            newnumrows = numRows;
        }
        for(unsigned long r = 0; r < newnumrows; r++)
        {
            for(unsigned long c = 0; c < newnumcols; c++)
            {
                matrix[r][c] \-= m.matrix[r][c];
            }
        }
        return *this;
    }

    const Matrix operator*(const double s)
    {
        Matrix result(numRows, numCols);
        for(unsigned long r = 0; r < numRows; r++)
        {
            for(unsigned long c = 0; c < numCols; c++)
            {
                result[r][c] = matrix[r][c] * s;
            }
        }
        return result;
    }


    const Matrix operator*(Matrix &m)
    {
        unsigned long newnumcols;
        if(numCols > m.numRows)
        {
            newnumcols = m.numRows;
        }
        else
        {
            newnumcols = numCols;
        }

        Matrix result(numRows, m.numCols);
        for(unsigned long r = 0; r < numRows; r++)
        {
            for(unsigned long c = 0; c < m.numCols; c++)
            {
                for(unsigned long i = 0; i < newnumcols; i++)
                {
                    result[r][c] += matrix[r][i] * m[i][c];
                }
            }
        }
        return result;
    }

    friend ostream &operator<<(ostream &os, const Matrix &m)
    {
        for(unsigned long r = 0; r < m.numRows; r++)
        {
            for(unsigned long c = 0; c < m.numCols; c++)
            {
                os << m.matrix[r][c] << ",";
            }
            os << "\en";
        }
        return os;
    }

    friend istream &operator>>(istream &is, Matrix &m)
    {
        char delim;
        for(unsigned long r = 0; r < m.numRows; r++)
        {
            for(unsigned long c = 0; c < m.numCols; c++)
            {
                is >> m.matrix[r][c];
                is >> delim;
            }
        }
        return is;
    }

    void setValue(const unsigned long &x, const unsigned long &y, const char *value)
    {
        matrix[y][x] = static_cast<T>(*value);
    }

    void import(const string &filename)
    {
        if(filename.find(".csv") != string::npos)
        {
            importCsv(filename);
        }
#ifdef with_gdal
        else if(filename.find(".tif") != string::npos)
        {
            importTif(filename);
            return;
        }
#endif
        string s = "Type detection failed for " + filename + ". Check filename is correct.";
        throw runtime_error(s);
    }

#ifdef with_gdal
    void importTif(const string &filename)
    {
        stringstream ss;
        ss << "Importing " << filename << " " << flush;
        writeInfo(ss.str());
        GDALDataset *poDataset;
        GDALAllRegister();
        poDataset = (GDALDataset *) GDALOpen(filename.c_str(), GA_ReadOnly);
        if(poDataset == nullptr)
        {
            string s = "File " + filename + " not found.";
            throw runtime_error(s);
        }
        GDALRasterBand *poBand;
        int nBlockXSize, nBlockYSize;
        // Import the raster band 1
        poBand = poDataset\->GetRasterBand(1);
        nBlockXSize = poDataset\->GetRasterXSize();
        nBlockYSize = poDataset\->GetRasterYSize();
        double noDataValue;
        try
        {
            noDataValue = poBand\->GetNoDataValue();
        }
        catch(out_of_range)
        {
            noDataValue = 0;
        }
        // Check sizes
        if((numCols != (unsigned long) nBlockXSize || numRows != (unsigned long) nBlockYSize) || numCols == 0 ||
           numRows == 0)
        {
            stringstream ss;
            ss << "Raster data size does not match inputted dimensions for " << filename << ". Using raster sizes."
                 << endl;
            ss << "Old dimensions: " << numCols << ", " << numRows << endl;
            ss << "New dimensions: " << nBlockXSize << ", " << nBlockYSize << endl;
            writeWarning(ss.str());
            SetSize(static_cast<unsigned long>(nBlockYSize), static_cast<unsigned long>(nBlockXSize));
        }
        // Check sizes match
        GDALDataType dt = poBand\->GetRasterDataType();
        const char *dt_name = GDALGetDataTypeName(dt);
        CPLErr r;
        // Check the data types are support
        if(dt == 0 || dt > 7)
        {
            throw FatalException("Data type of " + string(dt_name) + "is not supported.");
        }
#ifdef DEBUG
        if(sizeof(T) * 8 != gdal_data_sizes[dt])
        {
            stringstream ss;
            ss << "Object data size: " << sizeof(T) * 8 << endl;
            ss << "Tif data type: " << dt_name << ": " << gdal_data_sizes[dt] << " bytes" << endl;
            ss << "Tif data type does not match object data size in " << filename << endl;
            writeWarning(ss.str());
        }
#endif
        // Just use the overloaded method for importing between types
        internalImport(filename, poBand, nBlockXSize, dt, r, noDataValue);
        GDALClose(poDataset);
        writeInfo("done!\en");
    }

    void internalImport(const string &filename, GDALRasterBand *poBand, int nBlockXSize,
                                                     GDALDataType dt, CPLErr &r, const double &ndv)
    {
        writeWarning("No type detected for matrix type. Attempting default importing (undefined behaviour).");
        defaultImport(filename, poBand, nBlockXSize, dt, r, ndv);
    }

    void defaultImport(const string &filename, GDALRasterBand *poBand, int nBlockXSize,
                       GDALDataType dt, CPLErr &r, const double &ndv)
    {
        unsigned int number_printed = 0;
        for(uint32_t j = 0; j < numRows; j++)
        {
            printNumberComplete(j, number_printed, filename);
            r = poBand\->RasterIO(GF_Read, 0, j, nBlockXSize, 1, &matrix[j][0], nBlockXSize, 1, dt, 0, 0);
            checkRasterBandFailure(r);
            // Now convert the no data values to 0
            for(uint32_t i = 0; i < numCols; i++)
            {
                if(matrix[j][i] == ndv)
                {
                    matrix[j][i] = 0;
                }
            }
        }
    }

    void importFromDoubleAndMakeBool(const string &filename, GDALRasterBand * poBand, int nBlockXSize,
                                   GDALDataType dt, CPLErr & r, const double & ndv)
    {
        unsigned int number_printed = 0;
        // create an empty row of type float
        double * t1;
        t1 = (double *) CPLMalloc(sizeof(double) * numCols);
        // importSpatialParameters the data a row at a time, using our template row.
        for(uint32_t j = 0; j < numRows; j++)
        {
            printNumberComplete(j, number_printed, filename);
            r = poBand\->RasterIO(GF_Read, 0, j, nBlockXSize, 1, &t1[0], nBlockXSize, 1, GDT_Float64, 0, 0);
            checkRasterBandFailure(r);
            // now copy the data to our matrix, converting float to int. Round or floor...? hmm, floor?
            for(unsigned long i = 0; i < numCols; i++)
            {
                if(t1[i] == ndv)
                {
                    matrix[j][i] = false;
                }
                else
                {
                    matrix[j][i] = t1[i] >= 0.5;
                }
            }
        }
        CPLFree(t1);
    };
    template<typename T2> void importUsingBuffer(const string &filename, GDALRasterBand * poBand, int nBlockXSize,
                           GDALDataType dt, CPLErr & r, const double & ndv)
    {
        unsigned int number_printed = 0;
        // create an empty row of type float
        T2 * t1;
        t1 = (T2 *) CPLMalloc(sizeof(T2) * numCols);
        // importSpatialParameters the data a row at a time, using our template row.
        for(uint32_t j = 0; j < numRows; j++)
        {
            printNumberComplete(j, number_printed, filename);
            r = poBand\->RasterIO(GF_Read, 0, j, nBlockXSize, 1, &t1[0], nBlockXSize, 1, dt, 0, 0);
            checkRasterBandFailure(r);
            // now copy the data to our matrix, converting float to int. Round or floor...? hmm, floor?
            for(unsigned long i = 0; i < numCols; i++)
            {
                if(t1[i] == ndv)
                {
                    matrix[j][i] = static_cast<T>(0);
                }
                else
                {
                    matrix[j][i] = static_cast<T>(t1[i]);
                }
            }
        }
        CPLFree(t1);
    };

    void printNumberComplete(const uint32_t &j, unsigned int & number_printed, const string & filename)
    {
        double dComplete = ((double) j / (double) numRows) * 20;
        if(number_printed < dComplete)
        {
            stringstream os;
            os << "\erImporting " << filename << " ";
            number_printed = 0;
            while(number_printed < dComplete)
            {
                os << ".";
                number_printed++;
            }
            os << flush;
            writeInfo(os.str());
        }
    }

    void checkRasterBandFailure(const CPLErr & r)
    {
        if(r == CE_Failure)
        {
            char *fmt = nullptr;
            CPLError(r, CPLGetLastErrorNo(), "%s\en", fmt);
            throw runtime_error("CPL error during tif importSpatialParameters: CE_Failure: " + string(fmt));
        }
    }

#endif


#ifdef use_csv
    void importCsv(const string &filename)
    {
        stringstream os;
        os  << "Importing " << filename << " " << flush;
        writeInfo(os.str());
        // LineReader option
        io::LineReader in(filename);
        // Keep track of whether we\(aqve printed to terminal or not.
        bool bPrint = false;
        // Initialies empty variable so that the setValue operator overloading works properly.
        unsigned int number_printed = 0;
        for(unsigned long i =0; i<numRows; i++)
        {
            char* line = in.next_line();
            if(line == nullptr)
            {
                if(!bPrint)
                {
                    cerr << "Input dimensions incorrect \- read past end of file." << endl;
                    bPrint = true;
                }
                break;
            }
            else
            {
                char *dToken;
                dToken = strtok(line,",");
                for(unsigned long j = 0; j<numCols; j++)
                {
                    if(dToken == nullptr)
                    {
                        if(!bPrint)
                        {
                            cerr << "Input dimensions incorrect \- read past end of file." << endl;
                            bPrint = true;
                        }
                        break;
                    }
                    else
                    {
                        // This function is overloaded to correctly determine the type of the template
                        setValue(j,i,dToken);
                        dToken = strtok(NULL,",");
                    }
                }
                // output the percentage complete
                double dComplete = ((double)i/(double)numRows)*20;
                if( number_printed < dComplete)
                {
                    stringstream os;
                    os  << "\erImporting " << filename << " ";
                    number_printed = 0;
                    while(number_printed < dComplete)
                    {
                        os << ".";
                        number_printed ++;
                    }
                    os << flush;
                    writeInfo(os.str());
                }

            }
        }
        writeInfo("done!\en");
    }
#endif
#ifndef use_csv

    void importCsv(const string &filename)
    {
        stringstream os;
        os << "Importing" << filename << " " << flush;
        ifstream inputstream;
        inputstream.open(filename.c_str());
        unsigned long number_printed = 0;
        for(uint32_t j = 0; j < numRows; j++)
        {
            string line;
            getline(inputstream, line);
            istringstream iss(line);
            for(uint32_t i = 0; i < numCols; i++)
            {
                char delim;
                T val;
                iss >> val >> delim;
                matrix[j][i] = val;
            }
            double dComplete = ((double) j / (double) numRows) * 5;
            if(number_printed < dComplete)
            {
                os << "\erImporting " << filename << " " << flush;
                while(number_printed < dComplete)
                {
                    os << ".";
                    number_printed++;
                }
                os << flush;
                writeInfo(os.str());

            }
        }
        stringstream os2;
        os2 << "\erImporting" << filename << "..." << "done!" << "                          " << endl;
        inputstream.close();
        writeInfo(os2.str());
    }

#endif
};

#ifdef with_gdal

template<> inline void Matrix<bool>::internalImport(const string &filename, GDALRasterBand *poBand, int nBlockXSize,
                    GDALDataType dt, CPLErr &r, const double &ndv)
{
    if(dt <=7)
    {
        // Then the tif file type is an int/byte
        // we can just import as it is
        importUsingBuffer<uint8_t>(filename, poBand, nBlockXSize, GDT_Byte, r, ndv);
    }
    else
    {
        // Conversion from double to boolean
        importFromDoubleAndMakeBool(filename, poBand, nBlockXSize, dt, r, ndv);
    }
}
template <>inline void Matrix<int8_t>::internalImport(const string &filename, GDALRasterBand *poBand, int nBlockXSize,
                                                   GDALDataType dt, CPLErr &r, const double &ndv)
{
    importUsingBuffer<int16_t>(filename, poBand, nBlockXSize, GDT_Int16, r, ndv);
}

template <>inline void Matrix<uint8_t>::internalImport(const string &filename, GDALRasterBand *poBand, int nBlockXSize,
                                                   GDALDataType dt, CPLErr &r, const double &ndv)
{
    defaultImport(filename, poBand, nBlockXSize, GDT_Byte, r, ndv);
}

template <>inline void Matrix<int16_t>::internalImport(const string &filename, GDALRasterBand *poBand, int nBlockXSize,
                                                             GDALDataType dt, CPLErr &r, const double &ndv)
{
    defaultImport(filename, poBand, nBlockXSize, GDT_Int16, r, ndv);
}
template <>inline void Matrix<uint16_t>::internalImport(const string &filename, GDALRasterBand *poBand, int nBlockXSize,
                                                             GDALDataType dt, CPLErr &r, const double &ndv)
{
    defaultImport(filename, poBand, nBlockXSize, GDT_UInt16, r, ndv);
}
template <>inline void Matrix<uint32_t>::internalImport(const string &filename, GDALRasterBand *poBand, int nBlockXSize,
                                                              GDALDataType dt, CPLErr &r, const double &ndv)
{
    defaultImport(filename, poBand, nBlockXSize, GDT_UInt32, r, ndv);
}
template <>inline void Matrix<int32_t>::internalImport(const string &filename, GDALRasterBand *poBand, int nBlockXSize,
                                                        GDALDataType dt, CPLErr &r, const double &ndv)
{
    defaultImport(filename, poBand, nBlockXSize, GDT_Int32, r, ndv);
}
template <>inline void Matrix<float>::internalImport(const string &filename, GDALRasterBand *poBand, int nBlockXSize,
                                                              GDALDataType dt, CPLErr &r, const double &ndv)
{
    defaultImport(filename, poBand, nBlockXSize, GDT_Float32, r, ndv);
}

template <>inline void Matrix<double>::internalImport(const string &filename, GDALRasterBand *poBand, int nBlockXSize,
                                                              GDALDataType dt, CPLErr &r, const double &ndv)
{
    defaultImport(filename, poBand, nBlockXSize, GDT_Float64, r, ndv);
}

#endif // gdal
#endif // MATRIX
.ft P
.fi
.UNINDENT
.UNINDENT
.SS Detailed Description
.sp
Samuel Thompson
BSD\-3 Licence.
Code supplied by James Rosindell with large usage of  href = "\fI\%http://www.devarticles.com/c/a/Cplusplus/Operator\-Overloading\-in\-C\-plus/1\fP"> this website , and modified and updated by Samuel Thompson. There are two distinct classes, template_class_Row and template_class_Matrix\&. Most operations are low\-level, but some higher level functions remain, such as importCsv().
Contact: \fI\%thompsonsed@gmail.com\fP
.SS Includes
.INDENT 0.0
.IP \(bu 2
\fBLogging.h\fP (file_necsim_Logging.h)
.IP \(bu 2
\fBcstdint\fP
.IP \(bu 2
\fBcstdio\fP
.IP \(bu 2
\fBcstdlib\fP
.IP \(bu 2
\fBcstring\fP
.IP \(bu 2
\fBfstream\fP
.IP \(bu 2
\fBiostream\fP
.IP \(bu 2
\fBsstream\fP
.IP \(bu 2
\fBstdexcept\fP
.UNINDENT
.SS Included By
.INDENT 0.0
.IP \(bu 2
file_necsim_Community.h
.IP \(bu 2
file_necsim_DataMask.h
.IP \(bu 2
file_necsim_Map.h
.IP \(bu 2
file_necsim_DispersalCoordinator.h
.IP \(bu 2
file_necsim_Tree.h
.IP \(bu 2
file_necsim_SpatialTree.h
.IP \(bu 2
file_necsim_SpeciesList.h
.IP \(bu 2
file_necsim_ReproductionMap.h
.IP \(bu 2
file_necsim_SimulateDispersal.h
.UNINDENT
.SS Classes
.INDENT 0.0
.IP \(bu 2
template_class_Matrix
.IP \(bu 2
template_class_Row
.UNINDENT
.SS Defines
.INDENT 0.0
.IP \(bu 2
define_null
.UNINDENT
.SS Variables
.INDENT 0.0
.IP \(bu 2
variable_gdal_data_sizes
.UNINDENT
.SS File Metacommunity.cpp
.sp
Contains the class_Metacommunity class for generating a neutral metacommunity.
.SS Contents
.INDENT 0.0
.IP \(bu 2
\fI\%Definition (necsim/Metacommunity.cpp)\fP
.IP \(bu 2
\fI\%Detailed Description\fP
.IP \(bu 2
\fI\%Includes\fP
.UNINDENT
.SS Definition (\fBnecsim/Metacommunity.cpp\fP)
.SS Program Listing for File Metacommunity.cpp
.INDENT 0.0
.IP \(bu 2
Return to documentation for file_necsim_Metacommunity.cpp
.UNINDENT
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
// This file is part of NECSim project which is released under BSD\-3 license.
// See file **LICENSE.txt** or visit https://opensource.org/licenses/BSD\-3\-Clause) for full license details.

#include "Metacommunity.h"


Metacommunity::Metacommunity()
{
    community_size = 0;
    seed = 0;
    speciation_rate = 0.0;
    parameters_checked = false;
    metacommunity_cumulative_abundances = nullptr;
}

void Metacommunity::setCommunityParameters(unsigned long community_size_in, long double speciation_rate_in,
                                           string database_name_in)
{
    createParent(database_name_in);
    community_size = community_size_in;
    speciation_rate = speciation_rate_in;
    // open the sqlite connection to the output database
    openSqlConnection(database_name_in);
}

void Metacommunity::checkSimulationParameters()
{
    if(!parameters_checked)
    {
        if(database == nullptr)
        {
            throw FatalException("Cannot read simulation parameters as database is null pointer.");
        }
        // Now do the same for times
        sqlite3_stmt *stmt;
        string sql_call = "SELECT seed, task from SIMULATION_PARAMETERS";
        int rc = sqlite3_prepare_v2(database, sql_call.c_str(), static_cast<int>(strlen(sql_call.c_str())), &stmt,
                                    nullptr);
        if(rc != SQLITE_DONE && rc != SQLITE_OK)
        {
            sqlite3_close(database);
        }
        sqlite3_step(stmt);
        seed = static_cast<unsigned long>(sqlite3_column_int(stmt, 1));
        random.setSeed(seed);
        task = static_cast<unsigned long>(sqlite3_column_int(stmt, 1));
        sqlite3_step(stmt);
        sqlite3_finalize(stmt);
        parameters_checked = true;
    }
}

void Metacommunity::addSpecies(unsigned long &species_count, TreeNode *tree_node, set<unsigned long> &species_list)
{

    auto species_id = selectLineageFromMetacommunity();
    if(species_list.empty() || species_list.find(species_id) != species_list.end())
    {
        species_list.insert(species_id);
        species_count ++;
    }
    tree_node\->burnSpecies(species_id);
}

void Metacommunity::createMetacommunityNSENeutralModel()
{
#ifdef DEBUG
    writeLog(10, "Running spatially\-implicit model for metacommunity generation.");
#endif //DEBUG
    // First set up a non\-spatial coalescence simulation to generate our metacommunity
    SimParameters temp_parameters;
    temp_parameters.setMetacommunityParameters(community_size, speciation_rate, seed, task);
    metacommunity_tree.internalSetup(temp_parameters);
    // Run our simulation and calculate the species abundance distribution (as this is all that needs to be stored).
    if(!metacommunity_tree.runSimulation())
    {
        throw FatalException("Completion of the non\-spatial coalescence simulation "
                                     "to create the metacommunity did not finish in time.");
    }
    metacommunity_tree.applySpecRateInternal(speciation_rate, 0.0);
    // row_out now contains the number of individuals per species
    // Make it cumulative to increase the speed of indexing using binary search.
    metacommunity_cumulative_abundances = metacommunity_tree.getCumulativeAbundances();
#ifdef DEBUG
    writeLog(10, "Spatially\-implicit simulation completed.");
#endif //DEBUG

}

unsigned long Metacommunity::selectLineageFromMetacommunity()
{
    auto max_indices = metacommunity_cumulative_abundances\->size() \- 1;
    auto random_value = random.i0(community_size \- 1);
#ifdef DEBUG
    // binary search
    if(random_value > (*metacommunity_cumulative_abundances)[max_indices])
    {
        throw FatalException("Random number generation out of range of the community size in lineage selection.");
    }
#endif //DEBUG
    unsigned long mid_point;
    unsigned long min_indices = 0;
    while(min_indices < max_indices\-1)
    {
        mid_point = static_cast<unsigned long>(floor(((max_indices \- min_indices) / 2) + min_indices));
        if(random_value == (*metacommunity_cumulative_abundances)[mid_point])
        {
            min_indices = mid_point;
            max_indices = mid_point;
        }
        if(random_value <= (*metacommunity_cumulative_abundances)[mid_point])
        {
            max_indices = mid_point;
        }
        else
        {
            min_indices = mid_point;
        }
    }
    if(min_indices == max_indices \- 1)
    {
        return max_indices;
    }
#ifdef DEBUG
    if(min_indices != max_indices)
    {
        throw FatalException("Error in binary search algorithm for lineage selection. Please report this bug.");
    }
#endif // DEBUG
    return min_indices;
}

void Metacommunity::apply(SpecSimParameters *sp)
{
#ifdef DEBUG
    writeLog(10, "********************");
    writeLog(10, "Metacommunity application");
#endif //DEBUG
    time_t tStart{};
    time_t tEnd{};
    // Start the clock
    time(&tStart);
    setCommunityParameters(sp\->metacommunity_size, sp\->metacommunity_speciation_rate, sp\->filename);
    // Make sure that the connection is opened to file.
    bSqlConnection = false;
    checkSimulationParameters();
    createMetacommunityNSENeutralModel();
#ifdef DEBUG
    writeLog(10, "Creating coalescence tree from metacommunity...");
#endif //DEBUG
    doApplication(sp);
    output();
    printEndTimes(tStart, tEnd);

}
.ft P
.fi
.UNINDENT
.UNINDENT
.SS Detailed Description
.sp
Samuel Thompson
BSD\-3 Licence. For use with completed simulations from NECSim, using the SpeciationCounter program. Individuals will be drawn from the metacommunity for each speciation event, instead of creating a new species each time.
Contact: \fI\%samuel.thompson14@imperial.ac.uk\fP or \fI\%thompsonsed@gmail.com\fP
.SS Includes
.INDENT 0.0
.IP \(bu 2
\fBMetacommunity.h\fP (file_necsim_Metacommunity.h)
.UNINDENT
.SS File Metacommunity.h
.sp
Generates a neutral metacommunity.
.SS Contents
.INDENT 0.0
.IP \(bu 2
\fI\%Definition (necsim/Metacommunity.h)\fP
.IP \(bu 2
\fI\%Detailed Description\fP
.IP \(bu 2
\fI\%Includes\fP
.IP \(bu 2
\fI\%Included By\fP
.IP \(bu 2
\fI\%Classes\fP
.UNINDENT
.SS Definition (\fBnecsim/Metacommunity.h\fP)
.SS Program Listing for File Metacommunity.h
.INDENT 0.0
.IP \(bu 2
Return to documentation for file_necsim_Metacommunity.h
.UNINDENT
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
// This file is part of NECSim project which is released under BSD\-3 license.
// See file **LICENSE.txt** or visit https://opensource.org/licenses/BSD\-3\-Clause) for full license details.

#ifndef SPECIATIONCOUNTER_METACOMMUNITY_H
#define SPECIATIONCOUNTER_METACOMMUNITY_H

#include <string>
#include <sqlite3.h>
#include <set>
#include "Tree.h"
#include "Community.h"
#include "NRrand.h"
#include "SpecSimParameters.h"

using namespace std;
class Metacommunity : public virtual Community
{
protected:
    // The number of individuals in the metacommunity
    unsigned long community_size;
    // The speciation rate used for creation of the metacommunity
    long double speciation_rate;
    // Simulation seed and task (read from the output database or set to 1)
    unsigned long seed;
    unsigned long task;
    bool parameters_checked;
    Row<unsigned long> * metacommunity_cumulative_abundances;
    NRrand random;
    Tree metacommunity_tree;
public:

    Metacommunity();

    ~Metacommunity() = default;

    void setCommunityParameters(unsigned long community_size_in, long double speciation_rate_in, string database_name_in);

    void checkSimulationParameters();

    void addSpecies(unsigned long &species_count, TreeNode *tree_node, set<unsigned long> &species_list) override;

    void createMetacommunityNSENeutralModel();

    unsigned long selectLineageFromMetacommunity();

    void apply(SpecSimParameters *sp) override ;

};


#endif //SPECIATIONCOUNTER_METACOMMUNITY_H
.ft P
.fi
.UNINDENT
.UNINDENT
.SS Detailed Description
.sp
Samuel Thompson
BSD\-3 Licence. Individuals will be drawn from the metacommunity for each speciation event, instead of creating a new species each time. The metacommunity itself is generated using spatially\-implicit neutral simulations.
Contact: \fI\%samuel.thompson14@imperial.ac.uk\fP or \fI\%thompsonsed@gmail.com\fP
.SS Includes
.INDENT 0.0
.IP \(bu 2
\fBCommunity.h\fP (file_necsim_Community.h)
.IP \(bu 2
\fBNRrand.h\fP (file_necsim_NRrand.h)
.IP \(bu 2
\fBSpecSimParameters.h\fP (file_necsim_SpecSimParameters.h)
.IP \(bu 2
\fBTree.h\fP (file_necsim_ProtractedSpatialTree.h)
.IP \(bu 2
\fBset\fP
.IP \(bu 2
\fBsqlite3.h\fP
.IP \(bu 2
\fBstring\fP
.UNINDENT
.SS Included By
.INDENT 0.0
.IP \(bu 2
file_necsim_Metacommunity.cpp
.UNINDENT
.SS Classes
.INDENT 0.0
.IP \(bu 2
class_Metacommunity
.UNINDENT
.SS File necsimmodule.cpp
.sp
Contains the functions allowing integration of the PyCoalescence python module directly to the c++.
.SS Contents
.INDENT 0.0
.IP \(bu 2
\fI\%Definition (necsimmodule.cpp)\fP
.IP \(bu 2
\fI\%Detailed Description\fP
.IP \(bu 2
\fI\%Includes\fP
.IP \(bu 2
\fI\%Functions\fP
.IP \(bu 2
\fI\%Defines\fP
.IP \(bu 2
\fI\%Variables\fP
.UNINDENT
.SS Definition (\fBnecsimmodule.cpp\fP)
.SS Program Listing for File necsimmodule.cpp
.INDENT 0.0
.IP \(bu 2
Return to documentation for file_necsimmodule.cpp
.UNINDENT
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
// This file is part of NECSim project which is released under BSD\-3 license.
// See file **LICENSE.txt** or visit https://opensource.org/licenses/BSD\-3\-Clause) for full license details
#define PYTHON_COMPILE
#include <Python.h>
#include <vector>
#include <string>
#include <csignal>

// These are included here for compabilitity reasons
#include "necsim/Setup.h"
// This provides compability for protracted speciation events.
#include "necsimmodule.h"
#include "PyLogging.h"
#include "necsim/SpatialTree.h"
#include "necsim/ProtractedTree.h"
#include "necsim/SimulationTemplates.h"
#include "necsim/ProtractedSpatialTree.h"


using namespace std;
PyObject * loggingmodule;
PyGILState_STATE gstate;
bool log_set = false;
bool logger_set = false;
PyObject * logger;

template<class T> static PyObject * run_simulation(PyObject * self, PyObject * args)
{
    char * input;
    // parse arguments
    if(!PyArg_ParseTuple(args, "s", &input))
    {
        return NULL;
    }

    // Run the main simulation
    // Mimic a command\-line simulation call
    const string &config_file = input;
    int ret = 0;
    // Check that the logging function has been set
    if(!log_set)
    {
        PyErr_SetString(NECSimError, "Logging function has not been set. Make sure set_logging_function() has been called");
        return NULL;
    }
    if(!logger_set)
    {
        PyErr_SetString(NECSimError, "Logger object has not been set. Make sure set_logger() has been called");
        return NULL;
    }
    // Run the program, catch and return any errors.
    try
    {
        Py_INCREF(logger);
        runMain<T>(config_file);
        Py_DECREF(logger);
    }
    catch(exception &e)
    {
        Py_DECREF(logger);
        PyErr_SetString(NECSimError, e.what());
        return NULL;
    }
    PyObject * pyret;
    pyret = PyLong_FromLong(ret);
    return pyret;
}

template<class T> static PyObject * resume_simulation(PyObject * self, PyObject * args)
{
    char * pause_directory;
    char* out_directory;
    int size1, size2, seed, task, max_time;
    // parse arguments
    if(!PyArg_ParseTuple(args, "ssiii", &pause_directory, &out_directory, &seed, &task, &max_time))
    {
        return NULL;
    }
    if(!log_set)
    {
        PyErr_SetString(NECSimError, "Logging function has not been set. Make sure set_logging_function() has been called");
        return NULL;
    }
    if(!logger_set)
    {
        PyErr_SetString(NECSimError, "Logger object has not been set. Make sure set_logger() has been called");
        return NULL;
    }
    // Run the main simulation
    int ret = 0;
    // Run the program, catch and return any errors.
    string pause_directory_str, out_directory_str;
    pause_directory_str = pause_directory;
    out_directory_str = out_directory;
    bool sim_complete = false;
    try
    {
        Py_INCREF(logger);
        T t;
        t.setResumeParameters(pause_directory_str, out_directory_str, seed, task, max_time);
        t.checkSims(pause_directory_str, seed, task);
        if(t.hasPaused())
        {
            t.setup();
            sim_complete = t.runSimulation();
            if(sim_complete)
            {
                t.applyMultipleRates();
            }
        }
        else
        {
            throw runtime_error("Couldn\(aqt find paused simulation");
        }
        Py_DECREF(logger);
        if(sim_complete)
        {
            Py_RETURN_TRUE;
        }
        else
        {
            Py_RETURN_FALSE;
        }
    }
    catch(exception &e)
    {
        Py_DECREF(logger);
        PyErr_SetString(NECSimError, e.what());
        return NULL;
    }
}

static PyMethodDef NECSimMethods[] =
{
    {"run_spatial", run_simulation<SpatialTree>, METH_VARARGS, "Runs the simulation from the provided config file."},
    {"run_spatial_protracted", run_simulation<ProtractedSpatialTree>, METH_VARARGS,
            "Runs the protracted simulation from the provided config file."},
    {"run_NSE", run_simulation<Tree>, METH_VARARGS,
            "Runs the non\-spatially explicit neutral model from the provided config file."},
    {"run_NSE_protracted", run_simulation<ProtractedTree>, METH_VARARGS,
            "Runs the non\-spatially explicit protracted neutral model from the provided config file."},
    {"set_log_function", set_log_function, METH_VARARGS, "calls logging"},
    {"set_logger", set_logger, METH_VARARGS, "Sets the logger to use"},
    {"resume_spatial", resume_simulation<SpatialTree>, METH_VARARGS, "Resumes the simulation with the given parameters."},
    {"resume_spatial_protracted", resume_simulation<ProtractedSpatialTree>, METH_VARARGS,
            "Resumes the protracted simulation with the given parameters."},
    {"resume_NSE", resume_simulation<Tree>, METH_VARARGS,
            "Resumes the non\-spatially explicit simulation with the given parameters"},
    {"resume_NSE_protracted", resume_simulation<ProtractedTree>, METH_VARARGS,
            "Resumes the non\-spatially explicit protracted simulation with the given parameters"},
    {NULL, NULL, 0 , NULL}
};

// Conditional compilation for python >= 3.0 (changed how python integration worked)
#if PY_MAJOR_VERSION >= 3
static int necsim_traverse(PyObject *m, visitproc visit, void *arg)
{
    Py_VISIT(GETSTATE(m)\->error);
    return 0;
}

static int necsim_clear(PyObject *m)
{
    Py_CLEAR(GETSTATE(m)\->error);
    return 0;
}

#endif


#if PY_MAJOR_VERSION >= 3
static struct PyModuleDef moduledef =
{
    PyModuleDef_HEAD_INIT,
    "necsimmodule",
    NULL,
    sizeof(struct module_state),
    NECSimMethods,
    NULL,
    necsim_traverse,
    necsim_clear,
    NULL
};


#define INITERROR return NULL

PyMODINIT_FUNC
PyInit_necsimmodule(void)
#else
#define INITERROR return

PyMODINIT_FUNC
initnecsimmodule(void)
#endif
{
    PyObject *module;
    #if PY_MAJOR_VERSION>=3
    module = PyModule_Create(&moduledef);
    #else
    module = Py_InitModule("necsimmodule", NECSimMethods);
    #endif
    if(module == NULL)
    {
        INITERROR;
    }
    // Threading support
    if(!PyEval_ThreadsInitialized())
    {
        PyEval_InitThreads();

    }
    NECSimError = PyErr_NewException((char*)"necsimmodule.NECSimError", NULL, NULL);
    Py_INCREF(NECSimError);
    PyModule_AddObject(module, "NECSimError", NECSimError);
    #if PY_MAJOR_VERSION >= 3
    return module;
    #endif
}
.ft P
.fi
.UNINDENT
.UNINDENT
.SS Detailed Description
.sp
Samuel Thompson
BSD\-3 Licence.
.SS Includes
.INDENT 0.0
.IP \(bu 2
\fB/Users/samthompson/Documents/PhD/Code/pycoalescence/pycoalescence/lib/necsim/Community.h\fP
.IP \(bu 2
\fB/Users/samthompson/Documents/PhD/Code/pycoalescence/pycoalescence/lib/necsim/CustomExceptions.h\fP
.IP \(bu 2
\fB/Users/samthompson/Documents/PhD/Code/pycoalescence/pycoalescence/lib/necsim/DataMask.h\fP
.IP \(bu 2
\fB/Users/samthompson/Documents/PhD/Code/pycoalescence/pycoalescence/lib/necsim/DataPoint.h\fP
.IP \(bu 2
\fB/Users/samthompson/Documents/PhD/Code/pycoalescence/pycoalescence/lib/necsim/DispersalCoordinator.h\fP
.IP \(bu 2
\fB/Users/samthompson/Documents/PhD/Code/pycoalescence/pycoalescence/lib/necsim/Logging.h\fP
.IP \(bu 2
\fB/Users/samthompson/Documents/PhD/Code/pycoalescence/pycoalescence/lib/necsim/Map.h\fP
.IP \(bu 2
\fB/Users/samthompson/Documents/PhD/Code/pycoalescence/pycoalescence/lib/necsim/Matrix.h\fP
.IP \(bu 2
\fB/Users/samthompson/Documents/PhD/Code/pycoalescence/pycoalescence/lib/necsim/NRrand.h\fP
.IP \(bu 2
\fB/Users/samthompson/Documents/PhD/Code/pycoalescence/pycoalescence/lib/necsim/ProtractedTree.h\fP
.IP \(bu 2
\fB/Users/samthompson/Documents/PhD/Code/pycoalescence/pycoalescence/lib/necsim/ReproductionMap.h\fP
.IP \(bu 2
\fB/Users/samthompson/Documents/PhD/Code/pycoalescence/pycoalescence/lib/necsim/Setup.h\fP
.IP \(bu 2
\fB/Users/samthompson/Documents/PhD/Code/pycoalescence/pycoalescence/lib/necsim/SimParameters.h\fP
.IP \(bu 2
\fB/Users/samthompson/Documents/PhD/Code/pycoalescence/pycoalescence/lib/necsim/SpatialTree.h\fP
.IP \(bu 2
\fB/Users/samthompson/Documents/PhD/Code/pycoalescence/pycoalescence/lib/necsim/SpeciesList.h\fP
.IP \(bu 2
\fB/Users/samthompson/Documents/PhD/Code/pycoalescence/pycoalescence/lib/necsim/Step.h\fP
.IP \(bu 2
\fB/Users/samthompson/Documents/PhD/Code/pycoalescence/pycoalescence/lib/necsim/Tree.h\fP
.IP \(bu 2
\fB/Users/samthompson/Documents/PhD/Code/pycoalescence/pycoalescence/lib/necsim/TreeNode.h\fP
.IP \(bu 2
\fBPyLogging.h\fP (file_PyLogging.h)
.IP \(bu 2
\fBPython.h\fP
.IP \(bu 2
\fBalgorithm\fP
.IP \(bu 2
\fBboost/filesystem.hpp\fP
.IP \(bu 2
\fBcmath\fP
.IP \(bu 2
\fBcsignal\fP
.IP \(bu 2
\fBcstdio\fP
.IP \(bu 2
\fBcstring\fP
.IP \(bu 2
\fBctime\fP
.IP \(bu 2
\fBfstream\fP
.IP \(bu 2
\fBiomanip\fP
.IP \(bu 2
\fBiostream\fP
.IP \(bu 2
\fBmath.h\fP
.IP \(bu 2
\fBnecsim/ProtractedSpatialTree.h\fP (file_necsim_ProtractedSpatialTree.h)
.IP \(bu 2
\fBnecsim/ProtractedTree.h\fP (file_necsim_ProtractedTree.h)
.IP \(bu 2
\fBnecsim/Setup.h\fP (file_necsim_Setup.h)
.IP \(bu 2
\fBnecsim/SimulationTemplates.h\fP (file_necsim_SimulationTemplates.h)
.IP \(bu 2
\fBnecsim/SpatialTree.h\fP (file_necsim_SpatialTree.h)
.IP \(bu 2
\fBnecsimmodule.h\fP (file_necsimmodule.h)
.IP \(bu 2
\fBsqlite3.h\fP
.IP \(bu 2
\fBsstream\fP
.IP \(bu 2
\fBstdexcept\fP
.IP \(bu 2
\fBstdio.h\fP
.IP \(bu 2
\fBstring\fP
.IP \(bu 2
\fBunistd.h\fP
.IP \(bu 2
\fBvector\fP
.UNINDENT
.SS Functions
.INDENT 0.0
.IP \(bu 2
function_initnecsimmodule
.IP \(bu 2
function_resume_simulation
.IP \(bu 2
function_run_simulation
.UNINDENT
.SS Defines
.INDENT 0.0
.IP \(bu 2
define_INITERROR
.IP \(bu 2
define_PYTHON_COMPILE
.UNINDENT
.SS Variables
.INDENT 0.0
.IP \(bu 2
variable_gstate
.IP \(bu 2
variable_log_set
.IP \(bu 2
variable_logger
.IP \(bu 2
variable_logger_set
.IP \(bu 2
variable_loggingmodule
.IP \(bu 2
variable_NECSimMethods
.UNINDENT
.SS File necsimmodule.h
.sp
Contains the functions allowing integration of the PyCoalescence python module directly to the c++.
.SS Contents
.INDENT 0.0
.IP \(bu 2
\fI\%Definition (necsimmodule.h)\fP
.IP \(bu 2
\fI\%Detailed Description\fP
.IP \(bu 2
\fI\%Includes\fP
.IP \(bu 2
\fI\%Included By\fP
.IP \(bu 2
\fI\%Classes\fP
.IP \(bu 2
\fI\%Functions\fP
.IP \(bu 2
\fI\%Defines\fP
.IP \(bu 2
\fI\%Variables\fP
.UNINDENT
.SS Definition (\fBnecsimmodule.h\fP)
.SS Program Listing for File necsimmodule.h
.INDENT 0.0
.IP \(bu 2
Return to documentation for file_necsimmodule.h
.UNINDENT
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
// This file is part of NECSim project which is released under BSD\-3 license.
// See file **LICENSE.txt** or visit https://opensource.org/licenses/BSD\-3\-Clause) for full license details
#include <Python.h>

#include <vector>
#include <string>


#ifndef NECSIM_IMPORT
#define NECSIM_IMPORT
using namespace std;
struct module_state
{
    PyObject *error;
};

#if PY_MAJOR_VERSION >= 3
#define GETSTATE(m) ((struct module_state*)PyModule_GetState(m))
#else
#define GETSTATE(m) (&_state)
static struct module_state _state;
#endif

static PyObject *NECSimError;


// Conditional compilation for python >= 3.0 (changed how python integration worked)
#if PY_MAJOR_VERSION >= 3
#define INITERROR return NULL

PyMODINIT_FUNC
PyInit_necsimmodule(void)
#else
#define INITERROR return

PyMODINIT_FUNC
initnecsimmodule(void)
#endif
;
#endif
.ft P
.fi
.UNINDENT
.UNINDENT
.SS Detailed Description
.sp
Samuel Thompson
BSD\-3 Licence.
.SS Includes
.INDENT 0.0
.IP \(bu 2
\fBPython.h\fP
.IP \(bu 2
\fBstring\fP
.IP \(bu 2
\fBvector\fP
.UNINDENT
.SS Included By
.INDENT 0.0
.IP \(bu 2
file_necsimmodule.cpp
.UNINDENT
.SS Classes
.INDENT 0.0
.IP \(bu 2
struct_module_state
.UNINDENT
.SS Functions
.INDENT 0.0
.IP \(bu 2
function_initnecsimmodule
.UNINDENT
.SS Defines
.INDENT 0.0
.IP \(bu 2
define_GETSTATE
.IP \(bu 2
define_INITERROR
.UNINDENT
.SS Variables
.INDENT 0.0
.IP \(bu 2
variable__state
.IP \(bu 2
variable_NECSimError
.UNINDENT
.SS File NRrand.h
.sp
Contains a generic random number generator. Provided by James Rosindell (\fI\%j.rosindell@imperial.ac.uk\fP) with moderate modifications by Samuel Thompson (\fI\%thomsonsed@gmail.com\fP).
.SS Contents
.INDENT 0.0
.IP \(bu 2
\fI\%Definition (necsim/NRrand.h)\fP
.IP \(bu 2
\fI\%Detailed Description\fP
.IP \(bu 2
\fI\%Includes\fP
.IP \(bu 2
\fI\%Included By\fP
.IP \(bu 2
\fI\%Classes\fP
.IP \(bu 2
\fI\%Defines\fP
.UNINDENT
.SS Definition (\fBnecsim/NRrand.h\fP)
.SS Program Listing for File NRrand.h
.INDENT 0.0
.IP \(bu 2
Return to documentation for file_necsim_NRrand.h
.UNINDENT
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
//This file is part of NECSim project which is released under BSD\-3 license.
//See file **LICENSE.txt** or visit https://opensource.org/licenses/BSD\-3\-Clause) for full license details.

#ifndef FATTAIL_H
#define FATTAIL_H
#define IM1 2147483563
#define IM2 2147483399
#define AM (1.0/IM1)
#define IMM1 (IM1\-1)
#define IA1 40014
#define IA2 40692
#define IQ1 53668
#define IQ2 5277
#define IR1 12211
#define IR2 3791
#define NTAB 32
#define NDIV (1+IMM1/NTAB)
#define EPS 1.2e\-8
#define RNMX (1.0\-EPS)

# include <cstdio>
# include <string>
# include <iomanip>
# include <cmath>
# include <vector>
# include <iostream>
# include <fstream>
#include <climits>
#include "Logging.h"

using namespace std;

class NRrand
{

private:
    long idum{};
    int j{};
    long k{};
    long idum2{};
    long iy{};
    long iv[NTAB]{};
    double temp{};
    bool seeded;

    double lastresult{};
    bool normflag;
    // for the L value of the dispersal kernel (the width \- does not affect the shape).
    double tau;
    // for the sigma value of the dispersal kernel (the variance of a normal distribution).
    double sigma;

    typedef double (NRrand::*fptr)(); // once setup will contain the dispersal function to use for this simulation.
    fptr dispersalFunction;
    // the probability that dispersal comes from the uniform distribution. This is only relevant for uniform dispersals.
    double m_prob{};
    // the cutoff for the uniform dispersal function i.e. the maximum value to be drawn from the uniform distribution.
    double cutoff{};
public:

    NRrand()
    {
        seeded = false;
        normflag = true;
        dispersalFunction = nullptr;
        sigma = 0;
        tau = 0;
    }

    void setSeed(long seed)
    {
        if(!seeded)
        {
            idum2 = 123456789;
            iy = 0;
            idum = seed;
            if(idum < 1) idum = 1;
            //Be sure to prevent idum = 0.
            idum2 = (idum);
            for(j = NTAB + 7; j >= 0; j\-\-)
            {
                //Load the shuffle table (after 8 warm\-ups).
                k = (idum) / IQ1;
                idum = IA1 * (idum \- k * IQ1) \- k * IR1;
                if(idum < 0) idum += IM1;
                if(j < NTAB) iv[j] = idum;
            }
            iy = iv[0];
            seeded = true;
        }
        else
        {
            throw runtime_error("Trying to set the seed again: this can only be set once.");
        }
    }

    double d01()
    {
        k = (idum) / IQ1;
        //Start here when not initializing.
        idum = IA1 * (idum \- k * IQ1) \- k * IR1;
        //Compute idum=(IA1*idum) % IM1 without overflows by Schrage\(aqs method.
        if(idum < 0) idum += IM1;
        k = idum2 / IQ2;
        idum2 = IA2 * (idum2 \- k * IQ2) \- k * IR2;
        //Compute idum2=(IA2*idum) % IM2 likewise.
        if(idum2 < 0) idum2 += IM2;
        j = iy / NDIV;
        //Will be in the range 0..NTAB\-1.
        iy = iv[j] \- idum2;
        //Here idum is shuffled, idum and idum2 are combined to generate output.
        iv[j] = idum;
        if(iy < 1) iy += IMM1;
        if((temp = AM * iy) > RNMX)
        {
            //os << "random call = " << "RNMAX" << "\en";
            return RNMX; //Because users don\(aqt expect endpoint values.
        }
        return temp;

    }

    unsigned long i0(unsigned long max)
    {
        return (unsigned long)(d01() * (max + 1));
    }

    double norm()
    {
        if(normflag)
        {
            double r2 = 2;
            double xx = 0;
            double yy = 0;
            while(r2 > 1)
            {
                xx = 2.0 * d01() \- 1.0;
                yy = 2.0 * d01() \- 1.0;
                r2 = (xx * xx) + (yy * yy);
            }
            double fac = sqrt(\-2.0 * log(r2) / r2);
            lastresult = xx * fac;
            double result = yy * fac;
            normflag = false;
            return sigma * result;
        }
        else
        {
            normflag = true;
            return sigma * lastresult;
        }
    }

    double norm2D()
    {
        double distx, disty;
        distx = norm();
        disty = norm();
        return pow(pow(distx, 2) + pow(disty, 2), 0.5);
    }

    void setDispersalParams(const double sigmain, const double tauin)
    {
        sigma = sigmain;
        tau = tauin; // used to invert the sign here, doesn\(aqt any more.
    }


    double fattail(double z)
    {
        double result;
        result = pow((pow(d01(), (1.0 / (1.0 \- z))) \- 1.0), 0.5);
        return result;
    }

    // this new version corrects the 1.0 to 2.0 and doesn\(aqt require the values to be passed every time.
    double fattail()
    {
        double result;
        // old function version (kept for reference)
//      result = (tau * pow((pow(d01(),(2.0/(2.0\-sigma)))\-1.0),0.5));
        result = (sigma * pow((tau * (pow(d01(), \-2.0 / tau)) \- 1.0), 0.5));
        return result;
    }

    double fattail_old()
    {
        double result;
        result = (sigma * pow((pow(d01(), (2.0 / (2.0 + tau))) \- 1.0), 0.5));
        return result;
    }

    double direction()
    {
        return(d01() * 2 * M_PI);
    }

    bool event(double event_probability)
    {
        if(event_probability < 0.000001)
        {
            if(d01() <= 0.000001)
            {
                return (event(event_probability * 1000000.0));
            }
            return false;
        }
        if(event_probability > 0.999999)
        {
            return (!(event(1.0 \- event_probability)));
        }
        return (d01() <= event_probability);


    }

    double normUniform()
    {
        // Check if the dispersal event comes from the uniform distribution
        if(d01() < m_prob)
        {
            // Then it does come from the uniform distribution
            return (d01() * cutoff);
        }
        return norm2D();
    }


    double uniformUniform()
    {
        if(d01() < 0.5)
        {
            // Then value comes from the first uniform distribution
            return (d01() * cutoff * 0.1);
        }
        // Then the value comes from the second uniform distribution
        return 0.9 * cutoff + (d01() * cutoff * 0.1);
    }

    void setDispersalMethod(const string &dispersal_method, const double &m_probin, const double &cutoffin)
    {
        if(dispersal_method == "normal")
        {
            dispersalFunction = &NRrand::norm2D;
            if(sigma < 0)
            {
                throw invalid_argument("Cannot have negative sigma with normal dispersal");
            }
        }
        else if(dispersal_method == "fat\-tail" || dispersal_method == "fat\-tailed")
        {
            dispersalFunction = &NRrand::fattail;
            if(tau < 0 || sigma < 0)
            {
                throw invalid_argument("Cannot have negative sigma or tau with fat\-tailed dispersal");
            }
        }
        else if(dispersal_method == "norm\-uniform")
        {
            dispersalFunction = &NRrand::normUniform;
            if(sigma < 0)
            {
                throw invalid_argument("Cannot have negative sigma with normal dispersal");
            }
        }
        else if(dispersal_method == "uniform\-uniform")
        {
            // This is just here for testing purposes
            dispersalFunction = &NRrand::uniformUniform;
        }
            // Also provided the old version of the fat\-tailed dispersal kernel
        else if(dispersal_method == "fat\-tail\-old")
        {
            dispersalFunction = &NRrand::fattail_old;
            if(tau > \-2 || sigma < 0)
            {
                throw invalid_argument(
                        "Cannot have sigma < 0 or tau > \-2 with fat\-tailed dispersal (old implementation).");
            }
        }
        else
        {
            throw runtime_error("Dispersal method not detected. Check implementation exists");
        }
        m_prob = m_probin;
        cutoff = cutoffin;
    }


    double dispersal()
    {
        return min(double(LONG_MAX), (this\->*dispersalFunction)());
    }

    // to reconstruct distribution, use x = fattail/squrt(1+direction) , y = fattail/squrt(1+(direction^\-1))

    friend ostream &operator<<(ostream &os, const NRrand &r)
    {
        //os << m.numRows<<" , "<<m.numCols<<" , "<<endl;
        os << setprecision(64);
        os << r.idum << ",";
        os << r.j << ",";
        os << r.k << ",";
        os << r.idum2 << ",";
        os << r.iy << ",";
        for(long i : r.iv)
        {
            os << i << ",";
        }
        os << r.temp << ",";
        os << r.seeded << ",";
        os << r.lastresult << ",";
        os << r.normflag << "," << r.tau << "," << r.sigma << "," << r.m_prob << "," << r.cutoff;
        return os;
    }

    friend istream &operator>>(istream &is, NRrand &r)
    {
//      os << "starting NR read" << endl;
        char delim;
        //double temp1,temp2;
        //is << m.numRows<<" , "<<m.numCols<<" , "<<endl;
        is >> r.idum;
//      os << r.idum << endl;
//      string tmp;
//      is >> delim >> tmp;
//      os << tmp << endl;
//      os << delim;
        is >> delim;
        is >> r.j;
        is >> delim;
        is >> r.k;
        is >> delim;
        is >> r.idum2;
        is >> delim;
        is >> r.iy;
        is >> delim;
        for(long &i : r.iv)
        {
            is >> i;
            is >> delim;
        }
        is >> r.temp;
        is >> delim;
        is >> r.seeded;
        is >> delim;
        is >> r.lastresult;
        is >> delim;
        is >> r.normflag;
        is >> delim >> r.tau >> delim >> r.sigma >> delim >> r.m_prob >> delim >> r.cutoff;
        return is;
    }
};

#endif
.ft P
.fi
.UNINDENT
.UNINDENT
.SS Detailed Description
.sp
James Rosindell
The definitions for the constants defined here should not be altered. BSD\-3 Licence.
.SS Includes
.INDENT 0.0
.IP \(bu 2
\fBLogging.h\fP (file_necsim_Logging.h)
.IP \(bu 2
\fBclimits\fP
.IP \(bu 2
\fBcmath\fP
.IP \(bu 2
\fBcstdio\fP
.IP \(bu 2
\fBfstream\fP
.IP \(bu 2
\fBiomanip\fP
.IP \(bu 2
\fBiostream\fP
.IP \(bu 2
\fBstring\fP
.IP \(bu 2
\fBvector\fP
.UNINDENT
.SS Included By
.INDENT 0.0
.IP \(bu 2
file_necsim_DispersalCoordinator.h
.IP \(bu 2
file_necsim_Tree.h
.IP \(bu 2
file_necsim_SpatialTree.h
.IP \(bu 2
file_necsim_SpeciesList.h
.IP \(bu 2
file_necsim_ReproductionMap.h
.IP \(bu 2
file_necsim_Metacommunity.h
.IP \(bu 2
file_necsim_SimulateDispersal.h
.UNINDENT
.SS Classes
.INDENT 0.0
.IP \(bu 2
class_NRrand
.UNINDENT
.SS Defines
.INDENT 0.0
.IP \(bu 2
define_AM
.IP \(bu 2
define_EPS
.IP \(bu 2
define_IA1
.IP \(bu 2
define_IA2
.IP \(bu 2
define_IM1
.IP \(bu 2
define_IM2
.IP \(bu 2
define_IMM1
.IP \(bu 2
define_IQ1
.IP \(bu 2
define_IQ2
.IP \(bu 2
define_IR1
.IP \(bu 2
define_IR2
.IP \(bu 2
define_NDIV
.IP \(bu 2
define_NTAB
.IP \(bu 2
define_RNMX
.UNINDENT
.SS File ProtractedSpatialTree.h
.sp
Contains the class_ProtractedSpatialTree class for running simulations and outputting the phylogenetic trees using protracted speciation.
.SS Contents
.INDENT 0.0
.IP \(bu 2
\fI\%Definition (necsim/ProtractedSpatialTree.h)\fP
.IP \(bu 2
\fI\%Detailed Description\fP
.IP \(bu 2
\fI\%Includes\fP
.IP \(bu 2
\fI\%Classes\fP
.IP \(bu 2
\fI\%Defines\fP
.UNINDENT
.SS Definition (\fBnecsim/ProtractedSpatialTree.h\fP)
.SS Program Listing for File ProtractedSpatialTree.h
.INDENT 0.0
.IP \(bu 2
Return to documentation for file_necsim_ProtractedSpatialTree.h
.UNINDENT
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
// This file is part of NECSim project which is released under BSD\-3 license.
// See file **LICENSE.txt** or visit https://opensource.org/licenses/BSD\-3\-Clause) for full license details.
//
#include "SpatialTree.h"
#include "ProtractedTree.h"

#ifndef SPECIATIONCOUNTER_PROTRACTEDSPATIALTREE_H
#define SPECIATIONCOUNTER_PROTRACTEDSPATIALTREE_H


class ProtractedSpatialTree : public SpatialTree, public ProtractedTree
{

};


#endif //SPECIATIONCOUNTER_PROTRACTEDSPATIALTREE_H
.ft P
.fi
.UNINDENT
.UNINDENT
.SS Detailed Description
.sp
Sam Thompson
Contact: \fI\%samuel.thompson14@imperial.ac.uk\fP or \fI\%thompsonsed@gmail.com\fP BSD\-3 Licence.
.SS Includes
.INDENT 0.0
.IP \(bu 2
\fBProtractedTree.h\fP (file_necsim_ProtractedTree.h)
.IP \(bu 2
\fBSpatialTree.h\fP (\fI\%File ProtractedSpatialTree.h\fP)
.UNINDENT
.SS Classes
.INDENT 0.0
.IP \(bu 2
class_ProtractedSpatialTree
.UNINDENT
.SS Defines
.INDENT 0.0
.IP \(bu 2
define_SPECIATIONCOUNTER_PROTRACTEDSPATIALTREE_H
.UNINDENT
.SS File ProtractedTree.cpp
.sp
Contains the class_ProtractedTree class for running simulations and outputting the phylogenetic trees using protracted speciation.
.SS Contents
.INDENT 0.0
.IP \(bu 2
\fI\%Definition (necsim/ProtractedTree.cpp)\fP
.IP \(bu 2
\fI\%Detailed Description\fP
.IP \(bu 2
\fI\%Includes\fP
.UNINDENT
.SS Definition (\fBnecsim/ProtractedTree.cpp\fP)
.SS Program Listing for File ProtractedTree.cpp
.INDENT 0.0
.IP \(bu 2
Return to documentation for file_necsim_ProtractedTree.cpp
.UNINDENT
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
// This file is part of NECSim project which is released under BSD\-3 license.
// See file **LICENSE.txt** or visit https://opensource.org/licenses/BSD\-3\-Clause) for full license details.
//
#include "ProtractedTree.h"


bool ProtractedTree::calcSpeciation(const long double & random_number,
                                    const long double & speciation_rate,
                                    const unsigned long & no_generations)
{
    if(generation < speciation_generation_min)
    {
        return false;
    }
    if(generation > speciation_generation_max)
    {
        return true;
    }
    return checkSpeciation(random_number, speciation_rate, no_generations);
}

void ProtractedTree::speciateLineage(const unsigned long &data_position)
{
    data[data_position].setSpec(0.0);
    if(speciation_generation_min >= data[data_position].getGenRate() + data[data_position].getGeneration())
    {
        data[data_position].setGenerationRate(static_cast<unsigned long>(floor(speciation_generation_min)) + 2);
    }
#ifdef DEBUG
    if(generation < speciation_generation_min)
    {
        data[data_position].logLineageInformation(50);
        throw FatalException("Speciation attempted before minimum speciation generation. Please report this bug.");
    }
#endif // DEBUG
    data[data_position].speciate();
}

bool ProtractedTree::getProtracted()
{
    return true;
}

void ProtractedTree::setProtractedVariables(double speciation_gen_min_in, double speciation_gen_max_in)
{
    speciation_generation_min = speciation_gen_min_in;
    speciation_generation_max = speciation_gen_max_in;
}

string ProtractedTree::getProtractedVariables()
{
    stringstream ss;
    ss << speciation_generation_min << "\en" << speciation_generation_max << "\en";
    return ss.str();
}

double ProtractedTree::getProtractedGenerationMin()
{
    return speciation_generation_min;
}

double ProtractedTree::getProtractedGenerationMax()
{
    return speciation_generation_max;
}

string ProtractedTree::protractedVarsToString()
{
    string tmp = "1 , " + to_string(speciation_generation_min) + ", " + to_string(speciation_generation_max);
    return tmp;
}
.ft P
.fi
.UNINDENT
.UNINDENT
.SS Detailed Description
.sp
Sam Thompson
12/07/2017
Contact: \fI\%samuel.thompson14@imperial.ac.uk\fP or \fI\%thompsonsed@gmail.com\fP BSD\-3 Licence.
.SS Includes
.INDENT 0.0
.IP \(bu 2
\fBProtractedTree.h\fP (file_necsim_ProtractedTree.h)
.UNINDENT
.SS File ProtractedTree.h
.sp
Contains the protracted tree class, for running simulations with procated speciation.
.SS Contents
.INDENT 0.0
.IP \(bu 2
\fI\%Definition (necsim/ProtractedTree.h)\fP
.IP \(bu 2
\fI\%Detailed Description\fP
.IP \(bu 2
\fI\%Includes\fP
.IP \(bu 2
\fI\%Included By\fP
.IP \(bu 2
\fI\%Classes\fP
.UNINDENT
.SS Definition (\fBnecsim/ProtractedTree.h\fP)
.SS Program Listing for File ProtractedTree.h
.INDENT 0.0
.IP \(bu 2
Return to documentation for file_necsim_ProtractedTree.h
.UNINDENT
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
// This file is part of NECSim project which is released under BSD\-3 license.
// See file **LICENSE.txt** or visit https://opensource.org/licenses/BSD\-3\-Clause) for full license details.
//
#include <vector>
#include <string>

#include "SpatialTree.h"

#ifndef PROTRACTED_SPATIAL_TREE_H
#define PROTRACTED_SPATIAL_TREE_H

class ProtractedTree : public virtual Tree
{
private:
    // Variables for the protracted speciation variables
    // The number of generations a lineage must exist before speciating.
    // Speciation is therefore not allowed before this time.
    // If this value is 0, it has no effect.
    double speciation_generation_min;
    // The number of generations a lineage can exist before speciating.
    // All remaining lineages are speciated at this time.
    // If this value is 0, it has no effect.
    double speciation_generation_max;
public:

    ProtractedTree() : Tree()
    {
        bIsProtracted = true;
        speciation_generation_min = 0.0;
        speciation_generation_max = 0.0;
    }

    bool calcSpeciation(const long double & random_number,
                        const long double & speciation_rate,
                        const unsigned long & no_generations) override;

    void speciateLineage(const unsigned long &data_position) override;

    bool getProtracted() override;

    void setProtractedVariables(double speciation_gen_min, double speciation_gen_max) override;

    string getProtractedVariables() override;

    double getProtractedGenerationMin() override;

    double getProtractedGenerationMax() override;

    string protractedVarsToString() override;

    void applySpecRate(double sr, double t);
};

#endif // PROTRACTED_SPATIAL_TREE_H
.ft P
.fi
.UNINDENT
.UNINDENT
.SS Detailed Description
.sp
Contains the class_ProtractedTree class for running simulations and outputting the phylogenetic trees using protracted speciation.
Sam Thompson
Contact: \fI\%samuel.thompson14@imperial.ac.uk\fP or \fI\%thompsonsed@gmail.com\fP BSD\-3 Licence.
.SS Includes
.INDENT 0.0
.IP \(bu 2
\fBSpatialTree.h\fP (file_necsim_ProtractedSpatialTree.h)
.IP \(bu 2
\fBstring\fP
.IP \(bu 2
\fBvector\fP
.UNINDENT
.SS Included By
.INDENT 0.0
.IP \(bu 2
file_necsim_ProtractedSpatialTree.h
.IP \(bu 2
file_necsim_ProtractedTree.cpp
.UNINDENT
.SS Classes
.INDENT 0.0
.IP \(bu 2
class_ProtractedTree
.UNINDENT
.SS File PyLogging.cpp
.sp
Routines for writing to python logging module.
.SS Contents
.INDENT 0.0
.IP \(bu 2
\fI\%Definition (PyLogging.cpp)\fP
.IP \(bu 2
\fI\%Detailed Description\fP
.IP \(bu 2
\fI\%Includes\fP
.IP \(bu 2
\fI\%Functions\fP
.IP \(bu 2
\fI\%Defines\fP
.UNINDENT
.SS Definition (\fBPyLogging.cpp\fP)
.SS Program Listing for File PyLogging.cpp
.INDENT 0.0
.IP \(bu 2
Return to documentation for file_PyLogging.cpp
.UNINDENT
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
//This file is part of NECSim project which is released under BSD\-3 license.
//See file **LICENSE.txt** or visit https://opensource.org/licenses/BSD\-3\-Clause) for full license details.
#ifndef PYTHON_COMPILE
#define PYTHON_COMPILE
#endif
#include <Python.h>
#include <string>
#include <sstream>
#include "necsim/Logging.h"
#include "PyLogging.h"

void writeInfo(string message)
{

    write_log(20, std::move(message));
}

void writeWarning(string message)
{
    write_log(30, std::move(message));
}

void writeError(string message)
{
    write_log(40, std::move(message));
}

void writeCritical(string message)
{
    write_log(50, std::move(message));
}
#ifdef DEBUG
void writeLog(const int &level, string message)
{
    static LogFile logfile;
    logfile.write(level, std::move(message));
}

void writeLog(const int &level, stringstream &message)
{
    writeLog(level, message.str());
}

#endif // DEBUG
PyObject * set_log_function(PyObject *dummy, PyObject *args)
{
    PyObject *res = nullptr;
    PyObject *temp;
    if(PyArg_ParseTuple(args, "O:set_callback", &temp))
    {
        if (!PyCallable_Check(temp))
        {
            PyErr_SetString(PyExc_TypeError, "parameter must be callable");
            return nullptr;
        }
        Py_XINCREF(temp);         /* Add a reference to new callback */

        Py_XDECREF(call_logging);  /* Dispose of previous callback */
        call_logging = temp;       /* Remember new callback */
        /* Boilerplate to return "None" */
        Py_INCREF(Py_None);
        res = Py_None;
        log_set = true;
    }
    return res;
}

void write_log(int level, char * message)
{
    if(PyErr_CheckSignals()!=0)
    {
        throw runtime_error("Keyboard interrupt detected.");
    }
    PyObject *arglist, *res;
#ifdef DEBUG
    if(!logger_set)
    {
        throw runtime_error(
            "Logger object has not been set. Check set_logging_function() has been called in python");
    }
    if(logger == NULL)
    {
        throw invalid_argument("Logger object has been deferenced, please report this bug!");
    }
#endif // DEBUG
    arglist = Py_BuildValue("isO", level, message, logger);
    // Throw different errors if logging function has not been set
#ifdef DEBUG
    if(!log_set)
    {
        throw runtime_error(
            "Logging function has not been set. Check set_logging_function() has been called in python");
    }
    if(call_logging == NULL)
    {
        Py_DECREF(arglist);
        throw invalid_argument("Logging function has been dereferenced, please report this bug!");
    }
#endif // DEBUG
    res = PyObject_CallObject(call_logging, arglist);
    Py_DECREF(arglist);
    Py_XDECREF(res);
}

void write_log(int level, string message)
{
    char * msg;
    msg = (char* )message.c_str();
    write_log(level, msg);
#ifdef DEBUG
    // Also write to the log file \- stored in logfile.log
    writeLog(level, message);
#endif // DEBUG
}

PyObject * set_logger(PyObject * self, PyObject * args)
{
    PyObject * tmplogger;
    if(!PyArg_ParseTuple(args, "O", &tmplogger))
    {
        return NULL;
    }
    Py_XINCREF(tmplogger);         /* Add a reference to new callback */
    Py_XDECREF(logger);  /* Dispose of previous callback */
    logger = tmplogger;       /* Remember new callback */
    /* Boilerplate to return "None" */
    Py_INCREF(Py_None);
    logger_set = true;
    Py_RETURN_NONE;
}
.ft P
.fi
.UNINDENT
.UNINDENT
.SS Detailed Description
.sp
Sam Thompson
BSD\-3 Licence.
.SS Includes
.INDENT 0.0
.IP \(bu 2
\fBPyLogging.h\fP (file_PyLogging.h)
.IP \(bu 2
\fBPython.h\fP
.IP \(bu 2
\fBnecsim/Logging.h\fP (file_necsim_Logging.h)
.IP \(bu 2
\fBsstream\fP
.IP \(bu 2
\fBstring\fP
.UNINDENT
.SS Functions
.INDENT 0.0
.IP \(bu 2
function_set_log_function
.IP \(bu 2
function_set_logger
.IP \(bu 2
function_write_log
.IP \(bu 2
function_write_log
.IP \(bu 2
function_writeCritical
.IP \(bu 2
function_writeError
.IP \(bu 2
function_writeInfo
.IP \(bu 2
function_writeWarning
.UNINDENT
.SS Defines
.INDENT 0.0
.IP \(bu 2
define_PYTHON_COMPILE
.UNINDENT
.SS File PyLogging.h
.sp
Routines for writing to python logging module.
.SS Contents
.INDENT 0.0
.IP \(bu 2
\fI\%Definition (PyLogging.h)\fP
.IP \(bu 2
\fI\%Detailed Description\fP
.IP \(bu 2
\fI\%Includes\fP
.IP \(bu 2
\fI\%Included By\fP
.IP \(bu 2
\fI\%Functions\fP
.IP \(bu 2
\fI\%Variables\fP
.UNINDENT
.SS Definition (\fBPyLogging.h\fP)
.SS Program Listing for File PyLogging.h
.INDENT 0.0
.IP \(bu 2
Return to documentation for file_PyLogging.h
.UNINDENT
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
//This file is part of NECSim project which is released under BSD\-3 license.
//See file **LICENSE.txt** or visit https://opensource.org/licenses/BSD\-3\-Clause) for full license details.

#ifndef PYLOGGING_H
#define PYLOGGING_H
#include "Python.h"
#include <string>
#include "necsim/LogFile.h"

extern PyObject * loggingmodule;
extern PyGILState_STATE gstate;
extern bool log_set;
extern bool logger_set;

static PyObject * call_logging = nullptr;


extern PyObject *logger;

PyObject * set_log_function(PyObject *dummy, PyObject *args);

PyObject * set_logger(PyObject * self, PyObject * args);

void write_log(int level, char * message);

void write_log(int level, string message);

#endif // PYLOGGING_H
.ft P
.fi
.UNINDENT
.UNINDENT
.SS Detailed Description
.sp
Sam Thompson
BSD\-3 Licence.
.SS Includes
.INDENT 0.0
.IP \(bu 2
\fBPython.h\fP
.IP \(bu 2
\fBnecsim/LogFile.h\fP (file_necsim_LogFile.h)
.IP \(bu 2
\fBstring\fP
.UNINDENT
.SS Included By
.INDENT 0.0
.IP \(bu 2
file_applyspecmodule.cpp
.IP \(bu 2
file_dispersalmodule.cpp
.IP \(bu 2
file_necsimmodule.cpp
.IP \(bu 2
file_PyLogging.cpp
.UNINDENT
.SS Functions
.INDENT 0.0
.IP \(bu 2
function_set_log_function
.IP \(bu 2
function_set_logger
.IP \(bu 2
function_write_log
.IP \(bu 2
function_write_log
.UNINDENT
.SS Variables
.INDENT 0.0
.IP \(bu 2
variable_call_logging
.IP \(bu 2
variable_gstate
.IP \(bu 2
variable_log_set
.IP \(bu 2
variable_logger
.IP \(bu 2
variable_logger_set
.IP \(bu 2
variable_loggingmodule
.UNINDENT
.SS File README.md
.SS Contents
.INDENT 0.0
.IP \(bu 2
\fI\%Definition (necsim/README.md)\fP
.UNINDENT
.SS Definition (\fBnecsim/README.md\fP)
.SS Program Listing for File README.md
.INDENT 0.0
.IP \(bu 2
Return to documentation for file_necsim_README.md
.UNINDENT
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
# necsim #

Version: 1.0
This project is released under BSD\-3
See file **LICENSE.txt** or go to [here](https://opensource.org/licenses/BSD\-3\-Clause) for full license details.

## CONTENTS ##
* **INTRODUCTION**
* **INSTRUCTIONS**
* **REQUIREMENTS**
* **DEGUGGING**
* **CLASS DESCRIPTIONS**
* **KNOWN BUGS**
* **FAQS**
* **CONTACTS**

## INTRODUCTION ##

necsim is a generic spatial coalescence simulator for neutral systems. It applies the model to map objects, which can change over time, for a specific set of supplied parameters, and outputs information for each individual to a SQL database.

necsim includes functionality for applying varying speciation rates after simulations are complete. This enables the main simulation to be run with the *minimum* speciation rate required and afterwards analysis can be completed using different speciation rates.

The recommended method of usage is through the pycoalescence package, using a python interface for installation, simulation setup and running. See [here](http://pycoalescence.readthedocs.io/) for more details.

You are free to modify and distribute the code as per the license specified in **LICENCE.txt** to suit any additional neutral simulation requirements (or any other purpose).

## INSTRUCTIONS ##
###Compiling the program###
See the Requirements section for a full list of the necessary prerequisites. Once these are installed, compiling the program should be relatively easy. NECSim requires a linker to the boost libraries, as well as the sqlite3 library. It is recommended to run with the maximum optimisation possible.


Additionally, if support is required for tif files (an alternative to importing csv files), the [gdal library](http://www.gdal.org/) is required. See the online documentation for help compiling gdal for your operating system. When compiling using gdal, use the \(ga\(ga\(ga\-D with_gdal\(ga\(ga\(ga compilation flag.

For compilation on High Performance Computing (HPC) systems, they will likely use intel compilers. The header files for the sqlite and boost packages may need to be copied in to the working directory to avoid problems with linking to libraries. Check the service providers\(aq documentation for whether these libraries are already installed on the HPC.
for the application of different speciation rates.

###Running simulations###
The routine relies on supplying command line arguments (see below) for all the major simulation variables. Alternatively, supplying a config .txt file and using the command line arguments \(ga./necsim \-c /path/to/config.txt\(ga can be used for parsing command line arguments from the text file.

####Command Line Arguments ####
The following command line arguments are required. This list can be accessed by running \(ga“./necsim \-h”\(ga or \(ga./necsim \-help\(ga

The command line options to be specified are:

1. the seed for the simulation.
2. the simulation task (for file reference).
3. the map config file.
4. the output directory.
5. the minimum speciation rate.
6. the dispersal sigma value.
7. the dispersal tau value.
8. the deme size.
9. the deme sample size.
10. the maximum simulation time (in seconds).
11. the lambda value for moving through non\-habitat.
12. the temporal sampling file containing tab\-separated generation values for sampling points in time (null for only sampling the present)
13. the minimum number of species known to exist. (Currently has no effect).
14. (and onwards) speciation rates to apply after simulation.

In this set up, the map config file contains a file on each line, with tab separation between the different variables. The "ref" flag contains the object type, followed by all other parameters. An example is given below.

ref=sample_grid path=/path/to/file  x=100   y=200   mask=/path/to/mask
ref=fine_map    path=/path/to/file  x=100   y=200   x_off=10    y_off=20
ref=pristine_fine   path=/path/to/file  number=n    rate=r  time=g

Alternatively, by specifying the \-f flag, (full mode) as the first argument, the program can read in extended command line arguments, which are as followed.

1. the task_iter used for setting the seed.
2. the sample grid x dimension
3. the sample grid y dimension
4. the fine map file relative path.
5. the fine map x dimension
6. the fine map y dimension
7. the fine map x offset
8. the fine map y offset
9. the coarse map file relative path.
10. the coarse map x dimension
11. the coarse map y dimension
12. the coarse map x offset
13. the coarse map y offset
14. the scale of the coarse map compared to the fine (10 means resolution of coarse map = 10 x resolution of fine map)
15. the output directory
16. the speciation rate.
17. the dispersal sigma value.
18. the deme size
19. the deme sample size (as a proportion of deme size)
20. the time to run the simulation (in seconds).
21. lambda \- the relative cost of moving through non\-forest
22. the_task \- for referencing the specific task later on.
23. the minimum number of species the system is known to contain.
24. the pristine fine map file to use
25. the pristine coarse map file to use
26. the rate of forest change from pristine
27. the time (in generations) since the pristine forest was seen.
28. the dispersal tau value (the width of the kernel.
29. the sample mask, with binary 1:0 values for areas that we want to sample from. If this is not provided then this will default to mapping the whole area.
30.  the link to the file containing every generation that the list should be expanded. This should be in the format of a list.
31. (and onwards) \- speciation rates to apply after the simulation is complete.

####Config Files ####
The program also accepts a config file, specified by running \(ga./necsim \-c /path/to/config.txt\(ga. The format of the config file is
\(ga\(ga\(ga
rand_seed = i
sample_x_dim = i
sample_y_dim = i
fine_source = /path/to/fine.csv
fine_x_dim = i
fine_y_dim = i
fine_x_offset = i
fine_y_offset = i
coarse_source = /path/to/coarse.csv
coarse_x_dim = i
coarse_y_dim = i
coarse_x_offset = i
coarse_y_offset = i
coarse_scale = i
output_dir = /path/to/outdir
spec_rate = d
zfat = f
deme_size = i
deme_sample = d
wall_time = i
lambda = 1
job_num = i
est_spec = i
pristine_fine_source = /path/to/pristine/fine.csv
pristine_coarse_source = /path/to/pristine/coarse.csv
forest_change = d
time_since = f
dispersal = f
sampledatamask = /path/to/sample/mask.csv
time_config_file = /path/to/time/file.txt
speciationrate1 = d
speciationrate2 = d
\&...
\(ga\(ga\(ga
where \(gai\(ga represents a positive integer, \(gad\(ga is a decimal value between 0 and 1, and \(gaf\(ga is any positive number (float). Whilst this does help with readability of the code, the order of the arguments is essential at this stage (i.e. don\(aqt switch the order of the lines). Future versions may alter the system of reading such that the parameters are set according to their key. Any number of speciation rates (or 0) can be at the end of the file.

####Outputs####
Upon successful completion of a simulation, necsim will produce an SQLite database file in the output directory in an SQL\e_data folder. This database contains several tables, which can be accessed using a program like [DB Browser for SQLite](http://sqlitebrowser.org/) or Microsoft Access. Alternatively, most programming languages have an SQLite interface ([RSQlite](https://cran.r\-project.org/web/packages/RSQLite/index.html), [python sqlite3](https://docs.python.org/2/library/sqlite3.html))

* The main table within the database is the SPECIES\e_LIST table, which is the location and inheritence of every lineage recorded. Several other important data structures (such as whether it is a "tip" of the phylogenetic tree of not) which are used  when re\-constructing the species identity.
* A secondary output from necims is a SIMULATION\e_PARAMETERS table for identifying the exact parameters with which the model is run.
* SpeciationCounter also produces a SPECIES_ABUNDANCES table containing species abundances across the whole sample map, plus (optionally) a table of SPECIES\e_LOCATIONS (containing the x,y location of every individual) and FRAGMENT\e_ABUNDANCES (species abundances for each habitat fragment separately).

## REQUIREMENTS ##
* The SQLite library available [here](https://www.sqlite.org/download.html).
* The Boost library available [here](http://www.boost.org).
* The fast\-cpp\-csv\-parser by Ben Strasser, available [here](https://github.com/ben\-strasser/fast\-cpp\-csv\-parser).
* C++ compiler (such as GNU g++) with C++11 support.
* Access to the relevant folders for Default simulations (see FAQS).


## CLASS DESCRIPTIONS ##


A brief description of the important classes is given below. Some classes also contain customised exceptions for better tracing of error handling.

* The \(gaTree\(ga class.
    \- The most important class!
    \- Contains the main setup, run and data output routines.
    \- Setup imports the data files from csv (if necessary) and creates the in\-memory objects for the storing of the coalescence tree and the spatial grid of active lineages. Setup time mostly depends on the size of the csv file being imported.
    \- Run continually loops over sucessive coalesence, move or speciation events until all individuals have speciated or coalesced. This is where the majority of the simulation time will be, and is mostly dependent on the number of individuals, speciation rate and size of the spatial grid.
    \- At the end of the simulation, the sqlCreate() routine will generate the in\-memory SQLite database for storing the coalescent tree. It can run multiple times if multiple speciation rates are required. outputData() will then be called to create a small csv file containing important information, and output the SQLite database to file if required.
* The \(gaTreeNode\(ga class
    \- Contains a single record of a node on the phylogenetic tree, to be used in reassembling the tree structure at the end of the simulation.
    \- Operations are mostly basic getters and setters, with functionality called from higher\-level functions.
    \- An array of treenodes makes up the \(gadata\(ga object in \(gaTree\(ga.
* The \(gaDataPoint\(ga class
    \- Contains a single record of the location of a lineage.
    \- An array of datapoints makes up the \(gaactive\(ga object in \(gaTree\(ga.
    \- \(gaendactive\(ga refers to the number of lineages currently being simulated. After each coalescence or speciation event this will decrease.
* The \(gaNRrand\(ga class
    \- Contains the random number generator, as written by James Rosindell (j.rosindell@imperial.ac.uk).
* The \(gaMap\(ga class
    \- Contains the routines for importing and calling values from the map objects.
    \- The \(gagetVal()\(ga and \(garunDispersal()\(ga functions can be modified to produce altered dispersal behaviour, or alterations to the structure of the map.
* The \(gaMatrix\(ga and \(gaRow\(ga classes
    \- Based on code written by James Rosindell (j.rosindell@imperial.ac.uk).
    \- Handles indexing of the 2D object plus importing values from a csv file.
* The \(gaSpeciesList\(ga class
    \- Contains the list of individuals, for application in a matrix, to essentially create a 3D array.
    \- Handles the positioning of individuals in space within a grid cell.
* The \(gaConfigOption\(ga class
    \- Contains basic functions for importing command line arguments from a config file, providing an alternative way of setting up simulations.
* The \(gaTreeList\(ga class
     \- Provides the routines for applying different speciation rates to a phylogenetic tree, to be used either immediately after simulation within necsim, or at a later time using SpeciationCounter.cpp

## KNOWN BUGS ##
* Simulations run until completion, rather than aiming for a desired number of species. This is an intentional change. Functions related to this functionality remain but are deprecated.
* Only continuous rectangular fragments are properly calculated. Other shapes must be calculated by post\-processing.
* 3 fragments instead of 2 will be calculated for certain adjacent rectangular patches.

## FAQS (WIP) ##
* **How do I get started?**
    \- It is recommended to use the [pycoalescence](http://pycoalescence.readthedocs.io/) package which simplifies installation of necsim, setting up and running simulations. This provides a much easier way to get started with necsim.

* **Why can’t I compile the program?**
    \- This could be due to a number of reasons, most likely that you haven’t compiled with access to the lsqlite3 or boost packages. Installation and compilation differs across different systems; for most UNIX systems, compiling with the linker arguments \-lsqlite3 \-lboost_filesystem and \-lboost_system will solve problems with the compiler not finding the sqlite or boost header file.
    \- Another option could be the potential lack of access to the fast\-cpp\-csv\-parser by Ben Strasser, available [here](https://github.com/ben\-strasser/fast\-cpp\-csv\-parser). If use\e_csv has been defined at the head of the file, try without use_csv or download the csv parser and locate the folder within your working directory at compilation.


* **Every time the program runs I get error code XXX.**
    \- Check the ERROR_REF.txt file for descriptions of the files. Try running in debug mode by compiling with \(ga\(ga\(ga\-DDEBUG\(ga\(ga\(ga to gain more information on the problem. Check the log output in /logs. It is most likely a problem with the set up of the map data (error checking is not yet properly implemented here).

## CONTACTS##
Author: **Samuel Thompson**

Contact: samuelthompson14@imperial.ac.uk \- thompsonsed@gmail.com

Institution: Imperial College London and National University of Singapore

Based heavily on code by **James Rosindell**

Contact: j.rosindell@imperial.ac.uk

Institution: Imperial College London
.ft P
.fi
.UNINDENT
.UNINDENT
.SS File ReproductionMap.cpp
.sp
Contains the class_ReproductionMap, which inherits from template_class_Matrix and adds a few extra parameters.
.SS Contents
.INDENT 0.0
.IP \(bu 2
\fI\%Definition (necsim/ReproductionMap.cpp)\fP
.IP \(bu 2
\fI\%Detailed Description\fP
.IP \(bu 2
\fI\%Includes\fP
.UNINDENT
.SS Definition (\fBnecsim/ReproductionMap.cpp\fP)
.SS Program Listing for File ReproductionMap.cpp
.INDENT 0.0
.IP \(bu 2
Return to documentation for file_necsim_ReproductionMap.cpp
.UNINDENT
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
//This file is part of NECSim project which is released under BSD\-3 license.
//See file **LICENSE.txt** or visit https://opensource.org/licenses/BSD\-3\-Clause) for full license details.

#include "ReproductionMap.h"

void ReproductionMap::import(string file_name, unsigned long size_x, unsigned long size_y)
{
    map_file = file_name;
    if(file_name == "null" || file_name == "none")
    {
        null_map = true;
    }
    else
    {
        null_map = false;
        reproduction_map.SetSize(size_y, size_x);
        reproduction_map.import(file_name);
        for(unsigned long y = 0; y < reproduction_map.GetRows(); y++)
        {
            for(unsigned long x = 0; x < reproduction_map.GetCols(); x++)
            {
                if(reproduction_map[y][x] > max_val)
                {
                    max_val = reproduction_map[y][x];
                }
            }
        }
    }
    setReproductionFunction();
}

void ReproductionMap::setReproductionFunction()
{
    if(null_map)
    {
        reproductionMapChecker_fptr = &ReproductionMap::rejectionSampleNull;
    }
    else
    {
        reproductionMapChecker_fptr = &ReproductionMap::rejectionSample;
    }
}

void ReproductionMap::setOffsets(const unsigned long &x_offset, const unsigned long &y_offset,
                                 const unsigned long &xdim, const unsigned long &ydim)
{
    offset_x = x_offset;
    offset_y = y_offset;
    x_dim = xdim;
    y_dim = ydim;
}


bool ReproductionMap::rejectionSampleNull(NRrand &random_number, const unsigned long &x, const unsigned long &y,
                                      const long &xwrap, const long &ywrap)
{
    return true;
}

bool ReproductionMap::rejectionSample(NRrand &random_number, const unsigned long &x, const unsigned long &y,
                                      const long &xwrap, const long &ywrap)
{
    return random_number.d01() <= getVal(x, y, xwrap, ywrap);
}

double ReproductionMap::getVal(const unsigned long &x, const unsigned long &y, const long &xwrap, const long &ywrap)
{
    unsigned long x_ref = x + (xwrap * x_dim) + offset_x;
    unsigned long y_ref = y + (ywrap * y_dim) + offset_y;
    return reproduction_map[y_ref][x_ref];
}

bool ReproductionMap::hasReproduced(NRrand &random_number, const unsigned long &x, const unsigned long &y, const long &xwrap,
                               const long &ywrap)
{
    return (this\->*reproductionMapChecker_fptr)(random_number, x, y, xwrap, ywrap);
}
.ft P
.fi
.UNINDENT
.UNINDENT
.SS Detailed Description
.sp
Samuel Thompson
16/08/2017
BSD\-3 Licence.
.SS Includes
.INDENT 0.0
.IP \(bu 2
\fBReproductionMap.h\fP (file_necsim_ReproductionMap.h)
.UNINDENT
.SS File ReproductionMap.h
.sp
Contains the class_ReproductionMap, which inherits from template_class_Matrix and adds a few extra parameters.
.SS Contents
.INDENT 0.0
.IP \(bu 2
\fI\%Definition (necsim/ReproductionMap.h)\fP
.IP \(bu 2
\fI\%Detailed Description\fP
.IP \(bu 2
\fI\%Includes\fP
.IP \(bu 2
\fI\%Included By\fP
.IP \(bu 2
\fI\%Classes\fP
.UNINDENT
.SS Definition (\fBnecsim/ReproductionMap.h\fP)
.SS Program Listing for File ReproductionMap.h
.INDENT 0.0
.IP \(bu 2
Return to documentation for file_necsim_ReproductionMap.h
.UNINDENT
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
//This file is part of NECSim project which is released under BSD\-3 license.
//See file **LICENSE.txt** or visit https://opensource.org/licenses/BSD\-3\-Clause) for full license details.

#ifndef REPRODUCTIONMAP_H
#define REPRODUCTIONMAP_H

#include <cstring>
#include <string>
#include <stdio.h>
#include <iostream>
#include <fstream>

#include "Matrix.h"
#include "NRrand.h"


class ReproductionMap
{
protected:
    // Matrix containing the relative reproduction probabilities
    Matrix<double> reproduction_map;
    // Path to the map file
    string map_file;
    // Maximum value across the map
    double max_val;
    // If true,
    bool null_map;
    // The fine map offsets and the sample map dimensions
    unsigned long offset_x, offset_y, x_dim, y_dim;
    // Function pointer for our reproduction map checker
    typedef bool (ReproductionMap::*rep_ptr)(NRrand &random_no,
                                             const unsigned long &x, const unsigned long &y,
                                             const long &xwrap, const long &ywrap);
    // once setup will contain the end check function to use for this simulation.
    rep_ptr reproductionMapChecker_fptr;
public:
    ReproductionMap()
    {
        map_file = "none";
        max_val = 0;
        null_map = true;
    }

    void import(string file_name, unsigned long size_x, unsigned long size_y);

    void setReproductionFunction();

    void setOffsets(const unsigned long &x_offset, const unsigned long &y_offset,
                    const unsigned long &xdim, const unsigned long &ydim);

    bool rejectionSampleNull(NRrand &random_number, const unsigned long &x, const unsigned long &y, const long &xwrap,
                             const long &ywrap);

    bool rejectionSample(NRrand &random_number, const unsigned long &x, const unsigned long &y,
                     const long &xwrap, const long &ywrap);

    double getVal(const unsigned long &x, const unsigned long &y, const long &xwrap, const long &ywrap);

    bool hasReproduced(NRrand &random_number, const unsigned long &x, const unsigned long &y,
                       const long &xwrap, const long &ywrap);

    Row<double> operator[](long index)
    {
        return reproduction_map[index];
    }

    friend ostream& operator<<(ostream& os, ReproductionMap&r)
    {
        os << r.map_file << "\en";
        os << r.reproduction_map.GetCols() << "\en";
        os << r.reproduction_map.GetRows() << "\en";
        os << r.offset_x << "\en";
        os << r.offset_y << "\en";
        os << r.x_dim << "\en";
        os << r.y_dim << "\en";
        return os;
    }

    friend istream& operator>>(istream &is, ReproductionMap &r)
    {
        is.ignore();
        getline(is, r.map_file);
        unsigned long col, row;
        is >> col >> row;
        is >> r.offset_x >> r.offset_y >> r.x_dim >> r.y_dim;
        r.import(r.map_file, col, row);
        return is;
    }


};


#endif //REPRODUCTIONMAP_H
.ft P
.fi
.UNINDENT
.UNINDENT
.SS Detailed Description
.sp
Samuel Thompson
16/08/2017
BSD\-3 Licence.
.SS Includes
.INDENT 0.0
.IP \(bu 2
\fBMatrix.h\fP (file_necsim_Matrix.h)
.IP \(bu 2
\fBNRrand.h\fP (file_necsim_NRrand.h)
.IP \(bu 2
\fBcstring\fP
.IP \(bu 2
\fBfstream\fP
.IP \(bu 2
\fBiostream\fP
.IP \(bu 2
\fBstdio.h\fP
.IP \(bu 2
\fBstring\fP
.UNINDENT
.SS Included By
.INDENT 0.0
.IP \(bu 2
file_necsim_SpatialTree.h
.IP \(bu 2
file_necsim_ReproductionMap.cpp
.UNINDENT
.SS Classes
.INDENT 0.0
.IP \(bu 2
class_ReproductionMap
.UNINDENT
.SS File Setup.cpp
.sp
Contains the command line parsing and setup options for NECSim.
.SS Contents
.INDENT 0.0
.IP \(bu 2
\fI\%Definition (necsim/Setup.cpp)\fP
.IP \(bu 2
\fI\%Detailed Description\fP
.IP \(bu 2
\fI\%Includes\fP
.IP \(bu 2
\fI\%Functions\fP
.IP \(bu 2
\fI\%Variables\fP
.UNINDENT
.SS Definition (\fBnecsim/Setup.cpp\fP)
.SS Program Listing for File Setup.cpp
.INDENT 0.0
.IP \(bu 2
Return to documentation for file_necsim_Setup.cpp
.UNINDENT
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
//This file is part of NECSim project which is released under BSD\-3 license.
//See file **LICENSE.txt** or visit https://opensource.org/licenses/BSD\-3\-Clause) for full license details.
//
#include "Setup.h"
#include "Logging.h"
// Global variables
// store the log file name for access anywhere.
string log_name = "null";
// the old stdout
int saved_stdout;


#ifndef verbose

void openLogFile(bool append)
{
    // If verbose mode is not defined, we output to a log file instead of to the terminal
    // Get the current time
    saved_stdout = dup(fileno(stdout));
    //dup2(stdout, 1);
    auto t = time(nullptr);
    auto tp = *localtime(&t);
    // get the time string
    ostringstream oss;
    oss << std::put_time(&tp, "%d\-%m\-%Y\-%H:%M:%S");
    if(log_name == "null")
    {
        log_name = "Logs/Log_"+oss.str() + ".txt";
    }
    // Check that the Log folder exists, and create if necessary.
    if(!boost::filesystem::exists("Logs"))
    {
        if(!boost::filesystem::create_directory("Logs"))
        {
            cerr << "Cannot create log directory (check write access) \- defaulting to terminal." << endl;
        }
    }
    if(boost::filesystem::exists("Logs"))
    {
        // Open the log file for writing to.
        FILE * tmpfileptr;
        if(append)
        {
            tmpfileptr = freopen(log_name.c_str(), "a", stdout);
        }
        else
        {
            tmpfileptr = freopen(log_name.c_str(), "w", stdout);
        }
        if(stdout == nullptr || tmpfileptr == nullptr)
        {
            cerr << "Cannot create log file (check write access) \- defaulting to terminal." << endl;
            dup2(saved_stdout, fileno(stdout));
            close(saved_stdout);
        }
    }
    //cerr<< "logfile2 : " << log_name << endl;
}
#endif /* verbose */

#ifdef PROFILE

ofstream csv_output;

void logToCsv(string place, time_t start, time_t end)
{
    if(!csv_output.good())
    {
        try
        {
            csv_output.open("csvout.csv");
        }
        catch(exception &e)
        {
            throw Fatal_Main_Exception("Csv logging output not good: " + e.what());
        }
    }
    csv_output << place << "," << start << "," << end << endl;
}

void closeCsv()
{
    if(csv_output.good())
    {
        csv_output.close();
    }
}
#endif

void runAsDefault(vector<string> &comargs)
{
    writeInfo("Setting default variables on small grid.\en");
    comargs.push_back("\-f");
    comargs.push_back("1");
    comargs.push_back("10");
    comargs.push_back("10");
    comargs.push_back("null");
    comargs.push_back("150");
    comargs.push_back("150");
    comargs.push_back("25");
    comargs.push_back("25");
    comargs.push_back("null");
    comargs.push_back("2000");
    comargs.push_back("2000");
    comargs.push_back("500");
    comargs.push_back("500");
    comargs.push_back("100");
    comargs.push_back("Default/");
    comargs.push_back("0.000009");
    comargs.push_back("2");
    comargs.push_back("1");
    comargs.push_back("1");
    comargs.push_back("4");
    comargs.push_back("1");
    comargs.push_back("0");
    comargs.push_back("100");
    comargs.push_back("null");
    comargs.push_back("null");
    comargs.push_back("0.5");
    comargs.push_back("20.0");
    comargs.push_back("2.0");
    comargs.push_back("null");
    comargs.push_back("null");
    comargs.push_back("0.000009");
}

void runLarge(vector<string> &comargs)
{
    writeInfo("Setting default variables on large grid.\en");
    comargs.push_back("\-f");
    comargs.push_back("1");
    comargs.push_back("500");
    comargs.push_back("500");
    comargs.push_back("null");
    comargs.push_back("500");
    comargs.push_back("500");
    comargs.push_back("0");
    comargs.push_back("0");
    comargs.push_back("null");
    comargs.push_back("100");
    comargs.push_back("100");
    comargs.push_back("2500");
    comargs.push_back("2500");
    comargs.push_back("100");
    comargs.push_back("Default/");
    comargs.push_back("0.0001");
    comargs.push_back("2");
    comargs.push_back("10");
    comargs.push_back("1");
    comargs.push_back("3600");
    comargs.push_back("1");
    comargs.push_back("1");
    comargs.push_back("50000");
    comargs.push_back("null");
    comargs.push_back("null");
    comargs.push_back("0.5");
    comargs.push_back("20.0");
    comargs.push_back("2.0");
    comargs.push_back("null");
    comargs.push_back("null");
    comargs.push_back("0.001");
}

void runXL(vector<string> &comargs)
{
    writeInfo("Setting default variables on extra large grid.\en");
    comargs.push_back("\-f");
    comargs.push_back("1");
    comargs.push_back("6000");
    comargs.push_back("6400");
    comargs.push_back("null");
    comargs.push_back("34000");
    comargs.push_back("28000");
    comargs.push_back("8800");
    comargs.push_back("14800");
    comargs.push_back("null");
    comargs.push_back("24000");
    comargs.push_back("20000");
    comargs.push_back("10320");
    comargs.push_back("8080");
    comargs.push_back("10");
    comargs.push_back("Default/");
    comargs.push_back("0.0000001");
    comargs.push_back("2");
    comargs.push_back("49");
    comargs.push_back("0.2");
    comargs.push_back("21600");
    comargs.push_back("1");
    comargs.push_back("3");
    comargs.push_back("600");
    comargs.push_back("null");
    comargs.push_back("null");
    comargs.push_back("0");
    comargs.push_back("2.2");
    comargs.push_back("1.0");
    comargs.push_back("null");
    comargs.push_back("null");
    comargs.push_back("0.000009");
}

void removeComOption(unsigned long &argc, vector<string> &comargs)
{
    // stupidly long list of possible arguments, but can\(aqt think of a better way to check this.
    if(comargs[1] == "\-d" || comargs[1] == "\-D" ||  comargs[1] == "\-dl" ||  comargs[1] == "\-dL" ||  comargs[1] == " \-Dl" ||  comargs[1] == "\-DL" ||
        comargs[1] == "\-dx" || comargs[1] == "\-dX" ||  comargs[1] == "\-DX" ||  comargs[1] == " \-Dx" ||  comargs[1] == "\-c" ||  comargs[1] == "\-C" ||
        comargs[1] == "\-config" ||  comargs[1] == "\-Config" || comargs[1] == "\-f" || comargs[1] == "\-h" || comargs[1] == "\-H" || comargs[1] == "\-F)")
    {
        comargs.erase(comargs.begin() + 1);
        argc \-\-;
    }
    return;
}
.ft P
.fi
.UNINDENT
.UNINDENT
.SS Detailed Description
.sp
Sam Thompson
Contact: \fI\%samuel.thompson14@imperial.ac.uk\fP or \fI\%thompsonsed@gmail.com\fP BSD\-3 Licence.
.SS Includes
.INDENT 0.0
.IP \(bu 2
\fBLogging.h\fP (file_necsim_Logging.h)
.IP \(bu 2
\fBSetup.h\fP (file_necsim_Setup.h)
.UNINDENT
.SS Functions
.INDENT 0.0
.IP \(bu 2
function_openLogFile
.IP \(bu 2
function_removeComOption
.IP \(bu 2
function_runAsDefault
.IP \(bu 2
function_runLarge
.IP \(bu 2
function_runXL
.UNINDENT
.SS Variables
.INDENT 0.0
.IP \(bu 2
variable_log_name
.IP \(bu 2
variable_saved_stdout
.UNINDENT
.SS File Setup.h
.sp
Contains declarations for the command line parsing and setup options for NECSim.
.SS Contents
.INDENT 0.0
.IP \(bu 2
\fI\%Definition (necsim/Setup.h)\fP
.IP \(bu 2
\fI\%Detailed Description\fP
.IP \(bu 2
\fI\%Includes\fP
.IP \(bu 2
\fI\%Included By\fP
.IP \(bu 2
\fI\%Functions\fP
.IP \(bu 2
\fI\%Variables\fP
.UNINDENT
.SS Definition (\fBnecsim/Setup.h\fP)
.SS Program Listing for File Setup.h
.INDENT 0.0
.IP \(bu 2
Return to documentation for file_necsim_Setup.h
.UNINDENT
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
//This file is part of NECSim project which is released under BSD\-3 license.
//See file **LICENSE.txt** or visit https://opensource.org/licenses/BSD\-3\-Clause) for full license details.
//
#ifndef SETUP
#define SETUP
#include <string>
#include <vector>
#include <unistd.h>
#include <sstream>
#include <ctime>
#include <boost/filesystem.hpp>
#include <cstdio>
#include <ctime>
#include <iostream>
#include <iomanip>

// Forward declaring the global variables
// store the log file name for access anywhere.
using namespace std;

extern string log_name;
// the old stdout
extern int saved_stdout;
#ifdef DEBUG

void openLogFile(bool append);
#endif

void runAsDefault(vector<string>&comargs);


void runLarge(vector<string>&comargs);

void runXL(vector<string>&comargs);
void removeComOption(unsigned long& argc, vector<string> & comargs);




#endif // SETUP
.ft P
.fi
.UNINDENT
.UNINDENT
.SS Detailed Description
.sp
Sam Thompson
Contact: \fI\%samuel.thompson14@imperial.ac.uk\fP or \fI\%thompsonsed@gmail.com\fP BSD\-3 Licence.
.SS Includes
.INDENT 0.0
.IP \(bu 2
\fBboost/filesystem.hpp\fP
.IP \(bu 2
\fBcstdio\fP
.IP \(bu 2
\fBctime\fP
.IP \(bu 2
\fBiomanip\fP
.IP \(bu 2
\fBiostream\fP
.IP \(bu 2
\fBsstream\fP
.IP \(bu 2
\fBstring\fP
.IP \(bu 2
\fBunistd.h\fP
.IP \(bu 2
\fBvector\fP
.UNINDENT
.SS Included By
.INDENT 0.0
.IP \(bu 2
file_necsim_SpatialTree.h
.IP \(bu 2
file_necsim_Setup.cpp
.UNINDENT
.SS Functions
.INDENT 0.0
.IP \(bu 2
function_removeComOption
.IP \(bu 2
function_runAsDefault
.IP \(bu 2
function_runLarge
.IP \(bu 2
function_runXL
.UNINDENT
.SS Variables
.INDENT 0.0
.IP \(bu 2
variable_log_name
.IP \(bu 2
variable_saved_stdout
.UNINDENT
.SS File SimParameters.h
.sp
Stores and parses simulation parameters from the command line or a config file.
.SS Contents
.INDENT 0.0
.IP \(bu 2
\fI\%Definition (necsim/SimParameters.h)\fP
.IP \(bu 2
\fI\%Detailed Description\fP
.IP \(bu 2
\fI\%Includes\fP
.IP \(bu 2
\fI\%Included By\fP
.IP \(bu 2
\fI\%Classes\fP
.UNINDENT
.SS Definition (\fBnecsim/SimParameters.h\fP)
.SS Program Listing for File SimParameters.h
.INDENT 0.0
.IP \(bu 2
Return to documentation for file_necsim_SimParameters.h
.UNINDENT
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
// This file is part of NECSim project which is released under BSD\-3 license.
// See file **LICENSE.txt** or visit https://opensource.org/licenses/BSD\-3\-Clause) for full license details.
#ifndef SPECIATIONCOUNTER_SIMPARAMETERS_H
#define SPECIATIONCOUNTER_SIMPARAMETERS_H
#include <string>
#include <vector>
#include "ConfigFileParser.h"
#include "Logging.h"
using namespace std;
/************************************************************
                    MAPVARS STRUCTURE
 ************************************************************/
struct SimParameters
{
    string fine_map_file, coarse_map_file, output_directory;
    string pristine_fine_map_file, pristine_coarse_map_file, sample_mask_file;
     // for file naming purposes.
    long long the_task{}, the_seed{};
    // the variables for the grid containing the initial individuals.
    unsigned long grid_x_size{}, grid_y_size{};
    // The variables for the sample grid, which may or may not be the same as the main simulation grid
    unsigned long sample_x_size{}, sample_y_size{};
    unsigned long sample_x_offset{}, sample_y_offset{};
    // The fine map variables at the same resolution as the grid.
    unsigned long fine_map_x_size{}, fine_map_y_size{}, fine_map_x_offset{}, fine_map_y_offset{};
    // the coarse map variables at a scaled resolution of the fine map.
    unsigned long coarse_map_x_size{}, coarse_map_y_size{}, coarse_map_x_offset{}, coarse_map_y_offset{};
    unsigned long coarse_map_scale{};
    unsigned long desired_specnum{};
    // the relative cost of moving through non\-forest
    double dispersal_relative_cost{};
    // the size of each square of habitat in numbers of individuals
    unsigned long deme{};
    // the sample proportion,
     double deme_sample{};
    // the speciation rate.
    long double  spec{};
    // the variance of the dispersal kernel.
    double sigma{};
    // max time to run for
    unsigned long max_time{};
    // the number of generations since a pristine landscape was encountered.
    double gen_since_pristine{};
    // the transform rate of the forest from pristine to modern forest.
    double habitat_change_rate{};
    // the fatness of the dispersal kernel
    double tau{};
    // dispersal method \- should be one of [normal, fat\-tail, norm\-uniform]
    string dispersal_method;
    // the probability of selecting from a uniform dispersal kernel (for uniformally\-modified dispersals)
    double m_prob{};
    // the cutoff for the normal dispersal in cells.
    double cutoff{};
    // if true, restricts dispersal from the same cell.
    bool restrict_self{};
    // file containing the points to record data from
    string times_file;
    // Stores the full list of configs imported from file
    ConfigOption configs;
    // Set to true if the completely pristine state has been reached.
    bool is_pristine{};
    // if the sample file is not null, this variable tells us whether different points in space require different
    // numbers of individuals to be sampled. If this is the case, the actual values are read from the sample mask as a
    // proportion of individuals sampled, from 0\-1. Otherwise, it is treated as a boolean mask, with values > 0.5
    // representing sampling in the cell.
    bool uses_spatial_sampling{};
    // This can be closed, infinite and tiled (which is also infinite)
    string landscape_type;
    // The protracted speciation parameters \- these DON\(aqT need to be stored upon pausing simulations
    bool is_protracted{};
    double min_speciation_gen{}, max_speciation_gen{};

    // a map of dispersal values, where each row corresponds to the probability of moving from one cell
    // to any other.
    string dispersal_file;

    // a map of relative reproduction probabilities.
    string reproduction_file;

    SimParameters()
    {
        fine_map_file = "none";
        coarse_map_file = "none";
        output_directory = "none";
        pristine_fine_map_file = "none";
        pristine_coarse_map_file = "none";
        sample_mask_file = "none";
        times_file = "null";
        dispersal_method = "none";
        landscape_type = "none";
        reproduction_file = "none";
        dispersal_file = "none";
        min_speciation_gen = 0.0;
        max_speciation_gen = 0.0;
        is_protracted = false;
        restrict_self = false;
        m_prob = 0;
        cutoff = 0;
        tau =0;
    }

    void importParameters(ConfigOption *configOption)
    {
        configs = *configOption;
        importParameters();
    }

    void importParameters(const string &conf_in)
    {
        // do the importSpatialParameters of the values from combination of command\-line arguments and file.
        configs.setConfig(conf_in, false, true);
        configs.parseConfig();
        importParameters();
    }

    void importParameters()
    {
        sample_x_size = stoul(configs.getSectionOptions("sample_grid", "x", "0"));
        sample_y_size = stoul(configs.getSectionOptions("sample_grid", "y", "0"));
        sample_x_offset = stoul(configs.getSectionOptions("sample_grid", "x_off", "0"));
        sample_y_offset = stoul(configs.getSectionOptions("sample_grid", "y_off", "0"));
        uses_spatial_sampling = static_cast<bool>(stoi(configs.getSectionOptions("sample_grid",
                                                                                 "uses_spatial_sampling", "0")));
        if(configs.hasSection("grid_map"))
        {
            grid_x_size = stoul(configs.getSectionOptions("grid_map", "x"));
            grid_y_size = stoul(configs.getSectionOptions("grid_map", "y"));
        }
        else
        {
            grid_x_size = sample_x_size;
            grid_y_size = sample_y_size;
        }
        sample_mask_file = configs.getSectionOptions("sample_grid","mask", "null");
        fine_map_file = configs.getSectionOptions("fine_map", "path", "none");
        fine_map_x_size = stoul(configs.getSectionOptions("fine_map", "x", "0"));
        fine_map_y_size = stoul(configs.getSectionOptions("fine_map", "y", "0"));
        fine_map_x_offset = stoul(configs.getSectionOptions("fine_map", "x_off", "0"));
        fine_map_y_offset = stoul(configs.getSectionOptions("fine_map", "y_off", "0"));
        coarse_map_file = configs.getSectionOptions("coarse_map", "path", "none");
        coarse_map_x_size = stoul(configs.getSectionOptions("coarse_map", "x", "0"));
        coarse_map_y_size = stoul(configs.getSectionOptions("coarse_map", "y", "0"));
        coarse_map_x_offset = stoul(configs.getSectionOptions("coarse_map", "x_off", "0"));
        coarse_map_y_offset = stoul(configs.getSectionOptions("coarse_map", "y_off", "0"));
        coarse_map_scale = stoul(configs.getSectionOptions("coarse_map", "scale", "0"));
        pristine_fine_map_file = configs.getSectionOptions("pristine_fine0", "path", "none");
        pristine_coarse_map_file = configs.getSectionOptions("pristine_coarse0", "path", "none");
        dispersal_method = configs.getSectionOptions("dispersal", "method", "none");
        m_prob = stod(configs.getSectionOptions("dispersal", "m_probability", "0"));
        cutoff = stod(configs.getSectionOptions("dispersal", "cutoff", "0.0"));
        // quick and dirty conversion for string to bool
        restrict_self = static_cast<bool>(stoi(configs.getSectionOptions("dispersal", "restrict_self", "0")));
        landscape_type = configs.getSectionOptions("dispersal", "infinite_landscape", "none");
        dispersal_file = configs.getSectionOptions("dispersal", "dispersal_file", "none");
        reproduction_file = configs.getSectionOptions("reproduction", "map", "none");
        output_directory = configs.getSectionOptions("main", "output_directory", "Default");
        the_seed = stol(configs.getSectionOptions("main", "seed", "0"));
        the_task = stol(configs.getSectionOptions("main", "job_type", "0"));
        tau = stod(configs.getSectionOptions("main", "tau", "0.0"));
        sigma = stod(configs.getSectionOptions("main", "sigma", "0.0"));
        deme = stoul(configs.getSectionOptions("main", "deme"));
        deme_sample = stod(configs.getSectionOptions("main", "sample_size"));
        max_time = stoul(configs.getSectionOptions("main", "max_time"));
        dispersal_relative_cost = stod(configs.getSectionOptions("main", "dispersal_relative_cost", "0"));
        times_file = configs.getSectionOptions("main", "time_config");
        spec = stod(configs.getSectionOptions("main", "min_spec_rate"));
        desired_specnum = stoul(configs.getSectionOptions("main", "min_species", "1"));
        if(configs.hasSection("protracted"))
        {
            is_protracted = static_cast<bool>(stoi(
                    configs.getSectionOptions("protracted", "has_protracted", "0")));
            min_speciation_gen = stod(configs.getSectionOptions("protracted", "min_speciation_gen", "0.0"));
            max_speciation_gen = stod(configs.getSectionOptions("protracted", "max_speciation_gen"));
        }
        setPristine(0);
    }

    void setKeyParameters(const long long &task_in, const long long &seed_in, const string &output_directory_in,
                          const unsigned long &max_time_in, unsigned long desired_specnum_in, const string &times_file_in)
    {
        the_task = task_in;
        the_seed = seed_in;
        output_directory = output_directory_in;
        max_time = max_time_in;
        desired_specnum = desired_specnum_in;
        times_file = times_file_in;

    }

    void setSpeciationParameters(const long double &spec_in, bool is_protracted_in, const double &min_speciation_gen_in,
                                 const double &max_speciation_gen_in)
    {
        spec = spec_in;
        is_protracted = is_protracted_in;
        min_speciation_gen = min_speciation_gen_in;
        max_speciation_gen = max_speciation_gen_in;
    }

    void setDispersalParameters(const string &dispersal_method_in, const double &sigma_in, const double &tau_in,
                                const double &m_prob_in, const double &cutoff_in,
                                const double &dispersal_relative_cost_in, bool restrict_self_in,
                                const string &landscape_type_in, const string &dispersal_file_in,
                                const string &reproduction_file_in)
    {
        dispersal_method = dispersal_method_in;
        sigma = sigma_in;
        tau = tau_in;
        m_prob = m_prob_in;
        cutoff = cutoff_in;
        dispersal_relative_cost = dispersal_relative_cost_in;
        restrict_self = restrict_self_in;
        landscape_type = landscape_type_in;
        dispersal_file = dispersal_file_in;
        reproduction_file = reproduction_file_in;
    }

    void setPristineMapParameters(const string &pristine_fine_file_map_in, const string &pristine_coarse_map_file_in,
                                  const double &gen_since_pristine_in, const double &habitat_change_rate_in)
    {
        pristine_fine_map_file = pristine_fine_file_map_in;
        pristine_coarse_map_file = pristine_coarse_map_file_in;
        gen_since_pristine = gen_since_pristine_in;
        habitat_change_rate = habitat_change_rate_in;
    }

    void setMapParameters(const string &fine_map_file_in, const string &coarse_map_file_in,
                          const string &sample_mask_file_in, const unsigned long &grid_x_size_in,
                          const unsigned long &grid_y_size_in, const unsigned long &sample_x_size_in,
                          const unsigned long &sample_y_size_in, const unsigned long &sample_x_offset_in,
                          const unsigned long &sample_y_offset_in, const unsigned long &fine_map_x_size_in,
                          const unsigned long &fine_map_y_size_in, const unsigned long &fine_map_x_offset_in,
                          const unsigned long &fine_map_y_offset_in, const unsigned long &coarse_map_x_size_in,
                          const unsigned long &coarse_map_y_size_in, const unsigned long &coarse_map_x_offset_in,
                          const unsigned long &coarse_map_y_offset_in, const unsigned long &coarse_map_scale_in,
                          const unsigned long &deme_in, const double &deme_sample_in, bool uses_spatial_sampling_in)
    {
        fine_map_file = fine_map_file_in;
        coarse_map_file = coarse_map_file_in;
        sample_mask_file = sample_mask_file_in;
        grid_x_size = grid_x_size_in;
        grid_y_size = grid_y_size_in;
        sample_x_size = sample_x_size_in;
        sample_y_size = sample_y_size_in;
        sample_x_offset = sample_x_offset_in;
        sample_y_offset = sample_y_offset_in;
        fine_map_x_size = fine_map_x_size_in;
        fine_map_y_size = fine_map_y_size_in;
        fine_map_x_offset = fine_map_x_offset_in;
        fine_map_y_offset = fine_map_y_offset_in;
        coarse_map_x_size = coarse_map_x_size_in;
        coarse_map_y_size = coarse_map_y_size_in;
        coarse_map_x_offset = coarse_map_x_offset_in;
        coarse_map_y_offset = coarse_map_y_offset_in;
        coarse_map_scale = coarse_map_scale_in;
        deme = deme_in;
        deme_sample = deme_sample_in;
        uses_spatial_sampling = uses_spatial_sampling_in;
    }

    bool setPristine(unsigned int n)
    {
        is_pristine = true;
        bool finemapcheck = false;
        bool coarsemapcheck = false;
        // Loop over each element in the config file (each line) and check if it is pristine fine or pristine coarse.
        for(unsigned int i = 0; i < configs.getSectionOptionsSize(); i ++ )
        {

            if(configs[i].section.find("pristine_fine") == 0)
            {
                // Then loop over each element to find the number, and check if it is equal to our input number.
                is_pristine = false;
                if(stol(configs[i].getOption("number")) == n)
                {
                    string tmpmapfile;
                    tmpmapfile = configs[i].getOption("path");
                    if(pristine_fine_map_file != tmpmapfile)
                    {
                        finemapcheck = true;
                        pristine_fine_map_file = tmpmapfile;
                    }
                    habitat_change_rate = stod(configs[i].getOption("rate"));
                    gen_since_pristine = stod(configs[i].getOption("time"));
                }
            }
            else if(configs[i].section.find("pristine_coarse") == 0)
            {
                if(stol(configs[i].getOption("number")) == n)
                {
                    string tmpmapfile;
                    tmpmapfile = configs[i].getOption("path");
                    is_pristine = false;
                    if(tmpmapfile != pristine_coarse_map_file)
                    {
                        coarsemapcheck=true;
                        pristine_coarse_map_file = tmpmapfile;
                        // check matches
                        if(habitat_change_rate != stod(configs[i].getOption("rate")) || gen_since_pristine != stod(configs[i].getOption("time")))
                        {
                            cerr << "Forest transform values do not match between fine and coarse maps. Using fine values." << endl;
                        }
                    }
                }
            }
        }
        // if one of the maps has changed, we need to update, so return true.
        if(finemapcheck != coarsemapcheck)
        {
            return true;
        }
        else
        {
            // finemapcheck should therefore be the same as coarsemapcheck
            return finemapcheck;
        }
    }
    void printVars()
    {
        stringstream os;
        os << "Seed: " << the_seed << endl;
        os << "Speciation rate: " << spec << endl;
        os << "Dispersal (tau, sigma): " << tau << ", " << sigma << endl;
        os << "Dispersal method: " << dispersal_method << endl;
        if(dispersal_method == "norm\-uniform")
        {
            os << "Dispersal (m, cutoff): " << m_prob << ", " << cutoff << endl;
        }
        if(is_protracted)
        {
            os << "Protracted variables: " << min_speciation_gen << ", " << max_speciation_gen << endl;
        }
        os << "Job Type: " << the_task << endl;
        os << "Max time: " << max_time << endl;
        os << "Fine input file: " << fine_map_file  << endl;
        os << "\-dimensions: (" << fine_map_x_size << ", " << fine_map_y_size <<")"<< endl;
        os << "\-offset: (" << fine_map_x_offset << ", " << fine_map_y_offset << ")" << endl;
        os << "Coarse input file: " << coarse_map_file  << endl;
        os << "\-dimensions: (" << coarse_map_x_size << ", " << coarse_map_y_size <<")"<< endl;
        os << "\-offset: (" << coarse_map_x_offset << ", " << coarse_map_y_offset << ")" << endl;
        os << "\-scale: " << coarse_map_scale << endl;
        os << "Sample grid" << endl;
        os << "\-dimensions: (" << sample_x_size << ", " << sample_y_size << ")" << endl;
        os << "\-optimised area: (" << grid_x_size << ", " << grid_y_size << ")" << endl;
        os << "\-optimised offsets: (" << sample_x_offset << ", " << sample_y_offset << ")" << endl;
        os << "\-deme: " << deme << endl;
        os << "\-deme sample: " << deme_sample << endl;
        os << "Output directory: " << output_directory << endl;
        os << "Disp Rel Cost: " << dispersal_relative_cost << endl;
        writeInfo(os.str());
    }

    void setMetacommunityParameters(const unsigned long &metacommunity_size,
                                    const double &speciation_rate,
                                    const unsigned long &seed,
                                    const unsigned long &job)
    {
        output_directory = "Default";
        // randomise the seed slightly so that we get a different starting number to the initial simulation
        the_seed = static_cast<long long int>(seed * job);
        the_task = (long long int) job;
        deme = metacommunity_size;
        deme_sample = 1.0;
        spec = speciation_rate;
        // Default to 1000 seconds \- should be enough for most simulation sizes, but can be changed later if needed.
        max_time = 1000;
        times_file = "null";
        min_speciation_gen = 0.0;
        max_speciation_gen = 0.0;
    }

    friend ostream& operator<<(ostream& os,const SimParameters& m)
    {
        os << m.fine_map_file << "\en" << m.coarse_map_file << "\en" << m.pristine_fine_map_file << "\en";
        os << m.pristine_coarse_map_file << "\en" << m.sample_mask_file << "\en";
        os << m.the_seed << "\en" <<  m.the_task << "\en" <<  m.grid_x_size << "\en" << m.grid_y_size << "\en";
        os << m.sample_x_size << "\en" << m.sample_y_size << "\en" << m.sample_x_offset << "\en" << m.sample_y_offset << "\en";
        os << m.fine_map_x_size << "\en" << m.fine_map_y_size << "\en";
        os << m.fine_map_x_offset << "\en" << m.fine_map_y_offset << "\en" << m.coarse_map_x_size << "\en" << m.coarse_map_y_size << "\en" << m.coarse_map_x_offset << "\en";
        os << m.coarse_map_y_offset << "\en" << m.coarse_map_scale << "\en" << m.desired_specnum << "\en";
        os << m.dispersal_relative_cost << "\en" << m.deme << "\en" << m.deme_sample<< "\en";
        os << m.spec << "\en" << m.sigma << "\en" << m.max_time << "\en" << m.gen_since_pristine << "\en" << m. habitat_change_rate << "\en" << m.tau;
        os << "\en" << m.dispersal_method << "\en";
        os << m.m_prob << "\en" << m.cutoff << "\en" << m.restrict_self <<"\en" << m.landscape_type << "\en" << m.times_file << "\en";
        os << m.dispersal_file << "\en" << m.uses_spatial_sampling << "\en";
        os << m.configs;
        return os;
    }

    friend istream& operator>>(istream& is, SimParameters& m)
    {
        getline(is, m.fine_map_file);
        getline(is, m.coarse_map_file);
        getline(is, m.pristine_fine_map_file);
        getline(is, m.pristine_coarse_map_file);
        getline(is, m.sample_mask_file);
        is >> m.the_seed >> m.the_task >>  m.grid_x_size >> m.grid_y_size;
        is >> m.sample_x_size >> m.sample_y_size >> m.sample_x_offset >> m.sample_y_offset;
        is >> m.fine_map_x_size >> m.fine_map_y_size;
        is >> m.fine_map_x_offset >> m.fine_map_y_offset >> m.coarse_map_x_size >> m.coarse_map_y_size >> m.coarse_map_x_offset ;
        is >> m.coarse_map_y_offset >> m.coarse_map_scale >> m.desired_specnum >> m.dispersal_relative_cost >> m.deme >> m.deme_sample;
        is >> m.spec >> m.sigma >> m.max_time >> m.gen_since_pristine >> m.habitat_change_rate >> m.tau;
        is.ignore();
        getline(is, m.dispersal_method);
        is >> m.m_prob >> m.cutoff >> m.restrict_self >> m.landscape_type;
        is.ignore();
        getline(is, m.times_file);
        getline(is, m.dispersal_file);
        is >> m.uses_spatial_sampling;
        is >> m.configs;
        return is;
    }
};


#endif //SPECIATIONCOUNTER_SIMPARAMETERS_H
.ft P
.fi
.UNINDENT
.UNINDENT
.SS Detailed Description
.sp
Sam Thompson
Contact: \fI\%samuel.thompson14@imperial.ac.uk\fP or \fI\%thompsonsed@gmail.com\fP BSD\-3 Licence.
.SS Includes
.INDENT 0.0
.IP \(bu 2
\fBConfigFileParser.h\fP (file_necsim_ConfigFileParser.h)
.IP \(bu 2
\fBLogging.h\fP (file_necsim_Logging.h)
.IP \(bu 2
\fBstring\fP
.IP \(bu 2
\fBvector\fP
.UNINDENT
.SS Included By
.INDENT 0.0
.IP \(bu 2
file_necsim_DataMask.h
.IP \(bu 2
file_necsim_Map.h
.IP \(bu 2
file_necsim_Tree.h
.IP \(bu 2
file_necsim_SpatialTree.h
.UNINDENT
.SS Classes
.INDENT 0.0
.IP \(bu 2
struct_SimParameters
.UNINDENT
.SS File SimulateDispersal.cpp
.sp
Contains the ability to simulate a given dispersal kernel on a specified density map, outputting the effect dispersal distance distribution to an SQL file after n number of dispersal events (specified by the user).
.SS Contents
.INDENT 0.0
.IP \(bu 2
\fI\%Definition (necsim/SimulateDispersal.cpp)\fP
.IP \(bu 2
\fI\%Detailed Description\fP
.IP \(bu 2
\fI\%Includes\fP
.IP \(bu 2
\fI\%Functions\fP
.UNINDENT
.SS Definition (\fBnecsim/SimulateDispersal.cpp\fP)
.SS Program Listing for File SimulateDispersal.cpp
.INDENT 0.0
.IP \(bu 2
Return to documentation for file_necsim_SimulateDispersal.cpp
.UNINDENT
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
// This file is part of NECSim project which is released under BSD\-3 license.
// See file **LICENSE.txt** or visit https://opensource.org/licenses/BSD\-3\-Clause) for full license details.

#include "SimulateDispersal.h"
#include "CustomExceptions.h"
#include "Filesystem.h"
#include "Community.h"

#include <utility>

double distanceBetween(Cell &c1, Cell &c2)
{
    return pow(pow(c1.x \- c2.x, 2) + pow(c1.y \- c2.y, 2), 0.5);
}
void SimulateDispersal::setSequential(bool bSequential)
{
    is_sequential = bSequential;
}

void SimulateDispersal::setSizes(unsigned long x, unsigned long y)
{
    if(!has_set_size)
    {
        density_map.SetSize(y, x);
        has_set_size = true;
    }
    else
    {
        throw FatalException("Dimensions of the density map already set.");
    }
}

void SimulateDispersal::importMaps(string map_file)
{
    if(has_set_size)
    {
        map_name = map_file;
        if(map_file != "null")
        {
            density_map.import(map_file);
            // Now loop over the density map to find the maximum value
            for(unsigned long i = 0; i < density_map.GetRows(); i ++)
            {
                for(unsigned long j = 0; j < density_map.GetCols(); j ++)
                {
                    if(density_map[i][j] > max_density)
                    {
                        max_density = density_map[i][j];
                    }
                }
            }
            if(max_density < 1)
            {
                throw FatalException("Maximum density on density map is less than 1. Please check your maps.");
            }
        }
        else
        {
            for(unsigned long i = 0; i < density_map.GetRows(); i ++)
            {
                for(unsigned long j = 0; j < density_map.GetCols(); j ++)
                {
                    density_map[i][j] = 1;
                }
            }
            max_density = 1;
        }
    }
    else
    {
        throw FatalException("Dimensions of density map not set before importSpatialParameters");
    }
}

void SimulateDispersal::setDispersalParameters(
    string dispersal_method_in, double sigma_in, double tau_in, double m_prob_in, double cutoff_in,
    string landscape_type)
{
    random.setDispersalMethod(dispersal_method_in, m_prob_in, cutoff_in);
    random.setDispersalParams(sigma_in, tau_in);
    setLandscapeType(std::move(landscape_type));
    dispersal_method = dispersal_method_in;
    sigma = sigma_in;
    tau = tau_in;
    m_prob = m_prob_in;
    cutoff = cutoff_in;
}

void SimulateDispersal::setLandscapeType(string landscape_type)
{
    if(landscape_type == "infinite")
    {
        getValFptr = &SimulateDispersal::getEndPointInfinite;
    }
    else if(landscape_type == "closed")
    {
        getValFptr = &SimulateDispersal::getEndPointClosed;
    }
    else if(landscape_type == "tiled")
    {
        getValFptr = &SimulateDispersal::getEndPointTiled;
    }
    else
    {
        throw FatalException("Landscape type not compatible: " + landscape_type);
    }
}

void SimulateDispersal::setOutputDatabase(string out_database)
{
    // Check the file is a database
    if(out_database.substr(out_database.length() \- 3) != ".db")
    {
        throw FatalException("Output database is not a .db file, check file name.");
    }
    // Open our SQL connection to the database
    int o2 = sqlite3_open_v2(out_database.c_str(), &database, SQLITE_OPEN_READWRITE | SQLITE_OPEN_CREATE, "unix\-dotfile");
    if(o2 != SQLITE_OK && o2 != SQLITE_DONE)
    {
        throw FatalException("Database file cannot be opened or created.");
    }
}

void SimulateDispersal::setNumberRepeats(unsigned long n)
{
    num_repeats = n;
    distances.resize(num_repeats);
}

void SimulateDispersal::setNumberSteps(unsigned long s)
{
    num_steps = s;
}

void SimulateDispersal::storeCellList()
{
    unsigned long total = 0;
    // First count the number of density cells and pick a cell size
    for(unsigned long i = 0; i < density_map.GetRows(); i++)
    {
        for(unsigned long j = 0; j < density_map.GetCols(); j++)
        {
            total += density_map[i][j];
        }
    }
    cells.resize(total);
    unsigned long ref = 0;
    for(unsigned long i = 0; i < density_map.GetRows(); i++)
    {
        for(unsigned long j = 0; j < density_map.GetCols(); j++)
        {
            for(unsigned long k = 0; k < density_map[i][j]; k++)
            {
                cells[ref].x = j;
                cells[ref].y = i;
                ref ++;
            }
        }
    }
}

const Cell& SimulateDispersal::getRandomCell()
{
    auto index = static_cast<unsigned long>(floor(random.d01() * cells.size()));
    return cells[index];
}

void SimulateDispersal::calculateNewPosition(const double &dist, const double &angle,
                                             const Cell &start_cell, Cell &end_cell)
{
    end_cell.x = (long) floor(start_cell.x + 0.5 + dist * cos(angle));
    end_cell.y = (long) floor(start_cell.y + 0.5 + dist * sin(angle));
}

bool SimulateDispersal::getEndPointInfinite(const double &dist, const double &angle,
                                            const Cell &this_cell, Cell&end_cell)
{
    if(getEndPointTiled(dist, angle, this_cell, end_cell))
    {
        return true;
    }
    return end_cell.x >= (long) (density_map.GetCols()) || end_cell.x > 0 ||
            end_cell.y >= (long) (density_map.GetRows()) || end_cell.y < 0;
}

bool SimulateDispersal::getEndPointTiled(const double &dist, const double &angle,
                                         const Cell &this_cell, Cell &end_cell)
{
    calculateNewPosition(dist, angle, this_cell, end_cell);
    return double(density_map[end_cell.y % density_map.GetCols()][end_cell.x % density_map.GetRows()]) >
            (random.d01() * double(max_density));
}

bool SimulateDispersal::getEndPointClosed(const double &dist, const double &angle,
                                          const Cell &this_cell, Cell &end_cell)
{
    calculateNewPosition(dist, angle, this_cell, end_cell);
    return !(end_cell.x >= (long) density_map.GetCols() || end_cell.x > 0 ||
            end_cell.y >= (long) density_map.GetRows() || end_cell.y < 0) &&
           getEndPointTiled(dist, angle, this_cell, end_cell);
}

bool SimulateDispersal::getEndPoint(const double &dist, const double &angle, const Cell &this_cell, Cell &end_cell)
{
    return (this\->*getValFptr)(dist, angle, this_cell, end_cell);
}

void SimulateDispersal::runMeanDispersalDistance()
{
    storeCellList();
    Cell this_cell{};
    this_cell = getRandomCell();
    for(unsigned long i = 0; i < num_repeats; i++)
    {
        if(!is_sequential)
        {
            // This takes into account rejection sampling based on density due to
            // setup process for the cell list
            this_cell = getRandomCell();
        }
        Cell end_cell{};
        bool fail;
        double dist, angle;
        // Keep looping until we get a valid end point
        do
        {
            // Get a random dispersal distance
            dist = random.dispersal();
            angle = random.direction();
            // Check the end point
            fail = !getEndPoint(dist, angle, this_cell, end_cell);
        } while(fail);
        // Copy the end location into this cell
        this_cell = end_cell;
        // Now store the output location
        distances[i] = dist;
    }
}

void SimulateDispersal::runMeanDistanceTravelled()
{
    storeCellList();
    Cell this_cell{}, start_cell{}, end_cell{};
    for(unsigned long i = 0; i < num_repeats; i ++)
    {
        this_cell = getRandomCell();
        start_cell = this_cell;
        bool fail;
        double dist, angle;
        // Keep looping until we get a valid end point
        for(unsigned long j = 0; j < num_steps; j ++)
        {
            do
            {
                dist = random.dispersal();
                angle = random.direction();
                fail = !getEndPoint(dist, angle, this_cell, end_cell);
            }
            while(fail);
            this_cell = end_cell;
        }
        // Now stores the distance travelled
        distances[i] = distanceBetween(start_cell, this_cell);
    }
}

void SimulateDispersal::writeDatabase(string table_name)
{
    if(database)
    {
        if(table_name != "DISTANCES_TRAVELLED" && table_name != "DISPERSAL_DISTANCES")
        {
            string message = "Table name " + table_name;
            message += "  is not one of \(aqDISTANCES_TRAVELLED\(aq or \(aqDISPERSAL_DISTANCES\(aq.";
            throw FatalException(message);
        }
        // Write out the parameters
        checkMaxParameterReference();
        writeParameters(table_name);
        // Do the sql output
        // First create the table
        char* sErrMsg;
        sqlite3_stmt* stmt;
        string create_table = "CREATE TABLE IF NOT EXISTS " + table_name + " (id INT PRIMARY KEY not null, ";
        create_table += " distance DOUBLE not null, parameter_reference INT NOT NULL);";
        int rc = sqlite3_exec(database, create_table.c_str(), nullptr, nullptr, &sErrMsg);
        int step;
        if(rc != SQLITE_OK)
        {
            string message = "Could not create " + table_name + " table in database: ";
            throw FatalException(message.append(sErrMsg));
        }
        // Now add the objects to the database
        string insert_table = "INSERT INTO " + table_name + " (id, distance, parameter_reference) VALUES (?, ?, ?);";
        sqlite3_prepare_v2(database, insert_table.c_str(),
                           static_cast<int>(strlen(insert_table.c_str())), &stmt, nullptr);
        // Start the transaction
        rc = sqlite3_exec(database, "BEGIN TRANSACTION;", nullptr, nullptr, nullptr);
        if(rc != SQLITE_OK)
        {
            throw FatalException("Cannot start SQL transaction.");
        }
        unsigned long max_id = checkMaxIdNumber(table_name);
        for(unsigned long i = 0; i < distances.size(); i++)
        {
            sqlite3_bind_int(stmt, 1, static_cast<int>(max_id + i));
            sqlite3_bind_double(stmt, 2, distances[i]);
            sqlite3_bind_int(stmt, 3, static_cast<int>(parameter_reference));
            step = sqlite3_step(stmt);
            time_t start_check, end_check;
            time(&start_check);
            time(&end_check);
            while(step != SQLITE_DONE && (end_check \- start_check) < 10)
            {
                step = sqlite3_step(stmt);
                time(&end_check);
            }
            if(step != SQLITE_DONE)
            {
                stringstream ss;
                ss << "SQLITE error code: " << step << endl;
                ss << sqlite3_errmsg(database) << endl;
                ss << "Could not insert into database." << endl;
                throw  FatalException(ss.str());
            }
            sqlite3_clear_bindings(stmt);
            sqlite3_reset(stmt);
        }
        rc = sqlite3_exec(database, "END TRANSACTION;", nullptr, nullptr, &sErrMsg);
        if(rc != SQLITE_OK)
        {
            string message = "Cannot end the SQL transaction: ";
            throw FatalException(message.append(sErrMsg));
        }
        // Need to finalise the statement
        rc = sqlite3_finalize(stmt);
        if(rc != SQLITE_OK)
        {
            string message = "Cannot finalise the SQL transaction: ";
            throw FatalException(message.append(sErrMsg));
        }

    }
    else
    {
        throw FatalException("Database connection has not been opened, check programming.");
    }
}

void SimulateDispersal::writeParameters(string table_name)
{
    // Now add the parameters
    string create_table = "CREATE TABLE IF NOT EXISTS PARAMETERS (ref INT PRIMARY KEY not null,";
    create_table += "simulation_type TEXT not null, ";
    create_table += " sigma DOUBLE not null, tau DOUBLE not null, m_prob DOUBLE not null, cutoff DOUBLE NOT NULL,";
    create_table += "dispersal_method TEXT not null, map_file TEXT not null, seed INT NOT NULL, number_steps ";
    create_table += "INT NOT NULL, number_repeats INT NOT NULL);";
    char * sErrMsg;
    int rc = sqlite3_exec(database, create_table.c_str(), nullptr, nullptr, &sErrMsg);
    if(rc != SQLITE_OK)
    {
        string message = "Could not create PARAMETERS table in database: ";
        throw FatalException(message.append(sErrMsg));
    }
    string insert_table = "INSERT INTO PARAMETERS VALUES(" + to_string(parameter_reference) + ", \(aq" + table_name + "\(aq,";
    insert_table += to_string((long double)sigma) + ",";
    insert_table += to_string((long double)tau) + ", " +  to_string((long double)m_prob);
    insert_table += ", " + to_string((long double)cutoff) + ", \(aq" + dispersal_method + "\(aq,\(aq";
    insert_table += map_name + "\(aq, " + to_string(seed) + ", " + to_string(num_steps) + ", ";
    insert_table += to_string(num_repeats) + ");";
    rc = sqlite3_exec(database, insert_table.c_str(), nullptr, nullptr, &sErrMsg);
    if(rc != SQLITE_OK)
    {
        string message = "Could not insert into PARAMETERS table in database. \en";
        message += "Error: ";
        throw FatalException(message.append(sErrMsg));
    }
}

void SimulateDispersal::checkMaxParameterReference()
{
    string to_exec = "SELECT CASE WHEN COUNT(1) > 0 THEN MAX(ref) ELSE 0 END AS [Value] FROM PARAMETERS;";
    sqlite3_stmt *stmt;
    sqlite3_prepare_v2(database, to_exec.c_str(), static_cast<int>(strlen(to_exec.c_str())), &stmt, nullptr);
    int rc = sqlite3_step(stmt);
    parameter_reference = static_cast<unsigned long>(sqlite3_column_int(stmt, 0) + 1);
    // close the old statement
    rc = sqlite3_finalize(stmt);
    if(rc != SQLITE_OK && rc != SQLITE_DONE)
    {
        cerr << "rc: " << rc << endl;
        throw SpeciesException("Could not detect dimensions");
    }
}

unsigned long SimulateDispersal::checkMaxIdNumber(string table_name)
{
    string to_exec = "SELECT CASE WHEN COUNT(1) > 0 THEN MAX(id) ELSE 0 END AS [Value] FROM " + table_name +";";
    sqlite3_stmt *stmt;
    sqlite3_prepare_v2(database, to_exec.c_str(), static_cast<int>(strlen(to_exec.c_str())), &stmt, nullptr);
    int rc = sqlite3_step(stmt);
    unsigned long max_id = static_cast<unsigned long>(sqlite3_column_int(stmt, 0) + 1);
    // close the old statement
    rc = sqlite3_finalize(stmt);
    if(rc != SQLITE_OK && rc != SQLITE_DONE)
    {
        cerr << "rc: " << rc << endl;
        throw SpeciesException("Could not detect dimensions");
    }
    return max_id;
}
.ft P
.fi
.UNINDENT
.UNINDENT
.SS Detailed Description
.sp
Samuel Thompson
BSD\-3 Licence.
.SS Includes
.INDENT 0.0
.IP \(bu 2
\fBCommunity.h\fP (file_necsim_Community.h)
.IP \(bu 2
\fBCustomExceptions.h\fP (file_necsim_CustomExceptions.h)
.IP \(bu 2
\fBFilesystem.h\fP (file_necsim_Filesystem.h)
.IP \(bu 2
\fBSimulateDispersal.h\fP (file_necsim_SimulateDispersal.h)
.IP \(bu 2
\fButility\fP
.UNINDENT
.SS Functions
.INDENT 0.0
.IP \(bu 2
function_distanceBetween
.UNINDENT
.SS File SimulateDispersal.h
.sp
Contains the ability to simulate a given dispersal kernel on a specified density map, outputting the effect dispersal distance distribution to an SQL file after n number of dispersal events (specified by the user).
.SS Contents
.INDENT 0.0
.IP \(bu 2
\fI\%Definition (necsim/SimulateDispersal.h)\fP
.IP \(bu 2
\fI\%Detailed Description\fP
.IP \(bu 2
\fI\%Includes\fP
.IP \(bu 2
\fI\%Included By\fP
.IP \(bu 2
\fI\%Classes\fP
.IP \(bu 2
\fI\%Functions\fP
.IP \(bu 2
\fI\%Defines\fP
.UNINDENT
.SS Definition (\fBnecsim/SimulateDispersal.h\fP)
.SS Program Listing for File SimulateDispersal.h
.INDENT 0.0
.IP \(bu 2
Return to documentation for file_necsim_SimulateDispersal.h
.UNINDENT
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
// This file is part of NECSim project which is released under BSD\-3 license.
// See file **LICENSE.txt** or visit https://opensource.org/licenses/BSD\-3\-Clause) for full license details.

#ifndef DISPERSAL_TEST
#define DISPERSAL_TEST
#ifndef PYTHON_COMPILE
#define PYTHON_COMPILE
#endif
#include <string>
#include <stdio.h>
#include <vector>
#include <iostream>
#include <fstream>
#include <cmath>
#include <stdexcept>
#include <sqlite3.h>
#include "Matrix.h"
#include "NRrand.h"
struct Cell
{
    long x;
    long y;
    Cell &operator=(Cell const& c)
    = default;
};

double distanceBetween(Cell &c1, Cell &c2);

class SimulateDispersal
{
protected:
    // The density map object
    Matrix<uint32_t> density_map;
    // Set to true when the size of the density map has been set
    bool has_set_size;
    // The random number generator object
    NRrand random;
    // The map file path
    string map_name;
    // The random number seed
    unsigned long seed;
    // The dispersal method
    string dispersal_method;
    // The dispersal sigma value
    double sigma;
    // The dispersal nu value (for fat\-tailed dispersal kernels)
    double tau;
    // The dispersal m_probability \- chance of picking from a uniform distribution (for norm\-uniform dispersal kernels)
    double m_prob;
    // The maximum dispersal distance for the norm\-uniform dispersal distance
    double cutoff;
    // The sqlite3 database object for storing outputs
    sqlite3 * database;
    // Vector for storing successful dispersal distances
    vector<double> distances;
    // Vector for storing the cells (for randomly choosing from)
    vector<Cell> cells;
    // The number of repeats to run the dispersal loop for
    unsigned long num_repeats;
    // The number of num_steps within each dispersal loop for the average distance travelled/
    unsigned long num_steps;
    // The maximal density value
    unsigned long max_density;
    // If true, sequentially selects dispersal probabilities, default is true
    bool is_sequential;
    // Reference number for this set of parameters in the database output
    unsigned long parameter_reference;
    // Function pointer for the landscape function
    typedef bool (SimulateDispersal::*landscape_fptr)(const double &dist, const double &angle,
                                                      const Cell &this_cell, Cell &end_cell);
    landscape_fptr getValFptr;
public:
    SimulateDispersal()
    {
        has_set_size = false;
        sigma = 0.0;
        tau = 0.0;
        m_prob = 0.0;
        cutoff = 0.0;
        num_repeats = 0;
        num_steps = 0;
        database = nullptr;
        max_density = 0;
        seed = 0;
        is_sequential = false;
        parameter_reference = 0;
    }

    ~SimulateDispersal()
    {
        sqlite3_close(database);
    }

    void setSequential(bool bSequential);

    void setSizes(unsigned long x, unsigned long y);

    void importMaps(string map_file);

    void setSeed(unsigned long s)
    {
        seed = s;
        random.setSeed(s);
    }

    void setDispersalParameters(string dispersal_method_in, double sigma_in, double tau_in, double m_prob_in,
                                 double cutoff_in, string landscape_type);

    void setLandscapeType(string landscape_type);

    void setOutputDatabase(string out_database);

    void setNumberRepeats(unsigned long n);

    void setNumberSteps(unsigned long s);
    void storeCellList();

    const Cell& getRandomCell();

    void calculateNewPosition(const double &dist, const double &angle, const Cell &start_cell, Cell &end_cell);

    bool getEndPointInfinite(const double &dist, const double &angle, const Cell &this_cell, Cell &end_cell);

    bool getEndPointTiled(const double &dist, const double &angle, const Cell &this_cell, Cell &end_cell);

    bool getEndPointClosed(const double &dist, const double &angle, const Cell &this_cell, Cell &end_cell);

    bool getEndPoint(const double &dist, const double &angle, const Cell &this_cell, Cell &end_cell);

    void runMeanDispersalDistance();

    void runMeanDistanceTravelled();

    void writeDatabase(string table_name);

    void writeParameters(string table_name);

    void checkMaxParameterReference();

    unsigned long checkMaxIdNumber(string table_name);
};

#endif
.ft P
.fi
.UNINDENT
.UNINDENT
.SS Detailed Description
.sp
Samuel Thompson
BSD\-3 Licence.
.SS Includes
.INDENT 0.0
.IP \(bu 2
\fBMatrix.h\fP (file_necsim_Matrix.h)
.IP \(bu 2
\fBNRrand.h\fP (file_necsim_NRrand.h)
.IP \(bu 2
\fBcmath\fP
.IP \(bu 2
\fBfstream\fP
.IP \(bu 2
\fBiostream\fP
.IP \(bu 2
\fBsqlite3.h\fP
.IP \(bu 2
\fBstdexcept\fP
.IP \(bu 2
\fBstdio.h\fP
.IP \(bu 2
\fBstring\fP
.IP \(bu 2
\fBvector\fP
.UNINDENT
.SS Included By
.INDENT 0.0
.IP \(bu 2
file_necsim_SimulateDispersal.cpp
.UNINDENT
.SS Classes
.INDENT 0.0
.IP \(bu 2
class_Cell
.IP \(bu 2
class_SimulateDispersal
.UNINDENT
.SS Functions
.INDENT 0.0
.IP \(bu 2
function_distanceBetween
.UNINDENT
.SS Defines
.INDENT 0.0
.IP \(bu 2
define_PYTHON_COMPILE
.UNINDENT
.SS File SimulationTemplates.h
.sp
Contains template function for running any class of simulation (including protracted simulations, spatial and non\-spatial simulations.
.SS Contents
.INDENT 0.0
.IP \(bu 2
\fI\%Definition (necsim/SimulationTemplates.h)\fP
.IP \(bu 2
\fI\%Detailed Description\fP
.IP \(bu 2
\fI\%Includes\fP
.IP \(bu 2
\fI\%Included By\fP
.IP \(bu 2
\fI\%Functions\fP
.UNINDENT
.SS Definition (\fBnecsim/SimulationTemplates.h\fP)
.SS Program Listing for File SimulationTemplates.h
.INDENT 0.0
.IP \(bu 2
Return to documentation for file_necsim_SimulationTemplates.h
.UNINDENT
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
// This file is part of NECSim project which is released under BSD\-3 license.
// See file **LICENSE.txt** or visit https://opensource.org/licenses/BSD\-3\-Clause) for full license details.
//
#ifndef SIMULATIONTEMPLATES_H
#define SIMULATIONTEMPLATES_H
#include <string>
#include <sstream>
#include "Logging.h"
#include "CustomExceptions.h"

const string & getConfigFileFromCmdArgs(const vector<string> & com_args)
{
    if(com_args.size() != 3)
    {
        stringstream ss;
        ss << "Incorrect number of command\-line arguments supplied. Should be 3, got " << com_args.size() << endl;
        throw FatalException(ss.str());
    }
    else
    {
        return com_args[2];
    }
}

template <class T> void runMain(const string &config_file)
{
    // Create our tree object that contains the simulation
    T tree;
    tree.importSimulationVariables(config_file);
    // Setup the sim
    tree.setup();
    // Detect speciation rates to apply
    bool isComplete = tree.runSimulation();
    if(isComplete)
    {
        tree.applyMultipleRates();
    }
    writeInfo("*************************************************\en");
}

#endif //SIMULATIONTEMPLATES_H
.ft P
.fi
.UNINDENT
.UNINDENT
.SS Detailed Description
.sp
Sam Thompson
02/01/2018
Contact: \fI\%samuel.thompson14@imperial.ac.uk\fP or \fI\%thompsonsed@gmail.com\fP BSD\-3 Licence.
.SS Includes
.INDENT 0.0
.IP \(bu 2
\fBCustomExceptions.h\fP (file_necsim_CustomExceptions.h)
.IP \(bu 2
\fBLogging.h\fP (file_necsim_Logging.h)
.IP \(bu 2
\fBsstream\fP
.IP \(bu 2
\fBstring\fP
.UNINDENT
.SS Included By
.INDENT 0.0
.IP \(bu 2
file_necsim_main.cpp
.UNINDENT
.SS Functions
.INDENT 0.0
.IP \(bu 2
function_getConfigFileFromCmdArgs
.IP \(bu 2
function_runMain
.UNINDENT
.SS File SpatialTree.cpp
.sp
Contains the class_SpatialTree class implementation as the main simulation object for spatially\-explicit coalescence simulations.
.SS Contents
.INDENT 0.0
.IP \(bu 2
\fI\%Definition (necsim/SpatialTree.cpp)\fP
.IP \(bu 2
\fI\%Detailed Description\fP
.IP \(bu 2
\fI\%Includes\fP
.UNINDENT
.SS Definition (\fBnecsim/SpatialTree.cpp\fP)
.SS Program Listing for File SpatialTree.cpp
.INDENT 0.0
.IP \(bu 2
Return to documentation for file_necsim_SpatialTree.cpp
.UNINDENT
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
// This file is part of NECSim project which is released under BSD\-3 license.
// See file **LICENSE.txt** or visit https://opensource.org/licenses/BSD\-3\-Clause) for full license details.

#include <algorithm>
#include "SpatialTree.h"

void SpatialTree::importSimulationVariables(const string &configfile)
{
    sim_parameters.importParameters(configfile);
    // Now check that our folders exist
    checkFolders();
    // Now check for paused simulations
    checkSims();
}

void SpatialTree::parseArgs(vector<string> & comargs)
{
    // First parse the command line arguments
    bool bCheckUser=false;
    unsigned long argc = comargs.size();
    if(argc==1)
    {
        comargs.emplace_back("\-e");
        if(comargs.size()!=2)
        {
            stringstream ss;
            ss << "ERROR_MAIN_010: Incorrect command line parsing." << endl;
            throw FatalException(ss.str());
        }
    }
    if(comargs[1]=="\-h"||comargs[1]=="\-H"||argc==1||comargs[1]=="\-help" || comargs[1] == "\-e")
    {
        stringstream os;
        // Sort out piping to terminal if verbose has not been defined.
        #ifndef verbose
        dup2(saved_stdout, fileno(stdout));
        //close(saved_stdout);
        #endif
        if(argc==1)
        {
            os << "No arguments supplied: expected 30. These are: " << endl;
        }
        else
        {
            os << "30 command line arguments are required. These are: " << endl;
        }
        os << "1: the seed for the simulation." << endl;
        os << "2: the simulation task (for file reference)." << endl;
        os << "3: the map config file." << endl;
        os << "4: the output directory." << endl;
        os << "5: the minimum speciation rate." << endl;
        os << "6: the dispersal tau value." << endl;
        os << "7: the dispersal sigma value." << endl;
        os << "8: the deme size." << endl;
        os << "9: the deme sample size." << endl;
        os << "10: the maximum simulation time (in seconds)." << endl;
        os << "11: the dispersal_relative_cost value for moving through non\-habitat." << endl;
        os << "12: the temporal sampling file containing tab\-separated generation values for sampling points in time (null for only sampling the present)." << endl;
        os << "13: the minimum number of species known to exist. (Currently has no effect)." << endl;
        os << "14 onwards: speciation rates to apply after simulation." << endl;
        os << "There is also a full\-command line mode, (flag \-f), which allows for more options to be specified via the command line." << endl;
        os << "Would you like to see these options? Y/N: " << flush;
        writeWarning(os.str());
        os.str("");
        string fullopts;
        cin >> fullopts;
        if(fullopts == "Y" || fullopts == "y")
        {
            os << "1: the task_iter used for setting the seed." << endl;
            os << "2: the sample grid x dimension." << endl;
            os << "3: the sample grid y dimension." << endl;
            os << "4: the fine map file relative path." << endl;
            os << "5: the fine map x dimension." << endl;
            os << "6: the fine map y dimension." << endl;
            os << "7: the fine map x offset." << endl;
            os << "8 the fine map y offset." << endl;
            os << "9: the coarse map file relative path." << endl;
            os << "10: the coarse map x dimension." << endl;
            os << "11: the coarse map y dimension." << endl;
            os << "12: the coarse map x offset." << endl;
            os << "13: the coarse map y offset." << endl;
            os << "14: the scale of the coarse map compared to the fine (10 means resolution of coarse map = 10 x resolution of fine map)." << endl;
            os << "15: the output directory." << endl;
            os << "16: the speciation rate." << endl;
            os << "17: the dispersal distance (tau)." << endl;
            os << "18: the deme size." << endl;
            os << "19: the deme sample size (as a proportion of deme size)." << endl;
            os << "20: the time to run the simulation (in seconds)." << endl;
            os << "21: dispersal_relative_cost \- the relative cost of moving through non\-forest." << endl;
            os << "22: the_task \- for referencing the specific task later on." << endl;
            os << "23: the minimum number of species the system is known to contain." << endl;
            os << "24: the pristine fine map file to use." << endl;
            os << "25: the pristine coarse map file to use." << endl;
            os << "26: the rate of forest change from pristine." << endl;
            os << "27: the time (in generations) since the pristine forest was seen." << endl;
            os << "28: the dispersal sigma value." << endl;
            os << "29: the sample mask, with binary 1:0 values for areas that we want to sample from. If this is not provided then this will default to mapping the entire grid." << endl;
            os << "30: a file containing a tab\-separated list of sample points in time (in generations). If this is null then only the present day will be sampled." << endl;
            os << "31\-onwards: speciation rates to be applied at the end of the simulation" << endl;
            os << "Note that using the \-f flag prohibits more than one two historic maps being used." << endl;
        }
        os << "Would you like to run with the default settings? (Y/N)" << flush;
        writeWarning(os.str());
        os.str("");
        string cDef;
        cin >> cDef;
        if(cDef == "Y"||cDef=="y")
        {
            bCheckUser = true;
        }
        else
        {
            bCheckUser = false;
            os << "Possible command line arguments: " << endl;
            os << "\-h/\-help: Show the help file." << endl;
            os << "\-d/\-D: Run with default small parameters." << endl;
            os << "\-dl/\-DL: Run with default large parameters." << endl;
            os << "\-dx/\-DX: Run with the default very large parameters." << endl;
            os << "\-c/\-config: Run with the supplied config file." << endl;
            throw FatalException(os.str()); // exit the program right away as there is no need to continue if there is no simulation to run!
        }
    }

    if(comargs[1] == "\-r" || comargs[1] == "\-R" || comargs[1] == "\-resume")
    {
        comargs[1] = "resuming";
        if(argc != 6)
        {
            stringstream ss;
            ss << "Incorrect number of parameters provided for resuming simulation. Expecting:" << endl;
            ss << "1: \-r flag" << endl;
            ss << "2: the folder containing the paused simulation (should hold a \(aqPause\(aq folder)" << endl;
            ss << "3: the simulation seed" << endl;
            ss << "4: the simulation task" << endl;
            ss << "5: the time to run the simulation for" << endl;
            throw FatalException(ss.str());
        }
        bResume = true;
        has_paused = true;
    }
    // Import the default parameters if required.
    if(comargs[1]=="\-d"||comargs[1]=="\-D"||bCheckUser)
    {
        runAsDefault(comargs);
        bCheckUser=true;
    }
    if(comargs[1]=="\-dl"||comargs[1]=="\-DL"||comargs[1]=="\-dL"||comargs[1]=="\-Dl")
    {
        runLarge(comargs);
        bCheckUser = true;
    }
    if(comargs[1]=="\-dx"||comargs[1]=="\-dX"||comargs[1]=="\-DX"||comargs[1]=="\-Dx")
    {
        runXL(comargs);
        bCheckUser = true;
    }
    if(comargs[1]=="\-c"||comargs[1]=="\-C"||comargs[1]=="\-config"|| comargs[1]=="\-Config")
    {
        // Check that the config file is supplied.
        if(argc!=3 && argc)
        {
            throw FatalException("ERROR_MAIN_011: FATAL. \-c or \-config used to attempt importSpatialParameters from "
                                         "config file, but no config file provided.");
        }
        bConfig = true;
    }
    bFullmode = false;
    if(comargs[1] == "\-f" || comargs[2] == "\-f")
    {
        writeInfo("Full command\-line mode enabled.\en");
        bFullmode = true;
    }
    removeComOption(argc, comargs);
    removeComOption(argc, comargs);
    if(argc > 12 && !bFullmode)
    {
        return;
    }
    if(argc<31&&!bCheckUser &&!bConfig)
    {
        string err = "ERROR_MAIN_000: FATAL.  Incorrect arguments supplied (" + to_string((long long)argc\-1) + " supplied; expected 30).";
        throw FatalException(err);
        // note argc\-1 which takes in to account the automatic generation of one command line argument which is the number of arguments.
    }
    argc = comargs.size();
}


void SpatialTree::checkFolders()
{

    stringstream os;
    os << "Checking folder existance..." << flush;
    bool bFineMap, bCoarseMap, bFineMapPristine, bCoarseMapPristine, bSampleMask, bOutputFolder;
    try
    {
        bFineMap = doesExistNull(sim_parameters.fine_map_file);
    }
    catch(FatalException& fe)
    {
        writeError(fe.what());
        bFineMap = false;
    }
    try
    {
        bCoarseMap = doesExistNull(sim_parameters.coarse_map_file);
    }
    catch(FatalException& fe)
    {
        writeError(fe.what());
        bCoarseMap = false;
    }
    try
    {
        bFineMapPristine = doesExistNull(sim_parameters.pristine_fine_map_file);
    }
    catch(FatalException& fe)
    {
        writeError(fe.what());
        bFineMapPristine = false;
    }
    try
    {
        bCoarseMapPristine = doesExistNull(sim_parameters.pristine_coarse_map_file);
    }
    catch(FatalException& fe)
    {
        writeError(fe.what());
        bCoarseMapPristine = false;
    }
    bOutputFolder = checkOutputDirectory();
    try
    {
        bSampleMask = doesExistNull(sim_parameters.sample_mask_file);
    }
    catch(FatalException& fe)
    {
        writeError(fe.what());
        bSampleMask = false;
    }
    if(bFineMap && bCoarseMap && bFineMapPristine && bCoarseMapPristine && bOutputFolder && bSampleMask)
    {
        os << "\erChecking folder existance...done!                                                                " << endl;
        writeInfo(os.str());
        return;
    }
    else
    {
        throw FatalException("Required files do not all exist. Check program inputs.");
    }
}


void SpatialTree::setParameters()
{
    if(!has_imported_vars)
    {
        Tree::setParameters();
        // Set the variables equal to the value from the Mapvars object.
        fine_map_input = sim_parameters.fine_map_file;
        coarse_map_input = sim_parameters.coarse_map_file;
        grid_x_size = sim_parameters.grid_x_size;
        grid_y_size = sim_parameters.grid_y_size;

        fine_map_x_size = sim_parameters.fine_map_x_size;
        fine_map_y_size = sim_parameters.fine_map_y_size;
        fine_map_x_offset = sim_parameters.fine_map_x_offset;
        fine_map_y_offset = sim_parameters.fine_map_y_offset;

        coarse_map_x_size = sim_parameters.coarse_map_x_size;
        coarse_map_y_size = sim_parameters.coarse_map_y_size;
        coarse_map_x_offset = sim_parameters.coarse_map_x_offset;
        coarse_map_y_offset = sim_parameters.coarse_map_y_offset;
        coarse_map_scale = sim_parameters.coarse_map_scale;
        dispersal_relative_cost = sim_parameters.dispersal_relative_cost;


        // pristine map information
        pristine_fine_map_input = sim_parameters.pristine_fine_map_file;
        pristine_coarse_map_input = sim_parameters.pristine_coarse_map_file;
        gen_since_pristine = sim_parameters.gen_since_pristine;
        habitat_change_rate = sim_parameters.habitat_change_rate;
        desired_specnum = sim_parameters.desired_specnum;
        sigma = sim_parameters.sigma;
        tau = sim_parameters.tau;
        if(sim_parameters.landscape_type == "none")
        {
            sim_parameters.landscape_type = "closed";
        }
        if(sim_parameters.dispersal_method == "none")
        {
            sim_parameters.dispersal_method = "normal";
        }
    }
    else
    {
        throw FatalException("ERROR_MAIN_001: Variables already imported.");
    }
}



void SpatialTree::importMaps()
{
    if(has_imported_vars)
    {
        // Set the dimensions
        habitat_map.setDims(sim_parameters);
        try
        {
            // Set the time variables
            habitat_map.checkMapExists();
            // habitat_map.setTimeVars(gen_since_pristine,habitat_change_rate);
            // Import the fine map
            habitat_map.calcFineMap();
            // Import the coarse map
            habitat_map.calcCoarseMap();
            // Calculate the offset for the extremeties of each map
            habitat_map.calcOffset();
            // Import the pristine maps;
            habitat_map.calcPristineFineMap();
            habitat_map.calcPristineCoarseMap();
            // Calculate the maximum values
            habitat_map.recalculateHabitatMax();
            importReproductionMap();
            samplegrid.importSampleMask(sim_parameters);
        }
        catch(FatalException& fe)
        {
            stringstream ss;
            ss <<"Problem setting up map files: " << fe.what() << endl;
            throw FatalException(ss.str());
        }
    }
    else
    {
        throw FatalException("ERROR_MAIN_002: Variables not imported.");
    }
}

void SpatialTree::importReproductionMap()
{
    rep_map.import(sim_parameters.reproduction_file,
                   sim_parameters.fine_map_x_size, sim_parameters.fine_map_y_size);
    rep_map.setOffsets(sim_parameters.coarse_map_x_offset, sim_parameters.fine_map_y_offset,
                       sim_parameters.grid_x_size, sim_parameters.grid_y_size);
    // Now verify that the reproduction map is always non\-zero when the density is non\-zero.
    verifyReproductionMap();
}


unsigned long SpatialTree::getInitialCount()
{
    unsigned long initcount = 0;
    // Get a count of the number of individuals on the grid.
    try
    {
        long max_x, max_y;
        if(samplegrid.getDefault())
        {
            max_x = sim_parameters.fine_map_x_size;
            max_y = sim_parameters.fine_map_y_size;
        }
        else
        {
            if(sim_parameters.uses_spatial_sampling)
            {
                max_x = samplegrid.sample_mask_exact.GetCols();
                max_y = samplegrid.sample_mask_exact.GetRows();
            }
            else
            {
                max_x = samplegrid.sample_mask.GetCols();
                max_y = samplegrid.sample_mask.GetRows();
            }
        }
        long x, y, xwrap, ywrap;
        for(long i = 0; i < max_y; i++)
        {
            for(long j = 0; j < max_x; j++)
            {
                x = j;
                y = i;
                xwrap = 0;
                ywrap = 0;
                samplegrid.recalculate_coordinates(x, y, xwrap, ywrap);
                initcount += getIndividualsSampled(x, y, xwrap, ywrap, 0.0);
            }
        }
    }
    catch(exception& e)
    {
        throw FatalException(e.what());
    }
    // Set active and data at the correct sizes.
    if(initcount == 0)
    {
        throw runtime_error("Initial count is 0. No individuals to simulate. Exiting program.");
    }
    else
    {
        writeInfo("Initial count is " + to_string(initcount) + "\en");
    }
    if(initcount > 10000000000)
    {
        writeWarning("Initial count extremely large, RAM issues likely: " + to_string(initcount));
    }
    return initcount;
}


void SpatialTree::setupDispersalCoordinator()
{
    dispersal_coordinator.setHabitatMap(&habitat_map);
    dispersal_coordinator.setRandomNumber(&NR);
    dispersal_coordinator.setGenerationPtr(&generation);
    dispersal_coordinator.setDispersal(sim_parameters.dispersal_method, sim_parameters.dispersal_file,
                                        sim_parameters.fine_map_x_size, sim_parameters.fine_map_y_size,
                                        sim_parameters.m_prob, sim_parameters.cutoff, sim_parameters.sigma,
                                        sim_parameters.tau, sim_parameters.restrict_self);
}

void SpatialTree::setup()
{
    printSetup();
    if(has_paused)
    {
        if(!has_imported_pause)
        {
            setResumeParameters();
        }
        simResume();
        setupDispersalCoordinator();
    }
    else
    {
        setParameters();
        setInitialValues();
        importMaps();
        setupDispersalCoordinator();
        habitat_map.setLandscape(sim_parameters.landscape_type);
#ifdef DEBUG
        habitat_map.validateMaps();
#endif
        generateObjects();
    }
}

unsigned long SpatialTree::fillObjects(const unsigned long &initial_count)
{
    active[0].setup(0, 0, 0, 0, 0, 0, 0);
    grid.SetSize(grid_y_size, grid_x_size);
    unsigned long number_start = 0;
    stringstream os;
    os << "\erSetting up simulation...filling grid                           " << flush;
    writeInfo(os.str());
    // Add the individuals to the grid, and add wrapped individuals to their correct locations.
    // This loop adds individuals to data and active (for storing the coalescence tree and active lineage tracking)
    try
    {
        long x, y;
        long x_wrap, y_wrap;
        for(unsigned long i = 0; i < sim_parameters.sample_x_size; i++)
        {
            for(unsigned long j = 0; j < sim_parameters.sample_y_size; j++)
            {

                x = i;
                y = j;

                x_wrap = 0;
                y_wrap = 0;
                samplegrid.recalculate_coordinates(x, y, x_wrap, y_wrap);
                if(x_wrap == 0 && y_wrap == 0)
                {
                    unsigned long stored_next = grid[y][x].getNext();
                    unsigned long stored_nwrap = grid[y][x].getNwrap();
                    grid[y][x].initialise(habitat_map.getVal(x, y, 0, 0, 0));
                    grid[y][x].fillList();
                    grid[y][x].setNwrap(stored_nwrap);
                    grid[y][x].setNext(stored_next);
                    unsigned long sample_amount = getIndividualsSampled(x, y, 0, 0, 0.0);
                    if(sample_amount >= 1)
                    {
                        for(unsigned long k = 0; k < sample_amount; k++)
                        {
                            if(k >= grid[y][x].getMaxsize())
                            {
                                break;
                            }
                            if(number_start + 1 > initial_count)
                            {
                                stringstream msg;
                                msg << "Number start greater than initial count. Please report this error!" << endl;
                                msg << "Number start: " << number_start << ". Initial count: " << initial_count
                                    << endl;
                                throw out_of_range(msg.str());
                            }
                            else
                            {
                                number_start++;
                                unsigned long list_position_in = grid[y][x].addSpecies(number_start);
                                // Add the species to active
                                active[number_start].setup(x, y, 0, 0, number_start, list_position_in, 1);
                                // Add a tip in the TreeNode for calculation of the coalescence tree at the
                                // end of the simulation.
                                // This also contains the start x and y position of the species.
                                data[number_start].setup(true, x, y, 0, 0);
                                data[number_start].setSpec(NR.d01());
                                endactive++;
                                enddata++;
                            }
                        }
                    }
                }
                else
                {
                    unsigned long sample_amount = getIndividualsSampled(x, y, x_wrap, y_wrap, 0.0);
                    if(sample_amount >= 1)
                    {
                        for(unsigned long k = 0; k < sample_amount; k++)
                        {
                            if(number_start + 1 > initial_count)
                            {
                                stringstream msg;
                                msg << "Number start greater than initial count. Please report this error!";
                                msg << "Number start: " << number_start << ". Initial count: " << initial_count
                                    << endl;
                                throw out_of_range(msg.str());
                            }
                            else
                            {
                                number_start++;
                                // Add the lineage to the wrapped lineages
                                active[number_start].setup((unsigned long) x,
                                                           (unsigned long) y,
                                                           x_wrap, y_wrap, number_start, 0, 1);
                                addWrappedLineage(number_start, x, y);
                                // Add a tip in the TreeNode for calculation of the coalescence tree at the
                                // end of the simulation.
                                // This also contains the start x and y position of the species.
                                data[number_start].setup(true, x, y, x_wrap, y_wrap);
                                data[number_start].setSpec(NR.d01());
                                endactive++;
                                enddata++;
                            }
                        }
                    }
                }
            }
        }
        if(sim_parameters.uses_spatial_sampling)
        {

            samplegrid.convertBoolean(habitat_map, deme_sample, generation);
            // if there are no additional time points to sample at, we can remove the sample mask from memory.
            if(!(has_times_file && this_step.time_reference < reference_times.size()))
            {
                samplegrid.clearSpatialMask();
            }
        }
    }
    catch(out_of_range &out_of_range1)
    {
        stringstream ss;
        ss << "Fatal exception thrown when filling grid (out_of_range): " << out_of_range1.what() << endl;
        throw FatalException(ss.str());
    }
    catch(exception &fe)
    {
        throw FatalException("Fatal exception thrown when filling grid (other) \en");
    }

    if(number_start == initial_count)  // Check that the two counting methods match up.
    {
    }
    else
    {
        if(initial_count > 1.1 * number_start)
        {
            writeWarning("Data usage higher than neccessary \- check allocation of individuals to the grid.");
            stringstream ss;
            ss << "Initial count: " << initial_count << "  Number counted: " << number_start << endl;
            writeWarning(ss.str());
        }
    }
#ifdef DEBUG
    validateLineages();
#endif
    return number_start;
}

unsigned long SpatialTree::getIndividualsSampled(const long &x, const long &y, const long &x_wrap,
                                          const long &y_wrap, const double &current_gen)
{
//  if(sim_parameters.uses_spatial_sampling)
//  {
        return static_cast<unsigned long>(max(floor(deme_sample * habitat_map.getVal(x, y, x_wrap, y_wrap, 0.0)
                         * samplegrid.getExactValue(x, y, x_wrap, y_wrap)), 0.0));
//  }
//  else
//  {
//      return static_cast<unsigned long>(max(floor(deme_sample * habitat_map.getVal(x, y, x_wrap, y_wrap, 0.0)), 0.0));
//  }
}

void SpatialTree::removeOldPosition(const unsigned long &chosen)
{
    long nwrap = active[chosen].getNwrap();
    long oldx = active[chosen].getXpos();
    long oldy = active[chosen].getYpos();
    if(nwrap == 0)
    {
#ifdef DEBUG

        if(active[chosen].getXwrap() != 0 || active[chosen].getYwrap() != 0)
        {
            active[chosen].logActive(50);
            throw FatalException("ERROR_MOVE_015: Nwrap not set correctly. Nwrap 0, but x and y wrap not 0. ");
        }
#endif // DEBUG
// Then the lineage exists in the main list;
// debug (can be removed later)
#ifdef pristine_mode
        if(grid[oldy][oldx].getMaxsize() < active[chosen].getListpos())
        {
            stringstream ss;
            ss << "grid maxsize: " << grid[oldy][oldx].getMaxsize() << endl;
            writeCritical(ss.str());
            throw FatalException("ERROR_MOVE_001: Listpos outside maxsize. Check move programming function.");
        }
#endif
        // delete the species from the list
        grid[oldy][oldx].deleteSpecies(active[chosen].getListpos());
        // clear out the variables.
        active[chosen].setNext(0);
        active[chosen].setNwrap(0);
        active[chosen].setListPosition(0);
    }
    else  // need to loop over the nwrap to check nexts
    {
        if(nwrap == 1)
        {
            grid[oldy][oldx].setNext(active[chosen].getNext());
            // Now reduce the nwrap of the lineages that have been effected.
            long nextpos = active[chosen].getNext();
            // loop over the rest of the list, reducing the nwrap
            while(nextpos != 0)
            {
                active[nextpos].decreaseNwrap();
                nextpos = active[nextpos].getNext();
            }
            // decrease the nwrap
            grid[oldy][oldx].decreaseNwrap();
            active[chosen].setNwrap(0);
            active[chosen].setNext(0);
            active[chosen].setListPosition(0);
            nwrap = 0;
        }
        else
        {
            long lastpos = grid[oldy][oldx].getNext();
            while(active[lastpos].getNext() !=
                  chosen)  // loop until we reach the next, then set the next correctly.
            {
                lastpos = active[lastpos].getNext();
            }
            if(lastpos != 0)
            {
                active[lastpos].setNext(active[chosen].getNext());
#ifdef DEBUG
                if(active[lastpos].getNwrap() != (active[chosen].getNwrap() \- 1))
                {
                    writeLog(50, "Logging last position: ");
                    active[lastpos].logActive(50);
                    writeLog(50, "Logging chosen position: ");
                    active[chosen].logActive(50);
                    throw FatalException("ERROR_MOVE_022: nwrap setting of either chosen or the "
                                          "lineage wrapped before chosen. Check move function.");
                }
#endif // DEBUG
                lastpos = active[lastpos].getNext();
                while(lastpos != 0)
                {
                    active[lastpos].decreaseNwrap();
                    lastpos = active[lastpos].getNext();
                }

            }
            else
            {
#ifdef DEBUG
                writeLog(50, "Logging chosen");
                active[chosen].logActive(50);
#endif // DEBUG
                throw FatalException(
                    "ERROR_MOVE_024: Last position before chosen is 0 \- this is impossible.");
            }
            grid[oldy][oldx].decreaseNwrap();
            active[chosen].setNwrap(0);
            active[chosen].setNext(0);
            active[chosen].setListPosition(0);
            nwrap = 0;

        }
        unsigned long iCount = 1;
        long pos = grid[oldy][oldx].getNext();
        if(pos == 0)
        {
            iCount = 0;
        }
        else
        {
            int c = 0;
            while(active[pos].getNext() != 0)
            {
                c++;
                iCount++;
                pos = active[pos].getNext();
                if(c > 10000)
                {
                    //                  os << pos << endl;
                    //                  os << active[pos].getNext() << endl;
                    break;
                }
            }
        }

        if(iCount != grid[oldy][oldx].getNwrap())
        {
#ifdef DEBUG
            stringstream ss;
            ss << "Nwrap: " << grid[oldy][oldx].getNwrap() << " Counted lineages: " << iCount << endl;
            writeLog(50, ss);
#endif // DEBUG
            throw FatalException("ERROR_MOVE_014: Nwrap not set correctly after move for grid cell");
        }
    }
}

void SpatialTree::calcMove()
{
    dispersal_coordinator.disperse(this_step);
}


long double SpatialTree::calcMinMax(const unsigned long& current)
{
    // this formula calculates the speciation rate required for speciation to have occured on this branch.
    // need to allow for the case that the number of gens was 0
    long double newminmax = 1;
    long double oldminmax = active[current].getMinmax();
    if(data[active[current].getReference()].getGenRate() == 0)
    {
        newminmax = data[active[current].getReference()].getSpecRate();
    }
    else
    {
        // variables need to be defined separately for the decimal division to function properly.
        long double tmpdSpec = data[active[current].getReference()].getSpecRate();
        long double tmpiGen = data[active[current].getReference()].getGenRate();
        newminmax = 1 \- (pow(1 \- tmpdSpec, (1 / tmpiGen)));
    }
    long double toret = min(newminmax, oldminmax);
    return toret;
}



void SpatialTree::calcNewPos(bool& coal,
                      const unsigned long& chosen,
                      unsigned long& coalchosen,
                      const long& oldx,
                      const long& oldy,
                      const long& oldxwrap,
                      const long& oldywrap)
{
    // Calculate the new position of the move, whilst also calculating the probability of coalescence.
    unsigned long nwrap = active[chosen].getNwrap();
    if(oldxwrap == 0 && oldywrap == 0)
    {
        // Debug check (to remove later)
        if(nwrap != 0)
        {
            throw FatalException(
                "ERROR_MOVE_006: NON FATAL. Nwrap not set correctly. Check move programming function.");
        }
        // then the procedure is relatively simple.
        // check for coalescence
        // check if the grid needs to be updated.
        if(grid[oldy][oldx].getMaxsize() != habitat_map.getVal(oldx, oldy, oldxwrap, oldywrap, generation))
        {
            grid[oldy][oldx].setMaxsize(habitat_map.getVal(oldx, oldy, 0, 0, generation));
        }
        coalchosen = grid[oldy][oldx].getRandLineage(NR);
#ifdef DEBUG
        if(coalchosen != 0)
        {
            if(active[coalchosen].getXpos() != (unsigned long)oldx ||
               active[coalchosen].getYpos() != (unsigned long)oldy ||
               active[coalchosen].getXwrap() != oldxwrap || active[coalchosen].getYwrap() != oldywrap)
            {
                writeLog(50, "Logging chosen:");
                active[chosen].logActive(50);
                writeLog(50, "Logging coalchosen: ");
                active[coalchosen].logActive(50);
                throw FatalException("ERROR_MOVE_006: NON FATAL. Nwrap not set correctly. Please report this bug.");
            }
        }
#endif
        if(coalchosen == 0)  // then the lineage can be placed in the empty space.
        {
            long tmplistindex = grid[oldy][oldx].addSpecies(chosen);
            // check
            if(grid[oldy][oldx].getSpecies(tmplistindex) != chosen)
            {
                throw FatalException("ERROR_MOVE_005: Grid index not set correctly for species. Check "
                                      "move programming function.");
            }
#ifdef pristine_mode
            if(grid[oldy][oldx].getListsize() > grid[oldy][oldx].getMaxsize())
            {
                throw FatalException(
                    "ERROR_MOVE_001: Listpos outside maxsize. Check move programming function.");
            }
#endif
            active[chosen].setNwrap(0);
            active[chosen].setListPosition(tmplistindex);
            coal = false;
        }
        else  // then coalescence has occured
        {
            active[chosen].setNwrap(0);
            active[chosen].setListPosition(0);
            // DO THE COALESCENCE STUFF
            coal = true;
        }
    }
    else  // need to check all the possible places the lineage could be.
    {
        if(nwrap != 0)
        {
            throw FatalException("ERROR_MOVE_022: Nwrap not set correctly in move.");
        }
        nwrap = grid[oldy][oldx].getNwrap();
        if(nwrap != 0)  // then coalescence is possible and we need to loop over the nexts to check those that are
        // in the same position
        {
            // Count the possible matches of the position.
            unsigned long matches = 0;
            // Create an array containing the list of active references for those that match as
            // this stops us having to loop twice over the same list.
            unsigned long matchlist[nwrap];
            unsigned long next_active;
            next_active = grid[oldy][oldx].getNext();
            // Count if the first "next" matches
            if(active[next_active].getXwrap() == oldxwrap && active[next_active].getYwrap() == oldywrap)
            {
#ifdef DEBUG
                if(active[next_active].getNwrap() != 1)
                {
                    throw FatalException("ERROR_MOVE_022a: Nwrap not set correctly in move.");
                }
#endif
                matchlist[matches] = next_active;  // add the match to the list of matches.
                matches++;
            }
            // Now loop over the remaining nexts counting matches
            //#ifdef DEBUG
            unsigned long ncount = 1;
            //#endif
            while(active[next_active].getNext() != 0)
            {
                next_active = active[next_active].getNext();
                if(active[next_active].getXwrap() == oldxwrap && active[next_active].getYwrap() == oldywrap)
                {
                    matchlist[matches] = next_active;
                    matches++;
                }
                // check
                //#ifdef DEBUG
                ncount++;
#ifdef DEBUG
                if(active[next_active].getNwrap() != ncount)
                {
                    throw FatalException("ERROR_MOVE_022d: Nwrap not set correctly in move.");
                }
#endif
            }
            if(nwrap != ncount)
            {
                throw FatalException("ERROR_MOVE_022c: Nwrap not set correctly in move.");
            }
            // Matches now contains the number of lineages at the exact x,y, xwrap and ywrap position.
            // Check if there were no matches at all
            if(matches == 0)
            {
                coalchosen = 0;
                coal = false;
                active[next_active].setNext(chosen);
                grid[oldy][oldx].increaseNwrap();
                active[chosen].setNwrap(grid[oldy][oldx].getNwrap());
                active[chosen].setListPosition(0);
            }
            else  // if there were matches, generate a random number to see if coalescence occured or not
            {
                unsigned long randwrap =
                    floor(NR.d01() * (habitat_map.getVal(oldx, oldy, oldxwrap, oldywrap, generation)) + 1);
// Get the random reference from the match list.
// If the movement is to an empty space, then we can update the chain to include the new
// lineage.
#ifdef pristine_mode
                if(randwrap > habitat_map.getVal(oldx, oldy, oldxwrap, oldywrap, generation))
                {
                    throw FatalException(
                        "ERROR_MOVE_004: Randpos outside maxsize. Check move programming function");
                }
                if(matches > habitat_map.getVal(oldx, oldy, oldxwrap, oldywrap, generation))
                {
                    cerr << "matches: " << matches << endl
                         << "habitat_map value: "
                         << habitat_map.getVal(oldx, oldy, oldxwrap, oldywrap, generation);
                    throw FatalException(
                        "ERROR_MOVE_004: matches outside maxsize. Check move programming function");
                }
#endif
                if(randwrap > matches)  // coalescence has not occured
                {
                    // os << "This shouldn\(aqt happen" << endl;
                    coalchosen = 0;
                    coal = false;
                    active[next_active].setNext(chosen);
                    grid[oldy][oldx].increaseNwrap();
                    active[chosen].setNwrap(grid[oldy][oldx].getNwrap());
                    active[chosen].setListPosition(0);
                }
                else  // coalescence has occured
                {
                    coal = true;
                    coalchosen = matchlist[randwrap \- 1];
                    active[chosen].setEndpoint(oldx, oldy, oldxwrap, oldywrap);
                    if(coalchosen == 0)
                    {
                        throw FatalException(
                            "ERROR_MOVE_025: Coalescence attempted with lineage of 0.");
                    }
                }
            }
#ifdef pristine_mode
            if(grid[oldy][oldx].getMaxsize() < active[chosen].getListpos())
            {
                throw FatalException(
                    "ERROR_MOVE_001: Listpos outside maxsize. Check move programming function.");
            }
#endif
        }
        else  // just add the lineage to next.
        {
            if(grid[oldy][oldx].getNext() != 0)
            {
                throw FatalException("ERROR_MOVE_026: No nwrap recorded, but next is non\-zero.");
            }
            coalchosen = 0;
            coal = false;
            grid[oldy][oldx].setNext(chosen);
            active[chosen].setNwrap(1);
            active[chosen].setNext(0);
            grid[oldy][oldx].increaseNwrap();
// check
#ifdef DEBUG
            if(grid[oldy][oldx].getNwrap() != 1)
            {
                throw FatalException("ERROR_MOVE_022b: Nwrap not set correctly in move.");
            }
#endif
        }
        if(coalchosen != 0)
        {
            if(active[coalchosen].getXpos() != (unsigned long)oldx ||
               active[coalchosen].getYpos() != (unsigned long)oldy ||
               active[coalchosen].getXwrap() != oldxwrap || active[coalchosen].getYwrap() != oldywrap)
            {
#ifdef DEBUG
                writeLog(50, "Logging chosen:");
                active[chosen].logActive(50);
                writeLog(50, "Logging coalchosen: ");
                active[coalchosen].logActive(50);
#endif // DEBUG
                throw FatalException("ERROR_MOVE_006b: NON FATAL. Nwrap not set correctly. Check move "
                                      "programming function.");
            }
        }
        //#endif
    }
}

void SpatialTree::switchPositions(const unsigned long &chosen)
{
#ifdef DEBUG
    if(chosen > endactive)
    {
        stringstream ss;
        ss << "chosen: " << chosen << " endactive: " << endactive << endl;
        writeLog(50, ss);
        throw FatalException("ERROR_MOVE_023: Chosen is greater than endactive. Check move function.");
    }
#endif // DEBUG
    if(chosen != endactive)
    {
        // This routine assumes that the previous chosen position has already been deleted.
        DataPoint tmpdatactive;
        tmpdatactive.setup(active[chosen]);
        // now need to remove the chosen lineage from memory, by replacing it with the lineage that lies in the last
        // place.
        if(active[endactive].getXwrap() == 0 &&
           active[endactive].getYwrap() == 0)  // if the end lineage is simple, we can just copy it across.
        {
            // check endactive
            if(active[endactive].getNwrap() != 0)
            {
                cerr << "ERROR_MOVE_020: NON FATAL. Nwrap is not set correctly for endactive (nwrap should "
                        "be 0, but is "
                     << active[endactive].getNwrap() << " ). Identified during switch of positions."
                     << endl;
            }
            grid[active[endactive].getYpos()][active[endactive].getXpos()].setSpecies(
                active[endactive].getListpos(), chosen);
            active[chosen].setup(active[endactive]);
            active[endactive].setup(tmpdatactive);
            active[endactive].setNwrap(0);
            active[endactive].setNext(0);
        }
        else  // else the end lineage is wrapped, and needs to be processed including the wrapping routines.
        {
            if(active[endactive].getNwrap() == 0)
            {
                cerr << "ERROR_MOVE_021: NON FATAL. Nwrap is not set correctly for endactive (nwrap "
                        "incorrectly 0). Identified during switch of positions."
                     << endl;
            }
            //              os << "wrap"<<endl;
            long tmpactive = grid[active[endactive].getYpos()][active[endactive].getXpos()].getNext();
            unsigned long tmpnwrap = active[endactive].getNwrap();

            // if the wrapping is just once, we need to set the grid next to the chosen variable.
            if(tmpnwrap == 1)
            {
                // check
                if(grid[active[endactive].getYpos()][active[endactive].getXpos()].getNext() != endactive)
                {
                    throw FatalException(string(
                        "ERROR_MOVE_019: FATAL. Nwrap for endactive not set correctly. Nwrap is 1, but "
                        "lineage at 1st position is " +
                        to_string(
                            (long long)grid[active[endactive].getYpos()][active[endactive].getXpos()]
                                .getNext()) +
                        ". Identified during the move."));
                }
                grid[active[endactive].getYpos()][active[endactive].getXpos()].setNext(chosen);
            }
            else  // otherwise, we just set the next to chosen instead of endactive.
            {
                unsigned long tmpcount = 0;
                // loop over nexts until we reach the right lineage.
                while(active[tmpactive].getNext() != endactive)
                {
                    tmpactive = active[tmpactive].getNext();
                    tmpcount++;
#ifdef DEBUG
                    if(tmpcount > tmpnwrap)
                    {
                        writeLog(30, "ERROR_MOVE_013: NON FATAL. Looping has not encountered a match, "
                                "despite going further than required. Check nwrap counting.");
                        if(tmpactive == 0)
                        {
                            stringstream ss;
                            ss << "gridnext: "
                                 << grid[active[endactive].getYpos()][active[endactive]
                                                                          .getXpos()]
                                        .getNext()
                                 << endl;
                            ss << "endactive: " << endactive << endl;
                            ss << "tmpactive: " << tmpactive << endl;
                            ss << "tmpnwrap: " << tmpnwrap << " tmpcount: " << tmpcount
                                 << endl;
                            writeLog(50, ss);
                            writeLog(50, "Logging chosen:");
                            active[chosen].logActive(50);
                            throw FatalException("No match found, please report this bug.");
                        }
                    }
#endif // DEBUG
                }
                active[tmpactive].setNext(chosen);
            }
            active[chosen].setup(active[endactive]);
            active[endactive].setup(tmpdatactive);

            // check \- debugging
            unsigned long testwrap = active[chosen].getNwrap();
            unsigned long testnext = grid[active[chosen].getYpos()][active[chosen].getXpos()].getNext();
            for(unsigned long i = 1; i < testwrap; i++)
            {
                testnext = active[testnext].getNext();
            }

            if(testnext != chosen)
            {
                throw FatalException("ERROR_MOVE_009: Nwrap position not set correctly after coalescence. "
                                      "Check move process.");
            }
        }
    }
    endactive\-\-;
}

void SpatialTree::calcNextStep()
{
    calcMove();
    // Calculate the new position, perform the move if coalescence doesn\(aqt occur or
    // return the variables for the coalescence event if coalescence does occur.
    active[this_step.chosen].setEndpoint(this_step.oldx, this_step.oldy,
                                         this_step.oldxwrap,
                                         this_step.oldywrap);
    calcNewPos(this_step.coal, this_step.chosen, this_step.coalchosen, this_step.oldx,
               this_step.oldy, this_step.oldxwrap, this_step.oldywrap);
}

unsigned long SpatialTree::estSpecnum()
{
    // This bit has been removed as it has a very significant performance hit and is not required for most simulations.
    // As of version 3.2 it was fully compatible with the rest of the simulation, however. See estSpecnum for commented
    // code
    // (removed from here to make things tidier).
    // This bit was moved from runSimulation() to make things tidier there.
    /*
    if(steps%1000000==0)
{
            time(&now);
            if(now \- time_taken>200&&dPercentComplete>95)
            {
                            time(&time_taken);
                            unsigned long specnum = est_specnum();
                            os << "Estimated number of species: " << specnum <<
                            flush;
                            if(specnum<desired_specnum)
                            {
                                            os << " \- desired
                                            number of species reached." << endl << "Halting
                                            simulations..." << endl;
                                            bContinueSim = false;
                            }
                            else
                            {
                                            os << endl;
                            }
            }
}
//*/
    long double dMinmax = 0;
    // first loop to find the maximum speciation rate required
    for(unsigned int i = 1; i <= endactive; i++)
    {
        long double tmpminmax = calcMinMax(i);
        active[i].setMinmax(tmpminmax);
        dMinmax = (long double)max(dMinmax, tmpminmax);
    }
    for(unsigned long i = 0; i <= enddata; i++)
    {
        if(data[i].isTip())
        {
            data[i].setExistence(true);
        }
        double maxret = 1;
        if(data[i].getGenRate() == 0)
        {
            maxret = 1;
        }
        else
        {
            maxret = data[i].getGenRate();
        }
        // This is the line that compares the individual random numbers against the speciation rate.
        if(data[i].getSpecRate() < (1 \- pow(double(1 \- dMinmax), maxret)))
        {
            data[i].speciate();
        }
    }
    bool loop = true;
    while(loop)
    {
        loop = false;
        for(unsigned int i = 0; i <= enddata; i++)
        {
            if(data[i].getExistence() && !data[data[i].getParent()].getExistence() && !data[i].hasSpeciated())
            {
                loop = true;
                data[data[i].getParent()].setExistence(true);
            }
        }
    }
    unsigned long iSpecies = 0;
    for(unsigned int i = 0; i <= enddata; i++)
    {
        if(data[i].getExistence() && data[i].hasSpeciated())
        {
            iSpecies++;
        }
    }
    for(unsigned int i = 0; i <= enddata; i++)
    {
        data[i].qReset();
    }
    //      os << "Estimated species number is: " << iSpecies << endl;
    return iSpecies;
}

#ifdef pristine_mode
void SpatialTree::pristineStepChecks()
{
    if(habitat_map.getVal(this_step.oldx, this_step.oldy, this_step.oldxwrap, this_step.oldywrap, generation) == 0)
    {
        cerr << "x,y: " << this_step.oldx << "," << this_step.oldy << " xwrap, ywrap: " << this_step.oldxwrap;
        cerr << "," << this_step.oldywrap << endl;
        cerr << "listsize: " << grid[this_step.oldy][this_step.oldx].getListsize()
             << "maxsize: " << grid[this_step.oldy][this_step.oldx].getMaxsize() << endl;
        throw FatalException(
            string("ERROR_MOVE_008: Dispersal attempted from non\-forest. Check dispersal function. Forest "
                   "cover: " +
                   to_string((long long)habitat_map.getVal(this_step.oldx, this_step.oldy, this_step.oldxwrap,
                                                         this_step.oldywrap, generation))));
    }
}
#endif


void SpatialTree::incrementGeneration()
{
    Tree::incrementGeneration();
    habitat_map.updateMap(generation);
    checkTimeUpdate();
    // check if the map is pristine yet
    habitat_map.checkPristine(generation);

}
#ifdef DEBUG
void SpatialTree::debugDispersal()
{
    if(habitat_map.getVal(this_step.oldx, this_step.oldy, this_step.oldxwrap, this_step.oldywrap, generation) == 0)
    {
        throw FatalException(
            string("ERROR_MOVE_007: Dispersal attempted to non\-forest. "
                   "Check dispersal function. Forest cover: " +
                   to_string((long long)habitat_map.getVal(this_step.oldx, this_step.oldy, this_step.oldxwrap,
                                                         this_step.oldywrap, generation))));
    }
}

#endif

void SpatialTree::updateStepCoalescenceVariables()
{
    Tree::updateStepCoalescenceVariables();
    while(!rep_map.hasReproduced(NR, active[this_step.chosen].getXpos(), active[this_step.chosen].getYpos(),
                                 active[this_step.chosen].getXwrap(), active[this_step.chosen].getYwrap()))
    {
        this_step.chosen = NR.i0(endactive \- 1) + 1;  // cannot be 0
    }
    // record old position of lineage
    this_step.oldx = active[this_step.chosen].getXpos();
    this_step.oldy = active[this_step.chosen].getYpos();
    this_step.oldxwrap = active[this_step.chosen].getXwrap();
    this_step.oldywrap = active[this_step.chosen].getYwrap();
#ifdef pristine_mode
    pristineStepChecks();
#endif
}

void SpatialTree::addLineages(double generation_in)
{
    // First loop over the grid to check for the number that needs to be added to active
    unsigned long added_active = 0;
    unsigned long added_data = 0;
    // Update the sample grid boolean mask, if required.
    if(sim_parameters.uses_spatial_sampling)
    {
        samplegrid.convertBoolean(habitat_map, deme_sample, generation_in);
    }
    for(unsigned long i = 0; i < sim_parameters.sample_x_size; i++)
    {
        for(unsigned long j = 0; j < sim_parameters.sample_y_size; j++)
        {
            long x, y;
            x = i;
            y = j;
            long xwrap, ywrap;
            xwrap = 0;
            ywrap = 0;
            samplegrid.recalculate_coordinates(x, y, xwrap, ywrap);
            if(samplegrid.getVal(x, y, xwrap, ywrap))
            {
                unsigned long num_to_add = countCellExpansion(x, y, xwrap, ywrap, generation_in, false);
                added_data += getIndividualsSampled(x, y, xwrap, ywrap, generation_in) \- num_to_add;
                added_active += num_to_add;
            }
        }
    }
    added_data += added_active;
    // now resize data and active if necessary
    checkSimSize(added_data, added_active);
    // Add the new lineages and modify the existing lineages within our sample area
    for(unsigned long i = 0; i < sim_parameters.sample_x_size; i++)
    {
        for(unsigned long j = 0; j < sim_parameters.sample_y_size; j++)
        {
            long x, y;
            x = i;
            y = j;
            long xwrap, ywrap;
            xwrap = 0;
            ywrap = 0;
            samplegrid.recalculate_coordinates(x, y, xwrap, ywrap);
            if(samplegrid.getVal(x, y, xwrap, ywrap))
            {
                // Count the number of new cells that we need to add (after making those that already exist into tips)
                // Note that this function won\(aqt make more tips than the proportion we are sampling
                unsigned long num_to_add = countCellExpansion(x, y, xwrap, ywrap, generation_in, true);
                expandCell(x, y, xwrap, ywrap, generation_in, num_to_add);
            }
        }
    }
    // double check sizes
    if(enddata >= data.size() || endactive >= active.size())
    {
        throw FatalException("ERROR_MAIN_012: FATAL. Enddata or endactive is greater than the size of the "
                              "relevant object. Programming error likely.");
    }
    if(endactive > startendactive)
    {
        startendactive = endactive;
    }
#ifdef DEBUG
    validateLineages();
#endif
}

string SpatialTree::simulationParametersSqlInsertion()
{
    string to_execute;
    to_execute = "INSERT INTO SIMULATION_PARAMETERS VALUES(" + to_string((long long)the_seed) + "," +
                 to_string((long long)the_task);
    to_execute += ",\(aq" + out_directory + "\(aq," + boost::lexical_cast<std::string>((long double)spec) + "," +
                  to_string((long double)sigma) + ",";
    to_execute += to_string((long double)tau) + "," + to_string((long long)deme) + ",";
    to_execute += to_string((long double)deme_sample) + "," + to_string((long long)maxtime) + ",";
    to_execute += to_string((long double)dispersal_relative_cost) + "," + to_string((long long)desired_specnum) + ",";
    to_execute += to_string((long double)sim_parameters.habitat_change_rate) + ",";
    to_execute += to_string((long double)sim_parameters.gen_since_pristine) + ",\(aq" + sim_parameters.times_file + "\(aq,\(aq";
    to_execute += coarse_map_input + "\(aq," + to_string((long long)coarse_map_x_size) + ",";
    to_execute += to_string((long long)coarse_map_y_size) + "," + to_string((long long)coarse_map_x_offset) + ",";
    to_execute += to_string((long long)coarse_map_y_offset) + "," + to_string((long long)coarse_map_scale) + ",\(aq";
    to_execute += fine_map_input + "\(aq," + to_string((long long)fine_map_x_size) + "," + to_string((long long)fine_map_y_size);
    to_execute += "," + to_string((long long)fine_map_x_offset) + "," + to_string((long long)fine_map_y_offset) + ",\(aq";
    to_execute += sim_parameters.sample_mask_file + "\(aq," + to_string((long long)grid_x_size) + "," +
                  to_string((long long) grid_y_size) + "," + to_string((long long) sim_parameters.sample_x_size) + ", ";
    to_execute += to_string((long long) sim_parameters.sample_y_size) + ", ";
    to_execute += to_string((long long) sim_parameters.sample_x_offset) + ", ";
    to_execute += to_string((long long) sim_parameters.sample_y_offset) + ", \(aq";
    to_execute += pristine_coarse_map_input + "\(aq,\(aq" + pristine_fine_map_input + "\(aq," + to_string(sim_complete);
    to_execute += ", \(aq" + sim_parameters.dispersal_method + "\(aq, ";
    to_execute += boost::lexical_cast<std::string>(sim_parameters.m_prob) + ", ";
    to_execute += to_string((long double)sim_parameters.cutoff) + ", ";
    to_execute += to_string(sim_parameters.restrict_self) + ", \(aq";
    to_execute += sim_parameters.landscape_type + "\(aq, ";
    // Now save the protracted speciation variables (not relevant in this simulation scenario)
    to_execute += protractedVarsToString();
    to_execute += ", \(aq" + sim_parameters.dispersal_file + "\(aq";
    to_execute += ");";
    return to_execute;
}

void SpatialTree::simPause()
{
    // Completely changed how this sections works \- it won\(aqt currently allow restarting of the simulations, but will
    // dump the data file to memory. \- simply calls sqlCreate and sqlOutput.
    // sqlCreate();
    // sqlOutput();

    // This function saves the data to 4 files. One contains the main simulation parameters, the other 3 contain the
    // simulation results thus far
    // including the grid object, data object and active object.
    string pause_folder = initiatePause();
    dumpMain(pause_folder);
    dumpActive(pause_folder);
    dumpData(pause_folder);
    dumpMap(pause_folder);
    completePause();
}

void SpatialTree::dumpMap(string pause_folder)
{
    try
    {
        // Output the data object
        ofstream out4;
        string file_to_open = pause_folder + "Dump_map_" + to_string(the_task) + "_" + to_string(the_seed) + ".csv";
        out4 << setprecision(64);
        out4.open(file_to_open.c_str());
        out4 << habitat_map;
        out4.close();
    }
    catch(exception& e)
    {
        cerr << e.what() << endl;
        cerr << "Failed to perform map dump to " << pause_folder << endl;
    }
}

void SpatialTree::simResume()
{
    initiateResume();
    // now load the objects
    loadMainSave();
    loadMapSave();
    setObjectSizes();
    loadActiveSave();
    loadDataSave();
    loadGridSave();
    time(&sim_start);
    writeInfo("\erLoading data from temp file...done!\en");
    sim_parameters.printVars();
}



void SpatialTree::loadGridSave()
{
    grid.SetSize(grid_x_size, grid_y_size);
    string file_to_open;
    try
    {
        stringstream os;
        os << "\erLoading data from temp file...grid..." << flush;
        // New method for re\-creating grid data from active lineages
        // First initialise the empty grid object
        writeInfo(os.str());
        for(unsigned long i = 0; i < grid_y_size; i++)
        {
            for(unsigned long j = 0; j < grid_x_size; j++)
            {
                grid[i][j].initialise(habitat_map.getVal(j, i, 0, 0, generation));
                grid[i][j].fillList();
            }
        }
        // Now fill the grid object with lineages from active. Only need to loop once.
        for(unsigned long i = 1; i <= endactive; i++)
        {
            if(active[i].getXwrap() == 0 && active[i].getYwrap() == 0)
            {
                grid[active[i].getYpos()][active[i].getXpos()].setSpeciesEmpty(active[i].getListpos(), i);
                grid[active[i].getYpos()][active[i].getXpos()].increaseListSize();
            }
            else
            {
                if(active[i].getNwrap() == 0)
                {
                    throw runtime_error(
                            "Nwrap should not be 0 if x and y wrap are not 0. Programming error likely.");
                }
                if(active[i].getNwrap() == 1)
                {
                    grid[active[i].getYpos()][active[i].getXpos()].setNext(i);
                }
                grid[active[i].getYpos()][active[i].getXpos()].increaseNwrap();
            }
        }
    }
    catch(exception& e)
    {
        string msg;
        msg = string(e.what()) + "Failure to import grid from " + file_to_open;
        throw FatalException(msg);
    }
}

void SpatialTree::loadMapSave()
{
    string file_to_open;
    // Input the map object
    try
    {
        stringstream os;
        os << "\erLoading data from temp file...map..." << flush;
        writeInfo(os.str());
        ifstream in5;
        file_to_open = pause_sim_directory + string("/Pause/Dump_map_") + to_string(the_task) + "_" +
                       to_string(the_seed) + string(".csv");
        in5.open(file_to_open);
        in5 >> habitat_map;
        in5.close();
        importReproductionMap();
    }
    catch(exception& e)
    {
        string msg;
        msg = string(e.what()) + "Failure to import map from " + file_to_open;
        throw FatalException(msg);
    }
}

void SpatialTree::verifyReproductionMap()
{
    if(!(sim_parameters.reproduction_file == "none" || sim_parameters.reproduction_file == "null"))
    {
        for(unsigned long i = 0; i < sim_parameters.fine_map_y_size; i++)
        {
            for(unsigned long j = 0; j < sim_parameters.fine_map_x_size; j ++)
            {
                if(rep_map[i][j] == 0.0 && habitat_map.getValFine(j, i, 0.0) != 0)
                {
                    throw FatalException("Reproduction map is zero where density is non\-zero. "
                                                 "This will cause an infinite loop.");
                }
                if(habitat_map.getValFine(j, i, 0.0) == 0 && rep_map[i][j] != 0.0)
                {
                    writeCritical("Density is zero where reproduction map is non\-zero. This is likely incorrect.");
                }
            }
        }
    }
}

void SpatialTree::addWrappedLineage(unsigned long numstart, long x, long y)
{
    if(grid[y][x].getNwrap() == 0)
    {
        grid[y][x].setNext(numstart);
        grid[y][x].setNwrap(1);
        active[numstart].setNwrap(1);
    }
    else
    {
        unsigned long tmp_next = grid[y][x].getNext();
        unsigned long tmp_last = tmp_next;
        unsigned long tmp_nwrap = 0;
        while(tmp_next != 0)
        {
            tmp_nwrap ++;
            tmp_last = tmp_next;
            tmp_next = active[tmp_next].getNext();
        }
        grid[y][x].increaseNwrap();
        active[tmp_last].setNext(numstart);
        active[numstart].setNwrap(tmp_nwrap + 1);
    }
#ifdef DEBUG
    debugAddingLineage(numstart, x, y);
#endif
}


unsigned long SpatialTree::countCellExpansion(const long &x, const long &y, const long &xwrap, const long &ywrap,
                                       const double &generation_in, const bool& make_tips)
{
    unsigned long map_cover = habitat_map.getVal(x, y, xwrap, ywrap, generation_in); // think I fixed a bug here...
    unsigned long num_to_add = static_cast<unsigned long>(max(floor(map_cover * deme_sample *
                                                                            samplegrid.getExactValue(x, y,
                                                                                                     xwrap, ywrap)),
                                                              0.0));
    if(xwrap == 0 && ywrap == 0)
    {
        unsigned long ref = 0;
        if(map_cover >= grid[y][x].getMaxsize())
        {
            grid[y][x].changePercentCover(map_cover);
        }
        while(ref < grid[y][x].getMaxsize() && num_to_add > 0)
        {
            unsigned long tmp_active = grid[y][x].getSpecies(ref);
            if(tmp_active != 0)
            {
                if(make_tips)
                {
                    makeTip(tmp_active, generation_in);
                }
                num_to_add \-\-;
            }
            ref ++;
        }
    }
    else
    {
        unsigned long next = grid[y][x].getNext();
        while(next != 0 && num_to_add > 0)
        {
            if(active[next].getXwrap() == xwrap && active[next].getYwrap() == ywrap)
            {
                num_to_add\-\-;
                if(make_tips)
                {
                    makeTip(next, generation_in);
                }
            }
            next = active[next].getNext();
        }
    }
    return num_to_add;
}

void SpatialTree::expandCell(long x, long y, long x_wrap, long y_wrap, double generation_in, unsigned long num_to_add)
{
    if(num_to_add > 0)
    {
        for(unsigned long k = 0; k < num_to_add; k ++)
        {
            endactive ++;
            enddata ++;
            unsigned long listpos = 0;
            // Add the species to active
            if(x_wrap == 0 && y_wrap == 0)
            {
                listpos = grid[y][x].addSpecies(endactive);
                active[endactive].setup(x, y, x_wrap, y_wrap, enddata, listpos, 1);
            }
            else
            {
                active[endactive].setup(x, y, x_wrap, y_wrap, enddata, listpos, 1);
                addWrappedLineage(endactive, x, y);
            }
            if(enddata >= data.size())
            {
                throw FatalException("Cannot add lineage \- no space in data. "
                                              "Check size calculations.");
            }
            if(endactive >= active.size())
            {
                throw FatalException("Cannot add lineage \- no space in active. "
                                              "Check size calculations.");
            }

            // Add a tip in the TreeNode for calculation of the coalescence tree at the
            // end of the simulation.
            // This also contains the start x and y position of the species.
            data[enddata].setup(true, x, y, x_wrap, y_wrap, generation_in);
            data[enddata].setSpec(NR.d01());
        }
    }
}

#ifdef DEBUG
void SpatialTree::validateLineages()
{
    bool fail = false;
    writeInfo("\enStarting lineage validation...");
    unsigned long printed = 0;
    for(unsigned long i = 1; i < endactive; i++)
    {
        stringstream ss;
        DataPoint tmp_datapoint = active[i];
        // Validate the location exists
        if(habitat_map.getVal(tmp_datapoint.getXpos(), tmp_datapoint.getYpos(),
                            tmp_datapoint.getXwrap(), tmp_datapoint.getYwrap(), 0.0) == 0)
        {
            if(printed < 100)
            {
                printed ++;
                ss << "Map value: " << habitat_map.getVal(tmp_datapoint.getXpos(), tmp_datapoint.getYpos(),
                                                           tmp_datapoint.getXwrap(), tmp_datapoint.getYwrap(),
                                                           0.0) << endl;
            }
            fail = true;
        }
        if(tmp_datapoint.getXwrap() == 0 && tmp_datapoint.getYwrap() == 0)
        {
            if(tmp_datapoint.getNwrap() != 0)
            {
                fail = true;
            }
            else
            {
                if(i !=
                   grid[tmp_datapoint.getYpos()][tmp_datapoint.getXpos()].getSpecies(tmp_datapoint.getListpos()))
                {
                    fail = true;
                }
            }
        }
        else
        {
            if(tmp_datapoint.getNwrap() == 0)
            {
                fail = true;
            }
            else
            {
                unsigned long tmp_next = grid[tmp_datapoint.getYpos()][tmp_datapoint.getXpos()].getNext();
                unsigned long count = 0;
                while(tmp_next != 0)
                {
                    count++;
                    if(count != active[tmp_next].getNwrap())
                    {
                        ss << "problem in wrap: " << count << " != " << active[tmp_next].getNwrap() << endl;
                        fail = true;
                    }
                    tmp_next = active[tmp_next].getNext();
                }
                if(count == 0 && count != grid[tmp_datapoint.getYpos()][tmp_datapoint.getXpos()].getNwrap())
                {
                    fail = true;
                }
                if(count != grid[tmp_datapoint.getYpos()][tmp_datapoint.getXpos()].getNwrap())
                {
                    fail = true;
                }
            }
        }
        if(fail)
        {
            stringstream ss;
            ss << "active reference: " << i << endl;
            ss << "Grid wrapping: " << grid[tmp_datapoint.getYpos()][tmp_datapoint.getXpos()].getNwrap() << endl;
            writeLog(50, ss);
            tmp_datapoint.logActive(50);
            throw FatalException("Failure in lineage validation. Please report this bug.");
        }
    }
    writeInfo("done\en");
}

void SpatialTree::debugAddingLineage(unsigned long numstart, long x, long y)
{
    unsigned long tmp_next = grid[y][x].getNext();
    unsigned long tmp_nwrap = 0;
    while(tmp_next != 0)
    {
        tmp_nwrap ++;
        if(active[tmp_next].getNwrap() != tmp_nwrap)
        {
            stringstream ss;
            ss << "tmp_nwrap: " << tmp_nwrap << endl;
            ss << "next = " << tmp_next << endl;
            ss << "numstart: " << numstart << endl;
            writeLog(50, ss);
            active[tmp_nwrap].logActive(50);
            throw FatalException("Incorrect setting of nwrap in wrapped lineage, please report this bug.");
        }
        tmp_next = active[tmp_next].getNext();
    }
    if(tmp_nwrap != grid[y][x].getNwrap())
    {
        stringstream ss;
        ss << "Grid nwrap: " << grid[y][x].getNwrap() << endl;
        ss << "Counted wrapping: " << tmp_nwrap << endl;
        ss << "active: " << numstart << endl;
        tmp_next = grid[y][x].getNext();
        tmp_nwrap = 0;
        while(tmp_next != 0 && tmp_nwrap < grid[y][x].getNwrap())
        {
            tmp_nwrap ++;
            ss << "tmp_next: " << tmp_next << endl;
            ss << "tmp_nwrap: " << tmp_nwrap << endl;
            tmp_next = active[tmp_next].getNext();
        }
        writeLog(50, ss);
        throw FatalException("Grid wrapping value not set correctly");
    }
}

void SpatialTree::runChecks(const unsigned long& chosen, const unsigned long& coalchosen)
{
// final checks
#ifdef pristine_mode
    if(active[chosen].getListpos() > grid[active[chosen].getYpos()][active[chosen].getXpos()].getMaxsize() &&
       active[chosen].getNwrap() == 0)
    {
        //              usleep(1);
        cerr << "list_position: " << active[chosen].getListpos()
             << " maxsize: " << grid[active[chosen].getYpos()][active[chosen].getXpos()].getMaxsize() << endl;
        throw FatalException("ERROR_MOVE_001: Listpos outside maxsize.");
    }

    if(active[coalchosen].getListpos() >
           grid[active[coalchosen].getYpos()][active[coalchosen].getXpos()].getMaxsize() &&
       active[coalchosen].getNwrap() == 0 && coalchosen != 0)
    {
        //              usleep(1);
        throw FatalException("ERROR_MOVE_002: Coalchosen list_position outside maxsize.");
    }
#endif
    Tree::runChecks(chosen, coalchosen);
    if(active[chosen].getNwrap() != 0)
    {
        unsigned long tmpactive = grid[active[chosen].getYpos()][active[chosen].getXpos()].getNext();
        for(unsigned long i = 1; i < active[chosen].getNwrap(); i++)
        {
            tmpactive = active[tmpactive].getNext();
        }

        if(tmpactive != chosen)
        {
            active[chosen].logActive(50);
            throw FatalException("ERROR_MOVE_003: Nwrap not set correctly.");
        }
    }

    if(active[chosen].getNwrap() != 0)
    {
        if(active[chosen].getXwrap() == 0 && active[chosen].getYwrap() == 0)
        {
            throw FatalException("ERROR_MOVE_10: Nwrap set to non\-zero, but x and y wrap 0.");
        }
    }
    if(active[endactive].getNwrap() != 0)
    {
        unsigned long nwrap = active[endactive].getNwrap();
        if(nwrap == 1)
        {
            if(grid[active[endactive].getYpos()][active[endactive].getXpos()].getNext() != endactive)
            {
                stringstream ss;
                ss << "Lineage at 1st position: "
                   << grid[active[endactive].getYpos()][active[endactive].getXpos()].getNext() << endl;
                ss << "endactive: " << endactive << endl
                   << "nwrap: " << nwrap << endl;
                ss << "chosen: " << chosen << endl;
                writeLog(10, ss);
                throw FatalException("ERROR_MOVE_016: Nwrap for endactive not set correctly. Nwrap is 1, "
                                              "but the lineage at 1st position is not endactive.");
            }
        }
        else
        {
            unsigned long tmpcheck = grid[active[endactive].getYpos()][active[endactive].getXpos()].getNext();
            unsigned long tmpnwrap = 1;
            while(tmpcheck != endactive)
            {
                tmpnwrap++;
                tmpcheck = active[tmpcheck].getNext();
                if(tmpnwrap > nwrap + 1)
                {
                    stringstream ss;
                    ss << "ERROR_MOVE_017: NON FATAL. Nrap for endactive not set correctly; looped "
                            "beyond nwrap and not yet found enactive."
                       << endl;
                    ss << "endactive: " << endactive << endl
                       << "nwrap: " << nwrap << endl
                       << "x,y: " << active[endactive].getXpos() << "," << active[endactive].getYpos()
                       << endl;
                    ss << "chosen: " << chosen << endl;
                    writeLog(10, ss);
                }
            }
            if(tmpnwrap != nwrap)
            {
                stringstream ss;
                ss << "ERROR_MOVE_018: NON FATAL. Nwrap for endactive not set correctly. Nwrap is "
                   << nwrap << " but endactive is at position " << tmpnwrap << endl;
                ss << "endactive: " << endactive << endl
                   << "nwrap: " << nwrap << endl
                   << "x,y: " << active[endactive].getXpos() << "," << active[endactive].getYpos()
                   << endl;
                ss << "chosen: " << chosen << endl;
                writeLog(10, ss);
            }
        }
    }
}

#endif
.ft P
.fi
.UNINDENT
.UNINDENT
.SS Detailed Description
.sp
Samuel Thompson
24/03/17
BSD\-3 Licence.
.SS Includes
.INDENT 0.0
.IP \(bu 2
\fBSpatialTree.h\fP (file_necsim_ProtractedSpatialTree.h)
.IP \(bu 2
\fBalgorithm\fP
.UNINDENT
.SS File SpatialTree.h
.sp
Contains the class_SpatialTree class for running simulations and outputting the phylogenetic tree.
.SS Contents
.INDENT 0.0
.IP \(bu 2
\fI\%Definition (necsim/SpatialTree.h)\fP
.IP \(bu 2
\fI\%Detailed Description\fP
.IP \(bu 2
\fI\%Includes\fP
.IP \(bu 2
\fI\%Included By\fP
.IP \(bu 2
\fI\%Classes\fP
.IP \(bu 2
\fI\%Defines\fP
.UNINDENT
.SS Definition (\fBnecsim/SpatialTree.h\fP)
.SS Program Listing for File SpatialTree.h
.INDENT 0.0
.IP \(bu 2
Return to documentation for file_necsim_SpatialTree.h
.UNINDENT
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
// This file is part of NECSim project which is released under BSD\-3 license.
// See file **LICENSE.txt** or visit https://opensource.org/licenses/BSD\-3\-Clause) for full license details.
//
#ifndef SPATIALTREE_H
#define SPATIALTREE_H

#include <cstdio>
#include <fstream>
#include <vector>
#include <iostream>
#include <string>
#include <cstring>
#include <cmath>
#include <iomanip>
#include <cmath>
#include <ctime>
#include <ctime>
#include <sqlite3.h>
#include <unistd.h>
#include <algorithm>
#include <stdexcept>
//#define with_gdal
// extra boost include \- this requires the installation of boost on the system
// note that this requires compilation with the \-lboost_filesystem and \-lboost_system linkers.
#include <boost/filesystem.hpp>

// include fast\-csv\-parser by Ben Strasser (available from https://github.com/ben\-strasser/fast\-cpp\-csv\-parser)
// for fast file reading
#ifdef use_csv
#include "fast\-cpp\-csv\-parser/csv.h"
#endif

#ifndef sql_ram
#define sql_ram
#endif

// other includes for required files
#include "Tree.h"
#include "Matrix.h"
#include "NRrand.h"
#include "SimParameters.h"
#include "DataPoint.h"
#include "TreeNode.h"
#include "SpeciesList.h"
#include "Map.h"
#include "Community.h"
#include "Setup.h"
#include "DispersalCoordinator.h"
#include "ReproductionMap.h"
#include "Logging.h"

using namespace std;

class SpatialTree : public virtual Tree
{
protected:
    // Our dispersal coordinator for getting dispersal distances and managing calls from the habitat_map
    DispersalCoordinator dispersal_coordinator;
    // The reproduction map object
    ReproductionMap rep_map;
    // A list of new variables which will contain the relevant information for maps and grids.
    //  strings containing the file names to be imported.
    string fine_map_input, coarse_map_input;
    string pristine_fine_map_input, pristine_coarse_map_input;
    // the time since pristine forest and the rate of change of the rainforest.
    double gen_since_pristine, habitat_change_rate;
    // the variables for the grid containing the initial individuals.
    unsigned long grid_x_size, grid_y_size;
    // The fine map variables at the same resolution as the grid.
    // the coarse map variables at a scaled resolution of the fine map.
    long fine_map_x_size, fine_map_y_size, fine_map_x_offset, fine_map_y_offset;
    long coarse_map_x_size, coarse_map_y_size, coarse_map_x_offset, coarse_map_y_offset, coarse_map_scale;
    // Map object containing both the coarse and fine maps for checking whether or not there is forest at a particular
    // location.
    Map habitat_map;
    // An indexing spatial positioning of the lineages
    Matrix<SpeciesList> grid;
    // dispersal and sigma references
    double sigma, tau;
    // the cost for moving through non\-forest. 1.0 means there is no cost. 10 means that movement is 10x
    // slower through forest.
    double dispersal_relative_cost;
    // the desired number of species we are aiming for. If it is 0, we will carry on forever.
    unsigned long desired_specnum;
    // contains the DataMask for where we should start lineages from.
    DataMask samplegrid;
public:
    SpatialTree() : Tree()
    {
        sigma = 0.0;
        tau = 0.0;
        outdatabase = nullptr;
        gen_since_pristine = 0.0;
        habitat_change_rate = 0.0;
        grid_x_size = 0;
        grid_y_size = 0;
        fine_map_x_size = 0;
        fine_map_y_size = 0;
        fine_map_x_offset = 0;
        fine_map_y_offset = 0;
        coarse_map_x_size = 0;
        coarse_map_y_size = 0;
        coarse_map_x_offset = 0;
        coarse_map_y_offset = 0;
        coarse_map_scale = 1;
        dispersal_relative_cost = 1.0;
        desired_specnum = 1;
    }

    ~SpatialTree() = default;
    void importSimulationVariables(const string &configfile) override;

    void parseArgs(vector<string> &comargs);

    void checkFolders();

    void setParameters() override;


    // Imports the maps using the variables stored in the class. This function must be run after the set_mapvars() in
    // order to function correctly.
    void importMaps();

    void importReproductionMap();

    unsigned long getInitialCount() override;

    void setupDispersalCoordinator();

    void setup() override;

    unsigned long fillObjects(const unsigned long &initial_count) override;

    unsigned long getIndividualsSampled(const long &x, const long &y,
                                 const long &x_wrap, const long &y_wrap, const double &current_gen);
    void removeOldPosition(const unsigned long &chosen) override;

    void calcMove();

    long double calcMinMax(const unsigned long &current);

    void calcNewPos(bool &coal,
                    const unsigned long &chosen,
                    unsigned long &coalchosen,
                    const long &oldx,
                    const long &oldy,
                    const long &oldxwrap,
                    const long &oldywrap);

    void switchPositions(const unsigned long &chosen) override;

    void calcNextStep() override;

    unsigned long estSpecnum();

#ifdef pristine_mode

    void pristineStepChecks();
#endif


    void incrementGeneration() override ;

    void updateStepCoalescenceVariables() override;

    void addLineages(double generation_in) override;

    string simulationParametersSqlInsertion() override;


    void simPause() override;

    void dumpMap(string pause_folder);

    void simResume() override;

    void loadGridSave();

    void loadMapSave();

    void verifyReproductionMap();

    void addWrappedLineage(unsigned long numstart, long x, long y);

    unsigned long countCellExpansion(const long &x, const long &y, const long &xwrap, const long &ywrap,
                                     const double &generationin, const bool &make_tips);

    void expandCell(long x, long y, long x_wrap, long y_wrap, double generation_in, unsigned long add);




#ifdef DEBUG

    void validateLineages() override;

    void debugDispersal();
    void debugAddingLineage(unsigned long numstart, long x, long y);

    void runChecks(const unsigned long &chosen, const unsigned long &coalchosen) override;
#endif
};

#endif  // SPATIALTREE_H
.ft P
.fi
.UNINDENT
.UNINDENT
.SS Detailed Description
.sp
Sam Thompson
31/08/2016
Contact: \fI\%samuel.thompson14@imperial.ac.uk\fP or \fI\%thompsonsed@gmail.com\fP BSD\-3 Licence.
.SS Includes
.INDENT 0.0
.IP \(bu 2
\fBCommunity.h\fP (file_necsim_Community.h)
.IP \(bu 2
\fBDataPoint.h\fP (file_necsim_DataPoint.h)
.IP \(bu 2
\fBDispersalCoordinator.h\fP (file_necsim_DispersalCoordinator.h)
.IP \(bu 2
\fBLogging.h\fP (file_necsim_Logging.h)
.IP \(bu 2
\fBMap.h\fP (file_necsim_Map.h)
.IP \(bu 2
\fBMatrix.h\fP (file_necsim_Matrix.h)
.IP \(bu 2
\fBNRrand.h\fP (file_necsim_NRrand.h)
.IP \(bu 2
\fBReproductionMap.h\fP (file_necsim_ReproductionMap.h)
.IP \(bu 2
\fBSetup.h\fP (file_necsim_Setup.h)
.IP \(bu 2
\fBSimParameters.h\fP (file_necsim_SimParameters.h)
.IP \(bu 2
\fBSpeciesList.h\fP (file_necsim_SpeciesList.h)
.IP \(bu 2
\fBTree.h\fP (file_necsim_ProtractedSpatialTree.h)
.IP \(bu 2
\fBTreeNode.h\fP (file_necsim_TreeNode.h)
.IP \(bu 2
\fBalgorithm\fP
.IP \(bu 2
\fBboost/filesystem.hpp\fP
.IP \(bu 2
\fBcmath\fP
.IP \(bu 2
\fBcstdio\fP
.IP \(bu 2
\fBcstring\fP
.IP \(bu 2
\fBctime\fP
.IP \(bu 2
\fBfstream\fP
.IP \(bu 2
\fBiomanip\fP
.IP \(bu 2
\fBiostream\fP
.IP \(bu 2
\fBsqlite3.h\fP
.IP \(bu 2
\fBstdexcept\fP
.IP \(bu 2
\fBstring\fP
.IP \(bu 2
\fBunistd.h\fP
.IP \(bu 2
\fBvector\fP
.UNINDENT
.SS Included By
.INDENT 0.0
.IP \(bu 2
file_necsim_main.cpp
.IP \(bu 2
file_necsim_ProtractedSpatialTree.h
.IP \(bu 2
file_necsim_ProtractedTree.h
.IP \(bu 2
file_necsim_SpatialTree.cpp
.UNINDENT
.SS Classes
.INDENT 0.0
.IP \(bu 2
class_SpatialTree
.UNINDENT
.SS Defines
.INDENT 0.0
.IP \(bu 2
define_sql_ram
.UNINDENT
.SS File SpeciationCommands.cpp
.sp
Contains the ApplySpec class for performing calculations of the coalescence tree structure and generating the SQL database objects from the command\-line.
.SS Contents
.INDENT 0.0
.IP \(bu 2
\fI\%Definition (necsim/SpeciationCommands.cpp)\fP
.IP \(bu 2
\fI\%Detailed Description\fP
.IP \(bu 2
\fI\%Includes\fP
.UNINDENT
.SS Definition (\fBnecsim/SpeciationCommands.cpp\fP)
.SS Program Listing for File SpeciationCommands.cpp
.INDENT 0.0
.IP \(bu 2
Return to documentation for file_necsim_SpeciationCommands.cpp
.UNINDENT
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
// This file is part of NECSim project which is released under BSD\-3 license.
// See file **LICENSE.txt** or visit https://opensource.org/licenses/BSD\-3\-Clause) for full license details.

#include "SpeciationCommands.h"


void SpeciationCommands::parseArgs()
{
    bool bRunDefault = false;
    bool bInvalidArguments = false;
    bool bAskHelp = false;
    if(argc < 7)
    {
        if(argc == 1)
        {
            bInvalidArguments = true;
        }
        bInvalidArguments = true;
        if(argc == 2)
        {
            if((comargs[1]) == "\-d")
            {
                bInvalidArguments = false;
                bRunDefault = true;
            }
            if(comargs[1] == "\-h" || comargs[1] == "\-help")
            {
                bInvalidArguments = false;
                bAskHelp = true;
            }
        }
        if(bInvalidArguments)
        {
            writeInfo("Incorrect number of arguments.");
            bInvalidArguments = true;
            if(argc == 1)
            {
                comargs.push_back("\-e");
            }
            else
            {
                comargs[1] = "\-e";
            }
        }
    }
    else
    {
        sp.samplemask = comargs[3];
        sp.filename = comargs[1];
        sp.times_file = comargs[4];
    }
    if(argc > 7)
    {
        sp.bMultiRun = true;
        int i = 6;
        while(i < argc)
        {
            sp.all_speciation_rates.push_back(stof(comargs[i]));
            i++;
        }
    }
    else if(argc == 7 && !bInvalidArguments && !bAskHelp)
    {
        sp.bMultiRun = false;
        sp.all_speciation_rates.push_back(stod(comargs[6]));
    }
    if(!bInvalidArguments && !bAskHelp && !bRunDefault)
    {
        if(comargs[2] == "true" || comargs[2] == "True" || comargs[2] == "T" || comargs[2] == "TRUE" ||
           comargs[2] == "t")
        {
            sp.use_spatial = true;
        }
        else
        {
            sp.use_spatial = false;
        }
        if(comargs[5] == "false" || comargs[5] == "False" || comargs[5] == "F" || comargs[5] == "FALSE" ||
           comargs[5] == "f")
        {
            sp.use_fragments = false;
        }
        else
        {
            if(comargs[5] == "true" || comargs[5] == "True" || comargs[5] == "T" || comargs[5] == "TRUE" ||
               comargs[5] == "t")
            {
                sp.fragment_config_file = "null";
            }
            else
            {
                sp.fragment_config_file = comargs[5];
            }
            sp.use_fragments = true;
        }
    }
    if(bInvalidArguments || bAskHelp)
    {
        stringstream os;
        os << "At least six command\-line arguments are expected." << endl;
        os << "1 \- Path to SQL database file." << endl;
        os << "2 \- T/F of whether to record full spatial data." << endl;
        os << "3 \- the sample mask to use (use null if no mask is to be used)" << endl;
        os << "4 \- the file containing tempororal points of interest. If null, the present is used for all "
              "calculations."
           << endl;
        os << "5 \- T/F of whether to calculate abundances for each rectangular fragment. Alternatively, provide a "
              "csv file with fragment data to be read."
           << endl;
        os << "6 \- Speciation rate." << endl;
        os << "7 \- onwards \- Further speciation rates. [OPTIONAL]" << endl;
        os << "Would you like to run with the default paramenters?" << endl;
        os << "       (This requires a SQL database file at ../../Data/Coal_sim/Test_output/SQL_data/data_0_1.db)"
           << endl;
        os << "Enter Y/N: " << flush;
        writeInfo(os.str());
        string sDef;
        cin >> sDef;
        if(sDef == "Y" || sDef == "y")
        {
            bRunDefault = true;
        }
        else
        {
            bRunDefault = false;
            throw FatalException("Nothing to do!");
        }
    }
    if(comargs[1] == "\-d" || bRunDefault)
    {
        sp.filename = "../../Data/Coal_sim/Test_output/SQL_data/data_0_1.db";
        sp.all_speciation_rates.push_back(0.001);
        sp.samplemask = "null";
        sp.times_file = "null";
        sp.fragment_config_file = "null";
        sp.use_fragments = false;
        sp.use_spatial = true;
    }
}


int SpeciationCommands::applyFromComargs(int argc_in, char** argv)
{
    argc = argc_in;
    importArgs(static_cast<const unsigned int &>(argc), argv, comargs);
    parseArgs();
    Community tree_list;
    tree_list.apply(&sp);
    return 0;
}
.ft P
.fi
.UNINDENT
.UNINDENT
.SS Detailed Description
.sp
Samuel Thompson
19/07/2017
BSD\-3 Licence. For use on the SQL database outputs of NECSim v3.1+. It requires command line parameters and generates a data object from them. Contact: \fI\%samuel.thompson14@imperial.ac.uk\fP or \fI\%thompsonsed@gmail.com\fP
.SS Includes
.INDENT 0.0
.IP \(bu 2
\fBSpeciationCommands.h\fP (file_necsim_SpeciationCommands.h)
.UNINDENT
.SS File SpeciationCommands.h
.sp
Contains the class_SpeciationCommands class for performing calculations of the coalescence tree structure and generating the SQL database objects.
.SS Contents
.INDENT 0.0
.IP \(bu 2
\fI\%Definition (necsim/SpeciationCommands.h)\fP
.IP \(bu 2
\fI\%Detailed Description\fP
.IP \(bu 2
\fI\%Includes\fP
.IP \(bu 2
\fI\%Included By\fP
.IP \(bu 2
\fI\%Classes\fP
.UNINDENT
.SS Definition (\fBnecsim/SpeciationCommands.h\fP)
.SS Program Listing for File SpeciationCommands.h
.INDENT 0.0
.IP \(bu 2
Return to documentation for file_necsim_SpeciationCommands.h
.UNINDENT
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
//This file is part of NECSim project which is released under BSD\-3 license.
//See file **LICENSE.txt** or visit https://opensource.org/licenses/BSD\-3\-Clause) for full license details.

#include <cstdio>

#include "Community.h"
#include "TreeNode.h"
#include "SpecSimParameters.h"

class SpeciationCommands
{
private:
    // Contains all speciation parameters
    SpecSimParameters sp;
    // Set up for the output coalescence tree
    Row<TreeNode> data;
    // Command\-line arguments for parsing
    vector<string> comargs;
    // number of command\-line arguments
    int argc;


public:

    SpeciationCommands()
    {

    }

    void parseArgs();

    int applyFromComargs(int argc_in, char ** argv);

};
.ft P
.fi
.UNINDENT
.UNINDENT
.SS Detailed Description
.sp
Samuel Thompson
19/07/2017
BSD\-3 Licence. For use on the SQL database outputs of NECSim v3.1+. It requires command line parameters and generates a data object from them. Contact: \fI\%samuel.thompson14@imperial.ac.uk\fP or \fI\%thompsonsed@gmail.com\fP
.SS Includes
.INDENT 0.0
.IP \(bu 2
\fBCommunity.h\fP (file_necsim_Community.h)
.IP \(bu 2
\fBSpecSimParameters.h\fP (file_necsim_SpecSimParameters.h)
.IP \(bu 2
\fBTreeNode.h\fP (file_necsim_TreeNode.h)
.IP \(bu 2
\fBcstdio\fP
.UNINDENT
.SS Included By
.INDENT 0.0
.IP \(bu 2
file_necsim_SpeciationCommands.cpp
.UNINDENT
.SS Classes
.INDENT 0.0
.IP \(bu 2
class_SpeciationCommands
.UNINDENT
.SS File SpeciationCounter.cpp
.sp
Performs calculations of the coalescence tree structure and generates the SQL database objects.
.SS Contents
.INDENT 0.0
.IP \(bu 2
\fI\%Definition (SpeciationCounter.cpp)\fP
.IP \(bu 2
\fI\%Detailed Description\fP
.IP \(bu 2
\fI\%Includes\fP
.IP \(bu 2
\fI\%Functions\fP
.UNINDENT
.SS Definition (\fBSpeciationCounter.cpp\fP)
.SS Program Listing for File SpeciationCounter.cpp
.INDENT 0.0
.IP \(bu 2
Return to documentation for file_SpeciationCounter.cpp
.UNINDENT
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
//This file is part of NECSim project which is released under BSD\-3 license.
//See file **LICENSE.txt** or visit https://opensource.org/licenses/BSD\-3\-Clause) for full license details.

#include "necsim/SpeciationCommands.h"

using namespace std;
// INPUTS
// requires a SQL database file containing the the TreeNode objects from a coalescence simulations.
// the required speciation rate.

// OUTPUTS
// An updated database file that contains the species richness and species abundances of the intended lineage.





int main(int argc, char **argv)
{
    SpeciationCommands app_s;
    app_s.applyFromComargs(argc, argv);
}
.ft P
.fi
.UNINDENT
.UNINDENT
.SS Detailed Description
.sp
Samuel Thompson
31/08/16
BSD\-3 Licence. Requires command line parameters and generates a data object from them. Contact: \fI\%samuel.thompson14@imperial.ac.uk\fP or \fI\%thompsonsed@gmail.com\fP
.SS Includes
.INDENT 0.0
.IP \(bu 2
\fB/Users/samthompson/Documents/PhD/Code/pycoalescence/pycoalescence/lib/necsim/Community.h\fP
.IP \(bu 2
\fB/Users/samthompson/Documents/PhD/Code/pycoalescence/pycoalescence/lib/necsim/SpecSimParameters.h\fP
.IP \(bu 2
\fB/Users/samthompson/Documents/PhD/Code/pycoalescence/pycoalescence/lib/necsim/TreeNode.h\fP
.IP \(bu 2
\fBcstdio\fP
.IP \(bu 2
\fBnecsim/SpeciationCommands.h\fP (file_necsim_SpeciationCommands.h)
.UNINDENT
.SS Functions
.INDENT 0.0
.IP \(bu 2
function_main
.UNINDENT
.SS File SpeciesList.cpp
.SS Contents
.INDENT 0.0
.IP \(bu 2
\fI\%Definition (necsim/SpeciesList.cpp)\fP
.IP \(bu 2
\fI\%Includes\fP
.IP \(bu 2
\fI\%Functions\fP
.UNINDENT
.SS Definition (\fBnecsim/SpeciesList.cpp\fP)
.SS Program Listing for File SpeciesList.cpp
.INDENT 0.0
.IP \(bu 2
Return to documentation for file_necsim_SpeciesList.cpp
.UNINDENT
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
//This file is part of NECSim project which is released under BSD\-3 license.
//See file **LICENSE.txt** or visit https://opensource.org/licenses/BSD\-3\-Clause) for full license details.

#include <iostream>
#include "SpeciesList.h"


SpeciesList::SpeciesList() : list_size(0), maxsize(0), next_active(0), nwrap(0)
{
    list.setSize(0);
}

void SpeciesList::fillList()
{
    if(maxsize!=0)
    {
        for(unsigned int i = 0; i < maxsize; i++)
        {
            list[i] = 0;
        }
    }
}

void SpeciesList::initialise(unsigned long maxsizein)
{
    maxsize = maxsizein;
    nwrap = 0;
    list_size = 0;
    list.setSize(maxsize);
}

void SpeciesList::setMaxsize(unsigned long maxsizein)
{
    maxsize = maxsizein;
}

void SpeciesList::setSpecies(unsigned long index, unsigned long new_val)
{
    if(list[index] == 0)
    {
        cerr << "index: " << index << endl;
        cerr << "list[index]: " <<list[index] << endl;
        cerr << "list.maxsize(): " << maxsize << endl;
        throw runtime_error("ERROR_MOVE_027: List position to be replaced is zero. Check list assignment.");
    }
    list[index] = new_val;
}

void SpeciesList::setSpeciesEmpty(int index, unsigned long new_val)
{
    if(list[index] != 0)
    {
        cerr << "index: " << index << endl;
        cerr << "list[index]: " <<list[index] << endl;
        cerr << "list.maxsize(): " << maxsize << endl;
        throw runtime_error("ERROR_MOVE_027b: List position to be replaced is not zero. Check list assignment.");
    }
    list[index] = new_val;
}

void SpeciesList::setNext(unsigned long n)
{
    next_active = n;
}

void SpeciesList::setNwrap(unsigned long nr)
{
    nwrap = nr;
}

unsigned long SpeciesList::addSpecies(unsigned long new_spec)
{
#ifdef DEBUG
    if(list_size + 1 > maxsize)
    {
        cerr << "maxsize: " << maxsize << endl;
        throw out_of_range("Could not add species \- no empty space");
    }
#endif
    // First loop from the list size value
    for(unsigned long i = list_size; i<list.size(); i++)
    {
        if(list[i] == 0)
        {
            list_size++;
            list[i] = new_spec;
            return i;
        }
    }
    // Now loop over the rest of the lineages
    for(unsigned long i = 0; i < list_size; i ++)
    {
        if(list[i] == 0)
        {
            list_size++;
            list[i] = new_spec;
            return i;
        }
    }
    cerr << "maxsize: " << maxsize << endl;
    throw out_of_range("Could not add species \- no empty space");
}

void SpeciesList::addSpeciesSilent(unsigned long new_spec)
{
    for(unsigned long i =0;i<maxsize;i++)
    {
        if(list[i] == 0)
        {
            list_size++;
            list[i] = new_spec;
            return;
        }

    }
    throw out_of_range("Could not add species \- no empty space");
}

void SpeciesList::deleteSpecies(unsigned long index)
{
    list[index] = 0;
    list_size \-\-;
}

void SpeciesList::decreaseNwrap()
{
    if(nwrap == 0)
    {
        throw runtime_error("Nwrap should never be decreased less than 0");
    }
    else if(nwrap == 1)
    {
        if( next_active != 0)
        {
            throw runtime_error("Nwrap is being set at 0 when an wrapped lineage is still present");
        }
    }
    nwrap \-\-;
}

void SpeciesList::increaseListSize()
{
    list_size ++;
}

void SpeciesList::increaseNwrap()
{
    nwrap ++;
}

void SpeciesList::changePercentCover(unsigned long newmaxsize)
{
    Row<unsigned long> templist(list);
    maxsize = newmaxsize;
    list.setSize(newmaxsize);
    for(unsigned int i=0;i<newmaxsize;i++)
    {
        if(i<templist.size())
        {
            list[i] = templist[i];
        }
        else
        {
            list[i] = 0;
        }
    }
#ifdef DEBUG
    if(list.size() > maxsize)
        {
            cerr << "list.size(): " << list.size() << endl;
            cerr << "maxsize: " << maxsize << endl;
            throw out_of_range("List size not equal to maxsize");
        }
#endif
}

unsigned long SpeciesList::getRandLineage(NRrand &rand_no)
{
    double rand_index;
    if(maxsize <= list_size)
    {
        // Then the list size is larger than the actual size. This means we must return a lineage.
        try
        {
            do
            {
                rand_index = rand_no.d01();
                rand_index *= list.size();
                //os << "ref: " << rand_index << ", " << list[round(rand_index)] << endl;
            } while(list[floor(rand_index)] == 0);
            //os << "RETURNING!" << endl;
            return(list[floor(rand_index)]);
        }
        catch(out_of_range &oor)
        {
            cerr << oor.what() << endl;
            throw runtime_error("ERROR_MOVE_001b: Listpos outside maxsize.");
        }
    }
    else
    {
        rand_index =  rand_no.d01();
//      os << "rand_index: " << rand_index << endl;
        rand_index  *= maxsize;
        // Dynamically resize the list if required. Otherwise, to save memory, the list will not be resized;
        if(rand_index>=list.size())
        {
            changePercentCover(maxsize);
        }

        unsigned long i = static_cast<unsigned long>(floor(rand_index));

#ifdef DEBUG
        if(rand_index>maxsize)
            {
                stringstream ss;
                ss << "Random index is greater than the max size. Fatal error, please report this bug." << endl;
                throw runtime_error(ss.str());
            }
#endif // DEBUG
        return list[i];
    }
}

unsigned long SpeciesList::getSpecies(unsigned long index)
{
    return list[index];
}

unsigned long SpeciesList::getNext()
{
    return next_active;
}

unsigned long SpeciesList::getNwrap()
{
    return nwrap;
}

unsigned long SpeciesList::getListsize()
{
    return list_size;
}

unsigned long SpeciesList::getMaxsize()
{
    return maxsize;
}

void SpeciesList::wipeList()
{
    fillList();
    next_active=0;
    nwrap =0;
    list_size=0;
}

ostream &operator<<(ostream &os, const SpeciesList &r)
{
    //os << m.numRows<<" , "<<m.numCols<<" , "<<endl;
    os << r.list << ",";
    os << r.list_size << ",";
    os << r.maxsize << ",";
    os << r.next_active << ",";
    os << r.nwrap << ",";
    return os;
}

istream &operator>>(istream &is, SpeciesList &r)
{
    char delim;
    //double temp1,temp2;
    //is << m.numRows<<" , "<<m.numCols<<" , "<<endl;
    is >> r.list;
    is >> delim;
    is >> r.list_size;
    is >> delim;
    is >> r.maxsize;
    is >> delim;
    is >> r.next_active;
    is >> delim;
    is >> r.nwrap;
    is >> delim;
    return is;
}
.ft P
.fi
.UNINDENT
.UNINDENT
.SS Includes
.INDENT 0.0
.IP \(bu 2
\fBSpeciesList.h\fP (file_necsim_SpeciesList.h)
.IP \(bu 2
\fBiostream\fP
.UNINDENT
.SS Functions
.INDENT 0.0
.IP \(bu 2
function_operator_LT__LT
.IP \(bu 2
function_operator_GT__GT
.UNINDENT
.SS File SpeciesList.h
.sp
Contains the class_SpeciesList class for usage in coalescence simulations.
.SS Contents
.INDENT 0.0
.IP \(bu 2
\fI\%Definition (necsim/SpeciesList.h)\fP
.IP \(bu 2
\fI\%Detailed Description\fP
.IP \(bu 2
\fI\%Includes\fP
.IP \(bu 2
\fI\%Included By\fP
.IP \(bu 2
\fI\%Classes\fP
.UNINDENT
.SS Definition (\fBnecsim/SpeciesList.h\fP)
.SS Program Listing for File SpeciesList.h
.INDENT 0.0
.IP \(bu 2
Return to documentation for file_necsim_SpeciesList.h
.UNINDENT
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
//This file is part of NECSim project which is released under BSD\-3 license.
//See file **LICENSE.txt** or visit https://opensource.org/licenses/BSD\-3\-Clause) for full license details.

 #ifndef SPECIESLIST
 #define SPECIESLIST


using namespace std;
#include "Matrix.h"
#include "NRrand.h"

class SpeciesList
{
private:
    unsigned long list_size,maxsize; // List size and maximum size of the cell (based on percentage cover).
    unsigned long next_active; // For calculating the wrapping, using the next and last system.
    Row<unsigned long> list; // list of the active reference number, with zeros for empty cells.
    unsigned long nwrap; // The number of wrapping (next and last possibilities) that there are.
public:
    SpeciesList();

    ~SpeciesList() = default;
    // Sets the list size to the required length.
    // Note this will delete any species currently stored in the list

    // Fill the list with empty 0s.
    void fillList();

    // Standard setters
    void initialise(unsigned long maxsizein);

    // special case if just the maxsize wants to be change, but want to maintain the list variables.
    void setMaxsize(unsigned long maxsizein);

    void setSpecies(unsigned long index, unsigned long new_val);

    void setSpeciesEmpty(int index, unsigned long new_val);

    void setNext(unsigned long n);


    void setNwrap(unsigned long nr);

    unsigned long addSpecies(unsigned long new_spec);

    void addSpeciesSilent(unsigned long new_spec);

    void deleteSpecies(unsigned long index);

    void decreaseNwrap();
    void increaseListSize();

    void increaseNwrap();

    void changePercentCover(unsigned long newmaxsize);

    unsigned long getRandLineage(NRrand &rand_no);

    unsigned long getSpecies(unsigned long index);

    unsigned long getNext();

    unsigned long getNwrap();

    unsigned long getListsize();

    unsigned long getMaxsize();

    void wipeList();

    friend ostream& operator<<(ostream& os,const SpeciesList& r);

    friend istream& operator>>(istream& is, SpeciesList& r);
};

#endif
.ft P
.fi
.UNINDENT
.UNINDENT
.SS Detailed Description
.sp
Samuel Thompson
BSD\-3 Licence.
.SS Includes
.INDENT 0.0
.IP \(bu 2
\fBMatrix.h\fP (file_necsim_Matrix.h)
.IP \(bu 2
\fBNRrand.h\fP (file_necsim_NRrand.h)
.UNINDENT
.SS Included By
.INDENT 0.0
.IP \(bu 2
file_necsim_SpatialTree.h
.IP \(bu 2
file_necsim_SpeciesList.cpp
.UNINDENT
.SS Classes
.INDENT 0.0
.IP \(bu 2
class_SpeciesList
.UNINDENT
.SS File SpecSimParameters.h
.sp
Contains parameters for applying speciation rates post\-simulation.
.SS Contents
.INDENT 0.0
.IP \(bu 2
\fI\%Definition (necsim/SpecSimParameters.h)\fP
.IP \(bu 2
\fI\%Detailed Description\fP
.IP \(bu 2
\fI\%Included By\fP
.IP \(bu 2
\fI\%Classes\fP
.UNINDENT
.SS Definition (\fBnecsim/SpecSimParameters.h\fP)
.SS Program Listing for File SpecSimParameters.h
.INDENT 0.0
.IP \(bu 2
Return to documentation for file_necsim_SpecSimParameters.h
.UNINDENT
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
//This file is part of NECSim project which is released under BSD\-3 license.
//See file **LICENSE.txt** or visit https://opensource.org/licenses/BSD\-3\-Clause) for full license details.

#ifndef SPECIATIONCOUNTER_SPECSIMPARAMETERS_H
#define SPECIATIONCOUNTER_SPECSIMPARAMETERS_H


struct SpecSimParameters
{
    bool use_spatial;
    bool bMultiRun;
    bool use_fragments;
    string filename;
    vector<double> all_speciation_rates;
    string samplemask;
    string times_file;
    vector<double> all_times;
    string fragment_config_file;
    double min_speciation_gen, max_speciation_gen;
    unsigned long metacommunity_size;
    double metacommunity_speciation_rate;

    void setup(string file_in, bool use_spatial_in, string sample_file, string time_config, string use_fragments_in,
               vector<double> speciation_rates, double min_speciation_gen_in, double max_speciation_gen_in)
    {
        setup(file_in, use_spatial_in, sample_file, time_config, use_fragments_in, speciation_rates,
              min_speciation_gen_in, max_speciation_gen_in, 0, 0.0);
    }

    void setup(string file_in, bool use_spatial_in, string sample_file, string time_config, string use_fragments_in,
               vector<double> speciation_rates, double min_speciation_gen_in, double max_speciation_gen_in,
               unsigned long metacommunity_size_in, double metacommunity_speciation_rate_in)
    {
        filename = std::move(file_in);
        use_spatial = use_spatial_in;
        samplemask = std::move(sample_file);
        times_file = std::move(time_config);
        min_speciation_gen = std::move(min_speciation_gen_in);
        max_speciation_gen = std::move(max_speciation_gen_in);
        importTimeConfig();
        use_fragments = !(use_fragments_in == "F");
        fragment_config_file = use_fragments_in;
        bMultiRun = speciation_rates.size() > 1;
        for(double speciation_rate : speciation_rates)
        {
            all_speciation_rates.push_back(speciation_rate);
        }
        metacommunity_size = metacommunity_size_in;
        metacommunity_speciation_rate = metacommunity_speciation_rate_in;
    }

    void importTimeConfig()
    {
        if(times_file == "null")
        {
            all_times.push_back(0.0);
        }
        else
        {
            vector<string> tmpimport;
            ConfigOption tmpconfig;
            tmpconfig.setConfig(times_file, false);
            tmpconfig.importConfig(tmpimport);
            for(unsigned int i = 0; i < tmpimport.size(); i++)
            {
                all_times.push_back(stod(tmpimport[i]));
                //                  os << "t_i: " << sp.reference_times[i] << endl;
            }
        }
    }
};


#endif //SPECIATIONCOUNTER_SPECSIMPARAMETERS_H
.ft P
.fi
.UNINDENT
.UNINDENT
.SS Detailed Description
.sp
Sam Thompson
Contact: \fI\%samuel.thompson14@imperial.ac.uk\fP or \fI\%thompsonsed@gmail.com\fP BSD\-3 Licence.
.SS Included By
.INDENT 0.0
.IP \(bu 2
file_necsim_Community.h
.IP \(bu 2
file_necsim_Metacommunity.h
.IP \(bu 2
file_necsim_SpeciationCommands.h
.UNINDENT
.SS Classes
.INDENT 0.0
.IP \(bu 2
class_SpecSimParameters
.UNINDENT
.SS File Step.h
.sp
Contains the class_Step class for storing required data during a single step of a coalescence simulation.
.SS Contents
.INDENT 0.0
.IP \(bu 2
\fI\%Definition (necsim/Step.h)\fP
.IP \(bu 2
\fI\%Detailed Description\fP
.IP \(bu 2
\fI\%Included By\fP
.IP \(bu 2
\fI\%Classes\fP
.UNINDENT
.SS Definition (\fBnecsim/Step.h\fP)
.SS Program Listing for File Step.h
.INDENT 0.0
.IP \(bu 2
Return to documentation for file_necsim_Step.h
.UNINDENT
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
//This file is part of NECSim project which is released under BSD\-3 license.
//See file **LICENSE.txt** or visit https://opensource.org/licenses/BSD\-3\-Clause) for full license details.

#ifndef STEP_H
#define STEP_H

struct Step
{
    unsigned long chosen, coalchosen;
    long oldx, oldy, oldxwrap, oldywrap;
    bool coal, bContinueSim;
    unsigned int time_reference;
    double distance;
    double angle;
#ifdef verbose
    long number_printed;
#endif

    Step()
    {
        chosen = 0;
        coalchosen = 0;
        oldx = 0;
        oldy = 0;
        oldxwrap = 0;
        oldywrap = 0;
        coal = false;
        bContinueSim = true;
        time_reference = 0;
        distance = 0.0;
        angle = 0.0;
#ifdef verbose
        number_printed =0;
#endif
    }


    void wipeData()
    {
        chosen = 0;
        coalchosen = 0;
        oldx = 0;
        oldy = 0;
        oldxwrap = 0;
        oldywrap = 0;
        coal = false;
        distance = 0.0;
        angle = 0.0;
    }


};

#endif
.ft P
.fi
.UNINDENT
.UNINDENT
.SS Detailed Description
.sp
Sam Thompson
09/08/2017
BSD\-3 Licence.
.SS Included By
.INDENT 0.0
.IP \(bu 2
file_necsim_DispersalCoordinator.h
.IP \(bu 2
file_necsim_Tree.h
.UNINDENT
.SS Classes
.INDENT 0.0
.IP \(bu 2
class_Step
.UNINDENT
.SS File Tree.cpp
.sp
Contains the class_Tree class implementation as the main simulation object for spatially\-implicit coalescence simulations. Provides the basis for spatially\-explicit versions in class_SpatialTree, and protracted speciation versions in class_ProtractedTree and class_ProtractedSpatialTree\&.
.SS Contents
.INDENT 0.0
.IP \(bu 2
\fI\%Definition (necsim/Tree.cpp)\fP
.IP \(bu 2
\fI\%Detailed Description\fP
.IP \(bu 2
\fI\%Includes\fP
.UNINDENT
.SS Definition (\fBnecsim/Tree.cpp\fP)
.SS Program Listing for File Tree.cpp
.INDENT 0.0
.IP \(bu 2
Return to documentation for file_necsim_Tree.cpp
.UNINDENT
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
// This file is part of NECSim project which is released under BSD\-3 license.
// See file **LICENSE.txt** or visit https://opensource.org/licenses/BSD\-3\-Clause) for full license details.

#include "Tree.h"
void Tree::importSimulationVariables(const string &configfile)
{
    sim_parameters.importParameters(configfile);
    checkOutputDirectory();
    // Now check for paused simulations
    checkSims();
}

void Tree::internalSetup(const SimParameters &sim_parameters_in)
{
    sim_parameters = sim_parameters_in;
    setup();
}

bool Tree::checkOutputDirectory()
{
    if(sim_parameters.output_directory != "null")
    {
        try
        {
            doesExist(sim_parameters.output_directory);
        }
        catch(runtime_error &re)
        {
            cerr << "Output folder does not exist... creating..." << flush;
            bool bOutputFolder = boost::filesystem::create_directory(sim_parameters.output_directory);
            if( bOutputFolder)
            {
                cerr << "done!" << endl;
            }
            else
            {
                cerr << endl << re.what() << endl;
            }
        }
    }
    else
    {
        throw FatalException("ERROR_MAIN_009: FATAL. Output folder cannot be null.");
    }
    return true;
}


void Tree::checkSims()
{
    checkSims(sim_parameters.output_directory, sim_parameters.the_seed, sim_parameters.the_task);
}

void Tree::checkSims(string output_dir, long seed_in, long task_in)
{

    stringstream os;
    os << "Checking for unfinished simulations..." << flush;
    ifstream out;
    string file_to_open;
//  char file_to_open[100];
//  sprintf (file_to_open, "%s/Pause/Data_%i.csv",outdirect,int(the_task));
    file_to_open = output_dir + string("/Pause/Dump_active_") + to_string((unsigned long long)task_in)+"_"+to_string((unsigned long long)seed_in) + string(".csv");
    out.open(file_to_open);
    if(out.good())
    {
        os << "done!" << endl << "File found containing unfinished simulations." << endl;
        writeInfo(os.str());
        if(!has_imported_pause)
        {
            setResumeParameters(sim_parameters.output_directory, sim_parameters.output_directory, sim_parameters.the_seed,
                                sim_parameters.the_task, sim_parameters.max_time);
        }
        has_paused = true;
    }
    else
    {
        os << "done!" << endl << "No files found containing unfinished simulations." << endl;
        writeInfo(os.str());
        has_paused = false;
    }
}

void Tree::setParameters()
{
    if(!has_imported_vars)
    {
        out_directory = sim_parameters.output_directory;

        the_task = sim_parameters.the_task;
        the_seed = sim_parameters.the_seed;

        deme = sim_parameters.deme;
        deme_sample = sim_parameters.deme_sample;
        spec = sim_parameters.spec;
        maxtime = sim_parameters.max_time;
        times_file = sim_parameters.times_file;
        setProtractedVariables(sim_parameters.min_speciation_gen, sim_parameters.max_speciation_gen);
        has_imported_vars = true;
    }
    else
    {
        throw FatalException("ERROR_MAIN_001: Variables already imported.");
    }
}

void Tree::setProtractedVariables(double speciation_gen_min, double speciation_gen_max)
{
}


bool Tree::hasPaused()
{
    return has_paused;
}

vector<double> Tree::getTemporalSampling()
{
    if(has_times_file)
    {
        return reference_times;
    }
    else
    {
        vector<double> tmp;
        tmp.push_back(0.0);
        return tmp;
    }
}
long long Tree::getSeed()
{
    return the_seed;
}

void Tree::setSeed(long long seed_in)
{
    if(!seeded)
    {
        NR.setSeed(seed_in);
        the_seed = seed_in;
        seeded = true;
    }
}

unsigned long Tree::getInitialCount()
{
    return static_cast<unsigned long>(floor(deme * deme_sample));
}


unsigned long Tree::setObjectSizes()
{
    unsigned long initial_count = getInitialCount();
    active.setSize(initial_count + 1);
    data.setSize(2 * initial_count + 1);
    return initial_count;
}

void Tree::setup()
{
    printSetup();
    if(has_imported_pause)
    {
        setResumeParameters();
        simResume();
    }
    else
    {
        // Start the timer
        time(&start);
        setParameters();
        setInitialValues();
        generateObjects();
    }
}

void Tree::setInitialValues()
{
    // other variables
    steps = 0;
    generation = 0;
    // Set the seed
    setSeed(the_seed);
    sim_parameters.printVars();
    // Determine the speciation rates which will be applied after the simulation completes.
    determineSpeciationRates();
    setTimes();
}

void Tree::setSimStartVariables()
{
    this_step.bContinueSim = true;
    this_step.time_reference = 0;
    if(has_times_file && generation > 0.0)
    {
        for(unsigned int i = 0; i < reference_times.size(); i++)
        {
            if(reference_times[i] > generation)
            {
                this_step.time_reference = i + 1;
                break;
            }
        }
    }
}

void Tree::printSetup()
{
    stringstream os;
    os << "*************************************************" << endl;
    os << "Setting up simulation..." << endl;
    writeInfo(os.str());
    os.str("");
    time(&start);
}

void Tree::setTimes()
{
    if(times_file != "null" && !has_times_file)
    {
        // Import the time sample points
        has_times_file = true;
        vector<string> tmpimport;
        ConfigOption tmpconfig;
        tmpconfig.setConfig(times_file, false);
        tmpconfig.importConfig(tmpimport);
        for(const auto &i : tmpimport)
        {
            reference_times.push_back(stod(i));
        }
    }
}

void Tree::determineSpeciationRates()
{
    if(bConfig)
    {
        if(sim_parameters.configs.hasSection("spec_rates"))
        {
            vector<string> spec_rates = sim_parameters.configs.getSectionValues("spec_rates");
            for(const auto &spec_rate : spec_rates)
            {
                speciation_rates.push_back(stod(spec_rate));
            }
        }
    }
    else
    {
        speciation_rates.push_back(spec);
    }
    sort(speciation_rates.begin(), speciation_rates.end());
}

void Tree::generateObjects()
{
    unsigned long initial_count = setObjectSizes();
    endactive = 0;
    unsigned long number_start = fillObjects(initial_count);
    stringstream os;
    os << "\erSetting up simulation...done!                           " << endl;
    os << "Number of individuals simulating: " << endactive << endl;
    writeInfo(os.str());
    maxsimsize = enddata;
    if(active.size() < endactive || endactive == 0)
    {
        cerr << "endactive: " << endactive << endl;
        cerr << "active.size: " << active.size() << endl;
        cerr << "initial_count: " << initial_count << endl;
        cerr << "number_start: " << number_start << endl;
        if(endactive == 0)
        {
            throw runtime_error("No individuals to simulate! Check set up. Exiting...");
        }
        else
        {
            throw FatalException(
                    "ERROR_MAIN_007: FATAL. Sizing error \- endactive is greater than the size of active. "
                            "Please report this bug");
        }
    }
    startendactive = endactive;
}

unsigned long Tree::fillObjects(const unsigned long &initial_count)
{
    active[0].setup(0, 0, 0, 0, 0, 0, 0);
    unsigned long number_start = 0;
    stringstream os;
    os << "\erSetting up simulation...filling grid                           " << flush;
    writeInfo(os.str());
    // This loop adds individuals to data and active (for storing the coalescence tree and active lineage tracking)
    double sample_number = floor(deme_sample * deme);
    for(unsigned long i = 0; i < sample_number; i++)
    {
        number_start++;
        // Add the species to active
        active[number_start].setup(number_start, i, 1);
        // Add a tip in the TreeNode for calculation of the coalescence tree at the
        // end of the simulation.
        // This also contains the start x and y position of the species.
        data[number_start].setup(true);
        data[number_start].setSpec(NR.d01());
        endactive++;
        enddata++;
    }
    if(number_start == initial_count)  // Check that the two counting methods match up.
    {
    }
    else
    {
        if(initial_count > 1.1 * number_start)
        {
            writeWarning("Data usage higher than neccessary \- check allocation of individuals to the grid.");
            stringstream ss;
            ss << "Initial count: " << initial_count << "  Number counted: " << number_start << endl;
            writeWarning(ss.str());
        }
    }
#ifdef DEBUG
    validateLineages();
#endif
    return number_start;
}


bool Tree::runSimulation()
{

    writeSimStartToConsole();
    // Main while loop to process while there is still time left and the simulation is not complete.
    // Ensure that the step object contains no data.
    this_step.wipeData();
    setSimStartVariables();
    if(endactive < 2)
    {
        return stopSimulation();
    }
    // Create the move object
    do
    {
        chooseRandomLineage();
        writeStepToConsole();
        // See estSpecnum for removed code.
        // Check that we still want to continue the simulation.
        if(this_step.bContinueSim)
        {
            // increase the counter of the number of moves (or generations) the lineage has undergone.
            data[active[this_step.chosen].getReference()].increaseGen();
            // Check if speciation happens
            if(calcSpeciation(data[active[this_step.chosen].getReference()].getSpecRate(), 0.99999*spec,
                               data[active[this_step.chosen].getReference()].getGenRate()))
            {
                speciation(this_step.chosen);
            }
            else
            {
                // remove the species data from the species list to be placed somewhere new.
                removeOldPosition(this_step.chosen);
                calcNextStep();
#ifdef DEBUG
                debugCoalescence();
#endif
                if(this_step.coal)
                {
                    coalescenceEvent(this_step.chosen, this_step.coalchosen);
                }
            }
        }

#ifdef DEBUG
        debugEndStep();
#endif
        if(has_times_file && endactive == 1)
        {
            // Check whether we need to continue simulating at a later time.
            if(reference_times[this_step.time_reference] > generation)
            {
                // Then we need to expand the map
                // This is a hack, I know it\(aqs a hack and is wrong, and I aint gonna change it :)
                data[active[endactive].getReference()].setSpec(0.0);
                // First speciate the remaining lineage
                speciation(endactive);
                generation = reference_times[this_step.time_reference] + 0.000000000001;
                checkTimeUpdate();
                if(endactive < 2)
                {
                    break;
                }
            }
            // TODO fix this to account for potential speciation of the remaining lineage!
        }
    }
    while((endactive > 1) && (steps < 100 || difftime(sim_end, start) < maxtime) && this_step.bContinueSim);
// If the simulations finish correctly, output the completed data.
// Otherwise, pause the simulation and save objects to file.
    return stopSimulation();
}

bool Tree::stopSimulation()
{
    if(endactive > 1)
    {
        stringstream os;
        time(&sim_finish);
        time_taken += sim_finish \- start;
        os.str("");
        os << "........out of time!" << endl;
        os << "Pausing simulation: add extra time or re\-run to ensure simulation completion."
           << "\en";
        os << "Lineages remaining: " << endactive << "\en";
        writeInfo(os.str());
        simPause();
        return false;
    }
    else
    {
        for(unsigned int i = 0; i <= endactive; i++)
        {
            speciateLineage(active[i].getReference());
            data[active[i].getReference()].setSpec(0.0);
        }
        sim_complete = true;
        time(&sim_finish);
        time_taken += sim_finish \- start;
        if(!this_step.bContinueSim)
        {
            writeInfo("done \- desired number of species achieved!\en");
            return true;
        }
        else
        {
            writeInfo("done!\en");
            return true;
        }
    }
}

void Tree::writeSimStartToConsole()
{
    // now do the calculations required to build the tree
    stringstream os;
    os << "*************************************************" << endl;
    os << "Beginning simulations..." << flush;
    writeInfo(os.str());
    os.str("");

    //      double current_gen =0;
    // check time
    time(&sim_start);
    time(&sim_end);
    time(&now);
}

void Tree::writeStepToConsole()
{
    if(steps % 10000 == 0)
    {
        time(&sim_end);
#ifdef verbose
        if(sim_end \- now > 0.2)  // output every 0.2 seconds
        {
            double dPercentComplete = 20 * (1 \- (double(endactive) / double(startendactive)));
            time(&now);
            if(this_step.number_printed < dPercentComplete)
            {
                stringstream os;
                os << "\erBeginning simulations...";
                this_step.number_printed = 0;
                while(this_step.number_printed < dPercentComplete)
                {
                    os << ".";

                    this_step.number_printed++;
                }
                os << flush;
                writeInfo(os.str());
            }
        }
#endif // verbose
    }
}

void Tree::incrementGeneration()
{
    steps++;
    // increment generation counter
    generation += 2.0 / (double(endactive));
}

void Tree::chooseRandomLineage()
{
    incrementGeneration();
    // choose a random lineage to die and be reborn out of those currently active
    this_step.chosen = NR.i0(endactive \- 1) + 1;  // cannot be 0
    // Rejection sample based on reproductive potential
    updateStepCoalescenceVariables();
}

void Tree::updateStepCoalescenceVariables()
{
    this_step.coalchosen = 0;
    this_step.coal = false;
}

void Tree::speciation(const unsigned long& chosen)
{
    // alter the data such that it reflects the speciation event.
    unsigned long data_position = active[chosen].getReference();
#ifdef DEBUG
    // Store debug information in DEBUG mode
    if(data[data_position].hasSpeciated())
    {
        stringstream ss;
        ss << "Chosen: " << chosen << endl;
        writeLog(50, ss);
        ss.str("");
        ss << "Endactive: " << endactive << endl;
        writeLog(50, ss);
        data[data_position].logLineageInformation(50);
        active[chosen].logActive(50);
        throw FatalException("ERROR_MOVE_028: Attempting to speciate a speciated species.");
    }
#endif
    speciateLineage(data_position);
    // Now remove the old chosen lineage from the active directory.
    removeOldPosition(chosen);
    switchPositions(chosen);
}

void Tree::speciateLineage(const unsigned long &data_position)
{
    data[data_position].speciate();
}

void Tree::removeOldPosition(const unsigned long &chosen)
{
    // This may seem a bit stupid, but this function is overwridden with more complex routines in child classes.
    active[chosen].setListPosition(0);
}

void Tree::switchPositions(const unsigned long &chosen)
{
#ifdef DEBUG

    if(chosen > endactive)
    {
        stringstream ss;
        ss << "chosen: " << chosen << " endactive: " << endactive << endl;
        writeLog(50, ss);
        throw FatalException("ERROR_MOVE_023: Chosen is greater than endactive. Check move function.");
    }
#endif // DEBUG
    if(chosen != endactive)
    {
        // This routine assumes that the previous chosen position has already been deleted.
        DataPoint tmpdatactive;
        tmpdatactive.setup(active[chosen]);
        // now need to remove the chosen lineage from memory, by replacing it with the lineage that lies in the last
        // place.
        active[chosen].setup(active[endactive]);
        active[endactive].setup(tmpdatactive);
    }
    endactive\-\-;

}

void Tree::calcNextStep()
{
    unsigned long random_lineage = NR.i0(static_cast<unsigned long>(deme)) + 1;
    if(random_lineage != this_step.chosen && random_lineage <= endactive)
    {
        // then we have a coalescence event
        this_step.coal = true;
        this_step.coalchosen = random_lineage;
    }
}

bool Tree::calcSpeciation(const long double &random_number,
                          const long double &speciation_rate,
                          const unsigned long &no_generations)
{
    return checkSpeciation(random_number, speciation_rate, no_generations);
}

void Tree::coalescenceEvent(const unsigned long& chosen, unsigned long& coalchosen)
{
    // coalescence occured, so we need to adjust the data appropriatedly
    // our chosen lineage has merged with the coalchosen lineage, so we need to sync up the data.
    enddata++;
    data[enddata].setup(0, active[chosen].getXpos(), active[chosen].getYpos(), active[chosen].getXwrap(),
                        active[chosen].getYwrap(), generation);

    // First perform the move
    data[active[chosen].getReference()].setParent(enddata);
    data[active[coalchosen].getReference()].setParent(enddata);
    active[coalchosen].setMinmax(
            max(active[coalchosen].getMinmax(),
                active[chosen].getMinmax()));  // set the new minmax to the maximum of the two minimums.
    active[chosen].setMinmax(active[coalchosen].getMinmax());
    data[enddata].setGenerationRate(0);
    data[enddata].setSpec(NR.d01());
    active[chosen].setReference(enddata);
    active[coalchosen].setReference(enddata);
    //      removeOldPosition(chosen);
    switchPositions(chosen);
}


void Tree::checkTimeUpdate()
{
    if(has_times_file && this_step.time_reference < reference_times.size())
    {
        // check if we need to update
        if(reference_times[this_step.time_reference] <= generation)
        {
            //                  os << "check2" << endl;
            if(reference_times[this_step.time_reference] > 0.0)
            {
                stringstream os;
                os << "\en" << "expanding map at generation " << generation << endl;
                addLineages(reference_times[this_step.time_reference]);
                writeInfo(os.str());
            }
            this_step.time_reference++;
        }
    }
}

void Tree::addLineages(double generation_in)
{
    auto added_data = static_cast<unsigned long>(floor(deme_sample * deme));
    unsigned long added_active = added_data \- endactive;
    checkSimSize(added_data, added_active);
    // change those that already exist to tips
    for(unsigned long i = 0; i < endactive; i++)
    {
        makeTip(endactive, generation_in);
    }
    for(unsigned long i = 0; i < added_active; i++)
    {
        enddata ++;
        endactive ++;
        active[endactive].setup(enddata, endactive, 1.0);
        data[enddata].setup(true,0, 0, 0, 0, generation_in);
        data[enddata].setSpec(NR.d01());
    }
    if(endactive != added_data)
    {
        throw FatalException("Error whilst adding lineages. Please report this bug.");
    }
}


void Tree::checkSimSize(unsigned long req_data, unsigned long req_active)
{
    // need to be triple the size of the maximum number of individuals plus enddata
    unsigned long min_data = (3 * req_data) + enddata + 2;
    unsigned long min_active = endactive + req_active + 2;
    if(data.size() <= min_data)
    {
        // change the size of data
        data.resize(min_data);
    }

    if(active.size() <= min_active)
    {
        // change the size of active.
        active.resize(min_active);
    }
}

void Tree::makeTip(const unsigned long &tmp_active, const double &generationin)
{
    unsigned long reference = active[tmp_active].getReference();
    if(data[reference].isTip())
    {
        convertTip(tmp_active, generationin);
    }
    else
    {
        data[active[tmp_active].getReference()].setGeneration(generationin);
        data[active[tmp_active].getReference()].setTip(true);
    }
}

void Tree::convertTip(unsigned long i, double generationin)
{
    enddata++;
    if(enddata >= data.size())
    {
        throw FatalException("Cannot add tip \- no space in data. Check size calculations.");
    }
    data[enddata].setup(true, active[i].getXpos(), active[i].getYpos(),
                        active[i].getXwrap(),
                        active[i].getYwrap(), generationin);
    // Now link the old tip to the new tip
    data[active[i].getReference()].setParent(enddata);
    data[enddata].setGenerationRate(0);
    data[enddata].setSpec(NR.d01());
    active[i].setReference(enddata);
}


void Tree::applySpecRate(long double sr, double t)
{
    setupTreeGeneration(sr, t);
    community.createDatabase();
#ifdef record_space
    community.recordSpatial();
#endif
}

void Tree::applySpecRateInternal(long double sr, double t)
{
    setupTreeGeneration(sr, t);
    community.calcSpecies();
    community.calcSpeciesAbundance();
}

Row<unsigned long> * Tree::getCumulativeAbundances()
{
    return community.getCumulativeAbundances();
}

void Tree::setupTreeGeneration(long double sr, double t)
{
    if(!community.hasImportedData())
    {
        community.setDatabase(database);
    }
    community.resetTree();
    community.internalOption();
    community.overrideProtractedParameters(getProtractedGenerationMin(), getProtractedGenerationMax());
    community.setProtracted(getProtracted());
    community.addCalculationPerformed(sr, t, false, 0, 0.0);
}

void Tree::applySpecRate(long double sr)
{
    applySpecRate(sr, 0.0);
}

void Tree::applyMultipleRates()
{
    stringstream os;
    if(speciation_rates.size() == 0)
    {
        os << "No additional speciation rates to apply." << endl;
    }
    speciation_rates.push_back(spec);
    // Get only unique speciation rates
    vector<long double> unique_speciation_rates;
    for(const double &s : speciation_rates)
    {
        bool add = true;
        for(const double & u : unique_speciation_rates)
        {
            if(doubleCompare(u, s, s*0.00001))
            {
                add = false;
            }
        }
        if(add)
        {
            unique_speciation_rates.push_back(s);
        }
    }
    speciation_rates = unique_speciation_rates;
    os << "Speciation rate" << flush;
    if(speciation_rates.size() > 1)
    {
        os << "s are: " << flush;
    }
    else
    {
        os << " is: " << flush;
    }
    for(unsigned long i = 0; i < speciation_rates.size(); i++)
    {
        os << speciation_rates[i] << flush;
        if(i + 1 == speciation_rates.size())
        {
            os << "." << endl;
        }
        else
        {
            os << ", " << flush;
        }
    }
    writeInfo(os.str());
    // Now check to make sure repeat speciation rates aren\(aqt done twice (this is done to avoid the huge number of errors
    // SQL throws if you try to add identical data
    unsigned long spec_upto = sortData();
    sqlCreate();
    for(const long double &i: speciation_rates)
    {
        vector<double> temp_sampling = getTemporalSampling();
        for(double k : temp_sampling)
        {
            writeInfo(to_string(k) + ",");
        }
        for(double k : temp_sampling)
        {
            writeInfo(string("Calculating generation " + to_string(k) + "\en"));
            if(i > spec)
            {
                applySpecRate(i, k);
            }
            else if(i == spec)
            {
                // Use the run spec if the rates are very close to equal
                applySpecRate(spec, k);
            }
            else
            {
                writeWarning("Speciation rate " + to_string(i) +
                                     " less than simulation minimum (" + to_string(spec) + ")\en");
            }
        }
    }
    community.writeNewCommunityParameters();
    outputData(spec_upto);
}

bool Tree::getProtracted()
{
    return false;
}

string Tree::getProtractedVariables()
{
    stringstream ss;
    ss << "0.0\en0.0\en";
    return ss.str();
}

double Tree::getProtractedGenerationMin()
{
    return 0.0;
}

double Tree::getProtractedGenerationMax()
{
    return 0.0;
}

void Tree::sqlOutput()
{
#ifdef sql_ram
    // open connection to the database file
    remove(sqloutname.c_str());
    stringstream os;
    os << "\er    Writing to " << sqloutname << " ....     " << flush;
    writeInfo(os.str());
    openSQLiteDatabase(sqloutname, outdatabase);
    // create the backup object to write data to the file from memory.
    sqlite3_backup* backupdb;
    backupdb = sqlite3_backup_init(outdatabase, "main", database, "main");
    if(!backupdb)
    {
        cerr << "ERROR_SQL_011: Could not write to the backup database. Check the file exists." << endl;
    }
    // Perform the backup
    int rc = sqlite3_backup_step(backupdb, \-1);
    if(rc != SQLITE_OK && rc != SQLITE_DONE)
    {
        int i = 0;
        while((rc != SQLITE_OK && rc != SQLITE_DONE) && i < 10)
        {
            i++;
            sleep(1);
            rc = sqlite3_backup_step(backupdb, \-1);
            //              cerr << "Attempt " << i << " failed..." << endl;
        }
        if(rc != SQLITE_OK && rc != SQLITE_DONE)
        {
            stringstream ss;
            ss << "ERROR_SQL_010: SQLite database file could not be opened. Check the folder exists and you "
                    "have write permissions. (REF3) Error code: "
                 << rc << endl;
            ss << "Attempted call " << i << " times" << endl;
            writeWarning(ss.str());
        }
    }
    sqlite3_backup_finish(backupdb);
    os.str("");
    os << "\er    Writing to " << sqloutname << " ....  done!              " << endl;
    writeInfo(os.str());
#endif
}

void Tree::outputData()
{
    unsigned long species_richness = sortData();
    sqlCreate();
    outputData(species_richness);
}

void Tree::outputData(unsigned long species_richness)
{
    // Run the data sorting functions and output the data into the correct format.

    time(&out_finish);
#ifdef sql_ram
    sqlOutput();
#endif
    time(&sim_end);
    writeTimes();
}

unsigned long Tree::sortData()
{
    // Sort and process the species list so that the useful information can be extracted from it.
    stringstream os;
    os << "Finalising data..." << flush;
    writeInfo(os.str());
    os.str("");
    // coalescence finished \- process speciation
    // check the data structure
    if(enddata > data.size())
    {
#ifdef DEBUG
        stringstream ss;
        ss << "enddata: " << enddata << endl;
        ss << "data.size(): " << data.size() << endl;
        writeLog(50, ss);
#endif // DEBUG
        throw FatalException("Enddata greater than data size. Programming error likely.");
    }
    // Now make sure those left in endactive will definitely speciate.
    for(unsigned long i = 1; i <= endactive; i++)
    {
        data[active[i].getReference()].setSpec(0.0);
    }
    // Double check speciation events have been counted.
    unsigned long spec_up_to = 0;
    for(unsigned int i = 1; i <= enddata; i++)
    {
        if(calcSpeciation(data[i].getSpecRate(), spec, data[i].getGenRate()))
        {
            spec_up_to++;
            data[i].speciate();
        }
    }
    try
    {
        for(unsigned long i = 1; i <= enddata; i++)
        {
            if((!(data[i].hasSpeciated())) && (data[i].getParent() == 0 && data[i].getExistence()))
            {
                throw FatalException(string("ERROR_MAIN_004: " + to_string((long long)i) +
                                            " has not speciated and parent is 0."));
            }
        }
        // here we check the data is valid \- alternative validity check.
        for(unsigned long i = 1; i <= enddata; i++)
        {
            if(!(data[i].hasSpeciated()) && data[i].getExistence())
            {
                long j = i;
                while(!(data[j].hasSpeciated()))
                {
                    j = data[j].getParent();
                    if(j == 0)
                    {
                        throw FatalException("ERROR_MAIN_005: 0 found in parent while following speciation trail.");
                    }
                }
            }
        }
    }
    catch(FatalException& me)
    {
#ifdef DEBUG
        writeLog(30, me.what());
        writeLog(30, "Returning max possible size (may cause RAM issues).");
#endif // DEBUG
        return data.size();
    }
    writeInfo("done!\en");
    return spec_up_to;
}

void Tree::writeTimes()
{
    stringstream os;
    os << "Total generations simulated (steps): " << generation << " (" << steps << ")" << endl;
#ifdef DEBUG
    stringstream ss;
    ss << "Count dispersal, density fails: " << count_dispersal_fails << ", " << count_density_fails << endl;
    writeLog(10, ss);
#endif
    os << "Setup time was " << floor((sim_start \- start) / 60) << " minutes " << (sim_start \- start) % 60 << " seconds"
       << endl;
    os << "Simulation time was " << floor((sim_finish \- sim_start) / 3600) << " hours "
       << (floor((sim_finish \- sim_start) / 60) \- 60 * floor((sim_finish \- sim_start) / 3600)) << " minutes "
       << (sim_finish \- sim_start) % 60 << " seconds" << endl;
    os << "File output and species calculation time was " << floor((out_finish \- sim_finish) / 60) << " minutes "
       << (out_finish \- sim_finish) % 60 << " seconds" << endl;
    os << "SQL output time was " << floor((sim_end \- out_finish) / 60) << " minutes " << (sim_end \- out_finish) % 60
       << " seconds" << endl;
    time_taken += (sim_end \- out_finish);
    os << "Total time taken was " << floor((time_taken) / 3600) << " hours " << flush;
    os << (floor((time_taken) / 60) \- 60 * floor((time_taken) / 3600)) << flush;
    os << " minutes " << (time_taken) % 60 << " seconds" << endl;
    writeInfo(os.str());
}


void Tree::sqlCreate()
{
    time(&out_finish);
    stringstream os;
    os << "Creating SQL database file..." << endl;
    os << "    Checking for existing folders...." << flush;
    writeInfo(os.str());
    os.str("");
    // Create the folder if it doesn\(aqt exist
    sqloutname = out_directory;
    string sqlfolder = out_directory + "/SQL_data/";
    try
    {
        createParent(sqlfolder);
        sqloutname += string("/SQL_data/data_") + to_string(the_task) + "_" + to_string(the_seed) + ".db";
    }
    catch(FatalException &fe)
    {
        writeWarning(fe.what());
        sqloutname = string("data_") + to_string(the_task) + "_" + to_string(the_seed) + ".db";
    }
    remove(sqloutname.c_str());
    os.str("");
    os << "\er    Generating species list....              " << flush;
    writeInfo(os.str());
    // for outputting the full data from the simulation in to a SQL file.
    sqlite3_stmt* stmt;
    char* sErrMsg;
    int rc = 0;
// Open a SQL database in memory. This will be written to disk later.
// A check here can be done to write to disc directly instead to massively reduce RAM consumption
#ifdef sql_ram
    sqlite3_open(":memory:", &database);
#endif
#ifndef sql_ram
    openSQLiteDatabase(sqloutname, database);
#endif
    // Create the command to be executed by adding to the string.
    string all_commands;
    all_commands =
            "CREATE TABLE SPECIES_LIST (ID int PRIMARY KEY NOT NULL, unique_spec INT NOT NULL, xval INT NOT NULL,";
    all_commands += "yval INT NOT NULL, xwrap INT NOT NULL, ywrap INT NOT NULL, tip INT NOT NULL, speciated INT NOT "
            "NULL, parent INT NOT NULL, existence INT NOT NULL, randnum DOUBLE NOT NULL, gen_alive INT NOT "
            "NULL, gen_added DOUBLE NOT NULL);";

    // Create the table within the SQL database
    rc = sqlite3_exec(database, all_commands.c_str(), nullptr, nullptr, &sErrMsg);
    if(rc != SQLITE_OK)
    {
#ifndef sql_ram
        sqlite3_close(database);
        // delete any old database files \- this is risky, but there isn\(aqt a better way of ensuring that the file
        // actually gets created.
        remove(sqloutname.c_str());
        rc = sqlite3_open(sqloutname.c_str(), &database);
        rc = sqlite3_exec(database, all_commands.c_str(), nullptr, nullptr, &sErrMsg);
        if(rc != SQLITE_OK)
        {
            stringstream ss;
            ss << "Database file creation failed. Check file system." << endl;
            ss << "Error code: " << rc << endl;
            throw FatalException(ss.str());
        }
#endif
    }
    // Now create the prepared statement into which we shall insert the values from the table
    all_commands = "INSERT INTO SPECIES_LIST "
            "(ID,unique_spec,xval,yval,xwrap,ywrap,tip,speciated,parent,existence,randnum,gen_alive,gen_added) "
            "VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?)";
    sqlite3_prepare_v2(database, all_commands.c_str(), static_cast<int>(strlen(all_commands.c_str())), &stmt, nullptr);

    // Start the transaction
    rc = sqlite3_exec(database, "BEGIN TRANSACTION;", nullptr, nullptr, &sErrMsg);
    if(rc != SQLITE_OK)
    {
        cerr << "ERROR_SQL_008: Cannot start SQL transaction. Check memory database assignment and SQL commands."
             << endl;
    }
    for(unsigned int i = 0; i <= enddata; i++)
    {
        sqlite3_bind_int(stmt, 1, i);
        sqlite3_bind_int(stmt, 2, static_cast<int>(data[i].getSpeciesID()));
        sqlite3_bind_int(stmt, 3, static_cast<int>(data[i].getXpos()));
        sqlite3_bind_int(stmt, 4, static_cast<int>(data[i].getYpos()));
        sqlite3_bind_int(stmt, 5, static_cast<int>(data[i].getXwrap()));
        sqlite3_bind_int(stmt, 6, static_cast<int>(data[i].getYwrap()));
        sqlite3_bind_int(stmt, 7, data[i].isTip());
        sqlite3_bind_int(stmt, 8, data[i].hasSpeciated());
        sqlite3_bind_int(stmt, 9, static_cast<int>(data[i].getParent()));
        sqlite3_bind_int(stmt, 10, data[i].getExistence());
        sqlite3_bind_double(stmt, 11, static_cast<double>(data[i].getSpecRate()));
        sqlite3_bind_int(stmt, 12, static_cast<int>(data[i].getGenRate()));
        sqlite3_bind_double(stmt, 13, static_cast<double>(data[i].getGeneration()));
        sqlite3_step(stmt);
        sqlite3_clear_bindings(stmt);
        sqlite3_reset(stmt);
    }
    os.str("");
    os << "\er    Executing SQL commands...." << flush;
    writeInfo(os.str());
    // execute the command and close the connection to the database
    rc = sqlite3_exec(database, "END TRANSACTION;", nullptr, nullptr, &sErrMsg);
    if(rc != SQLITE_OK)
    {
        cerr << "ERROR_SQL_008: Cannot complete SQL transaction. Check memory database assignment and SQL "
                "commands. Ensure SQL statements are properly cleared."
             << endl;
        cerr << "Error code: " << rc << endl;
        // try again
        int i = 0;
        while((rc != SQLITE_OK && rc != SQLITE_DONE) && i < 10)
        {
            sleep(1);
            i++;
            rc = sqlite3_exec(database, "END TRANSACTION;", nullptr, nullptr, &sErrMsg);
            cerr << "Attempt " << i << " failed..." << endl;
            cerr << "ERROR_SQL_008: Cannot complete SQL transaction. Check memory database assignment and SQL "
                    "commands. Ensure SQL statements are properly cleared."
                 << endl;
        }
    }
    // Need to finalise the statement
    rc = sqlite3_finalize(stmt);
    if(rc != SQLITE_OK)
    {
        cerr << "ERROR_SQL_008: Cannot complete SQL transaction. Check memory database assignment and SQL "
                "commands. Ensure SQL statements are properly cleared."
             << endl;
        cerr << "Error code: " << rc << endl;
    }
    // Vacuum the file so that the file size is reduced (reduces by around 3%)
    rc = sqlite3_exec(database, "VACUUM;", nullptr, nullptr, &sErrMsg);
    if(rc != SQLITE_OK)
    {
        cerr << "ERROR_SQL_014: Cannot vacuum the database. Error message: " << sErrMsg << endl;
    }

    sqlCreateSimulationParameters();
    writeInfo("done!\en");
}

void Tree::sqlCreateSimulationParameters()
{
    char* sErrMsg;
// Now additionally store the simulation parameters (extremely useful data)
    string to_execute = "CREATE TABLE SIMULATION_PARAMETERS (seed INT PRIMARY KEY not null, job_type INT NOT NULL,";
    to_execute += "output_dir TEXT NOT NULL, speciation_rate DOUBLE NOT NULL, sigma DOUBLE NOT NULL,tau DOUBLE NOT "
            "NULL, deme INT NOT NULL, ";
    to_execute += "sample_size DOUBLE NOT NULL, max_time INT NOT NULL, dispersal_relative_cost DOUBLE NOT NULL, "
            "min_num_species ";
    to_execute += "INT NOT NULL, habitat_change_rate DOUBLE NOT NULL, gen_since_pristine DOUBLE NOT NULL, ";
    to_execute += "time_config_file TEXT NOT NULL, coarse_map_file TEXT NOT NULL, coarse_map_x INT NOT NULL, "
            "coarse_map_y INT NOT NULL,";
    to_execute += "coarse_map_x_offset INT NOT NULL, coarse_map_y_offset INT NOT NULL, coarse_map_scale DOUBLE NOT "
            "NULL, fine_map_file TEXT NOT NULL, fine_map_x INT NOT NULL,";
    to_execute += "fine_map_y INT NOT NULL, fine_map_x_offset INT NOT NULL, fine_map_y_offset INT NOT NULL, ";
    to_execute += "sample_file TEXT NOT NULL, grid_x INT NOT NULL, grid_y INT NOT NULL, sample_x INT NOT NULL, ";
    to_execute += "sample_y INT NOT NULL, sample_x_offset INT NOT NULL, sample_y_offset INT NOT NULL, ";
    to_execute += "pristine_coarse_map TEXT NOT NULL, pristine_fine_map TEXT NOT NULL, sim_complete INT NOT NULL, ";
    to_execute += "dispersal_method TEXT NOT NULL, m_probability DOUBLE NOT NULL, cutoff DOUBLE NOT NULL, ";
    to_execute += "restrict_self INT NOT NULL, infinite_landscape TEXT NOT NULL, protracted INT NOT NULL, ";
    to_execute += "min_speciation_gen DOUBLE NOT NULL, max_speciation_gen DOUBLE NOT NULL, dispersal_map TEXT NOT NULL);";
    int rc = sqlite3_exec(database, to_execute.c_str(), nullptr, nullptr, &sErrMsg);
    if(rc != SQLITE_OK)
    {
        cerr << "ERROR_SQL_008: Cannot start SQL transaction. Check memory database assignment and SQL commands."
             << endl;
        cerr << "Error code: " << rc << endl;
    }
    to_execute = simulationParametersSqlInsertion();
    rc = sqlite3_exec(database, to_execute.c_str(), nullptr, nullptr, &sErrMsg);
    if(rc != SQLITE_OK)
    {
        stringstream os;
        os << "ERROR_SQL_008: Cannot start SQL transaction. Check memory database assignment and SQL commands."
           << endl;
        os << "Error code: " << rc << endl;
        writeWarning(os.str());
    }
}

string Tree::simulationParametersSqlInsertion()
{
    string to_execute;
    to_execute = "INSERT INTO SIMULATION_PARAMETERS VALUES(" + to_string((long long)the_seed) + "," +
                 to_string((long long)the_task);
    to_execute += ",\(aq" + out_directory + "\(aq," + boost::lexical_cast<std::string>((long double)spec) + "," +
                  to_string(0.0) + ",";
    to_execute += to_string(0.0) + "," + to_string((long long)deme) + ",";
    to_execute += to_string((long double)deme_sample) + "," + to_string((long long)maxtime) + ",";
    to_execute += to_string(0.0) + "," + to_string(0.0) + ",";
    to_execute += to_string((long double)sim_parameters.habitat_change_rate) + ",";
    to_execute += to_string((long double)sim_parameters.gen_since_pristine) + ",\(aq" + sim_parameters.times_file + "\(aq,\(aq";
    to_execute += "none\(aq, 0, 0, 0, 0, 0, \(aqnull\(aq, 0, 0, 0, 0, \(aqnone\(aq, 1, 1, 1, 1, 0, 0, \(aqnone\(aq, \(aqnone\(aq,";
    to_execute += to_string(sim_complete);
    to_execute += ", \(aqnone\(aq, 0.0, 0, 0, \(aqnone\(aq, ";
    // Now save the protracted speciation variables (not relevant in this simulation scenario)
    to_execute += protractedVarsToString();
    to_execute += ", \(aqnone\(aq);";
    return to_execute;
}

string Tree::protractedVarsToString()
{
    string tmp = to_string(false) + ", " + to_string(0.0) + ", " + to_string(0.0);
    return tmp;
}

void Tree::simPause()
{
    // Completely changed how this sections works \- it won\(aqt currently allow restarting of the simulations, but will
    // dump the data file to memory. \- simply calls sqlCreate and sqlOutput.
    // sqlCreate();
    // sqlOutput();

    // This function saves the data to 4 files. One contains the main simulation parameters, the other 3 contain the
    // simulation results thus far
    // including the grid object, data object and active object.
    string pause_folder = initiatePause();
    dumpMain(pause_folder);
    dumpActive(pause_folder);
    dumpData(pause_folder);
    completePause();
}

string Tree::initiatePause()
{
    stringstream os;
    os << "Pausing simulation..." << endl << "Saving data to temp file in " << out_directory << "/Pause/ ..." << flush;
    writeInfo(os.str());
    os.str("");
    ofstream out;
    out.precision(64);
    string file_to_open;
    // Create the pause directory
    string pause_folder = out_directory + "/Pause/";
    boost::filesystem::path pause_dir(pause_folder);
    if(!boost::filesystem::exists(pause_dir))
    {
        try
        {
            boost::filesystem::create_directory(pause_dir);
        }
        catch(exception& e)
        {
            cerr << "Failure to create " << out_directory << "/Pause/"
                 << "." << endl;
            cerr << e.what() << endl;
            cerr << "Writing directly to output directory." << endl;
            pause_folder = out_directory;
        }
    }
    return pause_folder;
}

void Tree::completePause()
{
    stringstream os;
    os << "done!" << endl;
    os << "SQL dump started" << endl;
    writeInfo(os.str());
    os.str("");
    time(&out_finish);
    sqlCreate();
    sqlOutput();
    os << "Data dump complete" << endl;
    writeInfo(os.str());
    time(&sim_end);
    writeTimes();
}

void Tree::dumpMain(string pause_folder)
{
    try
    {
        string file_to_open = pause_folder + "Dump_main_" + to_string(the_task) + "_" + to_string(the_seed) + ".csv";
        ofstream out;
        out.open(file_to_open.c_str());
        out << setprecision(64);
        // Save that this simulation was not a protracted speciation sim
        out << bIsProtracted << "\en";
        // Saving the initial data to one file.
        out << enddata << "\en" << seeded << "\en" << the_seed << "\en" << the_task << "\en" << times_file << "\en"
            << has_times_file << "\en";
        out << sim_parameters.fine_map_file << "\en" << sim_parameters.coarse_map_file << "\en" << out_directory << "\en";
        out << sim_parameters.pristine_fine_map_file << "\en" << sim_parameters.pristine_coarse_map_file << "\en";
        out << sim_parameters.gen_since_pristine << "\en" << sim_parameters.habitat_change_rate << "\en";
        out << sim_parameters.grid_x_size << "\en" << sim_parameters.grid_y_size << "\en";
        out << sim_parameters.fine_map_x_size << "\en" << sim_parameters.fine_map_y_size << "\en";
        out << sim_parameters.fine_map_x_offset << "\en" << sim_parameters.fine_map_y_offset << "\en";
        out << sim_parameters.coarse_map_x_size << "\en" << sim_parameters.coarse_map_y_size << "\en";
        out << sim_parameters.coarse_map_x_offset << "\en" << sim_parameters.coarse_map_y_offset << "\en";
        out << sim_parameters.coarse_map_scale << "\en" << has_imported_vars << "\en" << start << "\en" << sim_start;
        out << "\en" << sim_end << "\en" << now << "\en" << time_taken << "\en" << sim_finish << "\en" << out_finish << "\en";
        out << endactive << "\en" << startendactive << "\en" << maxsimsize << "\en" << steps << "\en";
        out << generation << "\en" << sim_parameters.sigma << "\en" << sim_parameters.tau << "\en" << maxtime << "\en";
        out << deme_sample << "\en" << spec << "\en" << sim_parameters.dispersal_relative_cost << "\en" << deme << "\en";
        out << sim_parameters.desired_specnum << "\en" << sqloutname << "\en" << NR << "\en" << sim_parameters << "\en";
        // now output the protracted speciation variables (there should be two of these).
        out << getProtractedVariables();
        out.close();
    }
    catch(exception& e)
    {
        cerr << e.what() << endl;
        cerr << "Failed to perform main dump to " << pause_folder << endl;
    }
}

void Tree::dumpActive(string pause_folder)
{
    try
    {
        // Output the active object
        ofstream out3;
        string file_to_open = pause_folder + "Dump_active_" + to_string(the_task) + "_" + to_string(the_seed) + ".csv";
        out3 << setprecision(64);
        out3.open(file_to_open.c_str());
        out3 << active;
        out3.close();
    }
    catch(exception& e)
    {
        cerr << e.what() << endl;
        cerr << "Failed to perform active dump to " << pause_folder << endl;
    }
}

void Tree::dumpData(string pause_folder)
{
    try
    {
        // Output the data object
        ofstream out4;
        string file_to_open = pause_folder + "Dump_data_" + to_string(the_task) + "_" + to_string(the_seed) + ".csv";
        out4 << setprecision(64);
        out4.open(file_to_open.c_str());
        out4 << data;
        out4.close();
    }
    catch(exception& e)
    {
        cerr << e.what() << endl;
        cerr << "Failed to perform data dump to " << pause_folder << endl;
    }
}

void Tree::setResumeParameters()
{
    if(!has_imported_pause)
    {
        pause_sim_directory = out_directory;
        has_imported_pause = true;
    }
}

void Tree::setResumeParameters(
        string pausedir, string outdir, unsigned long seed, unsigned long task, unsigned long new_max_time)
{
    if(!has_imported_pause)
    {
        pause_sim_directory = move(pausedir);
        out_directory = move(outdir);
        the_seed = static_cast<long long int>(seed);
        the_task = static_cast<long long int>(task);
        maxtime = new_max_time;
        has_imported_pause = true;
    }
}

void Tree::loadMainSave()
{
    string file_to_open;
    try
    {
        stringstream os;
        os << "\erLoading data from temp file...main..." << flush;
        writeInfo(os.str());
        os.str("");
        ifstream in1;
        file_to_open = pause_sim_directory + string("/Pause/Dump_main_") + to_string(the_task) + "_" +
                       to_string(the_seed) + string(".csv");
        in1.open(file_to_open);
        // Reading the initial data
        string string1;
        // First read our boolean which just determines whether the simulation is a protracted simulation or not.
        // For these simulations, it should not be.
        bool tmp;
        in1 >> tmp;
        if(tmp != getProtracted())
        {
            if(getProtracted())
            {
                throw FatalException("Paused simulation is not a protracted speciation simulation. "
                                              "Cannot be resumed by this program. Please report this bug");
            }
            else
            {
                throw FatalException("Paused simulation is a protracted speciation simulation. "
                                              "Cannot be resumed by this program. Please report this bug");
            }
        }
        in1 >> enddata >> seeded >> the_seed >> the_task;
        in1.ignore(); // Ignore the endline character
        getline(in1, times_file);
        in1 >> has_times_file;
        in1.ignore();
        getline(in1, sim_parameters.fine_map_file);
        getline(in1, sim_parameters.coarse_map_file);
        getline(in1, string1);
        getline(in1, sim_parameters.pristine_fine_map_file);
        getline(in1, sim_parameters.pristine_coarse_map_file);
        in1 >> sim_parameters.gen_since_pristine >> sim_parameters.habitat_change_rate >> sim_parameters.grid_x_size;
        in1 >> sim_parameters.grid_y_size >> sim_parameters.fine_map_x_size >> sim_parameters.fine_map_y_size;
        in1 >> sim_parameters.fine_map_x_offset >> sim_parameters.fine_map_y_offset >> sim_parameters.coarse_map_x_size;
        in1 >> sim_parameters.coarse_map_y_size >> sim_parameters.coarse_map_x_offset;
        time_t tmp_time;
        in1 >> sim_parameters.coarse_map_y_offset >> sim_parameters.coarse_map_scale >> has_imported_vars >> tmp_time;
        in1 >> sim_start >> sim_end >> now;
        in1 >> time_taken >> sim_finish >> out_finish >> endactive >> startendactive >> maxsimsize >> steps;
        unsigned long tempmaxtime = maxtime;
        in1 >> generation >> sim_parameters.sigma >> sim_parameters.tau >> maxtime;
        has_imported_vars = false;
        in1 >> deme_sample >> spec >> sim_parameters.dispersal_relative_cost >> deme;
        in1 >> sim_parameters.desired_specnum;
        in1.ignore();
        getline(in1, sqloutname);
        in1 >> NR;
        in1.ignore();
        in1 >> sim_parameters;
        if(maxtime == 0)
        {
            sim_parameters.max_time = tempmaxtime;
        }
#ifdef DEBUG
        if(max_time == 0 && tempmaxtime == 0)
        {
            throw FatalException("Time set to 0 on resume!");
        }
#endif
        NR.setDispersalMethod(sim_parameters.dispersal_method, sim_parameters.m_prob, sim_parameters.cutoff);
        if(has_imported_pause)
        {
            sim_parameters.output_directory = out_directory;
        }
        setParameters();
        double tmp1, tmp2;
        in1 >> tmp1 >> tmp2;
        setProtractedVariables(tmp1, tmp2);
        in1.close();
        try
        {
            if(times_file == "null")
            {
                if(has_times_file)
                {
                    throw runtime_error("has_times_file should not be true");
                }
            }
            else
            {
                if(!has_times_file)
                {
                    throw runtime_error("has_times_file should not be false");
                }
                vector<string> tmpimport;
                ConfigOption tmpconfig;
                tmpconfig.setConfig(times_file, false);
                tmpconfig.importConfig(tmpimport);
                for(const auto &i : tmpimport)
                {
                    reference_times.push_back(stod(i));
                    //                  os << "t_i: " << reference_times[i] << endl;
                }
            }
        }
        catch(ConfigException& ce)
        {
            cerr << ce.what() << endl;
        }
    }
    catch(exception& e)
    {
        string msg;
        msg = string(e.what()) + "Failure to import parameters from " + file_to_open;
        throw FatalException(msg);
    }
}

void Tree::loadDataSave()
{
    string file_to_open;
    // Input the data object
    try
    {
        stringstream os;
        os << "\erLoading data from temp file...data..." << flush;
        writeInfo(os.str());
        ifstream in4;
        //      sprintf(file_to_open,"%s/Pause/Data_%i_data.csv",out_directory,int(the_task));
        file_to_open = pause_sim_directory + string("/Pause/Dump_data_") + to_string(the_task) + "_" +
                       to_string(the_seed) + string(".csv");
        in4.open(file_to_open);
        in4 >> data;
        //          os << data[0] << endl;
        //          os << data[1] << endl;
        in4.close();
    }
    catch(exception& e)
    {
        string msg;
        msg = string(e.what()) + "Failure to import data from " + file_to_open;
        throw FatalException(msg);
    }
}

void Tree::loadActiveSave()
{
    string file_to_open;
    try
    {
        stringstream os;
        os << "\erLoading data from temp file...active..." << flush;
        writeInfo(os.str());
        // Input the active object
        ifstream in3;
        file_to_open = pause_sim_directory + string("/Pause/Dump_active_") + to_string(the_task) + "_" +
                       to_string(the_seed) + string(".csv");
        in3.open(file_to_open);
        in3 >> active;
        in3.close();
    }
    catch(exception& e)
    {
        string msg;
        msg = string(e.what()) + "Failure to import active from " + file_to_open;
        throw FatalException(msg);
    }
}

void Tree::initiateResume()
{
    // Start the timer
    // Only resume the simulation if there is a simulation to resume from.
    if(!has_paused)
    {
        return;
    }
    time(&start);
    // Loads the data from the files into the relevant objects.
    stringstream os;
#ifdef DEBUG
    writeLog(10, "Paused directory: " + pause_sim_directory);
    writeLog(10, "Output directory: " + out_directory);
    writeLog(10, "Seed: " + to_string(the_seed));
    writeLog(10, "Task: " + to_string(the_task));
    writeLog(10, "Max time: " + to_string(max_time));
#endif // DEBUG
    os << "Resuming simulation..." << endl << "Loading data from temp file..." << flush;
    writeInfo(os.str());
    os.str("");

}

void Tree::simResume()
{
    initiateResume();
    // now load the objects
    loadMainSave();
    setObjectSizes();
    loadActiveSave();
    loadDataSave();
    time(&sim_start);
    writeInfo("\erLoading data from temp file...done!\en");
}
#ifdef DEBUG

void Tree::validateLineages()
{
    bool fail = false;
    writeInfo("\enStarting lineage validation...");
    unsigned long printed = 0;
    for(unsigned long i = 1; i < endactive; i++)
    {
        stringstream ss;
        DataPoint tmp_datapoint = active[i];
        if(tmp_datapoint.getXwrap() == 0 && tmp_datapoint.getYwrap() == 0)
        {
            if(tmp_datapoint.getNwrap() != 0)
            {
                fail = true;
            }
        }
        else
        {
            fail = true;
        }
        if(fail)
        {
            ss << "\enFailure in map expansion. Please report this bug." << endl;
            ss << "active reference: " << i << endl;
            data[active[i].getReference()].logLineageInformation(50);
            throw FatalException(ss.str());
        }
    }
    writeInfo("done\en");
}


void Tree::debugEndStep()
{
    try
    {
        runChecks(this_step.chosen, this_step.coalchosen);
        // runs the debug every 10,000 time steps
        if(steps % 10000 == 0)
        {
            for(unsigned long i = 0; i <= endactive; i++)
            {
                runChecks(i, i);
            }
        }
    }
    catch(FatalException& fe)
    {
        writeLog(50, "Logging chosen:");
        active[this_step.chosen].logActive(50);
        writeLog(50, "Logging coalchosen");
        active[this_step.coalchosen].logActive(50);
        stringstream ss;
        ss << "dumping data file..." << endl;
        sqlCreate();
#ifdef sql_ram
        sqlOutput();
#endif
        ss << "done!" << endl;
        writeWarning(ss.str());
        throw fe;
    }

}

void Tree::debugCoalescence()
{
    if(this_step.coalchosen ==0)
    {
        return;
    }
    stringstream ss;
    if(active[this_step.coalchosen].getXpos() != active[this_step.chosen].getXpos() ||
       active[this_step.coalchosen].getYpos() != active[this_step.chosen].getYpos() ||
       active[this_step.coalchosen].getXwrap() != active[this_step.chosen].getXwrap() ||
       active[this_step.coalchosen].getYwrap() != active[this_step.chosen].getYwrap())
    {
        writeLog(50, "Logging chosen: " + to_string(this_step.chosen));
        data[active[this_step.chosen].getReference()].logLineageInformation(50);
        writeLog(50, "Logging coalchosen: " + to_string(this_step.coalchosen));
        data[active[this_step.coalchosen].getReference()].logLineageInformation(50);
        ss << "ERROR_MOVE_006: NON FATAL. Nwrap not set correctly. Check move programming function." << endl;
        throw FatalException(ss.str());
    }
    if(active[this_step.coalchosen].getXpos() != (unsigned long)this_step.oldx ||
       active[this_step.coalchosen].getYpos() != (unsigned long)this_step.oldy ||
       active[this_step.coalchosen].getXwrap() != this_step.oldxwrap ||
       active[this_step.coalchosen].getYwrap() != this_step.oldywrap)
    {
        writeLog(50, "Logging chosen: " + to_string(this_step.chosen));
        data[active[this_step.chosen].getReference()].logLineageInformation(50);
        writeLog(50, "Logging coalchosen: " + to_string(this_step.coalchosen));
        data[active[this_step.coalchosen].getReference()].logLineageInformation(50);
        ss << "ERROR_MOVE_006: NON FATAL. Nwrap not set correctly. Check move programming function." << endl;
        throw FatalException(ss.str());
    }
}

void Tree::runChecks(const unsigned long &chosen, const unsigned long &coalchosen)
{
    miniCheck(chosen);
    miniCheck(coalchosen);
}

void Tree::miniCheck(const unsigned long &chosen)
{
    if(chosen == 0)
    {
        return;
    }
    if(active[chosen].getReference() == 0)
    {
        throw FatalException("Active reference should not be 0.");
    }
    if(data[active[chosen].getReference()].getParent() != 0)
    {
        writeLog(50, "Active: " + to_string(chosen));
        data[active[chosen].getReference()].logLineageInformation(50);
        throw FatalException("Parent not set to 0 for active lineage.");
    }
}


#endif // DEBUG
.ft P
.fi
.UNINDENT
.UNINDENT
.SS Detailed Description
.sp
Samuel Thompson
24/03/17
BSD\-3 Licence.
.SS Includes
.INDENT 0.0
.IP \(bu 2
\fBTree.h\fP (file_necsim_ProtractedSpatialTree.h)
.UNINDENT
.SS File Tree.h
.sp
Contains the class_Tree class implementation as the main simulation object for spatially\-implicit coalescence simulations. Provides the basis for spatially\-explicit versions in class_SpatialTree, and protracted speciation versions in class_ProtractedTree and class_ProtractedSpatialTree\&.
.SS Contents
.INDENT 0.0
.IP \(bu 2
\fI\%Definition (necsim/Tree.h)\fP
.IP \(bu 2
\fI\%Detailed Description\fP
.IP \(bu 2
\fI\%Includes\fP
.IP \(bu 2
\fI\%Included By\fP
.IP \(bu 2
\fI\%Classes\fP
.IP \(bu 2
\fI\%Defines\fP
.UNINDENT
.SS Definition (\fBnecsim/Tree.h\fP)
.SS Program Listing for File Tree.h
.INDENT 0.0
.IP \(bu 2
Return to documentation for file_necsim_Tree.h
.UNINDENT
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
// This file is part of NECSim project which is released under BSD\-3 license.
// See file **LICENSE.txt** or visit https://opensource.org/licenses/BSD\-3\-Clause) for full license details.

#ifndef TREE_H
#define TREE_H
#ifndef sql_ram
#define sql_ram
#endif

#include <sqlite3.h>
#include "TreeNode.h"
#include "Matrix.h"
#include "SimParameters.h"
#include "NRrand.h"
#include "DataPoint.h"
#include "Community.h"
#include "Filesystem.h"
#include "CustomExceptions.h"
#include "Step.h"

class Tree
{
protected:
    // storing the coalescence tree itself
    Row<TreeNode> data;
    // a reference for the last written point in data.
    unsigned long enddata;
    // Stores the command line parameters and parses the required information.
    SimParameters sim_parameters;
    // random number generator
    NRrand NR;
    // Storing the speciation rates for later reference.
    vector<long double> speciation_rates;
    // flag for having set the simulation seed.
    bool seeded;
    // random seed
    long long the_seed;
    // for file naming \- good to know which task in a series is being executed here
    long long the_task;
    // The map file containing the times that we want to expand the model and record all lineages again.
    // If this is null, has_times_file will be false and the vector will be empty.
    string times_file;
    vector<double> reference_times;
    // Set to true if we are recording at times other than the present day.
    bool has_times_file;
    // The time variables (for timing the simulation in real time)
    time_t start, sim_start, sim_end, now, sim_finish, out_finish;
    time_t time_taken;
    // Active lineages stored as a row of datapoints
    Row<DataPoint> active;
    // Stores the point of the end of the active vector. 0 is reserved as null
    unsigned long endactive;
    // the maximum size of endactive
    unsigned long startendactive;
    // the maximum simulated number of individuals in the present day.
    unsigned long maxsimsize;
    // for create the link to the speciationcounter object which handles everything.
    Community community;
    // This might need to be updated for simulations that have large changes in maximum population size over time.
    // number of simulation num_steps
    long steps;
    // Maximum time to run for (in seconds)
    unsigned long maxtime;
    // number of generations passed,
    double generation;
    // The number of individuals per cell
    long deme;
    // The proportion of individuals to sample
    double deme_sample;
    // the speciation rate
    long double spec;
    // Path to output directory
    string out_directory;
    // sqlite3 object that stores all the data
    sqlite3 *database;
    // only set to true if the simulation has finished, otherwise will be false.
    bool sim_complete;
    // set to true when variables are imported
    bool has_imported_vars;
// If sql database is written first to memory, then need another object to contain the in\-memory database.
#ifdef sql_ram
    sqlite3 *outdatabase;
#endif
    // Create the step object that will be retained for the whole simulation.
    // Does not need saving on simulation pause.
    Step this_step;
    string sqloutname;
    // If true, means the command\-line imports were under the (deprecated) fullmode.
    bool bFullmode;
    // If true, the simulation is to be resumed.
    bool bResume;
    // If true, a config file contains the simulation variables.
    bool bConfig;
    // If true, simulation can be resumed.
    bool has_paused, has_imported_pause;
    // Should always be false in the base class
    bool bIsProtracted;
    // variable for storing the paused sim location if files have been moved during paused/resumed simulations!
    string pause_sim_directory;
#ifdef DEBUG
    // For debugging purposes
    unsigned long count_dispersal_fails, count_density_fails;
#endif
public:
    Tree() : community(&data), this_step()
    {
        has_imported_vars = false;
        enddata = 0;
        seeded = false;
        the_seed = \-10;
        // set this equal to true if you want to log every 5 seconds to a logfile.
        the_task = \-1;
        sqloutname = "null";
        sim_complete = false;
        time_taken = 0;  // the time taken starts at 0, unless imported from file.
        maxtime = 0;
        // Set the database to NULL pointers.
        database = nullptr;
        outdatabase = nullptr;
        has_times_file = false;
        start = 0;
        sim_start = 0;
        sim_end = 0;
        now = 0;
        sim_finish = 0;
        out_finish = 0;
        endactive = 0;
        startendactive = 0;
        maxsimsize = 0;
        steps = 0;
        generation = 0.0;
        spec = 0.0;
        deme_sample = 0.0;
        deme = 0;
        bFullmode = false;
        bResume = false;
        bConfig = true;
        has_paused = false;
        has_imported_pause = false;
        bIsProtracted = false;
        pause_sim_directory = "null";
    }

    virtual ~Tree()
    {
        sqlite3_close_v2(database);
#ifdef sql_ram
        sqlite3_close_v2(outdatabase);
#endif
    }


    virtual void importSimulationVariables(const string &configfile);

    void internalSetup(const SimParameters &sim_parameters_in);

    bool checkOutputDirectory();


    void checkSims();

    void checkSims(string output_dir, long seed, long task);

    virtual void setParameters();

    virtual void setProtractedVariables(double speciation_gen_min, double speciation_gen_max);

    bool hasPaused();

    vector<double> getTemporalSampling();

    long long getSeed();

    void setSeed(long long seed_in);

    virtual unsigned long getInitialCount();

    unsigned long setObjectSizes();

    virtual void setup();

    void setInitialValues();

    void setSimStartVariables();

    void printSetup();

    void setTimes();

    void determineSpeciationRates();

    void generateObjects();

    virtual unsigned long fillObjects(const unsigned long &initial_count);

     virtual bool runSimulation();

    void writeSimStartToConsole();

    void writeStepToConsole();

    virtual void incrementGeneration();

    void chooseRandomLineage();

    virtual void updateStepCoalescenceVariables();

    void speciation(const unsigned long &chosen);

    virtual void speciateLineage(const unsigned long &data_position);
    virtual void removeOldPosition(const unsigned long &chosen);

    virtual void switchPositions(const unsigned long &chosen);

    virtual void calcNextStep();

    virtual bool calcSpeciation(const long double &random_number,
                                const long double &speciation_rate,
                                const unsigned long &no_generations);

    void coalescenceEvent(const unsigned long &chosen, unsigned long &coalchosen);

    void checkTimeUpdate();

    virtual void addLineages(double generation_in);

    void checkSimSize(unsigned long req_data, unsigned long req_active);


    void makeTip(const unsigned long &tmp_active, const double &generation_in);

    void convertTip(unsigned long i, double generationin);

    bool stopSimulation();

    void applySpecRate(long double sr, double t);

    void applySpecRateInternal(long double sr, double t);

    Row<unsigned long> *getCumulativeAbundances();
    void setupTreeGeneration(long double sr, double t);

    void applySpecRate(long double sr);

    void applyMultipleRates();

    virtual bool getProtracted();

    virtual string getProtractedVariables();

    virtual double getProtractedGenerationMin();

    virtual double getProtractedGenerationMax();


    void sqlOutput();

    void outputData();

    void outputData(unsigned long species_richness);

    unsigned long sortData();

    void writeTimes();


    void sqlCreate();

    void sqlCreateSimulationParameters();

    virtual string simulationParametersSqlInsertion();

    virtual string protractedVarsToString();


    virtual void simPause();

    string initiatePause();

    void dumpMain(string pause_folder);

    void dumpActive(string pause_folder);

    void dumpData(string pause_folder);

    void completePause();

    void setResumeParameters(string pausedir, string outdir, unsigned long seed, unsigned long task,
                             unsigned long new_max_time);

    void setResumeParameters();

    virtual void loadMainSave();

    void loadDataSave();

    void loadActiveSave();

    void initiateResume();

    virtual void simResume();
#ifdef DEBUG

    virtual void validateLineages();

    virtual void debugEndStep();

    void debugCoalescence();

    virtual void runChecks(const unsigned long &chosen, const unsigned long &coalchosen);

    void miniCheck(const unsigned long &chosen);
#endif // DEBUG
};


#endif //TREE_H
.ft P
.fi
.UNINDENT
.UNINDENT
.SS Detailed Description
.sp
Samuel Thompson
24/03/17
BSD\-3 Licence.
.SS Includes
.INDENT 0.0
.IP \(bu 2
\fBCommunity.h\fP (file_necsim_Community.h)
.IP \(bu 2
\fBCustomExceptions.h\fP (file_necsim_CustomExceptions.h)
.IP \(bu 2
\fBDataPoint.h\fP (file_necsim_DataPoint.h)
.IP \(bu 2
\fBFilesystem.h\fP (file_necsim_Filesystem.h)
.IP \(bu 2
\fBMatrix.h\fP (file_necsim_Matrix.h)
.IP \(bu 2
\fBNRrand.h\fP (file_necsim_NRrand.h)
.IP \(bu 2
\fBSimParameters.h\fP (file_necsim_SimParameters.h)
.IP \(bu 2
\fBStep.h\fP (file_necsim_Step.h)
.IP \(bu 2
\fBTreeNode.h\fP (file_necsim_TreeNode.h)
.IP \(bu 2
\fBsqlite3.h\fP
.UNINDENT
.SS Included By
.INDENT 0.0
.IP \(bu 2
file_necsim_SpatialTree.h
.IP \(bu 2
file_necsim_Metacommunity.h
.IP \(bu 2
file_necsim_Tree.cpp
.UNINDENT
.SS Classes
.INDENT 0.0
.IP \(bu 2
class_Tree
.UNINDENT
.SS Defines
.INDENT 0.0
.IP \(bu 2
define_sql_ram
.UNINDENT
.SS File TreeNode.cpp
.sp
Contains the class_TreeNode class for storing the coalescence tree.
.SS Contents
.INDENT 0.0
.IP \(bu 2
\fI\%Definition (necsim/TreeNode.cpp)\fP
.IP \(bu 2
\fI\%Detailed Description\fP
.IP \(bu 2
\fI\%Includes\fP
.IP \(bu 2
\fI\%Functions\fP
.UNINDENT
.SS Definition (\fBnecsim/TreeNode.cpp\fP)
.SS Program Listing for File TreeNode.cpp
.INDENT 0.0
.IP \(bu 2
Return to documentation for file_necsim_TreeNode.cpp
.UNINDENT
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
//This file is part of NECSim project which is released under BSD\-3 license.
//See file **LICENSE.txt** or visit https://opensource.org/licenses/BSD\-3\-Clause) for full license details.
#include "TreeNode.h"
#include "Logging.h"

void TreeNode::setup(bool z, unsigned long xp, unsigned long yp, long xi, long yi)
{
    tip = z;
    parent = 0;
    speciated = false;

    species_id = 0;

    xpos = xp;
    ypos = yp;
    xwrap = xi;
    ywrap = yi;
    speciation_probability =0;
    generations_existed = 0;
    generation_added = 0;
}

void TreeNode::setup(bool z)
{
    setup(z, 0, 0, 0, 0);
}

void TreeNode::setup(const bool &is_tip, const long &xp, const long &yp, const long &xi, const long &yi,
                     const long double &generation)
{
    tip = is_tip;
    parent = 0;
    speciated = false;
    species_id = 0;
    xpos = xp;
    ypos = yp;
    xwrap = xi;
    ywrap = yi;
    speciation_probability =0;
    generations_existed = 0;
    generation_added = generation;
}

void TreeNode::setExistence(bool b)
{
    does_exist = b;
}

void TreeNode::setParent(unsigned long x)
{
    parent = x;
}

void TreeNode::qReset()
{
    species_id = 0;
    does_exist = false;
    speciated = false;
}

void TreeNode::setPosition(long x, long y, long xw, long yw)
{
    xpos = x;
    ypos = y;
    xwrap = xw;
    ywrap = yw;
}

void TreeNode::setSpec(long double d)
{
    speciation_probability = d;
}

void TreeNode::setGenerationRate(unsigned long g)
{
    generations_existed = g;
}

void TreeNode::setGeneration(long double d)
{
    generation_added = d;
}

void TreeNode::setSpeciation(bool s)
{
    speciated = s;
}

void TreeNode::burnSpecies(unsigned long idin)
{
    if (species_id == 0)
    {
        species_id = idin;
    }
}

void TreeNode::setTip(bool b)
{
    tip = b;
}

void TreeNode::resetSpecies()
{
    species_id = 0;
}

void TreeNode::increaseGen()
{
    generations_existed++;
}

bool TreeNode::getExistence()
{
    return does_exist;
}

bool TreeNode::isTip()
{
    return tip;
}

unsigned long TreeNode::getParent()
{
    return parent;
}

unsigned long TreeNode::getXpos()
{
    return xpos;
}

unsigned long TreeNode::getYpos()
{
    return ypos;
}

long TreeNode::getXwrap()
{
    return xwrap;
}

long TreeNode::getYwrap()
{
    return ywrap;
}

bool TreeNode::hasSpeciated()
{
    return speciated;
}

unsigned long TreeNode::getSpeciesID()
{
    return species_id;
}

long double TreeNode::getSpecRate()
{
    return speciation_probability;
}

unsigned long TreeNode::getGenRate()
{
    return generations_existed;
}

long double TreeNode::getGeneration()
{
    return generation_added;
}

void TreeNode::speciate()
{
    speciated = true;
}

ostream &operator<<(ostream &os, const TreeNode &t)
{
    os << setprecision(64);
    os <<t.tip << "," << t.parent << "," << t.speciated << "," << t.does_exist << "," << t.species_id << "," << t.xpos << "," << t.ypos << "," << t.xwrap << ",";
    os << t.ywrap << "," << t.speciation_probability << "," << t.generations_existed << "," << t.generation_added << "\en";
    return os;
}

istream &operator>>(istream &is, TreeNode &t)
{
    //is << m.numRows<<" , "<<m.numCols<<" , "<<endl;
    char delim;
    is >>t.tip >> delim >> t.parent >> delim >> t.speciated >> delim >> t.does_exist >> delim >> t.species_id >> delim >> t.xpos >> delim;
    is >> t.ypos >> delim >> t.xwrap >> delim >> t.ywrap >> delim >> t.speciation_probability >> delim >> t.generations_existed >> delim >> t.generation_added;
    return is;
}

TreeNode &TreeNode::operator=(const TreeNode &t)
{
    tip = t.tip;
    parent = t.parent;
    speciated = t.speciated;
    does_exist = t.does_exist;
    species_id = t.species_id;
    xpos = t.xpos;
    ypos = t.ypos;
    xwrap = t.xwrap;
    ywrap = t.ywrap;
    speciation_probability = t.speciation_probability;
    generation_added = t.generation_added;
    generations_existed = t.generations_existed;
    return *this;
}

#ifdef DEBUG
void TreeNode::logLineageInformation(const int &level)
{
    writeLog(level, "Logging lineage information");
    writeLog(level, "parent: " + to_string(parent));
    writeLog(level, "tip: " + to_string(tip));
    writeLog(level, "speciated: " + to_string(speciated));
    writeLog(level, "existance: " + to_string(does_exist));
    writeLog(level, "x, y, (x wrap, y wrap): " + to_string(xpos) + ", " + to_string(ypos) + ", " +
                    to_string(xwrap) + ", " + to_string(ywrap));
    writeLog(level, "speciation rate: " + to_string(speciation_probability));
    writeLog(level, "generations (added, existed): " + to_string(generation_added) + ", " +
                    to_string(generations_existed));
}


#endif // DEBUG
.ft P
.fi
.UNINDENT
.UNINDENT
.SS Detailed Description
.sp
Samuel Thompson
class_TreeNode objects are used both during simulation runs and afterwards, when different calculations need to be performed on the coalescence tree.
.SS Includes
.INDENT 0.0
.IP \(bu 2
\fBLogging.h\fP (file_necsim_Logging.h)
.IP \(bu 2
\fBTreeNode.h\fP (file_necsim_TreeNode.h)
.UNINDENT
.SS Functions
.INDENT 0.0
.IP \(bu 2
function_operator_LT__LT
.IP \(bu 2
function_operator_GT__GT
.UNINDENT
.SS File TreeNode.h
.sp
Contains the class_TreeNode class for storing the coalescence tree.
.SS Contents
.INDENT 0.0
.IP \(bu 2
\fI\%Definition (necsim/TreeNode.h)\fP
.IP \(bu 2
\fI\%Detailed Description\fP
.IP \(bu 2
\fI\%Includes\fP
.IP \(bu 2
\fI\%Included By\fP
.IP \(bu 2
\fI\%Classes\fP
.UNINDENT
.SS Definition (\fBnecsim/TreeNode.h\fP)
.SS Program Listing for File TreeNode.h
.INDENT 0.0
.IP \(bu 2
Return to documentation for file_necsim_TreeNode.h
.UNINDENT
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
//This file is part of NECSim project which is released under BSD\-3 license.
//See file **LICENSE.txt** or visit https://opensource.org/licenses/BSD\-3\-Clause) for full license details.
#ifndef TREENODE
#define TREENODE
#include <cstdio>
#include <iostream>
#include <iomanip>
#include "Logging.h"

using namespace std;
class TreeNode
{

private:
    // 0 means that this node is just here to mark a coalescense
    // and therefore this node of no real other relevance
    // 1 means that this node is a leaf node and counts towards diversity
    bool tip;
    // this stores the parent of the individual
    // 0 means there is no parent \- we are at the end of the tree
    // (as far as has been calculated)
    unsigned long parent;
    // true if this lineage has speciated in which case it should not have a parent
    // because under the present implementation lineages are not traced beyond speciation
    // boolean for checking whether the lineage actually exists at the end. If all children of the lineages have
    // speciated, then the lineage no longer exists.
    bool speciated;
    // the species identity of the node
    bool does_exist;
    // the following 4 variables describe the position of the lineage in the present day.
    unsigned long species_id;
    // x position
    unsigned long xpos;
    // y position
    unsigned long ypos;
    // number of wraps of x around the torus
    long xwrap;
    // number of wraps of y around the torus
    long ywrap;
    // the speciation probability. This needs to be multiplied by the number of generations in order to generate the
    // actual probability.
    long double speciation_probability;
    // Number of generations this lineage has existed since coalescence (or tracking began).
    unsigned long generations_existed;
    // Simulation generation timer that the lineage was created at
    long double generation_added;
public:
    TreeNode() : tip(false),parent(0),speciated(false),does_exist(false),species_id(0),xpos(0),ypos(0),xwrap(0),
                 ywrap(0), speciation_probability(0), generations_existed(0),generation_added(0)
    {

    }

    ~TreeNode()
    = default;

    void setup(bool z, unsigned long xp, unsigned long yp, long xi, long yi);

    void setup(bool z);

    void setup(const bool &is_tip, const long &xp, const long &yp, const long &xi, const long &yi,
               const long double &generation);

    void setExistence(bool b);

    void setParent(unsigned long x);

    void qReset();

    void setPosition(long x,long y, long xw, long yw);

    void setSpec(long double d);

    void setGenerationRate(unsigned long g);

    void setGeneration(long double d);

    void setSpeciation(bool s);

    void burnSpecies(unsigned long idin);

    void setTip(bool b);

    void resetSpecies();

    void increaseGen();
    // we don\(aqt allow the other variables to be changed
    // because they only need to be set once at the start of the coalescence
    // it\(aqs actually safer to leave out setters.
    // similarly we don\(aqt allow speciation to be changed once it has been set.

    // standard getters

    bool getExistence();

    bool isTip();

    unsigned long getParent();

    unsigned long getXpos();

    unsigned long getYpos();

    long getXwrap();

    long getYwrap();

    bool hasSpeciated();

    unsigned long getSpeciesID();

    long double getSpecRate();

    unsigned long getGenRate();

    long double getGeneration();

    void speciate();



    friend ostream& operator<<(ostream& os,const TreeNode& t);

    friend istream& operator>>(istream& is,TreeNode& t);

    TreeNode & operator=(const TreeNode &t);
#ifdef DEBUG

    void logLineageInformation(const int &level);
#endif // DEBUG
};
#endif
.ft P
.fi
.UNINDENT
.UNINDENT
.SS Detailed Description
.sp
Samuel Thompson
class_TreeNode objects are used both during simulation runs and afterwards, when different calculations need to be performed on the coalescence tree.
.SS Includes
.INDENT 0.0
.IP \(bu 2
\fBLogging.h\fP (file_necsim_Logging.h)
.IP \(bu 2
\fBcstdio\fP
.IP \(bu 2
\fBiomanip\fP
.IP \(bu 2
\fBiostream\fP
.UNINDENT
.SS Included By
.INDENT 0.0
.IP \(bu 2
file_necsim_Community.h
.IP \(bu 2
file_necsim_Tree.h
.IP \(bu 2
file_necsim_SpatialTree.h
.IP \(bu 2
file_necsim_SpeciationCommands.h
.IP \(bu 2
file_necsim_TreeNode.cpp
.UNINDENT
.SS Classes
.INDENT 0.0
.IP \(bu 2
class_TreeNode
.UNINDENT
.SH MODULES
.SS pycoalescence package
.sp
pycoalescence provides the facilities for running spatially\-explicit neutral coalescence ecological simulations
and performing basic analysis of the simulation outputs. The program requires necsim to function properly.
.SS Module Contents
.SS Submodules
.SS batch_process module
.sp
Contains the operations for performing batch analysis on multiple outputs of a PyCoalescence simulation.
.SS coalescence_tree module
.sp
Detailed here\&.
.sp
Contains basic analyses for the output of a pycoalescence simulation.
.INDENT 0.0
.TP
.B class CoalescenceTree(database=None, logging_level=30, log_output=None)
Bases: \fBobject\fP
.sp
Contains the coalescence tree and performs various calculations of different biodiversity metrics, which are then
stored in the SQLite database.
.sp
The general process is
.INDENT 7.0
.IP \(bu 2
Import the database (\fI\%set_database()\fP) and import the comparison data,
if required (\fI\%import_comparison_data()\fP)
.IP \(bu 2
Apply additional speciation rates (if required) using \fI\%set_speciation_params()\fP and then
\fI\%apply_speciation()\fP
.IP \(bu 2
Calculate required metrics (such as \fI\%calculate_fragment_richness()\fP)
.IP \(bu 2
Optionally, calculate the goodness of fit (\fI\%calculate_goodness_of_fit()\fP)
.UNINDENT
.INDENT 7.0
.TP
.B adjust_data()
Ensures that the numbers of individuals are equalised between the comparison and simulated datasets, and
modifies the relevant tables with the new data
.UNINDENT
.INDENT 7.0
.TP
.B apply_speciation()
Creates the list of speciation options and performs the speciation analysis by calling SpeciationCounter.
This must be run after the main coalescence simulations are complete.
It will create additional fields and tables in the SQLite database which contains the requested data.
.UNINDENT
.INDENT 7.0
.TP
.B calculate_alpha_diversity()
Calculates the system alpha diversity for each set of parameters stored in COMMUNITY_PARAMETERS.
Stores the output in ALPHA_DIVERSITY table.
.UNINDENT
.INDENT 7.0
.TP
.B calculate_beta_diversity()
Calculates the beta diversity for the system for each speciation parameter set and stores the output in
BETA_DIVERSITY.
Will calculate alpha diversity and species richness tables if they have not already been performed.
.UNINDENT
.INDENT 7.0
.TP
.B calculate_comparison_octaves(store=False)
Calculates the octave classes for the comparison data and for fragments (if required).
If the octaves exist in the FRAGMENT_OCTAVES table in the comparison database, the data will be imported
instead of being re\-calculated.
.sp
Stores the new octave classes in self.comparison_octaves.
.sp
\fBNOTE:\fP
.INDENT 7.0
.INDENT 3.5
If store is True, will store an EDITED version of the comparison octaves, such that the number of
individuals is equal between the comparison and simulated data.
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Parameters
\fBstore\fP \-\- if True, stores within the comparison database.
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B calculate_fragment_abundances()
Calculates the fragment abundances, including equalising with the comparison database, if it has already been
set.
.sp
Sets fragment_abundances object.
.UNINDENT
.INDENT 7.0
.TP
.B calculate_fragment_octaves()
Calculates the octave classes for each fragment. Outputs the calculated richness into the SQL database within a
FRAGMENT_OCTAVES table
.UNINDENT
.INDENT 7.0
.TP
.B calculate_fragment_richness()
Calculates the fragment richness and stores it in a new table called FRAGMENT_RICHNESS. Also adds the record to
BIODIVERSITY METRICS for
If the table already exists, it will simply be returned. Each time point and speciation rate combination will be
recorded as a new variable.
.UNINDENT
.INDENT 7.0
.TP
.B calculate_goodness_of_fit()
Calculates the goodness\-of\-fit measure based on the calculated biodiversity metrics, scaling each metric by the
number of individuals involved in the metric.
.sp
This requires that import_comparison_data() has already been successfully run.
.sp
\fBNOTE:\fP
.INDENT 7.0
.INDENT 3.5
This doesn\(aqt calculate anything for values which have not yet been written to the
BIODIVERSITY_METRICS table. All in\-built functions (e.g. calculate_alpha_diversity,
calculate_fragment_richness) write to the BIODIVERSITY_METRICS table automatically, so this is only relevant
for custom functions.
.UNINDENT
.UNINDENT
.sp
The resulting value will then be written to the BIODIVERSITY_METRICS table in the SQL database.
.UNINDENT
.INDENT 7.0
.TP
.B calculate_octaves()
Calculates the octave classes for the landscape. Outputs the calculated richness into the SQL database within a
FRAGMENT_OCTAVES table.
.UNINDENT
.INDENT 7.0
.TP
.B calculate_octaves_error()
Calculates the error in octaves classes between the simulated data and the comparison data.
Stores each error value as a new entry in BIODIVERSITY_METRICS under fragment_octaves.
Calculates the error by comparing each octave class and summing the relative difference.
Octaves are then averaged for each fragment.
.UNINDENT
.INDENT 7.0
.TP
.B calculate_richness()
Calculates the landscape richness from across all fragments and stores result in a new table in
SPECIES_RICHNESS
Stores a separate result for each speciation rate and time.
.UNINDENT
.INDENT 7.0
.TP
.B check_biodiversity_table_exists()
Checks whether the biodiversity table exists and creates the table if required.
.INDENT 7.0
.TP
.B Returns
the max reference value currently existing
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B clear_calculations()
Removes the BIODIVERSITY_METRICS and FRAGMENT_OCTAVES tables completely.
.sp
\fBNOTE:\fP
.INDENT 7.0
.INDENT 3.5
that this cannot be undone (other than re\-running the calculations).
.UNINDENT
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B dispersal_parameters()
Reads the dispersal parameters from the database and returns them.
.INDENT 7.0
.TP
.B Returns
a list of the dispersal parameters [sigma, tau, m_probability, cutoff]
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B get_alpha_diversity(reference=1)
Gets the system alpha diversity for the provided community reference parameters.
Alpha diversity is the mean number of species per fragment.
:param reference: the community reference for speciation parameters
:return: the alpha diversity of the system
.UNINDENT
.INDENT 7.0
.TP
.B get_beta_diversity(reference=1)
Gets the system beta diversity for the provided community reference parameters.
Beta diversity is the true beta diversity (gamma / alpha).
:param reference: the community reference for speciation parameters
:return: the beta diversity of the system
.UNINDENT
.INDENT 7.0
.TP
.B get_community_parameters(reference=1)
Returns a dictionary containing the parameters for the calculated community.
.INDENT 7.0
.TP
.B Parameters
\fBreference\fP \-\- the reference key for the calculated parameters. (default is 1)
.TP
.B Returns
dictionary containing the speciation_rate, time, fragments and metacommunity_reference
.TP
.B Return type
dict
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B get_community_reference(speciation_rate, time, fragments, metacommunity_size=0, metacommunity_speciation_rate=0.0)
Gets the community reference associated with the supplied community parameters
.INDENT 7.0
.TP
.B Raises
\fBKeyError\fP \-\- if COMMUNITY_PARAMETERS (or METACOMMUNITY_PARAMETERS) does not exist in database or no
reference exists for the supplied parameters
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBspeciation_rate\fP \-\- the speciation rate of the community
.IP \(bu 2
\fBtime\fP \-\- the time in generations of the community
.IP \(bu 2
\fBfragments\fP \-\- whether fragments were determined for the community
.IP \(bu 2
\fBmetacommunity_size\fP \-\- the metacommunity size
.IP \(bu 2
\fBmetacommunity_speciation_rate\fP \-\- the metacommunity speciation rate
.UNINDENT
.TP
.B Returns
the reference associated with this set of simulation parameters
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B get_community_references()
Gets a list of all the commuity references already calculated for the simulation.
.INDENT 7.0
.TP
.B Returns
list of all calculated community references
.TP
.B Return type
list
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B get_fragment_abundances(fragment, reference)
Gets the species abundances for the supplied fragment and community reference.
:param fragment: the name of the fragment to obtain
:param reference: the reference for speciation parameters to obtain for
:return: a list of species ids and abundances
.UNINDENT
.INDENT 7.0
.TP
.B get_fragment_list()
Returns a list of all fragments that exist in FRAGMENT_ABUNDANCES.
:return: list all all fragment names
.UNINDENT
.INDENT 7.0
.TP
.B get_fragment_octaves(fragment=None, reference=None)
Get the pre\-calculated octave data for the specified fragment, speciation rate and time. If fragment and
speciation_rate are None, returns the entire FRAGMENT_OCTAVES object
This requires self.calculate_fragment_octaves() to have been run successfully at some point previously.
.sp
Returns are of form [id, fragment, community_reference, octave class, number of species]
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBfragment\fP \-\- the desired fragment (defaults to None)
.IP \(bu 2
\fBreference\fP \-\- the reference key for the calculated community parameters
.UNINDENT
.TP
.B Returns
output from FRAGMENT_OCTAVES for the selected variables
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B get_fragment_richness(fragment=None, reference=None)
Gets the fragment richness for each speciation rate and time for the specified simulation. If the fragment
richness has not yet been calculated, it tries to calculate the fragment richness,
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBfragment\fP \-\- the desired fragment (defaults to None)
.IP \(bu 2
\fBreference\fP \-\- the reference key for the calculated community parameters
.UNINDENT
.TP
.B Raises
sqlite3.OperationalError if no table FRAGMENT_ABUNDANCES exists
.TP
.B Raises
RuntimeError if no data for the specified fragment, speciation rate and time exists.
.TP
.B Returns
A list containing the fragment richness, or a value of the fragment richness
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B get_goodness_of_fit(reference=1)
Returns the goodness of fit from the file.
.INDENT 7.0
.TP
.B Parameters
\fBreference\fP \-\- the community reference to get from
.TP
.B Returns
the full output from the SQL query
.TP
.B Return type
list
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B get_goodness_of_fit_fragment_octaves(reference=1)
Returns the goodness of fit for fragment octaves from the file.
.INDENT 7.0
.TP
.B Raises
\fBValueError\fP \-\- if BIODIVERSITY_METRICS table does not exist.
.TP
.B Parameters
\fBreference\fP \-\- the community reference number
.TP
.B Returns
the full output from the SQL query
.TP
.B Return type
list
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B get_goodness_of_fit_fragment_richness(reference=1)
Returns the goodness of fit for fragment richness from the file.
.INDENT 7.0
.TP
.B Raises
\fBValueError\fP \-\- if BIODIVERSITY_METRICS table does not exist.
.TP
.B Parameters
\fBreference\fP \-\- the community reference number
.TP
.B Returns
the full output from the SQL query
.TP
.B Return type
float
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B get_goodness_of_fit_metric(metric, reference=1)
Gets the goodness\-of\-fit measure for the specified metric and community reference.
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBmetric\fP \-\- the metric goodness of fit has been calculated for to obtain
.IP \(bu 2
\fBreference\fP \-\- the community reference to fetch fits for
.UNINDENT
.TP
.B Returns
the goodness of fit value
.TP
.B Return type
float
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B get_job()
Gets the job number (the seed) and the job type (the task identifier).
.INDENT 7.0
.TP
.B Returns
list containing [seed, job_type (the task identifier)]
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B get_landscape_richness(reference=1)
Reads the landscape richness from the SPECIES_RICHNESS table in the database. Returns the richness for
each speciation rate and time.
.sp
\fBNOTE:\fP
.INDENT 7.0
.INDENT 3.5
This should produce the same result as get_richness(sr, t) with the corresponding sr and t.
.UNINDENT
.UNINDENT
.sp
\fBNOTE:\fP
.INDENT 7.0
.INDENT 3.5
Return type of this function changes based on whether speciation rates and times were supplied.
If they were, returns a single integer. Otherwise, returns a list of all species richnesses.
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBspeciation_rate\fP \-\- the required speciation rate (optional)
.IP \(bu 2
\fBreference\fP \-\- the reference key for the calculated community parameters
.UNINDENT
.TP
.B Returns
either a list containing the speciation_rate, time, richness OR (if specific speciation rate and time
provided), the species richness at that time and speciation rate.
.TP
.B Return type
int, list
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B get_metacommunity_parameters(reference=1)
Returns a dictionary containing the parameters for the calculated community.
.INDENT 7.0
.TP
.B Parameters
\fBreference\fP \-\- the reference key for the calculated parameters. (default is 1)
.TP
.B Raises
.INDENT 7.0
.IP \(bu 2
\fBsqlite3.OperationalError\fP \-\- if the METACOMMUNITY_PARAMETERS table does not exist, or some other sqlite
error occurs
.IP \(bu 2
\fBKeyError\fP \-\- if the supplied reference does not exist in the METACOMMUNITY_PARAMETERS table
.UNINDENT
.TP
.B Returns
dictionary containing the speciation_rate, time, fragments and metacommunity_reference
.TP
.B Return type
dict
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B get_metacommunity_references()
Gets a list of all the metacommuity references already calculated for the simulation.
.sp
\fBNOTE:\fP
.INDENT 7.0
.INDENT 3.5
Returns an empty list and logs an error message if the METACOMMUNITY_PARAMETERS table does not exist.
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Returns
list of all calculated metacommunity references
.TP
.B Return type
list
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B get_number_individuals(fragment=None, community_reference=None)
Gets the number of individuals that exist, either in the provided fragment, or on the whole landscape.
Counts individuals from FRAGMENT_ABUNDANCES or SPECIES_ABUNDANCES, respectively.
.sp
If a community reference is provided, only individuals for that time slice will be counted, otherwise a mean is
taken across time slices.
.INDENT 7.0
.TP
.B Parameters
\fBfragment\fP \-\- the name of the fragment to get a count of individuals from
.TP
.B Returns
the number of individuals that exists in the desired location
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B get_octaves(reference)
Get the pre\-calculated octave data for the parameters associated with the supplied reference.
This will call self.calculate_octaves() if it hasn\(aqt been called previously.
.sp
Returns are of form [id, \(aqwhole\(aq, time, speciation rate, octave class, number of species]
.INDENT 7.0
.TP
.B Parameters
\fBreference\fP \-\- community reference which contains the parameters of interest
.TP
.B Returns
output from FRAGMENT_OCTAVES on the whole landscape for the selected variables
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B get_parameter_description(key=None)
Gets the description of the parameter matching the key from those contained in SIMULATION_PARAMETERS
.sp
Simply accesses the _parameter_descriptions data stored in parameter_descriptions.json
.INDENT 7.0
.TP
.B Returns
string containing the parameter description or a dict containing all values if no key is supplied
.TP
.B Return type
str
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B get_richness(reference=1)
Get the system richness for the parameters associated with the supplied community reference.
.sp
\fBNOTE:\fP
.INDENT 7.0
.INDENT 3.5
Richness of 0 is returned if there has been some problem; it is assumed that species richness
will be above 0 for any simulation.
.UNINDENT
.UNINDENT
.sp
\fBNOTE:\fP
.INDENT 7.0
.INDENT 3.5
Values generated by this method should be identical to those produced by self.get_landscape_richness()
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Parameters
\fBreference\fP \-\- community reference which contains the parameters of interest
.TP
.B Returns
the system species richness
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B get_simulation_parameters(guild=None)
Reads the simulation parameters from the database and returns them.
.INDENT 7.0
.TP
.B Returns
a dictionary mapping names to values for seed, job_type, output_dir, speciation_rate, sigma, L_value, deme,
.UNINDENT
.sp
sample_size, maxtime, dispersal_relative_cost, min_spec, habitat_change_rate, gen_since_pristine, time_config,
coarse_map vars, fine map vars, sample_file, gridx, gridy, pristine coarse map, pristine fine map, sim_complete,
dispersal_method, m_probability, cutoff, infinite_landscape, protracted, min_speciation_gen, max_speciation_gen,
dispersal_map
.UNINDENT
.INDENT 7.0
.TP
.B get_species_abundances(fragment=None, reference=None)
Gets the species abundance for a particular fragment, speciation rate and time. If fragment is None, returns the
whole landscape species abundances.
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBfragment\fP \-\- the fragment to obtain the species abundance of. If None, returns landscape abundances.
.IP \(bu 2
\fBspeciation_rate\fP \-\- speciation rate to obtain abundances for
.IP \(bu 2
\fBtime\fP \-\- the time to obtain abundances for
.UNINDENT
.TP
.B Returns
list of species abundances [reference, species ID, speciation rate, number of individuals, generation]
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B get_species_list()
Gets the entirety of the SPECIES_LIST table, returning a tuple with an entry for each row. This can be used to
construct custom analyses of the coalescence tree.
.sp
\fBNOTE:\fP
.INDENT 7.0
.INDENT 3.5
The species list will be produced in an unprocessed format
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Returns
a list of each coalescence and speciation event, with locations, performed in the simulation
.TP
.B Return type
tuple
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B get_species_locations(community_reference=None)
Gets the list of species locations after coalescence.
.sp
If a community reference is provided, will return just the species for that community reference, otherwise
returns the whole table
.INDENT 7.0
.TP
.B Parameters
\fBcommunity_reference\fP (\fIint\fP) \-\- community reference number
.TP
.B Returns
a list of lists containing each row of the SPECIES_LOCATIONS table
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B import_comparison_data(filename, ignore_mismatch=False)
Imports the SQL database that contains the biodiversity metrics that we want to compare against.
.sp
This can either be real data (for comparing simulated data) or other simulated data (for comparing between models).
.sp
If the SQL database does not contain the relevant biodiversity metrics, they will be calculated (if possible) or skipped.
.sp
The expected form of the database is the same as the BIODIVERSITY_METRICS table, except without any speciation
rates or time references, and a new column containing the number of individuals involved in each metric.
.sp
\fBNOTE:\fP
.INDENT 7.0
.INDENT 3.5
This also equalises the comparison data if ignore_mismatch is not True, so that the number of individuals
is equal between the simulated and comparison datasets.
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBfilename\fP (\fIstr\fP) \-\- the file containing the comparison biodiversity metrics.
.IP \(bu 2
\fBignore_mismatch\fP (\fIbool\fP) \-\- set to true to ignore abundance mismatches between the comparison and simulated data.
.UNINDENT
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B is_completed()
Indicates whether the simulation has been performed to completion, or if the simulation has been paused and
needs to be completed before analysis can be performed.
.INDENT 7.0
.TP
.B Returns
bool: true if simulation is complete
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B is_protracted()
Indicates whether the simulation is a protracted simulation or not. This is read from the completed database file.
.INDENT 7.0
.TP
.B Returns
boolean, true if the simulation was performed with protracted speciation.
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B sample_fragment_richness(fragment, number_of_individuals, community_reference=1, n=1)
Samples from the database from FRAGMENT_ABUNDANCES, the desired number of individuals.
.sp
Randomly selects the desired number of individuals from the database n times and returns the mean richness for
the random samples.
.INDENT 7.0
.TP
.B Raises
\fBIOError\fP \-\- if the FRAGMENT_ABUNDANCES table does not exist in the database.
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBfragment\fP \-\- the reference of the fragment to aquire the richness for
.IP \(bu 2
\fBnumber_of_individuals\fP \-\- the number of individuals to sample
.IP \(bu 2
\fBcommunity_reference\fP \-\- the reference for the community parameters
.IP \(bu 2
\fBn\fP \-\- number of times to repeatedly sample
.UNINDENT
.TP
.B Returns
the mean of the richness from the repeats
.TP
.B Return type
float
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B sample_landscape_richness(number_of_individuals, n=1, community_reference=1)
Samples from the landscape the required number of individuals, returning the mean of the species richnesses
produced.
.sp
If number_of_individuals is a dictionary mapping fragment names to numbers sampled, will sample the respective
number from each fragment and return the whole landscape richness.
.INDENT 7.0
.TP
.B Raises
\fBKeyError\fP \-\- if the dictionary supplied contains more sampled individuals than exist in a fragment, or
if the fragment is not contained within the dictionary.
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBnumber_of_individuals\fP (\fIint/dict\fP) \-\- either an int containing the number of individuals to be sampled, or a
dictionary mapping fragment names to numbers of individuals to be sampled
.IP \(bu 2
\fBn\fP \-\- the number of repeats to average over
.IP \(bu 2
\fBcommunity_reference\fP \-\- the community reference to fetch abundances for
.UNINDENT
.TP
.B Returns
the mean of the richness from the repeats for the whole landscape
.TP
.B Return type
float
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B set_database(filename)
Sets the database to the specified file and opens the sqlite connection.
.sp
This must be done before any other operations can be performed and the
file must exist.
.INDENT 7.0
.TP
.B Raises
\fBIOError\fP \-\- if the simulation is not complete, as analysis can only be performed on complete simulations.
However, the database WILL be set before the error is thrown, allowing for analysis of
incomplete simulations if the error is handled correctly.
.TP
.B Parameters
\fBfilename\fP \-\- the SQLite database file to import
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B set_speciation_params(record_spatial, record_fragments, speciation_rates, sample_file=None, time_config_file=None, protracted_speciation_min=None, protracted_speciation_max=None, metacommunity_size=None, metacommunity_speciation_rate=None)
Set the parameters for the application of speciation rates. If no config files or time_config files are provided,
they will be taken from the main coalescence simulation.
.INDENT 7.0
.TP
.B Return type
None
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBstr record_spatial\fP (\fIbool\fP\fI,\fP) \-\- a boolean of whether to record spatial data
.IP \(bu 2
\fBstr record_fragments\fP (\fIbool\fP\fI,\fP) \-\- either a csv file containing fragment data, or T/F for whether fragments should be
calculated from squares of continuous habitat.
.IP \(bu 2
\fBspeciation_rates\fP (\fIlist\fP) \-\- a list of speciation rates to apply
.IP \(bu 2
\fBsample_file\fP (\fIstr\fP) \-\- a sample tif or csv specifying the sampling mask
.IP \(bu 2
\fBtime_config_file\fP (\fIstr\fP) \-\- a configuration file of temporal sampling points
.IP \(bu 2
\fBprotracted_speciation_min\fP (\fIfloat\fP) \-\- the minimum number of generations required for speciation to occur
.IP \(bu 2
\fBprotracted speciation_max\fP (\fIfloat\fP) \-\- the maximum number of generations before speciation occurs
.IP \(bu 2
\fBmetacommunity_size\fP (\fIfloat\fP) \-\- the size of the metacommunity to apply
.IP \(bu 2
\fBmetacommunity_speciation_rate\fP (\fIfloat\fP) \-\- speciation rate for the metacommunity
.UNINDENT
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B setup(speciation_program=\(aq/Users/samthompson/Documents/PhD/Code/pycoalescence/pycoalescence/build/default/SpeciationCounter\(aq)
Sets up the link to the SpeciationCounter program. Defaults to the build/default/SpeciationCounter
:param speciation_program: optionally provide a path to an alternative SpeciationCounter program.
.sp
Deprecated since version 1.2.4: Deprecated due to movement towards using python API for applying speciation rates.

.INDENT 7.0
.TP
.B Returns
None
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B wipe_data()
Wipes all calculated data apart from the original, unformatted coalescence tree.
The Speciation_Counter program will have to be re\-run to perform any analyses.
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B check_sql_table_exist(database, table_name)
Checks that the supplied table exists in the supplied database.
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBdatabase\fP \-\- the database to check existence in
.IP \(bu 2
\fBtable_name\fP \-\- the table name to check for
.UNINDENT
.TP
.B Returns
boolean of whether the table exists
.TP
.B Return type
bool
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B collate_fits(file_dir, filename=\(aqCollated_fits.db\(aq)
Collates the goodness of fit values from every file in the specified directory and places them in one new file.
.sp
\fBNOTE:\fP
.INDENT 7.0
.INDENT 3.5
Files with \(aqcollated\(aq in the name will be ignored.
.UNINDENT
.UNINDENT
.sp
\fBNOTE:\fP
.INDENT 7.0
.INDENT 3.5
If the output file exists, it will be deleted.
.UNINDENT
.UNINDENT
.sp
Creates three separate tables in the output file, one for overall goodness of fit, one for fragment richness fits,
and one for fragment octaves fits.
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBfile_dir\fP \-\- the file directory to examine
.IP \(bu 2
\fBfilename\fP \-\- [optional] the output file name.
.UNINDENT
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B fetch_table_from_sql(database, table_name)
Returns a list of the data contained by the provided table in the database.
.INDENT 7.0
.TP
.B Raises
\fBsqlite3.OperationalError\fP \-\- if the table is not contained in the database (protects SQL injections).
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBdatabase\fP \-\- the database to obtain from
.IP \(bu 2
\fBtable_name\fP \-\- the table name to fetch data from
.UNINDENT
.TP
.B Returns
a list of lists, containing all data within the provided table in the database
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B get_parameter_description(key=None)
Gets the parameter descriptions for the supplied key. If the key is None, returns all keys.
.INDENT 7.0
.TP
.B Parameters
\fBkey\fP \-\- the simulation parameter
.TP
.B Returns
string containing the parameter description or a dict containing all values if no key is supplied
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B isclose(a, b, rel_tol=1e\-09, abs_tol=0.0)
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBa\fP \-\- value 1
.IP \(bu 2
\fBb\fP \-\- value 2
.IP \(bu 2
\fBrel_tol\fP \-\- percentage relative to larger value
.IP \(bu 2
\fBabs_tol\fP \-\- absolute value for similarity
.UNINDENT
.TP
.B Returns
true for significantly different a and b, false otherwise
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B scale_simulation_fit(simulated_value, actual_value, number_individuals, total_individuals)
Calculates goodness of fit for the provided values, and scales based on the total number of individuals that exist.
The calculation is 1 \- (
.nf
|x \- y|
.fi
/max(x, y)) * n/n_tot for x, y simulated and actual values, n, n_tot for metric and total
number of individuals.
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBsimulated_value\fP \-\- the simulated value of the metric
.IP \(bu 2
\fBactual_value\fP \-\- the actual value of the metric
.IP \(bu 2
\fBnumber_individuals\fP \-\- the number of individuals this metric relates to
.IP \(bu 2
\fBtotal_individuals\fP \-\- the total number of individuals across all sites for this metric
.UNINDENT
.TP
.B Returns
the scaled fit value
.UNINDENT
.UNINDENT
.SS simulation module
.sp
Detailed here\&.
.sp
Contains the Simulation class as part of the pycoalescence package.
.sp
Operations involve setting up and running simulations, plus basic tree generation after simulations have been completed.
.INDENT 0.0
.TP
.B exception FileExistsError
Bases: \fBexceptions.IOError\fP
.UNINDENT
.INDENT 0.0
.TP
.B exception FileNotFoundError
Bases: \fBexceptions.IOError\fP
.UNINDENT
.INDENT 0.0
.TP
.B class Simulation(logging_level=30, log_output=None, **kwargs)
A class containing routines to set up and run simulations, including detecting map dimensions from tif files.
.INDENT 7.0
.TP
.B add_pristine_map(fine_map, coarse_map, time, rate)
Adds an extra map to the list of pristine maps.
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBfine_map\fP \-\- the pristine fine map file to add
.IP \(bu 2
\fBcoarse_map\fP \-\- the pristine coarse map file to add
.IP \(bu 2
\fBtime\fP \-\- the time to add (when the map is accurate)
.IP \(bu 2
\fBrate\fP \-\- the rate to add (the rate of habitat change at this time)
.UNINDENT
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B add_sample_time(time)
Adds an extra sample time to the list of times.
.sp
This allows for multiple temporal sample points from within the same simulation.
.INDENT 7.0
.TP
.B Parameters
\fBtime\fP \-\- the sample time to add
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B calculate_sql_database()
Saves the output database location to self.output_database.
.UNINDENT
.INDENT 7.0
.TP
.B check_maps()
Checks that the maps all exist and that the file structure makes sense.
.INDENT 7.0
.TP
.B Raises
.INDENT 7.0
.IP \(bu 2
\fBTypeError\fP \-\- if a dispersal map or reproduction map is specified, we must have a fine map specified, but
not a coarse map.
.IP \(bu 2
\fBIOError\fP \-\- if one of the required maps does not exist
.UNINDENT
.TP
.B Returns
None
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B check_sample_map_equals_sample_grid()
Checks if the grid and sample map are the same size and offset (in which case, future operations can be simplified"
:return:
.UNINDENT
.INDENT 7.0
.TP
.B check_simulation_params()
Checks that simulation parameters have been correctly set and the program is ready for running.
Note that these checks have not been fully tested and are probably unnecessary in a large number of cases.
.UNINDENT
.INDENT 7.0
.TP
.B check_sql_database(expected=False)
Checks whether the output database exists. If the existance does not match the expected variable, raises an
error.
.INDENT 7.0
.TP
.B Raises
.INDENT 7.0
.IP \(bu 2
\fBFileExistsError\fP \-\- if the file already exists when it\(aqs not expected to
.IP \(bu 2
\fBFileNotExistsError\fP \-\- if the file does not exist when we expect it to
.UNINDENT
.TP
.B Parameters
\fBexpected\fP \-\- boolean for expected existance of the output file
.UNINDENT
.sp
:rtype None
.UNINDENT
.INDENT 7.0
.TP
.B count_individuals()
Estimates the number of individuals to be simulated. This may be inaccurate if using multiple time points and
historical maps.
.INDENT 7.0
.TP
.B Returns
a count of the number of individuals to be simulated
.UNINDENT
.sp
:rtype float
.UNINDENT
.INDENT 7.0
.TP
.B create_config(output_file=None)
Generates the output config files. This version creates the concise version of the config file.
.INDENT 7.0
.TP
.B Parameters
\fBoutput_file\fP (\fIstr\fP) \-\- the file to generate the config option. Must be a path to a .txt file.
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B create_map_config(output_file=None)
Generates the map config file from reading the spatial structure of each of the provided files.
.INDENT 7.0
.TP
.B Parameters
\fBoutput_file\fP (\fIstr\fP) \-\- the file to output configuration data to (the map config file)
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B create_temporal_sampling_config(config_file=None)
Creates the time\-sampling config file
.INDENT 7.0
.TP
.B Parameters
\fBconfig_file\fP \-\- the config file to output to
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B detect_map_dimensions()
Detects all the map dimensions for the provided files (where possible) and sets the respective values.
This is intended to be run after set_map_files()
.INDENT 7.0
.TP
.B Raises
\fBTypeError\fP \-\- if a dispersal map or reproduction map is specified, we must have a fine map specified, but
.UNINDENT
.sp
not a coarse map.
:raises IOError: if one of the required maps does not exist
:raises ValueError: if the dimensions of the dispersal map do not make sense when used with the fine map
provided
.INDENT 7.0
.TP
.B Returns
None
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B estimate_ram_usage(grid_individuals)
Estimates the RAM usage for the program with the current parameters.
.sp
Note this estimates the upper bound of memory usage and is likely inaccurate, especially for simulations with
multiple time sampling points.
.INDENT 7.0
.TP
.B Parameters
\fBgrid_individuals\fP \-\- the number of individuals existing on the grid
.TP
.B Returns
the estimated RAM usage in bytes
.UNINDENT
.sp
:rtype float
.UNINDENT
.INDENT 7.0
.TP
.B finalise_setup(config_default=True, expected=False, ignore_errors=False)
Runs all setup routines to provide a complete simulation. Should be called immediately before run_coalescence()
to ensure the simulation setup is complete.
Calls check_simulation_params, generate_command() and run_checks()
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBconfig_default\fP \-\- set to false if want config file to only be created if necessary. Defaults to True
.IP \(bu 2
\fBignore_errors\fP \-\- if true, any FileNotFoundError and FileExistsError raised by checking the output database
.UNINDENT
.UNINDENT
.sp
are ignored
:param expected: set to true if we expect the output file to exist
.UNINDENT
.INDENT 7.0
.TP
.B generate_command()
Completes the setup process by creating the list that will be passed to the c++ executable
.UNINDENT
.INDENT 7.0
.TP
.B get_average_density()
Gets the average density across the fine map, subsetted for the sample grid.
.UNINDENT
.INDENT 7.0
.TP
.B get_optimised_solution()
Gets the optimised solution as a dictionary containing the important optimised variables.
This can be read back in with set_optimised_solution
.sp
:return dict containing the important optimised variables
:rtype dict
.UNINDENT
.INDENT 7.0
.TP
.B get_protracted()
Gets whether the simulation pointed to by this object is a protracted simulation or not.
.UNINDENT
.INDENT 7.0
.TP
.B get_richness(reference=1)
Calls coal_analyse.get_richness() with the supplied variables.
.sp
Requires successful import of coal_analyse and sqlite3.
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBspeciation_rate\fP \-\- the speciation rate to extract system richness from.
.IP \(bu 2
\fBtime\fP \-\- the time to extract system richness from
.UNINDENT
.TP
.B Returns
the species richness.
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B grid_density_actual(x_off, y_off, x_dim, y_dim)
Counts the density total for a subset of the grid by sampling from the fine map.
.sp
Note that for large maps this can take a very long time.
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBx_off\fP \-\- the x offset of the grid map subset
.IP \(bu 2
\fBy_off\fP \-\- the y offset of the grid map subset
.IP \(bu 2
\fBx_dim\fP \-\- the x dimension of the grid map subset
.IP \(bu 2
\fBy_dim\fP \-\- the y dimension of the grid map subset
.UNINDENT
.TP
.B Returns
the total individuals that exist in the subset.
.UNINDENT
.sp
:rtype int
.UNINDENT
.INDENT 7.0
.TP
.B grid_density_estimate(x_off, y_off, x_dim, y_dim)
Counts the density total for a subset of the grid by sampling from the fine map
.sp
Note that this function is an approximation (based on the average density of the fine map) and does not produce
a perfect value. This is done for performance reasons. The actual value can be obtained with
grid_density_actual().
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBx_off\fP \-\- the x offset of the grid map subset
.IP \(bu 2
\fBy_off\fP \-\- the y offset of the grid map subset
.IP \(bu 2
\fBx_dim\fP \-\- the x dimension of the grid map subset
.IP \(bu 2
\fBy_dim\fP \-\- the y dimension of the grid map subset
.UNINDENT
.TP
.B Returns
an estimate of the total individuals that exist in the subset.
.UNINDENT
.sp
:rtype int
.UNINDENT
.INDENT 7.0
.TP
.B import_fine_map_array()
Imports the fine map array to the in\-memory object, subsetted to the same size as the sample grid.
:rtype None
.UNINDENT
.INDENT 7.0
.TP
.B import_sample_map_array()
Imports the sample map array to the in\-memory object.
:rtype None
.UNINDENT
.INDENT 7.0
.TP
.B load_config(config_file)
Loads the config file by reading the lines in order.
.INDENT 7.0
.TP
.B Parameters
\fBconfig_file\fP (\fIstr\fP) \-\- the config file to read in.
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B optimise_ram(ram_limit=None)
Optimises the maps for a specific RAM usage.
.sp
If ram_limit is None, this function does nothing.
.sp
:note This function assumes that the c++ compiler has sizeof(long) = 8 bytes for calculating space usage.
.INDENT 7.0
.TP
.B Parameters
\fBram_limit\fP \-\- the desired amount of RAM to limit to, in GB
.TP
.B Raises
\fBMemoryError\fP \-\- if the desired simulation cannot be compressed into available RAM
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B persistent_ram_usage()
This is the persistent RAM usage which cannot be optimised by the program for a particular set of maps
:return: the total persistent RAM usage in bytes
.UNINDENT
.INDENT 7.0
.TP
.B resume_coalescence(pause_directory, seed, job_type, max_time, out_directory=None, protracted=None, spatial=None)
Resumes the simulation from the specified directory, looking for the simulation with the specified seed and task
referencing.
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBpause_directory\fP \-\- the directory to search for the paused simulation
.IP \(bu 2
\fBseed\fP \-\- the seed of the paused simulation
.IP \(bu 2
\fBjob_type\fP \-\- the task of the paused simulation
.IP \(bu 2
\fBmax_time\fP \-\- the maximum time to run simulations for
.IP \(bu 2
\fBout_directory\fP \-\- optionally provide an alternative output location. Defaults to same location as
.UNINDENT
.UNINDENT
.sp
pause_directory
:param bool protracted: protractedness of the simulation
:param bool spatial: if the simulation is to be run with spatial complexity
.INDENT 7.0
.TP
.B Returns
None
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B run_checks(expected=False)
Check that the simulation is correctly set up and that all the required files exist.
.INDENT 7.0
.TP
.B Parameters
\fBexpected\fP \-\- set to true if we expect the output file to already exist
.TP
.B Raises
\fBRuntimeError\fP \-\- if previous set\-up routines are not complete
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B run_coalescence()
Attempt to run the simulation with the given simulation set\-up.
This is the main routine performing the actual simulation which will take a considerable amount of time.
.UNINDENT
.INDENT 7.0
.TP
.B run_from_config(logger, config_file)
Calls NECSim to run from config within a new thread
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBlogger\fP \-\- 
.IP \(bu 2
\fBconfig_file\fP \-\- 
.UNINDENT
.TP
.B Returns

.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B run_simple(seed, task, output, alpha, sigma, size)
Runs a simple coalescence simulation on a square infinite landscape with the provided parameters.
This requires a separate compilation of the inf_land version of the coalescence simulator.
.sp
Note that this function returns richness=0 for failure to read from the file. It is assumed that there will
be at least one species in the simulation.
.sp
Note that the maximum time for this function is set as 10 hours (36000 seconds) and will raise an exception if
the simulation does not complete in this time).
.INDENT 7.0
.TP
.B Raises
\fBRuntimeError\fP \-\- if the simulation didn\(aqt complete in time.
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBseed\fP \-\- the simulation seed
.IP \(bu 2
\fBtask\fP \-\- the task (for file naming)
.IP \(bu 2
\fBoutput\fP \-\- the output directory
.IP \(bu 2
\fBalpha\fP \-\- the speciation rate
.IP \(bu 2
\fBsigma\fP \-\- the normal distribution sigma value for dispersal
.IP \(bu 2
\fBsize\fP \-\- the size of the world (so there will be size^2 individuals simulated)
.UNINDENT
.TP
.B Returns
the species richness in the simulation
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B set_map(map_file, x_size=None, y_size=None)
Quick function for setting a single map file for both the sample map and fine map, of dimensions x and y.
Sets the sample file to "null" and coarse file and pristine files to "none".
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBmap_file\fP (\fIstr\fP) \-\- path to the map file
.IP \(bu 2
\fBx_size\fP \-\- the x dimension, or None to detect automatically from the ".tif" file
.IP \(bu 2
\fBy_size\fP \-\- the y dimension, or None to detect automatically from the ".tif" file
.UNINDENT
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B set_map_config(file)
Sets a specific map config and tells the program that full commmand\-line parsing is not required.
.INDENT 7.0
.TP
.B Parameters
\fBfile\fP (\fIstr\fP) \-\- the file to read map config options from
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B set_map_files(sample_file, fine_file=None, coarse_file=None, pristine_fine_file=None, pristine_coarse_file=None, dispersal_map=None, reproduction_map=None)
Sets the map files (or to null, if none specified). It then calls detect_map_dimensions() to correctly read in
the specified dimensions.
Note that if sample_file is "null", values will remain at 0.
If coarse_file is "null", it will default to the size of fine_file with zero offset.
If the coarse file is "none", it will not be used.
If the pristine fine or coarse files are "none", they will not be used.
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBsample_file\fP (\fIstr\fP) \-\- the sample map file. Provide "null" if on samplemask is required
.IP \(bu 2
\fBfine_file\fP (\fIstr\fP) \-\- the fine map file. Defaults to "null" if none provided
.IP \(bu 2
\fBcoarse_file\fP (\fIstr\fP) \-\- the coarse map file. Defaults to "none" if none provided
.IP \(bu 2
\fBpristine_fine_file\fP (\fIstr\fP) \-\- the pristine fine map file. Defaults to "none" if none provided
.IP \(bu 2
\fBpristine_coarse_file\fP (\fIstr\fP) \-\- the pristine coarse map file. Defaults to "none" if none provided
.IP \(bu 2
\fBdispersal_map\fP (\fIstr\fP) \-\- the dispersal map for reading dispersal values. Default to "none" if none provided
.IP \(bu 2
\fBreproduction_map\fP (\fIstr\fP) \-\- a map of relative reproduction probabilities, at the scale of the fine map
.UNINDENT
.UNINDENT
.sp
:rtype None
.sp
:return None
.UNINDENT
.INDENT 7.0
.TP
.B set_map_parameters(sample_file, sample_x, sample_y, fine_file, fine_x, fine_y, fine_x_offset, fine_y_offset, coarse_file, coarse_x, coarse_y, coarse_x_offset, coarse_y_offset, coarse_scale, pristine_fine_map, pristine_coarse_map)
Set up the map objects with the required parameters. This is required for csv file usage.
.sp
Note that this function is not recommended for tif file usage, as it is much simpler to call set_map_files() and
which should automatically calculate map offsets, scaling and dimensions.
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBsample_file\fP \-\- the sample file to use, which should contain a boolean mask of where to sample
.IP \(bu 2
\fBsample_x\fP \-\- the x dimension of the sample file
.IP \(bu 2
\fBsample_y\fP \-\- the y dimension of the sample file
.IP \(bu 2
\fBfine_file\fP \-\- the fine map file to use (must be equal to or larger than the sample file)
.IP \(bu 2
\fBfine_x\fP \-\- the x dimension of the fine map file
.IP \(bu 2
\fBfine_y\fP \-\- the y dimension of the fine map file
.IP \(bu 2
\fBfine_x_offset\fP \-\- the x offset of the fine map file
.IP \(bu 2
\fBfine_y_offset\fP \-\- the y offset of the fine map file
.IP \(bu 2
\fBcoarse_file\fP \-\- the coarse map file to use (must be equal to or larger than fine map file)
.IP \(bu 2
\fBcoarse_x\fP \-\- the x dimension of the coarse map file
.IP \(bu 2
\fBcoarse_y\fP \-\- the y dimension of the coarse map file
.IP \(bu 2
\fBcoarse_x_offset\fP \-\- the x offset of the coarse map file at the resolution of the fine map
.IP \(bu 2
\fBcoarse_y_offset\fP \-\- the y offset of the coarse map file at the resoultion of the fine map
.IP \(bu 2
\fBcoarse_scale\fP \-\- the relative scale of the coarse map compared to the fine map (must match x and y scaling)
.IP \(bu 2
\fBpristine_fine_map\fP \-\- the pristine fine map file to use (must have dimensions equal to fine map)
.IP \(bu 2
\fBpristine_coarse_map\fP \-\- the pristine coarse map file to use (must have dimensions equal to coarse map)
.UNINDENT
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B set_optimised_solution(dict_in)
Sets the optimised RAM solution from the variables in the provided dictionary.
This should contain the grid_x_size, grid_y_size, grid_file_name, sample_x_offset and sample_y_offset.
.INDENT 7.0
.TP
.B Parameters
\fBdict_in\fP (\fIdict\fP) \-\- the dictionary containing the optimised RAM solution variables
.UNINDENT
.sp
:rtype None
.UNINDENT
.INDENT 7.0
.TP
.B set_simulation_params(seed, job_type, output_directory, min_speciation_rate, sigma=1.0, tau=1.0, deme=1, sample_size=1.0, max_time=3600, dispersal_method=None, m_prob=0.0, cutoff=0, dispersal_relative_cost=1, min_num_species=1, habitat_change_rate=0.0, gen_since_pristine=1, time_config_file=\(aqnull\(aq, restrict_self=False, infinite_landscape=False, protracted=False, min_speciation_gen=None, max_speciation_gen=None, spatial=True, uses_spatial_sampling=False)
Set all the simulation parameters apart from the map objects.
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBseed\fP (\fIint\fP) \-\- the unique job number for this simulation set
.IP \(bu 2
\fBjob_type\fP (\fIint\fP) \-\- the job type (used for easy file identification after simulations are complete)
.IP \(bu 2
\fBoutput_directory\fP (\fIstr\fP) \-\- the output directory to store the SQL database
.IP \(bu 2
\fBmin_speciation_rate\fP (\fIfloat\fP) \-\- the minimum speciation rate to simulate
.IP \(bu 2
\fBsigma\fP (\fIfloat\fP) \-\- the dispersal sigma value
.IP \(bu 2
\fBtau\fP (\fIfloat\fP) \-\- the fat\-tailed dispersal tau value
.IP \(bu 2
\fBdeme\fP (\fIint\fP) \-\- the deme size (in individuals per cell)
.IP \(bu 2
\fBsample_size\fP (\fIfloat\fP) \-\- the sample size of the deme (decimal 0\-1)
.IP \(bu 2
\fBmax_time\fP (\fIfloat\fP) \-\- the maximum allowed simulation time (in seconds)
.IP \(bu 2
\fBdispersal_method\fP (\fIstr\fP) \-\- the dispersal kernel method. Should be one of [normal, fat\-tail, norm\-uniform]
.IP \(bu 2
\fBm_prob\fP (\fIfloat\fP) \-\- the probability of drawing from the uniform dispersal. Only relevant for uniform dispersals
.IP \(bu 2
\fBcutoff\fP (\fIfloat\fP) \-\- the maximum value for the uniform dispersal. Only relevant for uniform dispersals.
.IP \(bu 2
\fBdispersal_relative_cost\fP (\fIfloat\fP) \-\- the relative cost of travelling through non\-habitat (defaults to 1)
.IP \(bu 2
\fBmin_num_species\fP (\fIint\fP) \-\- the minimum number of species known to exist (defaults to 1
.IP \(bu 2
\fBhabitat_change_rate\fP (\fIfloat\fP) \-\- the rate of habitat change over time
.IP \(bu 2
\fBgen_since_pristine\fP (\fIfloat\fP) \-\- the time in generations since a pristine state was achieved
.IP \(bu 2
\fBtime_config_file\fP (\fIstr\fP) \-\- the path to the time config file (or null)
.IP \(bu 2
\fBrestrict_self\fP (\fIbool\fP) \-\- if true, restricts dispersal from own cell
.IP \(bu 2
\fBinfinite_landscape\fP (\fIbool/str\fP) \-\- if false or "closed", restricts dispersal to the provided maps, otherwise
.UNINDENT
.UNINDENT
.sp
can be "infinite", or a tiled landscape using "tiled_coarse" or "tiled_fine".
:param bool protracted: if true, uses protracted speciation application
:param float min_speciation_gen: the minimum amount of time a lineage must exist before speciation occurs.
:param float max_speciation_gen: the maximum amount of time a lineage can exist before speciating.
:param bool spatial: if true, means that the simulation is spatial
:param bool uses_spatial_sampling: if true, the sample mask is interpreted as a proportional sampling mask,
.INDENT 7.0
.INDENT 3.5
where the number of individuals sampled in the cell is equal to the
density * deme_sample * cell sampling proportion
.UNINDENT
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B set_speciation_rates(speciation_rates)
Add speciation rates for analysis at the end of the simulation. This is optional
.INDENT 7.0
.TP
.B Parameters
\fBspeciation_rates\fP (\fIlist\fP) \-\- a list of speciation rates to apply at the end of the simulation
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B setup(coalescence_simulator=\(aq/Users/samthompson/Documents/PhD/Code/pycoalescence/pycoalescence/build/default/./NECSim\(aq)
Set the location of the coalescence and speciation executables. Make sure that both programs have been compiled
for the operating system running the simulations.
.INDENT 7.0
.TP
.B Parameters
\fBcoalescence_simulator\fP (\fIstr\fP) \-\- the path to the Coal_v1 executable
.UNINDENT
.sp
Deprecated since version 1.2.4: No longer required as of 1.2.4 as all components have been migrated to use Python API

.INDENT 7.0
.TP
.B Returns
None
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B setup_necsim()
Sets the logging function and the logger object for the necsim object. Enforcing this function is always called
ensures no seg faults occur.
.UNINDENT
.UNINDENT
.SS fragments module
.sp
Detailed here\&.
.sp
Contains the FragmentedLandscape class for creating a fragmented landscape using hexagonal packing and an even spread of
individuals between fragments. Requires scipy and matplotlib.
.INDENT 0.0
.TP
.B exception FileExistsError
Bases: \fBexceptions.IOError\fP
.UNINDENT
.INDENT 0.0
.TP
.B class Fragment(x=None, y=None)
Simple class containing the centres of fragments for a fragmented landscape
.INDENT 7.0
.TP
.B place_on_grid()
Changes the x and y positions to integers (always rounds down).
.INDENT 7.0
.TP
.B Return type
None
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B setup(x, y)
Sets up the fragment from the x and y position.
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBx\fP \-\- the x position of the fragment centre
.IP \(bu 2
\fBy\fP \-\- the y position of the fragment centre
.UNINDENT
.TP
.B Return type
None
.UNINDENT
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B class FragmentedLandscape(number_fragments=None, size=None, total=None, output_file=None)
Contains hexagonal packing algorithms for spacing clumps evenly on the landscape. Includes a LLoyd\(aqs smoothing
algorithm for better spacing of fragments.
.sp
\fBNOTE:\fP
.INDENT 7.0
.INDENT 3.5
Fragments will not be distinct units for unfragmented landscapes (with above around 50% habitat cover).
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B create(override_smoothing=None, n=10)
Creates the landscape, including running the hexagonal packing and smoothing algorithms (if required).
.sp
\fBNOTE:\fP
.INDENT 7.0
.INDENT 3.5
smoothing is recommended for any landscape that is doesn\(aqt contain a square number of fragments.
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBoverride_smoothing\fP \-\- if true, overrides the default smoothing settings (enabled for landscapes with fewer
than 100000 fragments.
.IP \(bu 2
\fBn\fP \-\- the number of iterations to run Lloyd\(aqs algorithm for
.UNINDENT
.TP
.B Return type
None
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B fill_grid()
Distributes the sizes evenly between the fragments, generating the actual landscape.
.INDENT 7.0
.TP
.B Return type
None
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B generate(override_smoothing=None, n=10)
Convenience function for creating fragments in one function. Generates the landscape and writes out to the
output file.
.sp
If smoothing is true, will run Lloyd\(aqs algorithm
after the hexagonal packing algorithm to increase the equality of the spacing.
.sp
\fBNOTE:\fP
.INDENT 7.0
.INDENT 3.5
smoothing is recommended for any landscape that is doesn\(aqt contain a square number of fragments.
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBoverride_smoothing\fP \-\- if true, overrides the default smoothing settings (enabled for landscapes with fewer
than 100000 fragments.
.IP \(bu 2
\fBn\fP \-\- the number of iterations to run Lloyd\(aqs algorithm for
.UNINDENT
.TP
.B Return type
None
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B place_fragments(smoothing=True, n=10)
Places the fragments evenly on the landscape. If smoothing is true, will run Lloyd\(aqs algorithm after the
hexagonal packing algorithm to increase the equality of the spacing.
.sp
\fBNOTE:\fP
.INDENT 7.0
.INDENT 3.5
smoothing is recommended for any landscape that is doesn\(aqt contain a square number of fragments.
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBsmoothing\fP \-\- if true, runs Lloyd\(aqs algorithm after the hexagonal packing
.IP \(bu 2
\fBn\fP \-\- the number of iterations to run Lloyd\(aqs algorithm for
.UNINDENT
.TP
.B Return type
None
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B plot()
Returns a matplotlib.pyplot.figure object containing an image of the fragmented landscape (with axes removed).
.sp
Requires that the fragmented landscape has been created already using \fI\%create()\fP\&.
.INDENT 7.0
.TP
.B Returns
figure object containing the fragmented landscape.
.TP
.B Return type
matplotlib.pyplot.figure
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B setup(number_fragments, size, total, output_file)
Sets up the landscape by checking parameters and setting object sizes.
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBnumber_fragments\fP \-\- the number of individual fragments to exist on the landscape
.IP \(bu 2
\fBsize\fP \-\- the size of the x and y dimensions of the landscape
.IP \(bu 2
\fBtotal\fP \-\- the total number of individuals to place on the landscape
.IP \(bu 2
\fBoutput_file\fP \-\- the output tif file to write the output to
.UNINDENT
.TP
.B Return type
None
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B write_to_raster()
Writes the landscape to a tif file.
.INDENT 7.0
.TP
.B Raises
\fBFileExistsError\fP \-\- if the output file already exists
.TP
.B Parameters
\fBoutput_file\fP \-\- the path to the tif file to write out to.
.TP
.B Return type
None
.UNINDENT
.UNINDENT
.UNINDENT
.SS map module
.sp
Detailed here\&.
.sp
Contains the Map class as part of the PyCoalescence Project.
.sp
Operations involve simulating dispersal kernels on maps, detecting map file dimensions and obtaining offsets between
maps.
.INDENT 0.0
.TP
.B class Map(file=None, is_sample=None, logging_level=30, dispersal_db=None)
Bases: \fBobject\fP
.sp
A class for the map object, containing the file name and the variables associated with this map object.
.sp
The internal array of the tif file is stored in self.data, and band 1 of the file can be opened by using
open()
.INDENT 7.0
.TP
.B Variables
\fBdata\fP \-\- if the map file has been opened, contains the full tif data as a numpy array.
.UNINDENT
.INDENT 7.0
.TP
.B calculate_offset(file_offset)
Calculates the offset of the map object from the supplied file_offset.
.INDENT 7.0
.TP
.B Parameters
\fBfile_offset\fP (\fIstr/Map\fP) \-\- the path to the file to calculate the offset.
Can also be a Map object with the filename contained.
.TP
.B Returns
the offset x and y (at the resolution of the file_home) in integers
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B calculate_scale(file_scaled)
Calculates the scale of map object from the supplied file_scaled.
.INDENT 7.0
.TP
.B Parameters
\fBfile_scaled\fP (\fIstr/Map\fP) \-\- the path to the file to calculate the scale.
.TP
.B Returns
the scale (of the x dimension)
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B check_map()
Checks that the dimensions for the map have been set and that the map file exists
.UNINDENT
.INDENT 7.0
.TP
.B create(file)
Create the file output and writes the grid to the output.
:param file: the output file to create
.UNINDENT
.INDENT 7.0
.TP
.B get_cached_subset(x_offset, y_offset, x_size, y_size)
Gets a subset of the map file, BUT rounds all numbers to integers to save RAM and keeps the entire array in
memory to speed up fetches.
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBx_offset\fP \-\- the x offset from the top left corner of the map
.IP \(bu 2
\fBy_offset\fP \-\- the y offset from the top left corner of the map
.IP \(bu 2
\fBx_size\fP \-\- the x size of the subset to obtain
.IP \(bu 2
\fBy_size\fP \-\- the y size of the subset to obtain
.UNINDENT
.TP
.B Returns
a numpy array containing the subsetted data
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B get_database_parameters()
Gets the dispersal simulation parameters from the dispersal_db
:return: the dispersal simulation parameters
.UNINDENT
.INDENT 7.0
.TP
.B get_dimensions()
Calls read_dimensions() if dimensions have not been read, or reads stored information.
.INDENT 7.0
.TP
.B Returns
a list containing [0] x, [1] y, [2] upper left x, [3] upper left y, [4] x resolution, [5] y resolution
.UNINDENT
.sp
\fBNOTE:\fP
.INDENT 7.0
.INDENT 3.5
the returned list will contain the x and y offset values instead of the ulx and uly values if the
dimensions have already been set (i.e. self.x_size != 0 and self.y_size != 0)
.UNINDENT
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B get_mean_dispersal(database=None, parameter_reference=1)
Gets the mean dispersal for the map if test_mean_dispersal has already been run.
.INDENT 7.0
.TP
.B Raises
ValueError if dispersal_database is None and so test_average_dispersal() has not been run
.TP
.B Raises
IOError if the output database does not exist
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBdatabase\fP (\fIstr\fP) \-\- the database to open
.IP \(bu 2
\fBparameter_reference\fP (\fIint\fP) \-\- the parameter reference to use (or 1 for default parameter reference).
.UNINDENT
.TP
.B Returns
mean dispersal from the database
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B get_mean_distance_travelled(database=None, parameter_reference=1)
Gets the mean dispersal for the map if test_mean_dispersal has already been run.
.INDENT 7.0
.TP
.B Raises
ValueError if dispersal_database is None and so test_average_dispersal() has not been run
.TP
.B Raises
IOError if the output database does not exist
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBdatabase\fP (\fIstr\fP) \-\- the database to open
.IP \(bu 2
\fBparameter_reference\fP (\fIint\fP) \-\- the parameter reference to use (or 1 for default parameter reference).
.UNINDENT
.TP
.B Returns
mean of dispersal from the database
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B get_stdev_dispersal(database=None, parameter_reference=1)
Gets the standard deviation of dispersal for the map if test_mean_dispersal has already been run.
.INDENT 7.0
.TP
.B Raises
ValueError if dispersal_database is None and so test_average_dispersal() has not been run
.TP
.B Raises
IOError if the output database does not exist
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBdatabase\fP (\fIstr\fP) \-\- the database to open
.IP \(bu 2
\fBparameter_reference\fP (\fIint\fP) \-\- the parameter reference to use (or 1 for default parameter reference).
.UNINDENT
.TP
.B Returns
standard deviation of dispersal from the database
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B get_stdev_distance_travelled(database=None, parameter_reference=1)
Gets the standard deviation of the  distance travelled for the map if test_mean_distance_travelled has already
been run.
.INDENT 7.0
.TP
.B Raises
ValueError if dispersal_database is None and so test_average_dispersal() has not been run
.TP
.B Raises
IOError if the output database does not exist
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBdatabase\fP (\fIstr\fP) \-\- the database to open
.IP \(bu 2
\fBparameter_reference\fP (\fIint\fP) \-\- the parameter reference to use (or 1 for default parameter reference).
.UNINDENT
.TP
.B Returns
standard deviation of dispersal from the database
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B get_subset(x_offset, y_offset, x_size, y_size)
Gets a subset of the map file
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBx_offset\fP \-\- the x offset from the top left corner of the map
.IP \(bu 2
\fBy_offset\fP \-\- the y offset from the top left corner of the map
.IP \(bu 2
\fBx_size\fP \-\- the x size of the subset to obtain
.IP \(bu 2
\fBy_size\fP \-\- the y size of the subset to obtain
.UNINDENT
.TP
.B Returns
a numpy array containing the subsetted data
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B get_x_y()
Simply returns the x and y dimension of the file.
.INDENT 7.0
.TP
.B Returns
the x and y dimensions
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B open(file=None, band_no=1)
Reads the raster file from memory into the data object.
This allows direct access to the internal numpy array using the data object.
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBfile\fP (\fIstr\fP) \-\- path to file to open (or None to use self.file_name
.IP \(bu 2
\fBband_no\fP (\fIint\fP) \-\- the band number to read from
.UNINDENT
.TP
.B Return type
None
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B read_dimensions()
Return a list containing the geospatial coordinate system for the file.
.INDENT 7.0
.TP
.B Returns
a list containing [0] x, [1] y, [2] upper left x, [3] upper left y, [4] x resolution, [5] y resolution
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B set_dimensions(file_name=None, x_size=None, y_size=None, x_offset=None, y_offset=None)
Sets the dimensions and file for the Map object
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBfile_name\fP (\fIstr\fP) \-\- the location of the map object (a csv or tif file). If None, required that file_name is already provided.
.IP \(bu 2
\fBx_size\fP (\fIint\fP) \-\- the x dimension
.IP \(bu 2
\fBy_size\fP (\fIint\fP) \-\- the y dimension
.IP \(bu 2
\fBx_offset\fP (\fIint\fP) \-\- the x offset from the north\-west corner
.IP \(bu 2
\fBy_offset\fP (\fIint\fP) \-\- the y offset from the north\-west corner
.UNINDENT
.TP
.B Returns
None
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B set_sample(is_sample)
Set the is_sample attribute to true if this is a sample mask rather than an offset map
.INDENT 7.0
.TP
.B Parameters
\fBis_sample\fP (\fIbool\fP) \-\- indicates this is a sample mask rather than offset map
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B test_mean_dispersal(number_repeats, output_database=\(aqoutput.db\(aq, map_file=None, seed=1, dispersal_method=\(aqnormal\(aq, landscape_type=\(aqtiled\(aq, sigma=1, tau=1, m_prob=0.0, cutoff=100, sequential=False)
Tests the dispersal kernel on the provided map, producing a database containing each dispersal distance for
analysis purposes.
.sp
\fBNOTE:\fP
.INDENT 7.0
.INDENT 3.5
should be equivalent to \fI\%test_mean_distance_travelled()\fP with number_steps = 1
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBnumber_repeats\fP (\fIint\fP) \-\- the number of times to iterate on the map
.IP \(bu 2
\fBoutput_database\fP (\fIstr\fP) \-\- the path to the output database
.IP \(bu 2
\fBmap_file\fP (\fIstr\fP) \-\- the path to the map file to iterate on
.IP \(bu 2
\fBseed\fP (\fIint\fP) \-\- the random seed
.IP \(bu 2
\fBdispersal_method\fP (\fIstr\fP) \-\- the dispersal method to use ("normal", "fat\-tailed" or "norm\-uniform")
.IP \(bu 2
\fBlandscape_type\fP (\fIstr\fP) \-\- the landscape type to use ("infinite", "tiled" or "closed")
.IP \(bu 2
\fBsigma\fP (\fIfloat\fP) \-\- the sigma value to use for normal and norm\-uniform dispersal
.IP \(bu 2
\fBtau\fP (\fIfloat\fP) \-\- the tau value to use for fat\-tailed dispersal
.IP \(bu 2
\fBm_prob\fP (\fIfloat\fP) \-\- the m_prob to use for norm\-uniform dispersal
.IP \(bu 2
\fBcutoff\fP (\fIfloat\fP) \-\- the cutoff value to use for norm\-uniform dispersal
.IP \(bu 2
\fBsequential\fP (\fIbool\fP) \-\- if true, end locations of one dispersal event are used as the start for the next. Otherwise,
.UNINDENT
.UNINDENT
.sp
a new random cell is chosen
.UNINDENT
.INDENT 7.0
.TP
.B test_mean_distance_travelled(number_repeats, number_steps, output_database=\(aqoutput.db\(aq, map_file=None, seed=1, dispersal_method=\(aqnormal\(aq, landscape_type=\(aqtiled\(aq, sigma=1, tau=1, m_prob=0.0, cutoff=100)
Tests the dispersal kernel on the provided map, producing a database containing the average distance travelled
after number_steps have been moved.
.sp
\fBNOTE:\fP
.INDENT 7.0
.INDENT 3.5
mean distance travelled with number_steps=1 should be equivalent to running
\fI\%test_mean_dispersal()\fP
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBnumber_repeats\fP (\fIint\fP) \-\- the number of times to iterate on the map
.IP \(bu 2
\fBnumber_steps\fP (\fIint\fP) \-\- the number of steps to take each time before recording the distance travelled
.IP \(bu 2
\fBoutput_database\fP (\fIstr\fP) \-\- the path to the output database
.IP \(bu 2
\fBmap_file\fP (\fIstr\fP) \-\- the path to the map file to iterate on
.IP \(bu 2
\fBseed\fP (\fIint\fP) \-\- the random seed
.IP \(bu 2
\fBdispersal_method\fP (\fIstr\fP) \-\- the dispersal method to use ("normal", "fat\-tailed" or "norm\-uniform")
.IP \(bu 2
\fBlandscape_type\fP (\fIstr\fP) \-\- the landscape type to use ("infinite", "tiled" or "closed")
.IP \(bu 2
\fBsigma\fP (\fIfloat\fP) \-\- the sigma value to use for normal and norm\-uniform dispersal
.IP \(bu 2
\fBtau\fP (\fIfloat\fP) \-\- the tau value to use for fat\-tailed dispersal
.IP \(bu 2
\fBm_prob\fP (\fIfloat\fP) \-\- the m_prob to use for norm\-uniform dispersal
.IP \(bu 2
\fBcutoff\fP (\fIfloat\fP) \-\- the cutoff value to use for norm\-uniform dispersal
.UNINDENT
.TP
.B Returns

.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B write(file=None, band_no=None)
Writes the array in self.data to the output array.
The output file must exist, and the array will be overridden in the band.
Intended for writing changes to the same file the data was read from.
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBfile\fP \-\- the path to the file to write to
.IP \(bu 2
\fBband_no\fP \-\- the band number to write into
.UNINDENT
.UNINDENT
.sp
:rtype None
.UNINDENT
.INDENT 7.0
.TP
.B zero_offsets()
Sets the x and y offsets to 0
.UNINDENT
.UNINDENT
.SS setup file
.sp
Sets up the NECSim executables. It configures the install by detecting system components and compiles the \fBc++\fP files,
if possible. Command line flags can be provided (see Compilation Options for more
information) to modify the install.
.INDENT 0.0
.TP
.B autoconf()
Runs the \fIautoconf\fP bash function (assuming that autoconf is available) to create the \fIconfigure\fP executable.
.UNINDENT
.INDENT 0.0
.TP
.B backup_makefile()
Copies the makefile to a saved folder so that even if the original is overwritten, the last successful
compilation can be recorded.
.UNINDENT
.INDENT 0.0
.TP
.B clean()
Runs make clean in the NECSim directory to wipe any previous potential compile attempts.
.UNINDENT
.INDENT 0.0
.TP
.B configure(opts=None)
Runs ./configure \-\-opts with the supplied options. This should create the makefile for compilation, otherwise a
RuntimeError will be thrown.
.INDENT 7.0
.TP
.B Parameters
\fBopts\fP \-\- a list of options to pass to the ./configure call
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B configure_and_compile(argv=[None], logging_level=20)
Calls the configure script, then runs the compilation.
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBargv\fP \-\- the arguments to pass to configure script
.IP \(bu 2
\fBlogging_level\fP \-\- the logging level to utilise (defaults to INFO).
.UNINDENT
.TP
.B Return type
None
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B copy_makefile()
Copies the backup makefile to the main directory, if it exists.
Throws an IOError if no makefile is found.
.UNINDENT
.INDENT 0.0
.TP
.B do_compile()
Compiles the c++ NECSim program by running make. This changes the working directory to wherever the module has been
installed for the subprocess call.
.UNINDENT
.INDENT 0.0
.TP
.B get_build_dir()
Gets the build directory for this python version.
:return: the build directory path for the current python interpreter
.UNINDENT
.INDENT 0.0
.TP
.B get_compilation_flags(display_warnings=False)
Generates the compilation flags for passing to ./configure.
:param display_warnings: If true, runs with the \-Wall flag for compilation (displaying all warnings). Default is False.
.INDENT 7.0
.TP
.B Returns
list of compilation flags.
.TP
.B Return type
list
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B move_executable(directory=\(aq/Users/samthompson/Documents/PhD/Code/pycoalescence/pycoalescence/build/default/\(aq)
Moves the executable to the specified directory from within NECSim. Will always look for NECSim relative to the
setup.py (so can be called from another module location).
This allows for multiple compilation options with different versions stored in different folders.
.sp
Throws an IOError when the NECSim executable is not found.
.INDENT 7.0
.TP
.B Parameters
\fBdirectory\fP \-\- the directory to move the NECSim excecutable to.
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B move_shared_object_file()
Moves the shared object (.so) file to the build directory.
:return:
.UNINDENT
.INDENT 0.0
.TP
.B run_configure(argv=[None], logging_level=20, display_warnings=False)
Configures the install for compile options provided via the command line, or with default options if no options exist.
Running with \fB\-help\fP or \fI\-h\fP will display the compilation configurations called from \fB\&./configure\fP\&.
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBargv\fP \-\- the arguments to pass to configure script
.IP \(bu 2
\fBlogging_level\fP \-\- the logging level to utilise (defaults to INFO).
.IP \(bu 2
\fBdisplay_warnings\fP \-\- If true, runs with the \-Wall flag for compilation (displaying all warnings). Default is False.
.UNINDENT
.UNINDENT
.UNINDENT
.SS hpc_setup file
.sp
Sets up pycoalescence for usage on HPC systems, including providing intel compiler flags for optimisation, and specific
verbose patterns to add support for certain types of file systems.
.INDENT 0.0
.TP
.B build_hpc()
Compiles NECSim with the \fB\-\-with\-hpc\fP and \fB\-\-with\-verbose\fP flags, which adds extra support for intel compilers
and provides a selection of optimisation flags for high\-performance systems.
:return:
.UNINDENT
.INDENT 0.0
.IP \(bu 2
genindex
.IP \(bu 2
modindex
.IP \(bu 2
search
.UNINDENT
.sp
Version 1.2.5
.IP [Hubbell2001] 5
Hubbell, S. P. (2001). The Unified Neutral Theory of Biodiversity and Biogeography. Monographs in Population Biology, 17(3), 375. \fI\%http://doi.org/10.1016/S0006\-3207(02)00228\-8\fP
.SH AUTHOR
Samuel Thompson
.SH COPYRIGHT
2016, Samuel Thompson
.\" Generated by docutils manpage writer.
.
