%% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,english]{sphinxmanual}
\ifdefined\pdfpxdimen
   \let\sphinxpxdimen\pdfpxdimen\else\newdimen\sphinxpxdimen
\fi \sphinxpxdimen=49336sp\relax

\usepackage[margin=1in,marginparwidth=0.5in]{geometry}
\usepackage[utf8]{inputenc}
\ifdefined\DeclareUnicodeCharacter
  \DeclareUnicodeCharacter{00A0}{\nobreakspace}
\fi
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb,amstext}
\usepackage{babel}
\usepackage{times}
\usepackage[Bjarne]{fncychap}
\usepackage{longtable}
\usepackage{sphinx}

\usepackage{multirow}
\usepackage{eqparbox}

% Include hyperref last.
\usepackage{hyperref}
% Fix anchor placement for figures with captions.
\usepackage{hypcap}% it must be loaded after hyperref.
% Set up styles of URL: it should be placed after hyperref.
\urlstyle{same}

\addto\captionsenglish{\renewcommand{\figurename}{Fig.}}
\addto\captionsenglish{\renewcommand{\tablename}{Table}}
\addto\captionsenglish{\renewcommand{\literalblockname}{Listing}}

\addto\extrasenglish{\def\pageautorefname{page}}

\setcounter{tocdepth}{1}



\title{PyCoalescence Documentation}
\date{Mar 13, 2017}
\release{1.1.0rc1}
\author{Samuel Thompson}
\newcommand{\sphinxlogo}{\sphinxincludegraphics{PyCoal_logo.png}\par}
\renewcommand{\releasename}{Release}
\makeindex

\begin{document}

\maketitle
\sphinxtableofcontents
\phantomsection\label{\detokenize{index::doc}}


\begin{sphinxShadowBox}
\begin{itemize}
\item {} 
\phantomsection\label{\detokenize{index:id2}}{\hyperref[\detokenize{index:introduction}]{\sphinxcrossref{Introduction}}}

\item {} 
\phantomsection\label{\detokenize{index:id3}}{\hyperref[\detokenize{index:how-to}]{\sphinxcrossref{How-to}}}
\begin{itemize}
\item {} 
\phantomsection\label{\detokenize{index:id4}}{\hyperref[\detokenize{index:installation}]{\sphinxcrossref{Installation}}}

\item {} 
\phantomsection\label{\detokenize{index:id5}}{\hyperref[\detokenize{index:performing-simulations}]{\sphinxcrossref{Performing simulations}}}

\item {} 
\phantomsection\label{\detokenize{index:id6}}{\hyperref[\detokenize{index:post-simulation-analysis}]{\sphinxcrossref{Post-simulation analysis}}}

\item {} 
\phantomsection\label{\detokenize{index:id7}}{\hyperref[\detokenize{index:extended-analysis}]{\sphinxcrossref{Extended analysis}}}

\item {} 
\phantomsection\label{\detokenize{index:id8}}{\hyperref[\detokenize{index:testing-install}]{\sphinxcrossref{Testing install}}}

\end{itemize}

\item {} 
\phantomsection\label{\detokenize{index:id9}}{\hyperref[\detokenize{index:prerequisites}]{\sphinxcrossref{Prerequisites}}}
\begin{itemize}
\item {} 
\phantomsection\label{\detokenize{index:id10}}{\hyperref[\detokenize{index:essential}]{\sphinxcrossref{Essential}}}

\item {} 
\phantomsection\label{\detokenize{index:id11}}{\hyperref[\detokenize{index:recommended}]{\sphinxcrossref{Recommended}}}

\end{itemize}

\item {} 
\phantomsection\label{\detokenize{index:id12}}{\hyperref[\detokenize{index:glossary}]{\sphinxcrossref{Glossary}}}

\item {} 
\phantomsection\label{\detokenize{index:id13}}{\hyperref[\detokenize{index:contacts}]{\sphinxcrossref{Contacts}}}

\item {} 
\phantomsection\label{\detokenize{index:id14}}{\hyperref[\detokenize{index:code-documentation}]{\sphinxcrossref{Code Documentation}}}

\end{itemize}
\end{sphinxShadowBox}


\chapter{Introduction}
\label{\detokenize{index:introduction}}\label{\detokenize{index:pycoalescence}}
PyCoalescence is a python module for the spatially-explicit coalescence
neutral simulator, described
{\hyperref[\detokenize{Exhaled/exhaled_library:introduction-necsim}]{\sphinxcrossref{\DUrole{std,std-ref}{here}}}}. In its
finished form, PyCoalescence will provide a pythonic interface for
setting up, running and analysing spatially-explicit neutral
simulations. It allows for much swifter and cleaner creation of
configuration files and setting of simulation parameters.


\chapter{How-to}
\label{\detokenize{index:how-to}}
\begin{sphinxShadowBox}
\begin{itemize}
\item {} 
\phantomsection\label{\detokenize{index:id15}}{\hyperref[\detokenize{index:installation}]{\sphinxcrossref{Installation}}}

\item {} 
\phantomsection\label{\detokenize{index:id16}}{\hyperref[\detokenize{index:performing-simulations}]{\sphinxcrossref{Performing simulations}}}

\item {} 
\phantomsection\label{\detokenize{index:id17}}{\hyperref[\detokenize{index:post-simulation-analysis}]{\sphinxcrossref{Post-simulation analysis}}}

\item {} 
\phantomsection\label{\detokenize{index:id18}}{\hyperref[\detokenize{index:extended-analysis}]{\sphinxcrossref{Extended analysis}}}

\item {} 
\phantomsection\label{\detokenize{index:id19}}{\hyperref[\detokenize{index:testing-install}]{\sphinxcrossref{Testing install}}}

\end{itemize}
\end{sphinxShadowBox}


\section{Installation}
\label{\detokenize{index:installation}}
Currently, only macOS and linux-based operating systems are supported. Windows compatibility will likely be added at a
later date.


\subsection{Method}
\label{\detokenize{index:method}}
Before attempting installation, make sure the {\hyperref[\detokenize{index:prerequisites}]{\sphinxcrossref{prerequisites are installed}}}. There are a few options for installation.
\phantomsection\label{\detokenize{index:prerequisites}}\phantomsection\label{\detokenize{index:prerequisites-are-installed}}\begin{itemize}
\item {} 
Use in-built installation \sphinxstylestrong{{[}recommended{]}}
\begin{quote}

This is the recommended method for installing the files. Simply run \sphinxcode{python setup.py {[}opts{]}} where \sphinxcode{{[}opts{]}} are
your required compilation flags (see  {\hyperref[\detokenize{index:compilation-options}]{\sphinxcrossref{Compilation Options}}}). On some systems this requires that \sphinxcode{autoconf} and
\sphinxcode{autotools} are installed on your computer. The configuration will be calculated,
\begin{quote}

{\hyperref[\detokenize{Exhaled/exhaled_library:introduction-necsim}]{\sphinxcrossref{\DUrole{std,std-ref}{NECSim}}}} and {\hyperref[\detokenize{Exhaled/exhaled_library:introduction-speciationcounter}]{\sphinxcrossref{\DUrole{std,std-ref}{SpeciationCounter}}}} will be
\end{quote}

compiled, and the executables will be placed in \sphinxstyleemphasis{build/default/}.
\end{quote}

\item {} 
Use {\hyperref[\detokenize{PyCoalescence:module-PyCoalescence.setup}]{\sphinxcrossref{\sphinxcode{setup.py}}}} to customise options and install locations. The procedure is the same
as exists in {\hyperref[\detokenize{PyCoalescence:PyCoalescence.setup.main}]{\sphinxcrossref{\sphinxcode{main()}}}}.
\begin{quote}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{PyCoalescence} \PYG{k+kn}{import} \PYG{n}{setup}
\PYG{n}{setup}\PYG{o}{.}\PYG{n}{autoconf}\PYG{p}{(}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} This may not be necessary and will fail if autotools is not installed.}
\PYG{n}{setup}\PYG{o}{.}\PYG{n}{configure}\PYG{p}{(}\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZhy{}\PYGZhy{}with\PYGZhy{}hpc}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZhy{}\PYGZhy{}with\PYGZhy{}verbose}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} Replace with desired install options}
\PYG{n}{setup}\PYG{o}{.}\PYG{n}{clean}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{setup}\PYG{o}{.}\PYG{n}{do\PYGZus{}compile}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{setup}\PYG{o}{.}\PYG{n}{move\PYGZus{}executable}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{build/custom\PYGZus{}install/}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} Move to a custom install location}
\end{sphinxVerbatim}
\end{quote}

\item {} 
Run \sphinxcode{./configure} and \sphinxcode{make} yourself.
\begin{quote}

If you require additional compilation options, run \sphinxcode{./configure} with your options from the NECSim/ directory. Then
run \sphinxcode{make} and check that installation is complete. The executables at NECSim/NECSim and NECSim/SpeciationCounter
should then be moved to where they are required.
\end{quote}

\item {} 
Custom compilation
\begin{quote}

Compile the c++ files yourself with the required defines and copy the executable to the required directory.
\end{quote}

\end{itemize}

For HPC use, running \sphinxcode{python hpc\_setup.py} (see {\hyperref[\detokenize{PyCoalescence:module-PyCoalescence.hpc_setup}]{\sphinxcrossref{\sphinxcode{hpc\_setup}}}}) will perform
compilation for an HPC using the intel compiler and copy the executable to ''../../Code'' relative to PyCoalescence.

\begin{sphinxadmonition}{warning}{Warning:}
Additional steps may have to be taken to ensure availability of the correct packages on HPC systems. Check
with your HPC administrator for details.
\end{sphinxadmonition}


\subsection{Compilation Options}
\label{\detokenize{index:sec-compilation-options}}\label{\detokenize{index:compilation-options}}
These are the possible flags which can be provided during installation as options in \sphinxcode{python setup.py {[}opts{]}}.

\noindent\begin{tabulary}{\linewidth}{|L|L|}
\hline
\sphinxstylethead{\relax 
Option
\unskip}\relax &\sphinxstylethead{\relax 
Description
\unskip}\relax \\
\hline
--with-debug
&
Adds additional debugging information
\\
\hline
--with-restrict\_self
&
Restricts self-selection during dispersal. Individuals can therefore not become their own parent
\\
\hline
--with-verbose
&
Prints information to the terminal. Otherwise, prints to a log file in \sphinxstyleemphasis{Logs/}
\\
\hline
--with-normal\_dispersal
&
Choose a normal distribution for dispersal distances
\\
\hline
--with-fat\_tail\_dispersal
&
Choose a fat-tailed kernel for dispersal distances
\\
\hline
--with-infinite\_landscape
&
Map boundaries are ignored and individuals can disperse to anywhere.
\\
\hline
--with-gdal=DIR
&
Define a gdal library at DIR
\\
\hline
--with-hpc
&
Compile ready for HPC, using intel's icpc compilation and a variety of optimisation flags.
\\
\hline
--with-boost=DIR
&
Define a boost library at DIR
\\
\hline\end{tabulary}


\begin{sphinxadmonition}{warning}{Warning:}
It is recommended that \sphinxcode{-{-}with-verbose} is always used for any HPC system, with the \sphinxcode{-{-}with-hpc} flag,
as writing to a log file can cause complications in a virtualised system where stdin and stdout calls are
redirected already. Compilation will likely fail due to libraries that are not present in the standard
library of most HPC systems.
\end{sphinxadmonition}


\section{Performing simulations}
\label{\detokenize{index:performing-simulations}}

\subsection{Setting up simulations}
\label{\detokenize{index:setting-up-simulations}}
It is recommended that PyCoalescence is used for simple simulation set up and running. There are two methods for providing
configuration options in PyCoalescence. Both require the same initial procedure.
\begin{enumerate}
\item {} 
Specify simulation parameters
\begin{itemize}
\item {} 
run {\hyperref[\detokenize{PyCoalescence:PyCoalescence.coalescence.Coalescence.setup}]{\sphinxcrossref{\sphinxcode{setup()}}}} to link to the correct executables. If you have
installed via \sphinxcode{python setup.py}, the arguments can be left blank. Otherwise, specify the path to the executables.

\item {} 
set simulation parameters using {\hyperref[\detokenize{PyCoalescence:PyCoalescence.coalescence.Coalescence.set_simulation_params}]{\sphinxcrossref{\sphinxcode{set\_simulation\_params()}}}}
to set the job number, task number, output directory and other key simulation variables.

\item {} 
set the map variables by one of the following:
\begin{enumerate}
\item {} 
{\hyperref[\detokenize{PyCoalescence:PyCoalescence.coalescence.Coalescence.set_map_parameters}]{\sphinxcrossref{\sphinxcode{set\_map\_parameters()}}}} to input file paths and dimensions

\item {} 
{\hyperref[\detokenize{PyCoalescence:PyCoalescence.coalescence.Coalescence.set_map_files}]{\sphinxcrossref{\sphinxcode{set\_map\_files()}}}} to set the map file paths. Then
run {\hyperref[\detokenize{PyCoalescence:PyCoalescence.coalescence.Coalescence.detect_map_dimensions}]{\sphinxcrossref{\sphinxcode{detect\_map\_dimensions()}}}} to automatically
detect file dimensions.

\end{enumerate}

\begin{sphinxadmonition}{tip}{Tip:}
Check {\hyperref[\detokenize{index:limitations-of-simulation-variables}]{\sphinxcrossref{Limitations of simulation variables}}} for important information on restrictions on simulation
inputs.
\end{sphinxadmonition}

\begin{sphinxadmonition}{note}{Note:}
{\hyperref[\detokenize{PyCoalescence:PyCoalescence.coalescence.Coalescence.detect_map_dimensions}]{\sphinxcrossref{\sphinxcode{detect\_map\_dimensions()}}}} requires
that the files are in \sphinxstylestrong{.tif} formats so that file dimensions can be read. If input files are csv format,
method a) should be used.
\end{sphinxadmonition}

\item {} 
Optionally, also run {\hyperref[\detokenize{PyCoalescence:PyCoalescence.coalescence.Coalescence.set_speciation_rates}]{\sphinxcrossref{\sphinxcode{set\_speciation\_rates()}}}}
to set a list of speciation rates to apply at the end of the simulation.

\end{itemize}

\item {} 
{[}Optionally{]} Add map configuration file
If you require multiple map files at different points in time, you shall need to create a configuration (.txt or .cfg)
file to make these options accessible to the program.
\begin{itemize}
\item {} 
First add the pristine map options using {\hyperref[\detokenize{PyCoalescence:PyCoalescence.coalescence.Coalescence.add_pristine_map}]{\sphinxcrossref{\sphinxcode{add\_pristine\_map()}}}}
This can be performed multiple times to add several maps.

\item {} 
Create the map configuration file ({\hyperref[\detokenize{PyCoalescence:PyCoalescence.coalescence.Coalescence.create_map_config}]{\sphinxcrossref{\sphinxcode{create\_map\_config()}}}})

\end{itemize}

\item {} 
{[}Optionally{]} Add temporal sampling configuration file
If you require sampling at points other than the present day, these can be specified in another configuration file.
\begin{itemize}
\item {} 
Add temporal sampling points using {\hyperref[\detokenize{PyCoalescence:PyCoalescence.coalescence.Coalescence.add_sample_time}]{\sphinxcrossref{\sphinxcode{add\_sample\_time()}}}}
Multiple sample points can be added.

\item {} 
Create the temporal sampling config file ({\hyperref[\detokenize{PyCoalescence:PyCoalescence.coalescence.Coalescence.create_temporal_sampling_config}]{\sphinxcrossref{\sphinxcode{create\_temporal\_sampling\_config()}}}})

\end{itemize}

\item {} 
{[}Optionally{]} Generate the main config file
Run {\hyperref[\detokenize{PyCoalescence:PyCoalescence.coalescence.Coalescence.create_config}]{\sphinxcrossref{\sphinxcode{create\_config()}}}} to generate the main config file.

\begin{sphinxadmonition}{note}{Note:}
If you wish to use multiple map files or multiple temporal samples and wish to use a main config file as well,
you must generate call
{\hyperref[\detokenize{PyCoalescence:PyCoalescence.coalescence.Coalescence.create_config}]{\sphinxcrossref{\sphinxcode{create\_config()}}}} \sphinxstylestrong{after} both
{\hyperref[\detokenize{PyCoalescence:PyCoalescence.coalescence.Coalescence.create_map_config}]{\sphinxcrossref{\sphinxcode{create\_map\_config()}}}} and
{\hyperref[\detokenize{PyCoalescence:PyCoalescence.coalescence.Coalescence.create_temporal_sampling_config}]{\sphinxcrossref{\sphinxcode{create\_temporal\_sampling\_config()}}}}
\end{sphinxadmonition}

\begin{sphinxadmonition}{warning}{Warning:}
It is possible to use temporal config files and map config files without using a main config file. However,
if you use a main config file, you \sphinxstylestrong{must} use a map config and temporal config.
\end{sphinxadmonition}

\item {} 
Check and run simulations
\begin{itemize}
\item {} 
Run {\hyperref[\detokenize{PyCoalescence:PyCoalescence.coalescence.Coalescence.complete_setup}]{\sphinxcrossref{\sphinxcode{complete\_setup()}}}} to generate the command to be
passed to the \sphinxcode{c++} program.

\item {} 
Run {\hyperref[\detokenize{PyCoalescence:PyCoalescence.coalescence.Coalescence.run_checks}]{\sphinxcrossref{\sphinxcode{run\_checks()}}}} to check that all prerequisites have
been fulfilled.

\item {} 
Finally, start the simulation using {\hyperref[\detokenize{PyCoalescence:PyCoalescence.coalescence.Coalescence.run_coalescence}]{\sphinxcrossref{\sphinxcode{run\_coalescence()}}}}

\end{itemize}

\end{enumerate}

\begin{sphinxadmonition}{note}{Note:}
See {\hyperref[\detokenize{index:glossary}]{\sphinxcrossref{Glossary}}} for definitions of {\hyperref[\detokenize{index:term-sample-grid}]{\sphinxtermref{\DUrole{xref,std,std-term}{sample grid}}}}, {\hyperref[\detokenize{index:term-fine-map}]{\sphinxtermref{\DUrole{xref,std,std-term}{fine map}}}} and {\hyperref[\detokenize{index:term-coarse-map}]{\sphinxtermref{\DUrole{xref,std,std-term}{coarse map}}}}.
\end{sphinxadmonition}


\subsection{Examples}
\label{\detokenize{index:examples}}
A simple simulation

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{PyCoalescence} \PYG{k+kn}{import} \PYG{n}{Coalescence}
\PYG{c+c1}{\PYGZsh{} use default executables}
\PYG{n}{c}\PYG{o}{.}\PYG{n}{setup}\PYG{p}{(}\PYG{p}{)}
\PYG{c+c1}{\PYGZsh{} set the main simulation parameters}
\PYG{n}{c}\PYG{o}{.}\PYG{n}{set\PYGZus{}simulation\PYGZus{}params}\PYG{p}{(}\PYG{n}{job\PYGZus{}num}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{job\PYGZus{}type}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{output\PYGZus{}directory}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{output}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{min\PYGZus{}speciation\PYGZus{}rate}\PYG{o}{=}\PYG{l+m+mf}{0.1}\PYG{p}{,}
                        \PYG{n}{zfat}\PYG{o}{=}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{n}{dispersal}\PYG{o}{=}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{n}{deme}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{sample\PYGZus{}size}\PYG{o}{=}\PYG{l+m+mf}{0.1}\PYG{p}{,} \PYG{n}{max\PYGZus{}time}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{lambda\PYGZus{}value}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,}
                        \PYG{n}{min\PYGZus{}num\PYGZus{}species}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{forest\PYGZus{}change\PYGZus{}param}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{pristine\PYGZus{}forest}\PYG{o}{=}\PYG{l+m+mi}{200}\PYG{p}{,} \PYG{n}{time\PYGZus{}config\PYGZus{}file}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{null}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{c+c1}{\PYGZsh{} set the speciation rates}
\PYG{n}{c}\PYG{o}{.}\PYG{n}{set\PYGZus{}speciation\PYGZus{}rates}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mf}{0.1}\PYG{p}{,} \PYG{l+m+mf}{0.2}\PYG{p}{,} \PYG{l+m+mf}{0.3}\PYG{p}{]}\PYG{p}{)}
\PYG{c+c1}{\PYGZsh{} set the map parameters \PYGZhy{} null means the map will be generated with 100\PYGZpc{} cover everywhere (no file input).}
\PYG{n}{c}\PYG{o}{.}\PYG{n}{set\PYGZus{}map\PYGZus{}parameters}\PYG{p}{(}\PYG{n}{sample\PYGZus{}file} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{null}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{sample\PYGZus{}x} \PYG{o}{=} \PYG{l+m+mi}{100}\PYG{p}{,} \PYG{n}{sample\PYGZus{}y}\PYG{o}{=}\PYG{l+m+mi}{100}\PYG{p}{,}
                     \PYG{n}{fine\PYGZus{}file} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{null}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{fine\PYGZus{}x} \PYG{o}{=} \PYG{l+m+mi}{200}\PYG{p}{,} \PYG{n}{fine\PYGZus{}y} \PYG{o}{=} \PYG{l+m+mi}{200}\PYG{p}{,} \PYG{n}{fine\PYGZus{}x\PYGZus{}offset} \PYG{o}{=} \PYG{l+m+mi}{50}\PYG{p}{,} \PYG{n}{fine\PYGZus{}y\PYGZus{}offset} \PYG{o}{=} \PYG{l+m+mi}{50}\PYG{p}{,}
                     \PYG{n}{coarse\PYGZus{}file} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{null}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{coarse\PYGZus{}x} \PYG{o}{=} \PYG{l+m+mi}{1000}\PYG{p}{,} \PYG{n}{coarse\PYGZus{}y} \PYG{o}{=} \PYG{l+m+mi}{1000}\PYG{p}{,}
                     \PYG{n}{coarse\PYGZus{}x\PYGZus{}offset} \PYG{o}{=} \PYG{l+m+mi}{100}\PYG{p}{,} \PYG{n}{coarse\PYGZus{}y\PYGZus{}offset} \PYG{o}{=} \PYG{l+m+mi}{100}\PYG{p}{,} \PYG{n}{coarse\PYGZus{}scale} \PYG{o}{=} \PYG{l+m+mi}{10}\PYG{p}{,}
                     \PYG{n}{pristine\PYGZus{}fine\PYGZus{}map} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{null}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{pristine\PYGZus{}coarse\PYGZus{}map} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{null}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{c+c1}{\PYGZsh{} complete setup and run simulation}
\PYG{n}{c}\PYG{o}{.}\PYG{n}{complete\PYGZus{}setup}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{c}\PYG{o}{.}\PYG{n}{run\PYGZus{}checks}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{c}\PYG{o}{.}\PYG{n}{run\PYGZus{}coalescence}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

A more complex example using config files, multiple temporal sampling points and detection of map dimensions from the
inputted map files.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{PyCoalescence} \PYG{k+kn}{import} \PYG{n}{Coalescence}
\PYG{n}{c} \PYG{o}{=} \PYG{n}{Coalescence}\PYG{p}{(}\PYG{p}{)}
\PYG{c+c1}{\PYGZsh{} use default executables}
\PYG{n}{c}\PYG{o}{.}\PYG{n}{setup}\PYG{p}{(}\PYG{p}{)}
\PYG{c+c1}{\PYGZsh{} set the main simulation parameters}
\PYG{n}{c}\PYG{o}{.}\PYG{n}{set\PYGZus{}simulation\PYGZus{}params}\PYG{p}{(}\PYG{n}{job\PYGZus{}num}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{job\PYGZus{}type}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{output\PYGZus{}directory}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{output}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{min\PYGZus{}speciation\PYGZus{}rate}\PYG{o}{=}\PYG{l+m+mf}{0.1}\PYG{p}{,}
                        \PYG{n}{zfat}\PYG{o}{=}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{n}{dispersal}\PYG{o}{=}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{n}{deme}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{sample\PYGZus{}size}\PYG{o}{=}\PYG{l+m+mf}{0.1}\PYG{p}{,} \PYG{n}{max\PYGZus{}time}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{lambda\PYGZus{}value}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,}
                        \PYG{n}{min\PYGZus{}num\PYGZus{}species}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{forest\PYGZus{}change\PYGZus{}param}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{pristine\PYGZus{}forest}\PYG{o}{=}\PYG{l+m+mi}{200}\PYG{p}{,} \PYG{n}{time\PYGZus{}config\PYGZus{}file}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{null}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{c+c1}{\PYGZsh{} set the speciation rates}
\PYG{n}{c}\PYG{o}{.}\PYG{n}{set\PYGZus{}speciation\PYGZus{}rates}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mf}{0.1}\PYG{p}{,} \PYG{l+m+mf}{0.2}\PYG{p}{,} \PYG{l+m+mf}{0.3}\PYG{p}{]}\PYG{p}{)}
\PYG{c+c1}{\PYGZsh{} set the map files}
\PYG{n}{c}\PYG{o}{.}\PYG{n}{set\PYGZus{}map\PYGZus{}files}\PYG{p}{(}\PYG{n}{sample\PYGZus{}file}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{null}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{fine\PYGZus{}file}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{path/to/fine.tif}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{coarse\PYGZus{}file}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{path/to/coarse.tif}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{c+c1}{\PYGZsh{} detect the dimensions of the .tif files}
\PYG{n}{c}\PYG{o}{.}\PYG{n}{detect\PYGZus{}map\PYGZus{}dimensions}\PYG{p}{(}\PYG{p}{)}
\PYG{c+c1}{\PYGZsh{} add sample times}
\PYG{n}{c}\PYG{o}{.}\PYG{n}{add\PYGZus{}sample\PYGZus{}time}\PYG{p}{(}\PYG{l+m+mf}{0.0}\PYG{p}{)}
\PYG{n}{c}\PYG{o}{.}\PYG{n}{add\PYGZus{}sample\PYGZus{}time}\PYG{p}{(}\PYG{l+m+mf}{1.0}\PYG{p}{)}
\PYG{c+c1}{\PYGZsh{} add pristine maps}
\PYG{n}{c}\PYG{o}{.}\PYG{n}{add\PYGZus{}pristine\PYGZus{}map}\PYG{p}{(}\PYG{n}{fine\PYGZus{}map}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{path/to/pristinefine1.tif}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{coarse\PYGZus{}map}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{path/to/pristinecoarse1.tif}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{time}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{rate}\PYG{o}{=}\PYG{l+m+mf}{0.5}\PYG{p}{)}
\PYG{c+c1}{\PYGZsh{} create configuration files}
\PYG{n}{c}\PYG{o}{.}\PYG{n}{create\PYGZus{}temporal\PYGZus{}sampling\PYGZus{}config}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{timeconf.txt}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{c}\PYG{o}{.}\PYG{n}{create\PYGZus{}map\PYGZus{}config}\PYG{p}{(}\PYG{n}{mapconf}\PYG{o}{.}\PYG{n}{txt}\PYG{p}{)}
\PYG{n}{c}\PYG{o}{.}\PYG{n}{create\PYGZus{}config}\PYG{p}{(}\PYG{n}{mainconf}\PYG{o}{.}\PYG{n}{txt}\PYG{p}{)}
\PYG{c+c1}{\PYGZsh{} complete setup and run checks}
\PYG{n}{c}\PYG{o}{.}\PYG{n}{complete\PYGZus{}setup}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{c}\PYG{o}{.}\PYG{n}{run\PYGZus{}checks}\PYG{p}{(}\PYG{p}{)}
\PYG{c+c1}{\PYGZsh{} run the simulation}
\PYG{n}{c}\PYG{o}{.}\PYG{n}{run\PYGZus{}coalescence}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\begin{sphinxadmonition}{note}{Note:}
NECSim can also be run directly using command line arguments (see
{\hyperref[\detokenize{Exhaled/exhaled_library:introduction-necsim}]{\sphinxcrossref{\DUrole{std,std-ref}{Introduction to NECSim}}}}).
\end{sphinxadmonition}


\subsection{Limitations of simulation variables}
\label{\detokenize{index:limitations-of-simulation-variables}}
\begin{sphinxadmonition}{important}{Important:}
This section contains key information about the simulation inputs. Please read carefully to minimise any
unnecessary bugs.
\end{sphinxadmonition}

Certain simulation variables have limitations, depending on the method of setting up the simulation.
\begin{itemize}
\item {} 
Map variables set up using {\hyperref[\detokenize{PyCoalescence:PyCoalescence.coalescence.Coalescence.set_map_parameters}]{\sphinxcrossref{\sphinxcode{set\_map\_parameters()}}}}
\begin{quote}
\begin{itemize}
\item {} 
Sample map dimensions must be smaller than fine map dimensions.

\item {} 
Fine map dimensions must be smaller than coarse map dimensions (supplied at the resolution of the fine map files).

\item {} 
Dimensions of pristine fine and coarse maps must match their respective current map dimensions.

\item {} 
All offsets must maintain the smaller map within the larger map

\item {} 
If any files are supplied as `null', map sizes must still be provided. This is important for sample map size, but
should be corrected in a future update for coarse map files.

\end{itemize}

\begin{sphinxadmonition}{note}{Todo}

Allow potential for specifying either ``null'' or ``none'' map types (``null'' creates a map at the specified
size, whereas ``none'' creates hard boundaries without any in-memory map object created at all.
\end{sphinxadmonition}
\end{quote}

\item {} 
Map files (and variables) set using {\hyperref[\detokenize{PyCoalescence:PyCoalescence.coalescence.Coalescence.set_map_files}]{\sphinxcrossref{\sphinxcode{set\_map\_files()}}}}
\begin{quote}
\begin{itemize}
\item {} 
In addition to the above conditions being true, the files must all be georeferenced, so that coarse and fine map
dimensions will be read correctly.

\end{itemize}

\begin{sphinxadmonition}{hint}{Hint:}
Use a GIS program (such as ArcGIS or QGIS) for manipulation of map files to
ensure georeferencing is preserved.
\end{sphinxadmonition}
\begin{itemize}
\item {} 
If the samplemask map is ``null'', the program will read the dimensions from the fine map and choose that as the
area to sample entirely over. Supplying ``null'' will therefore sample the entirety of the fine map.

\end{itemize}

\begin{sphinxadmonition}{hint}{Hint:}
Scalings and offsets between maps should also work correctly, but if problems are encountered, try manually
specifying offsets and dimensions to identify any problems.
\end{sphinxadmonition}
\end{quote}

\end{itemize}

An example of how the map files are related is shown below. Black arrows indicate the offsets for the fine map (in the x
and y dimensions) and purple arrows indicate the offsets for the coarse map.

\noindent\sphinxincludegraphics{{grid_sample}.png}


\section{Post-simulation analysis}
\label{\detokenize{index:post-simulation-analysis}}
Once simulations are complete, the {\hyperref[\detokenize{Exhaled/exhaled_library:introduction-speciationcounter}]{\sphinxcrossref{\DUrole{std,std-ref}{SpeciationCounter}}}} program can be used to apply additional speciation rates to the
coalescence tree. A simple way of applying additional simulation rates is provided within the
{\hyperref[\detokenize{PyCoalescence:PyCoalescence.coalescence.Coalescence}]{\sphinxcrossref{\sphinxcode{Coalescence class}}}}.

The two functions for this routine are
\begin{itemize}
\item {} 
{\hyperref[\detokenize{PyCoalescence:PyCoalescence.coalescence.Coalescence.set_speciation_params}]{\sphinxcrossref{\sphinxcode{set\_speciation\_params()}}}} which takes as arguments
\begin{itemize}
\item {} 
the SQL database file containing a finished simulation

\item {} 
T/F of recording full spatial data

\item {} 
either a csv file containing fragment data, or T/F for whether
fragments should be calculated from squares of continuous habitat.
* list of speciation rates to apply

\item {} 
{[}optional{]} a sample file to specify certain cells to sample from

\item {} 
{[}optional{]} a config file containing the temporal sampling points
desired.

\end{itemize}

\item {} 
{\hyperref[\detokenize{PyCoalescence:PyCoalescence.coalescence.Coalescence.apply_speciation}]{\sphinxcrossref{\sphinxcode{apply\_speciation()}}}} performs the analysis. This can be extremely
RAM and time-intensive for large simulations. The calculations will
be stored in extra tables within the same SQL file as originally
specified.

\end{itemize}

The procedure for applying additional speciation rates to an existing database is

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{PyCoalescence} \PYG{k+kn}{import} \PYG{n}{Coalescence}
\PYG{n}{c} \PYG{o}{=} \PYG{n}{Coalescence}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{speciation\PYGZus{}rates} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mf}{0.1}\PYG{p}{,} \PYG{l+m+mf}{0.2} \PYG{p}{,}\PYG{l+m+mf}{0.3}\PYG{p}{]}
\PYG{n}{c}\PYG{o}{.}\PYG{n}{set\PYGZus{}speciation\PYGZus{}params}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{output/SQL\PYGZus{}data/data\PYGZus{}1\PYGZus{}1.db}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{T}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{null}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{speciation\PYGZus{}rates}\PYG{p}{)}
\PYG{n}{c}\PYG{o}{.}\PYG{n}{apply\PYGZus{}speciation}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}


\section{Extended analysis}
\label{\detokenize{index:extended-analysis}}
The {\hyperref[\detokenize{PyCoalescence:module-PyCoalescence.coal_analyse}]{\sphinxcrossref{\sphinxcode{coal\_analyse}}}} module can be used for more extensive simulation analysis, such
as comparing simulated landscapes to real data, generating species abundance distributions and calculating goodness of
fits.

The general procedure for using this module involves a few functions, all contained in the
{\hyperref[\detokenize{PyCoalescence:PyCoalescence.coal_analyse.Tree}]{\sphinxcrossref{\sphinxcode{Tree class}}}}.
\begin{itemize}
\item {} 
{\hyperref[\detokenize{PyCoalescence:PyCoalescence.coal_analyse.Tree.set_database}]{\sphinxcrossref{\sphinxcode{set\_database()}}}} generates the link to the SQL database, which
should be an output from a NECSim simulation (probably ran using the
{\hyperref[\detokenize{PyCoalescence:PyCoalescence.coalescence.Coalescence}]{\sphinxcrossref{\sphinxcode{Coalescence class}}}}.

\item {} 
\sphinxcode{import\_comparison\_data()} reads an SQL database which
contains real data to compare to the simulation output. The comparison data should contain the following tables:
\begin{itemize}
\item {} 
BIODIVERSITY\_ METRICS, containing \sphinxstyleemphasis{only} ``metric'', ``fragment'', ``value'' and ``number\_of\_individuals'' columns.
The metric can be ``fragment\_richness'' or any other metric created by your own functions which will exists also in
the simulated data.

\item {} 
FRAGMENT\_ABUNDANCES containing \sphinxstyleemphasis{at least} ``plot

\end{itemize}

\end{itemize}


\section{Testing install}
\label{\detokenize{index:testing-install}}
The system install can be tested by running \sphinxcode{test\_install.py} from the command line
(\sphinxcode{python test\_install.py}) which will compile the program for a variety of simulation set-ups (first test run only)
and run a test suite. Compilation may take some time if it hasn't been run before.


\chapter{Prerequisites}
\label{\detokenize{index:prerequisites}}

\section{Essential}
\label{\detokenize{index:essential}}\begin{itemize}
\item {} 
The SQLite library available \href{https://www.sqlite.org/download.html}{here}. Require both \sphinxcode{c++} and \sphinxcode{python} installations.

\item {} 
The Boost library for C++ available \href{http://www.boost.org}{here}.

\item {} 
C++ compiler (such as GNU g++) with C++11 support.

\item {} 
Numerical python (\sphinxcode{numpy}) package.

\end{itemize}


\section{Recommended}
\label{\detokenize{index:recommended}}\begin{itemize}
\item {} 
The gdal library for both python and C++ (\href{http://www.gdal.org/}{available here}). This is \sphinxstylestrong{ESSENTIAL} if you wish
to use .tif files for {\hyperref[\detokenize{Exhaled/exhaled_library:introduction-necsim}]{\sphinxcrossref{\DUrole{std,std-ref}{NECSim}}}}.  It allows reading parameter information from .tif files
(using {\hyperref[\detokenize{PyCoalescence:PyCoalescence.coalescence.Coalescence.detect_map_dimensions}]{\sphinxcrossref{\sphinxcode{detect\_map\_dimensions()}}}}). Both the python
package and \sphinxcode{c++} binaries are required; installation differs between systems, so view the gdal documentation for more
help installing gdal properly.

\item {} 
The fast-cpp-csv-parser by Ben Strasser, available
\href{https://github.com/ben-strasser/fast-cpp-csv-parser}{here}. This provides much faster csv read and write capabilities
and is probably essential for larger-scale simulations, but not necessary if your simulations are small. The folder
\sphinxstyleemphasis{fast-cpp-csv-parser/} should be in the same directory as your C++ header files (the NECSim directory).

\end{itemize}

\begin{sphinxadmonition}{note}{Note:}
Running \sphinxcode{configure} (or \sphinxcode{python setup.py}) will detect system components, including \sphinxcode{sqlite3}, \sphinxcode{boost},
\sphinxcode{gdal} and \sphinxcode{fast-cpp-csv-parser} and set the correct compilation flags.
\end{sphinxadmonition}


\chapter{Glossary}
\label{\detokenize{index:glossary}}\begin{description}
\item[{sample grid\index{sample grid|textbf}}] \leavevmode\phantomsection\label{\detokenize{index:term-sample-grid}}
The map file containing the points to be sampled from. This is the most zoomed in level of the simulation, and
should encompass all starting locations of lineages.

\item[{fine map\index{fine map|textbf}}] \leavevmode\phantomsection\label{\detokenize{index:term-fine-map}}
The map file at a higher resolution (the same as the sample grid) which covers the area lineages are most likely
to move to, or where a higher spatial resolution is considered important.

\item[{coarse map\index{coarse map|textbf}}] \leavevmode\phantomsection\label{\detokenize{index:term-coarse-map}}
The map file at a lower resolution (specified by the scale) which covers a larger area than the fine map. This is
to allow lineages to move far from their starting positions if required.

\item[{pristine map\index{pristine map|textbf}}] \leavevmode\phantomsection\label{\detokenize{index:term-pristine-map}}
A historic map containing population densities at those times. Both fine and coarse pristine maps can be declared
and multiple sets of pristine maps can be declared at unique times.

\end{description}


\chapter{Contacts}
\label{\detokenize{index:contacts}}
Author: Samuel Thompson

Contact: \href{mailto:samuelthompson14@imperial.ac.uk}{samuelthompson14@imperial.ac.uk} - \href{mailto:thompsonsed@gmail.com}{thompsonsed@gmail.com}

Institution: Imperial College London and National University of
Singapore

This project is released under BSD-3 See file
\sphinxstylestrong{LICENSE.txt} or go to
\href{https://opensource.org/licenses/BSD-3-Clause}{here} for full license
details.


\chapter{Code Documentation}
\label{\detokenize{index:code-documentation}}

\section{Modules}
\label{\detokenize{modules:modules}}\label{\detokenize{modules::doc}}

\subsection{PyCoalescence package}
\label{\detokenize{PyCoalescence:module-PyCoalescence}}\label{\detokenize{PyCoalescence::doc}}\label{\detokenize{PyCoalescence:pycoalescence-package}}\index{PyCoalescence (module)}
PyCoalescence Package provides the facilities for running spatially-explicit neutral coalescence ecological simulations
and performing basic analysis of the simulation outputs. The program requires the NECSim program to function properly,
which will be included in the package at a later date.


\subsubsection{Module Contents}
\label{\detokenize{PyCoalescence:module-contents}}

\subsubsection{Submodules}
\label{\detokenize{PyCoalescence:submodules}}

\paragraph{batch\_process module}
\label{\detokenize{PyCoalescence:batch-process-module}}\label{\detokenize{PyCoalescence:module-PyCoalescence.batch_process}}\index{PyCoalescence.batch\_process (module)}
Contains the operations for performing batch analysis on multiple outputs of a PyCoalescence simulation.


\paragraph{coal\_analyse module}
\label{\detokenize{PyCoalescence:coal-analyse-module}}\label{\detokenize{PyCoalescence:module-PyCoalescence.coal_analyse}}\index{PyCoalescence.coal\_analyse (module)}
Contains the operations for performing basic analysis on the output of a PyCoalescence simulation.
\index{Tree (class in PyCoalescence.coal\_analyse)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{PyCoalescence:PyCoalescence.coal_analyse.Tree}}\pysigline{\sphinxstrong{class }\sphinxbfcode{Tree}}
Contains the coalescence tree and performs various calculations of different biodiversity metrics, which are then
stored in the SQLite database.

The general process is
\begin{itemize}
\item {} 
Import the database (set\_database()) and import the comparison data, if required (import\_comparison\_data())

\item {} 
Calculate required metrics (such as calculate\_fragment\_richness())

\item {} 
Save the required metrics to the SQL database (such as save\_fragment\_richness())

\item {} 
Optionally, calculate the goodness of fit (calculate\_goodness\_of\_fit())

\end{itemize}
\index{calculate\_BCI\_similarity() (Tree method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{PyCoalescence:PyCoalescence.coal_analyse.Tree.calculate_BCI_similarity}}\pysiglinewithargsret{\sphinxbfcode{calculate\_BCI\_similarity}}{}{}
Calculates the similarity between each fragment and the BCI dataset.

This function is only appropriate for Panama tree neutral simulations based on Center for Tropical Forest Science
(CTFS) tree census data

If the fragment species richness has not yet been calculated, calculate\_fragment\_richness() will be called.

\end{fulllineitems}

\index{calculate\_comparison\_octaves() (Tree method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{PyCoalescence:PyCoalescence.coal_analyse.Tree.calculate_comparison_octaves}}\pysiglinewithargsret{\sphinxbfcode{calculate\_comparison\_octaves}}{\emph{store=False}}{}
Calculates the octave classes for the comparison data and for fragments (if required).
If the octaves exist in the FRAGMENT\_OCTAVES table in the comparison database, the data will be imported
instead of being re-calculated.
Stores the new octave classes in self.comparison\_octaves.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{store} -- if True, stores within the comparison database.

\end{description}\end{quote}

\end{fulllineitems}

\index{calculate\_fragment\_octaves() (Tree method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{PyCoalescence:PyCoalescence.coal_analyse.Tree.calculate_fragment_octaves}}\pysiglinewithargsret{\sphinxbfcode{calculate\_fragment\_octaves}}{}{}
Calculates the octave classes for each fragment. Outputs the calculated richness into the SQL database within a
FRAGMENT\_OCTAVES table

\end{fulllineitems}

\index{calculate\_fragment\_richness() (Tree method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{PyCoalescence:PyCoalescence.coal_analyse.Tree.calculate_fragment_richness}}\pysiglinewithargsret{\sphinxbfcode{calculate\_fragment\_richness}}{}{}
Calculates the fragment richness and stores it in a new table. Each time point will be recorded as a new variable.

\end{fulllineitems}

\index{calculate\_goodness\_of\_fit() (Tree method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{PyCoalescence:PyCoalescence.coal_analyse.Tree.calculate_goodness_of_fit}}\pysiglinewithargsret{\sphinxbfcode{calculate\_goodness\_of\_fit}}{}{}
Calculates the goodness-of-fit measure based on the calculated biodiversity metrics, scaling each metric by the
number of individuals involved in the metric.

This requires that import\_comparison\_data() has already been successfully run.

Note that this doesn't calculate anything for values which have not yet been written to the SQL database -
make sure that the relevant save functions have been run already.

The resulting value will then be written to the BIODIVERSITY\_METRICS table in the SQL database.

\end{fulllineitems}

\index{calculate\_landscape\_octaves() (Tree method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{PyCoalescence:PyCoalescence.coal_analyse.Tree.calculate_landscape_octaves}}\pysiglinewithargsret{\sphinxbfcode{calculate\_landscape\_octaves}}{\emph{maxval}}{}
Calculates the octave classes for the landscape. Outputs the calculated richness into the SQL database within a
FRAGMENT\_OCTAVES table. Called automatically in calculate\_fragment\_octaves()
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{maxval} -- the maximum reference currently existing in the database (for correct outputting).

\end{description}\end{quote}

\end{fulllineitems}

\index{calculate\_landscape\_richness() (Tree method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{PyCoalescence:PyCoalescence.coal_analyse.Tree.calculate_landscape_richness}}\pysiglinewithargsret{\sphinxbfcode{calculate\_landscape\_richness}}{}{}
Calculates the landscape richness from across all fragments and stores result in a new table in
SPECIES\_RICHNESS
Stores a separate result for each speciation rate and time.

\end{fulllineitems}

\index{calculate\_octaves\_error() (Tree method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{PyCoalescence:PyCoalescence.coal_analyse.Tree.calculate_octaves_error}}\pysiglinewithargsret{\sphinxbfcode{calculate\_octaves\_error}}{}{}
Calculates the error in octaves classes between the simulated data and the comparison data.
Stores each error value as a new entry in BIODIVERSITY\_METRICS under fragment\_octaves.
Calculates the error by comparing each octave class and summing the relative difference.
Octaves are then averaged for each fragment.

\end{fulllineitems}

\index{check\_biodiversity\_table\_exists() (Tree method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{PyCoalescence:PyCoalescence.coal_analyse.Tree.check_biodiversity_table_exists}}\pysiglinewithargsret{\sphinxbfcode{check\_biodiversity\_table\_exists}}{}{}
Checks whether the biodiversity table exists and creates the table if required.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
the max reference value currently existing

\end{description}\end{quote}

\end{fulllineitems}

\index{clear\_calculations() (Tree method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{PyCoalescence:PyCoalescence.coal_analyse.Tree.clear_calculations}}\pysiglinewithargsret{\sphinxbfcode{clear\_calculations}}{}{}
Removes the BIODIVERSITY\_METRICS and FRAGMENT\_OCTAVES tables completely.
Note that this cannot be undone (other than re-running the calculations).

\end{fulllineitems}

\index{dispersal\_parameters() (Tree method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{PyCoalescence:PyCoalescence.coal_analyse.Tree.dispersal_parameters}}\pysiglinewithargsret{\sphinxbfcode{dispersal\_parameters}}{}{}
Reads the dispersal parameters from the database and returns them.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
a list of the dispersal parameters {[}zfat, L-value{]}

\end{description}\end{quote}

\end{fulllineitems}

\index{fix\_double\_fragments\_abundances() (Tree method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{PyCoalescence:PyCoalescence.coal_analyse.Tree.fix_double_fragments_abundances}}\pysiglinewithargsret{\sphinxbfcode{fix\_double\_fragments\_abundances}}{}{}
Fixes the double fragments from cocoli and sherman for the CTFS Panama dataset, combining the two fragment abundances
into one biodiversity metric.

\end{fulllineitems}

\index{fix\_double\_fragments\_octaves() (Tree method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{PyCoalescence:PyCoalescence.coal_analyse.Tree.fix_double_fragments_octaves}}\pysiglinewithargsret{\sphinxbfcode{fix\_double\_fragments\_octaves}}{}{}
Fixes the double fragments for cocoli and sherman for the CTFS Panama dataset, combining octave classes for the
two sites. Writes to the FRAGMENT\_OCTAVES table, removing old entries.

\end{fulllineitems}

\index{get\_fragment\_octaves() (Tree method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{PyCoalescence:PyCoalescence.coal_analyse.Tree.get_fragment_octaves}}\pysiglinewithargsret{\sphinxbfcode{get\_fragment\_octaves}}{\emph{fragment}, \emph{speciation\_rate}, \emph{time=0.0}}{}
Get the pre-calculated octave data for the specified fragment, speciation rate and time.
This requires self.calculate\_fragment\_octaves() to have been run successfully at some point previously.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{fragment} -- the desired fragment

\item {} 
\sphinxstyleliteralstrong{speciation\_rate} -- the desired speciation rate

\item {} 
\sphinxstyleliteralstrong{time} -- the desired generation time (defaults to 0.0)

\end{itemize}

\item[{Returns}] \leavevmode
output from FRAGMENT\_OCTAVES for the selected variables

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_goodness\_of\_fit() (Tree method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{PyCoalescence:PyCoalescence.coal_analyse.Tree.get_goodness_of_fit}}\pysiglinewithargsret{\sphinxbfcode{get\_goodness\_of\_fit}}{}{}
Returns the goodness of fit from the file.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
the full output from the SQL query

\item[{Return type}] \leavevmode
\href{https://docs.python.org/2/library/functions.html\#list}{list}

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_goodness\_of\_fit\_fragment\_octaves() (Tree method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{PyCoalescence:PyCoalescence.coal_analyse.Tree.get_goodness_of_fit_fragment_octaves}}\pysiglinewithargsret{\sphinxbfcode{get\_goodness\_of\_fit\_fragment\_octaves}}{}{}
Returns the goodness of fit for fragment octaves from the file.

Note that no error will be thrown if the table doesn't exist, just an empty list returned.
This improves compatibility of functions that call this one.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
the full output from the SQL query

\item[{Return type}] \leavevmode
\href{https://docs.python.org/2/library/functions.html\#list}{list}

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_goodness\_of\_fit\_fragment\_richness() (Tree method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{PyCoalescence:PyCoalescence.coal_analyse.Tree.get_goodness_of_fit_fragment_richness}}\pysiglinewithargsret{\sphinxbfcode{get\_goodness\_of\_fit\_fragment\_richness}}{}{}
Returns the goodness of fit for fragment richness from the file.

Note that no error will be thrown if the table doesn't exist, just an empty list returned.
This improves compatibility of functions that call this one.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
the full output from the SQL query

\item[{Return type}] \leavevmode
\href{https://docs.python.org/2/library/functions.html\#list}{list}

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_goodness\_of\_fit\_fragment\_similarity\_bci() (Tree method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{PyCoalescence:PyCoalescence.coal_analyse.Tree.get_goodness_of_fit_fragment_similarity_bci}}\pysiglinewithargsret{\sphinxbfcode{get\_goodness\_of\_fit\_fragment\_similarity\_bci}}{}{}
Returns the goodness of fit for fragment similarity with BCI from the file.
This is specifically for use in Panama tropical rainforest simulations parameterised by CTFS data.

Note that no error will be thrown if the table doesn't exist, just an empty list returned.
This improves compatibility of functions that call this one.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
the full output from the SQL query

\item[{Return type}] \leavevmode
\href{https://docs.python.org/2/library/functions.html\#list}{list}

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_job() (Tree method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{PyCoalescence:PyCoalescence.coal_analyse.Tree.get_job}}\pysiglinewithargsret{\sphinxbfcode{get\_job}}{}{}
Gets the job number (the seed) and the job type (task number).
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
list containing {[}job\_number (seed), job\_type (task number){]}

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_landscape\_richness() (Tree method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{PyCoalescence:PyCoalescence.coal_analyse.Tree.get_landscape_richness}}\pysiglinewithargsret{\sphinxbfcode{get\_landscape\_richness}}{\emph{speciation\_rate=None}, \emph{time=None}}{}
Reads the landscape richness from the SPECIES\_RICHNESS table in the database. Returns the richness for
each speciation rate and time.

Note that this should produce the same result as get\_richness(sr, t) with the corresponding sr and t.

Note that the return type of this function changes based on whether speciation rates and times were supplied.
If they were, returns a single integer. Otherwise, returns a list of all species richnesses.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{speciation\_rate} -- the required speciation rate (optional)

\item {} 
\sphinxstyleliteralstrong{time} -- the required time

\end{itemize}

\item[{Returns}] \leavevmode
either a list containing the speciation\_rate, time, richness OR (if specific speciation rate and time
provided), the species richness at that time and speciation rate.

\item[{Return type}] \leavevmode
\href{https://docs.python.org/2/library/functions.html\#int}{int}, \href{https://docs.python.org/2/library/functions.html\#list}{list}

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_richness() (Tree method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{PyCoalescence:PyCoalescence.coal_analyse.Tree.get_richness}}\pysiglinewithargsret{\sphinxbfcode{get\_richness}}{\emph{speciation\_rate=None}, \emph{time=None}}{}
Get the system richness for the supplied speciation rate and time.
Note that a richness of 0 is returned if there has been some problem; it is assumed that species richness
will be above 0 for any simulation.

Note that the values generated by this method should be identical to those produced by self.get\_landscape\_richness()
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{speciation\_rate} -- the required speciation rate

\item {} 
\sphinxstyleliteralstrong{time} -- the required time

\end{itemize}

\item[{Returns}] \leavevmode
the system species richness

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_simulation\_parameters() (Tree method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{PyCoalescence:PyCoalescence.coal_analyse.Tree.get_simulation_parameters}}\pysiglinewithargsret{\sphinxbfcode{get\_simulation\_parameters}}{}{}
Reads the simulation parameters from the database and returns them.
:return: a list of the simulation parameters {[}seed, job\_type, output\_dir, spec\_rate, zfat, L\_value, deme,
sample\_size, maxtime, lambda, min\_spec, forest\_change, time\_since\_pristine, time\_config, coarse\_map vars,
fine map vars, sample\_file, gridx, gridy, pristine coarse map, pristine fine map{]}

\end{fulllineitems}

\index{get\_species\_list() (Tree method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{PyCoalescence:PyCoalescence.coal_analyse.Tree.get_species_list}}\pysiglinewithargsret{\sphinxbfcode{get\_species\_list}}{}{}
Gets the entirety of the SPECIES\_LIST table, returning a tuple with an entry for each row. This can be used to
construct custom analyses of the coalescence tree.

\begin{sphinxadmonition}{note}{Note:}
The species list will be produced in an unprocessed format, with
\end{sphinxadmonition}
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
a list of each coalescence and speciation event, with locations, performed in the simulation

\item[{Return type}] \leavevmode
\href{https://docs.python.org/2/library/functions.html\#tuple}{tuple}

\end{description}\end{quote}

\end{fulllineitems}

\index{import\_comparison\_data() (Tree method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{PyCoalescence:PyCoalescence.coal_analyse.Tree.import_comparison_data}}\pysiglinewithargsret{\sphinxbfcode{import\_comparison\_data}}{\emph{filename}}{}
Imports the SQL database that contains the biodiversity metrics that we want to compare against.

This can either be real data (for comparing simulated data) or other simulated data (for comparing between models).

If the SQL database does not contain the relevant biodiversity metrics, they will be calculated (if possible) or skipped.

The expected form of the database is the same as the BIODIVERSITY\_METRICS table, except without any speciation
rates or time references, and a new column containing the number of individuals involved in each metric.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{filename} (\href{https://docs.python.org/2/library/functions.html\#str}{\sphinxstyleliteralemphasis{str}}) -- the file containing the comparison biodiversity metrics.

\end{description}\end{quote}

\end{fulllineitems}

\index{is\_completed() (Tree method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{PyCoalescence:PyCoalescence.coal_analyse.Tree.is_completed}}\pysiglinewithargsret{\sphinxbfcode{is\_completed}}{}{}
Indicates whether the simulation has been performed to completion, or if the simulation has been paused and
needs to be completed before analysis can be performed.
:return: bool: true if simulation is complete

\end{fulllineitems}

\index{save\_fragment\_richness() (Tree method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{PyCoalescence:PyCoalescence.coal_analyse.Tree.save_fragment_richness}}\pysiglinewithargsret{\sphinxbfcode{save\_fragment\_richness}}{}{}
Saves the fragment richness data, if it has been calculated (otherwise calculates it first) to a new table in the
SQL file.

\end{fulllineitems}

\index{save\_fragment\_similarity\_bci() (Tree method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{PyCoalescence:PyCoalescence.coal_analyse.Tree.save_fragment_similarity_bci}}\pysiglinewithargsret{\sphinxbfcode{save\_fragment\_similarity\_bci}}{}{}
Saves the fragment similarity to BCI, if it has been calculated (otherwise calculates it first) to a new table in the
SQL file.

\end{fulllineitems}

\index{set\_database() (Tree method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{PyCoalescence:PyCoalescence.coal_analyse.Tree.set_database}}\pysiglinewithargsret{\sphinxbfcode{set\_database}}{\emph{filename}}{}
Sets the database to the specified file and opens the sqlite connection.

This must be done before any other operations can be performed and the
file must exist.

Note that this will throw an IOError if the simulation is not complete, as analysis can only be performed on
complete simulations. However, the database WILL be set before the error is thrown, allowing for analysis of
incomplete simulations if the error is handled correctly.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{filename} -- the SQLite database file to import

\end{description}\end{quote}

\end{fulllineitems}

\index{wipe\_data() (Tree method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{PyCoalescence:PyCoalescence.coal_analyse.Tree.wipe_data}}\pysiglinewithargsret{\sphinxbfcode{wipe\_data}}{}{}
Wipes all calculated data apart from the original, unformatted coalescence tree.
The Speciation\_Counter program will have to be re-run to perform any analyses.

\end{fulllineitems}


\end{fulllineitems}

\index{collate\_bci\_sim() (in module PyCoalescence.coal\_analyse)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{PyCoalescence:PyCoalescence.coal_analyse.collate_bci_sim}}\pysiglinewithargsret{\sphinxbfcode{collate\_bci\_sim}}{\emph{file\_dir}, \emph{filename='Collated\_fits.db'}}{}
Collates the goodness of fit similarity with BCI values from every file in the specified directory and places them in one new file.
Note that files with `collated' in the name will be ignored.

This is specifically for use in Panama tropical rainforest simulations parameterised by CTFS data.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{file\_dir} -- the file directory to examine

\item {} 
\sphinxstyleliteralstrong{filename} -- {[}optional{]} the output file name.

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{collate\_fits() (in module PyCoalescence.coal\_analyse)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{PyCoalescence:PyCoalescence.coal_analyse.collate_fits}}\pysiglinewithargsret{\sphinxbfcode{collate\_fits}}{\emph{file\_dir}, \emph{filename='Collated\_fits.db'}}{}
Collates the goodness of fit values from every file in the specified directory and places them in one new file.
Note that files with `collated' in the name will be ignored.
Note that if the output file exists, it will be deleted.

Creates three separate tables in the output file, one for overall goodness of fit, one for fragment richness fits,
and one for fragment octaves fits.
:param file\_dir: the file directory to examine
:param filename: {[}optional{]} the output file name.

\end{fulllineitems}



\paragraph{coalescence module}
\label{\detokenize{PyCoalescence:coalescence-module}}\label{\detokenize{PyCoalescence:module-PyCoalescence.coalescence}}\index{PyCoalescence.coalescence (module)}
Contains the Coalescence and Map classes as part of the PyCoalescence Project.

Operations involve setting up and running simulations, plus basic tree generation after simulations have been completed.
\index{Coalescence (class in PyCoalescence.coalescence)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{PyCoalescence:PyCoalescence.coalescence.Coalescence}}\pysiglinewithargsret{\sphinxstrong{class }\sphinxbfcode{Coalescence}}{\emph{coalescence\_simulator=None}, \emph{speciation\_simulator=None}, \emph{logging\_level=20}, \emph{log\_output=None}, \emph{**kwargs}}{}
A class containing the coalescence running routines and methods for setting up the simulation of a variety of
different systems
\index{add\_pristine\_map() (Coalescence method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{PyCoalescence:PyCoalescence.coalescence.Coalescence.add_pristine_map}}\pysiglinewithargsret{\sphinxbfcode{add\_pristine\_map}}{\emph{fine\_map}, \emph{coarse\_map}, \emph{time}, \emph{rate}}{}
Adds an extra map to the list of pristine maps.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{fine\_map} -- the pristine fine map file to add

\item {} 
\sphinxstyleliteralstrong{coarse\_map} -- the pristine coarse map file to add

\item {} 
\sphinxstyleliteralstrong{time} -- the time to add (when the map is accurate)

\item {} 
\sphinxstyleliteralstrong{rate} -- the rate to add (the rate of forest change at this time)

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{add\_sample\_time() (Coalescence method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{PyCoalescence:PyCoalescence.coalescence.Coalescence.add_sample_time}}\pysiglinewithargsret{\sphinxbfcode{add\_sample\_time}}{\emph{time}}{}
Adds an extra sample time to the list of times.

This allows for multiple temporal sample points from within the same simulation.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{time} -- the sample time to add

\end{description}\end{quote}

\end{fulllineitems}

\index{apply\_speciation() (Coalescence method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{PyCoalescence:PyCoalescence.coalescence.Coalescence.apply_speciation}}\pysiglinewithargsret{\sphinxbfcode{apply\_speciation}}{}{}
Creates the list of speciation options and performs the speciation analysis by calling Speciation\_Counter.
This must be run after the main coalescence simulations are complete.
It will create additional fields and tables in the SQLite database which contains the requested data.

\end{fulllineitems}

\index{bci\_tif\_option() (Coalescence method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{PyCoalescence:PyCoalescence.coalescence.Coalescence.bci_tif_option}}\pysiglinewithargsret{\sphinxbfcode{bci\_tif\_option}}{}{}
Utilise the tif files instead of the csv files. Provided for increased speed of file parsing.

\end{fulllineitems}

\index{check\_simulation\_params() (Coalescence method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{PyCoalescence:PyCoalescence.coalescence.Coalescence.check_simulation_params}}\pysiglinewithargsret{\sphinxbfcode{check\_simulation\_params}}{}{}
Checks that simulation parameters have been correctly set and the program is ready for running.
Note that these checks have not been fully tested and are probably uneccessary in a large number of cases.

\end{fulllineitems}

\index{complete\_setup() (Coalescence method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{PyCoalescence:PyCoalescence.coalescence.Coalescence.complete_setup}}\pysiglinewithargsret{\sphinxbfcode{complete\_setup}}{}{}
Completes the setup process by creating the list that will be passed to the c++ executable

\end{fulllineitems}

\index{create\_config() (Coalescence method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{PyCoalescence:PyCoalescence.coalescence.Coalescence.create_config}}\pysiglinewithargsret{\sphinxbfcode{create\_config}}{\emph{output\_file}}{}
Generates the output config files. This version creates the concise version of the config file.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{output\_file} (\href{https://docs.python.org/2/library/functions.html\#str}{\sphinxstyleliteralemphasis{str}}) -- the file to generate the config option. Must be a path to a .txt file.

\end{description}\end{quote}

\end{fulllineitems}

\index{create\_map\_config() (Coalescence method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{PyCoalescence:PyCoalescence.coalescence.Coalescence.create_map_config}}\pysiglinewithargsret{\sphinxbfcode{create\_map\_config}}{\emph{output\_file}}{}
Generates the map config file from reading the spatial structure of each of the provided files.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{output\_file} (\href{https://docs.python.org/2/library/functions.html\#str}{\sphinxstyleliteralemphasis{str}}) -- the file to output configuration data to (the map config file)

\end{description}\end{quote}

\end{fulllineitems}

\index{create\_temporal\_sampling\_config() (Coalescence method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{PyCoalescence:PyCoalescence.coalescence.Coalescence.create_temporal_sampling_config}}\pysiglinewithargsret{\sphinxbfcode{create\_temporal\_sampling\_config}}{\emph{config\_file}}{}
\end{fulllineitems}

\index{detect\_map\_dimensions() (Coalescence method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{PyCoalescence:PyCoalescence.coalescence.Coalescence.detect_map_dimensions}}\pysiglinewithargsret{\sphinxbfcode{detect\_map\_dimensions}}{}{}
Detects all the map dimensions for the provided files (where possible) and sets the respective values.
This is intended to be run after set\_map\_files()
:return:

\end{fulllineitems}

\index{get\_richness() (Coalescence method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{PyCoalescence:PyCoalescence.coalescence.Coalescence.get_richness}}\pysiglinewithargsret{\sphinxbfcode{get\_richness}}{\emph{speciation\_rate=None}, \emph{time=None}}{}
Calls coal\_analyse.get\_richness() with the supplied variables.

Requires successful import of coal\_analyse and sqlite3.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{speciation\_rate} -- the speciation rate to extract system richness from.

\item {} 
\sphinxstyleliteralstrong{time} -- the time to extract system richness from

\end{itemize}

\item[{Returns}] \leavevmode
the species richness.

\end{description}\end{quote}

\end{fulllineitems}

\index{load\_config() (Coalescence method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{PyCoalescence:PyCoalescence.coalescence.Coalescence.load_config}}\pysiglinewithargsret{\sphinxbfcode{load\_config}}{\emph{config\_file}}{}
Loads the config file by reading the lines in order.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{config\_file} (\href{https://docs.python.org/2/library/functions.html\#str}{\sphinxstyleliteralemphasis{str}}) -- the config file to read in.

\end{description}\end{quote}

\end{fulllineitems}

\index{panama\_tif\_option() (Coalescence method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{PyCoalescence:PyCoalescence.coalescence.Coalescence.panama_tif_option}}\pysiglinewithargsret{\sphinxbfcode{panama\_tif\_option}}{}{}
Utilise the tif files instead of the csv files for fasting file reading.

\end{fulllineitems}

\index{resume\_sim() (Coalescence method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{PyCoalescence:PyCoalescence.coalescence.Coalescence.resume_sim}}\pysiglinewithargsret{\sphinxbfcode{resume\_sim}}{\emph{directory}, \emph{job\_num}, \emph{job\_type}, \emph{max\_time}}{}
Resumes the simulation from the specified directory, looking for the simulation with the specified seed and task
referencing.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{directory} -- the directory to search for the paused simulation

\item {} 
\sphinxstyleliteralstrong{job\_num} -- the seed of the paused simulation

\item {} 
\sphinxstyleliteralstrong{job\_type} -- the task of the paused simulation

\item {} 
\sphinxstyleliteralstrong{max\_time} -- the maximum time to run simulations for

\end{itemize}

\end{description}\end{quote}
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
None

\end{description}\end{quote}

\end{fulllineitems}

\index{run\_checks() (Coalescence method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{PyCoalescence:PyCoalescence.coalescence.Coalescence.run_checks}}\pysiglinewithargsret{\sphinxbfcode{run\_checks}}{}{}
Check that the simulation is correctly set up and that all the required files exist.

\end{fulllineitems}

\index{run\_coalescence() (Coalescence method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{PyCoalescence:PyCoalescence.coalescence.Coalescence.run_coalescence}}\pysiglinewithargsret{\sphinxbfcode{run\_coalescence}}{}{}
Attempt to run the simulation with the given simulation set-up.
This is the main routine performing the actual simulation which will take a considerable amount of time.

\end{fulllineitems}

\index{run\_simple() (Coalescence method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{PyCoalescence:PyCoalescence.coalescence.Coalescence.run_simple}}\pysiglinewithargsret{\sphinxbfcode{run\_simple}}{\emph{seed}, \emph{task}, \emph{output}, \emph{alpha}, \emph{sigma}, \emph{size}}{}
Runs a simple coalescence simulation on a square infinite landscape with the provided parameters.
This requires a separate compilation of the inf\_land version of the coalescence simulator.

Note that this function returns richness=0 for failure to read from the file. It is assumed that there will
be at least one species in the simulation.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{seed} -- the simulation seed

\item {} 
\sphinxstyleliteralstrong{task} -- the task (for file naming)

\item {} 
\sphinxstyleliteralstrong{output} -- the output directory

\item {} 
\sphinxstyleliteralstrong{alpha} -- the speciation rate (also nu)

\item {} 
\sphinxstyleliteralstrong{sigma} -- the normal distribution sigma value for dispersal

\item {} 
\sphinxstyleliteralstrong{size} -- the size of the world (so there will be size\textasciicircum{}2 individuals simulated)

\end{itemize}

\item[{Returns}] \leavevmode
the species richness in the simulation

\end{description}\end{quote}

\end{fulllineitems}

\index{set\_bci() (Coalescence method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{PyCoalescence:PyCoalescence.coalescence.Coalescence.set_bci}}\pysiglinewithargsret{\sphinxbfcode{set\_bci}}{\emph{job\_num}, \emph{job\_type}, \emph{zfat}, \emph{dispersal}, \emph{output\_directory=None}, \emph{data\_directory='./'}}{}
Sets up the simulation for the BCI and other CTFS plots in Panama (sampling only the CTFS plots).
This requires the compute node to have been specified beforehand.

Currently runs for 40 hours then stops the simulation.

\end{fulllineitems}

\index{set\_compute\_node() (Coalescence method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{PyCoalescence:PyCoalescence.coalescence.Coalescence.set_compute_node}}\pysiglinewithargsret{\sphinxbfcode{set\_compute\_node}}{\emph{compute\_node}}{}
Sets the compute node and (for pre-defined nodes) runs the setup routine.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{compute\_node} (\href{https://docs.python.org/2/library/functions.html\#str}{\sphinxstyleliteralemphasis{str}}) -- the reference for the desired compute node, chosen from pre-specified options

\end{description}\end{quote}

\end{fulllineitems}

\index{set\_map\_config() (Coalescence method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{PyCoalescence:PyCoalescence.coalescence.Coalescence.set_map_config}}\pysiglinewithargsret{\sphinxbfcode{set\_map\_config}}{\emph{file}}{}
Sets a specific map config and tells the program that full commmand-line parsing is not required.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{file} (\href{https://docs.python.org/2/library/functions.html\#str}{\sphinxstyleliteralemphasis{str}}) -- the file to read map config options from

\end{description}\end{quote}

\end{fulllineitems}

\index{set\_map\_files() (Coalescence method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{PyCoalescence:PyCoalescence.coalescence.Coalescence.set_map_files}}\pysiglinewithargsret{\sphinxbfcode{set\_map\_files}}{\emph{sample\_file}, \emph{fine\_file=None}, \emph{coarse\_file=None}, \emph{pristine\_fine\_file=None}, \emph{pristine\_coarse\_file=None}}{}
Sets the map files (or to null, if none specified). It then calls detect\_map\_dimensions() to correctly read in
the specified dimensions.
Note that if sample\_file is ``null'', values will remain at 0.
If coarse\_file is ``null'', it will default to the size of fine\_file with zero offset.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{sample\_file} -- the sample map file. Provide ``null'' if on samplemask is required.

\item {} 
\sphinxstyleliteralstrong{fine\_file} -- the fine map file. Defaults to ``null'' if none provided.

\item {} 
\sphinxstyleliteralstrong{coarse\_file} -- the coarse map file. Defaults to ``null'' if none provided.

\item {} 
\sphinxstyleliteralstrong{pristine\_fine\_file} -- the pristine fine map file. Defaults to ``null'' if none provided.

\item {} 
\sphinxstyleliteralstrong{pristine\_coarse\_file} -- the pristine coarse map file. Defaults to ``null'' if none provided.

\end{itemize}

\end{description}\end{quote}

:rtype None

:return None

\end{fulllineitems}

\index{set\_map\_parameters() (Coalescence method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{PyCoalescence:PyCoalescence.coalescence.Coalescence.set_map_parameters}}\pysiglinewithargsret{\sphinxbfcode{set\_map\_parameters}}{\emph{sample\_file}, \emph{sample\_x}, \emph{sample\_y}, \emph{fine\_file}, \emph{fine\_x}, \emph{fine\_y}, \emph{fine\_x\_offset}, \emph{fine\_y\_offset}, \emph{coarse\_file}, \emph{coarse\_x}, \emph{coarse\_y}, \emph{coarse\_x\_offset}, \emph{coarse\_y\_offset}, \emph{coarse\_scale}, \emph{pristine\_fine\_map}, \emph{pristine\_coarse\_map}}{}
Set up the map objects with the required parameters. This is required for csv file usage.

Note that this function is not recommended for tif file usage, as it is much simpler to call set\_map\_files() and
which should automatically calculate map offsets, scaling and dimensions.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{sample\_file} -- the sample file to use, which should contain a boolean mask of where to sample

\item {} 
\sphinxstyleliteralstrong{sample\_x} -- the x dimension of the sample file

\item {} 
\sphinxstyleliteralstrong{sample\_y} -- the y dimension of the sample file

\item {} 
\sphinxstyleliteralstrong{fine\_file} -- the fine map file to use (must be equal to or larger than the sample file)

\item {} 
\sphinxstyleliteralstrong{fine\_x} -- the x dimension of the fine map file

\item {} 
\sphinxstyleliteralstrong{fine\_y} -- the y dimension of the fine map file

\item {} 
\sphinxstyleliteralstrong{fine\_x\_offset} -- the x offset of the fine map file

\item {} 
\sphinxstyleliteralstrong{fine\_y\_offset} -- the y offset of the fine map file

\item {} 
\sphinxstyleliteralstrong{coarse\_file} -- the coarse map file to use (must be equal to or larger than fine map file)

\item {} 
\sphinxstyleliteralstrong{coarse\_x} -- the x dimension of the coarse map file

\item {} 
\sphinxstyleliteralstrong{coarse\_y} -- the y dimension of the coarse map file

\item {} 
\sphinxstyleliteralstrong{coarse\_x\_offset} -- the x offset of the coarse map file at the resolution of the fine map

\item {} 
\sphinxstyleliteralstrong{coarse\_y\_offset} -- the y offset of the coarse map file at the resoultion of the fine map

\item {} 
\sphinxstyleliteralstrong{coarse\_scale} -- the relative scale of the coarse map compared to the fine map (must match x and y scaling)

\item {} 
\sphinxstyleliteralstrong{pristine\_fine\_map} -- the pristine fine map file to use (must have dimensions equal to fine map)

\item {} 
\sphinxstyleliteralstrong{pristine\_coarse\_map} -- the pristine coarse map file to use (must have dimensions equal to coarse map)

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{set\_panama() (Coalescence method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{PyCoalescence:PyCoalescence.coalescence.Coalescence.set_panama}}\pysiglinewithargsret{\sphinxbfcode{set\_panama}}{\emph{job\_num}, \emph{job\_type}, \emph{zfat}, \emph{dispersal}, \emph{output\_directory=None}, \emph{data\_directory=None}}{}
Sets up the simulation for the whole of Panama.
This simulation require a massive amount of RAM and CPU time, so it is advisable to call this function only on HPC clusters.

\end{fulllineitems}

\index{set\_simulation\_params() (Coalescence method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{PyCoalescence:PyCoalescence.coalescence.Coalescence.set_simulation_params}}\pysiglinewithargsret{\sphinxbfcode{set\_simulation\_params}}{\emph{job\_num}, \emph{job\_type}, \emph{output\_directory}, \emph{min\_speciation\_rate}, \emph{zfat}, \emph{dispersal}, \emph{deme}, \emph{sample\_size}, \emph{max\_time}, \emph{lambda\_value}, \emph{min\_num\_species}, \emph{forest\_change\_param}, \emph{pristine\_forest}, \emph{time\_config\_file}}{}
Set all the simulation parameters apart from the map objects.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{job\_num} (\href{https://docs.python.org/2/library/functions.html\#int}{\sphinxstyleliteralemphasis{int}}) -- the unique job number for this simulation set

\item {} 
\sphinxstyleliteralstrong{job\_type} (\href{https://docs.python.org/2/library/functions.html\#int}{\sphinxstyleliteralemphasis{int}}) -- the job type (used for easy file identification after simulations are complete)

\item {} 
\sphinxstyleliteralstrong{output\_directory} (\href{https://docs.python.org/2/library/functions.html\#str}{\sphinxstyleliteralemphasis{str}}) -- the output directory to store the SQL database

\item {} 
\sphinxstyleliteralstrong{min\_speciation\_rate} (\href{https://docs.python.org/2/library/functions.html\#float}{\sphinxstyleliteralemphasis{float}}) -- the minimum speciation rate to simulate

\item {} 
\sphinxstyleliteralstrong{zfat} (\href{https://docs.python.org/2/library/functions.html\#float}{\sphinxstyleliteralemphasis{float}}) -- the dispersal zfat value, also called eta.

\item {} 
\sphinxstyleliteralstrong{dispersal} (\href{https://docs.python.org/2/library/functions.html\#float}{\sphinxstyleliteralemphasis{float}}) -- the dispersal L value.

\item {} 
\sphinxstyleliteralstrong{deme} (\href{https://docs.python.org/2/library/functions.html\#int}{\sphinxstyleliteralemphasis{int}}) -- the deme size (in individuals per cell)

\item {} 
\sphinxstyleliteralstrong{sample\_size} (\href{https://docs.python.org/2/library/functions.html\#float}{\sphinxstyleliteralemphasis{float}}) -- the sample size of the deme (decimal 0-1)

\item {} 
\sphinxstyleliteralstrong{max\_time} (\href{https://docs.python.org/2/library/functions.html\#float}{\sphinxstyleliteralemphasis{float}}) -- the maximum allowed simulation time (in seconds)

\item {} 
\sphinxstyleliteralstrong{lambda\_value} (\href{https://docs.python.org/2/library/functions.html\#float}{\sphinxstyleliteralemphasis{float}}) -- the relative cost of travelling through non-habitat (default is 1)

\item {} 
\sphinxstyleliteralstrong{min\_num\_species} (\href{https://docs.python.org/2/library/functions.html\#int}{\sphinxstyleliteralemphasis{int}}) -- the minimum number of species known to exist

\item {} 
\sphinxstyleliteralstrong{forest\_change\_param} (\href{https://docs.python.org/2/library/functions.html\#float}{\sphinxstyleliteralemphasis{float}}) -- the rate of forest change over time

\item {} 
\sphinxstyleliteralstrong{pristine\_forest} (\href{https://docs.python.org/2/library/functions.html\#float}{\sphinxstyleliteralemphasis{float}}) -- the time in generations since a pristine state was achieved

\item {} 
\sphinxstyleliteralstrong{time\_config\_file} (\href{https://docs.python.org/2/library/functions.html\#str}{\sphinxstyleliteralemphasis{str}}) -- the path to the time config file (or null)

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{set\_speciation\_params() (Coalescence method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{PyCoalescence:PyCoalescence.coalescence.Coalescence.set_speciation_params}}\pysiglinewithargsret{\sphinxbfcode{set\_speciation\_params}}{\emph{file}, \emph{record\_spatial}, \emph{record\_fragments}, \emph{speciation\_rates}, \emph{sample\_file=None}, \emph{time\_config\_file=None}}{}
Set the parameters for the application of speciation rates. If no config files or time\_config files are provided,
they will be taken from the main coalescence simulation.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{file} (\href{https://docs.python.org/2/library/functions.html\#str}{\sphinxstyleliteralemphasis{str}}) -- the file to read speciation parameters from

\item {} 
\sphinxstyleliteralstrong{str record\_spatial} (\href{https://docs.python.org/2/library/functions.html\#bool}{\sphinxstyleliteralemphasis{bool}}\sphinxstyleliteralemphasis{,}\sphinxstyleliteralemphasis{}) -- a boolean of whether to record spatial data

\item {} 
\sphinxstyleliteralstrong{record\_fragments} (\href{https://docs.python.org/2/library/functions.html\#str}{\sphinxstyleliteralemphasis{str}}) -- either a csv file containing fragment data, or T/F for whether fragments should be
calculated from squares of continuous habitat.

\item {} 
\sphinxstyleliteralstrong{speciation\_rates} (\href{https://docs.python.org/2/library/functions.html\#list}{\sphinxstyleliteralemphasis{list}}) -- a list of speciation rates to apply

\item {} 
\sphinxstyleliteralstrong{sample\_file} (\href{https://docs.python.org/2/library/functions.html\#str}{\sphinxstyleliteralemphasis{str}}) -- a sample tif or csv specifying the sampling mask

\item {} 
\sphinxstyleliteralstrong{time\_config\_file} (\href{https://docs.python.org/2/library/functions.html\#str}{\sphinxstyleliteralemphasis{str}}) -- a configuration file of temporal sampling points

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{set\_speciation\_rates() (Coalescence method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{PyCoalescence:PyCoalescence.coalescence.Coalescence.set_speciation_rates}}\pysiglinewithargsret{\sphinxbfcode{set\_speciation\_rates}}{\emph{speciation\_rates}}{}
Add speciation rates for analysis at the end of the simulation. This is optional
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{speciation\_rates} (\href{https://docs.python.org/2/library/functions.html\#list}{\sphinxstyleliteralemphasis{list}}) -- a list of speciation rates to apply at the end of the simulation

\end{description}\end{quote}

\end{fulllineitems}

\index{setup() (Coalescence method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{PyCoalescence:PyCoalescence.coalescence.Coalescence.setup}}\pysiglinewithargsret{\sphinxbfcode{setup}}{\emph{coalescence\_simulator='build/default/./NECSim'}, \emph{speciation\_simulator='build/default/./SpeciationCounter'}}{}
Set the location of the coalescence and speciation executables. Make sure that both programs have been compiled
for the operating system running the simulations.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{coalescence\_simulator} (\href{https://docs.python.org/2/library/functions.html\#str}{\sphinxstyleliteralemphasis{str}}) -- the path to the Coal\_v1 executable

\item {} 
\sphinxstyleliteralstrong{speciation\_simulator} (\href{https://docs.python.org/2/library/functions.html\#str}{\sphinxstyleliteralemphasis{str}}) -- the path to the Speciation\_Counter executable

\end{itemize}

\item[{Returns}] \leavevmode


\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{Map (class in PyCoalescence.coalescence)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{PyCoalescence:PyCoalescence.coalescence.Map}}\pysiglinewithargsret{\sphinxstrong{class }\sphinxbfcode{Map}}{\emph{is\_sample=None}}{}
A class for the map object, containing the file name and the variables associated with this map object.
\index{calculate\_offset() (Map method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{PyCoalescence:PyCoalescence.coalescence.Map.calculate_offset}}\pysiglinewithargsret{\sphinxbfcode{calculate\_offset}}{\emph{file\_offset}}{}
Calculates the offset of the map object from the supplied file\_offset.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{file\_offset} (\sphinxstyleliteralemphasis{str/Map}) -- the path to the file to calculate the offset.
Can also be a Map object with the filename contained.

\item[{Returns}] \leavevmode
the offset x and y (at the resolution of the file\_home) in integers

\end{description}\end{quote}

\end{fulllineitems}

\index{calculate\_scale() (Map method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{PyCoalescence:PyCoalescence.coalescence.Map.calculate_scale}}\pysiglinewithargsret{\sphinxbfcode{calculate\_scale}}{\emph{file\_scaled}}{}
Calculates the scale of map object from the supplied file\_scaled.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{file\_scaled} (\sphinxstyleliteralemphasis{str/Map}) -- the path to the file to calculate the scale.

\item[{Returns}] \leavevmode
the scale (of the x dimension)

\end{description}\end{quote}

\end{fulllineitems}

\index{check\_map() (Map method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{PyCoalescence:PyCoalescence.coalescence.Map.check_map}}\pysiglinewithargsret{\sphinxbfcode{check\_map}}{}{}
Checks that the dimensions for the map have been set and that the map file exists

\end{fulllineitems}

\index{get\_dimensions() (Map method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{PyCoalescence:PyCoalescence.coalescence.Map.get_dimensions}}\pysiglinewithargsret{\sphinxbfcode{get\_dimensions}}{}{}
Calls read\_dimensions() if dimensions have not been read, or reads stored information.
:return: a list containing {[}0{]} x, {[}1{]} y, {[}2{]} upper left x, {[}3{]} upper left y, {[}4{]} x resolution, {[}5{]} y resolution
.. note:: the returned list will contain the x and y offset values instead of the ulx and uly values if the
\begin{quote}

dimensions have already been set (i.e. self.x\_size != 0 and self.y\_size != 0)
\end{quote}

\end{fulllineitems}

\index{get\_x\_y() (Map method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{PyCoalescence:PyCoalescence.coalescence.Map.get_x_y}}\pysiglinewithargsret{\sphinxbfcode{get\_x\_y}}{}{}
Simply returns the x and y dimension of the file.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{file} (\href{https://docs.python.org/2/library/functions.html\#str}{\sphinxstyleliteralemphasis{str}}) -- the file to examine

\item[{Returns}] \leavevmode
the x and y dimensions

\end{description}\end{quote}

\end{fulllineitems}

\index{read\_dimensions() (Map method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{PyCoalescence:PyCoalescence.coalescence.Map.read_dimensions}}\pysiglinewithargsret{\sphinxbfcode{read\_dimensions}}{}{}
Return a list containing the geospatial coordinate system for the file.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
a list containing {[}0{]} x, {[}1{]} y, {[}2{]} upper left x, {[}3{]} upper left y, {[}4{]} x resolution, {[}5{]} y resolution

\end{description}\end{quote}

\end{fulllineitems}

\index{set\_dimensions() (Map method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{PyCoalescence:PyCoalescence.coalescence.Map.set_dimensions}}\pysiglinewithargsret{\sphinxbfcode{set\_dimensions}}{\emph{file\_name=None}, \emph{x\_size=None}, \emph{y\_size=None}, \emph{x\_offset=None}, \emph{y\_offset=None}}{}
Sets the dimensions and file for the Map object
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{file\_name} (\href{https://docs.python.org/2/library/functions.html\#str}{\sphinxstyleliteralemphasis{str}}) -- the location of the map object (a csv or tif file). If None, required that file\_name is already provided.

\item {} 
\sphinxstyleliteralstrong{x\_size} (\href{https://docs.python.org/2/library/functions.html\#int}{\sphinxstyleliteralemphasis{int}}) -- the x dimension

\item {} 
\sphinxstyleliteralstrong{y\_size} (\href{https://docs.python.org/2/library/functions.html\#int}{\sphinxstyleliteralemphasis{int}}) -- the y dimension

\item {} 
\sphinxstyleliteralstrong{x\_offset} (\href{https://docs.python.org/2/library/functions.html\#int}{\sphinxstyleliteralemphasis{int}}) -- the x offset from the north-west corner

\item {} 
\sphinxstyleliteralstrong{y\_offset} (\href{https://docs.python.org/2/library/functions.html\#int}{\sphinxstyleliteralemphasis{int}}) -- the y offset from the north-west corner

\end{itemize}

\item[{Returns}] \leavevmode


\end{description}\end{quote}

\end{fulllineitems}

\index{set\_sample() (Map method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{PyCoalescence:PyCoalescence.coalescence.Map.set_sample}}\pysiglinewithargsret{\sphinxbfcode{set\_sample}}{\emph{is\_sample}}{}
Set the is\_sample attribute to true if this is a sample mask rather than an offset map
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{is\_sample} (\href{https://docs.python.org/2/library/functions.html\#bool}{\sphinxstyleliteralemphasis{bool}}) -- indicates this is a sample mask rather than offset map

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}



\paragraph{setup file}
\label{\detokenize{PyCoalescence:setup-file}}\label{\detokenize{PyCoalescence:module-PyCoalescence.setup}}\index{PyCoalescence.setup (module)}
Sets up the NECSim executables. It configures the install by detecting system components and compiles the \sphinxcode{c++} files,
if possible. Command line flags can be provided (see {\hyperref[\detokenize{index:sec-compilation-options}]{\sphinxcrossref{\DUrole{std,std-ref}{Compilation Options}}}} for more
information) to modify the install.
\index{autoconf() (in module PyCoalescence.setup)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{PyCoalescence:PyCoalescence.setup.autoconf}}\pysiglinewithargsret{\sphinxbfcode{autoconf}}{}{}
Runs the \sphinxtitleref{autoconf} bash function (assuming that autoconf is available) to create the \sphinxtitleref{configure} executable.

\end{fulllineitems}

\index{clean() (in module PyCoalescence.setup)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{PyCoalescence:PyCoalescence.setup.clean}}\pysiglinewithargsret{\sphinxbfcode{clean}}{}{}
Runs make clean in the NECSim directory to wipe any previous potential compile attempts.

\end{fulllineitems}

\index{configure() (in module PyCoalescence.setup)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{PyCoalescence:PyCoalescence.setup.configure}}\pysiglinewithargsret{\sphinxbfcode{configure}}{\emph{opts=None}}{}
Runs ./configure --opts with the supplied options. This should create the makefile for compilation, otherwise a
RuntimeError will be thrown.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{opts} -- a list of options to pass to the ./configure call

\end{description}\end{quote}

\end{fulllineitems}

\index{do\_compile() (in module PyCoalescence.setup)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{PyCoalescence:PyCoalescence.setup.do_compile}}\pysiglinewithargsret{\sphinxbfcode{do\_compile}}{}{}
Compiles the c++ NECSim program by running make. This changes the working directory to wherever the module has been
installed for the subprocess call.

\end{fulllineitems}

\index{main() (in module PyCoalescence.setup)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{PyCoalescence:PyCoalescence.setup.main}}\pysiglinewithargsret{\sphinxbfcode{main}}{\emph{argv=None}}{}
Runs the install for compile options provided via the command line, or with default options if no options exist.
Running with \sphinxcode{-help} or \sphinxtitleref{-h} will display the compilation configurations called from \sphinxcode{./configure}.

\end{fulllineitems}

\index{move\_executable() (in module PyCoalescence.setup)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{PyCoalescence:PyCoalescence.setup.move_executable}}\pysiglinewithargsret{\sphinxbfcode{move\_executable}}{\emph{directory='build/default/'}}{}
Moves the executable to the specified directory from within NECSim. Will always look for NECSim relative to the
setup.py (so can be called from another module location).
This allows for multiple compilation options with different versions stored in different folders.

Throws an IOError when the NECSim executable is not found.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{directory} -- the directory to move the NECSim excecutable to.

\end{description}\end{quote}

\end{fulllineitems}

\index{set\_wd() (in module PyCoalescence.setup)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{PyCoalescence:PyCoalescence.setup.set_wd}}\pysiglinewithargsret{\sphinxbfcode{set\_wd}}{}{}
There should be two calls to this function.
\begin{itemize}
\item {} 
The first sets the working directory to the location of setup.py

\item {} 
The second moves the working directory back to its original location.

\end{itemize}

The second call should be before the move\_executable() call so that the new executables are moved to the path
supplied relative to the parent file. Otherwise executables will be moved relative to setup.py

\end{fulllineitems}



\paragraph{hpc\_setup file}
\label{\detokenize{PyCoalescence:hpc-setup-file}}\label{\detokenize{PyCoalescence:module-PyCoalescence.hpc_setup}}\index{PyCoalescence.hpc\_setup (module)}
Sets up the code for the hpc and moves the executable to the correct directory.
\index{build\_hpc() (in module PyCoalescence.hpc\_setup)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{PyCoalescence:PyCoalescence.hpc_setup.build_hpc}}\pysiglinewithargsret{\sphinxbfcode{build\_hpc}}{}{}
Compiles NECSim with the \sphinxcode{-{-}with-hpc}, \sphinxcode{-{-}with-verbose} and \sphinxcode{-{-}with-fat\_tail\_dispersal} flags, and moves the
executable to ../../Code/ relative to the file location.
:return:

\end{fulllineitems}



\subsection{C++ Documentation (NECSim)}
\label{\detokenize{Exhaled/exhaled_library::doc}}\label{\detokenize{Exhaled/exhaled_library:c-documentation-necsim}}
A Neutral Ecology Coalescence Simulator.

Version: 3.6

\begin{sphinxShadowBox}
\begin{itemize}
\item {} 
\phantomsection\label{\detokenize{Exhaled/exhaled_library:id4}}{\hyperref[\detokenize{Exhaled/exhaled_library:introduction}]{\sphinxcrossref{Introduction}}}
\begin{itemize}
\item {} 
\phantomsection\label{\detokenize{Exhaled/exhaled_library:id5}}{\hyperref[\detokenize{Exhaled/exhaled_library:necsim}]{\sphinxcrossref{NECSim}}}

\item {} 
\phantomsection\label{\detokenize{Exhaled/exhaled_library:id6}}{\hyperref[\detokenize{Exhaled/exhaled_library:a-note-on-the-neutral-theory-of-ecology}]{\sphinxcrossref{A Note on the Neutral Theory of Ecology}}}

\end{itemize}

\item {} 
\phantomsection\label{\detokenize{Exhaled/exhaled_library:id7}}{\hyperref[\detokenize{Exhaled/exhaled_library:instructions}]{\sphinxcrossref{Instructions}}}
\begin{itemize}
\item {} 
\phantomsection\label{\detokenize{Exhaled/exhaled_library:id8}}{\hyperref[\detokenize{Exhaled/exhaled_library:compiling-the-program}]{\sphinxcrossref{Compiling the program}}}

\item {} 
\phantomsection\label{\detokenize{Exhaled/exhaled_library:id9}}{\hyperref[\detokenize{Exhaled/exhaled_library:running-simulations}]{\sphinxcrossref{Running simulations}}}

\item {} 
\phantomsection\label{\detokenize{Exhaled/exhaled_library:id10}}{\hyperref[\detokenize{Exhaled/exhaled_library:outputs}]{\sphinxcrossref{Outputs}}}

\end{itemize}

\item {} 
\phantomsection\label{\detokenize{Exhaled/exhaled_library:id11}}{\hyperref[\detokenize{Exhaled/exhaled_library:speciationcounter}]{\sphinxcrossref{SpeciationCounter}}}
\begin{itemize}
\item {} 
\phantomsection\label{\detokenize{Exhaled/exhaled_library:id12}}{\hyperref[\detokenize{Exhaled/exhaled_library:applying-speciation-rates}]{\sphinxcrossref{Applying Speciation Rates}}}

\item {} 
\phantomsection\label{\detokenize{Exhaled/exhaled_library:id13}}{\hyperref[\detokenize{Exhaled/exhaled_library:debugging}]{\sphinxcrossref{Debugging}}}

\item {} 
\phantomsection\label{\detokenize{Exhaled/exhaled_library:id14}}{\hyperref[\detokenize{Exhaled/exhaled_library:brief-class-descriptions}]{\sphinxcrossref{Brief Class Descriptions}}}

\item {} 
\phantomsection\label{\detokenize{Exhaled/exhaled_library:id15}}{\hyperref[\detokenize{Exhaled/exhaled_library:known-bugs}]{\sphinxcrossref{Known Bugs}}}

\item {} 
\phantomsection\label{\detokenize{Exhaled/exhaled_library:id16}}{\hyperref[\detokenize{Exhaled/exhaled_library:faqs-wip}]{\sphinxcrossref{FAQS (WIP)}}}

\item {} 
\phantomsection\label{\detokenize{Exhaled/exhaled_library:id17}}{\hyperref[\detokenize{Exhaled/exhaled_library:contacts}]{\sphinxcrossref{Contacts}}}

\item {} 
\phantomsection\label{\detokenize{Exhaled/exhaled_library:id18}}{\hyperref[\detokenize{Exhaled/exhaled_library:licence}]{\sphinxcrossref{Licence}}}

\item {} 
\phantomsection\label{\detokenize{Exhaled/exhaled_library:id19}}{\hyperref[\detokenize{Exhaled/exhaled_library:class-hierarchy}]{\sphinxcrossref{Class Hierarchy}}}

\item {} 
\phantomsection\label{\detokenize{Exhaled/exhaled_library:id20}}{\hyperref[\detokenize{Exhaled/exhaled_library:file-hierarchy}]{\sphinxcrossref{File Hierarchy}}}

\item {} 
\phantomsection\label{\detokenize{Exhaled/exhaled_library:id21}}{\hyperref[\detokenize{Exhaled/exhaled_library:full-api}]{\sphinxcrossref{Full API}}}

\end{itemize}

\item {} 
\phantomsection\label{\detokenize{Exhaled/exhaled_library:id22}}{\hyperref[\detokenize{Exhaled/exhaled_library:namespaces}]{\sphinxcrossref{Namespaces}}}

\item {} 
\phantomsection\label{\detokenize{Exhaled/exhaled_library:id23}}{\hyperref[\detokenize{Exhaled/exhaled_library:classes-and-structs}]{\sphinxcrossref{Classes and Structs}}}

\item {} 
\phantomsection\label{\detokenize{Exhaled/exhaled_library:id24}}{\hyperref[\detokenize{Exhaled/exhaled_library:functions}]{\sphinxcrossref{Functions}}}

\item {} 
\phantomsection\label{\detokenize{Exhaled/exhaled_library:id25}}{\hyperref[\detokenize{Exhaled/exhaled_library:variables}]{\sphinxcrossref{Variables}}}

\item {} 
\phantomsection\label{\detokenize{Exhaled/exhaled_library:id26}}{\hyperref[\detokenize{Exhaled/exhaled_library:defines}]{\sphinxcrossref{Defines}}}

\item {} 
\phantomsection\label{\detokenize{Exhaled/exhaled_library:id27}}{\hyperref[\detokenize{Exhaled/exhaled_library:files}]{\sphinxcrossref{Files}}}

\end{itemize}
\end{sphinxShadowBox}


\subsubsection{Introduction}
\label{\detokenize{Exhaled/exhaled_library:introduction}}\label{\detokenize{Exhaled/exhaled_library:introduction-necsim}}

\paragraph{NECSim}
\label{\detokenize{Exhaled/exhaled_library:necsim}}
Provided here is a set of tools for running and analysing backwards-time (coalescent) neutral models in ecology. NECSim is a generic spatial coalescence simulator for neutral systems.
It applies the model to maps for the supplied parameters and outputs information for each
individual to a SQL database.

SpeciationCounter is a program for applying varying speciation rates to
outputs of NECSim for analysis after simulations are complete. This
enables the main simulation to be run with the \sphinxstyleemphasis{minimum} speciation rate
required and afterwards analysis can be completed using different
speciation rates. The same functionality is also provided within NECSim for application of speciation rates immediately after simulations are complete.


\paragraph{A Note on the Neutral Theory of Ecology}
\label{\detokenize{Exhaled/exhaled_library:a-note-on-the-neutral-theory-of-ecology}}
Neutral theory in ecology refers to the idea that individuals can be modelled as ecologically identical entities, undergoing dispersal, drift and speciation without niche effects or other competitive elements.

Whilst obviously not realistic, the patterns produced by such models can often give a suprisingly accurate protrayal of real-world systems. For more information on the topic, please see \phantomsection\label{\detokenize{Exhaled/exhaled_library:id1}}{\hyperref[\detokenize{Exhaled/exhaled_library:hubbell2001}]{\sphinxcrossref{{[}Hubbell2001{]}}}}.


\subsubsection{Instructions}
\label{\detokenize{Exhaled/exhaled_library:instructions}}

\paragraph{Compiling the program}
\label{\detokenize{Exhaled/exhaled_library:compiling-the-program}}
For compilation, there are several provided options:
\begin{itemize}
\item {} 
Compilation can be handled within PyCoalescence by running \sphinxcode{python setup.py}. \sphinxstylestrong{This is the recommended option.}

\item {} 
Alternatively, compilation can be completed with additional options using make. The steps are outlined below
\begin{itemize}
\item {} 
You might need to first run \sphinxcode{autoconf} from within the NECSim directory to generate the configure executable.

\item {} 
Run \sphinxcode{./configure} (located within the NECSim directory). Provide additional compilation flags if necessary (detailed below).

\item {} 
Run \sphinxcode{make all} to create the executable.

\item {} 
{[}Optional{]} Move the executable (called NECSim) to the \sphinxstyleemphasis{build/Default} directory in \sphinxstylestrong{PyCoalescence}.

\end{itemize}

\item {} 
If you require compilation outside of the PyCoalescence module, make use of the the file \sphinxstylestrong{Makefile} located in
\sphinxstylestrong{Makefiles/SimpleCompile}. This can be modified and run using \sphinxcode{make} to generate the executable.

\end{itemize}

Compilation on High-performance clusters will likely require an icc compiler and custom linking to the required libraries.

See the Requirements section for a full list of the necessary
prerequisites.


\subparagraph{Requirements}
\label{\detokenize{Exhaled/exhaled_library:requirements}}\begin{itemize}
\item {} 
The SQLite library available \href{https://www.sqlite.org/download.html}{here}.

\item {} 
The Boost library available \href{http://www.boost.org}{here}.

\item {} 
C++ compiler (such as GNU g++) with C++11 support.

\item {} 
Access to the relevant folders for Default simulations (see FAQS).

\end{itemize}

Recommended, but not essential:
\begin{itemize}
\item {} 
gdal library available \href{http://www.gdal.org}{here}: provides reading of tif files.

\item {} \begin{description}
\item[{The fast-cpp-csv-parser by Ben Strasser, available}] \leavevmode
\href{https://github.com/ben-strasser/fast-cpp-csv-parser}{here}: provides much faster csv read and write capabilities.

\end{description}

\end{itemize}


\subparagraph{Compiler Options}
\label{\detokenize{Exhaled/exhaled_library:compiler-options}}
Recognised compiler options include:

\noindent\begin{tabulary}{\linewidth}{|L|L|}
\hline
\sphinxstylethead{\relax 
Option
\unskip}\relax &\sphinxstylethead{\relax 
Description
\unskip}\relax \\
\hline
--with-debug
&
Adds additional debugging information
\\
\hline
--with-restrict\_self
&
Restricts self-selection during dispersal. Individuals can therefore not become their own parent
\\
\hline
--with-verbose
&
Prints information to the terminal. Otherwise, prints to a log file in \sphinxstyleemphasis{Logs/}
\\
\hline
--with-normal\_dispersal
&
Choose a normal distribution for dispersal distances
\\
\hline
--with-fat\_tail\_dispersal
&
Choose a fat-tailed kernel for dispersal distances
\\
\hline
--with-infinite\_landscape
&
Map boundaries are ignored and individuals can disperse to anywhere.
\\
\hline
--with-gdal=DIR
&
Define a gdal library at DIR
\\
\hline
--with-hpc
&
Compile ready for HPC, using intel's icpc compilation and a variety of optimisation flags.
\\
\hline
--with-boost=DIR
&
Define a boost library at DIR
\\
\hline\end{tabulary}


Additional c++ compilation flags can be specified by \sphinxcode{CPPFLAGS=opts} for additional library paths or compilation options as required.

Note that gdal and fast-cpp-csv-parser availability will be automatically detected and included in the compilation if possible.


\paragraph{Running simulations}
\label{\detokenize{Exhaled/exhaled_library:running-simulations}}
As of version 3.1 and above, the routine relies on
supplying command line arguments (see below) for all the major
simulation variables. Alternatively, supplying a config .txt file and
using the command line arguments \sphinxcode{./NECSim -c /path/to/config.txt}
can be used for parsing command line arguments from the text file.


\subparagraph{Command Line Arguments}
\label{\detokenize{Exhaled/exhaled_library:command-line-arguments}}
The following command line arguments are required. This list can be
accessed by running \sphinxcode{./NECSim -h} or \sphinxcode{./NECSim -help}

As of version 3.6 and above, the command line options to be specified are:
\begin{enumerate}
\item {} 
the seed for the simulation.

\item {} 
the simulation task (for file reference).

\item {} 
the map config file.

\item {} 
the output directory.

\item {} 
the minimum speciation rate.

\item {} 
the dispersal z\_fat value.

\item {} 
the dispersal L value.

\item {} 
the deme size.

\item {} 
the deme sample size.

\item {} 
the maximum simulation time (in seconds).

\item {} 
the lambda value for moving through non-habitat.

\item {} 
the temporal sampling file containing generation
values for sampling points in time (null for only sampling the
present)

\item {} 
the minimum number of species known to exist. (Currently has no
effect).

\item {} 
(and onwards) speciation rates to apply after simulation.

\end{enumerate}

In this format, the map config file and temporal sampling file are as described in {\hyperref[\detokenize{Exhaled/exhaled_library:config-files}]{\sphinxcrossref{Config Files}}}.

Alternatively, by specifying the -f flag, (full mode) as the first
argument, the program can read in pre-3.6 command line arguments, which
are as followed.
\begin{enumerate}
\item {} 
the task\_iter used for setting the seed.

\item {} 
the sample grid x dimension

\item {} 
the sample grid y dimension

\item {} 
the fine map file relative path.

\item {} 
the fine map x dimension

\item {} 
the fine map y dimension

\item {} 
the fine map x offset

\item {} 
the fine map y offset

\item {} 
the coarse map file relative path.

\item {} 
the coarse map x dimension

\item {} 
the coarse map y dimension

\item {} 
the coarse map x offset

\item {} 
the coarse map y offset

\item {} 
the scale of the coarse map compared to the fine (10 means
resolution of coarse map = 10 x resolution of fine map)

\item {} 
the output directory

\item {} 
the speciation rate.

\item {} 
the dispersal distance (zfat).

\item {} 
the deme size

\item {} 
the deme sample size (as a proportion of deme size)

\item {} 
the time to run the simulation (in seconds).

\item {} 
lambda - the relative cost of moving through non-forest

\item {} 
the\_task - for referencing the specific task later on.

\item {} 
the minimum number of species the system is known to contain.

\item {} 
the pristine fine map file to use

\item {} 
the pristine coarse map file to use

\item {} 
the rate of forest change from pristine

\item {} 
the time (in generations) since the pristine forest was seen.

\item {} 
the dispersal L value (the width of the kernel.

\item {} 
the sample mask, with binary 1:0 values for areas that we want to
sample from. If this is not provided then this will default to
mapping the whole area.

\item {} 
the link to the file containing every generation that the list
should be expanded. This should be in the format of a list.

\item {} 
(and onwards) - speciation rates to apply after the simulation is
complete.

\end{enumerate}

\begin{sphinxadmonition}{warning}{Warning:}
This method of running simulations is provided for legacy purposes only, and is no longer recommended. For
increase functionality, use the condensed command-line format, or use switch to using config files.
\end{sphinxadmonition}


\subparagraph{Config Files}
\label{\detokenize{Exhaled/exhaled_library:config-files}}
There are three separate config files which are used when setting up simulations.
\begin{itemize}
\item {} \begin{description}
\item[{{\hyperref[\detokenize{Exhaled/exhaled_library:main-simulation-config-file}]{\sphinxcrossref{main simulation config file}}}}] \leavevmode
Contains the main simulation parameters, including dispersal parameters, speciation rates, sampling information and
file referencing information. It also includes the paths to the other config files, which must be specified if the
main simulation config is used.

\end{description}

\item {} \begin{description}
\item[{{\hyperref[\detokenize{Exhaled/exhaled_library:map-config-file}]{\sphinxcrossref{map config file}}}}] \leavevmode
Contains the map parameters, including paths to the relevant map files, map dimensions, offsets and scaling. This
option cannot be null (map dimensions at least must be specified).

\end{description}

\item {} \begin{description}
\item[{{\hyperref[\detokenize{Exhaled/exhaled_library:time-config-file}]{\sphinxcrossref{time config file}}}}] \leavevmode
Contains the temporal sampling points, in generations. If this is `null', sampling will automatically occur only
at the present (generation time=0)

\end{description}

\end{itemize}

When running the simulation using config files, the path to the {\hyperref[\detokenize{Exhaled/exhaled_library:main-simulation-config-file}]{\sphinxcrossref{main simulation config file}}} should be specified, e.g
\sphinxcode{./NECSim -c /path/to/main/config.txt}.


\subparagraph{Main Config File}
\label{\detokenize{Exhaled/exhaled_library:main-simulation-config-file}}\label{\detokenize{Exhaled/exhaled_library:main-config-file}}
The configuration containing the majority of the simulation set up, outside of map dimensions. An example file is shown
below. This file can be automatically generated by {\hyperref[\detokenize{PyCoalescence:PyCoalescence.coalescence.Coalescence.create_config}]{\sphinxcrossref{\sphinxcode{create\_config()}}}}
in PyCoalescence. An example of this configuration is given below:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{[}\PYG{n}{main}\PYG{p}{]}
\PYG{n}{job\PYGZus{}num} \PYG{o}{=} \PYG{l+m+mi}{6}
\PYG{n}{job\PYGZus{}type} \PYG{o}{=} \PYG{l+m+mi}{6}
\PYG{n}{map\PYGZus{}config} \PYG{o}{=} \PYG{n}{output}\PYG{o}{/}\PYG{n}{mapconf}\PYG{o}{.}\PYG{n}{txt}
\PYG{n}{output\PYGZus{}directory} \PYG{o}{=} \PYG{n}{output}
\PYG{n}{min\PYGZus{}spec\PYGZus{}rate} \PYG{o}{=} \PYG{l+m+mf}{0.5}
\PYG{n}{zfat} \PYG{o}{=} \PYG{l+m+mi}{4}
\PYG{n}{lval} \PYG{o}{=} \PYG{l+m+mi}{4}
\PYG{n}{deme} \PYG{o}{=} \PYG{l+m+mi}{1}
\PYG{n}{sample\PYGZus{}size} \PYG{o}{=} \PYG{l+m+mf}{0.1}
\PYG{n}{max\PYGZus{}time} \PYG{o}{=} \PYG{l+m+mi}{1}
\PYG{k}{lambda} \PYG{o}{=} \PYG{l+m+mi}{1}
\PYG{n}{time\PYGZus{}config} \PYG{o}{=} \PYG{n}{output}\PYG{o}{/}\PYG{n}{tempconf}\PYG{o}{.}\PYG{n}{txt}
\PYG{n}{min\PYGZus{}species} \PYG{o}{=} \PYG{l+m+mi}{1}

\PYG{p}{[}\PYG{n}{spec\PYGZus{}rates}\PYG{p}{]}
\PYG{n}{spec\PYGZus{}rate1}  \PYG{o}{=} \PYG{l+m+mf}{0.6}
\PYG{n}{spec\PYGZus{}rate2}  \PYG{o}{=} \PYG{l+m+mf}{0.8}
\end{sphinxVerbatim}


\subparagraph{Map Config File}
\label{\detokenize{Exhaled/exhaled_library:map-config-file}}\label{\detokenize{Exhaled/exhaled_library:id2}}
The map config contains the information for setting up all maps required by the simulation. This involves maps at all
times and at all scales. An example is given below.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{[}\PYG{n}{sample\PYGZus{}grid}\PYG{p}{]}
\PYG{n}{path} \PYG{o}{=} \PYG{n}{null}
\PYG{n}{x} \PYG{o}{=} \PYG{l+m+mi}{13}
\PYG{n}{y} \PYG{o}{=} \PYG{l+m+mi}{13}
\PYG{n}{mask} \PYG{o}{=} \PYG{n}{null}

\PYG{p}{[}\PYG{n}{fine\PYGZus{}map}\PYG{p}{]}
\PYG{n}{path} \PYG{o}{=} \PYG{n}{sample}\PYG{o}{/}\PYG{n}{SA\PYGZus{}sample\PYGZus{}fine}\PYG{o}{.}\PYG{n}{tif}
\PYG{n}{x} \PYG{o}{=} \PYG{l+m+mi}{13}
\PYG{n}{y} \PYG{o}{=} \PYG{l+m+mi}{13}
\PYG{n}{x\PYGZus{}off} \PYG{o}{=} \PYG{l+m+mi}{0}
\PYG{n}{y\PYGZus{}off} \PYG{o}{=} \PYG{l+m+mi}{0}

\PYG{p}{[}\PYG{n}{coarse\PYGZus{}map}\PYG{p}{]}
\PYG{n}{path} \PYG{o}{=} \PYG{n}{sample}\PYG{o}{/}\PYG{n}{SA\PYGZus{}sample\PYGZus{}coarse}\PYG{o}{.}\PYG{n}{tif}
\PYG{n}{x} \PYG{o}{=} \PYG{l+m+mi}{35}
\PYG{n}{y} \PYG{o}{=} \PYG{l+m+mi}{41}
\PYG{n}{x\PYGZus{}off} \PYG{o}{=} \PYG{l+m+mi}{11}
\PYG{n}{y\PYGZus{}off} \PYG{o}{=} \PYG{l+m+mi}{14}
\PYG{n}{scale} \PYG{o}{=} \PYG{l+m+mf}{1.0}

\PYG{p}{[}\PYG{n}{pristine\PYGZus{}fine0}\PYG{p}{]}
\PYG{n}{path} \PYG{o}{=} \PYG{n}{sample}\PYG{o}{/}\PYG{n}{SA\PYGZus{}sample\PYGZus{}fine\PYGZus{}pristine1}\PYG{o}{.}\PYG{n}{tif}
\PYG{n}{number} \PYG{o}{=} \PYG{l+m+mi}{0}
\PYG{n}{time} \PYG{o}{=} \PYG{l+m+mi}{1}
\PYG{n}{rate} \PYG{o}{=} \PYG{l+m+mf}{0.5}

\PYG{p}{[}\PYG{n}{pristine\PYGZus{}coarse0}\PYG{p}{]}
\PYG{n}{path} \PYG{o}{=} \PYG{n}{sample}\PYG{o}{/}\PYG{n}{SA\PYGZus{}sample\PYGZus{}coarse\PYGZus{}pristine1}\PYG{o}{.}\PYG{n}{tif}
\PYG{n}{number} \PYG{o}{=} \PYG{l+m+mi}{0}
\PYG{n}{time} \PYG{o}{=} \PYG{l+m+mi}{1}
\PYG{n}{rate} \PYG{o}{=} \PYG{l+m+mf}{0.5}

\PYG{p}{[}\PYG{n}{pristine\PYGZus{}fine1}\PYG{p}{]}
\PYG{n}{path} \PYG{o}{=} \PYG{n}{sample}\PYG{o}{/}\PYG{n}{SA\PYGZus{}sample\PYGZus{}fine\PYGZus{}pristine2}\PYG{o}{.}\PYG{n}{tif}
\PYG{n}{number} \PYG{o}{=} \PYG{l+m+mi}{1}
\PYG{n}{time} \PYG{o}{=} \PYG{l+m+mi}{4}
\PYG{n}{rate} \PYG{o}{=} \PYG{l+m+mf}{0.7}

\PYG{p}{[}\PYG{n}{pristine\PYGZus{}coarse1}\PYG{p}{]}
\PYG{n}{path} \PYG{o}{=} \PYG{n}{sample}\PYG{o}{/}\PYG{n}{SA\PYGZus{}sample\PYGZus{}coarse\PYGZus{}pristine2}\PYG{o}{.}\PYG{n}{tif}
\PYG{n}{number} \PYG{o}{=} \PYG{l+m+mi}{1}
\PYG{n}{time} \PYG{o}{=} \PYG{l+m+mi}{4}
\PYG{n}{rate} \PYG{o}{=} \PYG{l+m+mf}{0.7}
\end{sphinxVerbatim}

\begin{sphinxadmonition}{note}{Note:}
The rates and times between the pairs of pristine fine maps and pristine coarse maps must match up. Without matching
values here, there could be undetermined errors, or coarse map values being ignored.
\end{sphinxadmonition}

\begin{sphinxadmonition}{note}{Note:}
Pristine maps assume the same dimensions as their respective present-day equivalents.
\end{sphinxadmonition}


\subparagraph{Time Config File}
\label{\detokenize{Exhaled/exhaled_library:time-config-file}}\label{\detokenize{Exhaled/exhaled_library:id3}}
The temporal sampling config file (referred to as ``time config file'') specifies times, in generations, when a full
sample according to the sample map should be taken again. An example of this file is given below.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{[}\PYG{n}{main}\PYG{p}{]}
\PYG{n}{time0} \PYG{o}{=} \PYG{l+m+mf}{0.0}
\PYG{n}{time1} \PYG{o}{=} \PYG{l+m+mf}{1.0}
\end{sphinxVerbatim}

\begin{sphinxadmonition}{note}{Note:}
For each speciation rate, all biodiversity measures (such as species' abundances and species' richness) will be
calculated for each time supplied separately.
\end{sphinxadmonition}


\subparagraph{Default parameters}
\label{\detokenize{Exhaled/exhaled_library:default-parameters}}
To run the program with the default parameters for testing purposes, run
with the command line arguments -d or -dl (for the larger default run).
Note that this will require access to the following folders relative to
the path of the program for storing the outputs to the default runs:

\sphinxstylestrong{./Default}

\sphinxstylestrong{./Default/SQL\_data/}


\paragraph{Outputs}
\label{\detokenize{Exhaled/exhaled_library:outputs}}
Upon successful completion of a simulation, the two files are created.
\begin{itemize}
\item {} 
A csv file is created called \sphinxstyleemphasis{Data\_\{the\_task\}\_\{the\_seed\}.csv} where the\_seed and the\_task are the values provided
in simulation set-up. This contains basic simulation information for quick reference.

\item {} 
an SQLite database file in the output directory in a folder called \sphinxstyleemphasis{SQL\_data}.
This database contains all important simulation data over several tables, which can be accessed
using a program like \href{http://sqlitebrowser.org/}{DB Browser for SQLite} or Microsoft Access.
Alternatively, most programming languages have an SQLite interface
(\href{https://cran.r-project.org/web/packages/RSQLite/index.html}{RSQlite},
\href{https://docs.python.org/2/library/sqlite3.html}{python sqlite3})

\end{itemize}

The tables in the SQLite database are
- SIMULATION\_PARAMETERS
\begin{quote}

contains the parameters the simulation was performed with for referencing later.
\end{quote}
\begin{itemize}
\item {} 
SPECIES\_LIST
\begin{quote}

contains the locations of every coalescence event. This is used by SpeciationCounter to reconstruct the coalescence
tree for application of speciation rates after simulations are complete.
\end{quote}

\item {} 
SPECIES\_ABUNDANCES
\begin{quote}

contains the species abundance distributions for each speciation rate and time point that has been specified.
\end{quote}

\item {} 
SPECIES\_LOCATIONS {[}optional{]}
\begin{quote}

contains the x, y coordinates of every individual at each time point and for every specified speciation rate,
along with species ID numbers.
\end{quote}

\item {} 
FRAGMENT\_ABUNDANCES {[}optional{]}
\begin{quote}

contains the species abundance distributions for each habitat fragment, either specified by the fragment csv file,
or detected from squares across the map.
\end{quote}

\end{itemize}

Additional information can be found in {\hyperref[\detokenize{Exhaled/exhaled_library:speciationcounter}]{\sphinxcrossref{SpeciationCounter}}} regarding the optional database tables.


\subsubsection{SpeciationCounter}
\label{\detokenize{Exhaled/exhaled_library:speciationcounter}}\label{\detokenize{Exhaled/exhaled_library:introduction-speciationcounter}}
SpeciationCounter provides a method for applying additional speciation rates to outputs from NECSim, without having to
re-run the entire simulation. SpeciationCounter works by reconstructing the coalescence tree, checking at each point if
an additional speciation rate has occured. As such, SpeciationCounter can only apply speciation rates higher than the
initial speciation rate the program was run with.


\paragraph{Applying Speciation Rates}
\label{\detokenize{Exhaled/exhaled_library:applying-speciation-rates}}
Run \sphinxcode{./SpeciationCounter} with the following command-line options:
\begin{enumerate}
\item {} 
path to the SQLite database file (this is the output of a NECSim simulation).

\item {} 
T/F for recording spatial data. If true, the SPECIES\_LOCATIONS table will be created (see {\hyperref[\detokenize{Exhaled/exhaled_library:outputs}]{\sphinxcrossref{Outputs}}}.)

\item {} 
a sample mask to use for the data. Species' identities for the individuals will only be calculated from locations
specified by a 1 in the sample mask (0 otherwise). Use ``null'' to record all locations.

\item {} 
a {\hyperref[\detokenize{Exhaled/exhaled_library:time-config-file}]{\sphinxcrossref{time config file}}} specifying temporal sampling locations.

\item {} 
T/F for calculating fragment species abundances individually. If true, the FRAGMENT\_ABUNDANCES table will be created
containing the species abundances for each fragment calculated as a square of continuous habitat. Alternatively, can
specify a csv file that contains the fragment information in the following format. All x, y coordinates are given on
the sample grid size specified at simulation run-time.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{fragment\PYGZus{}name1}\PYG{p}{,} \PYG{n}{x\PYGZus{}min}\PYG{p}{,} \PYG{n}{y\PYGZus{}min}\PYG{p}{,} \PYG{n}{x\PYGZus{}max}\PYG{p}{,} \PYG{n}{y\PYGZus{}max}\PYG{p}{,} \PYG{n}{number\PYGZus{}of\PYGZus{}individuals}
\PYG{n}{fragment\PYGZus{}name2}\PYG{p}{,} \PYG{n}{x\PYGZus{}min}\PYG{p}{,} \PYG{n}{y\PYGZus{}min}\PYG{p}{,} \PYG{n}{x\PYGZus{}max}\PYG{p}{,} \PYG{n}{y\PYGZus{}max}\PYG{p}{,} \PYG{n}{number\PYGZus{}of\PYGZus{}individuals}
\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}
\end{sphinxVerbatim}

\item {} 
A speciation rate to apply. Can list multiple speciation rates by supplying arguments 7 onwards.

\end{enumerate}


\paragraph{Debugging}
\label{\detokenize{Exhaled/exhaled_library:debugging}}
Most errors will return an error code in the form ERROR\_NAME\_XXX:
Description a list of which can be found in ERROR\_REF.txt.


\paragraph{Brief Class Descriptions}
\label{\detokenize{Exhaled/exhaled_library:brief-class-descriptions}}
A brief description of the important classes is given below. Some
classes also contain customised exceptions for better tracing of error
handling.
\begin{itemize}
\item {} 
The {\hyperref[\detokenize{Exhaled/exhale_class_Tree:_CPPv24Tree}]{\sphinxcrossref{\sphinxcode{Tree}}}} class
\begin{itemize}
\item {} 
The most important class!

\item {} 
Contains the main setup, run and data output routines.

\item {} 
{\hyperref[\detokenize{Exhaled/exhale_class_Tree:_CPPv2N4Tree5setupER6vectorI6stringEb}]{\sphinxcrossref{\sphinxcode{setup()}}}} imports the data files from csv (if necessary) and creates
the in-memory objects for the storing of the coalescence tree and
the spatial grid of active lineages. Setup time mostly depends on
the size of the csv file being imported.

\item {} 
Run continually loops over sucessive coalesence, move or
speciation events until all individuals have speciated or
coalesced. This is where the majority of the simulation time will
be, and is mostly dependent on the number of individuals,
speciation rate and size of the spatial grid.

\item {} 
At the end of the simulation, the sqlCreate() routine will
generate the in-memory SQLite database for storing the coalescent
tree. It can run multiple times if multiple speciation rates are
required. {\hyperref[\detokenize{Exhaled/exhale_class_Tree:_CPPv2N4Tree10outputDataEv}]{\sphinxcrossref{\sphinxcode{outputData()}}}} will then be called to create a small csv
file containing important information, and output the SQLite
database to file if required.

\end{itemize}

\item {} 
The {\hyperref[\detokenize{Exhaled/exhale_class_Treenode:_CPPv28Treenode}]{\sphinxcrossref{\sphinxcode{Treenode}}}} class
\begin{itemize}
\item {} 
Contains a single record of a node on the phylogenetic tree, to be
used in reassembling the tree structure at the end of the
simulation.

\end{itemize}

\item {} 
The {\hyperref[\detokenize{Exhaled/exhale_class_Datapoint:_CPPv29Datapoint}]{\sphinxcrossref{\sphinxcode{Datapoint}}}} class
\begin{itemize}
\item {} 
Contains a single record of the location of a lineage.

\end{itemize}

\item {} 
The {\hyperref[\detokenize{Exhaled/exhale_class_NRrand:_CPPv26NRrand}]{\sphinxcrossref{\sphinxcode{NRrand}}}} class
\begin{itemize}
\item {} 
Contains the random number generator, as written by James
Rosindell (\href{mailto:j.rosindell@imperial.ac.uk}{j.rosindell@imperial.ac.uk}).

\end{itemize}

\item {} 
The {\hyperref[\detokenize{Exhaled/exhale_class_Map:_CPPv23Map}]{\sphinxcrossref{\sphinxcode{Map}}}} class
\begin{itemize}
\item {} 
Contains the routines for importing and calling values from the
map objects.

\item {} 
The {\hyperref[\detokenize{Exhaled/exhale_class_Map:_CPPv2N3Map6getValERKdRKdRKlRKlRKd}]{\sphinxcrossref{\sphinxcode{getVal()}}}} and {\hyperref[\detokenize{Exhaled/exhale_class_Map:_CPPv2N3Map12runDispersalERKdRKdRlRlRlRlRbRKd}]{\sphinxcrossref{\sphinxcode{runDispersal()}}}} functions can be modified
to produce altered dispersal behaviour, or alterations to the
structure of the {\hyperref[\detokenize{Exhaled/exhale_class_Row:_CPPv23Row}]{\sphinxcrossref{\sphinxcode{Row}}}}

\end{itemize}

\item {} 
The {\hyperref[\detokenize{Exhaled/exhale_class_Matrix:_CPPv26Matrix}]{\sphinxcrossref{\sphinxcode{Matrix}}}} and {\hyperref[\detokenize{Exhaled/exhale_class_Row:_CPPv23Row}]{\sphinxcrossref{\sphinxcode{Row}}}} classes
\begin{itemize}
\item {} 
Based on code written by James Rosindell
(\href{mailto:j.rosindell@imperial.ac.uk}{j.rosindell@imperial.ac.uk}).

\item {} 
Handles indexing of the 2D object plus importing values from a csv
file.

\end{itemize}

\item {} 
The {\hyperref[\detokenize{Exhaled/exhale_class_SpeciesList:_CPPv211SpeciesList}]{\sphinxcrossref{\sphinxcode{SpeciesList}}}} class
\begin{itemize}
\item {} 
Contains the list of individuals, for application in a matrix, to
essentially create a 3D array.

\item {} 
Handles the positioning of individuals in space within a grid
cell.

\end{itemize}

\item {} 
The {\hyperref[\detokenize{Exhaled/exhale_class_ConfigOption:_CPPv212ConfigOption}]{\sphinxcrossref{\sphinxcode{ConfigOption}}}} class
\begin{itemize}
\item {} 
Contains basic functions for importing command line arguments from
a config file, providing an alternative way of setting up
simulations.

\end{itemize}

\item {} 
The {\hyperref[\detokenize{Exhaled/exhale_class_Treelist:_CPPv28Treelist}]{\sphinxcrossref{\sphinxcode{Treelist}}}} class
\begin{itemize}
\item {} 
Provides the routines for applying different speciation rates to a
phylogenetic tree, to be used either immediately after simulation
within NECSim, or at a later time using {\hyperref[\detokenize{Exhaled/exhaled_library:speciationcounter}]{\sphinxcrossref{SpeciationCounter}}}

\end{itemize}

\end{itemize}


\paragraph{Known Bugs}
\label{\detokenize{Exhaled/exhaled_library:known-bugs}}\begin{itemize}
\item {} 
Simulation pause and resume functions do not work properly at this
time (should be fixed in a later update).

\item {} 
Simulations run until completion, rather than aiming for a desired
number of species. This is an intentional change. Functions related
to this functionality remain but are deprecated.

\item {} 
In SpeciationCounter, only continuous rectangular fragments are
properly calculated. Other shapes must be calculated by
post-processing.

\item {} 
In SpeciationCounter, 3 fragments instead of 2 will be calculated for
certain adjacent rectangular patches.

\end{itemize}


\paragraph{FAQS (WIP)}
\label{\detokenize{Exhaled/exhaled_library:faqs-wip}}\begin{itemize}
\item {} 
\sphinxstylestrong{Why doesnt the default simulation output anything?}
\begin{itemize}
\item {} 
Check that the program has access to the folders relative to the
program at \sphinxtitleref{Default/}

\end{itemize}

\item {} 
\sphinxstylestrong{Why cant I compile the program?}
\begin{itemize}
\item {} 
This could be due to a number of reasons, most likely that you
havent compiled with access to the lsqlite3 or boost packages.
Installation and compilation differs across different systems; for
most UNIX systems, compiling with the linker arguments -lsqlite3
-lboost\_filesystem and -lboost\_system will solve problems with
the compiler not finding the sqlite or boost header file.

\item {} 
Another option could be the potential lack of access to the
fast-cpp-csv-parser by Ben Strasser, available
\href{https://github.com/ben-strasser/fast-cpp-csv-parser}{here}. If
use\_csv has been defined at the head of the file, try without
use\_csv or download the csv parser and locate the folder within
your working directory at compilation.

\end{itemize}

\item {} 
\sphinxstylestrong{Every time the program runs I get error code XXX.}
\begin{itemize}
\item {} 
Check the ERROR\_REF.txt file for descriptions of the files. Try compiling with the \sphinxtitleref{DEBUG} precursor to gain
more information on the problem. It is most likely a problem with
the set up of the map data (error checking is not yet properly
implemented here).

\end{itemize}

\end{itemize}


\paragraph{Contacts}
\label{\detokenize{Exhaled/exhaled_library:contacts}}
Author: \sphinxstylestrong{Samuel Thompson}

Contact: \href{mailto:samuelthompson14@imperial.ac.uk}{samuelthompson14@imperial.ac.uk} - \href{mailto:thompsonsed@gmail.com}{thompsonsed@gmail.com}

Institution: Imperial College London and National University of
Singapore

Based heavily on code by \sphinxstylestrong{James Rosindell}

Contact: \href{mailto:j.rosindell@imperial.ac.uk}{j.rosindell@imperial.ac.uk}

Institution: Imperial College London


\paragraph{Licence}
\label{\detokenize{Exhaled/exhaled_library:licence}}
This project is released under BSD-3 See file
\sphinxstylestrong{LICENSE.txt} or go to
\href{https://opensource.org/licenses/BSD-3-Clause}{here} for full license
details.

You are free to modify and distribute the code for any non-commercial purpose.


\paragraph{Class Hierarchy}
\label{\detokenize{Exhaled/exhaled_library:class-hierarchy}}\begin{itemize}
\item {} 
{\hyperref[\detokenize{Exhaled/exhale_struct_Config_Exception:struct-config-exception}]{\sphinxcrossref{\DUrole{std,std-ref}{Struct Config\_Exception}}}}

\item {} 
{\hyperref[\detokenize{Exhaled/exhale_struct_Fatal_Exception:struct-fatal-exception}]{\sphinxcrossref{\DUrole{std,std-ref}{Struct Fatal\_Exception}}}}

\item {} 
{\hyperref[\detokenize{Exhaled/exhale_struct_Fragment:struct-fragment}]{\sphinxcrossref{\DUrole{std,std-ref}{Struct Fragment}}}}

\item {} 
{\hyperref[\detokenize{Exhaled/exhale_struct_Main_Exception:struct-main-exception}]{\sphinxcrossref{\DUrole{std,std-ref}{Struct Main\_Exception}}}}

\item {} 
{\hyperref[\detokenize{Exhaled/exhale_struct_Map_Exception:struct-map-exception}]{\sphinxcrossref{\DUrole{std,std-ref}{Struct Map\_Exception}}}}

\item {} 
{\hyperref[\detokenize{Exhaled/exhale_struct_Map_Fatal_Exception:struct-map-fatal-exception}]{\sphinxcrossref{\DUrole{std,std-ref}{Struct Map\_Fatal\_Exception}}}}

\item {} 
{\hyperref[\detokenize{Exhaled/exhale_struct_Mapvars:struct-mapvars}]{\sphinxcrossref{\DUrole{std,std-ref}{Struct Mapvars}}}}

\item {} 
{\hyperref[\detokenize{Exhaled/exhale_struct_SectionOption:struct-sectionoption}]{\sphinxcrossref{\DUrole{std,std-ref}{Struct SectionOption}}}}

\item {} 
{\hyperref[\detokenize{Exhaled/exhale_struct_SpeciesException:struct-speciesexception}]{\sphinxcrossref{\DUrole{std,std-ref}{Struct SpeciesException}}}}

\item {} 
{\hyperref[\detokenize{Exhaled/exhale_class_ConfigOption:class-configoption}]{\sphinxcrossref{\DUrole{std,std-ref}{Class ConfigOption}}}}

\item {} 
{\hyperref[\detokenize{Exhaled/exhale_class_Datamask:class-datamask}]{\sphinxcrossref{\DUrole{std,std-ref}{Class Datamask}}}}

\item {} 
{\hyperref[\detokenize{Exhaled/exhale_class_Datapoint:class-datapoint}]{\sphinxcrossref{\DUrole{std,std-ref}{Class Datapoint}}}}

\item {} 
{\hyperref[\detokenize{Exhaled/exhale_class_Map:class-map}]{\sphinxcrossref{\DUrole{std,std-ref}{Class Map}}}}

\item {} 
{\hyperref[\detokenize{Exhaled/exhale_class_Matrix:class-matrix}]{\sphinxcrossref{\DUrole{std,std-ref}{Class Matrix}}}}

\item {} 
{\hyperref[\detokenize{Exhaled/exhale_class_NRrand:class-nrrand}]{\sphinxcrossref{\DUrole{std,std-ref}{Class NRrand}}}}

\item {} 
{\hyperref[\detokenize{Exhaled/exhale_class_Row:class-row}]{\sphinxcrossref{\DUrole{std,std-ref}{Class Row}}}}

\item {} 
{\hyperref[\detokenize{Exhaled/exhale_class_Samplematrix:class-samplematrix}]{\sphinxcrossref{\DUrole{std,std-ref}{Class Samplematrix}}}}

\item {} 
{\hyperref[\detokenize{Exhaled/exhale_class_simParameters:class-simparameters}]{\sphinxcrossref{\DUrole{std,std-ref}{Class simParameters}}}}

\item {} 
{\hyperref[\detokenize{Exhaled/exhale_class_SpeciesList:class-specieslist}]{\sphinxcrossref{\DUrole{std,std-ref}{Class SpeciesList}}}}

\item {} 
{\hyperref[\detokenize{Exhaled/exhale_class_Tree:class-tree}]{\sphinxcrossref{\DUrole{std,std-ref}{Class Tree}}}}

\item {} 
{\hyperref[\detokenize{Exhaled/exhale_class_Treelist:class-treelist}]{\sphinxcrossref{\DUrole{std,std-ref}{Class Treelist}}}}

\item {} 
{\hyperref[\detokenize{Exhaled/exhale_class_Treenode:class-treenode}]{\sphinxcrossref{\DUrole{std,std-ref}{Class Treenode}}}}

\end{itemize}


\paragraph{File Hierarchy}
\label{\detokenize{Exhaled/exhaled_library:file-hierarchy}}\begin{itemize}
\item {} 
{\hyperref[\detokenize{Exhaled/exhale_file_Config.cpp:file-config-cpp}]{\sphinxcrossref{\DUrole{std,std-ref}{File Config.cpp}}}}

\item {} 
{\hyperref[\detokenize{Exhaled/exhale_file_Config.h:file-config-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File Config.h}}}}

\item {} 
{\hyperref[\detokenize{Exhaled/exhale_file_CustomExceptions.h:file-customexceptions-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File CustomExceptions.h}}}}

\item {} 
{\hyperref[\detokenize{Exhaled/exhale_file_Datapoint.h:file-datapoint-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File Datapoint.h}}}}

\item {} 
{\hyperref[\detokenize{Exhaled/exhale_file_Fattaildeviate.h:file-fattaildeviate-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File Fattaildeviate.h}}}}

\item {} 
{\hyperref[\detokenize{Exhaled/exhale_file_main.cpp:file-main-cpp}]{\sphinxcrossref{\DUrole{std,std-ref}{File main.cpp}}}}

\item {} 
{\hyperref[\detokenize{Exhaled/exhale_file_Map.cpp:file-map-cpp}]{\sphinxcrossref{\DUrole{std,std-ref}{File Map.cpp}}}}

\item {} 
{\hyperref[\detokenize{Exhaled/exhale_file_Map.h:file-map-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File Map.h}}}}

\item {} 
{\hyperref[\detokenize{Exhaled/exhale_file_Matrix.h:file-matrix-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File Matrix.h}}}}

\item {} 
{\hyperref[\detokenize{Exhaled/exhale_file_Setup.cpp:file-setup-cpp}]{\sphinxcrossref{\DUrole{std,std-ref}{File Setup.cpp}}}}

\item {} 
{\hyperref[\detokenize{Exhaled/exhale_file_Setup.h:file-setup-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File Setup.h}}}}

\item {} 
{\hyperref[\detokenize{Exhaled/exhale_file_SpeciationCounter.cpp:file-speciationcounter-cpp}]{\sphinxcrossref{\DUrole{std,std-ref}{File SpeciationCounter.cpp}}}}

\item {} 
{\hyperref[\detokenize{Exhaled/exhale_file_SpeciesList.h:file-specieslist-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File SpeciesList.h}}}}

\item {} 
{\hyperref[\detokenize{Exhaled/exhale_file_Tree.h:file-tree-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File Tree.h}}}}

\item {} 
{\hyperref[\detokenize{Exhaled/exhale_file_Treelist.cpp:file-treelist-cpp}]{\sphinxcrossref{\DUrole{std,std-ref}{File Treelist.cpp}}}}

\item {} 
{\hyperref[\detokenize{Exhaled/exhale_file_Treelist.h:file-treelist-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File Treelist.h}}}}

\item {} 
{\hyperref[\detokenize{Exhaled/exhale_file_Treenode.h:file-treenode-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File Treenode.h}}}}

\end{itemize}


\paragraph{Full API}
\label{\detokenize{Exhaled/exhaled_library:full-api}}

\subsubsection{Namespaces}
\label{\detokenize{Exhaled/exhaled_library:namespaces}}

\paragraph{Namespace std}
\label{\detokenize{Exhaled/exhale_namespace_std:namespace-std}}\label{\detokenize{Exhaled/exhale_namespace_std::doc}}\label{\detokenize{Exhaled/exhale_namespace_std:id1}}

\subsubsection{Classes and Structs}
\label{\detokenize{Exhaled/exhaled_library:classes-and-structs}}

\paragraph{Struct Config\_Exception}
\label{\detokenize{Exhaled/exhale_struct_Config_Exception::doc}}\label{\detokenize{Exhaled/exhale_struct_Config_Exception:struct-config-exception}}\label{\detokenize{Exhaled/exhale_struct_Config_Exception:id1}}\begin{itemize}
\item {} 
Defined in {\hyperref[\detokenize{Exhaled/exhale_file_CustomExceptions.h:file-customexceptions-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File CustomExceptions.h}}}}

\end{itemize}
\index{Config\_Exception (C++ class)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_struct_Config_Exception:_CPPv216Config_Exception}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{Exhaled/exhale_struct_Config_Exception:NECSimstruct_config___exception}}\pysigline{\sphinxstrong{struct }\sphinxcode{}\sphinxbfcode{Config\_Exception}}%
\pysigstopmultiline
A structure for all exceptions thrown within config processes. 

Inherits from runtime\_error
\paragraph{Public Functions}
\index{Config\_Exception::Config\_Exception (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_struct_Config_Exception:_CPPv2N16Config_Exception16Config_ExceptionEv}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{Exhaled/exhale_struct_Config_Exception:NECSimstruct_config___exception_1ad961b68e63410989a188fe53ed451f86}}\pysiglinewithargsret{\sphinxbfcode{Config\_Exception}}{}{}%
\pysigstopmultiline
\end{fulllineitems}

\index{Config\_Exception::Config\_Exception (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_struct_Config_Exception:_CPPv2N16Config_Exception16Config_ExceptionE6string}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{Exhaled/exhale_struct_Config_Exception:NECSimstruct_config___exception_1aaf23f4c3935e1ecf31791007d1eb734b}}\pysiglinewithargsret{\sphinxbfcode{Config\_Exception}}{string \sphinxstyleemphasis{msg}}{}%
\pysigstopmultiline
\end{fulllineitems}


\end{fulllineitems}



\paragraph{Struct Fatal\_Exception}
\label{\detokenize{Exhaled/exhale_struct_Fatal_Exception:struct-fatal-exception}}\label{\detokenize{Exhaled/exhale_struct_Fatal_Exception::doc}}\label{\detokenize{Exhaled/exhale_struct_Fatal_Exception:id1}}\begin{itemize}
\item {} 
Defined in {\hyperref[\detokenize{Exhaled/exhale_file_CustomExceptions.h:file-customexceptions-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File CustomExceptions.h}}}}

\end{itemize}
\index{Fatal\_Exception (C++ class)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_struct_Fatal_Exception:_CPPv215Fatal_Exception}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{Exhaled/exhale_struct_Fatal_Exception:NECSimstruct_fatal___exception}}\pysigline{\sphinxstrong{struct }\sphinxcode{}\sphinxbfcode{Fatal\_Exception}}%
\pysigstopmultiline
This is called any time a fatal exception is called and the program is unwound and ended. 

Inherits from runtime\_error
\paragraph{Public Functions}
\index{Fatal\_Exception::Fatal\_Exception (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_struct_Fatal_Exception:_CPPv2N15Fatal_Exception15Fatal_ExceptionEv}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{Exhaled/exhale_struct_Fatal_Exception:NECSimstruct_fatal___exception_1a2a6ecc421a452f205213440140550a12}}\pysiglinewithargsret{\sphinxbfcode{Fatal\_Exception}}{}{}%
\pysigstopmultiline
\end{fulllineitems}

\index{Fatal\_Exception::Fatal\_Exception (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_struct_Fatal_Exception:_CPPv2N15Fatal_Exception15Fatal_ExceptionE6string}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{Exhaled/exhale_struct_Fatal_Exception:NECSimstruct_fatal___exception_1ab288be87b35a7efa13bd7f1eca94f28a}}\pysiglinewithargsret{\sphinxbfcode{Fatal\_Exception}}{string \sphinxstyleemphasis{msg}}{}%
\pysigstopmultiline
\end{fulllineitems}


\end{fulllineitems}



\paragraph{Struct Fragment}
\label{\detokenize{Exhaled/exhale_struct_Fragment:struct-fragment}}\label{\detokenize{Exhaled/exhale_struct_Fragment::doc}}\label{\detokenize{Exhaled/exhale_struct_Fragment:id1}}\begin{itemize}
\item {} 
Defined in {\hyperref[\detokenize{Exhaled/exhale_file_Treelist.h:file-treelist-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File Treelist.h}}}}

\end{itemize}
\index{Fragment (C++ class)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_struct_Fragment:_CPPv28Fragment}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{Exhaled/exhale_struct_Fragment:NECSimstruct_fragment}}\pysigline{\sphinxstrong{struct }\sphinxcode{}\sphinxbfcode{Fragment}}%
\pysigstopmultiline
Contains the information needed for defining a fragment. Fragments can be detected from the {\hyperref[\detokenize{Exhaled/exhale_class_Samplematrix:NECSimclass_samplematrix}]{\sphinxcrossref{\DUrole{std,std-ref}{Samplematrix}}}} object (which only detects rectangular fragments), or (preferably) is read from an input file. Currently all fragments must be rectangular, although they can be larger than the intended shape if necesssary. 
\paragraph{Public Members}
\index{Fragment::name (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_struct_Fragment:_CPPv2N8Fragment4nameE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{Exhaled/exhale_struct_Fragment:NECSimstruct_fragment_1acf92da0ecedecb7080adf56e35543636}}string \sphinxbfcode{name}}%
\pysigstopmultiline
\end{fulllineitems}

\index{Fragment::x\_east (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_struct_Fragment:_CPPv2N8Fragment6x_eastE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{Exhaled/exhale_struct_Fragment:NECSimstruct_fragment_1a5efcc13a53b913af83daa1a502b02521}}unsigned long \sphinxbfcode{x\_east}}%
\pysigstopmultiline
\end{fulllineitems}

\index{Fragment::x\_west (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_struct_Fragment:_CPPv2N8Fragment6x_westE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{Exhaled/exhale_struct_Fragment:NECSimstruct_fragment_1a5c685e7154e0e44fa1dbf1e34367506e}}unsigned long \sphinxbfcode{x\_west}}%
\pysigstopmultiline
\end{fulllineitems}

\index{Fragment::y\_north (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_struct_Fragment:_CPPv2N8Fragment7y_northE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{Exhaled/exhale_struct_Fragment:NECSimstruct_fragment_1a919835abbc0e01e236753d56dc908b2f}}unsigned long \sphinxbfcode{y\_north}}%
\pysigstopmultiline
\end{fulllineitems}

\index{Fragment::y\_south (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_struct_Fragment:_CPPv2N8Fragment7y_southE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{Exhaled/exhale_struct_Fragment:NECSimstruct_fragment_1ad1366ba2b4260af92fad0d15f782993e}}unsigned long \sphinxbfcode{y\_south}}%
\pysigstopmultiline
\end{fulllineitems}

\index{Fragment::num (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_struct_Fragment:_CPPv2N8Fragment3numE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{Exhaled/exhale_struct_Fragment:NECSimstruct_fragment_1ac966a3ac928cba2706ca9c87f159d1ee}}unsigned long \sphinxbfcode{num}}%
\pysigstopmultiline
\end{fulllineitems}

\index{Fragment::area (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_struct_Fragment:_CPPv2N8Fragment4areaE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{Exhaled/exhale_struct_Fragment:NECSimstruct_fragment_1ad37e6d449d9b0b1273e712e5a4da2887}}double \sphinxbfcode{area}}%
\pysigstopmultiline
\end{fulllineitems}


\end{fulllineitems}



\paragraph{Struct Main\_Exception}
\label{\detokenize{Exhaled/exhale_struct_Main_Exception:struct-main-exception}}\label{\detokenize{Exhaled/exhale_struct_Main_Exception::doc}}\label{\detokenize{Exhaled/exhale_struct_Main_Exception:id1}}\begin{itemize}
\item {} 
Defined in {\hyperref[\detokenize{Exhaled/exhale_file_CustomExceptions.h:file-customexceptions-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File CustomExceptions.h}}}}

\end{itemize}
\index{Main\_Exception (C++ class)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_struct_Main_Exception:_CPPv214Main_Exception}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{Exhaled/exhale_struct_Main_Exception:NECSimstruct_main___exception}}\pysigline{\sphinxstrong{struct }\sphinxcode{}\sphinxbfcode{Main\_Exception}}%
\pysigstopmultiline
These are used for non-fatal exception thrown from within the main simulation where no-more specific location information is possible. 

Inherits from runtime\_error
\paragraph{Public Functions}
\index{Main\_Exception::Main\_Exception (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_struct_Main_Exception:_CPPv2N14Main_Exception14Main_ExceptionEv}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{Exhaled/exhale_struct_Main_Exception:NECSimstruct_main___exception_1a7e8730788366daa2ea2a717c8794a7fa}}\pysiglinewithargsret{\sphinxbfcode{Main\_Exception}}{}{}%
\pysigstopmultiline
\end{fulllineitems}

\index{Main\_Exception::Main\_Exception (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_struct_Main_Exception:_CPPv2N14Main_Exception14Main_ExceptionE6string}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{Exhaled/exhale_struct_Main_Exception:NECSimstruct_main___exception_1a3b56c19b4513c6695cea80d90ca7da8f}}\pysiglinewithargsret{\sphinxbfcode{Main\_Exception}}{string \sphinxstyleemphasis{msg}}{}%
\pysigstopmultiline
\end{fulllineitems}


\end{fulllineitems}



\paragraph{Struct Map\_Exception}
\label{\detokenize{Exhaled/exhale_struct_Map_Exception::doc}}\label{\detokenize{Exhaled/exhale_struct_Map_Exception:struct-map-exception}}\label{\detokenize{Exhaled/exhale_struct_Map_Exception:id1}}\begin{itemize}
\item {} 
Defined in {\hyperref[\detokenize{Exhaled/exhale_file_CustomExceptions.h:file-customexceptions-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File CustomExceptions.h}}}}

\end{itemize}
\index{Map\_Exception (C++ class)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_struct_Map_Exception:_CPPv213Map_Exception}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{Exhaled/exhale_struct_Map_Exception:NECSimstruct_map___exception}}\pysigline{\sphinxstrong{struct }\sphinxcode{}\sphinxbfcode{Map\_Exception}}%
\pysigstopmultiline
The non-fatal exception thrown when a problem is encountered in any {\hyperref[\detokenize{Exhaled/exhale_class_Map:NECSimclass_map}]{\sphinxcrossref{\DUrole{std,std-ref}{Map}}}} object processes. 

Inherits from runtime\_error
\paragraph{Public Functions}
\index{Map\_Exception::Map\_Exception (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_struct_Map_Exception:_CPPv2N13Map_Exception13Map_ExceptionEv}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{Exhaled/exhale_struct_Map_Exception:NECSimstruct_map___exception_1a9fc5c3c330de9366ca078c1c29d09dd0}}\pysiglinewithargsret{\sphinxbfcode{Map\_Exception}}{}{}%
\pysigstopmultiline
\end{fulllineitems}

\index{Map\_Exception::Map\_Exception (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_struct_Map_Exception:_CPPv2N13Map_Exception13Map_ExceptionE6string}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{Exhaled/exhale_struct_Map_Exception:NECSimstruct_map___exception_1afe744dc47a8e404d1c48fc8d6a69cf24}}\pysiglinewithargsret{\sphinxbfcode{Map\_Exception}}{string \sphinxstyleemphasis{msg}}{}%
\pysigstopmultiline
\end{fulllineitems}


\end{fulllineitems}



\paragraph{Struct Map\_Fatal\_Exception}
\label{\detokenize{Exhaled/exhale_struct_Map_Fatal_Exception::doc}}\label{\detokenize{Exhaled/exhale_struct_Map_Fatal_Exception:struct-map-fatal-exception}}\label{\detokenize{Exhaled/exhale_struct_Map_Fatal_Exception:id1}}\begin{itemize}
\item {} 
Defined in {\hyperref[\detokenize{Exhaled/exhale_file_CustomExceptions.h:file-customexceptions-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File CustomExceptions.h}}}}

\end{itemize}
\index{Map\_Fatal\_Exception (C++ class)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_struct_Map_Fatal_Exception:_CPPv219Map_Fatal_Exception}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{Exhaled/exhale_struct_Map_Fatal_Exception:NECSimstruct_map___fatal___exception}}\pysigline{\sphinxstrong{struct }\sphinxcode{}\sphinxbfcode{Map\_Fatal\_Exception}}%
\pysigstopmultiline
The fatal exception thrown when a problem is encountered in any {\hyperref[\detokenize{Exhaled/exhale_class_Map:NECSimclass_map}]{\sphinxcrossref{\DUrole{std,std-ref}{Map}}}} object processes. 

Inherits from runtime\_error
\paragraph{Public Functions}
\index{Map\_Fatal\_Exception::Map\_Fatal\_Exception (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_struct_Map_Fatal_Exception:_CPPv2N19Map_Fatal_Exception19Map_Fatal_ExceptionEv}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{Exhaled/exhale_struct_Map_Fatal_Exception:NECSimstruct_map___fatal___exception_1ac252875d7732e5bb8a3ce350848a025f}}\pysiglinewithargsret{\sphinxbfcode{Map\_Fatal\_Exception}}{}{}%
\pysigstopmultiline
\end{fulllineitems}

\index{Map\_Fatal\_Exception::Map\_Fatal\_Exception (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_struct_Map_Fatal_Exception:_CPPv2N19Map_Fatal_Exception19Map_Fatal_ExceptionE6string}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{Exhaled/exhale_struct_Map_Fatal_Exception:NECSimstruct_map___fatal___exception_1a9ec327b70d3659e84c0b70ed8e74f775}}\pysiglinewithargsret{\sphinxbfcode{Map\_Fatal\_Exception}}{string \sphinxstyleemphasis{msg}}{}%
\pysigstopmultiline
\end{fulllineitems}


\end{fulllineitems}



\paragraph{Struct Mapvars}
\label{\detokenize{Exhaled/exhale_struct_Mapvars:struct-mapvars}}\label{\detokenize{Exhaled/exhale_struct_Mapvars::doc}}\label{\detokenize{Exhaled/exhale_struct_Mapvars:id1}}\begin{itemize}
\item {} 
Defined in {\hyperref[\detokenize{Exhaled/exhale_file_Map.h:file-map-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File Map.h}}}}

\end{itemize}
\index{Mapvars (C++ class)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_struct_Mapvars:_CPPv27Mapvars}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{Exhaled/exhale_struct_Mapvars:NECSimstruct_mapvars}}\pysigline{\sphinxstrong{struct }\sphinxcode{}\sphinxbfcode{Mapvars}}%
\pysigstopmultiline
Stores and imports the variables required by the {\hyperref[\detokenize{Exhaled/exhale_class_Map:NECSimclass_map}]{\sphinxcrossref{\DUrole{std,std-ref}{Map}}}} object. Used to setting the {\hyperref[\detokenize{Exhaled/exhale_class_Map:NECSimclass_map}]{\sphinxcrossref{\DUrole{std,std-ref}{Map}}}} variables in a more elegant way. 
\paragraph{Public Functions}
\index{Mapvars::import (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_struct_Mapvars:_CPPv2N7Mapvars6importERK6vectorI6stringEb}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{Exhaled/exhale_struct_Mapvars:NECSimstruct_mapvars_1a5ba85c9d29f23713878c38d003ee26ad}}\pysiglinewithargsret{void \sphinxbfcode{import}}{\sphinxstrong{const} vector\textless{}string\textgreater{} \&\sphinxstyleemphasis{comargs}, bool \sphinxstyleemphasis{fullmode}}{}%
\pysigstopmultiline
Imports the {\hyperref[\detokenize{Exhaled/exhale_class_Map:NECSimclass_map}]{\sphinxcrossref{\DUrole{std,std-ref}{Map}}}} variables from a vector of command line arguments. 

\begin{description}
\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{comargs}: 

\item {} 
\sphinxcode{fullmode}: whether the full import mode has been specified. 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{Mapvars::setPristine (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_struct_Mapvars:_CPPv2N7Mapvars11setPristineEj}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{Exhaled/exhale_struct_Mapvars:NECSimstruct_mapvars_1a00f3340dba02f7fa07aca4a15232e76b}}\pysiglinewithargsret{void \sphinxbfcode{setPristine}}{unsigned int \sphinxstyleemphasis{n}}{}%
\pysigstopmultiline
Alters the pristine parameters to the configuration matching the input number. If no configuration option exists for this number, bPristine will be set to true. 

\begin{description}
\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{n}: 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{Mapvars::printVars (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_struct_Mapvars:_CPPv2N7Mapvars9printVarsEv}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{Exhaled/exhale_struct_Mapvars:NECSimstruct_mapvars_1a1188dc9a73b84bc6ae8d36a8b9201667}}\pysiglinewithargsret{void \sphinxbfcode{printVars}}{}{}%
\pysigstopmultiline
Prints selected important variables to the terminal. 

\end{fulllineitems}

\paragraph{Public Members}
\index{Mapvars::finemapfile (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_struct_Mapvars:_CPPv2N7Mapvars11finemapfileE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{Exhaled/exhale_struct_Mapvars:NECSimstruct_mapvars_1abf6f400a61fa0da0bd816bfe2c6a49b4}}string \sphinxbfcode{finemapfile}}%
\pysigstopmultiline
\end{fulllineitems}

\index{Mapvars::coarsemapfile (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_struct_Mapvars:_CPPv2N7Mapvars13coarsemapfileE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{Exhaled/exhale_struct_Mapvars:NECSimstruct_mapvars_1a0db1076163dd07022b5e46d74e6361fd}}string \sphinxbfcode{coarsemapfile}}%
\pysigstopmultiline
\end{fulllineitems}

\index{Mapvars::outdirectory (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_struct_Mapvars:_CPPv2N7Mapvars12outdirectoryE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{Exhaled/exhale_struct_Mapvars:NECSimstruct_mapvars_1a1bc61853bd4cb1cb016d84bd08ba234a}}string \sphinxbfcode{outdirectory}}%
\pysigstopmultiline
\end{fulllineitems}

\index{Mapvars::pristinefinemapfile (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_struct_Mapvars:_CPPv2N7Mapvars19pristinefinemapfileE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{Exhaled/exhale_struct_Mapvars:NECSimstruct_mapvars_1a56394adebdcb1a19b190c7980cde8a7f}}string \sphinxbfcode{pristinefinemapfile}}%
\pysigstopmultiline
\end{fulllineitems}

\index{Mapvars::pristinecoarsemapfile (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_struct_Mapvars:_CPPv2N7Mapvars21pristinecoarsemapfileE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{Exhaled/exhale_struct_Mapvars:NECSimstruct_mapvars_1a9fbcfa0dd0fcedbf5f5aac5dad3036ab}}string \sphinxbfcode{pristinecoarsemapfile}}%
\pysigstopmultiline
\end{fulllineitems}

\index{Mapvars::samplemaskfile (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_struct_Mapvars:_CPPv2N7Mapvars14samplemaskfileE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{Exhaled/exhale_struct_Mapvars:NECSimstruct_mapvars_1a962d26e1d7d4355c364546b5107add86}}string \sphinxbfcode{samplemaskfile}}%
\pysigstopmultiline
\end{fulllineitems}

\index{Mapvars::the\_task (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_struct_Mapvars:_CPPv2N7Mapvars8the_taskE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{Exhaled/exhale_struct_Mapvars:NECSimstruct_mapvars_1a3fd25731b5e49646b7ea32a11900ed84}}long \sphinxbfcode{the\_task}}%
\pysigstopmultiline
\end{fulllineitems}

\index{Mapvars::vargridxsize (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_struct_Mapvars:_CPPv2N7Mapvars12vargridxsizeE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{Exhaled/exhale_struct_Mapvars:NECSimstruct_mapvars_1a1cbabec7a4878446d56ab844595fa0e6}}unsigned long \sphinxbfcode{vargridxsize}}%
\pysigstopmultiline
\end{fulllineitems}

\index{Mapvars::vargridysize (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_struct_Mapvars:_CPPv2N7Mapvars12vargridysizeE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{Exhaled/exhale_struct_Mapvars:NECSimstruct_mapvars_1a01c0b7f9b1d56ccd8ace480b0a745ef2}}unsigned long \sphinxbfcode{vargridysize}}%
\pysigstopmultiline
\end{fulllineitems}

\index{Mapvars::varfinemapxsize (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_struct_Mapvars:_CPPv2N7Mapvars15varfinemapxsizeE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{Exhaled/exhale_struct_Mapvars:NECSimstruct_mapvars_1a76417dc0f064158656205dc4fb9b6941}}unsigned long \sphinxbfcode{varfinemapxsize}}%
\pysigstopmultiline
\end{fulllineitems}

\index{Mapvars::varfinemapysize (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_struct_Mapvars:_CPPv2N7Mapvars15varfinemapysizeE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{Exhaled/exhale_struct_Mapvars:NECSimstruct_mapvars_1a7481301f19d85a26e1f941e5690a5a04}}unsigned long \sphinxbfcode{varfinemapysize}}%
\pysigstopmultiline
\end{fulllineitems}

\index{Mapvars::varfinemapxoffset (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_struct_Mapvars:_CPPv2N7Mapvars17varfinemapxoffsetE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{Exhaled/exhale_struct_Mapvars:NECSimstruct_mapvars_1a8d7e6776ef72ac56937445e10a14bc60}}unsigned long \sphinxbfcode{varfinemapxoffset}}%
\pysigstopmultiline
\end{fulllineitems}

\index{Mapvars::varfinemapyoffset (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_struct_Mapvars:_CPPv2N7Mapvars17varfinemapyoffsetE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{Exhaled/exhale_struct_Mapvars:NECSimstruct_mapvars_1ac1d2f829d652df364879e96fabc057b8}}unsigned long \sphinxbfcode{varfinemapyoffset}}%
\pysigstopmultiline
\end{fulllineitems}

\index{Mapvars::varcoarsemapxsize (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_struct_Mapvars:_CPPv2N7Mapvars17varcoarsemapxsizeE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{Exhaled/exhale_struct_Mapvars:NECSimstruct_mapvars_1a294f396135b7b42ce22b172317ba1277}}unsigned long \sphinxbfcode{varcoarsemapxsize}}%
\pysigstopmultiline
\end{fulllineitems}

\index{Mapvars::varcoarsemapysize (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_struct_Mapvars:_CPPv2N7Mapvars17varcoarsemapysizeE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{Exhaled/exhale_struct_Mapvars:NECSimstruct_mapvars_1af2ccb1609ffbcde9cb39fc34c32556ae}}unsigned long \sphinxbfcode{varcoarsemapysize}}%
\pysigstopmultiline
\end{fulllineitems}

\index{Mapvars::varcoarsemapxoffset (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_struct_Mapvars:_CPPv2N7Mapvars19varcoarsemapxoffsetE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{Exhaled/exhale_struct_Mapvars:NECSimstruct_mapvars_1a776af99ceacf2648668b84dbda661a80}}unsigned long \sphinxbfcode{varcoarsemapxoffset}}%
\pysigstopmultiline
\end{fulllineitems}

\index{Mapvars::varcoarsemapyoffset (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_struct_Mapvars:_CPPv2N7Mapvars19varcoarsemapyoffsetE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{Exhaled/exhale_struct_Mapvars:NECSimstruct_mapvars_1a9e0d3f663334b65ba9422dba86e90817}}unsigned long \sphinxbfcode{varcoarsemapyoffset}}%
\pysigstopmultiline
\end{fulllineitems}

\index{Mapvars::varcoarsemapscale (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_struct_Mapvars:_CPPv2N7Mapvars17varcoarsemapscaleE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{Exhaled/exhale_struct_Mapvars:NECSimstruct_mapvars_1a271a5387194b6bb60702402b62c20351}}unsigned long \sphinxbfcode{varcoarsemapscale}}%
\pysigstopmultiline
\end{fulllineitems}

\index{Mapvars::desired\_specnum (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_struct_Mapvars:_CPPv2N7Mapvars15desired_specnumE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{Exhaled/exhale_struct_Mapvars:NECSimstruct_mapvars_1a5dccd684eb1371d108e3fa422b24edff}}unsigned long \sphinxbfcode{desired\_specnum}}%
\pysigstopmultiline
\end{fulllineitems}

\index{Mapvars::lambda (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_struct_Mapvars:_CPPv2N7Mapvars6lambdaE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{Exhaled/exhale_struct_Mapvars:NECSimstruct_mapvars_1a48d59b103cf107fc08f460e827b17382}}double \sphinxbfcode{lambda}}%
\pysigstopmultiline
\end{fulllineitems}

\index{Mapvars::deme (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_struct_Mapvars:_CPPv2N7Mapvars4demeE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{Exhaled/exhale_struct_Mapvars:NECSimstruct_mapvars_1afb9f700a278961aaa1b28bb7b7e5f677}}long \sphinxbfcode{deme}}%
\pysigstopmultiline
\end{fulllineitems}

\index{Mapvars::deme\_sample (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_struct_Mapvars:_CPPv2N7Mapvars11deme_sampleE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{Exhaled/exhale_struct_Mapvars:NECSimstruct_mapvars_1a16bfaf5a36a8850963efaf3e71f0a364}}double \sphinxbfcode{deme\_sample}}%
\pysigstopmultiline
\end{fulllineitems}

\index{Mapvars::spec (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_struct_Mapvars:_CPPv2N7Mapvars4specE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{Exhaled/exhale_struct_Mapvars:NECSimstruct_mapvars_1ae87a5619f438ec7b12a61bc5553c3eb4}}long double \sphinxbfcode{spec}}%
\pysigstopmultiline
\end{fulllineitems}

\index{Mapvars::zfat (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_struct_Mapvars:_CPPv2N7Mapvars4zfatE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{Exhaled/exhale_struct_Mapvars:NECSimstruct_mapvars_1a733dac36e42cf959c73c15a2855a0d68}}double \sphinxbfcode{zfat}}%
\pysigstopmultiline
\end{fulllineitems}

\index{Mapvars::maxtime (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_struct_Mapvars:_CPPv2N7Mapvars7maxtimeE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{Exhaled/exhale_struct_Mapvars:NECSimstruct_mapvars_1ab7098e9dcf030ef104c0b7aef8231ed3}}double \sphinxbfcode{maxtime}}%
\pysigstopmultiline
\end{fulllineitems}

\index{Mapvars::dPristine (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_struct_Mapvars:_CPPv2N7Mapvars9dPristineE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{Exhaled/exhale_struct_Mapvars:NECSimstruct_mapvars_1a9cb350c71f9ff788d6e0fdd76322f097}}double \sphinxbfcode{dPristine}}%
\pysigstopmultiline
\end{fulllineitems}

\index{Mapvars::dForestTransform (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_struct_Mapvars:_CPPv2N7Mapvars16dForestTransformE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{Exhaled/exhale_struct_Mapvars:NECSimstruct_mapvars_1a772c32d441dbf394ea5c2f7f0f4f7561}}double \sphinxbfcode{dForestTransform}}%
\pysigstopmultiline
\end{fulllineitems}

\index{Mapvars::dLvalue (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_struct_Mapvars:_CPPv2N7Mapvars7dLvalueE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{Exhaled/exhale_struct_Mapvars:NECSimstruct_mapvars_1a43ad37178c0cd71aa0e60625c49aac1a}}double \sphinxbfcode{dLvalue}}%
\pysigstopmultiline
\end{fulllineitems}

\index{Mapvars::autocorrel\_file (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_struct_Mapvars:_CPPv2N7Mapvars15autocorrel_fileE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{Exhaled/exhale_struct_Mapvars:NECSimstruct_mapvars_1a9c92b42eba9a2fe76ffdfada37f467eb}}string \sphinxbfcode{autocorrel\_file}}%
\pysigstopmultiline
\end{fulllineitems}

\index{Mapvars::configs (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_struct_Mapvars:_CPPv2N7Mapvars7configsE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{Exhaled/exhale_struct_Mapvars:NECSimstruct_mapvars_1a84f6da12b9983ce05d2b7f90d6804785}}{\hyperref[\detokenize{Exhaled/exhale_class_ConfigOption:_CPPv212ConfigOption}]{\sphinxcrossref{ConfigOption}}} \sphinxbfcode{configs}}%
\pysigstopmultiline
\end{fulllineitems}

\index{Mapvars::bPristine (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_struct_Mapvars:_CPPv2N7Mapvars9bPristineE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{Exhaled/exhale_struct_Mapvars:NECSimstruct_mapvars_1a4437e7b6daf02d8055d96b8c9a6ac6b1}}bool \sphinxbfcode{bPristine}}%
\pysigstopmultiline
\end{fulllineitems}

\paragraph{Friends}
\index{operator\textless{}\textless{} (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_struct_Mapvars:_CPPv2lsR7ostreamRK7Mapvars}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{Exhaled/exhale_struct_Mapvars:NECSimstruct_mapvars_1a5ddb4f189244b9d86ca7e4315b6f8750}}\pysiglinewithargsret{ostream \&\sphinxbfcode{operator\textless{}\textless{}}}{ostream \&\sphinxstyleemphasis{os}, \sphinxstrong{const} {\hyperref[\detokenize{Exhaled/exhale_struct_Mapvars:_CPPv27Mapvars}]{\sphinxcrossref{Mapvars}}} \&\sphinxstyleemphasis{m}}{}%
\pysigstopmultiline
Overloading the \textless{}\textless{} operator for outputting to the output stream. 

\begin{description}
\item[{\sphinxstylestrong{Return}}] \leavevmode
os the output stream. 

\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{os}: the output stream. 

\item {} 
\sphinxcode{m}: the {\hyperref[\detokenize{Exhaled/exhale_struct_Mapvars:NECSimstruct_mapvars}]{\sphinxcrossref{\DUrole{std,std-ref}{Mapvars}}}} object. 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{operator\textgreater{}\textgreater{} (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_struct_Mapvars:_CPPv2rsR7istreamR7Mapvars}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{Exhaled/exhale_struct_Mapvars:NECSimstruct_mapvars_1a4efee8423c4b4d84844e830d55f9e1ed}}\pysiglinewithargsret{istream \&\sphinxbfcode{operator\textgreater{}\textgreater{}}}{istream \&\sphinxstyleemphasis{is}, {\hyperref[\detokenize{Exhaled/exhale_struct_Mapvars:_CPPv27Mapvars}]{\sphinxcrossref{Mapvars}}} \&\sphinxstyleemphasis{m}}{}%
\pysigstopmultiline
Overloading the \textgreater{}\textgreater{} operator for inputting from an input stream. 

\begin{description}
\item[{\sphinxstylestrong{Return}}] \leavevmode
is the input stream 

\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{is}: the input stream 

\item {} 
\sphinxcode{m}: the mapvars object 

\end{itemize}

\end{description}


\end{fulllineitems}


\end{fulllineitems}



\paragraph{Struct SectionOption}
\label{\detokenize{Exhaled/exhale_struct_SectionOption::doc}}\label{\detokenize{Exhaled/exhale_struct_SectionOption:struct-sectionoption}}\label{\detokenize{Exhaled/exhale_struct_SectionOption:id1}}\begin{itemize}
\item {} 
Defined in {\hyperref[\detokenize{Exhaled/exhale_file_Config.h:file-config-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File Config.h}}}}

\end{itemize}
\index{SectionOption (C++ class)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_struct_SectionOption:_CPPv213SectionOption}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{Exhaled/exhale_struct_SectionOption:NECSimstruct_section_option}}\pysigline{\sphinxstrong{struct }\sphinxcode{}\sphinxbfcode{SectionOption}}%
\pysigstopmultiline
A simple container for importing options from a config file. 
\paragraph{Public Functions}
\index{SectionOption::getOption (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_struct_SectionOption:_CPPv2N13SectionOption9getOptionE6string}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{Exhaled/exhale_struct_SectionOption:NECSimstruct_section_option_1a78d55aa842ba2056764236246492734f}}\pysiglinewithargsret{string \sphinxbfcode{getOption}}{string \sphinxstyleemphasis{refval}}{}%
\pysigstopmultiline
Returns the value for the provided reference from within the key. 

\begin{description}
\item[{\sphinxstylestrong{Return}}] \leavevmode
the requested value as a string. Returns string ``null'' if no reference is found. 

\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{refval}: the reference to obtain the value of 

\end{itemize}

\end{description}


\end{fulllineitems}

\paragraph{Public Members}
\index{SectionOption::section (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_struct_SectionOption:_CPPv2N13SectionOption7sectionE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{Exhaled/exhale_struct_SectionOption:NECSimstruct_section_option_1af6dd28af164466810fe9f36091b9d6d1}}string \sphinxbfcode{section}}%
\pysigstopmultiline
\end{fulllineitems}

\index{SectionOption::val (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_struct_SectionOption:_CPPv2N13SectionOption3valE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{Exhaled/exhale_struct_SectionOption:NECSimstruct_section_option_1a789da4aa7aeef3887bcfc94f7cf2c254}}vector\textless{}string\textgreater{} \sphinxbfcode{val}}%
\pysigstopmultiline
\end{fulllineitems}

\index{SectionOption::refs (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_struct_SectionOption:_CPPv2N13SectionOption4refsE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{Exhaled/exhale_struct_SectionOption:NECSimstruct_section_option_1a916b36005e0e1817a9dcf45bf02952e4}}vector\textless{}string\textgreater{} \sphinxbfcode{refs}}%
\pysigstopmultiline
\end{fulllineitems}

\paragraph{Friends}
\index{operator\textless{}\textless{} (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_struct_SectionOption:_CPPv2lsR7ostreamRK13SectionOption}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{Exhaled/exhale_struct_SectionOption:NECSimstruct_section_option_1a8e9eafe82f001a7bf599bebb1f0bdb76}}\pysiglinewithargsret{ostream \&\sphinxbfcode{operator\textless{}\textless{}}}{ostream \&\sphinxstyleemphasis{os}, \sphinxstrong{const} {\hyperref[\detokenize{Exhaled/exhale_struct_SectionOption:_CPPv213SectionOption}]{\sphinxcrossref{SectionOption}}} \&\sphinxstyleemphasis{k}}{}%
\pysigstopmultiline
Overloading the \textless{}\textless{} operator for outputting to the output stream. 

\begin{description}
\item[{\sphinxstylestrong{Return}}] \leavevmode
os the output stream. 

\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{os}: the output stream. 

\item {} 
\sphinxcode{k}: the KeyOption object. 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{operator\textgreater{}\textgreater{} (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_struct_SectionOption:_CPPv2rsR7istreamR13SectionOption}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{Exhaled/exhale_struct_SectionOption:NECSimstruct_section_option_1a6e317b3e4692b867e48205afcceff1a1}}\pysiglinewithargsret{istream \&\sphinxbfcode{operator\textgreater{}\textgreater{}}}{istream \&\sphinxstyleemphasis{is}, {\hyperref[\detokenize{Exhaled/exhale_struct_SectionOption:_CPPv213SectionOption}]{\sphinxcrossref{SectionOption}}} \&\sphinxstyleemphasis{k}}{}%
\pysigstopmultiline
Overloading the \textgreater{}\textgreater{} operator for inputting from an input stream. 

\begin{description}
\item[{\sphinxstylestrong{Return}}] \leavevmode
is the input stream 

\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{is}: the input stream 

\item {} 
\sphinxcode{k}: the KeyOption object 

\end{itemize}

\end{description}


\end{fulllineitems}


\end{fulllineitems}



\paragraph{Struct SpeciesException}
\label{\detokenize{Exhaled/exhale_struct_SpeciesException::doc}}\label{\detokenize{Exhaled/exhale_struct_SpeciesException:struct-speciesexception}}\label{\detokenize{Exhaled/exhale_struct_SpeciesException:id1}}\begin{itemize}
\item {} 
Defined in {\hyperref[\detokenize{Exhaled/exhale_file_CustomExceptions.h:file-customexceptions-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File CustomExceptions.h}}}}

\end{itemize}
\index{SpeciesException (C++ class)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_struct_SpeciesException:_CPPv216SpeciesException}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{Exhaled/exhale_struct_SpeciesException:NECSimstruct_species_exception}}\pysigline{\sphinxstrong{struct }\sphinxcode{}\sphinxbfcode{SpeciesException}}%
\pysigstopmultiline
An exception thrown whenever a non-fatal Species exception is thrown. 

Inherits from runtime\_error
\paragraph{Public Functions}
\index{SpeciesException::SpeciesException (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_struct_SpeciesException:_CPPv2N16SpeciesException16SpeciesExceptionEv}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{Exhaled/exhale_struct_SpeciesException:NECSimstruct_species_exception_1aad9febae65922d3a68a3d70ddc8b6a16}}\pysiglinewithargsret{\sphinxbfcode{SpeciesException}}{}{}%
\pysigstopmultiline
Throws a runtime\_error with a custom message indicating source. 

\end{fulllineitems}

\index{SpeciesException::SpeciesException (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_struct_SpeciesException:_CPPv2N16SpeciesException16SpeciesExceptionE6string}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{Exhaled/exhale_struct_SpeciesException:NECSimstruct_species_exception_1aee4c223dc1b702be3b937556f39b26a5}}\pysiglinewithargsret{\sphinxbfcode{SpeciesException}}{string \sphinxstyleemphasis{msg}}{}%
\pysigstopmultiline
Overloaded runtime\_error call which provides error message parsing. 

\begin{description}
\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{msg}: the message to be passed to the runtime\_error 

\end{itemize}

\end{description}


\end{fulllineitems}


\end{fulllineitems}



\paragraph{Class ConfigOption}
\label{\detokenize{Exhaled/exhale_class_ConfigOption::doc}}\label{\detokenize{Exhaled/exhale_class_ConfigOption:class-configoption}}\label{\detokenize{Exhaled/exhale_class_ConfigOption:id1}}\begin{itemize}
\item {} 
Defined in {\hyperref[\detokenize{Exhaled/exhale_file_Config.h:file-config-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File Config.h}}}}

\end{itemize}
\index{ConfigOption (C++ class)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_class_ConfigOption:_CPPv212ConfigOption}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{Exhaled/exhale_class_ConfigOption:NECSimclass_config_option}}\pysigline{\sphinxstrong{class }\sphinxcode{}\sphinxbfcode{ConfigOption}}%
\pysigstopmultiline
Config option class to store and import options from a file. 
\paragraph{Public Functions}
\index{ConfigOption::ConfigOption (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_class_ConfigOption:_CPPv2N12ConfigOption12ConfigOptionEv}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{Exhaled/exhale_class_ConfigOption:NECSimclass_config_option_1ac0639cf9fc6660b1436ebc9e7af52525}}\pysiglinewithargsret{\sphinxbfcode{ConfigOption}}{}{}%
\pysigstopmultiline
default construtor for {\hyperref[\detokenize{Exhaled/exhale_class_ConfigOption:NECSimclass_config_option}]{\sphinxcrossref{\DUrole{std,std-ref}{ConfigOption}}}} 

\end{fulllineitems}

\index{ConfigOption::getFile (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_class_ConfigOption:_CPPv2N12ConfigOption7getFileEv}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{Exhaled/exhale_class_ConfigOption:NECSimclass_config_option_1a3f8a4c5ed86342e5750e25b4e2effc1d}}\pysiglinewithargsret{string \sphinxbfcode{getFile}}{}{}%
\pysigstopmultiline
Standard getter for the file name. 

\begin{description}
\item[{\sphinxstylestrong{Return}}] \leavevmode
string the file name. 

\end{description}


\end{fulllineitems}

\index{ConfigOption::getMain (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_class_ConfigOption:_CPPv2N12ConfigOption7getMainEv}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{Exhaled/exhale_class_ConfigOption:NECSimclass_config_option_1a9efbb1ec989baccfa4476edf347381f3}}\pysiglinewithargsret{bool \sphinxbfcode{getMain}}{}{}%
\pysigstopmultiline
Gets if the config is a main command-line import. 

\begin{description}
\item[{\sphinxstylestrong{Return}}] \leavevmode
bool bMain 

\end{description}


\end{fulllineitems}

\index{ConfigOption::getFull (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_class_ConfigOption:_CPPv2N12ConfigOption7getFullEv}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{Exhaled/exhale_class_ConfigOption:NECSimclass_config_option_1a39e97c0cd7dc9451e4a518dabf38e132}}\pysiglinewithargsret{bool \sphinxbfcode{getFull}}{}{}%
\pysigstopmultiline
Gets if the config requires each KeyOption structure to be returned after each read. 

\begin{description}
\item[{\sphinxstylestrong{Return}}] \leavevmode
bool bFullParse 

\end{description}


\end{fulllineitems}

\index{ConfigOption::setConfig (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_class_ConfigOption:_CPPv2N12ConfigOption9setConfigE6stringbb}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{Exhaled/exhale_class_ConfigOption:NECSimclass_config_option_1a98226d8cb889e3c5d99cf2a8f49e5dd1}}\pysiglinewithargsret{void \sphinxbfcode{setConfig}}{string \sphinxstyleemphasis{file}, bool \sphinxstyleemphasis{main}, bool \sphinxstyleemphasis{full\_parse} = false}{}%
\pysigstopmultiline
Sets the config file the specified string. A boolean is also provided, set equal to true if this is the main command line import. This causes the deletion of the first few command line options after import. 

\begin{description}
\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{file}: the target config file (in .txt format). 

\item {} 
\sphinxcode{main}: boolean of if this is the main command line import. 

\item {} 
\sphinxcode{full\_parse}: sets bFullParse to provided value 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{ConfigOption::parseConfig (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_class_ConfigOption:_CPPv2N12ConfigOption11parseConfigEv}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{Exhaled/exhale_class_ConfigOption:NECSimclass_config_option_1a45cdefa1516c378e5a90803d594ccd34}}\pysiglinewithargsret{void \sphinxbfcode{parseConfig}}{}{}%
\pysigstopmultiline
Reads a config file of a specific configuration. Each line must be a set of values related to the object determined by ref='object'. Each key must have the form key=value, which will be read as a string into a KeyOption structure. 

\end{fulllineitems}

\index{ConfigOption::testPrint (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_class_ConfigOption:_CPPv2N12ConfigOption9testPrintEv}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{Exhaled/exhale_class_ConfigOption:NECSimclass_config_option_1a4f37e62b7f4ef9368f3eeea7e6385c49}}\pysiglinewithargsret{void \sphinxbfcode{testPrint}}{}{}%
\pysigstopmultiline
\end{fulllineitems}

\index{ConfigOption::getSectionOptions (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_class_ConfigOption:_CPPv2N12ConfigOption17getSectionOptionsEv}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{Exhaled/exhale_class_ConfigOption:NECSimclass_config_option_1ab106a54b3555a0192a1651116578a80d}}\pysiglinewithargsret{vector\textless{}{\hyperref[\detokenize{Exhaled/exhale_struct_SectionOption:_CPPv213SectionOption}]{\sphinxcrossref{SectionOption}}}\textgreater{} \sphinxbfcode{getSectionOptions}}{}{}%
\pysigstopmultiline
Returns the vector of key options imported from the file. 

\begin{description}
\item[{\sphinxstylestrong{Return}}] \leavevmode
vector of key options 

\end{description}


\end{fulllineitems}

\index{ConfigOption::operator{[}{]} (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_class_ConfigOption:_CPPv2N12ConfigOptionixEi}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{Exhaled/exhale_class_ConfigOption:NECSimclass_config_option_1a66d2199cf3bd4fa015ef38e34fe02bd1}}\pysiglinewithargsret{{\hyperref[\detokenize{Exhaled/exhale_struct_SectionOption:_CPPv213SectionOption}]{\sphinxcrossref{SectionOption}}} \sphinxbfcode{operator{[}{]}}}{int \sphinxstyleemphasis{index}}{}%
\pysigstopmultiline
\end{fulllineitems}

\index{ConfigOption::getSectionOptionsSize (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_class_ConfigOption:_CPPv2N12ConfigOption21getSectionOptionsSizeEv}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{Exhaled/exhale_class_ConfigOption:NECSimclass_config_option_1acb7b9141efc8d0e50e21ff1adce8e9cb}}\pysiglinewithargsret{unsigned int \sphinxbfcode{getSectionOptionsSize}}{}{}%
\pysigstopmultiline
Gets the size of the key options vector. 

\begin{description}
\item[{\sphinxstylestrong{Return}}] \leavevmode
the size of the configuration vector. 

\end{description}


\end{fulllineitems}

\index{ConfigOption::getSections (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_class_ConfigOption:_CPPv2N12ConfigOption11getSectionsEv}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{Exhaled/exhale_class_ConfigOption:NECSimclass_config_option_1ab32e6555e331e499b8071722885e9bc6}}\pysiglinewithargsret{vector\textless{}string\textgreater{} \sphinxbfcode{getSections}}{}{}%
\pysigstopmultiline
Gets the sections contained in the SectionOptions object. 

\begin{description}
\item[{\sphinxstylestrong{Return}}] \leavevmode
A vector of the section names. 

\end{description}


\end{fulllineitems}

\index{ConfigOption::hasSection (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_class_ConfigOption:_CPPv2N12ConfigOption10hasSectionE6string}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{Exhaled/exhale_class_ConfigOption:NECSimclass_config_option_1a283504b26f0a4e79c1ea28045ac765ba}}\pysiglinewithargsret{bool \sphinxbfcode{hasSection}}{string \sphinxstyleemphasis{sec}}{}%
\pysigstopmultiline
Checks whether the config option has the specified section. 

\begin{description}
\item[{\sphinxstylestrong{Return}}] \leavevmode
true if the section has been found 

\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{sec}: the section name to check for 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{ConfigOption::getSectionValues (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_class_ConfigOption:_CPPv2N12ConfigOption16getSectionValuesE6string}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{Exhaled/exhale_class_ConfigOption:NECSimclass_config_option_1a7558ac5aaee81415034d28aea7485f0b}}\pysiglinewithargsret{vector\textless{}string\textgreater{} \sphinxbfcode{getSectionValues}}{string \sphinxstyleemphasis{sec}}{}%
\pysigstopmultiline
Gets all values within a section. 

Throws a {\hyperref[\detokenize{Exhaled/exhale_struct_Config_Exception:NECSimstruct_config___exception}]{\sphinxcrossref{\DUrole{std,std-ref}{Config\_Exception}}}} if the section is not found. \begin{description}
\item[{\sphinxstylestrong{Return}}] \leavevmode
a vector of the section's values. 

\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{sec}: the section to find values for 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{ConfigOption::getSectionOptions (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_class_ConfigOption:_CPPv2N12ConfigOption17getSectionOptionsE6string6string}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{Exhaled/exhale_class_ConfigOption:NECSimclass_config_option_1a36917196846e64db6634730fa9b2b3f3}}\pysiglinewithargsret{string \sphinxbfcode{getSectionOptions}}{string \sphinxstyleemphasis{section}, string \sphinxstyleemphasis{ref}}{}%
\pysigstopmultiline
Returns a specific value for a particular key options and reference. 

\begin{description}
\item[{\sphinxstylestrong{Return}}] \leavevmode
the string at the correct place in KeyOptions.val 

\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{key}: the key to match (this corresponds to the line the value comes from 

\item {} 
\sphinxcode{ref}: the reference to match 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{ConfigOption::importConfig (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_class_ConfigOption:_CPPv2N12ConfigOption12importConfigER6vectorI6stringE}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{Exhaled/exhale_class_ConfigOption:NECSimclass_config_option_1afbd1ed9d006c8ff48d90e63a57f55e2a}}\pysiglinewithargsret{int \sphinxbfcode{importConfig}}{vector\textless{}string\textgreater{} \&\sphinxstyleemphasis{comargs}}{}%
\pysigstopmultiline
Imports the parameters from the config file and returns an integer of the number of arguments. 

\begin{description}
\item[{\sphinxstylestrong{Return}}] \leavevmode
a count of the number of arguments (should also be the size of comargs). 

\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{comargs}: a vector of command line arguments to import to from file. 

\end{itemize}

\end{description}


\end{fulllineitems}

\paragraph{Friends}
\index{operator\textless{}\textless{} (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_class_ConfigOption:_CPPv2lsR7ostreamRK12ConfigOption}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{Exhaled/exhale_class_ConfigOption:NECSimclass_config_option_1a9e0cbadb5ac652eb62eb6e046dad5126}}\pysiglinewithargsret{ostream \&\sphinxbfcode{operator\textless{}\textless{}}}{ostream \&\sphinxstyleemphasis{os}, \sphinxstrong{const} {\hyperref[\detokenize{Exhaled/exhale_class_ConfigOption:_CPPv212ConfigOption}]{\sphinxcrossref{ConfigOption}}} \&\sphinxstyleemphasis{c}}{}%
\pysigstopmultiline
Overloading the \textless{}\textless{} operator for outputting to the output stream. 

\begin{description}
\item[{\sphinxstylestrong{Return}}] \leavevmode
os the output stream. 

\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{os}: the output stream. 

\item {} 
\sphinxcode{c}: the {\hyperref[\detokenize{Exhaled/exhale_class_ConfigOption:NECSimclass_config_option}]{\sphinxcrossref{\DUrole{std,std-ref}{ConfigOption}}}} object. 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{operator\textgreater{}\textgreater{} (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_class_ConfigOption:_CPPv2rsR7istreamR12ConfigOption}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{Exhaled/exhale_class_ConfigOption:NECSimclass_config_option_1ad418094c35f378a7b92ca5922e45a206}}\pysiglinewithargsret{istream \&\sphinxbfcode{operator\textgreater{}\textgreater{}}}{istream \&\sphinxstyleemphasis{is}, {\hyperref[\detokenize{Exhaled/exhale_class_ConfigOption:_CPPv212ConfigOption}]{\sphinxcrossref{ConfigOption}}} \&\sphinxstyleemphasis{c}}{}%
\pysigstopmultiline
Overloading the \textgreater{}\textgreater{} operator for inputting from an input stream. Note that the config file must still exist for re-inport and parsing. 

\begin{description}
\item[{\sphinxstylestrong{Return}}] \leavevmode
is the input stream 

\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{is}: the input stream 

\item {} 
\sphinxcode{c}: the {\hyperref[\detokenize{Exhaled/exhale_class_ConfigOption:NECSimclass_config_option}]{\sphinxcrossref{\DUrole{std,std-ref}{ConfigOption}}}} object 

\end{itemize}

\end{description}


\end{fulllineitems}


\end{fulllineitems}



\paragraph{Class Datamask}
\label{\detokenize{Exhaled/exhale_class_Datamask:id1}}\label{\detokenize{Exhaled/exhale_class_Datamask::doc}}\label{\detokenize{Exhaled/exhale_class_Datamask:class-datamask}}\begin{itemize}
\item {} 
Defined in {\hyperref[\detokenize{Exhaled/exhale_file_Map.h:file-map-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File Map.h}}}}

\end{itemize}
\index{Datamask (C++ class)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_class_Datamask:_CPPv28Datamask}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{Exhaled/exhale_class_Datamask:NECSimclass_datamask}}\pysigline{\sphinxstrong{class }\sphinxcode{}\sphinxbfcode{Datamask}}%
\pysigstopmultiline
Contains the {\hyperref[\detokenize{Exhaled/exhale_class_Datamask:NECSimclass_datamask}]{\sphinxcrossref{\DUrole{std,std-ref}{Datamask}}}} object, a {\hyperref[\detokenize{Exhaled/exhale_class_Matrix:NECSimclass_matrix}]{\sphinxcrossref{\DUrole{std,std-ref}{Matrix}}}} of booleans describing the spatial sampling pattern. 
\paragraph{Public Functions}
\index{Datamask::Datamask (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_class_Datamask:_CPPv2N8Datamask8DatamaskEv}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{Exhaled/exhale_class_Datamask:NECSimclass_datamask_1a15b4eff700fb628df58218873dd20923}}\pysiglinewithargsret{\sphinxbfcode{Datamask}}{}{}%
\pysigstopmultiline
The {\hyperref[\detokenize{Exhaled/exhale_class_Datamask:NECSimclass_datamask}]{\sphinxcrossref{\DUrole{std,std-ref}{Datamask}}}} constructor. 

\end{fulllineitems}

\index{Datamask::importDatamask (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_class_Datamask:_CPPv2N8Datamask14importDatamaskER7Mapvars}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{Exhaled/exhale_class_Datamask:NECSimclass_datamask_1a2e2534c526fc40be884bc36f4e98bfb3}}\pysiglinewithargsret{void \sphinxbfcode{importDatamask}}{{\hyperref[\detokenize{Exhaled/exhale_struct_Mapvars:_CPPv27Mapvars}]{\sphinxcrossref{Mapvars}}} \&\sphinxstyleemphasis{mapvarin}}{}%
\pysigstopmultiline
Imports the {\hyperref[\detokenize{Exhaled/exhale_class_Datamask:NECSimclass_datamask}]{\sphinxcrossref{\DUrole{std,std-ref}{Datamask}}}} from the supplied csv file. Requires the mapvar object for command line parsing. 

\begin{description}
\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{mapvarin}: the {\hyperref[\detokenize{Exhaled/exhale_struct_Mapvars:NECSimstruct_mapvars}]{\sphinxcrossref{\DUrole{std,std-ref}{Mapvars}}}} object to parse. 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{Datamask::getVal (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_class_Datamask:_CPPv2N8Datamask6getValEll}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{Exhaled/exhale_class_Datamask:NECSimclass_datamask_1a6ec4cdb241cba0f9f31b7e131f09e399}}\pysiglinewithargsret{bool \sphinxbfcode{getVal}}{long \sphinxstyleemphasis{x}, long \sphinxstyleemphasis{y}}{}%
\pysigstopmultiline
Calculates the matrix value at the provided x, y location. If everywhere is sampled, simply returns true, as no sample\_mask will be stored in memory. This is to save RAM where possible. 

\begin{description}
\item[{\sphinxstylestrong{Return}}] \leavevmode
the sample\_mask value at x,y (or true if the file was ``null''). 

\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{x}: the x position on the grid. 

\item {} 
\sphinxcode{y}: the y position on the grid. 

\end{itemize}

\end{description}


\end{fulllineitems}

\paragraph{Public Members}
\index{Datamask::sample\_mask (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_class_Datamask:_CPPv2N8Datamask11sample_maskE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{Exhaled/exhale_class_Datamask:NECSimclass_datamask_1ac037e2e0a54970d0ddee0226f695d757}}{\hyperref[\detokenize{Exhaled/exhale_class_Matrix:_CPPv26Matrix}]{\sphinxcrossref{Matrix}}}\textless{}bool\textgreater{} \sphinxbfcode{sample\_mask}}%
\pysigstopmultiline
A binary grid telling whether or not the cell should be sampled. 

\end{fulllineitems}


\end{fulllineitems}



\paragraph{Class Datapoint}
\label{\detokenize{Exhaled/exhale_class_Datapoint:class-datapoint}}\label{\detokenize{Exhaled/exhale_class_Datapoint::doc}}\label{\detokenize{Exhaled/exhale_class_Datapoint:id1}}\begin{itemize}
\item {} 
Defined in {\hyperref[\detokenize{Exhaled/exhale_file_Datapoint.h:file-datapoint-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File Datapoint.h}}}}

\end{itemize}
\index{Datapoint (C++ class)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_class_Datapoint:_CPPv29Datapoint}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{Exhaled/exhale_class_Datapoint:NECSimclass_datapoint}}\pysigline{\sphinxstrong{class }\sphinxcode{}\sphinxbfcode{Datapoint}}%
\pysigstopmultiline
A data object used in coalescence simulations for calculating the output. Data from this object is outputted to an SQLite database after simulations are complete. 

\begin{description}
\item[{\sphinxstylestrong{Author}}] \leavevmode
Samuel Thompson 

\item[{\sphinxstylestrong{Date}}] \leavevmode
30/08/2016 

\end{description}

\paragraph{Public Functions}
\index{Datapoint::Datapoint (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_class_Datapoint:_CPPv2N9Datapoint9DatapointEv}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{Exhaled/exhale_class_Datapoint:NECSimclass_datapoint_1ad86563f411c605764c69f64767ed9fef}}\pysiglinewithargsret{\sphinxbfcode{Datapoint}}{}{}%
\pysigstopmultiline
Standard constructor. 

\end{fulllineitems}

\index{Datapoint::\textasciitilde{}Datapoint (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_class_Datapoint:_CPPv2N9DatapointD0Ev}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{Exhaled/exhale_class_Datapoint:NECSimclass_datapoint_1a88c3068213a8e9ba32d4636ba9e5b36e}}\pysiglinewithargsret{\sphinxbfcode{\textasciitilde{}Datapoint}}{}{}%
\pysigstopmultiline
Standard destructor. 

\end{fulllineitems}

\index{Datapoint::setup (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_class_Datapoint:_CPPv2N9Datapoint5setupEmmllmtd}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{Exhaled/exhale_class_Datapoint:NECSimclass_datapoint_1af24f470ad8295fd9ecb7167dc179e621}}\pysiglinewithargsret{void \sphinxbfcode{setup}}{unsigned long \sphinxstyleemphasis{x}, unsigned long \sphinxstyleemphasis{y}, long \sphinxstyleemphasis{xwrapin}, long \sphinxstyleemphasis{ywrapin}, unsigned long \sphinxstyleemphasis{matrix\_position}, unsigned short \sphinxstyleemphasis{listposin}, double \sphinxstyleemphasis{dMinmaxin}}{}%
\pysigstopmultiline
Setup of lineage data with any information that's wanted. Note that nwrap is set to 0 in this routine. 

\begin{description}
\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{x}: the x position on the grid 

\item {} 
\sphinxcode{y}: the y position on the grid 

\item {} 
\sphinxcode{xwrapin}: the number of wraps of the location on the grid in the x direction. 

\item {} 
\sphinxcode{ywrapin}: the number of wraps of the location on the grid in the y direction. 

\item {} 
\sphinxcode{matrix\_position}: the position in the {\hyperref[\detokenize{Exhaled/exhale_class_Treenode:NECSimclass_treenode}]{\sphinxcrossref{\DUrole{std,std-ref}{Treenode}}}} reference object. 

\item {} 
\sphinxcode{listposin}: the position within the {\hyperref[\detokenize{Exhaled/exhale_class_SpeciesList:NECSimclass_species_list}]{\sphinxcrossref{\DUrole{std,std-ref}{SpeciesList}}}} object at the relevant x,y position. 

\item {} 
\sphinxcode{dMinmaxin}: the input maximum minimum speciation rate required for speciation to have occured on this branch. 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{Datapoint::setup (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_class_Datapoint:_CPPv2N9Datapoint5setupE9Datapoint}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{Exhaled/exhale_class_Datapoint:NECSimclass_datapoint_1a83643d56367b2bbb7c258fb914425000}}\pysiglinewithargsret{void \sphinxbfcode{setup}}{{\hyperref[\detokenize{Exhaled/exhale_class_Datapoint:_CPPv29Datapoint}]{\sphinxcrossref{Datapoint}}} \sphinxstyleemphasis{datin}}{}%
\pysigstopmultiline
Copy constructor from another {\hyperref[\detokenize{Exhaled/exhale_class_Datapoint:NECSimclass_datapoint}]{\sphinxcrossref{\DUrole{std,std-ref}{Datapoint}}}} object. 

\begin{description}
\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{datin}: a {\hyperref[\detokenize{Exhaled/exhale_class_Datapoint:NECSimclass_datapoint}]{\sphinxcrossref{\DUrole{std,std-ref}{Datapoint}}}} object to copy the data from. 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{Datapoint::setMpos (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_class_Datapoint:_CPPv2N9Datapoint7setMposEm}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{Exhaled/exhale_class_Datapoint:NECSimclass_datapoint_1a620aac6c81add9e842ca78005f04cf25}}\pysiglinewithargsret{void \sphinxbfcode{setMpos}}{unsigned long \sphinxstyleemphasis{z}}{}%
\pysigstopmultiline
Sets the mpos (the position within the {\hyperref[\detokenize{Exhaled/exhale_class_Row:NECSimclass_row}]{\sphinxcrossref{\DUrole{std,std-ref}{Row}}}} of {\hyperref[\detokenize{Exhaled/exhale_class_Treenode:NECSimclass_treenode}]{\sphinxcrossref{\DUrole{std,std-ref}{Treenode}}}} objects.). 

\begin{description}
\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{z}: the desired mpos. 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{Datapoint::setNext (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_class_Datapoint:_CPPv2N9Datapoint7setNextEm}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{Exhaled/exhale_class_Datapoint:NECSimclass_datapoint_1a7a2e682e5a607ead9c42df83a85a2451}}\pysiglinewithargsret{void \sphinxbfcode{setNext}}{unsigned long \sphinxstyleemphasis{x}}{}%
\pysigstopmultiline
Set the next link in the linked list. 

\begin{description}
\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{x}: the next {\hyperref[\detokenize{Exhaled/exhale_class_Datapoint:NECSimclass_datapoint}]{\sphinxcrossref{\DUrole{std,std-ref}{Datapoint}}}} object. 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{Datapoint::setListpos (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_class_Datapoint:_CPPv2N9Datapoint10setListposEt}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{Exhaled/exhale_class_Datapoint:NECSimclass_datapoint_1a6b215c1f8d39a4f92586304bd5bc98e6}}\pysiglinewithargsret{void \sphinxbfcode{setListpos}}{unsigned short \sphinxstyleemphasis{l}}{}%
\pysigstopmultiline
Sets the list position within the {\hyperref[\detokenize{Exhaled/exhale_class_SpeciesList:NECSimclass_species_list}]{\sphinxcrossref{\DUrole{std,std-ref}{SpeciesList}}}} object. 

\begin{description}
\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{l}: the input list position. 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{Datapoint::setNwrap (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_class_Datapoint:_CPPv2N9Datapoint8setNwrapEt}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{Exhaled/exhale_class_Datapoint:NECSimclass_datapoint_1a9ceb306367b83f24d28a4d9145137c44}}\pysiglinewithargsret{void \sphinxbfcode{setNwrap}}{unsigned short \sphinxstyleemphasis{n}}{}%
\pysigstopmultiline
Sets the number of wraps from the first {\hyperref[\detokenize{Exhaled/exhale_class_SpeciesList:NECSimclass_species_list}]{\sphinxcrossref{\DUrole{std,std-ref}{SpeciesList}}}} wrapped lineage. If and only if this is 0, the lineage is within the main grid (i.e xwrap and ywrap should be 0). 

\begin{description}
\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{n}: the desired nwrap. 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{Datapoint::setMinmax (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_class_Datapoint:_CPPv2N9Datapoint9setMinmaxEd}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{Exhaled/exhale_class_Datapoint:NECSimclass_datapoint_1ae39f89adc38ffd3402d0f375d93e9362}}\pysiglinewithargsret{void \sphinxbfcode{setMinmax}}{double \sphinxstyleemphasis{d}}{}%
\pysigstopmultiline
Sets the minmax variable. This is the minimum maximum speciation rate required for speciation to have occured on this branch. 

\begin{description}
\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{d}: the minmax to set. 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{Datapoint::subtractListpos (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_class_Datapoint:_CPPv2N9Datapoint15subtractListposEv}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{Exhaled/exhale_class_Datapoint:NECSimclass_datapoint_1a0c024dd886ef3c62ac732ceffd963f9f}}\pysiglinewithargsret{void \sphinxbfcode{subtractListpos}}{}{}%
\pysigstopmultiline
Decreases the list position by one. 

\end{fulllineitems}

\index{Datapoint::getXpos (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_class_Datapoint:_CPPv2N9Datapoint7getXposEv}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{Exhaled/exhale_class_Datapoint:NECSimclass_datapoint_1a5306d840ce80a85bc490197dade66836}}\pysiglinewithargsret{unsigned long \sphinxbfcode{getXpos}}{}{}%
\pysigstopmultiline
Get the x position. 

\begin{description}
\item[{\sphinxstylestrong{Return}}] \leavevmode
the xpos. 

\end{description}


\end{fulllineitems}

\index{Datapoint::getYpos (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_class_Datapoint:_CPPv2N9Datapoint7getYposEv}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{Exhaled/exhale_class_Datapoint:NECSimclass_datapoint_1aea9d27e1580af67e8bccbcf50f1dfe71}}\pysiglinewithargsret{unsigned long \sphinxbfcode{getYpos}}{}{}%
\pysigstopmultiline
Get the y position. 

\begin{description}
\item[{\sphinxstylestrong{Return}}] \leavevmode
the ypos. 

\end{description}


\end{fulllineitems}

\index{Datapoint::getXwrap (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_class_Datapoint:_CPPv2N9Datapoint8getXwrapEv}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{Exhaled/exhale_class_Datapoint:NECSimclass_datapoint_1a6470232aaebd69b3032a10c94f83eb7a}}\pysiglinewithargsret{long \sphinxbfcode{getXwrap}}{}{}%
\pysigstopmultiline
Get the x wrapping. 

\begin{description}
\item[{\sphinxstylestrong{Return}}] \leavevmode
the xwrap. 

\end{description}


\end{fulllineitems}

\index{Datapoint::getYwrap (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_class_Datapoint:_CPPv2N9Datapoint8getYwrapEv}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{Exhaled/exhale_class_Datapoint:NECSimclass_datapoint_1a662b95b7a5b1bbaa13163fbd36b81efd}}\pysiglinewithargsret{long \sphinxbfcode{getYwrap}}{}{}%
\pysigstopmultiline
Get the y wrapping. 

\begin{description}
\item[{\sphinxstylestrong{Return}}] \leavevmode
the ywrap. 

\end{description}


\end{fulllineitems}

\index{Datapoint::getMpos (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_class_Datapoint:_CPPv2N9Datapoint7getMposEv}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{Exhaled/exhale_class_Datapoint:NECSimclass_datapoint_1a2fc40c16d1d4642e3de6ad9ea828d9e1}}\pysiglinewithargsret{unsigned long \sphinxbfcode{getMpos}}{}{}%
\pysigstopmultiline
Get the matrix position variable. 

\begin{description}
\item[{\sphinxstylestrong{Return}}] \leavevmode
the mpos. 

\end{description}


\end{fulllineitems}

\index{Datapoint::getNext (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_class_Datapoint:_CPPv2N9Datapoint7getNextEv}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{Exhaled/exhale_class_Datapoint:NECSimclass_datapoint_1aeeeaebcc794466d066bafd2db7ef3f15}}\pysiglinewithargsret{unsigned long \sphinxbfcode{getNext}}{}{}%
\pysigstopmultiline
\end{fulllineitems}

\index{Datapoint::getListpos (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_class_Datapoint:_CPPv2N9Datapoint10getListposEv}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{Exhaled/exhale_class_Datapoint:NECSimclass_datapoint_1ad53fbe59c29639b953456e768c24eeb1}}\pysiglinewithargsret{unsigned short \sphinxbfcode{getListpos}}{}{}%
\pysigstopmultiline
Gets the list position with the {\hyperref[\detokenize{Exhaled/exhale_class_SpeciesList:NECSimclass_species_list}]{\sphinxcrossref{\DUrole{std,std-ref}{SpeciesList}}}} object at the relevant x,y position. 

\begin{description}
\item[{\sphinxstylestrong{Return}}] \leavevmode
the listpos. 

\end{description}


\end{fulllineitems}

\index{Datapoint::getNwrap (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_class_Datapoint:_CPPv2N9Datapoint8getNwrapEv}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{Exhaled/exhale_class_Datapoint:NECSimclass_datapoint_1a73da30c8bc51285c3b27fe0883f9686b}}\pysiglinewithargsret{unsigned short \sphinxbfcode{getNwrap}}{}{}%
\pysigstopmultiline
Get the position in the linked list from the {\hyperref[\detokenize{Exhaled/exhale_class_SpeciesList:NECSimclass_species_list}]{\sphinxcrossref{\DUrole{std,std-ref}{SpeciesList}}}} object. If this is 0, indicates the lineage lies on the original grid, and xwrap and ywrap should be 0. 

\begin{description}
\item[{\sphinxstylestrong{Return}}] \leavevmode
the nwrap. 

\end{description}


\end{fulllineitems}

\index{Datapoint::getMinmax (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_class_Datapoint:_CPPv2N9Datapoint9getMinmaxEv}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{Exhaled/exhale_class_Datapoint:NECSimclass_datapoint_1a7b8c11d840f3267814304ec49ce5ac70}}\pysiglinewithargsret{double \sphinxbfcode{getMinmax}}{}{}%
\pysigstopmultiline
Get the maximum minimum speciation rate required for speciation to have occured on this branch. 

\begin{description}
\item[{\sphinxstylestrong{Return}}] \leavevmode
the minmax. 

\end{description}


\end{fulllineitems}

\index{Datapoint::decreaseNwrap (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_class_Datapoint:_CPPv2N9Datapoint13decreaseNwrapEv}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{Exhaled/exhale_class_Datapoint:NECSimclass_datapoint_1a21ea22f081195093473c96a20273ee24}}\pysiglinewithargsret{void \sphinxbfcode{decreaseNwrap}}{}{}%
\pysigstopmultiline
Decreases the nwrap by 1 (to a minimum of 0). 

\end{fulllineitems}

\index{Datapoint::setEndpoint (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_class_Datapoint:_CPPv2N9Datapoint11setEndpointEllll}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{Exhaled/exhale_class_Datapoint:NECSimclass_datapoint_1a22596e6d3f3e75b1ccc4f1169cf3a2d1}}\pysiglinewithargsret{void \sphinxbfcode{setEndpoint}}{long \sphinxstyleemphasis{x}, long \sphinxstyleemphasis{y}, long \sphinxstyleemphasis{xwrapin}, long \sphinxstyleemphasis{ywrapin}}{}%
\pysigstopmultiline
Sets the position in space. 

\begin{description}
\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{x}: the x position. 

\item {} 
\sphinxcode{y}: the y position. 

\item {} 
\sphinxcode{xwrapin}: the number of wraps in the x direction. 

\item {} 
\sphinxcode{ywrapin}: the number of wraps in the y direction. 

\end{itemize}

\end{description}


\end{fulllineitems}

\paragraph{Friends}
\index{operator\textless{}\textless{} (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_class_Datapoint:_CPPv2lsR7ostreamRK9Datapoint}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{Exhaled/exhale_class_Datapoint:NECSimclass_datapoint_1a4a75b1eb47fdbc43e2feaa39f0170403}}\pysiglinewithargsret{ostream \&\sphinxbfcode{operator\textless{}\textless{}}}{ostream \&\sphinxstyleemphasis{os}, \sphinxstrong{const} {\hyperref[\detokenize{Exhaled/exhale_class_Datapoint:_CPPv29Datapoint}]{\sphinxcrossref{Datapoint}}} \&\sphinxstyleemphasis{d}}{}%
\pysigstopmultiline
An operator for piping the variables of the {\hyperref[\detokenize{Exhaled/exhale_class_Datapoint:NECSimclass_datapoint}]{\sphinxcrossref{\DUrole{std,std-ref}{Datapoint}}}} object to the output stream. 

\begin{description}
\item[{\sphinxstylestrong{Return}}] \leavevmode
returns the output stream at the end. 

\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{os}: the output stream. 

\item {} 
\sphinxcode{d}: the {\hyperref[\detokenize{Exhaled/exhale_class_Datapoint:NECSimclass_datapoint}]{\sphinxcrossref{\DUrole{std,std-ref}{Datapoint}}}} object to output. 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{operator\textgreater{}\textgreater{} (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_class_Datapoint:_CPPv2rsR7istreamR9Datapoint}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{Exhaled/exhale_class_Datapoint:NECSimclass_datapoint_1a0bd7caab24edc6b23fef8afd392ed4ce}}\pysiglinewithargsret{istream \&\sphinxbfcode{operator\textgreater{}\textgreater{}}}{istream \&\sphinxstyleemphasis{is}, {\hyperref[\detokenize{Exhaled/exhale_class_Datapoint:_CPPv29Datapoint}]{\sphinxcrossref{Datapoint}}} \&\sphinxstyleemphasis{d}}{}%
\pysigstopmultiline
An operator for piping the variables in to the {\hyperref[\detokenize{Exhaled/exhale_class_Datapoint:NECSimclass_datapoint}]{\sphinxcrossref{\DUrole{std,std-ref}{Datapoint}}}} object from the input stream. 

\begin{description}
\item[{\sphinxstylestrong{Return}}] \leavevmode
returns the input stream at the end. 

\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{is}: the input stream 

\item {} 
\sphinxcode{d}: the {\hyperref[\detokenize{Exhaled/exhale_class_Datapoint:NECSimclass_datapoint}]{\sphinxcrossref{\DUrole{std,std-ref}{Datapoint}}}} object to input to. 

\end{itemize}

\end{description}


\end{fulllineitems}


\end{fulllineitems}



\paragraph{Class Map}
\label{\detokenize{Exhaled/exhale_class_Map:class-map}}\label{\detokenize{Exhaled/exhale_class_Map::doc}}\label{\detokenize{Exhaled/exhale_class_Map:id1}}\begin{itemize}
\item {} 
Defined in {\hyperref[\detokenize{Exhaled/exhale_file_Map.h:file-map-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File Map.h}}}}

\end{itemize}
\index{Map (C++ class)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_class_Map:_CPPv23Map}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{Exhaled/exhale_class_Map:NECSimclass_map}}\pysigline{\sphinxstrong{class }\sphinxcode{}\sphinxbfcode{Map}}%
\pysigstopmultiline
Contains all maps and provides the functions for accessing a grid cell in the correct temporal and spacial location. The function {\hyperref[\detokenize{Exhaled/exhale_class_Map:NECSimclass_map_1a1e51ddc7b9472eecb12245fddaf67319}]{\sphinxcrossref{\DUrole{std,std-ref}{runDispersal()}}}} also provides the move routine, provided two alternative methods for moving individuals. 
\paragraph{Public Functions}
\index{Map::Map (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_class_Map:_CPPv2N3Map3MapEv}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{Exhaled/exhale_class_Map:NECSimclass_map_1a0f5ad0fd4563497b4214038cbca8b582}}\pysiglinewithargsret{\sphinxbfcode{Map}}{}{}%
\pysigstopmultiline
The default constructor. 

\end{fulllineitems}

\index{Map::setDims (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_class_Map:_CPPv2N3Map7setDimsE7Mapvars}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{Exhaled/exhale_class_Map:NECSimclass_map_1afeeaf2700774681a411b634a82870c6f}}\pysiglinewithargsret{void \sphinxbfcode{setDims}}{{\hyperref[\detokenize{Exhaled/exhale_struct_Mapvars:_CPPv27Mapvars}]{\sphinxcrossref{Mapvars}}} \sphinxstyleemphasis{mapvarsin}}{}%
\pysigstopmultiline
Sets the dimensions of the grid, the area where the species are initially sampled from. This function must be run before any of the calc map functions to allow for the correct deme allocation. 

\begin{description}
\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{mapvarsin}: the {\hyperref[\detokenize{Exhaled/exhale_struct_Mapvars:NECSimstruct_mapvars}]{\sphinxcrossref{\DUrole{std,std-ref}{Mapvars}}}} object containing the map variables to import 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{Map::checkMapExists (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_class_Map:_CPPv2N3Map14checkMapExistsEv}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{Exhaled/exhale_class_Map:NECSimclass_map_1ab74d57e0de40b6e16c7bb62489ecff5c}}\pysiglinewithargsret{bool \sphinxbfcode{checkMapExists}}{}{}%
\pysigstopmultiline
\end{fulllineitems}

\index{Map::calcFineMap (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_class_Map:_CPPv2N3Map11calcFineMapEv}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{Exhaled/exhale_class_Map:NECSimclass_map_1ab3c9e77675ad9ca1d34e9ff8e861901d}}\pysiglinewithargsret{void \sphinxbfcode{calcFineMap}}{}{}%
\pysigstopmultiline
Imports the fine map object from file and calculates the correct values at each point. Without a map to input, the fine map will simply be a matrix of 1s. 

\end{fulllineitems}

\index{Map::calcPristineFineMap (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_class_Map:_CPPv2N3Map19calcPristineFineMapEv}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{Exhaled/exhale_class_Map:NECSimclass_map_1ab1d1bac59d3e1518deaa2ebc561a7f82}}\pysiglinewithargsret{void \sphinxbfcode{calcPristineFineMap}}{}{}%
\pysigstopmultiline
Imports the pristine fine map object from file and calculates the correct values at each point. Without a map to input, the pristine fine map will simply be a matrix of 1s. This has the potential to be changed easily in future versions. 

\end{fulllineitems}

\index{Map::calcCoarseMap (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_class_Map:_CPPv2N3Map13calcCoarseMapEv}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{Exhaled/exhale_class_Map:NECSimclass_map_1ac0b46ec7e4792d6ad3d7bdcf358ecabf}}\pysiglinewithargsret{void \sphinxbfcode{calcCoarseMap}}{}{}%
\pysigstopmultiline
Imports the coarse map object from file and calculates the correct values at each point. Without a map to input, the coarse map will simply be a matrix of 1s. This has the potential to be changed easily in future versions. 

\end{fulllineitems}

\index{Map::calcPristineCoarseMap (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_class_Map:_CPPv2N3Map21calcPristineCoarseMapEv}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{Exhaled/exhale_class_Map:NECSimclass_map_1a4efc51f5d4e2bb562cf4126a7f291f33}}\pysiglinewithargsret{void \sphinxbfcode{calcPristineCoarseMap}}{}{}%
\pysigstopmultiline
Imports the pristine coarse map object from file and calculates the correct values at each point. Without a map to input, the pristine coarse map will simply be a matrix of 1s. This has the potential to be changed easily in future versions. 

\end{fulllineitems}

\index{Map::setTimeVars (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_class_Map:_CPPv2N3Map11setTimeVarsEdd}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{Exhaled/exhale_class_Map:NECSimclass_map_1aa91176218ae59941096b4a080b2e45ee}}\pysiglinewithargsret{void \sphinxbfcode{setTimeVars}}{double \sphinxstyleemphasis{dPristinein}, double \sphinxstyleemphasis{dForestTransformin}}{}%
\pysigstopmultiline
Sets the time variables. 

\begin{description}
\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{dPristinein}: the time (in generations) since a pristine habitat state was achieved. 

\item {} 
\sphinxcode{dForestTransformin}: the rate of transform of the forest up until the pristine time. A value of 0.2 would mean 20\% of the change occurs linearlly up until the pristine time and the remaining 80\% occurs in a jump to the pristine state. 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{Map::calcOffset (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_class_Map:_CPPv2N3Map10calcOffsetEv}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{Exhaled/exhale_class_Map:NECSimclass_map_1a7615f4c20da51b3a96d60f9fa89ec73e}}\pysiglinewithargsret{void \sphinxbfcode{calcOffset}}{}{}%
\pysigstopmultiline
Calculates the offset and extremeties of the fine map. 

Note that setting lambda to a value other than 1 can massively increase simulation time. 

\end{fulllineitems}

\index{Map::validateMaps (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_class_Map:_CPPv2N3Map12validateMapsEv}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{Exhaled/exhale_class_Map:NECSimclass_map_1a123d710095a549030f2c801ccf9645f1}}\pysiglinewithargsret{void \sphinxbfcode{validateMaps}}{}{}%
\pysigstopmultiline
Checks that the map file sizes are correct and that each value on the fragmented maps is less than the pristine maps. This should be disabled in simulations where habitat sizes are expected to shrink as well as grow. 

\end{fulllineitems}

\index{Map::updateMap (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_class_Map:_CPPv2N3Map9updateMapEd}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{Exhaled/exhale_class_Map:NECSimclass_map_1a0c71277515f9f2fc5e2ae586ae9d07f8}}\pysiglinewithargsret{void \sphinxbfcode{updateMap}}{double \sphinxstyleemphasis{generation}}{}%
\pysigstopmultiline
Updates the maps to the newer map. 

\end{fulllineitems}

\index{Map::isPristine (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_class_Map:_CPPv2N3Map10isPristineEv}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{Exhaled/exhale_class_Map:NECSimclass_map_1a7c4ca1306850126bf6c040f1c0cc0754}}\pysiglinewithargsret{bool \sphinxbfcode{isPristine}}{}{}%
\pysigstopmultiline
Gets the pristine boolean. 

\begin{description}
\item[{\sphinxstylestrong{Return}}] \leavevmode
the pristine map state. 

\end{description}


\end{fulllineitems}

\index{Map::setPristine (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_class_Map:_CPPv2N3Map11setPristineERKb}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{Exhaled/exhale_class_Map:NECSimclass_map_1aff6628e343532689d5bdcee2433ac041}}\pysiglinewithargsret{void \sphinxbfcode{setPristine}}{\sphinxstrong{const} bool \&\sphinxstyleemphasis{bPristinein}}{}%
\pysigstopmultiline
Sets the pristine state of the system. 

\begin{description}
\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{bPristinein}: the pristine state. 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{Map::getVal (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_class_Map:_CPPv2N3Map6getValERKdRKdRKlRKlRKd}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{Exhaled/exhale_class_Map:NECSimclass_map_1a0b45a88de2168f54a7c0005bd458114c}}\pysiglinewithargsret{unsigned short \sphinxbfcode{getVal}}{\sphinxstrong{const} double \&\sphinxstyleemphasis{x}, \sphinxstrong{const} double \&\sphinxstyleemphasis{y}, \sphinxstrong{const} long \&\sphinxstyleemphasis{xwrap}, \sphinxstrong{const} long \&\sphinxstyleemphasis{ywrap}, \sphinxstrong{const} double \&\sphinxstyleemphasis{dCurrentGen}}{}%
\pysigstopmultiline
Gets the value at a particular coordinate from the correct map. Takes in to account temporal and spatial referencing. This version assumes an infinite landscape. 

\begin{description}
\item[{\sphinxstylestrong{Return}}] \leavevmode
the value on the correct map at the correct space. 

\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{x}: the x position on the grid. 

\item {} 
\sphinxcode{y}: the y position on the grid. 

\item {} 
\sphinxcode{xwrap}: the number of wraps in the x dimension.. 

\item {} 
\sphinxcode{ywrap}: the number of wraps in the y dimension.. 

\item {} 
\sphinxcode{dCurrentGen}: the current generation time. 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{Map::getInitialCount (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_class_Map:_CPPv2N3Map15getInitialCountEdR8Datamask}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{Exhaled/exhale_class_Map:NECSimclass_map_1ad5a611be56ff6dc834dac93e91644f8e}}\pysiglinewithargsret{unsigned long \sphinxbfcode{getInitialCount}}{double \sphinxstyleemphasis{dSample}, {\hyperref[\detokenize{Exhaled/exhale_class_Datamask:_CPPv28Datamask}]{\sphinxcrossref{Datamask}}} \&\sphinxstyleemphasis{samplemask}}{}%
\pysigstopmultiline
Counts the number of spaces available in the initial species space. Requires the samplemask to check the sampling area. 

\begin{description}
\item[{\sphinxstylestrong{Return}}] \leavevmode
the total number of individuals predicted to initially exist on the map. 

\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{dSample}: the sample proportion (from 0 to 1). 

\item {} 
\sphinxcode{samplemask}: the {\hyperref[\detokenize{Exhaled/exhale_class_Datamask:NECSimclass_datamask}]{\sphinxcrossref{\DUrole{std,std-ref}{Datamask}}}} object to sample from. 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{Map::checkMap (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_class_Map:_CPPv2N3Map8checkMapERKdRKdRKlRKlKd}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{Exhaled/exhale_class_Map:NECSimclass_map_1ac5e842ad3f8d76f2293a6b1be44071ca}}\pysiglinewithargsret{bool \sphinxbfcode{checkMap}}{\sphinxstrong{const} double \&\sphinxstyleemphasis{x}, \sphinxstrong{const} double \&\sphinxstyleemphasis{y}, \sphinxstrong{const} long \&\sphinxstyleemphasis{xwrap}, \sphinxstrong{const} long \&\sphinxstyleemphasis{ywrap}, \sphinxstrong{const} double \sphinxstyleemphasis{generation}}{}%
\pysigstopmultiline
Checks whether the point is forest or non-forest. 

\begin{description}
\item[{\sphinxstylestrong{Return}}] \leavevmode
a boolean of whether the map is forest or non-forest. 

\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{x}: the x position on the grid. 

\item {} 
\sphinxcode{y}: the y position on the grid. 

\item {} 
\sphinxcode{xwrap}: the number of wraps in the x dimension. 

\item {} 
\sphinxcode{ywrap}: the number of wraps in the y dimension. 

\item {} 
\sphinxcode{generation}: the current generation time. 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{Map::checkFine (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_class_Map:_CPPv2N3Map9checkFineERKdRKdRKlRKl}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{Exhaled/exhale_class_Map:NECSimclass_map_1aae9663c2b5bb78e89e2c476d1d1a409b}}\pysiglinewithargsret{bool \sphinxbfcode{checkFine}}{\sphinxstrong{const} double \&\sphinxstyleemphasis{x}, \sphinxstrong{const} double \&\sphinxstyleemphasis{y}, \sphinxstrong{const} long \&\sphinxstyleemphasis{xwrap}, \sphinxstrong{const} long \&\sphinxstyleemphasis{ywrap}}{}%
\pysigstopmultiline
Checks whether the point comes from the fine grid. 

\begin{description}
\item[{\sphinxstylestrong{Return}}] \leavevmode
a boolean of whether the location is on the fine map. 

\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{x}: the x position. 

\item {} 
\sphinxcode{y}: the y position. 

\item {} 
\sphinxcode{xwrap}: the number of wraps in the x dimension. 

\item {} 
\sphinxcode{ywrap}: the number of wraps in the y dimension. 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{Map::convertCoordinates (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_class_Map:_CPPv2N3Map18convertCoordinatesERdRdRlRl}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{Exhaled/exhale_class_Map:NECSimclass_map_1af0f4a6a41c91e915614b56b2422d6d5a}}\pysiglinewithargsret{void \sphinxbfcode{convertCoordinates}}{double \&\sphinxstyleemphasis{x}, double \&\sphinxstyleemphasis{y}, long \&\sphinxstyleemphasis{xwrap}, long \&\sphinxstyleemphasis{ywrap}}{}%
\pysigstopmultiline
Converts the coordinates to within the original grid, altering the xwrap and ywrap consequently. 

\begin{description}
\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{x}: the x position. 

\item {} 
\sphinxcode{y}: the y position. 

\item {} 
\sphinxcode{xwrap}: the number of wraps in the x dimension. 

\item {} 
\sphinxcode{ywrap}: the number of wraps in the y dimension. 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{Map::runDispersal (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_class_Map:_CPPv2N3Map12runDispersalERKdRKdRlRlRlRlRbRKd}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{Exhaled/exhale_class_Map:NECSimclass_map_1a1e51ddc7b9472eecb12245fddaf67319}}\pysiglinewithargsret{void \sphinxbfcode{runDispersal}}{\sphinxstrong{const} double \&\sphinxstyleemphasis{dist}, \sphinxstrong{const} double \&\sphinxstyleemphasis{angle}, long \&\sphinxstyleemphasis{startx}, long \&\sphinxstyleemphasis{starty}, long \&\sphinxstyleemphasis{startxwrap}, long \&\sphinxstyleemphasis{startywrap}, bool \&\sphinxstyleemphasis{disp\_comp}, \sphinxstrong{const} double \&\sphinxstyleemphasis{generation}}{}%
\pysigstopmultiline
The function that actually performs the dispersal. It is included here for easier programming and efficiency as the function doesn't need to perform all the checks until the edge of the fine grid. 

\begin{description}
\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{dist}: the distance travelled (or ``distance energy'' if lambda is not 1). 

\item {} 
\sphinxcode{angle}: the angle of movement. 

\item {} 
\sphinxcode{startx}: the start x position. 

\item {} 
\sphinxcode{starty}: the start y position. 

\item {} 
\sphinxcode{startxwrap}: the start number of wraps in the x dimension. 

\item {} 
\sphinxcode{startywrap}: the start number of wraps in the y dimension. 

\item {} 
\sphinxcode{disp\_comp}: a boolean of whether the dispersal was complete or not. This value is returned true if dispersal is to habitat, false otherwise. 

\item {} 
\sphinxcode{generation}: the time in generations since the start of the simulation. 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{Map::printVars (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_class_Map:_CPPv2N3Map9printVarsEv}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{Exhaled/exhale_class_Map:NECSimclass_map_1a6f9331522fad5f91269e8ececc75a20d}}\pysiglinewithargsret{void \sphinxbfcode{printVars}}{}{}%
\pysigstopmultiline
Prints some selected {\hyperref[\detokenize{Exhaled/exhale_class_Map:NECSimclass_map}]{\sphinxcrossref{\DUrole{std,std-ref}{Map}}}} variables to the terminal. 

\end{fulllineitems}

\index{Map::clearMap (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_class_Map:_CPPv2N3Map8clearMapEv}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{Exhaled/exhale_class_Map:NECSimclass_map_1a7ded655c7db0e9d72816430b4f2c83a5}}\pysiglinewithargsret{void \sphinxbfcode{clearMap}}{}{}%
\pysigstopmultiline
Wipes the map of all variables. Only really useful for testing purposes. 

\end{fulllineitems}

\paragraph{Friends}
\index{operator\textless{}\textless{} (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_class_Map:_CPPv2lsR7ostreamRK3Map}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{Exhaled/exhale_class_Map:NECSimclass_map_1a0da37af2cd547fa045e06a2da3c1039f}}\pysiglinewithargsret{ostream \&\sphinxbfcode{operator\textless{}\textless{}}}{ostream \&\sphinxstyleemphasis{os}, \sphinxstrong{const} {\hyperref[\detokenize{Exhaled/exhale_class_Map:_CPPv23Map}]{\sphinxcrossref{Map}}} \&\sphinxstyleemphasis{r}}{}%
\pysigstopmultiline
Operator for outputting the {\hyperref[\detokenize{Exhaled/exhale_class_Map:NECSimclass_map}]{\sphinxcrossref{\DUrole{std,std-ref}{Map}}}} object variables to an output stream. This is used for storing the {\hyperref[\detokenize{Exhaled/exhale_class_Map:NECSimclass_map}]{\sphinxcrossref{\DUrole{std,std-ref}{Map}}}} object to file. 

\begin{description}
\item[{\sphinxstylestrong{Return}}] \leavevmode
the output stream. 

\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{os}: the output stream. 

\item {} 
\sphinxcode{r}: the {\hyperref[\detokenize{Exhaled/exhale_class_Map:NECSimclass_map}]{\sphinxcrossref{\DUrole{std,std-ref}{Map}}}} object to output. 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{operator\textgreater{}\textgreater{} (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_class_Map:_CPPv2rsR7istreamR3Map}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{Exhaled/exhale_class_Map:NECSimclass_map_1a480da4c3f474c0af7eacdde650546dc1}}\pysiglinewithargsret{istream \&\sphinxbfcode{operator\textgreater{}\textgreater{}}}{istream \&\sphinxstyleemphasis{is}, {\hyperref[\detokenize{Exhaled/exhale_class_Map:_CPPv23Map}]{\sphinxcrossref{Map}}} \&\sphinxstyleemphasis{r}}{}%
\pysigstopmultiline
Operator for inputting the {\hyperref[\detokenize{Exhaled/exhale_class_Map:NECSimclass_map}]{\sphinxcrossref{\DUrole{std,std-ref}{Map}}}} object variables from an input stream. This is used for reading the {\hyperref[\detokenize{Exhaled/exhale_class_Map:NECSimclass_map}]{\sphinxcrossref{\DUrole{std,std-ref}{Map}}}} object from file. 

\begin{description}
\item[{\sphinxstylestrong{Return}}] \leavevmode
the input stream. 

\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{is}: the input stream. 

\item {} 
\sphinxcode{r}: the {\hyperref[\detokenize{Exhaled/exhale_class_Map:NECSimclass_map}]{\sphinxcrossref{\DUrole{std,std-ref}{Map}}}} object to input to. 

\end{itemize}

\end{description}


\end{fulllineitems}


\end{fulllineitems}



\paragraph{Class Matrix}
\label{\detokenize{Exhaled/exhale_class_Matrix:class-matrix}}\label{\detokenize{Exhaled/exhale_class_Matrix::doc}}\label{\detokenize{Exhaled/exhale_class_Matrix:id1}}\begin{itemize}
\item {} 
Defined in {\hyperref[\detokenize{Exhaled/exhale_file_Matrix.h:file-matrix-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File Matrix.h}}}}

\end{itemize}
\index{Matrix (C++ class)}

\begin{fulllineitems}
\pysigline{\phantomsection\label{\detokenize{Exhaled/exhale_class_Matrix:NECSimclass_matrix}}\sphinxstrong{template }\textless{}class \sphinxstyleemphasis{T}\textgreater{}}\phantomsection\label{\detokenize{Exhaled/exhale_class_Matrix:_CPPv26Matrix}}%
\pysigstartmultiline
\pysigline{\sphinxstrong{class }\sphinxcode{}\sphinxbfcode{Matrix}}%
\pysigstopmultiline
A class containing the {\hyperref[\detokenize{Exhaled/exhale_class_Matrix:NECSimclass_matrix}]{\sphinxcrossref{\DUrole{std,std-ref}{Matrix}}}} object, set up as an array of {\hyperref[\detokenize{Exhaled/exhale_class_Row:NECSimclass_row}]{\sphinxcrossref{\DUrole{std,std-ref}{Row}}}} objects. Includes basic operations, as well as the {\hyperref[\detokenize{Exhaled/exhale_class_Matrix:NECSimclass_matrix_1ace5dbaac7d1be865b2f366bfe8896a41}]{\sphinxcrossref{\DUrole{std,std-ref}{importCsv()}}}} function for more advanced reading from file. 
\paragraph{Public Functions}
\index{Matrix::Matrix (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_class_Matrix:_CPPv2N6Matrix6MatrixEii}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{Exhaled/exhale_class_Matrix:NECSimclass_matrix_1a3ebbc04812668005b87e5c0cf28fa4ac}}\pysiglinewithargsret{\sphinxbfcode{Matrix}}{int \sphinxstyleemphasis{rows} = 0, int \sphinxstyleemphasis{cols} = 0}{}%
\pysigstopmultiline
The standard constructor. 

\begin{description}
\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{rows}: optionally provide the number of rows. 

\item {} 
\sphinxcode{cols}: optionally provide the number of columns. 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{Matrix::Matrix (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_class_Matrix:_CPPv2N6Matrix6MatrixERK6Matrix}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{Exhaled/exhale_class_Matrix:NECSimclass_matrix_1a3796b4f32dc8e11f908a90fd3dd39c45}}\pysiglinewithargsret{\sphinxbfcode{Matrix}}{\sphinxstrong{const} {\hyperref[\detokenize{Exhaled/exhale_class_Matrix:_CPPv2N6Matrix6MatrixEii}]{\sphinxcrossref{Matrix}}} \&\sphinxstyleemphasis{m}}{}%
\pysigstopmultiline
The copy constructor. 

\begin{description}
\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{m}: a {\hyperref[\detokenize{Exhaled/exhale_class_Matrix:NECSimclass_matrix}]{\sphinxcrossref{\DUrole{std,std-ref}{Matrix}}}} object to copy from. 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{Matrix::\textasciitilde{}Matrix (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_class_Matrix:_CPPv2N6MatrixD0Ev}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{Exhaled/exhale_class_Matrix:NECSimclass_matrix_1a91aa704de674203e96aece9e1955ccd3}}\pysiglinewithargsret{\sphinxbfcode{\textasciitilde{}Matrix}}{}{}%
\pysigstopmultiline
The descructor. 

\end{fulllineitems}

\index{Matrix::SetSize (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_class_Matrix:_CPPv2N6Matrix7SetSizeEii}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{Exhaled/exhale_class_Matrix:NECSimclass_matrix_1a3a67be1265f2a0b3013c404de23bb923}}\pysiglinewithargsret{void \sphinxbfcode{SetSize}}{int \sphinxstyleemphasis{rows}, int \sphinxstyleemphasis{cols}}{}%
\pysigstopmultiline
Sets the matrix size. Similar concept to that for Rows. 

\begin{description}
\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{rows}: the number of rows. 

\item {} 
\sphinxcode{cols}: the number of columns. 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{Matrix::GetCols (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_class_Matrix:_CPPv2NK6Matrix7GetColsEv}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{Exhaled/exhale_class_Matrix:NECSimclass_matrix_1a7c5a2084fef6150e385a0999a8be0c42}}\pysiglinewithargsret{int \sphinxbfcode{GetCols}}{}{ \sphinxstrong{const}}%
\pysigstopmultiline
Getter for the number of columns. 

\begin{description}
\item[{\sphinxstylestrong{Return}}] \leavevmode
the number of columns. 

\end{description}


\end{fulllineitems}

\index{Matrix::GetRows (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_class_Matrix:_CPPv2NK6Matrix7GetRowsEv}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{Exhaled/exhale_class_Matrix:NECSimclass_matrix_1a5327f1aa4d6066effedb00227dc8ad2f}}\pysiglinewithargsret{int \sphinxbfcode{GetRows}}{}{ \sphinxstrong{const}}%
\pysigstopmultiline
Getter for the number of rows. 

\begin{description}
\item[{\sphinxstylestrong{Return}}] \leavevmode
the number of rows. 

\end{description}


\end{fulllineitems}

\index{Matrix::operator{[}{]} (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_class_Matrix:_CPPv2N6MatrixixEm}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{Exhaled/exhale_class_Matrix:NECSimclass_matrix_1ae7e14b4bd8bb570260a4e578e4a601b7}}\pysiglinewithargsret{{\hyperref[\detokenize{Exhaled/exhale_class_Row:_CPPv23Row}]{\sphinxcrossref{Row}}}\textless{}T\textgreater{} \&\sphinxbfcode{operator{[}{]}}}{unsigned long \sphinxstyleemphasis{index}}{}%
\pysigstopmultiline
Overoads the {[}{]} operator for {\hyperref[\detokenize{Exhaled/exhale_class_Matrix:NECSimclass_matrix}]{\sphinxcrossref{\DUrole{std,std-ref}{Matrix}}}}. Allows referencing of a value i,j using {\hyperref[\detokenize{Exhaled/exhale_class_Matrix:NECSimclass_matrix}]{\sphinxcrossref{\DUrole{std,std-ref}{Matrix}}}}{[}i{]}{[}j{]}. Includes error checking for if the indices are out of range of the matrix. Note that this functionality has been altered since the original file generation. 

\begin{description}
\item[{\sphinxstylestrong{Return}}] \leavevmode
the matrix row object. 

\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{index}: the row number to get the value from. 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{Matrix::operator= (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_class_Matrix:_CPPv2N6MatrixaSERK6Matrix}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{Exhaled/exhale_class_Matrix:NECSimclass_matrix_1a94508f84ba0d62e81aa8d508aa43f1ec}}\pysiglinewithargsret{{\hyperref[\detokenize{Exhaled/exhale_class_Matrix:_CPPv26Matrix}]{\sphinxcrossref{Matrix}}} \&\sphinxbfcode{operator=}}{\sphinxstrong{const} {\hyperref[\detokenize{Exhaled/exhale_class_Matrix:_CPPv26Matrix}]{\sphinxcrossref{Matrix}}} \&\sphinxstyleemphasis{m}}{}%
\pysigstopmultiline
Overloading the = operator. 

\begin{description}
\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{m}: the matrix to copy from. 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{Matrix::operator+ (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_class_Matrix:_CPPv2N6MatrixplERK6Matrix}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{Exhaled/exhale_class_Matrix:NECSimclass_matrix_1a311f3649e41cb4a3155f3f71a65829cb}}\pysiglinewithargsret{\sphinxstrong{const} {\hyperref[\detokenize{Exhaled/exhale_class_Matrix:_CPPv26Matrix}]{\sphinxcrossref{Matrix}}} \sphinxbfcode{operator+}}{\sphinxstrong{const} {\hyperref[\detokenize{Exhaled/exhale_class_Matrix:_CPPv26Matrix}]{\sphinxcrossref{Matrix}}} \&\sphinxstyleemphasis{m}}{}%
\pysigstopmultiline
Overloading the + operator. 

\begin{description}
\item[{\sphinxstylestrong{Return}}] \leavevmode
the matrix object which is the sum of the two matrices. 

\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{m}: the matrix to add to this matrix. 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{Matrix::operator- (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_class_Matrix:_CPPv2N6MatrixmiERK6Matrix}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{Exhaled/exhale_class_Matrix:NECSimclass_matrix_1a08e75978ea8288083ef36f53b4ac115d}}\pysiglinewithargsret{\sphinxstrong{const} {\hyperref[\detokenize{Exhaled/exhale_class_Matrix:_CPPv26Matrix}]{\sphinxcrossref{Matrix}}} \sphinxbfcode{operator-}}{\sphinxstrong{const} {\hyperref[\detokenize{Exhaled/exhale_class_Matrix:_CPPv26Matrix}]{\sphinxcrossref{Matrix}}} \&\sphinxstyleemphasis{m}}{}%
\pysigstopmultiline
Overloading the - operator. 

\begin{description}
\item[{\sphinxstylestrong{Return}}] \leavevmode
the matrix object which is the subtraction of the two matrices. 

\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{m}: the matrix to subtract from this matrix. 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{Matrix::operator+= (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_class_Matrix:_CPPv2N6MatrixpLERK6Matrix}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{Exhaled/exhale_class_Matrix:NECSimclass_matrix_1a480a72298ae1fc8443b0edfaa66d7c46}}\pysiglinewithargsret{{\hyperref[\detokenize{Exhaled/exhale_class_Matrix:_CPPv26Matrix}]{\sphinxcrossref{Matrix}}} \&\sphinxbfcode{operator+=}}{\sphinxstrong{const} {\hyperref[\detokenize{Exhaled/exhale_class_Matrix:_CPPv26Matrix}]{\sphinxcrossref{Matrix}}} \&\sphinxstyleemphasis{m}}{}%
\pysigstopmultiline
Overloading the += operator so that the new object is written to the current object. 

\begin{description}
\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{m}: the {\hyperref[\detokenize{Exhaled/exhale_class_Matrix:NECSimclass_matrix}]{\sphinxcrossref{\DUrole{std,std-ref}{Matrix}}}} object to add to this matrix. 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{Matrix::operator-= (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_class_Matrix:_CPPv2N6MatrixmIERK6Matrix}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{Exhaled/exhale_class_Matrix:NECSimclass_matrix_1a0e459fd035b2435ea016dc93c55ccac0}}\pysiglinewithargsret{{\hyperref[\detokenize{Exhaled/exhale_class_Matrix:_CPPv26Matrix}]{\sphinxcrossref{Matrix}}} \&\sphinxbfcode{operator-=}}{\sphinxstrong{const} {\hyperref[\detokenize{Exhaled/exhale_class_Matrix:_CPPv26Matrix}]{\sphinxcrossref{Matrix}}} \&\sphinxstyleemphasis{m}}{}%
\pysigstopmultiline
Overloading the -= operator so that the new object is written to the current object. 

\begin{description}
\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{m}: the {\hyperref[\detokenize{Exhaled/exhale_class_Matrix:NECSimclass_matrix}]{\sphinxcrossref{\DUrole{std,std-ref}{Matrix}}}} object to subtract from this matrix. 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{Matrix::operator* (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_class_Matrix:_CPPv2N6MatrixmlEKd}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{Exhaled/exhale_class_Matrix:NECSimclass_matrix_1ac4e94b307c56a15fb47a9255855f94a9}}\pysiglinewithargsret{\sphinxstrong{const} {\hyperref[\detokenize{Exhaled/exhale_class_Matrix:_CPPv26Matrix}]{\sphinxcrossref{Matrix}}} \sphinxbfcode{operator*}}{\sphinxstrong{const} double \sphinxstyleemphasis{s}}{}%
\pysigstopmultiline
Overloading the * operator for scaling. 

\begin{description}
\item[{\sphinxstylestrong{Return}}] \leavevmode
the scaled matrix. 

\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{s}: the constant to scale the matrix by. 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{Matrix::operator* (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_class_Matrix:_CPPv2N6MatrixmlER6Matrix}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{Exhaled/exhale_class_Matrix:NECSimclass_matrix_1ac396cdd2d98e1b4d99f7e17c1c26b1ec}}\pysiglinewithargsret{\sphinxstrong{const} {\hyperref[\detokenize{Exhaled/exhale_class_Matrix:_CPPv26Matrix}]{\sphinxcrossref{Matrix}}} \sphinxbfcode{operator*}}{{\hyperref[\detokenize{Exhaled/exhale_class_Matrix:_CPPv26Matrix}]{\sphinxcrossref{Matrix}}} \&\sphinxstyleemphasis{m}}{}%
\pysigstopmultiline
Overloading the * operator for matrix multiplication. Multiplies each value in the matrix with its corresponding value in the other matrix. 

\begin{description}
\item[{\sphinxstylestrong{Return}}] \leavevmode
the product of each ith,jth value of the matrix. 

\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{m}: the matrix to multiply with 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{Matrix::symmetric (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_class_Matrix:_CPPv2N6Matrix9symmetricEv}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{Exhaled/exhale_class_Matrix:NECSimclass_matrix_1a2df813f38f535bde8d1c8ae00b9c2eb4}}\pysiglinewithargsret{bool \sphinxbfcode{symmetric}}{}{}%
\pysigstopmultiline
Checks if the matrix is symmetric or not. 

\begin{description}
\item[{\sphinxstylestrong{Return}}] \leavevmode
true if matrix is symmetric, false otherwise. 

\end{description}


\end{fulllineitems}

\index{Matrix::setValue (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_class_Matrix:_CPPv2N6Matrix8setValueERKmRKmPcRKd}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{Exhaled/exhale_class_Matrix:NECSimclass_matrix_1a93ee02612d3a28747bdbe7667e3c3f29}}\pysiglinewithargsret{void \sphinxbfcode{setValue}}{\sphinxstrong{const} unsigned long \&\sphinxstyleemphasis{x}, \sphinxstrong{const} unsigned long \&\sphinxstyleemphasis{y}, char *\sphinxstyleemphasis{value}, \sphinxstrong{const} double \&\sphinxstyleemphasis{t}}{}%
\pysigstopmultiline
Overloaded function for setting the (double) value of a matrix based on the template type of the matrix. This appears like a bit of a goofy workaround and there might be a better way of doing this, but it works. 

\begin{description}
\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{x}: the x index. 

\item {} 
\sphinxcode{y}: the y index. 

\item {} 
\sphinxcode{value}: the value to set 

\item {} 
\sphinxcode{t}: the template class (passed to the function). 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{Matrix::setValue (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_class_Matrix:_CPPv2N6Matrix8setValueERKmRKmPcRKc}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{Exhaled/exhale_class_Matrix:NECSimclass_matrix_1ac742681e44a0b08c105ce7c16047ee20}}\pysiglinewithargsret{void \sphinxbfcode{setValue}}{\sphinxstrong{const} unsigned long \&\sphinxstyleemphasis{x}, \sphinxstrong{const} unsigned long \&\sphinxstyleemphasis{y}, char *\sphinxstyleemphasis{value}, \sphinxstrong{const} char \&\sphinxstyleemphasis{t}}{}%
\pysigstopmultiline
Overloaded function for setting the (char) value of a matrix based on the template type of the matrix. This appears like a bit of a goofy workaround and there might be a better way of doing this, but it works. Note this version of the function has not been properly tested and is included for compilation purposes only. 

\begin{description}
\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{x}: the x index. 

\item {} 
\sphinxcode{y}: the y index. 

\item {} 
\sphinxcode{value}: the value to set 

\item {} 
\sphinxcode{t}: the template class (passed to the function). 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{Matrix::setValue (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_class_Matrix:_CPPv2N6Matrix8setValueERKmRKmPcRK6int8_t}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{Exhaled/exhale_class_Matrix:NECSimclass_matrix_1ad9c05b3b70a1d2cbde0da69d9c509b28}}\pysiglinewithargsret{void \sphinxbfcode{setValue}}{\sphinxstrong{const} unsigned long \&\sphinxstyleemphasis{x}, \sphinxstrong{const} unsigned long \&\sphinxstyleemphasis{y}, char *\sphinxstyleemphasis{value}, \sphinxstrong{const} int8\_t \&\sphinxstyleemphasis{t}}{}%
\pysigstopmultiline
Overloaded function for setting the (int8\_t) value of a matrix based on the template type of the matrix. This appears like a bit of a goofy workaround and there might be a better way of doing this, but it works. Note this version of the function has not been properly tested and is included for compilation purposes only. 

\begin{description}
\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{x}: the x index. 

\item {} 
\sphinxcode{y}: the y index. 

\item {} 
\sphinxcode{value}: the value to set 

\item {} 
\sphinxcode{t}: the template class (passed to the function). 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{Matrix::setValue (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_class_Matrix:_CPPv2N6Matrix8setValueERKmRKmPcRK7uint8_t}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{Exhaled/exhale_class_Matrix:NECSimclass_matrix_1a8e6de70fe02f240a62ec9cc1fd81dcc6}}\pysiglinewithargsret{void \sphinxbfcode{setValue}}{\sphinxstrong{const} unsigned long \&\sphinxstyleemphasis{x}, \sphinxstrong{const} unsigned long \&\sphinxstyleemphasis{y}, char *\sphinxstyleemphasis{value}, \sphinxstrong{const} uint8\_t \&\sphinxstyleemphasis{t}}{}%
\pysigstopmultiline
Overloaded function for setting the (uint8\_t) value of a matrix based on the template type of the matrix. This appears like a bit of a goofy workaround and there might be a better way of doing this, but it works. Note this version of the function has not been properly tested and is included for compilation purposes only. 

\begin{description}
\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{x}: the x index. 

\item {} 
\sphinxcode{y}: the y index. 

\item {} 
\sphinxcode{value}: the value to set 

\item {} 
\sphinxcode{t}: the template class (passed to the function). 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{Matrix::setValue (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_class_Matrix:_CPPv2N6Matrix8setValueERKmRKmPcRKb}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{Exhaled/exhale_class_Matrix:NECSimclass_matrix_1a922762fa2b44b243ae23c9a009f1d097}}\pysiglinewithargsret{void \sphinxbfcode{setValue}}{\sphinxstrong{const} unsigned long \&\sphinxstyleemphasis{x}, \sphinxstrong{const} unsigned long \&\sphinxstyleemphasis{y}, char *\sphinxstyleemphasis{value}, \sphinxstrong{const} bool \&\sphinxstyleemphasis{t}}{}%
\pysigstopmultiline
Overloaded function for setting the (integer) value of a matrix based on the template type of the matrix. This appears like a bit of a goofy workaround and there might be a better way of doing this, but it works. 

\begin{description}
\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{x}: the x index. 

\item {} 
\sphinxcode{y}: the y index. 

\item {} 
\sphinxcode{value}: the value to set 

\item {} 
\sphinxcode{t}: the template class (passed to the function). 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{Matrix::setValue (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_class_Matrix:_CPPv2N6Matrix8setValueERKmRKmPcRKm}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{Exhaled/exhale_class_Matrix:NECSimclass_matrix_1a559bd9956b135c07d4b9f4c7b7ab3587}}\pysiglinewithargsret{void \sphinxbfcode{setValue}}{\sphinxstrong{const} unsigned long \&\sphinxstyleemphasis{x}, \sphinxstrong{const} unsigned long \&\sphinxstyleemphasis{y}, char *\sphinxstyleemphasis{value}, \sphinxstrong{const} unsigned long \&\sphinxstyleemphasis{t}}{}%
\pysigstopmultiline
Overloaded function for setting the (unsigned long integer) value of a matrix based on the template type of the matrix. This appears like a bit of a goofy workaround and there might be a better way of doing this, but it works. 

\begin{description}
\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{x}: the x index. 

\item {} 
\sphinxcode{y}: the y index. 

\item {} 
\sphinxcode{value}: the value to set 

\item {} 
\sphinxcode{t}: the template class (passed to the function). 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{Matrix::setValue (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_class_Matrix:_CPPv2N6Matrix8setValueERKmRKmPcRKl}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{Exhaled/exhale_class_Matrix:NECSimclass_matrix_1a143c4e675168a714dfb039e142cb9623}}\pysiglinewithargsret{void \sphinxbfcode{setValue}}{\sphinxstrong{const} unsigned long \&\sphinxstyleemphasis{x}, \sphinxstrong{const} unsigned long \&\sphinxstyleemphasis{y}, char *\sphinxstyleemphasis{value}, \sphinxstrong{const} long \&\sphinxstyleemphasis{t}}{}%
\pysigstopmultiline
Overloaded function for setting the (long integer) value of a matrix based on the template type of the matrix. This appears like a bit of a goofy workaround and there might be a better way of doing this, but it works. 

\begin{description}
\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{x}: the x index. 

\item {} 
\sphinxcode{y}: the y index. 

\item {} 
\sphinxcode{value}: the value to set 

\item {} 
\sphinxcode{t}: the template class (passed to the function). 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{Matrix::import (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_class_Matrix:_CPPv2N6Matrix6importE6string}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{Exhaled/exhale_class_Matrix:NECSimclass_matrix_1ad52cb35470afb7a524e825b586cc2ccb}}\pysiglinewithargsret{void \sphinxbfcode{import}}{string \sphinxstyleemphasis{filename}}{}%
\pysigstopmultiline
Imports the matrix from either a csv or tif file. Calls either {\hyperref[\detokenize{Exhaled/exhale_class_Matrix:NECSimclass_matrix_1ace5dbaac7d1be865b2f366bfe8896a41}]{\sphinxcrossref{\DUrole{std,std-ref}{importCsv()}}}} or importTif() dependent on the provided file type. 

\begin{description}
\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{filename}: the file to import. 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{Matrix::importCsv (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_class_Matrix:_CPPv2N6Matrix9importCsvE6string}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{Exhaled/exhale_class_Matrix:NECSimclass_matrix_1ace5dbaac7d1be865b2f366bfe8896a41}}\pysiglinewithargsret{void \sphinxbfcode{importCsv}}{string \sphinxstyleemphasis{filename}}{}%
\pysigstopmultiline
Imports the matrix from a tif file using the gdal library functions. 

\begin{description}
\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{filename}: the path to the file to import. Imports the matrix from a csv file using the fast-csv-parser method. 

\item {} 
\sphinxcode{filename}: the path to the file to import. Imports the matrix from a csv file using the standard, slower method. 

\end{itemize}

\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{filename}: the path to the file to import. 

\end{itemize}

\end{description}


\end{fulllineitems}

\paragraph{Protected Attributes}
\index{Matrix::numCols (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_class_Matrix:_CPPv2N6Matrix7numColsE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{Exhaled/exhale_class_Matrix:NECSimclass_matrix_1a341aaedcfaac978957087bd0467dc527}}unsigned long \sphinxbfcode{numCols}}%
\pysigstopmultiline
\end{fulllineitems}

\index{Matrix::numRows (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_class_Matrix:_CPPv2N6Matrix7numRowsE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{Exhaled/exhale_class_Matrix:NECSimclass_matrix_1ac1e96667d48c7845708f978ddd17475d}}unsigned long \sphinxbfcode{numRows}}%
\pysigstopmultiline
\end{fulllineitems}

\index{Matrix::matrix (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_class_Matrix:_CPPv2N6Matrix6matrixE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{Exhaled/exhale_class_Matrix:NECSimclass_matrix_1a7a143ae112112155c9622ba17dc434c7}}{\hyperref[\detokenize{Exhaled/exhale_class_Row:_CPPv23Row}]{\sphinxcrossref{Row}}}\textless{}T\textgreater{} *\sphinxbfcode{matrix}}%
\pysigstopmultiline
\end{fulllineitems}

\paragraph{Friends}
\index{operator\textless{}\textless{} (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_class_Matrix:_CPPv2lsR7ostreamRK6Matrix}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{Exhaled/exhale_class_Matrix:NECSimclass_matrix_1a5ed9a90fd6f010e7e9840a17d92d5361}}\pysiglinewithargsret{ostream \&\sphinxbfcode{operator\textless{}\textless{}}}{ostream \&\sphinxstyleemphasis{os}, \sphinxstrong{const} {\hyperref[\detokenize{Exhaled/exhale_class_Matrix:_CPPv26Matrix}]{\sphinxcrossref{Matrix}}} \&\sphinxstyleemphasis{m}}{}%
\pysigstopmultiline
Overloading the \textless{}\textless{} operator for outputting to an output stream. This can be used for writing to console or storing to file. 

\begin{description}
\item[{\sphinxstylestrong{Return}}] \leavevmode
the output stream. 

\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{os}: the output stream. 

\item {} 
\sphinxcode{m}: the matrix to output. 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{operator\textgreater{}\textgreater{} (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_class_Matrix:_CPPv2rsR7istreamR6Matrix}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{Exhaled/exhale_class_Matrix:NECSimclass_matrix_1afcea9fa7d9a5052070fe1fda963ef237}}\pysiglinewithargsret{istream \&\sphinxbfcode{operator\textgreater{}\textgreater{}}}{istream \&\sphinxstyleemphasis{is}, {\hyperref[\detokenize{Exhaled/exhale_class_Matrix:_CPPv26Matrix}]{\sphinxcrossref{Matrix}}} \&\sphinxstyleemphasis{m}}{}%
\pysigstopmultiline
Overloading the \textgreater{}\textgreater{} operator for inputting from an input stream. This can be used for writing to console or storing to file. 

\begin{description}
\item[{\sphinxstylestrong{Return}}] \leavevmode
the input stream. 

\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{is}: the input stream. 

\item {} 
\sphinxcode{m}: the matrix to input to. 

\end{itemize}

\end{description}


\end{fulllineitems}


\end{fulllineitems}



\paragraph{Class NRrand}
\label{\detokenize{Exhaled/exhale_class_NRrand:class-nrrand}}\label{\detokenize{Exhaled/exhale_class_NRrand::doc}}\label{\detokenize{Exhaled/exhale_class_NRrand:id1}}\begin{itemize}
\item {} 
Defined in {\hyperref[\detokenize{Exhaled/exhale_file_Fattaildeviate.h:file-fattaildeviate-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File Fattaildeviate.h}}}}

\end{itemize}
\index{NRrand (C++ class)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_class_NRrand:_CPPv26NRrand}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{Exhaled/exhale_class_NRrand:NECSimclass_n_rrand}}\pysigline{\sphinxstrong{class }\sphinxcode{}\sphinxbfcode{NRrand}}%
\pysigstopmultiline
Contains the functions for random number generation. 
\paragraph{Public Functions}
\index{NRrand::NRrand (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_class_NRrand:_CPPv2N6NRrand6NRrandEv}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{Exhaled/exhale_class_NRrand:NECSimclass_n_rrand_1a674521c4c29a6cb692f343ea9cf6a40c}}\pysiglinewithargsret{\sphinxbfcode{NRrand}}{}{}%
\pysigstopmultiline
Standard constructor. 

\end{fulllineitems}

\index{NRrand::setSeed (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_class_NRrand:_CPPv2N6NRrand7setSeedEl}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{Exhaled/exhale_class_NRrand:NECSimclass_n_rrand_1a23325b4d35ee0b5b580726db05e2b8a3}}\pysiglinewithargsret{void \sphinxbfcode{setSeed}}{long \sphinxstyleemphasis{seed}}{}%
\pysigstopmultiline
Sets the seed to the given input. Is only seeded if the seed hasn't already been provided. 

\begin{description}
\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{seed}: the input seed. 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{NRrand::d01 (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_class_NRrand:_CPPv2N6NRrand3d01Ev}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{Exhaled/exhale_class_NRrand:NECSimclass_n_rrand_1a0043ba1c33b3dcb3b98210fb432f9f6c}}\pysiglinewithargsret{double \sphinxbfcode{d01}}{}{}%
\pysigstopmultiline
The random number generator. Uses Schrage's method and a shuffle table to generate the output. 

\begin{description}
\item[{\sphinxstylestrong{Return}}] \leavevmode
the random number (a double between 0 and 1). 

\end{description}


\end{fulllineitems}

\index{NRrand::i0 (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_class_NRrand:_CPPv2N6NRrand2i0El}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{Exhaled/exhale_class_NRrand:NECSimclass_n_rrand_1a68fb3474c8f51ef5c61adf2cc499c61c}}\pysiglinewithargsret{long \sphinxbfcode{i0}}{long \sphinxstyleemphasis{max}}{}%
\pysigstopmultiline
Generates a random number uniformly from 0 to the maximum value provided. 

\begin{description}
\item[{\sphinxstylestrong{Return}}] \leavevmode
an integer of the produced random number. 

\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{max}: the maximum number. 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{NRrand::norm (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_class_NRrand:_CPPv2N6NRrand4normEv}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{Exhaled/exhale_class_NRrand:NECSimclass_n_rrand_1aa57a6e9bae94c2df5a00473ba6fa900d}}\pysiglinewithargsret{double \sphinxbfcode{norm}}{}{}%
\pysigstopmultiline
Generates a normally distributed number Uses the standard normal distribution. 

\begin{description}
\item[{\sphinxstylestrong{Return}}] \leavevmode
the random number from a normal distribution. 

\end{description}


\end{fulllineitems}

\index{NRrand::setDispersalParams (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_class_NRrand:_CPPv2N6NRrand18setDispersalParamsEdd}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{Exhaled/exhale_class_NRrand:NECSimclass_n_rrand_1a23e46ac2b0294dc59b8cc95f3ffe7ae1}}\pysiglinewithargsret{void \sphinxbfcode{setDispersalParams}}{double \sphinxstyleemphasis{zfatin}, double \sphinxstyleemphasis{dLvaluein}}{}%
\pysigstopmultiline
Sets the dispersal parameters, avoiding requirement to provide these numbers each function call. This is only relevant for fat-tailed dispersal calls. 

\begin{description}
\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{zfatin}: the fatness of the fat-tailed dispersal kernel. 

\item {} 
\sphinxcode{dLvaluein}: the width of the fat-tailed dispersal kernel. 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{NRrand::fattail (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_class_NRrand:_CPPv2N6NRrand7fattailEd}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{Exhaled/exhale_class_NRrand:NECSimclass_n_rrand_1a464101f3def678477f9156d0bd1aab54}}\pysiglinewithargsret{double \sphinxbfcode{fattail}}{double \sphinxstyleemphasis{z}}{}%
\pysigstopmultiline
Call from the fat-tailed dispersal kernel with the provided zfat. This is the original version. 

\begin{description}
\item[{\sphinxstylestrong{Return}}] \leavevmode
a random number drawn from the fat-tailed dispersal kernel. 

\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{z}: the desired zfat. 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{NRrand::fattail (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_class_NRrand:_CPPv2N6NRrand7fattailEv}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{Exhaled/exhale_class_NRrand:NECSimclass_n_rrand_1a3ec8aae87ae486ddfb5ad481a7972c27}}\pysiglinewithargsret{double \sphinxbfcode{fattail}}{}{}%
\pysigstopmultiline
Call from fat-tailed dispersal kernel. This function requires {\hyperref[\detokenize{Exhaled/exhale_class_NRrand:NECSimclass_n_rrand_1a23e46ac2b0294dc59b8cc95f3ffe7ae1}]{\sphinxcrossref{\DUrole{std,std-ref}{setDispersalParams()}}}} has already been called. 

\begin{description}
\item[{\sphinxstylestrong{Return}}] \leavevmode
a random number drawn from the fat-tailed dispersal kernel. 

\end{description}


\end{fulllineitems}

\index{NRrand::direction (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_class_NRrand:_CPPv2N6NRrand9directionEv}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{Exhaled/exhale_class_NRrand:NECSimclass_n_rrand_1aef021289f62893215204589af450bf65}}\pysiglinewithargsret{double \sphinxbfcode{direction}}{}{}%
\pysigstopmultiline
An old direction-producing function. 

\begin{description}
\item[{\sphinxstylestrong{Return}}] \leavevmode
the direction. 

\end{description}


\end{fulllineitems}

\index{NRrand::event (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_class_NRrand:_CPPv2N6NRrand5eventEd}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{Exhaled/exhale_class_NRrand:NECSimclass_n_rrand_1a4a28ef1e508296a5a85b435f8005d9f7}}\pysiglinewithargsret{bool \sphinxbfcode{event}}{double \sphinxstyleemphasis{probin}}{}%
\pysigstopmultiline
For a given event probability, returns the probability that the event has occured. 

\begin{description}
\item[{\sphinxstylestrong{Return}}] \leavevmode
whether or not the event has occured. 

\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{probin}: the event probability. 

\end{itemize}

\end{description}


\end{fulllineitems}

\paragraph{Friends}
\index{operator\textless{}\textless{} (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_class_NRrand:_CPPv2lsR7ostreamRK6NRrand}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{Exhaled/exhale_class_NRrand:NECSimclass_n_rrand_1a604ebc1c878ab63df21e123dbd34185f}}\pysiglinewithargsret{ostream \&\sphinxbfcode{operator\textless{}\textless{}}}{ostream \&\sphinxstyleemphasis{os}, \sphinxstrong{const} {\hyperref[\detokenize{Exhaled/exhale_class_NRrand:_CPPv26NRrand}]{\sphinxcrossref{NRrand}}} \&\sphinxstyleemphasis{r}}{}%
\pysigstopmultiline
Outputs the {\hyperref[\detokenize{Exhaled/exhale_class_NRrand:NECSimclass_n_rrand}]{\sphinxcrossref{\DUrole{std,std-ref}{NRrand}}}} object to the output stream. Used for saving the object to file. 

\begin{description}
\item[{\sphinxstylestrong{Return}}] \leavevmode
the output stream. 

\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{os}: the output stream. 

\item {} 
\sphinxcode{r}: the {\hyperref[\detokenize{Exhaled/exhale_class_NRrand:NECSimclass_n_rrand}]{\sphinxcrossref{\DUrole{std,std-ref}{NRrand}}}} object to output. 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{operator\textgreater{}\textgreater{} (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_class_NRrand:_CPPv2rsR7istreamR6NRrand}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{Exhaled/exhale_class_NRrand:NECSimclass_n_rrand_1a0b8544414e90bb92ba90afa881b1f06e}}\pysiglinewithargsret{istream \&\sphinxbfcode{operator\textgreater{}\textgreater{}}}{istream \&\sphinxstyleemphasis{is}, {\hyperref[\detokenize{Exhaled/exhale_class_NRrand:_CPPv26NRrand}]{\sphinxcrossref{NRrand}}} \&\sphinxstyleemphasis{r}}{}%
\pysigstopmultiline
Inputs the {\hyperref[\detokenize{Exhaled/exhale_class_NRrand:NECSimclass_n_rrand}]{\sphinxcrossref{\DUrole{std,std-ref}{NRrand}}}} object from the input stream. Used for reading the {\hyperref[\detokenize{Exhaled/exhale_class_NRrand:NECSimclass_n_rrand}]{\sphinxcrossref{\DUrole{std,std-ref}{NRrand}}}} object from a file. 

\begin{description}
\item[{\sphinxstylestrong{Return}}] \leavevmode
the input stream. 

\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{is}: the input stream. 

\item {} 
\sphinxcode{r}: the {\hyperref[\detokenize{Exhaled/exhale_class_NRrand:NECSimclass_n_rrand}]{\sphinxcrossref{\DUrole{std,std-ref}{NRrand}}}} object to input to. 

\end{itemize}

\end{description}


\end{fulllineitems}


\end{fulllineitems}



\paragraph{Class Row}
\label{\detokenize{Exhaled/exhale_class_Row::doc}}\label{\detokenize{Exhaled/exhale_class_Row:class-row}}\label{\detokenize{Exhaled/exhale_class_Row:id1}}\begin{itemize}
\item {} 
Defined in {\hyperref[\detokenize{Exhaled/exhale_file_Matrix.h:file-matrix-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File Matrix.h}}}}

\end{itemize}
\index{Row (C++ class)}

\begin{fulllineitems}
\pysigline{\phantomsection\label{\detokenize{Exhaled/exhale_class_Row:NECSimclass_row}}\sphinxstrong{template }\textless{}class \sphinxstyleemphasis{T}\textgreater{}}\phantomsection\label{\detokenize{Exhaled/exhale_class_Row:_CPPv23Row}}%
\pysigstartmultiline
\pysigline{\sphinxstrong{class }\sphinxcode{}\sphinxbfcode{Row}}%
\pysigstopmultiline
Contains a tempate {\hyperref[\detokenize{Exhaled/exhale_class_Row:NECSimclass_row}]{\sphinxcrossref{\DUrole{std,std-ref}{Row}}}} class and basic operations. Uses an array to store the row. 
\paragraph{Public Functions}
\index{Row::Row (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_class_Row:_CPPv2N3Row3RowEi}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{Exhaled/exhale_class_Row:NECSimclass_row_1ac1d1a6e8c44d33b4b24db1949fc89572}}\pysiglinewithargsret{\sphinxbfcode{Row}}{int \sphinxstyleemphasis{cols} = 0}{}%
\pysigstopmultiline
Standard constructor. 

\begin{description}
\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{cols}: optionally provide the number of rows to initiate with. 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{Row::\textasciitilde{}Row (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_class_Row:_CPPv2N3RowD0Ev}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{Exhaled/exhale_class_Row:NECSimclass_row_1a8e888a33060156cd2e3757a95e9feee1}}\pysiglinewithargsret{\sphinxbfcode{\textasciitilde{}Row}}{}{}%
\pysigstopmultiline
Standard destructor. 

\end{fulllineitems}

\index{Row::Row (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_class_Row:_CPPv2N3Row3RowERK3Row}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{Exhaled/exhale_class_Row:NECSimclass_row_1a3c76905ddd4522c92da0d8a9e24a22a1}}\pysiglinewithargsret{\sphinxbfcode{Row}}{\sphinxstrong{const} {\hyperref[\detokenize{Exhaled/exhale_class_Row:_CPPv2N3Row3RowEi}]{\sphinxcrossref{Row}}} \&\sphinxstyleemphasis{r}}{}%
\pysigstopmultiline
Copy constructor. 

\begin{description}
\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{r}: the {\hyperref[\detokenize{Exhaled/exhale_class_Row:NECSimclass_row}]{\sphinxcrossref{\DUrole{std,std-ref}{Row}}}} object to copy from. 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{Row::SetRowSize (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_class_Row:_CPPv2N3Row10SetRowSizeEm}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{Exhaled/exhale_class_Row:NECSimclass_row_1a1d40c45a688cb831eb642cc1790469a2}}\pysiglinewithargsret{void \sphinxbfcode{SetRowSize}}{unsigned long \sphinxstyleemphasis{n}}{}%
\pysigstopmultiline
Setter for the row size. 

\begin{description}
\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{n}: the number of rows to initiate with. {\hyperref[\detokenize{Exhaled/exhale_class_Row:NECSimclass_row_1a1d40c45a688cb831eb642cc1790469a2}]{\sphinxcrossref{\DUrole{std,std-ref}{SetRowSize()}}}} deletes any old data, and allocates space for new data, unless we set the number of columns to 0, in which case it merely deletes the data. This lets us use this function for construction, destruction, and dynamic modification in one method. 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{Row::changeSize (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_class_Row:_CPPv2N3Row10changeSizeEm}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{Exhaled/exhale_class_Row:NECSimclass_row_1a6a19d7810876be81ad91cdb779b0d9a9}}\pysiglinewithargsret{void \sphinxbfcode{changeSize}}{unsigned long \sphinxstyleemphasis{n}}{}%
\pysigstopmultiline
Changes the size of the array. 

\begin{description}
\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{n}: the new size to change to. Note that no checks are performed that the new row size is larger than the old row size. Thus is this function is used to shrink the row size, a bad\_alloc error will likely be thrown. 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{Row::size (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_class_Row:_CPPv2N3Row4sizeEv}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{Exhaled/exhale_class_Row:NECSimclass_row_1a5fdbcb2478b0ff00d12b8b109b0eb89a}}\pysiglinewithargsret{unsigned long \sphinxbfcode{size}}{}{}%
\pysigstopmultiline
Getter for the size of the array. 

\begin{description}
\item[{\sphinxstylestrong{Return}}] \leavevmode
the number of columns. 

\end{description}


\end{fulllineitems}

\index{Row::operator{[}{]} (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_class_Row:_CPPv2N3RowixEm}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{Exhaled/exhale_class_Row:NECSimclass_row_1aecb642c8ceffbb7d6c69bc13d9de4bb0}}\pysiglinewithargsret{T \&\sphinxbfcode{operator{[}{]}}}{unsigned long \sphinxstyleemphasis{column}}{}%
\pysigstopmultiline
Overloading the {[}{]} operator to allow for simple referencing. 

\begin{description}
\item[{\sphinxstylestrong{Return}}] \leavevmode
the value in the specified column. Note that different versions deal with values outside of (0,numCols) in different ways. 

\item[{\sphinxstylestrong{Note}}] \leavevmode
updated to throw an out\_of\_range exception if the column is out of the row range. 

\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{column}: the column to get the value from. 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{Row::operator= (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_class_Row:_CPPv2N3RowaSERK3Row}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{Exhaled/exhale_class_Row:NECSimclass_row_1a877484e061eef2a179cc28d30b3ec542}}\pysiglinewithargsret{{\hyperref[\detokenize{Exhaled/exhale_class_Row:_CPPv23Row}]{\sphinxcrossref{Row}}} \&\sphinxbfcode{operator=}}{\sphinxstrong{const} {\hyperref[\detokenize{Exhaled/exhale_class_Row:_CPPv23Row}]{\sphinxcrossref{Row}}} \&\sphinxstyleemphasis{r}}{}%
\pysigstopmultiline
Overloading the = operator to allow for copying data across. 

\begin{description}
\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{r}: the {\hyperref[\detokenize{Exhaled/exhale_class_Row:NECSimclass_row}]{\sphinxcrossref{\DUrole{std,std-ref}{Row}}}} object to copy data from. 

\end{itemize}

\end{description}


\end{fulllineitems}

\paragraph{Friends}
\index{operator\textless{}\textless{} (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_class_Row:_CPPv2lsR7ostreamRK3Row}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{Exhaled/exhale_class_Row:NECSimclass_row_1a8aaaee73ace04bfd4dda937bc311a16e}}\pysiglinewithargsret{ostream \&\sphinxbfcode{operator\textless{}\textless{}}}{ostream \&\sphinxstyleemphasis{os}, \sphinxstrong{const} {\hyperref[\detokenize{Exhaled/exhale_class_Row:_CPPv23Row}]{\sphinxcrossref{Row}}} \&\sphinxstyleemphasis{r}}{}%
\pysigstopmultiline
Overloading the \textless{}\textless{} operator for outputting to the output stream. 

\begin{description}
\item[{\sphinxstylestrong{Return}}] \leavevmode
os the output stream. 

\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{os}: the output stream. 

\item {} 
\sphinxcode{r}: the {\hyperref[\detokenize{Exhaled/exhale_class_Row:NECSimclass_row}]{\sphinxcrossref{\DUrole{std,std-ref}{Row}}}} object to output from. 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{operator\textgreater{}\textgreater{} (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_class_Row:_CPPv2rsR7istreamR3Row}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{Exhaled/exhale_class_Row:NECSimclass_row_1adaa9bd295e9b13a99d9205911763468c}}\pysiglinewithargsret{istream \&\sphinxbfcode{operator\textgreater{}\textgreater{}}}{istream \&\sphinxstyleemphasis{is}, {\hyperref[\detokenize{Exhaled/exhale_class_Row:_CPPv23Row}]{\sphinxcrossref{Row}}} \&\sphinxstyleemphasis{r}}{}%
\pysigstopmultiline
Overloading the \textless{}\textless{} operator for inputting from an input stream. 

\begin{description}
\item[{\sphinxstylestrong{Return}}] \leavevmode
the input stream. 

\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{is}: the input stream. 

\item {} 
\sphinxcode{r}: the {\hyperref[\detokenize{Exhaled/exhale_class_Row:NECSimclass_row}]{\sphinxcrossref{\DUrole{std,std-ref}{Row}}}} object to input to. 

\end{itemize}

\end{description}


\end{fulllineitems}


\end{fulllineitems}



\paragraph{Class Samplematrix}
\label{\detokenize{Exhaled/exhale_class_Samplematrix::doc}}\label{\detokenize{Exhaled/exhale_class_Samplematrix:class-samplematrix}}\label{\detokenize{Exhaled/exhale_class_Samplematrix:id1}}\begin{itemize}
\item {} 
Defined in {\hyperref[\detokenize{Exhaled/exhale_file_Treelist.h:file-treelist-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File Treelist.h}}}}

\end{itemize}
\index{Samplematrix (C++ class)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_class_Samplematrix:_CPPv212Samplematrix}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{Exhaled/exhale_class_Samplematrix:NECSimclass_samplematrix}}\pysigline{\sphinxstrong{class }\sphinxcode{}\sphinxbfcode{Samplematrix}}%
\pysigstopmultiline
A child of the {\hyperref[\detokenize{Exhaled/exhale_class_Matrix:NECSimclass_matrix}]{\sphinxcrossref{\DUrole{std,std-ref}{Matrix}}}} class as booleans. Used for determining where to sample species from. 

Inherits from {\hyperref[\detokenize{Exhaled/exhale_class_Matrix:NECSimclass_matrix}]{\sphinxcrossref{\DUrole{std,std-ref}{Matrix\textless{} bool \textgreater{}}}}}
\paragraph{Public Functions}
\index{Samplematrix::Samplematrix (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_class_Samplematrix:_CPPv2N12Samplematrix12SamplematrixEv}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{Exhaled/exhale_class_Samplematrix:NECSimclass_samplematrix_1abe3fb4ca1e24678f2720f451cee80492}}\pysiglinewithargsret{\sphinxbfcode{Samplematrix}}{}{}%
\pysigstopmultiline
Inherit construction from the {\hyperref[\detokenize{Exhaled/exhale_class_Matrix:NECSimclass_matrix}]{\sphinxcrossref{\DUrole{std,std-ref}{Matrix}}}} class, but also set the booleans. 

\end{fulllineitems}

\index{Samplematrix::setIsNull (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_class_Samplematrix:_CPPv2N12Samplematrix9setIsNullEb}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{Exhaled/exhale_class_Samplematrix:NECSimclass_samplematrix_1ac983c4f86579ed522de98bc1d0bfa3d6}}\pysiglinewithargsret{void \sphinxbfcode{setIsNull}}{bool \sphinxstyleemphasis{b}}{}%
\pysigstopmultiline
Checks whether the object is defined as null or not. 

\begin{description}
\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{b}: the boolean to set 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{Samplematrix::getIsNull (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_class_Samplematrix:_CPPv2N12Samplematrix9getIsNullEv}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{Exhaled/exhale_class_Samplematrix:NECSimclass_samplematrix_1a2c893703e39fa5c167e67ec91d544ade}}\pysiglinewithargsret{bool \sphinxbfcode{getIsNull}}{}{}%
\pysigstopmultiline
Getter for the null boolean. 

\begin{description}
\item[{\sphinxstylestrong{Return}}] \leavevmode
the null boolean. 

\end{description}


\end{fulllineitems}

\index{Samplematrix::getTestVal (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_class_Samplematrix:_CPPv2N12Samplematrix10getTestValEjj}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{Exhaled/exhale_class_Samplematrix:NECSimclass_samplematrix_1a5d6d2b3611d8438a61229624dcbe9b88}}\pysiglinewithargsret{bool \sphinxbfcode{getTestVal}}{unsigned int \sphinxstyleemphasis{xval}, unsigned int \sphinxstyleemphasis{yval}}{}%
\pysigstopmultiline
Returns the value at the x,y position. This is used for testing purposes only. 

\begin{description}
\item[{\sphinxstylestrong{Return}}] \leavevmode
the value at x,y. 

\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{xval}: the x coordinate. 

\item {} 
\sphinxcode{yval}: the y coordinate 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{Samplematrix::getVal (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_class_Samplematrix:_CPPv2N12Samplematrix6getValEjj}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{Exhaled/exhale_class_Samplematrix:NECSimclass_samplematrix_1abe43e3d61d1ca7cdfcd2eb1d48895daf}}\pysiglinewithargsret{bool \sphinxbfcode{getVal}}{unsigned int \sphinxstyleemphasis{xval}, unsigned int \sphinxstyleemphasis{yval}}{}%
\pysigstopmultiline
Returns the value at the x,y position. Also checks whether or not the map is set to null, or whether the value comes from within a fragment. 

\begin{description}
\item[{\sphinxstylestrong{Return}}] \leavevmode
the value at x,y. 

\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{xval}: the x coordinate. 

\item {} 
\sphinxcode{yval}: the y coordinate 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{Samplematrix::setFragment (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_class_Samplematrix:_CPPv2N12Samplematrix11setFragmentE8Fragment}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{Exhaled/exhale_class_Samplematrix:NECSimclass_samplematrix_1a864f4e7c7e1b413909ac3db943469439}}\pysiglinewithargsret{void \sphinxbfcode{setFragment}}{{\hyperref[\detokenize{Exhaled/exhale_struct_Fragment:_CPPv28Fragment}]{\sphinxcrossref{Fragment}}} \sphinxstyleemphasis{fragment\_in}}{}%
\pysigstopmultiline
Set the fragment for the samplemask to some calculated fragment. This can be set multiple times. 

\begin{description}
\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{fragment\_in}: the {\hyperref[\detokenize{Exhaled/exhale_struct_Fragment:NECSimstruct_fragment}]{\sphinxcrossref{\DUrole{std,std-ref}{Fragment}}}} to set the samplemask to. 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{Samplematrix::removeFragment (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_class_Samplematrix:_CPPv2N12Samplematrix14removeFragmentEv}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{Exhaled/exhale_class_Samplematrix:NECSimclass_samplematrix_1a9b796f2279f1716c2a555ff3d641ea0b}}\pysiglinewithargsret{void \sphinxbfcode{removeFragment}}{}{}%
\pysigstopmultiline
Removes the fragment. 

\end{fulllineitems}


\end{fulllineitems}



\paragraph{Class simParameters}
\label{\detokenize{Exhaled/exhale_class_simParameters:class-simparameters}}\label{\detokenize{Exhaled/exhale_class_simParameters::doc}}\label{\detokenize{Exhaled/exhale_class_simParameters:id1}}\begin{itemize}
\item {} 
Defined in {\hyperref[\detokenize{Exhaled/exhale_file_SpeciationCounter.cpp:file-speciationcounter-cpp}]{\sphinxcrossref{\DUrole{std,std-ref}{File SpeciationCounter.cpp}}}}

\end{itemize}
\index{simParameters (C++ class)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_class_simParameters:_CPPv213simParameters}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{Exhaled/exhale_class_simParameters:NECSimstructsim_parameters}}\pysigline{\sphinxstrong{class }\sphinxcode{}\sphinxbfcode{simParameters}}%
\pysigstopmultiline
Contains the simulation parameters that are read from the command line. 
\paragraph{Public Members}
\index{simParameters::RecordSpatial (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_class_simParameters:_CPPv2N13simParameters13RecordSpatialE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{Exhaled/exhale_class_simParameters:NECSimstructsim_parameters_1a2dd19b6ec8367ea41e91017068586fce}}bool \sphinxbfcode{RecordSpatial}}%
\pysigstopmultiline
\end{fulllineitems}

\index{simParameters::bMultiRun (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_class_simParameters:_CPPv2N13simParameters9bMultiRunE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{Exhaled/exhale_class_simParameters:NECSimstructsim_parameters_1a2ac8b45800ecc7e77687098f8798be65}}bool \sphinxbfcode{bMultiRun}}%
\pysigstopmultiline
\end{fulllineitems}

\index{simParameters::RecordFragments (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_class_simParameters:_CPPv2N13simParameters15RecordFragmentsE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{Exhaled/exhale_class_simParameters:NECSimstructsim_parameters_1ac1281067fb4d4bbd94c4b15a9f4f5f6d}}bool \sphinxbfcode{RecordFragments}}%
\pysigstopmultiline
\end{fulllineitems}

\index{simParameters::filename (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_class_simParameters:_CPPv2N13simParameters8filenameE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{Exhaled/exhale_class_simParameters:NECSimstructsim_parameters_1a724bda50314df0894173209511214dff}}string \sphinxbfcode{filename}}%
\pysigstopmultiline
\end{fulllineitems}

\index{simParameters::vSpecRates (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_class_simParameters:_CPPv2N13simParameters10vSpecRatesE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{Exhaled/exhale_class_simParameters:NECSimstructsim_parameters_1ac30808e41a12f850a1de37669c4e02ba}}vector\textless{}double\textgreater{} \sphinxbfcode{vSpecRates}}%
\pysigstopmultiline
\end{fulllineitems}

\index{simParameters::samplemask (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_class_simParameters:_CPPv2N13simParameters10samplemaskE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{Exhaled/exhale_class_simParameters:NECSimstructsim_parameters_1a3f2e2b6f735beecdc903ecd265fc58c0}}string \sphinxbfcode{samplemask}}%
\pysigstopmultiline
\end{fulllineitems}

\index{simParameters::autocorrel\_file (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_class_simParameters:_CPPv2N13simParameters15autocorrel_fileE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{Exhaled/exhale_class_simParameters:NECSimstructsim_parameters_1affddf96b753f29031a72e1d2de36670a}}string \sphinxbfcode{autocorrel\_file}}%
\pysigstopmultiline
\end{fulllineitems}

\index{simParameters::autocorrel\_times (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_class_simParameters:_CPPv2N13simParameters16autocorrel_timesE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{Exhaled/exhale_class_simParameters:NECSimstructsim_parameters_1a6d959cdd8dd2bd1713fcd697d7e32ff2}}vector\textless{}double\textgreater{} \sphinxbfcode{autocorrel\_times}}%
\pysigstopmultiline
\end{fulllineitems}

\index{simParameters::bAuto (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_class_simParameters:_CPPv2N13simParameters5bAutoE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{Exhaled/exhale_class_simParameters:NECSimstructsim_parameters_1ac066a4014816d9fa5a430a1da48f9f79}}bool \sphinxbfcode{bAuto}}%
\pysigstopmultiline
\end{fulllineitems}

\index{simParameters::fragment\_config\_file (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_class_simParameters:_CPPv2N13simParameters20fragment_config_fileE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{Exhaled/exhale_class_simParameters:NECSimstructsim_parameters_1a4ce4580923c1be3eb863eb38d441906e}}string \sphinxbfcode{fragment\_config\_file}}%
\pysigstopmultiline
\end{fulllineitems}


\end{fulllineitems}



\paragraph{Class SpeciesList}
\label{\detokenize{Exhaled/exhale_class_SpeciesList:class-specieslist}}\label{\detokenize{Exhaled/exhale_class_SpeciesList::doc}}\label{\detokenize{Exhaled/exhale_class_SpeciesList:id1}}\begin{itemize}
\item {} 
Defined in {\hyperref[\detokenize{Exhaled/exhale_file_SpeciesList.h:file-specieslist-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File SpeciesList.h}}}}

\end{itemize}
\index{SpeciesList (C++ class)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_class_SpeciesList:_CPPv211SpeciesList}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{Exhaled/exhale_class_SpeciesList:NECSimclass_species_list}}\pysigline{\sphinxstrong{class }\sphinxcode{}\sphinxbfcode{SpeciesList}}%
\pysigstopmultiline
Contains a list of the species that exist at one location. The {\hyperref[\detokenize{Exhaled/exhale_class_Row:NECSimclass_row}]{\sphinxcrossref{\DUrole{std,std-ref}{Row}}}} object, list, contains the active reference number, for looking up the lineage in a {\hyperref[\detokenize{Exhaled/exhale_class_Row:NECSimclass_row}]{\sphinxcrossref{\DUrole{std,std-ref}{Row}}}} of {\hyperref[\detokenize{Exhaled/exhale_class_Datapoint:NECSimclass_datapoint}]{\sphinxcrossref{\DUrole{std,std-ref}{Datapoint}}}} objects. Also contains the functions for correctly generating coalescence probabilities and list management. 

Note that the maximum size of the list is constrained by the maximum size of unsigned short. If problems are encountered with this, a fairly simple process of replacing these procedures with unsigned longs is possible but would increase RAM usage. 
\paragraph{Public Functions}
\index{SpeciesList::SpeciesList (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_class_SpeciesList:_CPPv2N11SpeciesList11SpeciesListEv}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{Exhaled/exhale_class_SpeciesList:NECSimclass_species_list_1a5ebcb2cf12fc4e7a3d8bbd650814a5fb}}\pysiglinewithargsret{\sphinxbfcode{SpeciesList}}{}{}%
\pysigstopmultiline
Default constructor. 

\end{fulllineitems}

\index{SpeciesList::\textasciitilde{}SpeciesList (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_class_SpeciesList:_CPPv2N11SpeciesListD0Ev}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{Exhaled/exhale_class_SpeciesList:NECSimclass_species_list_1a43cfe3bc42ef1729732f988fa690ac59}}\pysiglinewithargsret{\sphinxbfcode{\textasciitilde{}SpeciesList}}{}{}%
\pysigstopmultiline
Default destructor. 

\end{fulllineitems}

\index{SpeciesList::fillList (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_class_SpeciesList:_CPPv2N11SpeciesList8fillListEv}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{Exhaled/exhale_class_SpeciesList:NECSimclass_species_list_1ad617317047f221e64066dd851b9e8d2d}}\pysiglinewithargsret{void \sphinxbfcode{fillList}}{}{}%
\pysigstopmultiline
Fills the list with 0, up to the specified maximum size. 

\end{fulllineitems}

\index{SpeciesList::initialise (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_class_SpeciesList:_CPPv2N11SpeciesList10initialiseEt}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{Exhaled/exhale_class_SpeciesList:NECSimclass_species_list_1a61b8414b9cfc97b410c01b470e246e76}}\pysiglinewithargsret{void \sphinxbfcode{initialise}}{unsigned short \sphinxstyleemphasis{maxsizein}}{}%
\pysigstopmultiline
Initialises the list to the specified size. 

\begin{description}
\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{maxsizein}: the maximum list size. 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{SpeciesList::setMaxsize (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_class_SpeciesList:_CPPv2N11SpeciesList10setMaxsizeEt}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{Exhaled/exhale_class_SpeciesList:NECSimclass_species_list_1ae177e91885cec1c53f2ec5f1b977616b}}\pysiglinewithargsret{void \sphinxbfcode{setMaxsize}}{unsigned short \sphinxstyleemphasis{maxsizein}}{}%
\pysigstopmultiline
Sets the maxsize without altering the actual size of list. 

\begin{description}
\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{maxsizein}: The new maximum size to set. 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{SpeciesList::setSpecies (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_class_SpeciesList:_CPPv2N11SpeciesList10setSpeciesEim}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{Exhaled/exhale_class_SpeciesList:NECSimclass_species_list_1a175f542a92ecd497428ec24488baf4fe}}\pysiglinewithargsret{void \sphinxbfcode{setSpecies}}{int \sphinxstyleemphasis{index}, unsigned long \sphinxstyleemphasis{new\_val}}{}%
\pysigstopmultiline
Set specific entry to a particular species reference number. 

\begin{description}
\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{index}: the location in list of the species. 

\item {} 
\sphinxcode{new\_val}: the new species reference to set list{[}index{]} to. 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{SpeciesList::setNext (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_class_SpeciesList:_CPPv2N11SpeciesList7setNextEm}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{Exhaled/exhale_class_SpeciesList:NECSimclass_species_list_1a627f9d95948f4a2cb6cfb3d8b8f9f2ea}}\pysiglinewithargsret{void \sphinxbfcode{setNext}}{unsigned long \sphinxstyleemphasis{n}}{}%
\pysigstopmultiline
Set the next active lineage (for wrapping purposes). 

\begin{description}
\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{n}: the lineage to set as the first wrapped lineage. 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{SpeciesList::setNwrap (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_class_SpeciesList:_CPPv2N11SpeciesList8setNwrapEt}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{Exhaled/exhale_class_SpeciesList:NECSimclass_species_list_1ae15d196a9cdb202c43e06699edd1406a}}\pysiglinewithargsret{void \sphinxbfcode{setNwrap}}{unsigned short \sphinxstyleemphasis{nr}}{}%
\pysigstopmultiline
Set the number of wrapping lineages. 

\begin{description}
\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{nr}: the number of wrapped lineages. 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{SpeciesList::addSpecies (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_class_SpeciesList:_CPPv2N11SpeciesList10addSpeciesEm}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{Exhaled/exhale_class_SpeciesList:NECSimclass_species_list_1ae4a3fd2cf383f1db91c3df01067a02a5}}\pysiglinewithargsret{unsigned short \sphinxbfcode{addSpecies}}{unsigned long \sphinxstyleemphasis{new\_spec}}{}%
\pysigstopmultiline
Add a new species to the first empty place and return the position of the lineage. 

\begin{description}
\item[{\sphinxstylestrong{Return}}] \leavevmode
the location the species has been added to. 

\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{new\_spec}: the new species reference to place in the first empty space. 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{SpeciesList::addSpeciesSilent (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_class_SpeciesList:_CPPv2N11SpeciesList16addSpeciesSilentEm}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{Exhaled/exhale_class_SpeciesList:NECSimclass_species_list_1af84a5aa6584f16dfb8e8f2ce379cf947}}\pysiglinewithargsret{void \sphinxbfcode{addSpeciesSilent}}{unsigned long \sphinxstyleemphasis{new\_spec}}{}%
\pysigstopmultiline
Add a new species to the first empty place. Essentially a version of {\hyperref[\detokenize{Exhaled/exhale_class_SpeciesList:NECSimclass_species_list_1ae4a3fd2cf383f1db91c3df01067a02a5}]{\sphinxcrossref{\DUrole{std,std-ref}{addSpecies()}}}} without returning the species location. 

\begin{description}
\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{new\_spec}: the new species reference to place in the first empty space. 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{SpeciesList::deleteSpecies (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_class_SpeciesList:_CPPv2N11SpeciesList13deleteSpeciesEi}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{Exhaled/exhale_class_SpeciesList:NECSimclass_species_list_1ad779da97d12aff6a96ff321757c0c0c4}}\pysiglinewithargsret{void \sphinxbfcode{deleteSpecies}}{int \sphinxstyleemphasis{index}}{}%
\pysigstopmultiline
Removes the species at the specified index. The species number will be replaced with 0, indicating no species present. 

Older versions of this function re-shuffled the list so that all species came at the top. \begin{description}
\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{index}: the index of the species to remove from the list. 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{SpeciesList::decreaseNwrap (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_class_SpeciesList:_CPPv2N11SpeciesList13decreaseNwrapEv}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{Exhaled/exhale_class_SpeciesList:NECSimclass_species_list_1a15420717ab0ba00bba0ff55f971ee3d2}}\pysiglinewithargsret{void \sphinxbfcode{decreaseNwrap}}{}{}%
\pysigstopmultiline
Decreases the nwrap by one. 

Indicates the number of species wrapped at the location of this {\hyperref[\detokenize{Exhaled/exhale_class_SpeciesList:NECSimclass_species_list}]{\sphinxcrossref{\DUrole{std,std-ref}{SpeciesList}}}} object has decreased by one. 

\end{fulllineitems}

\index{SpeciesList::increaseNwrap (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_class_SpeciesList:_CPPv2N11SpeciesList13increaseNwrapEv}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{Exhaled/exhale_class_SpeciesList:NECSimclass_species_list_1aa9e64b4e922b43c17e188ca2038cb18a}}\pysiglinewithargsret{void \sphinxbfcode{increaseNwrap}}{}{}%
\pysigstopmultiline
Increases the nwrap by one. 

Indicates the number of species wrapped at the location of this {\hyperref[\detokenize{Exhaled/exhale_class_SpeciesList:NECSimclass_species_list}]{\sphinxcrossref{\DUrole{std,std-ref}{SpeciesList}}}} object has increased by one. 

\end{fulllineitems}

\index{SpeciesList::changePercentCover (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_class_SpeciesList:_CPPv2N11SpeciesList18changePercentCoverEt}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{Exhaled/exhale_class_SpeciesList:NECSimclass_species_list_1a7d5e912082f1bac79eb0e2c74ba3b933}}\pysiglinewithargsret{void \sphinxbfcode{changePercentCover}}{unsigned short \sphinxstyleemphasis{newmaxsize}}{}%
\pysigstopmultiline
Changes the maximum size of the {\hyperref[\detokenize{Exhaled/exhale_class_SpeciesList:NECSimclass_species_list}]{\sphinxcrossref{\DUrole{std,std-ref}{SpeciesList}}}}. Creates a new list object with all the species in the correct place from the old list object and zeros everywhere else. 

\begin{description}
\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{newmaxsize}: the new maximum size to be applied. 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{SpeciesList::getRandLineage (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_class_SpeciesList:_CPPv2N11SpeciesList14getRandLineageER6NRrand}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{Exhaled/exhale_class_SpeciesList:NECSimclass_species_list_1a8e57aa257510bf61680e53c548fd4610}}\pysiglinewithargsret{unsigned long \sphinxbfcode{getRandLineage}}{{\hyperref[\detokenize{Exhaled/exhale_class_NRrand:_CPPv26NRrand}]{\sphinxcrossref{NRrand}}} \&\sphinxstyleemphasis{rand\_no}}{}%
\pysigstopmultiline
Get a random species reference number from all the potential entries. Updated alternative version returns any entry, including empty cells, giving the probability of coalescence as well. 

\begin{description}
\item[{\sphinxstylestrong{Return}}] \leavevmode
the reference of the random lineage. 0 indicates an empty space. 

\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{rand\_no}: the random number object to pass (for maintaining the same seed throughout simulations). 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{SpeciesList::getSpecies (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_class_SpeciesList:_CPPv2N11SpeciesList10getSpeciesEt}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{Exhaled/exhale_class_SpeciesList:NECSimclass_species_list_1abbc425e57d905026ece411f31972001f}}\pysiglinewithargsret{unsigned long \sphinxbfcode{getSpecies}}{unsigned short \sphinxstyleemphasis{index}}{}%
\pysigstopmultiline
Get the species reference number from a particular entry. 

\begin{description}
\item[{\sphinxstylestrong{Return}}] \leavevmode
the species reference at the specified location. 

\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{index}: the location of the species to reference. 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{SpeciesList::getNext (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_class_SpeciesList:_CPPv2N11SpeciesList7getNextEv}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{Exhaled/exhale_class_SpeciesList:NECSimclass_species_list_1ac3fffc2d47557af6964cb25336d0e5cc}}\pysiglinewithargsret{unsigned long \sphinxbfcode{getNext}}{}{}%
\pysigstopmultiline
Get the next\_active variable. 

\begin{description}
\item[{\sphinxstylestrong{Return}}] \leavevmode
the next linked species reference. 

\end{description}


\end{fulllineitems}

\index{SpeciesList::getNwrap (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_class_SpeciesList:_CPPv2N11SpeciesList8getNwrapEv}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{Exhaled/exhale_class_SpeciesList:NECSimclass_species_list_1a398274dd3a9276ffd382d313e3e72873}}\pysiglinewithargsret{unsigned short \sphinxbfcode{getNwrap}}{}{}%
\pysigstopmultiline
Getter for the nwrap. 

\begin{description}
\item[{\sphinxstylestrong{Return}}] \leavevmode
the number of wrapped lineages currently at this grid cell. 

\end{description}


\end{fulllineitems}

\index{SpeciesList::getListsize (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_class_SpeciesList:_CPPv2N11SpeciesList11getListsizeEv}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{Exhaled/exhale_class_SpeciesList:NECSimclass_species_list_1a04d19103f77bbaf30c27d155c60b3f85}}\pysiglinewithargsret{int \sphinxbfcode{getListsize}}{}{}%
\pysigstopmultiline
Getter for the list size. 

\begin{description}
\item[{\sphinxstylestrong{Return}}] \leavevmode
the number of lineages currently directly within the {\hyperref[\detokenize{Exhaled/exhale_class_SpeciesList:NECSimclass_species_list}]{\sphinxcrossref{\DUrole{std,std-ref}{SpeciesList}}}}. 

\end{description}


\end{fulllineitems}

\index{SpeciesList::getMaxsize (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_class_SpeciesList:_CPPv2N11SpeciesList10getMaxsizeEv}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{Exhaled/exhale_class_SpeciesList:NECSimclass_species_list_1a329f1961bc58e76680df8df474314980}}\pysiglinewithargsret{int \sphinxbfcode{getMaxsize}}{}{}%
\pysigstopmultiline
Getter for the maximum size of the {\hyperref[\detokenize{Exhaled/exhale_class_SpeciesList:NECSimclass_species_list}]{\sphinxcrossref{\DUrole{std,std-ref}{SpeciesList}}}} object. 

\begin{description}
\item[{\sphinxstylestrong{Return}}] \leavevmode
the maximum number of lineages that can exist currently. 

\end{description}


\end{fulllineitems}

\index{SpeciesList::wipeList (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_class_SpeciesList:_CPPv2N11SpeciesList8wipeListEv}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{Exhaled/exhale_class_SpeciesList:NECSimclass_species_list_1acd0fd4ab7517523f04d8c37bb918d390}}\pysiglinewithargsret{void \sphinxbfcode{wipeList}}{}{}%
\pysigstopmultiline
Empties the list of any data and fills the list with zeros. 

\end{fulllineitems}

\paragraph{Friends}
\index{operator\textless{}\textless{} (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_class_SpeciesList:_CPPv2lsR7ostreamRK11SpeciesList}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{Exhaled/exhale_class_SpeciesList:NECSimclass_species_list_1a307fffef634cd0a4615794ef7498cd4a}}\pysiglinewithargsret{ostream \&\sphinxbfcode{operator\textless{}\textless{}}}{ostream \&\sphinxstyleemphasis{os}, \sphinxstrong{const} {\hyperref[\detokenize{Exhaled/exhale_class_SpeciesList:_CPPv211SpeciesList}]{\sphinxcrossref{SpeciesList}}} \&\sphinxstyleemphasis{r}}{}%
\pysigstopmultiline
Outputs the {\hyperref[\detokenize{Exhaled/exhale_class_SpeciesList:NECSimclass_species_list}]{\sphinxcrossref{\DUrole{std,std-ref}{SpeciesList}}}} object to an output stream. Allows for piping to the terminal or writing the object to a file. 

\begin{description}
\item[{\sphinxstylestrong{Return}}] \leavevmode
the output stream. 

\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{os}: the output stream. 

\item {} 
\sphinxcode{r}: the {\hyperref[\detokenize{Exhaled/exhale_class_SpeciesList:NECSimclass_species_list}]{\sphinxcrossref{\DUrole{std,std-ref}{SpeciesList}}}} object to output. 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{operator\textgreater{}\textgreater{} (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_class_SpeciesList:_CPPv2rsR7istreamR11SpeciesList}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{Exhaled/exhale_class_SpeciesList:NECSimclass_species_list_1a2d74faa6012ce148a9f437249390c294}}\pysiglinewithargsret{istream \&\sphinxbfcode{operator\textgreater{}\textgreater{}}}{istream \&\sphinxstyleemphasis{is}, {\hyperref[\detokenize{Exhaled/exhale_class_SpeciesList:_CPPv211SpeciesList}]{\sphinxcrossref{SpeciesList}}} \&\sphinxstyleemphasis{r}}{}%
\pysigstopmultiline
Inputs the {\hyperref[\detokenize{Exhaled/exhale_class_SpeciesList:NECSimclass_species_list}]{\sphinxcrossref{\DUrole{std,std-ref}{SpeciesList}}}} object from an input stream. Allows for reading data from a file or string stream. 

\begin{description}
\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{is}: the input stream. 

\item {} 
\sphinxcode{r}: the {\hyperref[\detokenize{Exhaled/exhale_class_SpeciesList:NECSimclass_species_list}]{\sphinxcrossref{\DUrole{std,std-ref}{SpeciesList}}}} object to input to. 

\end{itemize}

\end{description}


\end{fulllineitems}


\end{fulllineitems}



\paragraph{Class Tree}
\label{\detokenize{Exhaled/exhale_class_Tree:class-tree}}\label{\detokenize{Exhaled/exhale_class_Tree::doc}}\label{\detokenize{Exhaled/exhale_class_Tree:id1}}\begin{itemize}
\item {} 
Defined in {\hyperref[\detokenize{Exhaled/exhale_file_Tree.h:file-tree-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File Tree.h}}}}

\end{itemize}
\index{Tree (C++ class)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_class_Tree:_CPPv24Tree}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{Exhaled/exhale_class_Tree:NECSimclass_tree}}\pysigline{\sphinxstrong{class }\sphinxcode{}\sphinxbfcode{Tree}}%
\pysigstopmultiline
Represents the output phylogenetic tree. 

Contains all functions for running simulations, outputting data and calculating coalescence tree structure. 
\paragraph{Public Functions}
\index{Tree::Tree (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_class_Tree:_CPPv2N4Tree4TreeEv}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{Exhaled/exhale_class_Tree:NECSimclass_tree_1ad376a7c639d857312f5de2ef47482f68}}\pysiglinewithargsret{\sphinxbfcode{Tree}}{}{}%
\pysigstopmultiline
The constructor for the tree object. 

Sets all uninitiated variables to false, except log\_all. log\_all should be changed to false if minimal text output during simulations is desired. 

\end{fulllineitems}

\index{Tree::setMapVars (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_class_Tree:_CPPv2N4Tree10setMapVarsE6vectorI6stringEb}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{Exhaled/exhale_class_Tree:NECSimclass_tree_1a0043d87cb60cd89df78a335181585712}}\pysiglinewithargsret{void \sphinxbfcode{setMapVars}}{vector\textless{}string\textgreater{} \sphinxstyleemphasis{comargs}, bool \sphinxstyleemphasis{fullmode}}{}%
\pysigstopmultiline
Sets the map object with the correct variables, taking the {\hyperref[\detokenize{Exhaled/exhale_struct_Mapvars:NECSimstruct_mapvars}]{\sphinxcrossref{\DUrole{std,std-ref}{Mapvars}}}} structure defined elsewhere for the parameters. 

This function can only be run once, otherwise a {\hyperref[\detokenize{Exhaled/exhale_struct_Main_Exception:NECSimstruct_main___exception}]{\sphinxcrossref{\DUrole{std,std-ref}{Main\_Exception}}}} will be thrown

\begin{description}
\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{comargs}: a vector of command-line arguments to be parsed 

\item {} 
\sphinxcode{fullmode}: if true, the simulation is using full command-line flags 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{Tree::getTemporalSampling (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_class_Tree:_CPPv2N4Tree19getTemporalSamplingEv}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{Exhaled/exhale_class_Tree:NECSimclass_tree_1a8147222ac6af4e0d669a5dd439885d7d}}\pysiglinewithargsret{vector\textless{}double\textgreater{} \sphinxbfcode{getTemporalSampling}}{}{}%
\pysigstopmultiline
Gets the map autocorrel times. 

\end{fulllineitems}

\index{Tree::importMaps (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_class_Tree:_CPPv2N4Tree10importMapsEv}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{Exhaled/exhale_class_Tree:NECSimclass_tree_1a8e60e04be160c2d7de0ab1c834e6a95b}}\pysiglinewithargsret{void \sphinxbfcode{importMaps}}{}{}%
\pysigstopmultiline
Imports the maps into the forestmap object. 

The simulation variables should have already been imported by {\hyperref[\detokenize{Exhaled/exhale_class_Tree:NECSimclass_tree_1a0043d87cb60cd89df78a335181585712}]{\sphinxcrossref{\DUrole{std,std-ref}{setMapVars()}}}}, otherwise a {\hyperref[\detokenize{Exhaled/exhale_struct_Fatal_Exception:NECSimstruct_fatal___exception}]{\sphinxcrossref{\DUrole{std,std-ref}{Fatal\_Exception}}}} will be thrown. 

\end{fulllineitems}

\index{Tree::getSeed (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_class_Tree:_CPPv2N4Tree7getSeedEv}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{Exhaled/exhale_class_Tree:NECSimclass_tree_1a857521315ca6bd9b3300d099488d74f1}}\pysiglinewithargsret{long long \sphinxbfcode{getSeed}}{}{}%
\pysigstopmultiline
Getter for the simulation seed. 

\begin{description}
\item[{\sphinxstylestrong{Return}}] \leavevmode
Returns the seeds 

\end{description}


\end{fulllineitems}

\index{Tree::setSeed (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_class_Tree:_CPPv2N4Tree7setSeedEx}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{Exhaled/exhale_class_Tree:NECSimclass_tree_1a65f098693e08e33f039a8797ba57c3e0}}\pysiglinewithargsret{void \sphinxbfcode{setSeed}}{long long \sphinxstyleemphasis{theseedin}}{}%
\pysigstopmultiline
Sets the simulation seed to the provided variable. 

The seed is set within the NR object. This will be fixed for the simulation and is only performed once.

\begin{description}
\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{theseedin}: the desired seed to set for the simulation 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{Tree::randomList (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_class_Tree:_CPPv2N4Tree10randomListEll}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{Exhaled/exhale_class_Tree:NECSimclass_tree_1a033d3e333bd9e335dd1157af6b920edf}}\pysiglinewithargsret{vector\textless{}long\textgreater{} \sphinxbfcode{randomList}}{long \sphinxstyleemphasis{maxnum}, long \sphinxstyleemphasis{numnum}}{}%
\pysigstopmultiline
Deprecated function which generated a random list. 

\begin{description}
\item[{\sphinxstylestrong{Return}}] \leavevmode


\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{maxnum}: 

\item {} 
\sphinxcode{numnum}: 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{Tree::setup (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_class_Tree:_CPPv2N4Tree5setupER6vectorI6stringEb}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{Exhaled/exhale_class_Tree:NECSimclass_tree_1a63960c821daf9d8daec875f2625ae7d6}}\pysiglinewithargsret{void \sphinxbfcode{setup}}{vector\textless{}string\textgreater{} \&\sphinxstyleemphasis{comargs}, bool \sphinxstyleemphasis{fullmode}}{}%
\pysigstopmultiline
The setup function for parsing the command line arguments and generating the simulation objects. 

The simulation parameters are set from comargs using {\hyperref[\detokenize{Exhaled/exhale_class_Tree:NECSimclass_tree_1a0043d87cb60cd89df78a335181585712}]{\sphinxcrossref{\DUrole{std,std-ref}{setMapVars()}}}}. Generates and fills the active and grid objects as well as importing all the maps from the supplied files. {\hyperref[\detokenize{Exhaled/exhale_class_Tree:NECSimclass_tree_1a8e60e04be160c2d7de0ab1c834e6a95b}]{\sphinxcrossref{\DUrole{std,std-ref}{importMaps()}}}} is called for importing the map files



\begin{description}
\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{comargs}: a vector of the command-line arguments which are parsed using {\hyperref[\detokenize{Exhaled/exhale_class_Tree:NECSimclass_tree_1a0043d87cb60cd89df78a335181585712}]{\sphinxcrossref{\DUrole{std,std-ref}{setMapVars()}}}}. 

\item {} 
\sphinxcode{fullmode}: if true, the command line options are fully specified, rather than in the updated condensed form 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{Tree::removeOldPos (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_class_Tree:_CPPv2N4Tree12removeOldPosERKm}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{Exhaled/exhale_class_Tree:NECSimclass_tree_1a351650bda95319b2213c2234fa930f49}}\pysiglinewithargsret{void \sphinxbfcode{removeOldPos}}{\sphinxstrong{const} unsigned long \&\sphinxstyleemphasis{chosen}}{}%
\pysigstopmultiline
Removes the old position within active by checking any wrapping and removing connections. 

The function also corrects the linked list to identify the correct nwrap for every wrapped lineage in that space.

\begin{description}
\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{chosen}: the desired active reference to remove from the grid. 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{Tree::calcMove (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_class_Tree:_CPPv2N4Tree8calcMoveERlRlRlRl}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{Exhaled/exhale_class_Tree:NECSimclass_tree_1a4ea7f044e9a59de344dc7e12cf00e85e}}\pysiglinewithargsret{void \sphinxbfcode{calcMove}}{long \&\sphinxstyleemphasis{oldx}, long \&\sphinxstyleemphasis{oldy}, long \&\sphinxstyleemphasis{oldxwrap}, long \&\sphinxstyleemphasis{oldywrap}}{}%
\pysigstopmultiline
Calculate the move, given a start x,y coordinates and wrapping. 

The provided parameters will be altered to contain the new values so no record of the old variables remains after function running. Current dispersal methods use a fattailed dispersal.

\begin{description}
\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{oldx}: the old x position on the grid 

\item {} 
\sphinxcode{oldy}: the old y position on the grid 

\item {} 
\sphinxcode{oldxwrap}: the old x wrapping 

\item {} 
\sphinxcode{oldywrap}: the old y wrapping 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{Tree::calcMinMax (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_class_Tree:_CPPv2N4Tree10calcMinMaxERKm}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{Exhaled/exhale_class_Tree:NECSimclass_tree_1a70a652ff4273d83e642257e4f5b5dd47}}\pysiglinewithargsret{long double \sphinxbfcode{calcMinMax}}{\sphinxstrong{const} unsigned long \&\sphinxstyleemphasis{current}}{}%
\pysigstopmultiline
Calculates the minmax for a given branch. 

Calculates the speciation rate required for speciation to have occured on this branch.

\begin{description}
\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{current}: the current active reference to perform calculations over. 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{Tree::coalescenceEvent (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_class_Tree:_CPPv2N4Tree16coalescenceEventERKmRm}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{Exhaled/exhale_class_Tree:NECSimclass_tree_1a16eedb70009e7570d933f88e8ce44117}}\pysiglinewithargsret{void \sphinxbfcode{coalescenceEvent}}{\sphinxstrong{const} unsigned long \&\sphinxstyleemphasis{chosen}, unsigned long \&\sphinxstyleemphasis{coalchosen}}{}%
\pysigstopmultiline
Perform the coalescence between lineages. Once coalesced, lineages are removed from the active scope. 

\begin{description}
\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{chosen}: the chosen lineage for coalescence 

\item {} 
\sphinxcode{coalchosen}: the target lineage for coalscence 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{Tree::calcNewPos (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_class_Tree:_CPPv2N4Tree10calcNewPosERbRKmRmRKlRKlRKlRKl}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{Exhaled/exhale_class_Tree:NECSimclass_tree_1a05a0e0f5f70d2763f9dad3bd54618c62}}\pysiglinewithargsret{void \sphinxbfcode{calcNewPos}}{bool \&\sphinxstyleemphasis{coal}, \sphinxstrong{const} unsigned long \&\sphinxstyleemphasis{chosen}, unsigned long \&\sphinxstyleemphasis{coalchosen}, \sphinxstrong{const} long \&\sphinxstyleemphasis{oldx}, \sphinxstrong{const} long \&\sphinxstyleemphasis{oldy}, \sphinxstrong{const} long \&\sphinxstyleemphasis{oldxwrap}, \sphinxstrong{const} long \&\sphinxstyleemphasis{oldywrap}}{}%
\pysigstopmultiline
Calculates the new position, checking whether coalescence has occured and with which lineage. 

This involves correct handling of checking wrapped lineages (outside the original grid). The probability of coalescence is also calculated.

\begin{description}
\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{coal}: boolean for whether coalescence occured or not 

\item {} 
\sphinxcode{chosen}: the chosen lineage 

\item {} 
\sphinxcode{coalchosen}: the lineaged that is coalescing (if required) 

\item {} 
\sphinxcode{oldx}: the old x position 

\item {} 
\sphinxcode{oldy}: the old y position 

\item {} 
\sphinxcode{oldxwrap}: the old x wrapping 

\item {} 
\sphinxcode{oldywrap}: the old y wrapping 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{Tree::switchPositions (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_class_Tree:_CPPv2N4Tree15switchPositionsEKm}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{Exhaled/exhale_class_Tree:NECSimclass_tree_1a89e2fa28e3d637b4bc034fb3afc53e81}}\pysiglinewithargsret{void \sphinxbfcode{switchPositions}}{\sphinxstrong{const} unsigned long \sphinxstyleemphasis{chosen}}{}%
\pysigstopmultiline
Switches the chosen position with the endactive position. 

\begin{description}
\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{chosen}: the chosen lineage to switch with endactive. 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{Tree::speciation (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_class_Tree:_CPPv2N4Tree10speciationERKm}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{Exhaled/exhale_class_Tree:NECSimclass_tree_1a05c9e44f1a4d7af83e65b6c4565b1b28}}\pysiglinewithargsret{void \sphinxbfcode{speciation}}{\sphinxstrong{const} unsigned long \&\sphinxstyleemphasis{chosen}}{}%
\pysigstopmultiline
Speciation to supplied lineage. 

Also calls the {\hyperref[\detokenize{Exhaled/exhale_class_Tree:NECSimclass_tree_1a351650bda95319b2213c2234fa930f49}]{\sphinxcrossref{\DUrole{std,std-ref}{removeOldPos()}}}} and {\hyperref[\detokenize{Exhaled/exhale_class_Tree:NECSimclass_tree_1a89e2fa28e3d637b4bc034fb3afc53e81}]{\sphinxcrossref{\DUrole{std,std-ref}{switchPositions()}}}} functions for removing the lineage out of active reference. \begin{description}
\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{chosen}: 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{Tree::estSpecnum (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_class_Tree:_CPPv2N4Tree10estSpecnumEv}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{Exhaled/exhale_class_Tree:NECSimclass_tree_1a8f4c4cbc5ad516f0fde489c9a826e676}}\pysiglinewithargsret{unsigned long \sphinxbfcode{estSpecnum}}{}{}%
\pysigstopmultiline
Estimates the species number from the second largest minimum speciation rate remaining in active. 

This allows for halting of the simulation once this threshold has been reached. However, the function is not currently in use as calculating the coalescence tree is very computionally intensive. 

\end{fulllineitems}

\index{Tree::runChecks (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_class_Tree:_CPPv2N4Tree9runChecksERKmRKm}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{Exhaled/exhale_class_Tree:NECSimclass_tree_1a3820405a51ac9043346d37b0e267d364}}\pysiglinewithargsret{void \sphinxbfcode{runChecks}}{\sphinxstrong{const} unsigned long \&\sphinxstyleemphasis{chosen}, \sphinxstrong{const} unsigned long \&\sphinxstyleemphasis{coalchosen}}{}%
\pysigstopmultiline
Run checks at the end of each cycle which make certain the move has been successful. 

\begin{description}
\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{chosen}: the chosen lineage to check 

\item {} 
\sphinxcode{coalchosen}: the lineage which is coalescing with the chosen lineage which we are also required to check 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{Tree::validationCheck (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_class_Tree:_CPPv2N4Tree15validationCheckERKmiRKmRKb}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{Exhaled/exhale_class_Tree:NECSimclass_tree_1aa60dbbf173231fb224e2c6792cbae292}}\pysiglinewithargsret{void \sphinxbfcode{validationCheck}}{\sphinxstrong{const} unsigned long \&\sphinxstyleemphasis{chosen}, int \sphinxstyleemphasis{o}, \sphinxstrong{const} unsigned long \&\sphinxstyleemphasis{current}, \sphinxstrong{const} bool \&\sphinxstyleemphasis{coal}}{}%
\pysigstopmultiline
Validates the chosen lineage is set up correctly. 

This functions is for debugging purposes. It checks that the wrapping of the lineage in active is correct, and links to other lineages are applied correctly.

\begin{description}
\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{chosen}: the desired lineage to check 

\item {} 
\sphinxcode{o}: an integer for outputting and referencing later on 

\item {} 
\sphinxcode{current}: the current lineage in memory, again for referencing purposes. 

\item {} 
\sphinxcode{coal}: boolean for whether coalescence has occured. 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{Tree::checkSimSize (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_class_Tree:_CPPv2N4Tree12checkSimSizeEmm}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{Exhaled/exhale_class_Tree:NECSimclass_tree_1ab8a62d0ca2b1746676073e3f33e2a949}}\pysiglinewithargsret{void \sphinxbfcode{checkSimSize}}{unsigned long \sphinxstyleemphasis{req\_data}, unsigned long \sphinxstyleemphasis{req\_active}}{}%
\pysigstopmultiline
Checks the size of the main active and data objects is large enough. 

\begin{description}
\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{req\_data}: the required data object size 

\item {} 
\sphinxcode{req\_active}: the required active object size 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{Tree::runSim (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_class_Tree:_CPPv2N4Tree6runSimEv}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{Exhaled/exhale_class_Tree:NECSimclass_tree_1a76061f067f4cebd400a33f1cffe73172}}\pysiglinewithargsret{bool \sphinxbfcode{runSim}}{}{}%
\pysigstopmultiline
Run the entire simulation given the start conditions already defined by {\hyperref[\detokenize{Exhaled/exhale_class_Tree:NECSimclass_tree_1a63960c821daf9d8daec875f2625ae7d6}]{\sphinxcrossref{\DUrole{std,std-ref}{setup()}}}} 

Setup is assumed to have been run already. This function is the main function containing the main loop of the simulation. At the end of the simulation, returns true if the simulation is complete, false otherwise. 

\end{fulllineitems}

\index{Tree::expandMap (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_class_Tree:_CPPv2N4Tree9expandMapEd}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{Exhaled/exhale_class_Tree:NECSimclass_tree_1aea93074542f30a4a51c05140aae93708}}\pysiglinewithargsret{void \sphinxbfcode{expandMap}}{double \sphinxstyleemphasis{generationin}}{}%
\pysigstopmultiline
Expands the map, generating the new lineages where necessary. 

The samplemask provided is used for expansion. Any empty spaces are filled with a new lineage. Lineages which have not moved are changed to tips, with a new data entry so that original and new generations are recorded.

\begin{description}
\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{generationin}: the generation that the expansion is occuring at. This is used in recording the new tips. 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{Tree::sortData (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_class_Tree:_CPPv2N4Tree8sortDataEv}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{Exhaled/exhale_class_Tree:NECSimclass_tree_1a2d2065bbebee8b55270d2691d40cd974}}\pysiglinewithargsret{unsigned long \sphinxbfcode{sortData}}{}{}%
\pysigstopmultiline
Sort and process the species list so that the useful information can be extracted from it. 

\end{fulllineitems}

\index{Tree::outputData (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_class_Tree:_CPPv2N4Tree10outputDataEv}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{Exhaled/exhale_class_Tree:NECSimclass_tree_1afdf680e187c25ed39d1e66542ce44cc3}}\pysiglinewithargsret{void \sphinxbfcode{outputData}}{}{}%
\pysigstopmultiline
Outputs important simulation data to a csv file. Overloaded version which automatically calls {\hyperref[\detokenize{Exhaled/exhale_class_Tree:NECSimclass_tree_1a2d2065bbebee8b55270d2691d40cd974}]{\sphinxcrossref{\DUrole{std,std-ref}{sortData()}}}} if no species richness is provided. 

\end{fulllineitems}

\index{Tree::outputData (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_class_Tree:_CPPv2N4Tree10outputDataEm}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{Exhaled/exhale_class_Tree:NECSimclass_tree_1a5acf7d0eea9ea2ef4928bb6691b87724}}\pysiglinewithargsret{void \sphinxbfcode{outputData}}{unsigned long \sphinxstyleemphasis{species\_richness}}{}%
\pysigstopmultiline
Outputs important simulation data to a csv file. This function will likely be remove in future versions as all simulation output is now contained in an SQLite database. 

\begin{description}
\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{species\_richness}: the species richness of the tree with the minimum speciation rate. Outputted into the csv file. 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{Tree::writeTimes (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_class_Tree:_CPPv2N4Tree10writeTimesEv}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{Exhaled/exhale_class_Tree:NECSimclass_tree_1ab8785fc9e27868a56335048321c13290}}\pysiglinewithargsret{void \sphinxbfcode{writeTimes}}{}{}%
\pysigstopmultiline
Writes the times to the terminal for simulation information. 

\end{fulllineitems}

\index{Tree::simPause (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_class_Tree:_CPPv2N4Tree8simPauseEv}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{Exhaled/exhale_class_Tree:NECSimclass_tree_1ae5308f74e982485ac444aa394b952152}}\pysiglinewithargsret{void \sphinxbfcode{simPause}}{}{}%
\pysigstopmultiline
Pause the simulation and dump data from memory. 



\end{fulllineitems}

\index{Tree::simResume (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_class_Tree:_CPPv2N4Tree9simResumeEb}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{Exhaled/exhale_class_Tree:NECSimclass_tree_1abbfb2ce1be81b10a8c77f0aa2a8cbcb8}}\pysiglinewithargsret{void \sphinxbfcode{simResume}}{bool \sphinxstyleemphasis{cont\_sim}}{}%
\pysigstopmultiline
Resumes the simulation from a previous state. 

Reads in the parameters and objects from file and re-starts the simulation. \begin{description}
\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{cont\_sim}: whether or not to resume simulations, imported from a call to checkSims(). 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{Tree::sqlCreate (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_class_Tree:_CPPv2N4Tree9sqlCreateEv}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{Exhaled/exhale_class_Tree:NECSimclass_tree_1ae784a6ed362f6c5263ee797759f715b6}}\pysiglinewithargsret{void \sphinxbfcode{sqlCreate}}{}{}%
\pysigstopmultiline
Generates the SQL database file from the full simulation data. This allows for greater analysis of the data after completion of the simulation. 

\end{fulllineitems}

\index{Tree::sqlOutput (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_class_Tree:_CPPv2N4Tree9sqlOutputEv}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{Exhaled/exhale_class_Tree:NECSimclass_tree_1a8cd3db7add1884ea53b0d98002d39cd3}}\pysiglinewithargsret{void \sphinxbfcode{sqlOutput}}{}{}%
\pysigstopmultiline
Copy the in-memory database to file. 

This function should not be called if the database is already opened on disc, and won't do anything if it is. 

\end{fulllineitems}

\index{Tree::applySpecRates (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_class_Tree:_CPPv2N4Tree14applySpecRatesEdd}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{Exhaled/exhale_class_Tree:NECSimclass_tree_1a1cb7f43588bd4605e746326376409b00}}\pysiglinewithargsret{void \sphinxbfcode{applySpecRates}}{double \sphinxstyleemphasis{sr}, double \sphinxstyleemphasis{t}}{}%
\pysigstopmultiline
Applies the given speciation rate to the tree. 

\begin{description}
\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{sr}: the required speciation rate. 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{Tree::applySpecRates (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_class_Tree:_CPPv2N4Tree14applySpecRatesEd}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{Exhaled/exhale_class_Tree:NECSimclass_tree_1a53d7bc7826706a2b0343f7458dd91c0f}}\pysiglinewithargsret{void \sphinxbfcode{applySpecRates}}{double \sphinxstyleemphasis{sr}}{}%
\pysigstopmultiline
Overloaded version of applySpecRates for the default generation (0.0). 

\begin{description}
\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{sr}: the speciation rate to apply to the tree. 

\end{itemize}

\end{description}


\end{fulllineitems}


\end{fulllineitems}



\paragraph{Class Treelist}
\label{\detokenize{Exhaled/exhale_class_Treelist:id1}}\label{\detokenize{Exhaled/exhale_class_Treelist::doc}}\label{\detokenize{Exhaled/exhale_class_Treelist:class-treelist}}\begin{itemize}
\item {} 
Defined in {\hyperref[\detokenize{Exhaled/exhale_file_Treelist.h:file-treelist-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File Treelist.h}}}}

\end{itemize}
\index{Treelist (C++ class)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_class_Treelist:_CPPv28Treelist}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{Exhaled/exhale_class_Treelist:NECSimclass_treelist}}\pysigline{\sphinxstrong{class }\sphinxcode{}\sphinxbfcode{Treelist}}%
\pysigstopmultiline
A class to contain the tree object lineages and reconstructing the coalescence tree. Contains functions for calculating the number of species for a given speciation rate, outputting spatial data and generating species abundance distributions. Requires a link to the SQLite database from simulation output, and produces results within the same database file. 
\paragraph{Public Functions}
\index{Treelist::Treelist (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_class_Treelist:_CPPv2N8Treelist8TreelistER3RowI8TreenodeE}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{Exhaled/exhale_class_Treelist:NECSimclass_treelist_1a14b5d2fcea1a3e93082f59e460633717}}\pysiglinewithargsret{\sphinxbfcode{Treelist}}{{\hyperref[\detokenize{Exhaled/exhale_class_Row:_CPPv23Row}]{\sphinxcrossref{Row}}}\textless{}{\hyperref[\detokenize{Exhaled/exhale_class_Treenode:_CPPv28Treenode}]{\sphinxcrossref{Treenode}}}\textgreater{} \&\sphinxstyleemphasis{r}}{}%
\pysigstopmultiline
Contructor for treelist. 

\begin{description}
\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{r}: {\hyperref[\detokenize{Exhaled/exhale_class_Row:NECSimclass_row}]{\sphinxcrossref{\DUrole{std,std-ref}{Row}}}} of {\hyperref[\detokenize{Exhaled/exhale_class_Treenode:NECSimclass_treenode}]{\sphinxcrossref{\DUrole{std,std-ref}{Treenode}}}} objects to link to. 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{Treelist::setList (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_class_Treelist:_CPPv2N8Treelist7setListER3RowI8TreenodeE}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{Exhaled/exhale_class_Treelist:NECSimclass_treelist_1a6e71bfa9e8bd28878d3edc6e89065fd3}}\pysiglinewithargsret{void \sphinxbfcode{setList}}{{\hyperref[\detokenize{Exhaled/exhale_class_Row:_CPPv23Row}]{\sphinxcrossref{Row}}}\textless{}{\hyperref[\detokenize{Exhaled/exhale_class_Treenode:_CPPv28Treenode}]{\sphinxcrossref{Treenode}}}\textgreater{} \&\sphinxstyleemphasis{l}}{}%
\pysigstopmultiline
Set the nodes object to the input {\hyperref[\detokenize{Exhaled/exhale_class_Row:NECSimclass_row}]{\sphinxcrossref{\DUrole{std,std-ref}{Row}}}} of {\hyperref[\detokenize{Exhaled/exhale_class_Treenode:NECSimclass_treenode}]{\sphinxcrossref{\DUrole{std,std-ref}{Treenode}}}} objects. 

\begin{description}
\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{l}: the {\hyperref[\detokenize{Exhaled/exhale_class_Row:NECSimclass_row}]{\sphinxcrossref{\DUrole{std,std-ref}{Row}}}} of {\hyperref[\detokenize{Exhaled/exhale_class_Treenode:NECSimclass_treenode}]{\sphinxcrossref{\DUrole{std,std-ref}{Treenode}}}} objects to link to. 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{Treelist::setDatabase (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_class_Treelist:_CPPv2N8Treelist11setDatabaseEP7sqlite3}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{Exhaled/exhale_class_Treelist:NECSimclass_treelist_1a0991cf24ea19b2d99c5bc70f47b45518}}\pysiglinewithargsret{void \sphinxbfcode{setDatabase}}{sqlite3 *\sphinxstyleemphasis{dbin}}{}%
\pysigstopmultiline
Sets the database object for the sqlite functions. 

\begin{description}
\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{dbin}: the sqlite3 input database. 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{Treelist::hasSetMem (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_class_Treelist:_CPPv2N8Treelist9hasSetMemEv}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{Exhaled/exhale_class_Treelist:NECSimclass_treelist_1afff0552b9a5d41ac589e6bf88f3ab295}}\pysiglinewithargsret{bool \sphinxbfcode{hasSetMem}}{}{}%
\pysigstopmultiline
Get the boolean of whether the memory has been set yet. 

\begin{description}
\item[{\sphinxstylestrong{Return}}] \leavevmode
the memory boolean. 

\end{description}


\end{fulllineitems}

\index{Treelist::getMinimumSpeciation (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_class_Treelist:_CPPv2N8Treelist20getMinimumSpeciationEv}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{Exhaled/exhale_class_Treelist:NECSimclass_treelist_1ad6177750efa83354a844bb7072551227}}\pysiglinewithargsret{double \sphinxbfcode{getMinimumSpeciation}}{}{}%
\pysigstopmultiline
Get the minimum speciation rate the simulation was originally run with. This value is read in from the SIMULATION\_PARAMETERS table in the database file. 

\begin{description}
\item[{\sphinxstylestrong{Return}}] \leavevmode
the minimum speciation rate. 

\end{description}


\end{fulllineitems}

\index{Treelist::importSamplemask (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_class_Treelist:_CPPv2N8Treelist16importSamplemaskE6string}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{Exhaled/exhale_class_Treelist:NECSimclass_treelist_1a40a8108fe416b9431b232b0e49280e52}}\pysiglinewithargsret{void \sphinxbfcode{importSamplemask}}{string \sphinxstyleemphasis{sSamplemask}}{}%
\pysigstopmultiline
Imports the samplemask if it hasn't already been imported. 

\begin{description}
\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{sSamplemask}: the path to the samplemask file. 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{Treelist::countSpecies (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_class_Treelist:_CPPv2N8Treelist12countSpeciesEv}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{Exhaled/exhale_class_Treelist:NECSimclass_treelist_1af8888281f584bb1cc6a1543f70b747e9}}\pysiglinewithargsret{unsigned long \sphinxbfcode{countSpecies}}{}{}%
\pysigstopmultiline
Counts the number of species that have speciated currently on the tree. 

\begin{description}
\item[{\sphinxstylestrong{Return}}] \leavevmode
the number of species 

\end{description}


\end{fulllineitems}

\index{Treelist::doubleCompare (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_class_Treelist:_CPPv2N8Treelist13doubleCompareEddd}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{Exhaled/exhale_class_Treelist:NECSimclass_treelist_1a05569869366578bd13f228f098200383}}\pysiglinewithargsret{bool \sphinxbfcode{doubleCompare}}{double \sphinxstyleemphasis{d1}, double \sphinxstyleemphasis{d2}, double \sphinxstyleemphasis{epsilon}}{}%
\pysigstopmultiline
Compares two doubles and returns a boolean of whether they are equal, within the epsilon deviation. This is useful for floating point errors in saving and reading doubles from file. 

\begin{description}
\item[{\sphinxstylestrong{Return}}] \leavevmode


\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{d1}: the first double. 

\item {} 
\sphinxcode{d2}: the second double. 

\item {} 
\sphinxcode{epsilon}: the deviation within which the values are assumed to be equal. 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{Treelist::calcSpecies (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_class_Treelist:_CPPv2N8Treelist11calcSpeciesEd}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{Exhaled/exhale_class_Treelist:NECSimclass_treelist_1a251b84151f3ba70e34bca3824b165093}}\pysiglinewithargsret{unsigned long \sphinxbfcode{calcSpecies}}{double \sphinxstyleemphasis{s}}{}%
\pysigstopmultiline
Calculate the number of species in the list given a specific speciation rate. This is the main function which reconstructs the coalescence tree. Each {\hyperref[\detokenize{Exhaled/exhale_class_Treenode:NECSimclass_treenode}]{\sphinxcrossref{\DUrole{std,std-ref}{Treenode}}}} object will end having its existance value set correctly after a call to this function. 

\begin{description}
\item[{\sphinxstylestrong{Return}}] \leavevmode
the number of species present. 

\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{s}: the speciation rate to apply. 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{Treelist::calcSpeciesAbundance (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_class_Treelist:_CPPv2N8Treelist20calcSpeciesAbundanceEv}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{Exhaled/exhale_class_Treelist:NECSimclass_treelist_1a7d077eac323c32bfdce6bca808f357ae}}\pysiglinewithargsret{void \sphinxbfcode{calcSpeciesAbundance}}{}{}%
\pysigstopmultiline
Calculates the species abundance of the dataset. The species abundances will be with rOut after a call do this function. If a samplemask has been applied, only lineages which originally existed in the samplemask will be counted. 

\end{fulllineitems}

\index{Treelist::resetTree (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_class_Treelist:_CPPv2N8Treelist9resetTreeEv}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{Exhaled/exhale_class_Treelist:NECSimclass_treelist_1ad089f6a63b1904d0b50299adfae52f5b}}\pysiglinewithargsret{void \sphinxbfcode{resetTree}}{}{}%
\pysigstopmultiline
Resets the entire tree. Sets existance to false, speciation to false and removes any species ID. 

\end{fulllineitems}

\index{Treelist::detectDimensions (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_class_Treelist:_CPPv2N8Treelist16detectDimensionsE6string}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{Exhaled/exhale_class_Treelist:NECSimclass_treelist_1acaa619f2d186f60c9c9fa5d90db0da68}}\pysiglinewithargsret{void \sphinxbfcode{detectDimensions}}{string \sphinxstyleemphasis{db}}{}%
\pysigstopmultiline
This function detects the maximum x and y values of the sql database. This allows for the dimensions before opening the map file. 

\begin{description}
\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{db}: the path to the input database to read from. 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{Treelist::importData (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_class_Treelist:_CPPv2N8Treelist10importDataE6string}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{Exhaled/exhale_class_Treelist:NECSimclass_treelist_1a8042f6a3ab6eb1e7dc75baba20240118}}\pysiglinewithargsret{void \sphinxbfcode{importData}}{string \sphinxstyleemphasis{inputfile}}{}%
\pysigstopmultiline
Imports the data from the desired SQL database object into the array. It also stores an in-memory version of the data for working with. 

\begin{description}
\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{inputfile}: the path to the input SQLite database. 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{Treelist::setGeneration (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_class_Treelist:_CPPv2N8Treelist13setGenerationEe}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{Exhaled/exhale_class_Treelist:NECSimclass_treelist_1a3bdea04b963ec5a92711d5f389a534c2}}\pysiglinewithargsret{void \sphinxbfcode{setGeneration}}{long double \sphinxstyleemphasis{generationin}}{}%
\pysigstopmultiline
Set the time of interest where all analysis will be performed. It is assumed that this was one of the temporal points defined at simulation time. 

\begin{description}
\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{generationin}: the target generation. 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{Treelist::createDatabase (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_class_Treelist:_CPPv2N8Treelist14createDatabaseEd}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{Exhaled/exhale_class_Treelist:NECSimclass_treelist_1a3416c2a81ee64b98b3d7956f58a8132d}}\pysiglinewithargsret{void \sphinxbfcode{createDatabase}}{double \sphinxstyleemphasis{s}}{}%
\pysigstopmultiline
Creates a new table in the database file and outputs the database object to the same file as the input file. The new SPECIES\_ABUNDANCES table contains the species abundance distribution for the whole samplemask. A similar tabe FRAGMENT\_ABUNDANCES is generated by {\hyperref[\detokenize{Exhaled/exhale_class_Treelist:NECSimclass_treelist_1aba14303915c31c334e1d63ae61c3812c}]{\sphinxcrossref{\DUrole{std,std-ref}{createFragmentDatabase()}}}} if specified via the command line parameters. 

\begin{description}
\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{s}: the speciation rate to apply. 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{Treelist::createFragmentDatabase (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_class_Treelist:_CPPv2N8Treelist22createFragmentDatabaseERK8Fragment}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{Exhaled/exhale_class_Treelist:NECSimclass_treelist_1aba14303915c31c334e1d63ae61c3812c}}\pysiglinewithargsret{void \sphinxbfcode{createFragmentDatabase}}{\sphinxstrong{const} {\hyperref[\detokenize{Exhaled/exhale_struct_Fragment:_CPPv28Fragment}]{\sphinxcrossref{Fragment}}} \&\sphinxstyleemphasis{f}}{}%
\pysigstopmultiline
Creates a new table in the database file and outputs the database object to the same file as the input file. Essentially creates a species abundance distribution (as in {\hyperref[\detokenize{Exhaled/exhale_class_Treelist:NECSimclass_treelist_1a3416c2a81ee64b98b3d7956f58a8132d}]{\sphinxcrossref{\DUrole{std,std-ref}{createDatabase()}}}}), but for the specified fragment within the samplemask. 

\begin{description}
\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{f}: the {\hyperref[\detokenize{Exhaled/exhale_struct_Fragment:NECSimstruct_fragment}]{\sphinxcrossref{\DUrole{std,std-ref}{Fragment}}}} to sample from. 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{Treelist::exportDatabase (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_class_Treelist:_CPPv2N8Treelist14exportDatabaseE6string}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{Exhaled/exhale_class_Treelist:NECSimclass_treelist_1a3f7f7eb4526ee91180742010394e0f65}}\pysiglinewithargsret{void \sphinxbfcode{exportDatabase}}{string \sphinxstyleemphasis{outputfile}}{}%
\pysigstopmultiline
Output the database from memory to the database file. Most of the time, it is desirable for the outputfile to be the same path as the input file and will write to the same object. 

\begin{description}
\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{outputfile}: the path to the output file. 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{Treelist::recordSpatial (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_class_Treelist:_CPPv2N8Treelist13recordSpatialEv}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{Exhaled/exhale_class_Treelist:NECSimclass_treelist_1a3bba0e4657b3c98025331ae6c76d2a14}}\pysiglinewithargsret{void \sphinxbfcode{recordSpatial}}{}{}%
\pysigstopmultiline
Record the full spatial data. Creates a new table, SPECIES\_LOCATIONS containing every species and their parameters. This allows for more in-depth analysis to be performed if necessary. 

\end{fulllineitems}

\index{Treelist::calcFragments (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_class_Treelist:_CPPv2N8Treelist13calcFragmentsE6string}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{Exhaled/exhale_class_Treelist:NECSimclass_treelist_1ac0569d1ff2167b24751e490d7d76ac9f}}\pysiglinewithargsret{void \sphinxbfcode{calcFragments}}{string \sphinxstyleemphasis{fragment\_file}}{}%
\pysigstopmultiline
Calculates the limits of each fragment in the sample map and adds it to the vector of fragments. If the fragment\_file is null, then the program will attempt to calculate fragments from the map. 

\begin{description}
\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{fragment\_file}: the fragment file to read from. 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{Treelist::applyFragments (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_class_Treelist:_CPPv2N8Treelist14applyFragmentsEv}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{Exhaled/exhale_class_Treelist:NECSimclass_treelist_1a40ce2abdada3090379f75ac0532e9ea0}}\pysiglinewithargsret{void \sphinxbfcode{applyFragments}}{}{}%
\pysigstopmultiline
Calculate species abundances for each fragment, and call {\hyperref[\detokenize{Exhaled/exhale_class_Treelist:NECSimclass_treelist_1aba14303915c31c334e1d63ae61c3812c}]{\sphinxcrossref{\DUrole{std,std-ref}{createFragmentDatabase()}}}} for each {\hyperref[\detokenize{Exhaled/exhale_struct_Fragment:NECSimstruct_fragment}]{\sphinxcrossref{\DUrole{std,std-ref}{Fragment}}}}. 

\end{fulllineitems}


\end{fulllineitems}



\paragraph{Class Treenode}
\label{\detokenize{Exhaled/exhale_class_Treenode:id1}}\label{\detokenize{Exhaled/exhale_class_Treenode::doc}}\label{\detokenize{Exhaled/exhale_class_Treenode:class-treenode}}\begin{itemize}
\item {} 
Defined in {\hyperref[\detokenize{Exhaled/exhale_file_Treenode.h:file-treenode-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File Treenode.h}}}}

\end{itemize}
\index{Treenode (C++ class)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_class_Treenode:_CPPv28Treenode}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{Exhaled/exhale_class_Treenode:NECSimclass_treenode}}\pysigline{\sphinxstrong{class }\sphinxcode{}\sphinxbfcode{Treenode}}%
\pysigstopmultiline
The {\hyperref[\detokenize{Exhaled/exhale_class_Treenode:NECSimclass_treenode}]{\sphinxcrossref{\DUrole{std,std-ref}{Treenode}}}} class that acts as a data storage object for the phylogenetic tree. 

Also contains all the necessary routines for changes to a lineage's attributes, called by {\hyperref[\detokenize{Exhaled/exhale_class_Treelist:NECSimclass_treelist}]{\sphinxcrossref{\DUrole{std,std-ref}{Treelist}}}} objects when generating new coalescence trees. 
\paragraph{Public Functions}
\index{Treenode::Treenode (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_class_Treenode:_CPPv2N8Treenode8TreenodeEv}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{Exhaled/exhale_class_Treenode:NECSimclass_treenode_1a443ef4898396930c793f1c46c4a0bcc8}}\pysiglinewithargsret{\sphinxbfcode{Treenode}}{}{}%
\pysigstopmultiline
The default constructor. 

\end{fulllineitems}

\index{Treenode::\textasciitilde{}Treenode (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_class_Treenode:_CPPv2N8TreenodeD0Ev}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{Exhaled/exhale_class_Treenode:NECSimclass_treenode_1a9744b9626015b4a7902e52f7febd09c8}}\pysiglinewithargsret{\sphinxbfcode{\textasciitilde{}Treenode}}{}{}%
\pysigstopmultiline
The default destructor. 

\end{fulllineitems}

\index{Treenode::setup (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_class_Treenode:_CPPv2N8Treenode5setupEbmmll}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{Exhaled/exhale_class_Treenode:NECSimclass_treenode_1a3664bad0e23571689662ca26aad97f62}}\pysiglinewithargsret{void \sphinxbfcode{setup}}{bool \sphinxstyleemphasis{z}, unsigned long \sphinxstyleemphasis{xp}, unsigned long \sphinxstyleemphasis{yp}, long \sphinxstyleemphasis{xi}, long \sphinxstyleemphasis{yi}}{}%
\pysigstopmultiline
Sets up variables with initial conditions. 

\begin{description}
\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{z}: whether this lineage is a tip or not (represents the end of a tree). 

\item {} 
\sphinxcode{xp}: the x position on the grid. 

\item {} 
\sphinxcode{yp}: the y position on the grid. 

\item {} 
\sphinxcode{xi}: the number of wraps in the x dimension. 

\item {} 
\sphinxcode{yi}: the number of wraps in the y dimension. 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{Treenode::setup (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_class_Treenode:_CPPv2N8Treenode5setupEbmmlle}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{Exhaled/exhale_class_Treenode:NECSimclass_treenode_1ac4d93bdc85ed25fdec54a6cbfd7b71ee}}\pysiglinewithargsret{void \sphinxbfcode{setup}}{bool \sphinxstyleemphasis{z}, unsigned long \sphinxstyleemphasis{xp}, unsigned long \sphinxstyleemphasis{yp}, long \sphinxstyleemphasis{xi}, long \sphinxstyleemphasis{yi}, long double \sphinxstyleemphasis{generation}}{}%
\pysigstopmultiline
Overloaded {\hyperref[\detokenize{Exhaled/exhale_class_Treenode:NECSimclass_treenode_1a3664bad0e23571689662ca26aad97f62}]{\sphinxcrossref{\DUrole{std,std-ref}{setup()}}}} function, additionally taking a generation time point. 

Used when creating lineages after the start of the simulation, when the generation is not 0. \begin{description}
\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{z}: whether this lineage is a tip or not (represents the end of a tree). 

\item {} 
\sphinxcode{xp}: the x position on the grid. 

\item {} 
\sphinxcode{yp}: the y position on the grid. 

\item {} 
\sphinxcode{xi}: the number of wraps in the x dimension. 

\item {} 
\sphinxcode{yi}: the number of wraps in the y dimension. 

\item {} 
\sphinxcode{generation}: the current generation at creation time. 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{Treenode::setExistance (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_class_Treenode:_CPPv2N8Treenode12setExistanceEb}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{Exhaled/exhale_class_Treenode:NECSimclass_treenode_1a09f4c23f8182919fbe5ba4441c6f9789}}\pysiglinewithargsret{void \sphinxbfcode{setExistance}}{bool \sphinxstyleemphasis{b}}{}%
\pysigstopmultiline
Setter for the existance of the lineage. 

\begin{description}
\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{b}: existance boolean. 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{Treenode::setParent (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_class_Treenode:_CPPv2N8Treenode9setParentEm}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{Exhaled/exhale_class_Treenode:NECSimclass_treenode_1a4aceb22d86000b58f10039b7fd396aa6}}\pysiglinewithargsret{void \sphinxbfcode{setParent}}{unsigned long \sphinxstyleemphasis{x}}{}%
\pysigstopmultiline
Setter for the parent reference. 

\begin{description}
\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{x}: a reference for the parent location. 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{Treenode::qReset (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_class_Treenode:_CPPv2N8Treenode6qResetEv}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{Exhaled/exhale_class_Treenode:NECSimclass_treenode_1a9f67cecf8724424486f08b31080a3f21}}\pysiglinewithargsret{void \sphinxbfcode{qReset}}{}{}%
\pysigstopmultiline
Resets the lineage. Remove any species ID, existance and speciation record. 

\end{fulllineitems}

\index{Treenode::setPosition (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_class_Treenode:_CPPv2N8Treenode11setPositionEllll}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{Exhaled/exhale_class_Treenode:NECSimclass_treenode_1a6cdacbd3e26bd70dfb0c974b52456970}}\pysiglinewithargsret{void \sphinxbfcode{setPosition}}{long \sphinxstyleemphasis{x}, long \sphinxstyleemphasis{y}, long \sphinxstyleemphasis{xw}, long \sphinxstyleemphasis{yw}}{}%
\pysigstopmultiline
Set a new position for the lineage. 

\begin{description}
\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{x}: the x position on the grid. 

\item {} 
\sphinxcode{y}: the y position on the grid. 

\item {} 
\sphinxcode{xw}: the number of wraps in the x dimension. 

\item {} 
\sphinxcode{yw}: the number of wraps in the y dimension. 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{Treenode::setSpec (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_class_Treenode:_CPPv2N8Treenode7setSpecEe}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{Exhaled/exhale_class_Treenode:NECSimclass_treenode_1a4d54472f94fc213570dd50fd32b997f7}}\pysiglinewithargsret{void \sphinxbfcode{setSpec}}{long double \sphinxstyleemphasis{d}}{}%
\pysigstopmultiline
Setter for the randomly generated number (from NRrand.d0()) for the speciation probability for this lineage. 

\begin{description}
\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{d}: the speciation probability. 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{Treenode::setIGen (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_class_Treenode:_CPPv2N8Treenode7setIGenEm}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{Exhaled/exhale_class_Treenode:NECSimclass_treenode_1ac926fbbbe37c10eca7930b9d6f07b072}}\pysiglinewithargsret{void \sphinxbfcode{setIGen}}{unsigned long \sphinxstyleemphasis{g}}{}%
\pysigstopmultiline
Setter for the number of generations this lineage has existed for. 

\begin{description}
\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{g}: the number of generations that the lineage has existed. 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{Treenode::setGeneration (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_class_Treenode:_CPPv2N8Treenode13setGenerationEe}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{Exhaled/exhale_class_Treenode:NECSimclass_treenode_1a1f53687ac75f39008ac4a8b6869a5266}}\pysiglinewithargsret{void \sphinxbfcode{setGeneration}}{long double \sphinxstyleemphasis{d}}{}%
\pysigstopmultiline
Setter for the birth generation timer for the lineage. 

Note that moves that don't involve coalescence do not create a new {\hyperref[\detokenize{Exhaled/exhale_class_Treenode:NECSimclass_treenode}]{\sphinxcrossref{\DUrole{std,std-ref}{Treenode}}}} object, and therefore the generation\_added does not get updated. However, coalescence events will cause a new {\hyperref[\detokenize{Exhaled/exhale_class_Treenode:NECSimclass_treenode}]{\sphinxcrossref{\DUrole{std,std-ref}{Treenode}}}} object creation. The lineage birth generation is generally only important for calculating the age of tips. \begin{description}
\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{d}: 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{Treenode::setSpeciation (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_class_Treenode:_CPPv2N8Treenode13setSpeciationEb}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{Exhaled/exhale_class_Treenode:NECSimclass_treenode_1a116b74093b6ccb16323f958be4820e7e}}\pysiglinewithargsret{void \sphinxbfcode{setSpeciation}}{bool \sphinxstyleemphasis{s}}{}%
\pysigstopmultiline
Setter for the speciation boolean. 

\begin{description}
\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{s}: the speciation boolean. 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{Treenode::burnSpecies (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_class_Treenode:_CPPv2N8Treenode11burnSpeciesEm}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{Exhaled/exhale_class_Treenode:NECSimclass_treenode_1ad4373585fe62f316eeabd88b9c2d7b2f}}\pysiglinewithargsret{void \sphinxbfcode{burnSpecies}}{unsigned long \sphinxstyleemphasis{idin}}{}%
\pysigstopmultiline
Setter for the species ID. Once set to something other than 0, this cannot be changed with a call to {\hyperref[\detokenize{Exhaled/exhale_class_Treenode:NECSimclass_treenode_1a9f67cecf8724424486f08b31080a3f21}]{\sphinxcrossref{\DUrole{std,std-ref}{qReset()}}}} or {\hyperref[\detokenize{Exhaled/exhale_class_Treenode:NECSimclass_treenode_1aeb5aa21b29ab16bd0c50012aa6e052b7}]{\sphinxcrossref{\DUrole{std,std-ref}{resetSpecies()}}}}. 

\begin{description}
\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{idin}: the species ID. 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{Treenode::setTip (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_class_Treenode:_CPPv2N8Treenode6setTipEb}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{Exhaled/exhale_class_Treenode:NECSimclass_treenode_1a4886d8c939a7caa46f505a6f99ca1f3d}}\pysiglinewithargsret{void \sphinxbfcode{setTip}}{bool \sphinxstyleemphasis{b}}{}%
\pysigstopmultiline
Setter for the tip boolean. 

\begin{description}
\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{b}: the tip boolean. 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{Treenode::resetSpecies (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_class_Treenode:_CPPv2N8Treenode12resetSpeciesEv}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{Exhaled/exhale_class_Treenode:NECSimclass_treenode_1aeb5aa21b29ab16bd0c50012aa6e052b7}}\pysiglinewithargsret{void \sphinxbfcode{resetSpecies}}{}{}%
\pysigstopmultiline
Reset the species ID to 0. 

\end{fulllineitems}

\index{Treenode::increaseGen (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_class_Treenode:_CPPv2N8Treenode11increaseGenEv}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{Exhaled/exhale_class_Treenode:NECSimclass_treenode_1a96218ba8d509081101da166dd4663aa0}}\pysiglinewithargsret{void \sphinxbfcode{increaseGen}}{}{}%
\pysigstopmultiline
Increases the generation counter by one. 

\end{fulllineitems}

\index{Treenode::getExistance (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_class_Treenode:_CPPv2N8Treenode12getExistanceEv}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{Exhaled/exhale_class_Treenode:NECSimclass_treenode_1ace87274d2796a77256dbce935e2375b2}}\pysiglinewithargsret{bool \sphinxbfcode{getExistance}}{}{}%
\pysigstopmultiline
Getter for the existance boolean. 

\begin{description}
\item[{\sphinxstylestrong{Return}}] \leavevmode
the existance boolean. 

\end{description}


\end{fulllineitems}

\index{Treenode::isTip (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_class_Treenode:_CPPv2N8Treenode5isTipEv}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{Exhaled/exhale_class_Treenode:NECSimclass_treenode_1a4f965feba2b2ba0ac4dd5bec0d54e684}}\pysiglinewithargsret{bool \sphinxbfcode{isTip}}{}{}%
\pysigstopmultiline
Getter for the tip boolean. 

\begin{description}
\item[{\sphinxstylestrong{Return}}] \leavevmode
the tip boolean. 

\end{description}


\end{fulllineitems}

\index{Treenode::getParent (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_class_Treenode:_CPPv2N8Treenode9getParentEv}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{Exhaled/exhale_class_Treenode:NECSimclass_treenode_1a64ec6d0d909b1e34dac2428872e8b06e}}\pysiglinewithargsret{unsigned long \sphinxbfcode{getParent}}{}{}%
\pysigstopmultiline
Getter for the parent location. 

\begin{description}
\item[{\sphinxstylestrong{Return}}] \leavevmode
the parent reference. 

\end{description}


\end{fulllineitems}

\index{Treenode::getXpos (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_class_Treenode:_CPPv2N8Treenode7getXposEv}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{Exhaled/exhale_class_Treenode:NECSimclass_treenode_1a21e176b5d030751de95c6e8f9d1aea98}}\pysiglinewithargsret{unsigned long \sphinxbfcode{getXpos}}{}{}%
\pysigstopmultiline
Getter for the x position. 

\begin{description}
\item[{\sphinxstylestrong{Return}}] \leavevmode
the x position. 

\end{description}


\end{fulllineitems}

\index{Treenode::getYpos (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_class_Treenode:_CPPv2N8Treenode7getYposEv}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{Exhaled/exhale_class_Treenode:NECSimclass_treenode_1a97e64a35740dbea2ef2dc0069cef2b8e}}\pysiglinewithargsret{unsigned long \sphinxbfcode{getYpos}}{}{}%
\pysigstopmultiline
Getter for the y position. 

\begin{description}
\item[{\sphinxstylestrong{Return}}] \leavevmode
the y position. 

\end{description}


\end{fulllineitems}

\index{Treenode::getXwrap (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_class_Treenode:_CPPv2N8Treenode8getXwrapEv}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{Exhaled/exhale_class_Treenode:NECSimclass_treenode_1a949741ee546b263eae8265e27ad74df4}}\pysiglinewithargsret{long \sphinxbfcode{getXwrap}}{}{}%
\pysigstopmultiline
Getter for the number of times the lineage is wrapped in the x dimension. 

\begin{description}
\item[{\sphinxstylestrong{Return}}] \leavevmode
the number of times the lineage is wrapped in the x dimension. 

\end{description}


\end{fulllineitems}

\index{Treenode::getYwrap (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_class_Treenode:_CPPv2N8Treenode8getYwrapEv}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{Exhaled/exhale_class_Treenode:NECSimclass_treenode_1a62be6c15c2378148c8c85b4f4d3b7f78}}\pysiglinewithargsret{long \sphinxbfcode{getYwrap}}{}{}%
\pysigstopmultiline
Getter for the number of times the lineage is wrapped in the y dimension. 

\begin{description}
\item[{\sphinxstylestrong{Return}}] \leavevmode
the number of times the lineage is wrapped in the y dimension. 

\end{description}


\end{fulllineitems}

\index{Treenode::hasSpeciated (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_class_Treenode:_CPPv2N8Treenode12hasSpeciatedEv}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{Exhaled/exhale_class_Treenode:NECSimclass_treenode_1a5e37d24c2f1808262518402fcf50183c}}\pysiglinewithargsret{bool \sphinxbfcode{hasSpeciated}}{}{}%
\pysigstopmultiline
Getter for the speciation boolean. 

\begin{description}
\item[{\sphinxstylestrong{Return}}] \leavevmode
the speciation boolean. 

\end{description}


\end{fulllineitems}

\index{Treenode::getSpeciesID (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_class_Treenode:_CPPv2N8Treenode12getSpeciesIDEv}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{Exhaled/exhale_class_Treenode:NECSimclass_treenode_1ad1a1ea65124c7db886de695522ea3272}}\pysiglinewithargsret{unsigned long \sphinxbfcode{getSpeciesID}}{}{}%
\pysigstopmultiline
Getter for the species ID. 

\begin{description}
\item[{\sphinxstylestrong{Return}}] \leavevmode
the species ID. 

\end{description}


\end{fulllineitems}

\index{Treenode::getSpecRate (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_class_Treenode:_CPPv2N8Treenode11getSpecRateEv}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{Exhaled/exhale_class_Treenode:NECSimclass_treenode_1a50699133e245bae92dbdf3fcf30eccd9}}\pysiglinewithargsret{long double \sphinxbfcode{getSpecRate}}{}{}%
\pysigstopmultiline
Getter for the randomly generated speciation probability. 

\begin{description}
\item[{\sphinxstylestrong{Return}}] \leavevmode
the speciation probability. 

\end{description}


\end{fulllineitems}

\index{Treenode::getGenRate (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_class_Treenode:_CPPv2N8Treenode10getGenRateEv}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{Exhaled/exhale_class_Treenode:NECSimclass_treenode_1a0414c6a3ff3dad43f4e2e1b441ceb617}}\pysiglinewithargsret{unsigned long \sphinxbfcode{getGenRate}}{}{}%
\pysigstopmultiline
Getter for the number of generations the lineage has existed. 

\begin{description}
\item[{\sphinxstylestrong{Return}}] \leavevmode
the number of generations of existance. 

\end{description}


\end{fulllineitems}

\index{Treenode::getGeneration (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_class_Treenode:_CPPv2N8Treenode13getGenerationEv}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{Exhaled/exhale_class_Treenode:NECSimclass_treenode_1ab89bf951b5e557a2cf72294e5e289b19}}\pysiglinewithargsret{long double \sphinxbfcode{getGeneration}}{}{}%
\pysigstopmultiline
Getter for the generation the lineage was created. 

\begin{description}
\item[{\sphinxstylestrong{Return}}] \leavevmode
the generation counter the lineage was created. 

\end{description}


\end{fulllineitems}

\index{Treenode::speciate (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_class_Treenode:_CPPv2N8Treenode8speciateEv}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{Exhaled/exhale_class_Treenode:NECSimclass_treenode_1a094f8313cfeaedee44c967d7b750019b}}\pysiglinewithargsret{void \sphinxbfcode{speciate}}{}{}%
\pysigstopmultiline
Sets the speciation boolean to true. 

\end{fulllineitems}

\paragraph{Friends}
\index{operator\textless{}\textless{} (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_class_Treenode:_CPPv2lsR7ostreamRK8Treenode}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{Exhaled/exhale_class_Treenode:NECSimclass_treenode_1a9f22e750fa7a3579f15289953003d68d}}\pysiglinewithargsret{ostream \&\sphinxbfcode{operator\textless{}\textless{}}}{ostream \&\sphinxstyleemphasis{os}, \sphinxstrong{const} {\hyperref[\detokenize{Exhaled/exhale_class_Treenode:_CPPv28Treenode}]{\sphinxcrossref{Treenode}}} \&\sphinxstyleemphasis{t}}{}%
\pysigstopmultiline
Overloading the \textless{}\textless{} operator for outputting a {\hyperref[\detokenize{Exhaled/exhale_class_Treenode:NECSimclass_treenode}]{\sphinxcrossref{\DUrole{std,std-ref}{Treenode}}}} object to an output stream. 

\begin{description}
\item[{\sphinxstylestrong{Return}}] \leavevmode
the output stream. 

\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{os}: the output stream. 

\item {} 
\sphinxcode{t}: a {\hyperref[\detokenize{Exhaled/exhale_class_Treenode:NECSimclass_treenode}]{\sphinxcrossref{\DUrole{std,std-ref}{Treenode}}}} object to output. 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{operator\textgreater{}\textgreater{} (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_class_Treenode:_CPPv2rsR7istreamR8Treenode}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{Exhaled/exhale_class_Treenode:NECSimclass_treenode_1ad0037bea966b28d79a15e43c05a43587}}\pysiglinewithargsret{istream \&\sphinxbfcode{operator\textgreater{}\textgreater{}}}{istream \&\sphinxstyleemphasis{is}, {\hyperref[\detokenize{Exhaled/exhale_class_Treenode:_CPPv28Treenode}]{\sphinxcrossref{Treenode}}} \&\sphinxstyleemphasis{t}}{}%
\pysigstopmultiline
Overloading the \textgreater{}\textgreater{} operator for inputting the {\hyperref[\detokenize{Exhaled/exhale_class_Treenode:NECSimclass_treenode}]{\sphinxcrossref{\DUrole{std,std-ref}{Treenode}}}} object from an input stream. 

\begin{description}
\item[{\sphinxstylestrong{Return}}] \leavevmode
the input stream. 

\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{is}: the input stream. 

\item {} 
\sphinxcode{t}: a {\hyperref[\detokenize{Exhaled/exhale_class_Treenode:NECSimclass_treenode}]{\sphinxcrossref{\DUrole{std,std-ref}{Treenode}}}} object to input to. 

\end{itemize}

\end{description}


\end{fulllineitems}


\end{fulllineitems}



\subsubsection{Functions}
\label{\detokenize{Exhaled/exhaled_library:functions}}

\paragraph{Function charconvertor}
\label{\detokenize{Exhaled/exhale_function_charconvertor:function-charconvertor}}\label{\detokenize{Exhaled/exhale_function_charconvertor::doc}}\label{\detokenize{Exhaled/exhale_function_charconvertor:id1}}\begin{itemize}
\item {} 
Defined in {\hyperref[\detokenize{Exhaled/exhale_file_Setup.cpp:file-setup-cpp}]{\sphinxcrossref{\DUrole{std,std-ref}{File Setup.cpp}}}}

\end{itemize}
\index{charconvertor (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_function_charconvertor:_CPPv213charconvertorc}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{Exhaled/exhale_function_charconvertor:NECSim_setup_8h_1afa342b670d1d093e50f7e56ea7d6975c}}\pysiglinewithargsret{long \sphinxcode{}\sphinxbfcode{charconvertor}}{char \sphinxstyleemphasis{charin}}{}%
\pysigstopmultiline
converts the characters to an integer for command-line parsing. 

Originally written for handy HPC use. \begin{description}
\item[{\sphinxstylestrong{Return}}] \leavevmode
the converted integer. 

\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{charin}: the character to change to an integer. 

\end{itemize}

\end{description}


\end{fulllineitems}



\paragraph{Function checkFolders}
\label{\detokenize{Exhaled/exhale_function_checkFolders:id1}}\label{\detokenize{Exhaled/exhale_function_checkFolders::doc}}\label{\detokenize{Exhaled/exhale_function_checkFolders:function-checkfolders}}\begin{itemize}
\item {} 
Defined in {\hyperref[\detokenize{Exhaled/exhale_file_Setup.cpp:file-setup-cpp}]{\sphinxcrossref{\DUrole{std,std-ref}{File Setup.cpp}}}}

\end{itemize}
\index{checkFolders (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_function_checkFolders:_CPPv212checkFolders6string6string6string6string6string6string}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{Exhaled/exhale_function_checkFolders:NECSim_setup_8h_1aef1ca8da5e133963764d397fac17b5fe}}\pysiglinewithargsret{void \sphinxcode{}\sphinxbfcode{checkFolders}}{string \sphinxstyleemphasis{sFineMap}, string \sphinxstyleemphasis{sCoarseMap}, string \sphinxstyleemphasis{sFineMapPristine}, string \sphinxstyleemphasis{sCoarseMapPristine}, string \sphinxstyleemphasis{sOutputFolder}, string \sphinxstyleemphasis{sSampleMask}}{}%
\pysigstopmultiline
Runs doesExist() on every supplied map, providing defaults where possible if one doesn't. 

\begin{description}
\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{sFineMap}: the fine map file path 

\item {} 
\sphinxcode{sCoarseMap}: the course map file path 

\item {} 
\sphinxcode{sFineMapPristine}: the fine pristine map file path 

\item {} 
\sphinxcode{sCoarseMapPristine}: the coarse pristine map file path 

\item {} 
\sphinxcode{sOutputFolder}: the output folder 

\item {} 
\sphinxcode{sSampleMask}: the sample mask file path 

\end{itemize}

\end{description}


\end{fulllineitems}



\paragraph{Function checkSims}
\label{\detokenize{Exhaled/exhale_function_checkSims:function-checksims}}\label{\detokenize{Exhaled/exhale_function_checkSims::doc}}\label{\detokenize{Exhaled/exhale_function_checkSims:id1}}\begin{itemize}
\item {} 
Defined in {\hyperref[\detokenize{Exhaled/exhale_file_Setup.cpp:file-setup-cpp}]{\sphinxcrossref{\DUrole{std,std-ref}{File Setup.cpp}}}}

\end{itemize}
\index{checkSims (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_function_checkSims:_CPPv29checkSimsii6string}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{Exhaled/exhale_function_checkSims:NECSim_setup_8h_1ada6c0c991c61b74c5009ab414ef132f4}}\pysiglinewithargsret{bool \sphinxcode{}\sphinxbfcode{checkSims}}{int \sphinxstyleemphasis{the\_task}, int \sphinxstyleemphasis{the\_seed}, string \sphinxstyleemphasis{outdirect}}{}%
\pysigstopmultiline
Checks for previous simulations and resumes simulations if required. 

\begin{description}
\item[{\sphinxstylestrong{Return}}] \leavevmode
returns whether or not there is a file to be resumed from. 

\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{the\_task}: the task reference for reading the files 

\item {} 
\sphinxcode{the\_seed}: the seed reference 

\item {} 
\sphinxcode{outdirect}: the directory that the files were originally outputted to. 

\end{itemize}

\end{description}


\end{fulllineitems}



\paragraph{Function checkSpeciation}
\label{\detokenize{Exhaled/exhale_function_checkSpeciation::doc}}\label{\detokenize{Exhaled/exhale_function_checkSpeciation:function-checkspeciation}}\label{\detokenize{Exhaled/exhale_function_checkSpeciation:id1}}\begin{itemize}
\item {} 
Defined in {\hyperref[\detokenize{Exhaled/exhale_file_Treelist.cpp:file-treelist-cpp}]{\sphinxcrossref{\DUrole{std,std-ref}{File Treelist.cpp}}}}

\end{itemize}
\index{checkSpeciation (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_function_checkSpeciation:_CPPv215checkSpeciationeei}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{Exhaled/exhale_function_checkSpeciation:NECSim_treelist_8h_1ae5282a305ae38ce683dd9d4bada7112d}}\pysiglinewithargsret{bool \sphinxcode{}\sphinxbfcode{checkSpeciation}}{long double \sphinxstyleemphasis{random\_number}, long double \sphinxstyleemphasis{speciation\_rate}, int \sphinxstyleemphasis{number\_of\_generations}}{}%
\pysigstopmultiline
Checks whether speciation has occured for the provided parameters. Provided here for ease of use when bug-fixing. 

\begin{description}
\item[{\sphinxstylestrong{Return}}] \leavevmode
bool the speciation state of the lineage 

\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{random\_number}: the random number associated with a lineage 

\item {} 
\sphinxcode{speciation\_rate}: the global speciation rate 

\item {} 
\sphinxcode{number\_of\_generations}: the number of generations the lineage has existed 

\end{itemize}

\end{description}


\end{fulllineitems}



\paragraph{Function doesExist}
\label{\detokenize{Exhaled/exhale_function_doesExist::doc}}\label{\detokenize{Exhaled/exhale_function_doesExist:function-doesexist}}\label{\detokenize{Exhaled/exhale_function_doesExist:id1}}\begin{itemize}
\item {} 
Defined in {\hyperref[\detokenize{Exhaled/exhale_file_Setup.cpp:file-setup-cpp}]{\sphinxcrossref{\DUrole{std,std-ref}{File Setup.cpp}}}}

\end{itemize}
\index{doesExist (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_function_doesExist:_CPPv29doesExist6string}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{Exhaled/exhale_function_doesExist:NECSim_setup_8h_1af836e59d723600545dfdfe76b0c14b94}}\pysiglinewithargsret{bool \sphinxcode{}\sphinxbfcode{doesExist}}{string \sphinxstyleemphasis{testfile}}{}%
\pysigstopmultiline
Checks the existance of a file on the hard drive. 

\begin{description}
\item[{\sphinxstylestrong{Return}}] \leavevmode
if true, file exists 

\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{testfile}: the file to examine 

\end{itemize}

\end{description}


\end{fulllineitems}



\paragraph{Function doesExistNull}
\label{\detokenize{Exhaled/exhale_function_doesExistNull:function-doesexistnull}}\label{\detokenize{Exhaled/exhale_function_doesExistNull::doc}}\label{\detokenize{Exhaled/exhale_function_doesExistNull:id1}}\begin{itemize}
\item {} 
Defined in {\hyperref[\detokenize{Exhaled/exhale_file_Setup.cpp:file-setup-cpp}]{\sphinxcrossref{\DUrole{std,std-ref}{File Setup.cpp}}}}

\end{itemize}
\index{doesExistNull (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_function_doesExistNull:_CPPv213doesExistNull6string}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{Exhaled/exhale_function_doesExistNull:NECSim_setup_8h_1a0b70d536db024e2f65c377c02fa596ba}}\pysiglinewithargsret{bool \sphinxcode{}\sphinxbfcode{doesExistNull}}{string \sphinxstyleemphasis{testfile}}{}%
\pysigstopmultiline
Checks for the existance of a file, but returns true if the file name is `null'. Note: this function just calls doesExist(). 

\begin{description}
\item[{\sphinxstylestrong{Return}}] \leavevmode
if true, file exists (or is null). 

\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{testfile}: the file to examine 

\end{itemize}

\end{description}


\end{fulllineitems}



\paragraph{Function getSR}
\label{\detokenize{Exhaled/exhale_function_getSR:function-getsr}}\label{\detokenize{Exhaled/exhale_function_getSR::doc}}\label{\detokenize{Exhaled/exhale_function_getSR:id1}}\begin{itemize}
\item {} 
Defined in {\hyperref[\detokenize{Exhaled/exhale_file_Setup.cpp:file-setup-cpp}]{\sphinxcrossref{\DUrole{std,std-ref}{File Setup.cpp}}}}

\end{itemize}
\index{getSR (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_function_getSR:_CPPv25getSRiRK6vectorI6stringER4Tree}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{Exhaled/exhale_function_getSR:NECSim_setup_8h_1a6902d610cf1da84c91b19a55ab81f0d3}}\pysiglinewithargsret{void \sphinxcode{}\sphinxbfcode{getSR}}{int \sphinxstyleemphasis{argc}, \sphinxstrong{const} vector\textless{}string\textgreater{} \&\sphinxstyleemphasis{comargs}, {\hyperref[\detokenize{Exhaled/exhale_class_Tree:_CPPv24Tree}]{\sphinxcrossref{Tree}}} \&\sphinxstyleemphasis{t}}{}%
\pysigstopmultiline
Applies the speciation rates provided on the coalescence tree post-simulation. 

\begin{description}
\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{argc}: the number of arguments initially provided 

\item {} 
\sphinxcode{comargs}: a vector of command line arguments to parse. 

\item {} 
\sphinxcode{t}: a {\hyperref[\detokenize{Exhaled/exhale_class_Tree:NECSimclass_tree}]{\sphinxcrossref{\DUrole{std,std-ref}{Tree}}}} object containing the coalescence tree from a completed simulation. 

\end{itemize}

\end{description}


\end{fulllineitems}



\paragraph{Function importArgs}
\label{\detokenize{Exhaled/exhale_function_importArgs::doc}}\label{\detokenize{Exhaled/exhale_function_importArgs:function-importargs}}\label{\detokenize{Exhaled/exhale_function_importArgs:id1}}\begin{itemize}
\item {} 
Defined in {\hyperref[\detokenize{Exhaled/exhale_file_Config.cpp:file-config-cpp}]{\sphinxcrossref{\DUrole{std,std-ref}{File Config.cpp}}}}

\end{itemize}
\index{importArgs (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_function_importArgs:_CPPv210importArgsRKjA_PcR6vectorI6stringE}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{Exhaled/exhale_function_importArgs:NECSim_config_8h_1ab14ba2a8e5a50a5a24b48c45294ef483}}\pysiglinewithargsret{void \sphinxcode{}\sphinxbfcode{importArgs}}{\sphinxstrong{const} unsigned int \&\sphinxstyleemphasis{argc}, char *\sphinxstyleemphasis{argv}{[}{]}, vector\textless{}string\textgreater{} \&\sphinxstyleemphasis{comargs}}{}%
\pysigstopmultiline
Import the command line arguments in to the vector for future processing. Arguments will be placed in the vector comargs. 

\begin{description}
\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{argc}: the number of arguments. 

\item {} 
\sphinxcode{argv}: a point to the array of arguments in raw character form. 

\item {} 
\sphinxcode{comargs}: a vector of the command-line arguments to be filled. 

\end{itemize}

\end{description}


\end{fulllineitems}



\paragraph{Function importConfig}
\label{\detokenize{Exhaled/exhale_function_importConfig::doc}}\label{\detokenize{Exhaled/exhale_function_importConfig:function-importconfig}}\label{\detokenize{Exhaled/exhale_function_importConfig:id1}}\begin{itemize}
\item {} 
Defined in {\hyperref[\detokenize{Exhaled/exhale_file_Setup.cpp:file-setup-cpp}]{\sphinxcrossref{\DUrole{std,std-ref}{File Setup.cpp}}}}

\end{itemize}
\index{ConfigOption::importConfig (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_function_importConfig:_CPPv2N12ConfigOption12importConfigER6vectorI6stringE}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{Exhaled/exhale_function_importConfig:NECSimclass_config_option_1afbd1ed9d006c8ff48d90e63a57f55e2a}}\pysiglinewithargsret{int \sphinxcode{ConfigOption::}\sphinxbfcode{importConfig}}{vector\textless{}string\textgreater{} \&\sphinxstyleemphasis{comargs}}{}%
\pysigstopmultiline
Imports the parameters from the config file and returns an integer of the number of arguments. 

\begin{description}
\item[{\sphinxstylestrong{Return}}] \leavevmode
a count of the number of arguments (should also be the size of comargs). 

\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{comargs}: a vector of command line arguments to import to from file. 

\end{itemize}

\end{description}


\end{fulllineitems}



\paragraph{Function jobConvertor}
\label{\detokenize{Exhaled/exhale_function_jobConvertor:function-jobconvertor}}\label{\detokenize{Exhaled/exhale_function_jobConvertor::doc}}\label{\detokenize{Exhaled/exhale_function_jobConvertor:id1}}\begin{itemize}
\item {} 
Defined in {\hyperref[\detokenize{Exhaled/exhale_file_Setup.cpp:file-setup-cpp}]{\sphinxcrossref{\DUrole{std,std-ref}{File Setup.cpp}}}}

\end{itemize}
\index{jobConvertor (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_function_jobConvertor:_CPPv212jobConvertorPc}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{Exhaled/exhale_function_jobConvertor:NECSim_setup_8h_1a429e25f77967b5bad5d6739c1f014221}}\pysiglinewithargsret{long \sphinxcode{}\sphinxbfcode{jobConvertor}}{char *\sphinxstyleemphasis{argin}}{}%
\pysigstopmultiline
Converts the job character into a job number. 

\begin{description}
\item[{\sphinxstylestrong{Return}}] \leavevmode
the job integer. 

\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{argin}: the character to convert 

\end{itemize}

\end{description}


\end{fulllineitems}



\paragraph{Function main}
\label{\detokenize{Exhaled/exhale_function_main:id1}}\label{\detokenize{Exhaled/exhale_function_main::doc}}\label{\detokenize{Exhaled/exhale_function_main:function-main}}\begin{itemize}
\item {} 
Defined in {\hyperref[\detokenize{Exhaled/exhale_file_main.cpp:file-main-cpp}]{\sphinxcrossref{\DUrole{std,std-ref}{File main.cpp}}}}

\end{itemize}

\begin{sphinxadmonition}{warning}{Warning:}
doxygenfunction: Cannot find function ``main'' in doxygen xml output for project ``NECSim'' from directory: ../PyCoalescence/NECSim/Documentation/xml/
\end{sphinxadmonition}


\paragraph{Function openLogFile}
\label{\detokenize{Exhaled/exhale_function_openLogFile:function-openlogfile}}\label{\detokenize{Exhaled/exhale_function_openLogFile::doc}}\label{\detokenize{Exhaled/exhale_function_openLogFile:id1}}\begin{itemize}
\item {} 
Defined in {\hyperref[\detokenize{Exhaled/exhale_file_Setup.cpp:file-setup-cpp}]{\sphinxcrossref{\DUrole{std,std-ref}{File Setup.cpp}}}}

\end{itemize}
\index{openLogFile (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_function_openLogFile:_CPPv211openLogFileb}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{Exhaled/exhale_function_openLogFile:NECSim_setup_8h_1a25e6e7ae1e07841be7b7872521e8ad8b}}\pysiglinewithargsret{void \sphinxcode{}\sphinxbfcode{openLogFile}}{bool \sphinxstyleemphasis{append}}{}%
\pysigstopmultiline
Opens the log file for redirecting stdout. 

\begin{description}
\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{append}: if true, appends to the existing log file. 

\end{itemize}

\end{description}


\end{fulllineitems}



\paragraph{Function parseArgs}
\label{\detokenize{Exhaled/exhale_function_parseArgs:function-parseargs}}\label{\detokenize{Exhaled/exhale_function_parseArgs::doc}}\label{\detokenize{Exhaled/exhale_function_parseArgs:id1}}\begin{itemize}
\item {} 
Defined in {\hyperref[\detokenize{Exhaled/exhale_file_Setup.cpp:file-setup-cpp}]{\sphinxcrossref{\DUrole{std,std-ref}{File Setup.cpp}}}}

\end{itemize}
\index{parseArgs (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_function_parseArgs:_CPPv29parseArgsRiR6vectorI6stringE}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{Exhaled/exhale_function_parseArgs:NECSim_setup_8h_1ac55564867aba1c376e529cc2499fa6a5}}\pysiglinewithargsret{bool \sphinxcode{}\sphinxbfcode{parseArgs}}{int \&\sphinxstyleemphasis{argc}, vector\textless{}string\textgreater{} \&\sphinxstyleemphasis{comargs}}{}%
\pysigstopmultiline
Parse the command line parameters, taking in to account all the options for default runs, showing help options and importing from a config file. 

This version of the functions operates when infinite landscapes are not in order,

\begin{description}
\item[{\sphinxstylestrong{Return}}] \leavevmode
boolean set to true if the arguments are to be parsed in the new method. False for old, verbose method. 

\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{argc}: the number of arguments initially provided 

\item {} 
\sphinxcode{comargs}: a vector of command line arguments to parse. 

\end{itemize}

\end{description}


\end{fulllineitems}



\paragraph{Function removeComOption}
\label{\detokenize{Exhaled/exhale_function_removeComOption:function-removecomoption}}\label{\detokenize{Exhaled/exhale_function_removeComOption::doc}}\label{\detokenize{Exhaled/exhale_function_removeComOption:id1}}\begin{itemize}
\item {} 
Defined in {\hyperref[\detokenize{Exhaled/exhale_file_Setup.cpp:file-setup-cpp}]{\sphinxcrossref{\DUrole{std,std-ref}{File Setup.cpp}}}}

\end{itemize}
\index{removeComOption (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_function_removeComOption:_CPPv215removeComOptionRiR6vectorI6stringE}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{Exhaled/exhale_function_removeComOption:NECSim_setup_8h_1ad36797f569fd407030aa166b88eb4ae6}}\pysiglinewithargsret{void \sphinxcode{}\sphinxbfcode{removeComOption}}{int \&\sphinxstyleemphasis{argc}, vector\textless{}string\textgreater{} \&\sphinxstyleemphasis{comargs}}{}%
\pysigstopmultiline
Removes the command line options supplied, leaving just a clean vector with the correct data in. 

\end{fulllineitems}



\paragraph{Function runAsDefault}
\label{\detokenize{Exhaled/exhale_function_runAsDefault:function-runasdefault}}\label{\detokenize{Exhaled/exhale_function_runAsDefault::doc}}\label{\detokenize{Exhaled/exhale_function_runAsDefault:id1}}\begin{itemize}
\item {} 
Defined in {\hyperref[\detokenize{Exhaled/exhale_file_Setup.cpp:file-setup-cpp}]{\sphinxcrossref{\DUrole{std,std-ref}{File Setup.cpp}}}}

\end{itemize}
\index{runAsDefault (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_function_runAsDefault:_CPPv212runAsDefaultR6vectorI6stringE}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{Exhaled/exhale_function_runAsDefault:NECSim_setup_8h_1ae5f0fe9d930f0bf31869e95f1d284e73}}\pysiglinewithargsret{void \sphinxcode{}\sphinxbfcode{runAsDefault}}{vector\textless{}string\textgreater{} \&\sphinxstyleemphasis{comargs}}{}%
\pysigstopmultiline
Sets up the command-line arguments for default parameters. 

This is intended for testing purposes only. \begin{description}
\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{comargs}: a vector of command-line arguments for putting the parameters into. 

\end{itemize}

\end{description}


\end{fulllineitems}



\paragraph{Function runLarge}
\label{\detokenize{Exhaled/exhale_function_runLarge:function-runlarge}}\label{\detokenize{Exhaled/exhale_function_runLarge::doc}}\label{\detokenize{Exhaled/exhale_function_runLarge:id1}}\begin{itemize}
\item {} 
Defined in {\hyperref[\detokenize{Exhaled/exhale_file_Setup.cpp:file-setup-cpp}]{\sphinxcrossref{\DUrole{std,std-ref}{File Setup.cpp}}}}

\end{itemize}
\index{runLarge (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_function_runLarge:_CPPv28runLargeR6vectorI6stringE}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{Exhaled/exhale_function_runLarge:NECSim_setup_8h_1ae630bc537fa43724bcb8e13905640d4f}}\pysiglinewithargsret{void \sphinxcode{}\sphinxbfcode{runLarge}}{vector\textless{}string\textgreater{} \&\sphinxstyleemphasis{comargs}}{}%
\pysigstopmultiline
Sets up the command-line arguments for larger-scale default parameters. 

This is intended for testing purposes only. \begin{description}
\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{comargs}: a vector of command-line arguments for putting the parameters into. 

\end{itemize}

\end{description}


\end{fulllineitems}



\paragraph{Function runXL}
\label{\detokenize{Exhaled/exhale_function_runXL:function-runxl}}\label{\detokenize{Exhaled/exhale_function_runXL::doc}}\label{\detokenize{Exhaled/exhale_function_runXL:id1}}\begin{itemize}
\item {} 
Defined in {\hyperref[\detokenize{Exhaled/exhale_file_Setup.cpp:file-setup-cpp}]{\sphinxcrossref{\DUrole{std,std-ref}{File Setup.cpp}}}}

\end{itemize}
\index{runXL (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_function_runXL:_CPPv25runXLR6vectorI6stringE}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{Exhaled/exhale_function_runXL:NECSim_setup_8h_1ac712ff5a067a5d07f3b4c3dc6e5bfad1}}\pysiglinewithargsret{void \sphinxcode{}\sphinxbfcode{runXL}}{vector\textless{}string\textgreater{} \&\sphinxstyleemphasis{comargs}}{}%
\pysigstopmultiline
Sets up the command-line arguments for default very large scale parameters. 

This is intended for testing purposes only. \begin{description}
\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{comargs}: a vector of command-line arguments for putting the parameters into. 

\end{itemize}

\end{description}


\end{fulllineitems}



\subsubsection{Variables}
\label{\detokenize{Exhaled/exhaled_library:variables}}

\paragraph{Variable gdal\_data\_sizes}
\label{\detokenize{Exhaled/exhale_variable_gdal_data_sizes:variable-gdal-data-sizes}}\label{\detokenize{Exhaled/exhale_variable_gdal_data_sizes::doc}}\label{\detokenize{Exhaled/exhale_variable_gdal_data_sizes:id1}}\begin{itemize}
\item {} 
Defined in {\hyperref[\detokenize{Exhaled/exhale_file_Matrix.h:file-matrix-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File Matrix.h}}}}

\end{itemize}
\index{gdal\_data\_sizes (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_variable_gdal_data_sizes:_CPPv215gdal_data_sizes}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{Exhaled/exhale_variable_gdal_data_sizes:NECSim_matrix_8h_1a02aa962cfe49d9cc0a492fd0aaf74bd9}}\sphinxstrong{const} int \sphinxcode{}\sphinxbfcode{gdal\_data\_sizes}{[}{]} = \{0,8,16,16,32,32,32,64\}}%
\pysigstopmultiline
\end{fulllineitems}



\paragraph{Variable log\_name}
\label{\detokenize{Exhaled/exhale_variable_log_name::doc}}\label{\detokenize{Exhaled/exhale_variable_log_name:variable-log-name}}\label{\detokenize{Exhaled/exhale_variable_log_name:id1}}\begin{itemize}
\item {} 
Defined in {\hyperref[\detokenize{Exhaled/exhale_file_Setup.cpp:file-setup-cpp}]{\sphinxcrossref{\DUrole{std,std-ref}{File Setup.cpp}}}}

\end{itemize}
\index{log\_name (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_variable_log_name:_CPPv28log_name}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{Exhaled/exhale_variable_log_name:NECSim_setup_8h_1a2b3e7c0f4a5a17a01a5157ab01e59a60}}string \sphinxcode{}\sphinxbfcode{log\_name}}%
\pysigstopmultiline
\end{fulllineitems}



\paragraph{Variable saved\_stdout}
\label{\detokenize{Exhaled/exhale_variable_saved_stdout:id1}}\label{\detokenize{Exhaled/exhale_variable_saved_stdout::doc}}\label{\detokenize{Exhaled/exhale_variable_saved_stdout:variable-saved-stdout}}\begin{itemize}
\item {} 
Defined in {\hyperref[\detokenize{Exhaled/exhale_file_Setup.cpp:file-setup-cpp}]{\sphinxcrossref{\DUrole{std,std-ref}{File Setup.cpp}}}}

\end{itemize}
\index{saved\_stdout (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_variable_saved_stdout:_CPPv212saved_stdout}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{Exhaled/exhale_variable_saved_stdout:NECSim_setup_8h_1abc860612bcc3ce0f446f60f8314195d0}}int \sphinxcode{}\sphinxbfcode{saved\_stdout}}%
\pysigstopmultiline
\end{fulllineitems}



\subsubsection{Defines}
\label{\detokenize{Exhaled/exhaled_library:defines}}

\paragraph{Define AM}
\label{\detokenize{Exhaled/exhale_define_AM::doc}}\label{\detokenize{Exhaled/exhale_define_AM:define-am}}\label{\detokenize{Exhaled/exhale_define_AM:id1}}\begin{itemize}
\item {} 
Defined in {\hyperref[\detokenize{Exhaled/exhale_file_Fattaildeviate.h:file-fattaildeviate-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File Fattaildeviate.h}}}}

\end{itemize}
\index{AM (C macro)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_define_AM:c.AM}}\pysigline{\phantomsection\label{\detokenize{Exhaled/exhale_define_AM:NECSim_fattaildeviate_8h_1ad301e6a88b1c01108f4867f2ea6f683c}}\sphinxbfcode{AM}}
\end{fulllineitems}



\paragraph{Define EPS}
\label{\detokenize{Exhaled/exhale_define_EPS::doc}}\label{\detokenize{Exhaled/exhale_define_EPS:define-eps}}\label{\detokenize{Exhaled/exhale_define_EPS:id1}}\begin{itemize}
\item {} 
Defined in {\hyperref[\detokenize{Exhaled/exhale_file_Fattaildeviate.h:file-fattaildeviate-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File Fattaildeviate.h}}}}

\end{itemize}
\index{EPS (C macro)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_define_EPS:c.EPS}}\pysigline{\phantomsection\label{\detokenize{Exhaled/exhale_define_EPS:NECSim_fattaildeviate_8h_1a6ebf6899d6c1c8b7b9d09be872c05aae}}\sphinxbfcode{EPS}}
\end{fulllineitems}



\paragraph{Define IA1}
\label{\detokenize{Exhaled/exhale_define_IA1:define-ia1}}\label{\detokenize{Exhaled/exhale_define_IA1::doc}}\label{\detokenize{Exhaled/exhale_define_IA1:id1}}\begin{itemize}
\item {} 
Defined in {\hyperref[\detokenize{Exhaled/exhale_file_Fattaildeviate.h:file-fattaildeviate-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File Fattaildeviate.h}}}}

\end{itemize}
\index{IA1 (C macro)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_define_IA1:c.IA1}}\pysigline{\phantomsection\label{\detokenize{Exhaled/exhale_define_IA1:NECSim_fattaildeviate_8h_1a6ef2749dca39c605c3d033f788afe6e3}}\sphinxbfcode{IA1}}
\end{fulllineitems}



\paragraph{Define IA2}
\label{\detokenize{Exhaled/exhale_define_IA2:define-ia2}}\label{\detokenize{Exhaled/exhale_define_IA2::doc}}\label{\detokenize{Exhaled/exhale_define_IA2:id1}}\begin{itemize}
\item {} 
Defined in {\hyperref[\detokenize{Exhaled/exhale_file_Fattaildeviate.h:file-fattaildeviate-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File Fattaildeviate.h}}}}

\end{itemize}
\index{IA2 (C macro)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_define_IA2:c.IA2}}\pysigline{\phantomsection\label{\detokenize{Exhaled/exhale_define_IA2:NECSim_fattaildeviate_8h_1a372a58d7e9e25912fd79e7afaa06cc7a}}\sphinxbfcode{IA2}}
\end{fulllineitems}



\paragraph{Define IM1}
\label{\detokenize{Exhaled/exhale_define_IM1:id1}}\label{\detokenize{Exhaled/exhale_define_IM1::doc}}\label{\detokenize{Exhaled/exhale_define_IM1:define-im1}}\begin{itemize}
\item {} 
Defined in {\hyperref[\detokenize{Exhaled/exhale_file_Fattaildeviate.h:file-fattaildeviate-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File Fattaildeviate.h}}}}

\end{itemize}
\index{IM1 (C macro)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_define_IM1:c.IM1}}\pysigline{\phantomsection\label{\detokenize{Exhaled/exhale_define_IM1:NECSim_fattaildeviate_8h_1a78325bdf48423acef7c012567628b391}}\sphinxbfcode{IM1}}
\end{fulllineitems}



\paragraph{Define IM2}
\label{\detokenize{Exhaled/exhale_define_IM2:define-im2}}\label{\detokenize{Exhaled/exhale_define_IM2::doc}}\label{\detokenize{Exhaled/exhale_define_IM2:id1}}\begin{itemize}
\item {} 
Defined in {\hyperref[\detokenize{Exhaled/exhale_file_Fattaildeviate.h:file-fattaildeviate-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File Fattaildeviate.h}}}}

\end{itemize}
\index{IM2 (C macro)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_define_IM2:c.IM2}}\pysigline{\phantomsection\label{\detokenize{Exhaled/exhale_define_IM2:NECSim_fattaildeviate_8h_1ad8c519de7e5de4ae35344ddcf21fd062}}\sphinxbfcode{IM2}}
\end{fulllineitems}



\paragraph{Define IMM1}
\label{\detokenize{Exhaled/exhale_define_IMM1:define-imm1}}\label{\detokenize{Exhaled/exhale_define_IMM1::doc}}\label{\detokenize{Exhaled/exhale_define_IMM1:id1}}\begin{itemize}
\item {} 
Defined in {\hyperref[\detokenize{Exhaled/exhale_file_Fattaildeviate.h:file-fattaildeviate-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File Fattaildeviate.h}}}}

\end{itemize}
\index{IMM1 (C macro)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_define_IMM1:c.IMM1}}\pysigline{\phantomsection\label{\detokenize{Exhaled/exhale_define_IMM1:NECSim_fattaildeviate_8h_1a87a6e0054f9d827c979c43aa0d5e621a}}\sphinxbfcode{IMM1}}
\end{fulllineitems}



\paragraph{Define IQ1}
\label{\detokenize{Exhaled/exhale_define_IQ1:define-iq1}}\label{\detokenize{Exhaled/exhale_define_IQ1::doc}}\label{\detokenize{Exhaled/exhale_define_IQ1:id1}}\begin{itemize}
\item {} 
Defined in {\hyperref[\detokenize{Exhaled/exhale_file_Fattaildeviate.h:file-fattaildeviate-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File Fattaildeviate.h}}}}

\end{itemize}
\index{IQ1 (C macro)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_define_IQ1:c.IQ1}}\pysigline{\phantomsection\label{\detokenize{Exhaled/exhale_define_IQ1:NECSim_fattaildeviate_8h_1a9afa86ff22da69bda72fe271ae71ad46}}\sphinxbfcode{IQ1}}
\end{fulllineitems}



\paragraph{Define IQ2}
\label{\detokenize{Exhaled/exhale_define_IQ2:define-iq2}}\label{\detokenize{Exhaled/exhale_define_IQ2::doc}}\label{\detokenize{Exhaled/exhale_define_IQ2:id1}}\begin{itemize}
\item {} 
Defined in {\hyperref[\detokenize{Exhaled/exhale_file_Fattaildeviate.h:file-fattaildeviate-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File Fattaildeviate.h}}}}

\end{itemize}
\index{IQ2 (C macro)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_define_IQ2:c.IQ2}}\pysigline{\phantomsection\label{\detokenize{Exhaled/exhale_define_IQ2:NECSim_fattaildeviate_8h_1abae040385946a6acdf5e10d2efd86f3d}}\sphinxbfcode{IQ2}}
\end{fulllineitems}



\paragraph{Define IR1}
\label{\detokenize{Exhaled/exhale_define_IR1:define-ir1}}\label{\detokenize{Exhaled/exhale_define_IR1::doc}}\label{\detokenize{Exhaled/exhale_define_IR1:id1}}\begin{itemize}
\item {} 
Defined in {\hyperref[\detokenize{Exhaled/exhale_file_Fattaildeviate.h:file-fattaildeviate-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File Fattaildeviate.h}}}}

\end{itemize}
\index{IR1 (C macro)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_define_IR1:c.IR1}}\pysigline{\phantomsection\label{\detokenize{Exhaled/exhale_define_IR1:NECSim_fattaildeviate_8h_1a7b2b32709f9770a283701ffcf3723497}}\sphinxbfcode{IR1}}
\end{fulllineitems}



\paragraph{Define IR2}
\label{\detokenize{Exhaled/exhale_define_IR2:define-ir2}}\label{\detokenize{Exhaled/exhale_define_IR2::doc}}\label{\detokenize{Exhaled/exhale_define_IR2:id1}}\begin{itemize}
\item {} 
Defined in {\hyperref[\detokenize{Exhaled/exhale_file_Fattaildeviate.h:file-fattaildeviate-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File Fattaildeviate.h}}}}

\end{itemize}
\index{IR2 (C macro)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_define_IR2:c.IR2}}\pysigline{\phantomsection\label{\detokenize{Exhaled/exhale_define_IR2:NECSim_fattaildeviate_8h_1a5a08e4f5cb3582e623cc14a6c92d48de}}\sphinxbfcode{IR2}}
\end{fulllineitems}



\paragraph{Define MATRIX}
\label{\detokenize{Exhaled/exhale_define_MATRIX:define-matrix}}\label{\detokenize{Exhaled/exhale_define_MATRIX::doc}}\label{\detokenize{Exhaled/exhale_define_MATRIX:id1}}\begin{itemize}
\item {} 
Defined in {\hyperref[\detokenize{Exhaled/exhale_file_Matrix.h:file-matrix-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File Matrix.h}}}}

\end{itemize}
\index{MATRIX (C macro)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_define_MATRIX:c.MATRIX}}\pysigline{\phantomsection\label{\detokenize{Exhaled/exhale_define_MATRIX:NECSim_matrix_8h_1af1d98fb728b5c7300f80dd782702d1dd}}\sphinxbfcode{MATRIX}}
\end{fulllineitems}



\paragraph{Define NDIV}
\label{\detokenize{Exhaled/exhale_define_NDIV::doc}}\label{\detokenize{Exhaled/exhale_define_NDIV:define-ndiv}}\label{\detokenize{Exhaled/exhale_define_NDIV:id1}}\begin{itemize}
\item {} 
Defined in {\hyperref[\detokenize{Exhaled/exhale_file_Fattaildeviate.h:file-fattaildeviate-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File Fattaildeviate.h}}}}

\end{itemize}
\index{NDIV (C macro)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_define_NDIV:c.NDIV}}\pysigline{\phantomsection\label{\detokenize{Exhaled/exhale_define_NDIV:NECSim_fattaildeviate_8h_1a62339d74dd5d9d00480e1a288cf88fe8}}\sphinxbfcode{NDIV}}
\end{fulllineitems}



\paragraph{Define NTAB}
\label{\detokenize{Exhaled/exhale_define_NTAB:define-ntab}}\label{\detokenize{Exhaled/exhale_define_NTAB::doc}}\label{\detokenize{Exhaled/exhale_define_NTAB:id1}}\begin{itemize}
\item {} 
Defined in {\hyperref[\detokenize{Exhaled/exhale_file_Fattaildeviate.h:file-fattaildeviate-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File Fattaildeviate.h}}}}

\end{itemize}
\index{NTAB (C macro)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_define_NTAB:c.NTAB}}\pysigline{\phantomsection\label{\detokenize{Exhaled/exhale_define_NTAB:NECSim_fattaildeviate_8h_1a0e93cfb2d62849853fd34957ba6e6fdc}}\sphinxbfcode{NTAB}}
\end{fulllineitems}



\paragraph{Define null}
\label{\detokenize{Exhaled/exhale_define_null:define-null}}\label{\detokenize{Exhaled/exhale_define_null::doc}}\label{\detokenize{Exhaled/exhale_define_null:id1}}\begin{itemize}
\item {} 
Defined in {\hyperref[\detokenize{Exhaled/exhale_file_Matrix.h:file-matrix-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File Matrix.h}}}}

\end{itemize}
\index{null (C macro)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_define_null:c.null}}\pysigline{\phantomsection\label{\detokenize{Exhaled/exhale_define_null:NECSim_matrix_8h_1ac97b8ee753e4405397a42ad5799b0f9e}}\sphinxbfcode{null}}
\end{fulllineitems}



\paragraph{Define RNMX}
\label{\detokenize{Exhaled/exhale_define_RNMX::doc}}\label{\detokenize{Exhaled/exhale_define_RNMX:define-rnmx}}\label{\detokenize{Exhaled/exhale_define_RNMX:id1}}\begin{itemize}
\item {} 
Defined in {\hyperref[\detokenize{Exhaled/exhale_file_Fattaildeviate.h:file-fattaildeviate-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File Fattaildeviate.h}}}}

\end{itemize}
\index{RNMX (C macro)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_define_RNMX:c.RNMX}}\pysigline{\phantomsection\label{\detokenize{Exhaled/exhale_define_RNMX:NECSim_fattaildeviate_8h_1aa7436c9270ffb06f8c1eae8d2e605cec}}\sphinxbfcode{RNMX}}
\end{fulllineitems}



\paragraph{Define sql\_ram}
\label{\detokenize{Exhaled/exhale_define_sql_ram:define-sql-ram}}\label{\detokenize{Exhaled/exhale_define_sql_ram::doc}}\label{\detokenize{Exhaled/exhale_define_sql_ram:id1}}\begin{itemize}
\item {} 
Defined in {\hyperref[\detokenize{Exhaled/exhale_file_Tree.h:file-tree-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File Tree.h}}}}

\end{itemize}
\index{sql\_ram (C macro)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_define_sql_ram:c.sql_ram}}\pysigline{\phantomsection\label{\detokenize{Exhaled/exhale_define_sql_ram:NECSimgroup___d_e_f_i_n_e_s_1ga063c2e626b5c0dcf65522d05574349a6}}\sphinxbfcode{sql\_ram}}
Macro for using the fast-cpp-csv-parser from Ben Strasser (available from \url{https://github.com/ben-strasser/fast-cpp-csv-parser}). This enables much faster csv reading, but can cause problems on systems where this module is not fully tested.

Macro to compile using RAM for storage of the active SQL database. Without this, the database will be written directly to disc (which is slower, but an option if RAM requirements get too huge). For HPC systems, it is recommended to use this option as write speeds are generally fast and large simulations don't have a linear increase in the SQL database size (at least in RAM). 

\end{fulllineitems}



\paragraph{Define version1\_01}
\label{\detokenize{Exhaled/exhale_define_version1_01:define-version1-01}}\label{\detokenize{Exhaled/exhale_define_version1_01::doc}}\label{\detokenize{Exhaled/exhale_define_version1_01:id1}}\begin{itemize}
\item {} 
Defined in {\hyperref[\detokenize{Exhaled/exhale_file_Datapoint.h:file-datapoint-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File Datapoint.h}}}}

\end{itemize}
\index{version1\_01 (C macro)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_define_version1_01:c.version1_01}}\pysigline{\phantomsection\label{\detokenize{Exhaled/exhale_define_version1_01:NECSim_datapoint_8h_1aca2ccda620c3127230016731afffa03d}}\sphinxbfcode{version1\_01}}
\end{fulllineitems}



\paragraph{Define version1\_11}
\label{\detokenize{Exhaled/exhale_define_version1_11:define-version1-11}}\label{\detokenize{Exhaled/exhale_define_version1_11::doc}}\label{\detokenize{Exhaled/exhale_define_version1_11:id1}}\begin{itemize}
\item {} 
Defined in {\hyperref[\detokenize{Exhaled/exhale_file_Matrix.h:file-matrix-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File Matrix.h}}}}

\end{itemize}
\index{version1\_11 (C macro)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Exhaled/exhale_define_version1_11:c.version1_11}}\pysigline{\phantomsection\label{\detokenize{Exhaled/exhale_define_version1_11:NECSim_matrix_8h_1ab5df3db6024502bad57208775401ad6c}}\sphinxbfcode{version1\_11}}
\end{fulllineitems}



\subsubsection{Files}
\label{\detokenize{Exhaled/exhaled_library:files}}

\paragraph{File Config.cpp}
\label{\detokenize{Exhaled/exhale_file_Config.cpp::doc}}\label{\detokenize{Exhaled/exhale_file_Config.cpp:file-config-cpp}}\label{\detokenize{Exhaled/exhale_file_Config.cpp:id1}}

\subparagraph{Definition (\sphinxstyleliteralintitle{Config.cpp})}
\label{\detokenize{Exhaled/exhale_file_Config.cpp:definition-config-cpp}}

\subparagraph{Program Listing for File Config.cpp}
\label{\detokenize{Exhaled/exhale_program_listing_file_Config.cpp:program-listing-for-file-config-cpp}}\label{\detokenize{Exhaled/exhale_program_listing_file_Config.cpp::doc}}\label{\detokenize{Exhaled/exhale_program_listing_file_Config.cpp:program-listing-file-config-cpp}}\begin{itemize}
\item {} 
Return to documentation for {\hyperref[\detokenize{Exhaled/exhale_file_Config.cpp:file-config-cpp}]{\sphinxcrossref{\DUrole{std,std-ref}{File Config.cpp}}}}

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{//This file is part of NECSim project which is released under BSD\PYGZhy{}3 license.}
\PYG{c+c1}{//See file **LICENSE.txt** or visit https://opensource.org/licenses/BSD\PYGZhy{}3\PYGZhy{}Clause) for full license details.}
\PYG{c+c1}{//}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZdq{}Config.h\PYGZdq{}}
\PYG{k+kt}{void} \PYG{n+nf}{importArgs}\PYG{p}{(}\PYG{k}{const} \PYG{k+kt}{unsigned} \PYG{k+kt}{int}\PYG{o}{\PYGZam{}} \PYG{n}{argc}\PYG{p}{,} \PYG{k+kt}{char}\PYG{o}{*} \PYG{n}{argv} \PYG{p}{[}\PYG{p}{]}\PYG{p}{,} \PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{n}{string}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZam{}} \PYG{n}{comargs}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{argc}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{comargs}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{n}{string}\PYG{p}{(}\PYG{n}{argv}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{c+c1}{// check size is correct}
    \PYG{k}{if}\PYG{p}{(}\PYG{n}{comargs}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)} \PYG{o}{!}\PYG{o}{=} \PYG{n}{argc}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{cerr} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ERROR\PYGZus{}MAIN\PYGZus{}010: Incorrect command line parsing.}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}


\subparagraph{Includes}
\label{\detokenize{Exhaled/exhale_file_Config.cpp:includes}}\begin{itemize}
\item {} 
\sphinxcode{Config.h} ({\hyperref[\detokenize{Exhaled/exhale_file_Config.h:file-config-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File Config.h}}}})

\end{itemize}


\subparagraph{Functions}
\label{\detokenize{Exhaled/exhale_file_Config.cpp:functions}}\begin{itemize}
\item {} 
{\hyperref[\detokenize{Exhaled/exhale_function_importArgs:function-importargs}]{\sphinxcrossref{\DUrole{std,std-ref}{Function importArgs}}}}

\end{itemize}


\paragraph{File Config.h}
\label{\detokenize{Exhaled/exhale_file_Config.h:id1}}\label{\detokenize{Exhaled/exhale_file_Config.h::doc}}\label{\detokenize{Exhaled/exhale_file_Config.h:file-config-h}}

\subparagraph{Definition (\sphinxstyleliteralintitle{Config.h})}
\label{\detokenize{Exhaled/exhale_file_Config.h:definition-config-h}}

\subparagraph{Program Listing for File Config.h}
\label{\detokenize{Exhaled/exhale_program_listing_file_Config.h:program-listing-for-file-config-h}}\label{\detokenize{Exhaled/exhale_program_listing_file_Config.h::doc}}\label{\detokenize{Exhaled/exhale_program_listing_file_Config.h:program-listing-file-config-h}}\begin{itemize}
\item {} 
Return to documentation for {\hyperref[\detokenize{Exhaled/exhale_file_Config.h:file-config-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File Config.h}}}}

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{// This file is part of NECSim project which is released under BSD\PYGZhy{}3 license.}
\PYG{c+c1}{// See file **LICENSE.txt** or visit https://opensource.org/licenses/BSD\PYGZhy{}3\PYGZhy{}Clause) for full license details.}
\PYG{c+c1}{//}
\PYG{c+c1}{// Header guard}
\PYG{c+c1}{//}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifndef CONFIGCLASS}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define CONFIGCLASS}

\PYG{c+cm}{/************************************************************}
\PYG{c+cm}{                                                                                                                                                                                                INCLUDES}
\PYG{c+cm}{ ************************************************************/}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}string\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}iostream\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}sstream\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}fstream\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}stdexcept\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}vector\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}cstring\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}unistd.h\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}cmath\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}cctype\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}algorithm\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZdq{}CustomExceptions.h\PYGZdq{}}
\PYG{k}{using} \PYG{k}{namespace} \PYG{n}{std}\PYG{p}{;}
\PYG{k}{using} \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{string}\PYG{p}{;}
\PYG{k+kt}{void} \PYG{n+nf}{importArgs}\PYG{p}{(}\PYG{k}{const} \PYG{k+kt}{unsigned} \PYG{k+kt}{int}\PYG{o}{\PYGZam{}} \PYG{n}{argc}\PYG{p}{,} \PYG{k+kt}{char}\PYG{o}{*} \PYG{n}{argv}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,} \PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{n}{string}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZam{}} \PYG{n}{comargs}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{//}

\PYG{k}{struct} \PYG{n}{SectionOption}
\PYG{p}{\PYGZob{}}
    \PYG{n}{string} \PYG{n}{section}\PYG{p}{;}
    \PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{n}{string}\PYG{o}{\PYGZgt{}} \PYG{n}{val}\PYG{p}{;}
    \PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{n}{string}\PYG{o}{\PYGZgt{}} \PYG{n}{refs}\PYG{p}{;}

    \PYG{n}{string} \PYG{n+nf}{getOption}\PYG{p}{(}\PYG{n}{string} \PYG{n}{refval}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
    \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{refs}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{refs}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{=}\PYG{o}{=} \PYG{n}{refval}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
            \PYG{k}{return} \PYG{p}{(}\PYG{n}{val}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
        \PYG{p}{\PYGZcb{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifdef DEBUG}
    \PYG{n}{cerr} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Reference not found in keyoption.}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif}
    \PYG{k}{return} \PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{null}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{k}{friend} \PYG{n}{ostream}\PYG{o}{\PYGZam{}} \PYG{k}{operator}\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{p}{(}\PYG{n}{ostream}\PYG{o}{\PYGZam{}} \PYG{n}{os}\PYG{p}{,} \PYG{k}{const} \PYG{n}{SectionOption}\PYG{o}{\PYGZam{}} \PYG{n}{k}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
    \PYG{n}{os} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{k}\PYG{p}{.}\PYG{n}{section} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{k}\PYG{p}{.}\PYG{n}{val}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{k}\PYG{p}{.}\PYG{n}{refs}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
    \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{k}\PYG{p}{.}\PYG{n}{val}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
        \PYG{n}{os} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{k}\PYG{p}{.}\PYG{n}{val}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
    \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{k}\PYG{p}{.}\PYG{n}{refs}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
        \PYG{n}{os} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{k}\PYG{p}{.}\PYG{n}{refs}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
    \PYG{k}{return} \PYG{n}{os}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{k}{friend} \PYG{n}{istream}\PYG{o}{\PYGZam{}} \PYG{k}{operator}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{n}{istream}\PYG{o}{\PYGZam{}} \PYG{n}{is}\PYG{p}{,} \PYG{n}{SectionOption}\PYG{o}{\PYGZam{}} \PYG{n}{k}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
    \PYG{c+c1}{// os \PYGZlt{}\PYGZlt{} m.numRows\PYGZlt{}\PYGZlt{}\PYGZdq{} , \PYGZdq{}\PYGZlt{}\PYGZlt{}m.numCols\PYGZlt{}\PYGZlt{}\PYGZdq{} , \PYGZdq{}\PYGZlt{}\PYGZlt{}endl;}
    \PYG{k+kt}{unsigned} \PYG{k+kt}{int} \PYG{n}{valsize}\PYG{p}{,} \PYG{n}{refsize}\PYG{p}{;}
    \PYG{n}{is} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{k}\PYG{p}{.}\PYG{n}{section} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{valsize} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{refsize}\PYG{p}{;}
    \PYG{n}{string} \PYG{n}{tmp}\PYG{p}{;}
    \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{valsize}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
        \PYG{n}{is} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{tmp}\PYG{p}{;}
        \PYG{n}{k}\PYG{p}{.}\PYG{n}{val}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{n}{tmp}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
    \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{refsize}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
        \PYG{n}{is} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{tmp}\PYG{p}{;}
        \PYG{n}{k}\PYG{p}{.}\PYG{n}{refs}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{n}{tmp}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
    \PYG{k}{return} \PYG{n}{is}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}

\PYG{k}{class} \PYG{n+nc}{ConfigOption}
\PYG{p}{\PYGZob{}}
   \PYG{k}{private}\PYG{o}{:}
    \PYG{n}{string} \PYG{n}{configfile}\PYG{p}{;}
    \PYG{k+kt}{bool} \PYG{n}{bConfig}\PYG{p}{;}
    \PYG{k+kt}{bool} \PYG{n}{bMain}\PYG{p}{;}  \PYG{c+c1}{// is true if this is the main command line import (and therefore we want to delete the first few}
    \PYG{c+c1}{// command line options)}
    \PYG{k+kt}{bool} \PYG{n}{bFullParse}\PYG{p}{;}  \PYG{c+c1}{// if this is true, each KeyOption structure will be returned after each read.}
    \PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{n}{SectionOption}\PYG{o}{\PYGZgt{}} \PYG{n}{configs}\PYG{p}{;}  \PYG{c+c1}{// all config data if full parse is true.}
   \PYG{k}{public}\PYG{o}{:}
    \PYG{n}{ConfigOption}\PYG{p}{(}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
    \PYG{n}{bConfig} \PYG{o}{=} \PYG{n+nb}{false}\PYG{p}{;}
    \PYG{n}{configfile} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{none}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{n}{string} \PYG{n}{getFile}\PYG{p}{(}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{return} \PYG{n}{configfile}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{k+kt}{bool} \PYG{n}{getMain}\PYG{p}{(}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{return} \PYG{n}{bMain}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{k+kt}{bool} \PYG{n}{getFull}\PYG{p}{(}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{return} \PYG{n}{bFullParse}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{k+kt}{void} \PYG{n}{setConfig}\PYG{p}{(}\PYG{n}{string} \PYG{n}{file}\PYG{p}{,} \PYG{k+kt}{bool} \PYG{n}{main}\PYG{p}{,} \PYG{k+kt}{bool} \PYG{n}{full\PYGZus{}parse} \PYG{o}{=} \PYG{n+nb}{false}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{if}\PYG{p}{(}\PYG{o}{!}\PYG{n}{bConfig}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{bMain} \PYG{o}{=} \PYG{n}{main}\PYG{p}{;}
            \PYG{n}{configfile} \PYG{o}{=} \PYG{n}{file}\PYG{p}{;}
            \PYG{n}{bConfig} \PYG{o}{=} \PYG{n+nb}{true}\PYG{p}{;}
            \PYG{n}{bFullParse} \PYG{o}{=} \PYG{n}{full\PYGZus{}parse}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{else}
        \PYG{p}{\PYGZob{}}
            \PYG{k}{throw} \PYG{n}{Config\PYGZus{}Exception}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Attempt to set config file twice.}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
    \PYG{p}{\PYGZcb{}}

    \PYG{k+kt}{void} \PYG{n}{parseConfig}\PYG{p}{(}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{ifstream} \PYG{n}{is\PYGZus{}file}\PYG{p}{;}
        \PYG{k}{try}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{is\PYGZus{}file}\PYG{p}{.}\PYG{n}{open}\PYG{p}{(}\PYG{n}{configfile}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{catch}\PYG{p}{(}\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{k}{throw} \PYG{n}{Config\PYGZus{}Exception}\PYG{p}{(}
                \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ERROR\PYGZus{}CONF\PYGZus{}004c: Could not open the config file. Check file exists and is readable.}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{if}\PYG{p}{(}\PYG{o}{!}\PYG{n}{is\PYGZus{}file}\PYG{p}{.}\PYG{n}{fail}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{string} \PYG{n}{line}\PYG{p}{;}
            \PYG{c+c1}{// Get the first line of the file.}
            \PYG{k}{while}\PYG{p}{(}\PYG{n}{getline}\PYG{p}{(}\PYG{n}{is\PYGZus{}file}\PYG{p}{,} \PYG{n}{line}\PYG{p}{)}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
\PYG{c+c1}{//              cout \PYGZlt{}\PYGZlt{} line \PYGZlt{}\PYGZlt{} endl;}
                \PYG{n}{istringstream} \PYG{n}{is\PYGZus{}line}\PYG{p}{(}\PYG{n}{line}\PYG{p}{)}\PYG{p}{;}
                \PYG{n}{string} \PYG{n}{key}\PYG{p}{;}
                \PYG{n}{string} \PYG{n}{val}\PYG{p}{;}
                \PYG{c+c1}{// Skip all whitespace}
                \PYG{n}{is\PYGZus{}line} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{skipws}\PYG{p}{;}
                \PYG{c+c1}{// start a new section}
                \PYG{k}{if}\PYG{p}{(}\PYG{n}{line}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{=}\PYG{o}{=} \PYG{l+s+sc}{\PYGZsq{}}\PYG{l+s+sc}{[}\PYG{l+s+sc}{\PYGZsq{}}\PYG{p}{)}
                \PYG{p}{\PYGZob{}}
                    \PYG{n}{SectionOption} \PYG{n}{tempSections}\PYG{p}{;}
                    \PYG{c+c1}{// get the section name}
                    \PYG{n}{string} \PYG{n}{section}\PYG{p}{;}
                    \PYG{k}{if}\PYG{p}{(}\PYG{n}{getline}\PYG{p}{(}\PYG{n}{is\PYGZus{}line}\PYG{p}{,} \PYG{n}{section}\PYG{p}{,} \PYG{l+s+sc}{\PYGZsq{}}\PYG{l+s+sc}{]}\PYG{l+s+sc}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{)}
                    \PYG{p}{\PYGZob{}}
                        \PYG{n}{section} \PYG{o}{=} \PYG{n}{section}\PYG{p}{.}\PYG{n}{erase}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
                        \PYG{n}{tempSections}\PYG{p}{.}\PYG{n}{section} \PYG{o}{=} \PYG{n}{section}\PYG{p}{;}
\PYG{c+c1}{//                      cout \PYGZlt{}\PYGZlt{} section \PYGZlt{}\PYGZlt{} endl;}
                    \PYG{p}{\PYGZcb{}}
                    \PYG{c+c1}{// read each line}
                    \PYG{k}{while}\PYG{p}{(}\PYG{n}{getline}\PYG{p}{(}\PYG{n}{is\PYGZus{}file}\PYG{p}{,} \PYG{n}{line}\PYG{p}{)}\PYG{p}{)}
                    \PYG{p}{\PYGZob{}}
                        \PYG{c+c1}{// end the section when a new one starts.}
                        \PYG{k}{if}\PYG{p}{(}\PYG{n}{line}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{=}\PYG{o}{=} \PYG{l+s+sc}{\PYGZsq{}}\PYG{l+s+sc}{[}\PYG{l+s+sc}{\PYGZsq{}} \PYG{o}{\textbar{}}\PYG{o}{\textbar{}} \PYG{n}{line}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)}
                        \PYG{p}{\PYGZob{}}
                            \PYG{k}{break}\PYG{p}{;}
                        \PYG{p}{\PYGZcb{}}
                        \PYG{n}{istringstream} \PYG{n}{is\PYGZus{}line2}\PYG{p}{(}\PYG{n}{line}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{// update the input\PYGZhy{}line stream}
                        \PYG{k}{if}\PYG{p}{(}\PYG{n}{getline}\PYG{p}{(}\PYG{n}{is\PYGZus{}line2}\PYG{p}{,} \PYG{n}{key}\PYG{p}{,} \PYG{l+s+sc}{\PYGZsq{}}\PYG{l+s+sc}{=}\PYG{l+s+sc}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{)}
                        \PYG{p}{\PYGZob{}}
                            \PYG{n}{key}\PYG{p}{.}\PYG{n}{erase}\PYG{p}{(}\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{remove}\PYG{p}{(}\PYG{n}{key}\PYG{p}{.}\PYG{n}{begin}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{n}{key}\PYG{p}{.}\PYG{n}{end}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{l+s+sc}{\PYGZsq{}}\PYG{l+s+sc}{ }\PYG{l+s+sc}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{,} \PYG{n}{key}\PYG{p}{.}\PYG{n}{end}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
                            \PYG{n}{is\PYGZus{}line2} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{skipws}\PYG{p}{;}
                        \PYG{p}{\PYGZcb{}}
                        \PYG{k}{if}\PYG{p}{(}\PYG{o}{!}\PYG{n}{is\PYGZus{}line2}\PYG{p}{)}
                        \PYG{p}{\PYGZob{}}
\PYG{c+c1}{//                          cout \PYGZlt{}\PYGZlt{} is\PYGZus{}line2 \PYGZlt{}\PYGZlt{} endl;}
                            \PYG{k}{throw} \PYG{n}{Config\PYGZus{}Exception}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ERROR\PYGZus{}CONF\PYGZus{}001: Read error in config file.}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
                        \PYG{p}{\PYGZcb{}}
                        \PYG{k}{if}\PYG{p}{(}\PYG{n}{getline}\PYG{p}{(}\PYG{n}{is\PYGZus{}line2}\PYG{p}{,} \PYG{n}{val}\PYG{p}{)}\PYG{p}{)}
                        \PYG{p}{\PYGZob{}}
                            \PYG{n}{val}\PYG{p}{.}\PYG{n}{erase}\PYG{p}{(}\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{remove}\PYG{p}{(}\PYG{n}{val}\PYG{p}{.}\PYG{n}{begin}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{n}{val}\PYG{p}{.}\PYG{n}{end}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{l+s+sc}{\PYGZsq{}}\PYG{l+s+sc}{ }\PYG{l+s+sc}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{,} \PYG{n}{val}\PYG{p}{.}\PYG{n}{end}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
                        \PYG{p}{\PYGZcb{}}
                        \PYG{k}{if}\PYG{p}{(}\PYG{o}{!}\PYG{n}{is\PYGZus{}line2}\PYG{p}{)}
                        \PYG{p}{\PYGZob{}}
                            \PYG{k}{throw} \PYG{n}{Config\PYGZus{}Exception}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ERROR\PYGZus{}CONF\PYGZus{}001: Read error in config file.}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
                        \PYG{p}{\PYGZcb{}}
                        \PYG{n}{tempSections}\PYG{p}{.}\PYG{n}{refs}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{n}{key}\PYG{p}{)}\PYG{p}{;}
                        \PYG{n}{tempSections}\PYG{p}{.}\PYG{n}{val}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{n}{val}\PYG{p}{)}\PYG{p}{;}
                    \PYG{p}{\PYGZcb{}}
                    \PYG{n}{configs}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{n}{tempSections}\PYG{p}{)}\PYG{p}{;}
                \PYG{p}{\PYGZcb{}}
            \PYG{p}{\PYGZcb{}}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{else}
        \PYG{p}{\PYGZob{}}
            \PYG{k}{throw} \PYG{n}{Config\PYGZus{}Exception}\PYG{p}{(}
                \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ERROR\PYGZus{}CONF\PYGZus{}004b: Could not open the config file. Check file exists and is readable.}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{is\PYGZus{}file}\PYG{p}{.}\PYG{n}{eof}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{is\PYGZus{}file}\PYG{p}{.}\PYG{n}{close}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{else}
        \PYG{p}{\PYGZob{}}
            \PYG{k}{throw} \PYG{n}{Config\PYGZus{}Exception}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ERROR\PYGZus{}CONF\PYGZus{}002: End of file not reached. Check input file formating.}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
    \PYG{p}{\PYGZcb{}}

    \PYG{k+kt}{void} \PYG{n}{testPrint}\PYG{p}{(}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{configs}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
        \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{configs}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{configs}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{section} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
            \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{n}{j} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{j} \PYG{o}{\PYGZlt{}} \PYG{n}{configs}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{refs}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{n}{j}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{configs}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{refs}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{configs}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{val}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ , }\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
            \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
    \PYG{p}{\PYGZcb{}}
    \PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{n}{SectionOption}\PYG{o}{\PYGZgt{}} \PYG{n}{getSectionOptions}\PYG{p}{(}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{return} \PYG{n}{configs}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{n}{SectionOption} \PYG{k}{operator}\PYG{p}{[}\PYG{p}{]}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{index}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{return} \PYG{p}{(}\PYG{n}{configs}\PYG{p}{[}\PYG{n}{index}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{k+kt}{unsigned} \PYG{k+kt}{int} \PYG{n}{getSectionOptionsSize}\PYG{p}{(}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{return} \PYG{p}{(}\PYG{n}{configs}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{n}{string}\PYG{o}{\PYGZgt{}} \PYG{n}{getSections}\PYG{p}{(}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{n}{string}\PYG{o}{\PYGZgt{}} \PYG{n}{toret}\PYG{p}{;}
        \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{configs}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{n}{i} \PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{toret}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{n}{configs}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{section}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{return}\PYG{p}{(}\PYG{n}{toret}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{k+kt}{bool} \PYG{n}{hasSection}\PYG{p}{(}\PYG{n}{string} \PYG{n}{sec}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{configs}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{k}{if}\PYG{p}{(}\PYG{n}{configs}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{section} \PYG{o}{=}\PYG{o}{=} \PYG{n}{sec}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{k}{return}\PYG{p}{(}\PYG{n+nb}{true}\PYG{p}{)}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{return}\PYG{p}{(}\PYG{n+nb}{false}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{n}{string}\PYG{o}{\PYGZgt{}} \PYG{n}{getSectionValues}\PYG{p}{(}\PYG{n}{string} \PYG{n}{sec}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{configs}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{k}{if}\PYG{p}{(}\PYG{n}{configs}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{section} \PYG{o}{=}\PYG{o}{=} \PYG{n}{sec}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{k}{return}\PYG{p}{(}\PYG{n}{configs}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{val}\PYG{p}{)}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{throw} \PYG{n}{Config\PYGZus{}Exception}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Section not found in config file: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{+} \PYG{n}{sec}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{n}{string} \PYG{n}{getSectionOptions}\PYG{p}{(}\PYG{n}{string} \PYG{n}{section}\PYG{p}{,} \PYG{n}{string} \PYG{n}{ref}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{configs}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{k}{if}\PYG{p}{(}\PYG{n}{configs}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{section} \PYG{o}{=}\PYG{o}{=} \PYG{n}{section}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{int} \PYG{n}{j} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{j} \PYG{o}{\PYGZlt{}} \PYG{n}{configs}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{refs}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{n}{j}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
                \PYG{p}{\PYGZob{}}
                    \PYG{k}{if}\PYG{p}{(}\PYG{n}{configs}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{refs}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]} \PYG{o}{=}\PYG{o}{=} \PYG{n}{ref}\PYG{p}{)}
                    \PYG{p}{\PYGZob{}}
                        \PYG{k}{return} \PYG{p}{(}\PYG{n}{configs}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{val}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
                    \PYG{p}{\PYGZcb{}}
                \PYG{p}{\PYGZcb{}}
            \PYG{p}{\PYGZcb{}}
        \PYG{p}{\PYGZcb{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifdef DEBUG}
        \PYG{n}{cerr} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{No reference found for }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{section} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{, }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{ref} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif}
        \PYG{k}{return} \PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{null}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{k+kt}{int} \PYG{n}{importConfig}\PYG{p}{(}\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{n}{string}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZam{}} \PYG{n}{comargs}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
    \PYG{c+c1}{// Check that the previous arguments have already been imported.}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{bMain}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{k}{if}\PYG{p}{(}\PYG{n}{comargs}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)} \PYG{o}{!}\PYG{o}{=} \PYG{l+m+mi}{3}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{k}{throw} \PYG{n}{Config\PYGZus{}Exception}\PYG{p}{(}
                    \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ERROR\PYGZus{}CONF\PYGZus{}003: Number of command line arguments not correct before import.}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
        \PYG{p}{\PYGZcb{}}
        \PYG{n}{ifstream} \PYG{n}{is\PYGZus{}file}\PYG{p}{;}
        \PYG{k}{try}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{is\PYGZus{}file}\PYG{p}{.}\PYG{n}{open}\PYG{p}{(}\PYG{n}{configfile}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{catch}\PYG{p}{(}\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{k}{throw} \PYG{n}{Config\PYGZus{}Exception}\PYG{p}{(}
                \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ERROR\PYGZus{}CONF\PYGZus{}004a: Could not open the config file. Check file exists and is readable.}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{if}\PYG{p}{(}\PYG{o}{!}\PYG{n}{is\PYGZus{}file}\PYG{p}{.}\PYG{n}{fail}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{string} \PYG{n}{line}\PYG{p}{;}
            \PYG{k}{while}\PYG{p}{(}\PYG{n}{getline}\PYG{p}{(}\PYG{n}{is\PYGZus{}file}\PYG{p}{,} \PYG{n}{line}\PYG{p}{)}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{n}{istringstream} \PYG{n}{is\PYGZus{}line}\PYG{p}{(}\PYG{n}{line}\PYG{p}{)}\PYG{p}{;}
                \PYG{n}{string} \PYG{n}{key}\PYG{p}{;}
                \PYG{n}{is\PYGZus{}line} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{skipws}\PYG{p}{;}
                \PYG{k}{if}\PYG{p}{(}\PYG{n}{line}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{=}\PYG{o}{=} \PYG{l+s+sc}{\PYGZsq{}}\PYG{l+s+sc}{[}\PYG{l+s+sc}{\PYGZsq{}}\PYG{p}{)}
                \PYG{p}{\PYGZob{}}
                    \PYG{k}{continue}\PYG{p}{;}
                \PYG{p}{\PYGZcb{}}
                \PYG{k}{if}\PYG{p}{(}\PYG{n}{getline}\PYG{p}{(}\PYG{n}{is\PYGZus{}line}\PYG{p}{,} \PYG{n}{key}\PYG{p}{,} \PYG{l+s+sc}{\PYGZsq{}}\PYG{l+s+sc}{=}\PYG{l+s+sc}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{)}
                \PYG{p}{\PYGZob{}}
                    \PYG{c+c1}{// Could implement proper data parsing based on the key object.}
                    \PYG{n}{is\PYGZus{}line} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{skipws}\PYG{p}{;}
                    \PYG{n}{string} \PYG{n}{value}\PYG{p}{;}
                    \PYG{k}{if}\PYG{p}{(}\PYG{n}{getline}\PYG{p}{(}\PYG{n}{is\PYGZus{}line}\PYG{p}{,} \PYG{n}{value}\PYG{p}{)}\PYG{p}{)}
                    \PYG{p}{\PYGZob{}}
                        \PYG{n}{value}\PYG{p}{.}\PYG{n}{erase}\PYG{p}{(}\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{remove}\PYG{p}{(}\PYG{n}{value}\PYG{p}{.}\PYG{n}{begin}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{n}{value}\PYG{p}{.}\PYG{n}{end}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{l+s+sc}{\PYGZsq{}}\PYG{l+s+sc}{ }\PYG{l+s+sc}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{,} \PYG{n}{value}\PYG{p}{.}\PYG{n}{end}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
                        \PYG{k}{if}\PYG{p}{(}\PYG{o}{!}\PYG{n}{is\PYGZus{}line}\PYG{p}{)}
                        \PYG{p}{\PYGZob{}}
                            \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{value} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
                            \PYG{k}{throw} \PYG{n+nf}{Config\PYGZus{}Exception}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ERROR\PYGZus{}CONF\PYGZus{}001: Read error in config file.}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
                        \PYG{p}{\PYGZcb{}}
                        \PYG{k+kt}{char}\PYG{o}{*} \PYG{n}{tmp} \PYG{o}{=} \PYG{k}{new} \PYG{k+kt}{char}\PYG{p}{[}\PYG{n}{value}\PYG{p}{.}\PYG{n}{length}\PYG{p}{(}\PYG{p}{)} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{;}
                        \PYG{n}{strcpy}\PYG{p}{(}\PYG{n}{tmp}\PYG{p}{,} \PYG{n}{value}\PYG{p}{.}\PYG{n}{c\PYGZus{}str}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
                        \PYG{n}{comargs}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{n}{tmp}\PYG{p}{)}\PYG{p}{;}
                    \PYG{p}{\PYGZcb{}}
                \PYG{p}{\PYGZcb{}}
            \PYG{p}{\PYGZcb{}}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{else}
        \PYG{p}{\PYGZob{}}
            \PYG{k}{throw} \PYG{n}{Config\PYGZus{}Exception}\PYG{p}{(}
                \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ERROR\PYGZus{}CONF\PYGZus{}004b: Could not open the config file. Check file exists and is readable.}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{is\PYGZus{}file}\PYG{p}{.}\PYG{n}{eof}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{is\PYGZus{}file}\PYG{p}{.}\PYG{n}{close}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{else}
        \PYG{p}{\PYGZob{}}
            \PYG{k}{throw} \PYG{n}{Config\PYGZus{}Exception}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ERROR\PYGZus{}CONF\PYGZus{}002: End of file not reached. Check input file formating.}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{bMain}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{c+c1}{// remove the file name from the command line arguments to maintain the vector format.}
            \PYG{n}{comargs}\PYG{p}{.}\PYG{n}{erase}\PYG{p}{(}\PYG{n}{comargs}\PYG{p}{.}\PYG{n}{begin}\PYG{p}{(}\PYG{p}{)} \PYG{o}{+} \PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{return} \PYG{n}{comargs}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{k}{friend} \PYG{n}{ostream}\PYG{o}{\PYGZam{}} \PYG{k}{operator}\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{p}{(}\PYG{n}{ostream}\PYG{o}{\PYGZam{}} \PYG{n}{os}\PYG{p}{,} \PYG{k}{const} \PYG{n}{ConfigOption}\PYG{o}{\PYGZam{}} \PYG{n}{c}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{os} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{c}\PYG{p}{.}\PYG{n}{configfile} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{c}\PYG{p}{.}\PYG{n}{bConfig} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{c}\PYG{p}{.}\PYG{n}{bMain} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{c}\PYG{p}{.}\PYG{n}{bFullParse} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{c}\PYG{p}{.}\PYG{n}{configs}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}
           \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
        \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{c}\PYG{p}{.}\PYG{n}{configs}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{os} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{c}\PYG{p}{.}\PYG{n}{configs}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{return} \PYG{n}{os}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{k}{friend} \PYG{n}{istream}\PYG{o}{\PYGZam{}} \PYG{k}{operator}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{n}{istream}\PYG{o}{\PYGZam{}} \PYG{n}{is}\PYG{p}{,} \PYG{n}{ConfigOption}\PYG{o}{\PYGZam{}} \PYG{n}{c}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{c+c1}{// os \PYGZlt{}\PYGZlt{} m.numRows\PYGZlt{}\PYGZlt{}\PYGZdq{} , \PYGZdq{}\PYGZlt{}\PYGZlt{}m.numCols\PYGZlt{}\PYGZlt{}\PYGZdq{} , \PYGZdq{}\PYGZlt{}\PYGZlt{}endl;}
        \PYG{k+kt}{unsigned} \PYG{k+kt}{int} \PYG{n}{configsize}\PYG{p}{;}
        \PYG{n}{is} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{c}\PYG{p}{.}\PYG{n}{configfile} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{c}\PYG{p}{.}\PYG{n}{bConfig} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{c}\PYG{p}{.}\PYG{n}{bMain} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{c}\PYG{p}{.}\PYG{n}{bFullParse} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{configsize}\PYG{p}{;}
        \PYG{n}{SectionOption} \PYG{n}{tmpoption}\PYG{p}{;}
        \PYG{c+c1}{// cout \PYGZlt{}\PYGZlt{} \PYGZdq{}configsize: \PYGZdq{} \PYGZlt{}\PYGZlt{} configsize \PYGZlt{}\PYGZlt{} endl;}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{configsize} \PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{0}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{configsize}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{n}{is} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{tmpoption}\PYG{p}{;}
                \PYG{n}{c}\PYG{p}{.}\PYG{n}{configs}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{n}{tmpoption}\PYG{p}{)}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
        \PYG{p}{\PYGZcb{}}
        \PYG{c+c1}{// cout \PYGZlt{}\PYGZlt{} \PYGZdq{}end config\PYGZdq{} \PYGZlt{}\PYGZlt{} endl;}
        \PYG{k}{return} \PYG{n}{is}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif}
\end{sphinxVerbatim}


\subparagraph{Includes}
\label{\detokenize{Exhaled/exhale_file_Config.h:includes}}\begin{itemize}
\item {} 
\sphinxcode{CustomExceptions.h} ({\hyperref[\detokenize{Exhaled/exhale_file_CustomExceptions.h:file-customexceptions-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File CustomExceptions.h}}}})

\item {} 
\sphinxcode{algorithm}

\item {} 
\sphinxcode{cctype}

\item {} 
\sphinxcode{cmath}

\item {} 
\sphinxcode{cstring}

\item {} 
\sphinxcode{fstream}

\item {} 
\sphinxcode{iostream}

\item {} 
\sphinxcode{sstream}

\item {} 
\sphinxcode{stdexcept}

\item {} 
\sphinxcode{string}

\item {} 
\sphinxcode{unistd.h}

\item {} 
\sphinxcode{vector}

\end{itemize}


\subparagraph{Included By}
\label{\detokenize{Exhaled/exhale_file_Config.h:included-by}}\begin{itemize}
\item {} 
{\hyperref[\detokenize{Exhaled/exhale_file_Config.cpp:file-config-cpp}]{\sphinxcrossref{\DUrole{std,std-ref}{File Config.cpp}}}}

\item {} 
{\hyperref[\detokenize{Exhaled/exhale_file_Map.h:file-map-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File Map.h}}}}

\item {} 
{\hyperref[\detokenize{Exhaled/exhale_file_Tree.h:file-tree-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File Tree.h}}}}

\item {} 
{\hyperref[\detokenize{Exhaled/exhale_file_SpeciationCounter.cpp:file-speciationcounter-cpp}]{\sphinxcrossref{\DUrole{std,std-ref}{File SpeciationCounter.cpp}}}}

\end{itemize}


\subparagraph{Namespaces}
\label{\detokenize{Exhaled/exhale_file_Config.h:namespaces}}\begin{itemize}
\item {} 
{\hyperref[\detokenize{Exhaled/exhale_namespace_std:namespace-std}]{\sphinxcrossref{\DUrole{std,std-ref}{Namespace std}}}}

\end{itemize}


\subparagraph{Classes}
\label{\detokenize{Exhaled/exhale_file_Config.h:classes}}\begin{itemize}
\item {} 
{\hyperref[\detokenize{Exhaled/exhale_struct_SectionOption:struct-sectionoption}]{\sphinxcrossref{\DUrole{std,std-ref}{Struct SectionOption}}}}

\item {} 
{\hyperref[\detokenize{Exhaled/exhale_class_ConfigOption:class-configoption}]{\sphinxcrossref{\DUrole{std,std-ref}{Class ConfigOption}}}}

\end{itemize}


\subparagraph{Functions}
\label{\detokenize{Exhaled/exhale_file_Config.h:functions}}\begin{itemize}
\item {} 
{\hyperref[\detokenize{Exhaled/exhale_function_importArgs:function-importargs}]{\sphinxcrossref{\DUrole{std,std-ref}{Function importArgs}}}}

\end{itemize}


\paragraph{File CustomExceptions.h}
\label{\detokenize{Exhaled/exhale_file_CustomExceptions.h:file-customexceptions-h}}\label{\detokenize{Exhaled/exhale_file_CustomExceptions.h::doc}}\label{\detokenize{Exhaled/exhale_file_CustomExceptions.h:id1}}

\subparagraph{Definition (\sphinxstyleliteralintitle{CustomExceptions.h})}
\label{\detokenize{Exhaled/exhale_file_CustomExceptions.h:definition-customexceptions-h}}

\subparagraph{Program Listing for File CustomExceptions.h}
\label{\detokenize{Exhaled/exhale_program_listing_file_CustomExceptions.h:program-listing-file-customexceptions-h}}\label{\detokenize{Exhaled/exhale_program_listing_file_CustomExceptions.h::doc}}\label{\detokenize{Exhaled/exhale_program_listing_file_CustomExceptions.h:program-listing-for-file-customexceptions-h}}\begin{itemize}
\item {} 
Return to documentation for {\hyperref[\detokenize{Exhaled/exhale_file_CustomExceptions.h:file-customexceptions-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File CustomExceptions.h}}}}

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{//This file is part of NECSim project which is released under BSD\PYGZhy{}3 license.}
\PYG{c+c1}{//See file **LICENSE.txt** or visit https://opensource.org/licenses/BSD\PYGZhy{}3\PYGZhy{}Clause) for full license details.}
\PYG{c+c1}{// Author: Samuel Thompson}
\PYG{c+c1}{// Contact: samuel.thompson14@imperial.ac.uk or thompsonsed@gmail.com}
 \PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifndef EXCEPTION}
 \PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define EXCEPTION}
 \PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}stdexcept\PYGZgt{}}
 \PYG{k}{using} \PYG{k}{namespace} \PYG{n}{std}\PYG{p}{;}
\PYG{k}{struct} \PYG{n+nl}{Main\PYGZus{}Exception} \PYG{p}{:} \PYG{k}{public} \PYG{n}{runtime\PYGZus{}error}
\PYG{p}{\PYGZob{}}
  \PYG{n}{Main\PYGZus{}Exception}\PYG{p}{(}\PYG{p}{)}\PYG{o}{:}\PYG{n}{runtime\PYGZus{}error}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Exception thrown at run time in main: }\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}
  \PYG{n}{Main\PYGZus{}Exception}\PYG{p}{(}\PYG{n}{string} \PYG{n}{msg}\PYG{p}{)}\PYG{o}{:}\PYG{n}{runtime\PYGZus{}error}\PYG{p}{(}\PYG{n}{msg}\PYG{p}{.}\PYG{n}{c\PYGZus{}str}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}


\PYG{k}{struct} \PYG{n+nl}{Fatal\PYGZus{}Exception} \PYG{p}{:} \PYG{k}{public} \PYG{n}{runtime\PYGZus{}error}
\PYG{p}{\PYGZob{}}
  \PYG{n}{Fatal\PYGZus{}Exception}\PYG{p}{(}\PYG{p}{)}\PYG{o}{:}\PYG{n}{runtime\PYGZus{}error}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Fatal exception thrown at run time, quitting program. }\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}
  \PYG{n}{Fatal\PYGZus{}Exception}\PYG{p}{(}\PYG{n}{string} \PYG{n}{msg}\PYG{p}{)}\PYG{o}{:}\PYG{n}{runtime\PYGZus{}error}\PYG{p}{(}\PYG{n}{msg}\PYG{p}{.}\PYG{n}{c\PYGZus{}str}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}

 \PYG{c+c1}{// for non fatal map exceptions \PYGZhy{} in most cases, if they can\PYGZsq{}t be resolved, the program will have to quit regardless.}
 \PYG{k}{struct} \PYG{n+nl}{Map\PYGZus{}Exception} \PYG{p}{:} \PYG{k}{public} \PYG{n}{runtime\PYGZus{}error}
\PYG{p}{\PYGZob{}}
    \PYG{n}{Map\PYGZus{}Exception}\PYG{p}{(}\PYG{p}{)}\PYG{o}{:}\PYG{n}{runtime\PYGZus{}error}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Exception thrown at run time in Map: }\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}
    \PYG{n}{Map\PYGZus{}Exception}\PYG{p}{(}\PYG{n}{string} \PYG{n}{msg}\PYG{p}{)}\PYG{o}{:}\PYG{n}{runtime\PYGZus{}error}\PYG{p}{(}\PYG{n}{msg}\PYG{p}{.}\PYG{n}{c\PYGZus{}str}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}

 \PYG{c+c1}{// For returning fatal map exceptions}
 \PYG{k}{struct} \PYG{n+nl}{Map\PYGZus{}Fatal\PYGZus{}Exception} \PYG{p}{:} \PYG{k}{public} \PYG{n}{runtime\PYGZus{}error}
 \PYG{p}{\PYGZob{}}
    \PYG{n}{Map\PYGZus{}Fatal\PYGZus{}Exception}\PYG{p}{(}\PYG{p}{)}\PYG{o}{:}\PYG{n}{runtime\PYGZus{}error}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Fatal exception thrown at run time in Map: }\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}
    \PYG{n}{Map\PYGZus{}Fatal\PYGZus{}Exception}\PYG{p}{(}\PYG{n}{string} \PYG{n}{msg}\PYG{p}{)}\PYG{o}{:}\PYG{n}{runtime\PYGZus{}error}\PYG{p}{(}\PYG{n}{msg}\PYG{p}{.}\PYG{n}{c\PYGZus{}str}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}
 \PYG{p}{\PYGZcb{}}\PYG{p}{;}

 \PYG{c+cm}{/************************************************************}
\PYG{c+cm}{                        CONFIGOPTION CLASS}
\PYG{c+cm}{ ************************************************************/}
 \PYG{c+c1}{// Create the ConfigException object}
\PYG{k}{struct} \PYG{n+nl}{Config\PYGZus{}Exception} \PYG{p}{:} \PYG{k}{public} \PYG{n}{runtime\PYGZus{}error}
\PYG{p}{\PYGZob{}}
  \PYG{n}{Config\PYGZus{}Exception}\PYG{p}{(}\PYG{p}{)}\PYG{o}{:}\PYG{n}{runtime\PYGZus{}error}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Exception thrown at run time in config: }\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}
  \PYG{n}{Config\PYGZus{}Exception}\PYG{p}{(}\PYG{n}{string} \PYG{n}{msg}\PYG{p}{)}\PYG{o}{:}\PYG{n}{runtime\PYGZus{}error}\PYG{p}{(}\PYG{n}{msg}\PYG{p}{.}\PYG{n}{c\PYGZus{}str}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}


\PYG{k}{using} \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{runtime\PYGZus{}error}\PYG{p}{;}
\PYG{k}{struct} \PYG{n+nl}{SpeciesException} \PYG{p}{:} \PYG{k}{public} \PYG{n}{runtime\PYGZus{}error}
\PYG{p}{\PYGZob{}}
    \PYG{n}{SpeciesException}\PYG{p}{(}\PYG{p}{)}\PYG{o}{:}\PYG{n}{runtime\PYGZus{}error}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Exception thrown at run time in SpeciationCounter: }\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}
    \PYG{n}{SpeciesException}\PYG{p}{(}\PYG{n}{string} \PYG{n}{msg}\PYG{p}{)}\PYG{o}{:}\PYG{n}{runtime\PYGZus{}error}\PYG{p}{(}\PYG{n}{msg}\PYG{p}{.}\PYG{n}{c\PYGZus{}str}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif}
\end{sphinxVerbatim}


\subparagraph{Includes}
\label{\detokenize{Exhaled/exhale_file_CustomExceptions.h:includes}}\begin{itemize}
\item {} 
\sphinxcode{stdexcept}

\end{itemize}


\subparagraph{Included By}
\label{\detokenize{Exhaled/exhale_file_CustomExceptions.h:included-by}}\begin{itemize}
\item {} 
{\hyperref[\detokenize{Exhaled/exhale_file_Config.h:file-config-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File Config.h}}}}

\item {} 
{\hyperref[\detokenize{Exhaled/exhale_file_Treelist.h:file-treelist-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File Treelist.h}}}}

\end{itemize}


\subparagraph{Classes}
\label{\detokenize{Exhaled/exhale_file_CustomExceptions.h:classes}}\begin{itemize}
\item {} 
{\hyperref[\detokenize{Exhaled/exhale_struct_Config_Exception:struct-config-exception}]{\sphinxcrossref{\DUrole{std,std-ref}{Struct Config\_Exception}}}}

\item {} 
{\hyperref[\detokenize{Exhaled/exhale_struct_Fatal_Exception:struct-fatal-exception}]{\sphinxcrossref{\DUrole{std,std-ref}{Struct Fatal\_Exception}}}}

\item {} 
{\hyperref[\detokenize{Exhaled/exhale_struct_Main_Exception:struct-main-exception}]{\sphinxcrossref{\DUrole{std,std-ref}{Struct Main\_Exception}}}}

\item {} 
{\hyperref[\detokenize{Exhaled/exhale_struct_Map_Exception:struct-map-exception}]{\sphinxcrossref{\DUrole{std,std-ref}{Struct Map\_Exception}}}}

\item {} 
{\hyperref[\detokenize{Exhaled/exhale_struct_Map_Fatal_Exception:struct-map-fatal-exception}]{\sphinxcrossref{\DUrole{std,std-ref}{Struct Map\_Fatal\_Exception}}}}

\item {} 
{\hyperref[\detokenize{Exhaled/exhale_struct_SpeciesException:struct-speciesexception}]{\sphinxcrossref{\DUrole{std,std-ref}{Struct SpeciesException}}}}

\end{itemize}


\paragraph{File Datapoint.h}
\label{\detokenize{Exhaled/exhale_file_Datapoint.h:file-datapoint-h}}\label{\detokenize{Exhaled/exhale_file_Datapoint.h::doc}}\label{\detokenize{Exhaled/exhale_file_Datapoint.h:id1}}

\subparagraph{Definition (\sphinxstyleliteralintitle{Datapoint.h})}
\label{\detokenize{Exhaled/exhale_file_Datapoint.h:definition-datapoint-h}}

\subparagraph{Program Listing for File Datapoint.h}
\label{\detokenize{Exhaled/exhale_program_listing_file_Datapoint.h:program-listing-file-datapoint-h}}\label{\detokenize{Exhaled/exhale_program_listing_file_Datapoint.h:program-listing-for-file-datapoint-h}}\label{\detokenize{Exhaled/exhale_program_listing_file_Datapoint.h::doc}}\begin{itemize}
\item {} 
Return to documentation for {\hyperref[\detokenize{Exhaled/exhale_file_Datapoint.h:file-datapoint-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File Datapoint.h}}}}

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{//This file is part of NECSim project which is released under BSD\PYGZhy{}3 license.}
\PYG{c+c1}{//See file **LICENSE.txt** or visit https://opensource.org/licenses/BSD\PYGZhy{}3\PYGZhy{}Clause) for full license details.}
\PYG{c+c1}{// Datapoint.cpp version 3.1}
\PYG{c+c1}{// Author \PYGZhy{} Samuel Thompson \PYGZhy{} Imperial College London}
\PYG{c+c1}{// with large use of code supplied by James Rosindell (Imperial College London)}
\PYG{c+c1}{// This file contains the datapoint class for usage in coalescence simulations.}
\PYG{c+c1}{// Version 2.01 removes any references to matrix vs grid x and y coordinates, instead simplifying to a single coordinate system.}


\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ define version1\PYGZus{}01}

\PYG{c+cm}{/************************************************************}
\PYG{c+cm}{                    DATA POINT OBJECT}
\PYG{c+cm}{ ************************************************************/}
 \PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}iostream\PYGZgt{}}
\PYG{k}{using} \PYG{k}{namespace} \PYG{n}{std}\PYG{p}{;}
\PYG{k}{class} \PYG{n+nc}{Datapoint}
\PYG{p}{\PYGZob{}}

\PYG{k}{private}\PYG{o}{:}
    \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{xpos}\PYG{p}{;}
    \PYG{c+c1}{// x position}
    \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{ypos}\PYG{p}{;}
    \PYG{c+c1}{// y position}
    \PYG{k+kt}{long} \PYG{n}{xwrap}\PYG{p}{;}
    \PYG{c+c1}{// number of wraps of x around the torus}
    \PYG{k+kt}{long} \PYG{n}{ywrap}\PYG{p}{;}
    \PYG{c+c1}{// number of wraps of y around the torus}
    \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{iNext}\PYG{p}{;}
    \PYG{c+c1}{// the next individual in the loop of those that have the same xypos}
\PYG{c+c1}{//  unsigned long last; // removed as of version 3.1}
\PYG{c+c1}{//  // the last individual in the loop 0 means the only one}
    \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{mpos}\PYG{p}{;}
    \PYG{c+c1}{// points to the position in output of this lineage}
    \PYG{k+kt}{unsigned} \PYG{k+kt}{short} \PYG{n}{listpos}\PYG{p}{;}
    \PYG{c+c1}{// points to the position in the SpeciesList file.}
    \PYG{k+kt}{unsigned} \PYG{k+kt}{short} \PYG{n}{nwrap}\PYG{p}{;}

    \PYG{c+c1}{// the max\PYGZhy{}min number}
    \PYG{k+kt}{double} \PYG{n}{dMinmax}\PYG{p}{;}
\PYG{k}{public}\PYG{o}{:}

    \PYG{n}{Datapoint}\PYG{p}{(}\PYG{p}{)} \PYG{o}{:} \PYG{n}{xpos}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{,}\PYG{n}{ypos}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{,}\PYG{n}{xwrap}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{,}\PYG{n}{ywrap}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{,}\PYG{n}{iNext}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{,}\PYG{n}{mpos}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{,}\PYG{n}{listpos}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{,}\PYG{n}{nwrap}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{,}\PYG{n}{dMinmax}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}

    \PYG{p}{\PYGZcb{}}

    \PYG{o}{\PYGZti{}}\PYG{n}{Datapoint}\PYG{p}{(}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}

    \PYG{p}{\PYGZcb{}}

    \PYG{k+kt}{void} \PYG{n}{setup}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{x} \PYG{p}{,} \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{y} \PYG{p}{,} \PYG{k+kt}{long} \PYG{n}{xwrapin}\PYG{p}{,} \PYG{k+kt}{long} \PYG{n}{ywrapin}\PYG{p}{,} \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{matrix\PYGZus{}position}\PYG{p}{,} \PYG{k+kt}{unsigned} \PYG{k+kt}{short} \PYG{n}{listposin}\PYG{p}{,} \PYG{k+kt}{double} \PYG{n}{dMinmaxin}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{xpos} \PYG{o}{=} \PYG{n}{x}\PYG{p}{;}
        \PYG{n}{ypos} \PYG{o}{=} \PYG{n}{y}\PYG{p}{;}
        \PYG{n}{xwrap} \PYG{o}{=} \PYG{n}{xwrapin}\PYG{p}{;}
        \PYG{n}{ywrap} \PYG{o}{=} \PYG{n}{ywrapin}\PYG{p}{;}
        \PYG{n}{iNext} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{c+c1}{//      last =0;// removed as of version 3.1}
        \PYG{n}{mpos} \PYG{o}{=} \PYG{n}{matrix\PYGZus{}position}\PYG{p}{;}
        \PYG{n}{listpos} \PYG{o}{=} \PYG{n}{listposin}\PYG{p}{;}
        \PYG{n}{nwrap} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
        \PYG{n}{dMinmax} \PYG{o}{=} \PYG{n}{dMinmaxin}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{k+kt}{void} \PYG{n}{setup}\PYG{p}{(}\PYG{n}{Datapoint} \PYG{n}{datin}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{xpos} \PYG{o}{=} \PYG{n}{datin}\PYG{p}{.}\PYG{n}{getXpos}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{ypos} \PYG{o}{=} \PYG{n}{datin}\PYG{p}{.}\PYG{n}{getYpos}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{xwrap} \PYG{o}{=} \PYG{n}{datin}\PYG{p}{.}\PYG{n}{getXwrap}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{ywrap} \PYG{o}{=} \PYG{n}{datin}\PYG{p}{.}\PYG{n}{getYwrap}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{iNext} \PYG{o}{=} \PYG{n}{datin}\PYG{p}{.}\PYG{n}{getNext}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{c+c1}{//      last = datin.get\PYGZus{}last(); // removed as of version 3.1}
        \PYG{n}{mpos} \PYG{o}{=} \PYG{n}{datin}\PYG{p}{.}\PYG{n}{getMpos}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{listpos} \PYG{o}{=} \PYG{n}{datin}\PYG{p}{.}\PYG{n}{getListpos}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{nwrap} \PYG{o}{=} \PYG{n}{datin}\PYG{p}{.}\PYG{n}{getNwrap}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{dMinmax} \PYG{o}{=} \PYG{n}{datin}\PYG{p}{.}\PYG{n}{getMinmax}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}


    \PYG{k+kt}{void} \PYG{n}{setMpos}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{z}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{mpos} \PYG{o}{=} \PYG{n}{z}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{k+kt}{void} \PYG{n}{setNext}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{x}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{iNext} \PYG{o}{=} \PYG{n}{x}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{k+kt}{void} \PYG{n}{setListpos}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{short} \PYG{n}{l}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{listpos} \PYG{o}{=} \PYG{n}{l}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{k+kt}{void} \PYG{n}{setNwrap}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{short} \PYG{n}{n}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{nwrap} \PYG{o}{=} \PYG{n}{n}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{k+kt}{void} \PYG{n}{setMinmax}\PYG{p}{(}\PYG{k+kt}{double} \PYG{n}{d}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{dMinmax} \PYG{o}{=} \PYG{n}{d}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{k+kt}{void} \PYG{n}{subtractListpos}\PYG{p}{(}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{listpos} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{c+c1}{// note that position variables (8 of them) are set by lineage move routines below}

    \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{getXpos}\PYG{p}{(}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{return} \PYG{n}{xpos}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{getYpos}\PYG{p}{(}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{return} \PYG{n}{ypos}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{k+kt}{long} \PYG{n}{getXwrap}\PYG{p}{(}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{return} \PYG{n}{xwrap}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{k+kt}{long} \PYG{n}{getYwrap}\PYG{p}{(}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{return} \PYG{n}{ywrap}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{getMpos}\PYG{p}{(}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{return} \PYG{n}{mpos}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{getNext}\PYG{p}{(}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{return} \PYG{n}{iNext}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{c+c1}{// removed as of version 3.1}
\PYG{c+c1}{//  unsigned long get\PYGZus{}last()}
\PYG{c+c1}{//  \PYGZob{}}
\PYG{c+c1}{//      return last;}
\PYG{c+c1}{//  \PYGZcb{}}
    \PYG{k+kt}{unsigned} \PYG{k+kt}{short} \PYG{n}{getListpos}\PYG{p}{(}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{return} \PYG{n}{listpos}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{k+kt}{unsigned} \PYG{k+kt}{short} \PYG{n}{getNwrap}\PYG{p}{(}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{return} \PYG{n}{nwrap}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{k+kt}{double} \PYG{n}{getMinmax}\PYG{p}{(}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{return} \PYG{n}{dMinmax}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{k+kt}{void} \PYG{n}{decreaseNwrap}\PYG{p}{(}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{try}
        \PYG{p}{\PYGZob{}}
            \PYG{k}{if}\PYG{p}{(}\PYG{n}{nwrap}\PYG{o}{=}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{k}{throw} \PYG{n}{out\PYGZus{}of\PYGZus{}range}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ERROR\PYGZus{}DATA\PYGZus{}001: Trying to decrease  nwrap less than 0.}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
            \PYG{k}{else}
            \PYG{p}{\PYGZob{}}
                \PYG{n}{nwrap} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{catch}\PYG{p}{(}\PYG{n}{out\PYGZus{}of\PYGZus{}range}\PYG{o}{\PYGZam{}} \PYG{n}{oor}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{cerr} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{oor}\PYG{p}{.}\PYG{n}{what}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
    \PYG{p}{\PYGZcb{}}
    \PYG{c+c1}{// routines}
    \PYG{c+c1}{// removed the move and checkpos routines as they are no longer relevant.}
    \PYG{k+kt}{void} \PYG{n}{setEndpoint}\PYG{p}{(}\PYG{k+kt}{long} \PYG{n}{x}\PYG{p}{,} \PYG{k+kt}{long} \PYG{n}{y}\PYG{p}{,} \PYG{k+kt}{long} \PYG{n}{xwrapin}\PYG{p}{,} \PYG{k+kt}{long} \PYG{n}{ywrapin}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{xpos} \PYG{o}{=} \PYG{n}{x}\PYG{p}{;}
        \PYG{n}{ypos} \PYG{o}{=} \PYG{n}{y}\PYG{p}{;}
        \PYG{n}{xwrap} \PYG{o}{=} \PYG{n}{xwrapin}\PYG{p}{;}
        \PYG{n}{ywrap} \PYG{o}{=} \PYG{n}{ywrapin}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{k}{friend} \PYG{n}{ostream}\PYG{o}{\PYGZam{}} \PYG{k}{operator}\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{p}{(}\PYG{n}{ostream}\PYG{o}{\PYGZam{}} \PYG{n}{os}\PYG{p}{,} \PYG{k}{const} \PYG{n}{Datapoint}\PYG{o}{\PYGZam{}} \PYG{n}{d}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{os} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{d}\PYG{p}{.}\PYG{n}{xpos} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{,}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{d}\PYG{p}{.}\PYG{n}{ypos}  \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{,}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{d}\PYG{p}{.}\PYG{n}{xwrap} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{,}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{d}\PYG{p}{.}\PYG{n}{ywrap} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{,}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{d}\PYG{p}{.}\PYG{n}{iNext} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{,}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{d}\PYG{p}{.}\PYG{n}{mpos} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{,}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{d}\PYG{p}{.}\PYG{n}{listpos} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{,}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{d}\PYG{p}{.}\PYG{n}{nwrap}\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{,}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
        \PYG{n}{os} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{d}\PYG{p}{.}\PYG{n}{dMinmax} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{,}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
        \PYG{k}{return} \PYG{n}{os}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{k}{friend} \PYG{n}{istream}\PYG{o}{\PYGZam{}} \PYG{k}{operator}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{n}{istream}\PYG{o}{\PYGZam{}} \PYG{n}{is}\PYG{p}{,} \PYG{n}{Datapoint}\PYG{o}{\PYGZam{}} \PYG{n}{d}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{c+c1}{//os \PYGZlt{}\PYGZlt{} m.numRows\PYGZlt{}\PYGZlt{}\PYGZdq{} , \PYGZdq{}\PYGZlt{}\PYGZlt{}m.numCols\PYGZlt{}\PYGZlt{}\PYGZdq{} , \PYGZdq{}\PYGZlt{}\PYGZlt{}endl;}
        \PYG{k+kt}{char} \PYG{n}{delim}\PYG{p}{;}
        \PYG{c+c1}{//cout \PYGZlt{}\PYGZlt{} \PYGZdq{}datapoint\PYGZdq{} \PYGZlt{}\PYGZlt{} endl;}
        \PYG{n}{is} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{d}\PYG{p}{.}\PYG{n}{xpos} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{delim} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{d}\PYG{p}{.}\PYG{n}{ypos}  \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{delim} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{d}\PYG{p}{.}\PYG{n}{xwrap} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{delim} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{d}\PYG{p}{.}\PYG{n}{ywrap} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{delim} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{d}\PYG{p}{.}\PYG{n}{iNext} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{delim} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{d}\PYG{p}{.}\PYG{n}{mpos} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{delim} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{d}\PYG{p}{.}\PYG{n}{listpos} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{delim} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{d}\PYG{p}{.}\PYG{n}{nwrap}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{delim}\PYG{p}{;}
        \PYG{n}{is} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{d}\PYG{p}{.}\PYG{n}{dMinmax} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{delim}\PYG{p}{;}
        \PYG{k}{return} \PYG{n}{is}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\end{sphinxVerbatim}


\subparagraph{Includes}
\label{\detokenize{Exhaled/exhale_file_Datapoint.h:includes}}\begin{itemize}
\item {} 
\sphinxcode{iostream}

\end{itemize}


\subparagraph{Included By}
\label{\detokenize{Exhaled/exhale_file_Datapoint.h:included-by}}\begin{itemize}
\item {} 
{\hyperref[\detokenize{Exhaled/exhale_file_Tree.h:file-tree-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File Tree.h}}}}

\end{itemize}


\subparagraph{Classes}
\label{\detokenize{Exhaled/exhale_file_Datapoint.h:classes}}\begin{itemize}
\item {} 
{\hyperref[\detokenize{Exhaled/exhale_class_Datapoint:class-datapoint}]{\sphinxcrossref{\DUrole{std,std-ref}{Class Datapoint}}}}

\end{itemize}


\subparagraph{Defines}
\label{\detokenize{Exhaled/exhale_file_Datapoint.h:defines}}\begin{itemize}
\item {} 
{\hyperref[\detokenize{Exhaled/exhale_define_version1_01:define-version1-01}]{\sphinxcrossref{\DUrole{std,std-ref}{Define version1\_01}}}}

\end{itemize}


\paragraph{File Fattaildeviate.h}
\label{\detokenize{Exhaled/exhale_file_Fattaildeviate.h:file-fattaildeviate-h}}\label{\detokenize{Exhaled/exhale_file_Fattaildeviate.h::doc}}\label{\detokenize{Exhaled/exhale_file_Fattaildeviate.h:id1}}

\subparagraph{Definition (\sphinxstyleliteralintitle{Fattaildeviate.h})}
\label{\detokenize{Exhaled/exhale_file_Fattaildeviate.h:definition-fattaildeviate-h}}

\subparagraph{Program Listing for File Fattaildeviate.h}
\label{\detokenize{Exhaled/exhale_program_listing_file_Fattaildeviate.h:program-listing-for-file-fattaildeviate-h}}\label{\detokenize{Exhaled/exhale_program_listing_file_Fattaildeviate.h:program-listing-file-fattaildeviate-h}}\label{\detokenize{Exhaled/exhale_program_listing_file_Fattaildeviate.h::doc}}\begin{itemize}
\item {} 
Return to documentation for {\hyperref[\detokenize{Exhaled/exhale_file_Fattaildeviate.h:file-fattaildeviate-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File Fattaildeviate.h}}}}

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{//This file is part of NECSim project which is released under BSD\PYGZhy{}3 license.}
\PYG{c+c1}{//See file **LICENSE.txt** or visit https://opensource.org/licenses/BSD\PYGZhy{}3\PYGZhy{}Clause) for full license details.}

\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define IM1 2147483563}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define IM2 2147483399}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define AM (1.0}\PYG{c+cp}{/}\PYG{c+cp}{IM1)}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define IMM1 (IM1\PYGZhy{}1)}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define IA1 40014}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define IA2 40692}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define IQ1 53668}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define IQ2 5277}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define IR1 12211}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define IR2 3791}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define NTAB 32}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define NDIV (1+IMM1}\PYG{c+cp}{/}\PYG{c+cp}{NTAB)}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define EPS 1.2e\PYGZhy{}8}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define RNMX (1.0\PYGZhy{}EPS)}

\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ include \PYGZlt{}stdio.h\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ include \PYGZlt{}string\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ include \PYGZlt{}math.h\PYGZgt{}}

\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ include \PYGZlt{}vector\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ include \PYGZlt{}iostream\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ include \PYGZlt{}fstream\PYGZgt{}}

\PYG{k}{using} \PYG{k}{namespace} \PYG{n}{std}\PYG{p}{;}

\PYG{k}{class} \PYG{n+nc}{NRrand} \PYG{p}{\PYGZob{}}

\PYG{k}{private}\PYG{o}{:}
    \PYG{k+kt}{long} \PYG{n}{idum}\PYG{p}{;}
    \PYG{k+kt}{int} \PYG{n}{j}\PYG{p}{;}
    \PYG{k+kt}{long} \PYG{n}{k}\PYG{p}{;}
    \PYG{k+kt}{long} \PYG{n}{idum2}\PYG{p}{;}
    \PYG{k+kt}{long} \PYG{n}{iy}\PYG{p}{;}
    \PYG{k+kt}{long} \PYG{n}{iv}\PYG{p}{[}\PYG{n}{NTAB}\PYG{p}{]}\PYG{p}{;}
    \PYG{k+kt}{double} \PYG{n}{temp}\PYG{p}{;}
    \PYG{k+kt}{bool} \PYG{n}{seeded}\PYG{p}{;}

    \PYG{k+kt}{double} \PYG{n}{lastresult}\PYG{p}{;}
    \PYG{k+kt}{bool} \PYG{n}{normflag}\PYG{p}{;}
    \PYG{c+c1}{// for the L value of the dispersal kernel (the width \PYGZhy{} does not affect the shape).}
    \PYG{k+kt}{double} \PYG{n}{dLvalue}\PYG{p}{;}
    \PYG{c+c1}{// for the zfat value of the dispersal kernel (affects the shape).}
    \PYG{k+kt}{double} \PYG{n}{zfat}\PYG{p}{;}


\PYG{k}{public}\PYG{o}{:}

    \PYG{n}{NRrand}\PYG{p}{(}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{seeded} \PYG{o}{=} \PYG{n+nb}{false}\PYG{p}{;}
        \PYG{n}{normflag} \PYG{o}{=} \PYG{n+nb}{true}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{k+kt}{void} \PYG{n}{setSeed}\PYG{p}{(}\PYG{k+kt}{long} \PYG{n}{seed}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{if} \PYG{p}{(}\PYG{o}{!}\PYG{n}{seeded}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
        \PYG{n}{idum2} \PYG{o}{=} \PYG{l+m+mi}{123456789}\PYG{p}{;}
        \PYG{n}{iy} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
        \PYG{n}{idum} \PYG{o}{=} \PYG{n}{seed}\PYG{p}{;}
        \PYG{k}{if} \PYG{p}{(}\PYG{n}{idum} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{1}\PYG{p}{)} \PYG{n}{idum}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;}
        \PYG{c+c1}{//Be sure to prevent idum = 0.}
        \PYG{n}{idum2}\PYG{o}{=}\PYG{p}{(}\PYG{n}{idum}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{for} \PYG{p}{(}\PYG{n}{j}\PYG{o}{=}\PYG{n}{NTAB}\PYG{o}{+}\PYG{l+m+mi}{7}\PYG{p}{;}\PYG{n}{j}\PYG{o}{\PYGZgt{}}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;}\PYG{n}{j}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{c+c1}{//Load the shuffle table (after 8 warm\PYGZhy{}ups).}
            \PYG{n}{k}\PYG{o}{=}\PYG{p}{(}\PYG{n}{idum}\PYG{p}{)}\PYG{o}{/}\PYG{n}{IQ1}\PYG{p}{;}
            \PYG{n}{idum}\PYG{o}{=}\PYG{n}{IA1}\PYG{o}{*}\PYG{p}{(}\PYG{n}{idum}\PYG{o}{\PYGZhy{}}\PYG{n}{k}\PYG{o}{*}\PYG{n}{IQ1}\PYG{p}{)}\PYG{o}{\PYGZhy{}}\PYG{n}{k}\PYG{o}{*}\PYG{n}{IR1}\PYG{p}{;}
            \PYG{k}{if} \PYG{p}{(}\PYG{n}{idum} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{0}\PYG{p}{)} \PYG{n}{idum} \PYG{o}{+}\PYG{o}{=} \PYG{n}{IM1}\PYG{p}{;}
            \PYG{k}{if} \PYG{p}{(}\PYG{n}{j} \PYG{o}{\PYGZlt{}} \PYG{n}{NTAB}\PYG{p}{)} \PYG{n}{iv}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]} \PYG{o}{=} \PYG{n}{idum}\PYG{p}{;}
          \PYG{p}{\PYGZcb{}}
        \PYG{n}{iy}\PYG{o}{=}\PYG{n}{iv}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{;}
        \PYG{n}{seeded} \PYG{o}{=} \PYG{n+nb}{true}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
    \PYG{p}{\PYGZcb{}}

    \PYG{k+kt}{double} \PYG{n}{d01}\PYG{p}{(}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{k}\PYG{o}{=}\PYG{p}{(}\PYG{n}{idum}\PYG{p}{)}\PYG{o}{/}\PYG{n}{IQ1}\PYG{p}{;}
        \PYG{c+c1}{//Start here when not initializing.}
        \PYG{n}{idum}\PYG{o}{=}\PYG{n}{IA1}\PYG{o}{*}\PYG{p}{(}\PYG{n}{idum}\PYG{o}{\PYGZhy{}}\PYG{n}{k}\PYG{o}{*}\PYG{n}{IQ1}\PYG{p}{)}\PYG{o}{\PYGZhy{}}\PYG{n}{k}\PYG{o}{*}\PYG{n}{IR1}\PYG{p}{;}
        \PYG{c+c1}{//Compute idum=(IA1*idum) \PYGZpc{} IM1 without overflows by Schrage\PYGZsq{}s method.}
        \PYG{k}{if} \PYG{p}{(}\PYG{n}{idum} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{0}\PYG{p}{)} \PYG{n}{idum} \PYG{o}{+}\PYG{o}{=} \PYG{n}{IM1}\PYG{p}{;}
        \PYG{n}{k}\PYG{o}{=}\PYG{n}{idum2}\PYG{o}{/}\PYG{n}{IQ2}\PYG{p}{;}
        \PYG{n}{idum2}\PYG{o}{=}\PYG{n}{IA2}\PYG{o}{*}\PYG{p}{(}\PYG{n}{idum2}\PYG{o}{\PYGZhy{}}\PYG{n}{k}\PYG{o}{*}\PYG{n}{IQ2}\PYG{p}{)}\PYG{o}{\PYGZhy{}}\PYG{n}{k}\PYG{o}{*}\PYG{n}{IR2}\PYG{p}{;}
        \PYG{c+c1}{//Compute idum2=(IA2*idum) \PYGZpc{} IM2 likewise.}
        \PYG{k}{if} \PYG{p}{(}\PYG{n}{idum2} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{0}\PYG{p}{)} \PYG{n}{idum2} \PYG{o}{+}\PYG{o}{=} \PYG{n}{IM2}\PYG{p}{;}
        \PYG{n}{j}\PYG{o}{=}\PYG{n}{iy}\PYG{o}{/}\PYG{n}{NDIV}\PYG{p}{;}
        \PYG{c+c1}{//Will be in the range 0..NTAB\PYGZhy{}1.}
        \PYG{n}{iy}\PYG{o}{=}\PYG{n}{iv}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{o}{\PYGZhy{}}\PYG{n}{idum2}\PYG{p}{;}
        \PYG{c+c1}{//Here idum is shuffled, idum and idum2 are combined to generate output.}
        \PYG{n}{iv}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]} \PYG{o}{=} \PYG{n}{idum}\PYG{p}{;}
        \PYG{k}{if} \PYG{p}{(}\PYG{n}{iy} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{1}\PYG{p}{)} \PYG{n}{iy} \PYG{o}{+}\PYG{o}{=} \PYG{n}{IMM1}\PYG{p}{;}
        \PYG{k}{if} \PYG{p}{(}\PYG{p}{(}\PYG{n}{temp}\PYG{o}{=}\PYG{n}{AM}\PYG{o}{*}\PYG{n}{iy}\PYG{p}{)} \PYG{o}{\PYGZgt{}} \PYG{n}{RNMX}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{c+c1}{//cout \PYGZlt{}\PYGZlt{} \PYGZdq{}random call = \PYGZdq{} \PYGZlt{}\PYGZlt{} \PYGZdq{}RNMAX\PYGZdq{} \PYGZlt{}\PYGZlt{} \PYGZdq{}\PYGZbs{}n\PYGZdq{};}
            \PYG{k}{return} \PYG{n}{RNMX}\PYG{p}{;} \PYG{c+c1}{//Because users don\PYGZsq{}t expect endpoint values.}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{else}
        \PYG{p}{\PYGZob{}}

            \PYG{k}{return} \PYG{n}{temp}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
    \PYG{p}{\PYGZcb{}}

    \PYG{k+kt}{long} \PYG{n}{i0}\PYG{p}{(}\PYG{k+kt}{long} \PYG{n}{max}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{c+c1}{//long temp = (long(d01()*(max+1)));}
        \PYG{c+c1}{//cout \PYGZlt{}\PYGZlt{} \PYGZdq{}random call = \PYGZdq{} \PYGZlt{}\PYGZlt{} temp \PYGZlt{}\PYGZlt{} \PYGZdq{}\PYGZbs{}n\PYGZdq{};}
        \PYG{k}{return} \PYG{p}{(}\PYG{k+kt}{long}\PYG{p}{(}\PYG{n}{d01}\PYG{p}{(}\PYG{p}{)}\PYG{o}{*}\PYG{p}{(}\PYG{n}{max}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

     \PYG{k+kt}{double} \PYG{n}{norm}\PYG{p}{(}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{if} \PYG{p}{(}\PYG{n}{normflag}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
        \PYG{k+kt}{double} \PYG{n}{r2} \PYG{o}{=} \PYG{l+m+mi}{2}\PYG{p}{;}
        \PYG{k+kt}{double} \PYG{n}{xx}\PYG{p}{;}
        \PYG{k+kt}{double} \PYG{n}{yy}\PYG{p}{;}
        \PYG{k}{while} \PYG{p}{(}\PYG{n}{r2}\PYG{o}{\PYGZgt{}}\PYG{l+m+mi}{1}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{xx}\PYG{o}{=}\PYG{l+m+mf}{2.0}\PYG{o}{*}\PYG{n}{d01}\PYG{p}{(}\PYG{p}{)}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{1.0}\PYG{p}{;}
            \PYG{n}{yy}\PYG{o}{=}\PYG{l+m+mf}{2.0}\PYG{o}{*}\PYG{n}{d01}\PYG{p}{(}\PYG{p}{)}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{1.0}\PYG{p}{;}
            \PYG{n}{r2}\PYG{o}{=}\PYG{p}{(}\PYG{n}{xx}\PYG{o}{*}\PYG{n}{xx}\PYG{p}{)}\PYG{o}{+}\PYG{p}{(}\PYG{n}{yy}\PYG{o}{*}\PYG{n}{yy}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{k+kt}{double} \PYG{n}{fac}\PYG{o}{=}\PYG{n}{sqrt}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{2.0}\PYG{o}{*}\PYG{n}{log}\PYG{p}{(}\PYG{n}{r2}\PYG{p}{)}\PYG{o}{/}\PYG{n}{r2}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{lastresult} \PYG{o}{=} \PYG{n}{xx}\PYG{o}{*}\PYG{n}{fac}\PYG{p}{;}
        \PYG{k+kt}{double} \PYG{n}{result} \PYG{o}{=} \PYG{n}{yy}\PYG{o}{*}\PYG{n}{fac}\PYG{p}{;}
        \PYG{n}{normflag} \PYG{o}{=} \PYG{n+nb}{false}\PYG{p}{;}
        \PYG{k}{return} \PYG{n}{result}\PYG{p}{;}
          \PYG{p}{\PYGZcb{}}
        \PYG{k}{else}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{normflag} \PYG{o}{=} \PYG{n+nb}{true}\PYG{p}{;}
            \PYG{k}{return} \PYG{n}{lastresult}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
    \PYG{p}{\PYGZcb{}}


    \PYG{k+kt}{void} \PYG{n}{setDispersalParams}\PYG{p}{(}\PYG{k+kt}{double} \PYG{n}{zfatin}\PYG{p}{,} \PYG{k+kt}{double} \PYG{n}{dLvaluein}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{zfat} \PYG{o}{=} \PYG{n}{zfatin}\PYG{p}{;}
        \PYG{n}{dLvalue} \PYG{o}{=} \PYG{n}{dLvaluein}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}


    \PYG{k+kt}{double} \PYG{n}{fattail}\PYG{p}{(}\PYG{k+kt}{double} \PYG{n}{z}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k+kt}{double} \PYG{n}{result}\PYG{p}{;}
        \PYG{n}{result} \PYG{o}{=} \PYG{n}{pow}\PYG{p}{(}\PYG{p}{(}\PYG{n}{pow}\PYG{p}{(}\PYG{n}{d01}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,}\PYG{p}{(}\PYG{l+m+mf}{1.0}\PYG{o}{/}\PYG{p}{(}\PYG{l+m+mf}{1.0}\PYG{o}{\PYGZhy{}}\PYG{n}{z}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{1.0}\PYG{p}{)}\PYG{p}{,}\PYG{l+m+mf}{0.5}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{return} \PYG{n}{result}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{c+c1}{// this new version corrects the 1.0 to 2.0 and doesn\PYGZsq{}t require the values to be passed every time.}
    \PYG{k+kt}{double} \PYG{n}{fattail}\PYG{p}{(}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k+kt}{double} \PYG{n}{result}\PYG{p}{;}
        \PYG{n}{result} \PYG{o}{=} \PYG{p}{(}\PYG{n}{dLvalue} \PYG{o}{*} \PYG{n}{pow}\PYG{p}{(}\PYG{p}{(}\PYG{n}{pow}\PYG{p}{(}\PYG{n}{d01}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,}\PYG{p}{(}\PYG{l+m+mf}{2.0}\PYG{o}{/}\PYG{p}{(}\PYG{l+m+mf}{2.0}\PYG{o}{\PYGZhy{}}\PYG{n}{zfat}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{1.0}\PYG{p}{)}\PYG{p}{,}\PYG{l+m+mf}{0.5}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{return} \PYG{n}{result}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{k+kt}{double} \PYG{n}{direction}\PYG{p}{(}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k+kt}{double} \PYG{n}{xx} \PYG{o}{=} \PYG{l+m+mf}{1.0} \PYG{p}{,} \PYG{n}{yy} \PYG{o}{=} \PYG{l+m+mf}{1.0}\PYG{p}{;}
        \PYG{k}{while} \PYG{p}{(}\PYG{n}{xx}\PYG{o}{*}\PYG{n}{xx}\PYG{o}{+}\PYG{n}{yy}\PYG{o}{*}\PYG{n}{yy}\PYG{o}{\PYGZgt{}}\PYG{l+m+mf}{1.0}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
        \PYG{n}{xx} \PYG{o}{=} \PYG{n}{d01}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{yy} \PYG{o}{=} \PYG{n}{d01}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{return} \PYG{n}{pow}\PYG{p}{(}\PYG{p}{(}\PYG{n}{xx}\PYG{o}{/}\PYG{n}{yy}\PYG{p}{)}\PYG{p}{,}\PYG{l+m+mf}{2.0}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{k+kt}{bool} \PYG{n}{event}\PYG{p}{(}\PYG{k+kt}{double} \PYG{n}{probin}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{if} \PYG{p}{(}\PYG{n}{probin} \PYG{o}{\PYGZlt{}} \PYG{l+m+mf}{0.000001}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{k}{if} \PYG{p}{(}\PYG{n}{d01}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{l+m+mf}{0.000001}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{k}{return} \PYG{p}{(}\PYG{n}{event}\PYG{p}{(}\PYG{n}{probin} \PYG{o}{*} \PYG{l+m+mf}{1000000.0}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
            \PYG{k}{else}
            \PYG{p}{\PYGZob{}}
                \PYG{k}{return} \PYG{n+nb}{false}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{else}
        \PYG{p}{\PYGZob{}}
            \PYG{k}{if} \PYG{p}{(}\PYG{n}{probin} \PYG{o}{\PYGZgt{}} \PYG{l+m+mf}{0.999999}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{k}{return} \PYG{p}{(}\PYG{o}{!}\PYG{p}{(}\PYG{n}{event}\PYG{p}{(}\PYG{l+m+mf}{1.0}\PYG{o}{\PYGZhy{}}\PYG{n}{probin}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
            \PYG{k}{else}
            \PYG{p}{\PYGZob{}}
                \PYG{k}{return} \PYG{p}{(}\PYG{n}{d01}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{n}{probin}\PYG{p}{)}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
        \PYG{p}{\PYGZcb{}}
    \PYG{p}{\PYGZcb{}}

    \PYG{c+c1}{// to reconstruct distribution, use x = fattail/squrt(1+direction) , y = fattail/squrt(1+(direction\PYGZca{}\PYGZhy{}1))}

    \PYG{k}{friend} \PYG{n}{ostream}\PYG{o}{\PYGZam{}} \PYG{k}{operator}\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{p}{(}\PYG{n}{ostream}\PYG{o}{\PYGZam{}} \PYG{n}{os}\PYG{p}{,}\PYG{k}{const} \PYG{n}{NRrand}\PYG{o}{\PYGZam{}} \PYG{n}{r}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{c+c1}{//os \PYGZlt{}\PYGZlt{} m.numRows\PYGZlt{}\PYGZlt{}\PYGZdq{} , \PYGZdq{}\PYGZlt{}\PYGZlt{}m.numCols\PYGZlt{}\PYGZlt{}\PYGZdq{} , \PYGZdq{}\PYGZlt{}\PYGZlt{}endl;}

        \PYG{n}{os} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{r}\PYG{p}{.}\PYG{n}{idum} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{,}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
        \PYG{n}{os} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{r}\PYG{p}{.}\PYG{n}{j} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{,}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
        \PYG{n}{os} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{r}\PYG{p}{.}\PYG{n}{k} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{,}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
        \PYG{n}{os} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{r}\PYG{p}{.}\PYG{n}{idum2} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{,}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
        \PYG{n}{os} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{r}\PYG{p}{.}\PYG{n}{iy} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{,}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
        \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;}\PYG{n}{i}\PYG{o}{\PYGZlt{}}\PYG{n}{NTAB}\PYG{p}{;}\PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{os} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{r}\PYG{p}{.}\PYG{n}{iv}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{,}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{n}{os} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{r}\PYG{p}{.}\PYG{n}{temp} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{,}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
        \PYG{n}{os} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{r}\PYG{p}{.}\PYG{n}{seeded} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{,}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
        \PYG{n}{os} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{r}\PYG{p}{.}\PYG{n}{lastresult} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{,}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
        \PYG{n}{os} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{r}\PYG{p}{.}\PYG{n}{normflag} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{,}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{r}\PYG{p}{.}\PYG{n}{dLvalue} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{,}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{r}\PYG{p}{.}\PYG{n}{zfat} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{,}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
        \PYG{k}{return} \PYG{n}{os}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{k}{friend} \PYG{n}{istream}\PYG{o}{\PYGZam{}} \PYG{k}{operator}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{n}{istream}\PYG{o}{\PYGZam{}} \PYG{n}{is}\PYG{p}{,} \PYG{n}{NRrand}\PYG{o}{\PYGZam{}} \PYG{n}{r}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k+kt}{char} \PYG{n}{delim}\PYG{p}{;}
        \PYG{c+c1}{//double temp1,temp2;}
        \PYG{c+c1}{//is \PYGZlt{}\PYGZlt{} m.numRows\PYGZlt{}\PYGZlt{}\PYGZdq{} , \PYGZdq{}\PYGZlt{}\PYGZlt{}m.numCols\PYGZlt{}\PYGZlt{}\PYGZdq{} , \PYGZdq{}\PYGZlt{}\PYGZlt{}endl;}
        \PYG{n}{is} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{r}\PYG{p}{.}\PYG{n}{idum}\PYG{p}{;}
        \PYG{n}{is} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{delim}\PYG{p}{;}
        \PYG{n}{is} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{r}\PYG{p}{.}\PYG{n}{j}\PYG{p}{;}
        \PYG{n}{is} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{delim}\PYG{p}{;}
        \PYG{n}{is} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{r}\PYG{p}{.}\PYG{n}{k}\PYG{p}{;}
        \PYG{n}{is} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{delim}\PYG{p}{;}
        \PYG{n}{is} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{r}\PYG{p}{.}\PYG{n}{idum2}\PYG{p}{;}
        \PYG{n}{is} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{delim}\PYG{p}{;}
        \PYG{n}{is} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{r}\PYG{p}{.}\PYG{n}{iy}\PYG{p}{;}
        \PYG{n}{is} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{delim}\PYG{p}{;}
        \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;}\PYG{n}{i}\PYG{o}{\PYGZlt{}}\PYG{n}{NTAB}\PYG{p}{;}\PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{is} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{r}\PYG{p}{.}\PYG{n}{iv}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{;}
            \PYG{n}{is} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{delim}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{n}{is} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{r}\PYG{p}{.}\PYG{n}{temp}\PYG{p}{;}
        \PYG{n}{is} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{delim}\PYG{p}{;}
        \PYG{n}{is} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{r}\PYG{p}{.}\PYG{n}{seeded}\PYG{p}{;}
        \PYG{n}{is} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{delim}\PYG{p}{;}
        \PYG{n}{is} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{r}\PYG{p}{.}\PYG{n}{lastresult}\PYG{p}{;}
        \PYG{n}{is} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{delim}\PYG{p}{;}
        \PYG{n}{is} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}}\PYG{n}{r}\PYG{p}{.}\PYG{n}{normflag}\PYG{p}{;}
        \PYG{n}{is} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{delim} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{r}\PYG{p}{.}\PYG{n}{dLvalue} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{delim} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{r}\PYG{p}{.}\PYG{n}{zfat} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{delim}\PYG{p}{;}
        \PYG{k}{return} \PYG{n}{is}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\end{sphinxVerbatim}


\subparagraph{Includes}
\label{\detokenize{Exhaled/exhale_file_Fattaildeviate.h:includes}}\begin{itemize}
\item {} 
\sphinxcode{fstream}

\item {} 
\sphinxcode{iostream}

\item {} 
\sphinxcode{math.h}

\item {} 
\sphinxcode{stdio.h}

\item {} 
\sphinxcode{string}

\item {} 
\sphinxcode{vector}

\end{itemize}


\subparagraph{Included By}
\label{\detokenize{Exhaled/exhale_file_Fattaildeviate.h:included-by}}\begin{itemize}
\item {} 
{\hyperref[\detokenize{Exhaled/exhale_file_Tree.h:file-tree-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File Tree.h}}}}

\end{itemize}


\subparagraph{Classes}
\label{\detokenize{Exhaled/exhale_file_Fattaildeviate.h:classes}}\begin{itemize}
\item {} 
{\hyperref[\detokenize{Exhaled/exhale_class_NRrand:class-nrrand}]{\sphinxcrossref{\DUrole{std,std-ref}{Class NRrand}}}}

\end{itemize}


\subparagraph{Defines}
\label{\detokenize{Exhaled/exhale_file_Fattaildeviate.h:defines}}\begin{itemize}
\item {} 
{\hyperref[\detokenize{Exhaled/exhale_define_AM:define-am}]{\sphinxcrossref{\DUrole{std,std-ref}{Define AM}}}}

\item {} 
{\hyperref[\detokenize{Exhaled/exhale_define_EPS:define-eps}]{\sphinxcrossref{\DUrole{std,std-ref}{Define EPS}}}}

\item {} 
{\hyperref[\detokenize{Exhaled/exhale_define_IA1:define-ia1}]{\sphinxcrossref{\DUrole{std,std-ref}{Define IA1}}}}

\item {} 
{\hyperref[\detokenize{Exhaled/exhale_define_IA2:define-ia2}]{\sphinxcrossref{\DUrole{std,std-ref}{Define IA2}}}}

\item {} 
{\hyperref[\detokenize{Exhaled/exhale_define_IM1:define-im1}]{\sphinxcrossref{\DUrole{std,std-ref}{Define IM1}}}}

\item {} 
{\hyperref[\detokenize{Exhaled/exhale_define_IM2:define-im2}]{\sphinxcrossref{\DUrole{std,std-ref}{Define IM2}}}}

\item {} 
{\hyperref[\detokenize{Exhaled/exhale_define_IMM1:define-imm1}]{\sphinxcrossref{\DUrole{std,std-ref}{Define IMM1}}}}

\item {} 
{\hyperref[\detokenize{Exhaled/exhale_define_IQ1:define-iq1}]{\sphinxcrossref{\DUrole{std,std-ref}{Define IQ1}}}}

\item {} 
{\hyperref[\detokenize{Exhaled/exhale_define_IQ2:define-iq2}]{\sphinxcrossref{\DUrole{std,std-ref}{Define IQ2}}}}

\item {} 
{\hyperref[\detokenize{Exhaled/exhale_define_IR1:define-ir1}]{\sphinxcrossref{\DUrole{std,std-ref}{Define IR1}}}}

\item {} 
{\hyperref[\detokenize{Exhaled/exhale_define_IR2:define-ir2}]{\sphinxcrossref{\DUrole{std,std-ref}{Define IR2}}}}

\item {} 
{\hyperref[\detokenize{Exhaled/exhale_define_NDIV:define-ndiv}]{\sphinxcrossref{\DUrole{std,std-ref}{Define NDIV}}}}

\item {} 
{\hyperref[\detokenize{Exhaled/exhale_define_NTAB:define-ntab}]{\sphinxcrossref{\DUrole{std,std-ref}{Define NTAB}}}}

\item {} 
{\hyperref[\detokenize{Exhaled/exhale_define_RNMX:define-rnmx}]{\sphinxcrossref{\DUrole{std,std-ref}{Define RNMX}}}}

\end{itemize}


\paragraph{File main.cpp}
\label{\detokenize{Exhaled/exhale_file_main.cpp::doc}}\label{\detokenize{Exhaled/exhale_file_main.cpp:file-main-cpp}}\label{\detokenize{Exhaled/exhale_file_main.cpp:id1}}

\subparagraph{Definition (\sphinxstyleliteralintitle{main.cpp})}
\label{\detokenize{Exhaled/exhale_file_main.cpp:definition-main-cpp}}

\subparagraph{Program Listing for File main.cpp}
\label{\detokenize{Exhaled/exhale_program_listing_file_main.cpp:program-listing-for-file-main-cpp}}\label{\detokenize{Exhaled/exhale_program_listing_file_main.cpp::doc}}\label{\detokenize{Exhaled/exhale_program_listing_file_main.cpp:program-listing-file-main-cpp}}\begin{itemize}
\item {} 
Return to documentation for {\hyperref[\detokenize{Exhaled/exhale_file_main.cpp:file-main-cpp}]{\sphinxcrossref{\DUrole{std,std-ref}{File main.cpp}}}}

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{//Copyright: 2015, Samuel Thompson, thompsonsed@gmail.com}
\PYG{c+c1}{// License: BSD\PYGZhy{}3}
\PYG{c+c1}{//All rights reserved.}
\PYG{c+c1}{//}
\PYG{c+c1}{//Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:}
\PYG{c+c1}{//}
\PYG{c+c1}{//1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.}
\PYG{c+c1}{//}
\PYG{c+c1}{//2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.}
\PYG{c+c1}{//}
\PYG{c+c1}{//3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.}

\PYG{c+c1}{//THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \PYGZdq{}AS IS\PYGZdq{} AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.}

\PYG{c+c1}{//}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifdef DEBUG}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifndef verbose}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define verbose}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}stdio.h\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZdq{}Setup.h\PYGZdq{}}
\PYG{c+c1}{// \PYGZsh{}define pristine\PYGZus{}mode // not required unless you experience problems.}
\PYG{c+c1}{// This performs a more thorough check after each move operation.}
\PYG{c+c1}{// Currently, it will also check that the pristine state value is greater than the returned value within every map cell.}
\PYG{c+c1}{// Note that this may cause problems if the pristine state is not the state with the highest number of individuals.}



\PYG{c+cm}{/************************************************************}
\PYG{c+cm}{        MAIN ROUTINE AND COMMAND LINE ARG ROUTINES}

\PYG{c+cm}{ ************************************************************/}



\PYG{k+kt}{int} \PYG{n+nf}{main}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{argc}\PYG{p}{,} \PYG{k+kt}{char} \PYG{o}{*}\PYG{n}{argv}\PYG{p}{[}\PYG{p}{]}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{c+cm}{/*}
\PYG{c+cm}{    // COMMAND LINE ARGUMENTS}
\PYG{c+cm}{    // The argument argc is the number of arguments supplied to the program (automatically generated by c++)}
\PYG{c+cm}{    // The arguments 1 to N are as follows}
\PYG{c+cm}{    // 1: the task\PYGZus{}iter used for setting the seed.}
\PYG{c+cm}{    // 2: the sample grid x dimension}
\PYG{c+cm}{    // 3: the sample grid y dimension}
\PYG{c+cm}{    // 4: the fine map file relative path.}
\PYG{c+cm}{    // 5: the fine map x dimension}
\PYG{c+cm}{    // 6: the fine map y dimension}
\PYG{c+cm}{    // 7: the fine map x offset}
\PYG{c+cm}{    // 8 the fine map y offset}
\PYG{c+cm}{    // 9: the coarse map file relative path.}
\PYG{c+cm}{    // 10: the coarse map x dimension}
\PYG{c+cm}{    // 11: the coarse map y dimension}
\PYG{c+cm}{    // 12: the coarse map x offset}
\PYG{c+cm}{    // 13: the coarse map y offset}
\PYG{c+cm}{    // 14: the scale of the coarse map compared to the fine (10 means resolution of coarse map = 10 x resolution of fine map)}
\PYG{c+cm}{    // 15: the output directory}
\PYG{c+cm}{    // 16: the speciation rate.}
\PYG{c+cm}{    // 17: the dispersal distance (zfat).}
\PYG{c+cm}{    // 18: the deme size}
\PYG{c+cm}{    // 19: the deme sample size (as a proportion of deme size)}
\PYG{c+cm}{    // 20: the time to run the simulation (in seconds).}
\PYG{c+cm}{     // 21: lambda \PYGZhy{} the relative cost of moving through non\PYGZhy{}forest}
\PYG{c+cm}{    // 22: the\PYGZus{}task \PYGZhy{} for referencing the specific task later on.}
\PYG{c+cm}{    // 23: the minimum number of species the system is known to contain.}
\PYG{c+cm}{    // 24: the pristine fine map file to use}
\PYG{c+cm}{    // 25: the pristine coarse map file to use}
\PYG{c+cm}{    // 26: the rate of forest change from pristine}
\PYG{c+cm}{    // 27: the time (in generations) since the pristine forest was seen.}
\PYG{c+cm}{    // 28: the dispersal L value (the width of the kernel.}
\PYG{c+cm}{    // 29: the sample mask, with binary 1:0 values for areas that we want to sample from. If this is not provided then this will default to mapping the whole area.}
\PYG{c+cm}{    // 30:  the link to the file containing every generation that the list should be expanded. This should be in the format of a list.}
\PYG{c+cm}{    // 31\PYGZhy{} onwards: speciation rates to apply after the simulation is complete.}
\PYG{c+cm}{      */}
    \PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifndef verbose}
    \PYG{n}{openLogFile}\PYG{p}{(}\PYG{n+nb}{false}\PYG{p}{)}\PYG{p}{;}
    \PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif}
    \PYG{c+c1}{//freopen(\PYGZdq{}Logs/Log\PYGZus{}\PYGZdq{})}
      \PYG{k+kt}{bool} \PYG{n}{fullmode} \PYG{o}{=} \PYG{n+nb}{false}\PYG{p}{;}
     \PYG{k}{try}
     \PYG{p}{\PYGZob{}}
         \PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{n}{string}\PYG{o}{\PYGZgt{}} \PYG{n}{comargs}\PYG{p}{;}
        \PYG{k}{try}
        \PYG{p}{\PYGZob{}}
            \PYG{c+c1}{// Import the command line arguments and parse the arguments correctly.}
            \PYG{n}{importArgs}\PYG{p}{(}\PYG{n}{argc}\PYG{p}{,}\PYG{n}{argv}\PYG{p}{,}\PYG{n}{comargs}\PYG{p}{)}\PYG{p}{;}
            \PYG{n}{fullmode} \PYG{o}{=} \PYG{n}{parseArgs}\PYG{p}{(}\PYG{n}{argc}\PYG{p}{,}\PYG{n}{comargs}\PYG{p}{)}\PYG{p}{;}
\PYG{c+c1}{//          cout \PYGZlt{}\PYGZlt{} fullmode \PYGZlt{}\PYGZlt{} endl;}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{catch}\PYG{p}{(}\PYG{n}{Main\PYGZus{}Exception}\PYG{o}{\PYGZam{}} \PYG{n}{me}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{cerr} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{me}\PYG{p}{.}\PYG{n}{what}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
            \PYG{n}{exit}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{c+c1}{// Add the command line variables to the Mapvars structure.}
        \PYG{k}{try}
        \PYG{p}{\PYGZob{}}
            \PYG{k}{if}\PYG{p}{(}\PYG{n}{fullmode}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{n}{checkFolders}\PYG{p}{(}\PYG{n}{comargs}\PYG{p}{[}\PYG{l+m+mi}{4}\PYG{p}{]}\PYG{p}{,}\PYG{n}{comargs}\PYG{p}{[}\PYG{l+m+mi}{9}\PYG{p}{]}\PYG{p}{,}\PYG{n}{comargs}\PYG{p}{[}\PYG{l+m+mi}{24}\PYG{p}{]}\PYG{p}{,}\PYG{n}{comargs}\PYG{p}{[}\PYG{l+m+mi}{25}\PYG{p}{]}\PYG{p}{,}\PYG{n}{comargs}\PYG{p}{[}\PYG{l+m+mi}{15}\PYG{p}{]}\PYG{p}{,}\PYG{n}{comargs}\PYG{p}{[}\PYG{l+m+mi}{29}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
            \PYG{k}{else}
            \PYG{p}{\PYGZob{}}
\PYG{c+c1}{//              cout \PYGZlt{}\PYGZlt{} \PYGZsq{}test\PYGZsq{} \PYGZlt{}\PYGZlt{} endl;}
                \PYG{k}{if}\PYG{p}{(}\PYG{n}{comargs}\PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{]} \PYG{o}{=}\PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{null}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}
                \PYG{p}{\PYGZob{}}
                    \PYG{k}{throw} \PYG{n}{Fatal\PYGZus{}Exception}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ERROR\PYGZus{}MAIN\PYGZus{}009: FATAL. Map file cannot be null.}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
                \PYG{p}{\PYGZcb{}}
                \PYG{k}{if}\PYG{p}{(}\PYG{n}{comargs}\PYG{p}{[}\PYG{l+m+mi}{4}\PYG{p}{]} \PYG{o}{=}\PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{null}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}
                \PYG{p}{\PYGZob{}}
                    \PYG{k}{throw} \PYG{n}{Fatal\PYGZus{}Exception}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ERROR\PYGZus{}MAIN\PYGZus{}009: FATAL. Output folder cannot be null.}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
                \PYG{p}{\PYGZcb{}}
\PYG{c+c1}{//              for(unsigned i = 0; i \PYGZlt{} comargs.size(); i ++ )}
\PYG{c+c1}{//              \PYGZob{}}
\PYG{c+c1}{//                  cout \PYGZlt{}\PYGZlt{} comargs[i] \PYGZlt{}\PYGZlt{} endl;}
\PYG{c+c1}{//              \PYGZcb{}}
                \PYG{n}{doesExist}\PYG{p}{(}\PYG{n}{comargs}\PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
                \PYG{n}{doesExist}\PYG{p}{(}\PYG{n}{comargs}\PYG{p}{[}\PYG{l+m+mi}{4}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
                \PYG{n}{doesExistNull}\PYG{p}{(}\PYG{n}{comargs}\PYG{p}{[}\PYG{l+m+mi}{12}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{catch}\PYG{p}{(}\PYG{n}{Fatal\PYGZus{}Exception}\PYG{o}{\PYGZam{}} \PYG{n}{fe}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{cerr} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{fe}\PYG{p}{.}\PYG{n}{what}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
            \PYG{n}{exit}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{k+kt}{long} \PYG{n}{the\PYGZus{}seed} \PYG{o}{=} \PYG{n}{stoi}\PYG{p}{(}\PYG{n}{comargs}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}

        \PYG{c+c1}{// import the command line arguments (or config file parameters) in to the Mapvars object.}
        \PYG{c+c1}{// This object is passed on to the tree object for integration in to the whole simulation.}
        \PYG{c+c1}{// Create the tree object which contains the whole simulation}
        \PYG{n}{Tree} \PYG{n}{tree}\PYG{p}{;}
        \PYG{n}{tree}\PYG{p}{.}\PYG{n}{setSeed}\PYG{p}{(}\PYG{n}{the\PYGZus{}seed}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{// set the seed \PYGZhy{} removed the +161 as this can now be incorporated at a higher level, allowing for cleaner control.}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{fullmode}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{INITIALISING....}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{seed: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{the\PYGZus{}seed} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Speciation Rate: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{comargs}\PYG{p}{[}\PYG{l+m+mi}{16}\PYG{p}{]}\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Dispersal (z,L): }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{(}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{n}{comargs}\PYG{p}{[}\PYG{l+m+mi}{17}\PYG{p}{]}\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{,}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{comargs}\PYG{p}{[}\PYG{l+m+mi}{28}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{)}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{n}{endl}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{else}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{INITIALISING....}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{seed: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{the\PYGZus{}seed} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Speciation Rate: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{comargs}\PYG{p}{[}\PYG{l+m+mi}{5}\PYG{p}{]}\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Dispersal (z,L): }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{(}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{n}{comargs}\PYG{p}{[}\PYG{l+m+mi}{6}\PYG{p}{]}\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{,}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{comargs}\PYG{p}{[}\PYG{l+m+mi}{7}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{)}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{n}{endl}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{c+c1}{// Setup the simulations.}
        \PYG{n}{tree}\PYG{p}{.}\PYG{n}{setup}\PYG{p}{(}\PYG{n}{comargs}\PYG{p}{,}\PYG{n}{fullmode}\PYG{p}{)}\PYG{p}{;}
        \PYG{c+c1}{// Check for previous unfinished simulations with the same seed number.}
        \PYG{k+kt}{bool} \PYG{n}{simCheck} \PYG{o}{=} \PYG{n+nb}{false}\PYG{p}{;}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{fullmode}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{simCheck} \PYG{o}{=} \PYG{n}{checkSims}\PYG{p}{(}\PYG{n}{stoi}\PYG{p}{(}\PYG{n}{comargs}\PYG{p}{[}\PYG{l+m+mi}{22}\PYG{p}{]}\PYG{p}{)}\PYG{p}{,}\PYG{n}{the\PYGZus{}seed}\PYG{p}{,}\PYG{n}{comargs}\PYG{p}{[}\PYG{l+m+mi}{15}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{else}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{simCheck} \PYG{o}{=} \PYG{n}{checkSims}\PYG{p}{(}\PYG{n}{stoi}\PYG{p}{(}\PYG{n}{comargs}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{)}\PYG{p}{,}\PYG{n}{the\PYGZus{}seed}\PYG{p}{,}\PYG{n}{comargs}\PYG{p}{[}\PYG{l+m+mi}{4}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{n}{tree}\PYG{p}{.}\PYG{n}{simResume}\PYG{p}{(}\PYG{n}{simCheck}\PYG{p}{)}\PYG{p}{;}  \PYG{c+c1}{//will do nothing if check is false. Otherwise will load the paused simulation into RAM.}
        \PYG{c+c1}{// Run the simulation \PYGZhy{} the single longest and most important step.}
        \PYG{k+kt}{bool} \PYG{n}{isComplete} \PYG{o}{=} \PYG{n}{tree}\PYG{p}{.}\PYG{n}{runSim}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{if} \PYG{p}{(} \PYG{n}{isComplete} \PYG{p}{)}
        \PYG{p}{\PYGZob{}}
\PYG{c+c1}{//          cout \PYGZlt{}\PYGZlt{} \PYGZdq{}size: \PYGZdq{} \PYGZlt{}\PYGZlt{} argc \PYGZlt{}\PYGZlt{} \PYGZdq{} alt: \PYGZdq{} \PYGZlt{}\PYGZlt{} comargs.size() \PYGZlt{}\PYGZlt{} endl;}
            \PYG{n}{getSR}\PYG{p}{(}\PYG{n}{comargs}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{n}{comargs}\PYG{p}{,}\PYG{n}{tree}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
     \PYG{p}{\PYGZcb{}}
     \PYG{k}{catch}\PYG{p}{(}\PYG{n}{Fatal\PYGZus{}Exception}\PYG{o}{\PYGZam{}} \PYG{n}{fe}\PYG{p}{)}
     \PYG{p}{\PYGZob{}}
         \PYG{n}{cerr} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{fe}\PYG{p}{.}\PYG{n}{what}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
         \PYG{k}{return} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{;}
     \PYG{p}{\PYGZcb{}}
     \PYG{k}{catch}\PYG{p}{(}\PYG{n}{Map\PYGZus{}Fatal\PYGZus{}Exception}\PYG{o}{\PYGZam{}} \PYG{n}{mfe}\PYG{p}{)}
     \PYG{p}{\PYGZob{}}
         \PYG{n}{cerr} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{mfe}\PYG{p}{.}\PYG{n}{what}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
         \PYG{k}{return} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{;}
     \PYG{p}{\PYGZcb{}}
     \PYG{k}{catch}\PYG{p}{(}\PYG{k}{const} \PYG{n}{exception} \PYG{o}{\PYGZam{}}\PYG{n}{e}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{cerr} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{e}\PYG{p}{.}\PYG{n}{what}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifndef verbose}
    \PYG{n}{fclose}\PYG{p}{(}\PYG{n}{stdout}\PYG{p}{)}\PYG{p}{;}
    \PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif}
    \PYG{k}{return} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}


\subparagraph{Includes}
\label{\detokenize{Exhaled/exhale_file_main.cpp:includes}}\begin{itemize}
\item {} 
\sphinxcode{Setup.h} ({\hyperref[\detokenize{Exhaled/exhale_file_Setup.h:file-setup-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File Setup.h}}}})

\item {} 
\sphinxcode{stdio.h}

\end{itemize}


\subparagraph{Functions}
\label{\detokenize{Exhaled/exhale_file_main.cpp:functions}}\begin{itemize}
\item {} 
{\hyperref[\detokenize{Exhaled/exhale_function_main:function-main}]{\sphinxcrossref{\DUrole{std,std-ref}{Function main}}}}

\end{itemize}


\paragraph{File Map.cpp}
\label{\detokenize{Exhaled/exhale_file_Map.cpp:id1}}\label{\detokenize{Exhaled/exhale_file_Map.cpp::doc}}\label{\detokenize{Exhaled/exhale_file_Map.cpp:file-map-cpp}}

\subparagraph{Definition (\sphinxstyleliteralintitle{Map.cpp})}
\label{\detokenize{Exhaled/exhale_file_Map.cpp:definition-map-cpp}}

\subparagraph{Program Listing for File Map.cpp}
\label{\detokenize{Exhaled/exhale_program_listing_file_Map.cpp::doc}}\label{\detokenize{Exhaled/exhale_program_listing_file_Map.cpp:program-listing-for-file-map-cpp}}\label{\detokenize{Exhaled/exhale_program_listing_file_Map.cpp:program-listing-file-map-cpp}}\begin{itemize}
\item {} 
Return to documentation for {\hyperref[\detokenize{Exhaled/exhale_file_Map.cpp:file-map-cpp}]{\sphinxcrossref{\DUrole{std,std-ref}{File Map.cpp}}}}

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{// This file is part of NECSim project which is released under BSD\PYGZhy{}3 license.}
\PYG{c+c1}{// See file **LICENSE.txt** or visit https://opensource.org/licenses/BSD\PYGZhy{}3\PYGZhy{}Clause) for full license details}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZdq{}Map.h\PYGZdq{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZdq{}Setup.h\PYGZdq{}}

\PYG{k+kt}{void} \PYG{n}{Map}\PYG{o}{:}\PYG{o}{:}\PYG{n}{setDims}\PYG{p}{(}\PYG{n}{Mapvars} \PYG{n}{mapvarsin}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k}{if}\PYG{p}{(}\PYG{o}{!}\PYG{n}{checksetdim}\PYG{p}{)}  \PYG{c+c1}{// checks to make sure it hasn\PYGZsq{}t been run already.}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{mapvars} \PYG{o}{=} \PYG{n}{mapvarsin}\PYG{p}{;}
        \PYG{n}{deme} \PYG{o}{=} \PYG{n}{mapvarsin}\PYG{p}{.}\PYG{n}{deme}\PYG{p}{;}
        \PYG{n}{xdim} \PYG{o}{=} \PYG{n}{mapvarsin}\PYG{p}{.}\PYG{n}{vargridxsize}\PYG{p}{;}
        \PYG{n}{ydim} \PYG{o}{=} \PYG{n}{mapvarsin}\PYG{p}{.}\PYG{n}{vargridysize}\PYG{p}{;}
        \PYG{n}{scale} \PYG{o}{=} \PYG{n}{mapvarsin}\PYG{p}{.}\PYG{n}{varcoarsemapscale}\PYG{p}{;}
        \PYG{n}{nUpdate} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
        \PYG{n}{checksetdim} \PYG{o}{=} \PYG{n+nb}{true}\PYG{p}{;}
        \PYG{n}{dUpdateTime} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
        \PYG{n}{dPristine} \PYG{o}{=} \PYG{n}{mapvarsin}\PYG{p}{.}\PYG{n}{dPristine}\PYG{p}{;}
        \PYG{n}{dForestTransform} \PYG{o}{=} \PYG{n}{mapvarsin}\PYG{p}{.}\PYG{n}{dForestTransform}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{else}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{cerr} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ERROR\PYGZus{}MAP\PYGZus{}001: Dimensions have already been set}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
        \PYG{k}{return}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{return}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{bool} \PYG{n}{Map}\PYG{o}{:}\PYG{o}{:}\PYG{n}{checkMapExists}\PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{mapvars}\PYG{p}{.}\PYG{n}{configs}\PYG{p}{.}\PYG{n}{getSectionOptionsSize}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{string} \PYG{n}{tmppath} \PYG{o}{=} \PYG{n}{mapvars}\PYG{p}{.}\PYG{n}{configs}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getOption}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{path}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{if}\PYG{p}{(}\PYG{o}{!}\PYG{n}{doesExistNull}\PYG{p}{(}\PYG{n}{tmppath}\PYG{p}{)}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{k}{return} \PYG{p}{(}\PYG{n+nb}{false}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{return} \PYG{p}{(}\PYG{n+nb}{true}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{void} \PYG{n}{Map}\PYG{o}{:}\PYG{o}{:}\PYG{n}{calcFineMap}\PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{n}{string} \PYG{n}{fileinput} \PYG{o}{=} \PYG{n}{mapvars}\PYG{p}{.}\PYG{n}{finemapfile}\PYG{p}{;}
    \PYG{k+kt}{long} \PYG{n}{mapxsize} \PYG{o}{=} \PYG{n}{mapvars}\PYG{p}{.}\PYG{n}{varfinemapxsize}\PYG{p}{;}
    \PYG{k+kt}{long} \PYG{n}{mapysize} \PYG{o}{=} \PYG{n}{mapvars}\PYG{p}{.}\PYG{n}{varfinemapysize}\PYG{p}{;}
    \PYG{k}{if}\PYG{p}{(}\PYG{o}{!}\PYG{n}{checksetdim}\PYG{p}{)}  \PYG{c+c1}{// checks that the dimensions have been set.}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{throw} \PYG{n}{Map\PYGZus{}Exception}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ERROR\PYGZus{}MAP\PYGZus{}002: dimensions not set.}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{c+c1}{// Note that the default \PYGZdq{}null\PYGZdq{} type is to have 100\PYGZpc{} forest cover in every cell.}
    \PYG{n}{Matrix}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{float}\PYG{o}{\PYGZgt{}} \PYG{n}{toret}\PYG{p}{;}
    \PYG{n}{toret}\PYG{p}{.}\PYG{n}{SetSize}\PYG{p}{(}\PYG{n}{mapysize}\PYG{p}{,} \PYG{n}{mapxsize}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{fine\PYGZus{}map}\PYG{p}{.}\PYG{n}{SetSize}\PYG{p}{(}\PYG{n}{mapysize}\PYG{p}{,} \PYG{n}{mapxsize}\PYG{p}{)}\PYG{p}{;}
    \PYG{k}{if}\PYG{p}{(}\PYG{n}{fileinput} \PYG{o}{=}\PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{null}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{mapxsize}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{j} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{j} \PYG{o}{\PYGZlt{}} \PYG{n}{mapysize}\PYG{p}{;} \PYG{n}{j}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{n}{toret}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mf}{1.0}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
        \PYG{p}{\PYGZcb{}}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{else}  \PYG{c+c1}{// There is a map to read in.}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{toret}\PYG{p}{.}\PYG{n}{import}\PYG{p}{(}\PYG{n}{fileinput}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{c+c1}{// cout \PYGZlt{}\PYGZlt{} toret \PYGZlt{}\PYGZlt{} endl;}
    \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{mapxsize}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{j} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{j} \PYG{o}{\PYGZlt{}} \PYG{n}{mapysize}\PYG{p}{;} \PYG{n}{j}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{fine\PYGZus{}map}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{=} \PYG{n}{round}\PYG{p}{(}\PYG{n}{toret}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{*} \PYG{n}{deme}\PYG{p}{)}\PYG{p}{;}
\PYG{c+c1}{//          cout \PYGZlt{}\PYGZlt{} fine\PYGZus{}map[j][i] \PYGZlt{}\PYGZlt{} endl;}
        \PYG{p}{\PYGZcb{}}
    \PYG{p}{\PYGZcb{}}
    \PYG{c+c1}{// cout \PYGZlt{}\PYGZlt{} \PYGZdq{}deme: \PYGZdq{} \PYGZlt{}\PYGZlt{} deme \PYGZlt{}\PYGZlt{} endl;}
    \PYG{k}{return}\PYG{p}{;}
    \PYG{c+c1}{//*/}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{void} \PYG{n}{Map}\PYG{o}{:}\PYG{o}{:}\PYG{n}{calcPristineFineMap}\PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{n}{string} \PYG{n}{fileinput} \PYG{o}{=} \PYG{n}{mapvars}\PYG{p}{.}\PYG{n}{pristinefinemapfile}\PYG{p}{;}
    \PYG{k+kt}{long} \PYG{n}{mapxsize} \PYG{o}{=} \PYG{n}{mapvars}\PYG{p}{.}\PYG{n}{varfinemapxsize}\PYG{p}{;}
    \PYG{k+kt}{long} \PYG{n}{mapysize} \PYG{o}{=} \PYG{n}{mapvars}\PYG{p}{.}\PYG{n}{varfinemapysize}\PYG{p}{;}
    \PYG{k}{if}\PYG{p}{(}\PYG{o}{!}\PYG{n}{checksetdim}\PYG{p}{)}  \PYG{c+c1}{// checks that the dimensions have been set.}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{throw} \PYG{n}{Map\PYGZus{}Exception}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ERROR\PYGZus{}MAP\PYGZus{}002: dimensions not set.}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{c+c1}{// Note that the default \PYGZdq{}null\PYGZdq{} type is to have 100\PYGZpc{} forest cover in every cell.}
    \PYG{n}{Matrix}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{float}\PYG{o}{\PYGZgt{}} \PYG{n}{toret}\PYG{p}{;}
    \PYG{n}{toret}\PYG{p}{.}\PYG{n}{SetSize}\PYG{p}{(}\PYG{n}{mapysize}\PYG{p}{,} \PYG{n}{mapxsize}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{pristine\PYGZus{}fine\PYGZus{}map}\PYG{p}{.}\PYG{n}{SetSize}\PYG{p}{(}\PYG{n}{mapysize}\PYG{p}{,} \PYG{n}{mapxsize}\PYG{p}{)}\PYG{p}{;}
    \PYG{k}{if}\PYG{p}{(}\PYG{n}{fileinput} \PYG{o}{=}\PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{null}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{mapxsize}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{j} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{j} \PYG{o}{\PYGZlt{}} \PYG{n}{mapysize}\PYG{p}{;} \PYG{n}{j}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{n}{toret}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mf}{1.0}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
        \PYG{p}{\PYGZcb{}}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{else}  \PYG{c+c1}{// There is a map to read in.}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{toret}\PYG{p}{.}\PYG{n}{import}\PYG{p}{(}\PYG{n}{fileinput}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{c+c1}{// cout \PYGZlt{}\PYGZlt{} toret \PYGZlt{}\PYGZlt{} endl;}
    \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{mapxsize}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{j} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{j} \PYG{o}{\PYGZlt{}} \PYG{n}{mapysize}\PYG{p}{;} \PYG{n}{j}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{pristine\PYGZus{}fine\PYGZus{}map}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{=} \PYG{n}{round}\PYG{p}{(}\PYG{n}{toret}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{*} \PYG{n}{deme}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
    \PYG{p}{\PYGZcb{}}
    \PYG{c+c1}{// cout \PYGZlt{}\PYGZlt{} \PYGZdq{}deme: \PYGZdq{} \PYGZlt{}\PYGZlt{} deme \PYGZlt{}\PYGZlt{} endl;}
    \PYG{k}{return}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{void} \PYG{n}{Map}\PYG{o}{:}\PYG{o}{:}\PYG{n}{calcCoarseMap}\PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{n}{string} \PYG{n}{fileinput} \PYG{o}{=} \PYG{n}{mapvars}\PYG{p}{.}\PYG{n}{coarsemapfile}\PYG{p}{;}
    \PYG{k+kt}{long} \PYG{n}{mapxsize} \PYG{o}{=} \PYG{n}{mapvars}\PYG{p}{.}\PYG{n}{varcoarsemapxsize}\PYG{p}{;}
    \PYG{k+kt}{long} \PYG{n}{mapysize} \PYG{o}{=} \PYG{n}{mapvars}\PYG{p}{.}\PYG{n}{varcoarsemapysize}\PYG{p}{;}
    \PYG{k}{if}\PYG{p}{(}\PYG{o}{!}\PYG{n}{checksetdim}\PYG{p}{)}  \PYG{c+c1}{// checks that the dimensions have been set.}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{throw} \PYG{n}{Map\PYGZus{}Exception}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ERROR\PYGZus{}MAP\PYGZus{}003: dimensions not set.}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{c+c1}{// Note that the default \PYGZdq{}null\PYGZdq{} type for the coarse type is to have non\PYGZhy{}forest in every cell.}
    \PYG{n}{Matrix}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{float}\PYG{o}{\PYGZgt{}} \PYG{n}{toret}\PYG{p}{;}
    \PYG{n}{toret}\PYG{p}{.}\PYG{n}{SetSize}\PYG{p}{(}\PYG{n}{mapysize}\PYG{p}{,} \PYG{n}{mapxsize}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{coarse\PYGZus{}map}\PYG{p}{.}\PYG{n}{SetSize}\PYG{p}{(}\PYG{n}{mapysize}\PYG{p}{,} \PYG{n}{mapxsize}\PYG{p}{)}\PYG{p}{;}
    \PYG{k}{if}\PYG{p}{(}\PYG{n}{fileinput} \PYG{o}{=}\PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{null}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{mapxsize}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{j} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{j} \PYG{o}{\PYGZlt{}} \PYG{n}{mapysize}\PYG{p}{;} \PYG{n}{j}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{n}{toret}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mf}{0.0}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
        \PYG{p}{\PYGZcb{}}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{else}  \PYG{c+c1}{// There is a map to read in.}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{toret}\PYG{p}{.}\PYG{n}{import}\PYG{p}{(}\PYG{n}{fileinput}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{mapxsize}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{j} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{j} \PYG{o}{\PYGZlt{}} \PYG{n}{mapysize}\PYG{p}{;} \PYG{n}{j}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{coarse\PYGZus{}map}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{=} \PYG{n}{round}\PYG{p}{(}\PYG{n}{toret}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{*} \PYG{n}{deme} \PYG{o}{*} \PYG{n}{scale} \PYG{o}{*} \PYG{n}{scale}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{return}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{void} \PYG{n}{Map}\PYG{o}{:}\PYG{o}{:}\PYG{n}{calcPristineCoarseMap}\PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{n}{string} \PYG{n}{fileinput} \PYG{o}{=} \PYG{n}{mapvars}\PYG{p}{.}\PYG{n}{pristinecoarsemapfile}\PYG{p}{;}
    \PYG{k+kt}{long} \PYG{n}{mapxsize} \PYG{o}{=} \PYG{n}{mapvars}\PYG{p}{.}\PYG{n}{varcoarsemapxsize}\PYG{p}{;}
    \PYG{k+kt}{long} \PYG{n}{mapysize} \PYG{o}{=} \PYG{n}{mapvars}\PYG{p}{.}\PYG{n}{varcoarsemapysize}\PYG{p}{;}
    \PYG{k}{if}\PYG{p}{(}\PYG{o}{!}\PYG{n}{checksetdim}\PYG{p}{)}  \PYG{c+c1}{// checks that the dimensions have been set.}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{throw} \PYG{n}{Map\PYGZus{}Exception}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ERROR\PYGZus{}MAP\PYGZus{}003: dimensions not set.}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{c+c1}{// Note that the default \PYGZdq{}null\PYGZdq{} type for the coarse type is to have non\PYGZhy{}forest in every cell.}
    \PYG{n}{Matrix}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{float}\PYG{o}{\PYGZgt{}} \PYG{n}{toret}\PYG{p}{;}
    \PYG{n}{toret}\PYG{p}{.}\PYG{n}{SetSize}\PYG{p}{(}\PYG{n}{mapysize}\PYG{p}{,} \PYG{n}{mapxsize}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{pristine\PYGZus{}coarse\PYGZus{}map}\PYG{p}{.}\PYG{n}{SetSize}\PYG{p}{(}\PYG{n}{mapysize}\PYG{p}{,} \PYG{n}{mapxsize}\PYG{p}{)}\PYG{p}{;}
    \PYG{k}{if}\PYG{p}{(}\PYG{n}{fileinput} \PYG{o}{=}\PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{null}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{mapxsize}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{j} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{j} \PYG{o}{\PYGZlt{}} \PYG{n}{mapysize}\PYG{p}{;} \PYG{n}{j}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{n}{toret}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mf}{1.0}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
        \PYG{p}{\PYGZcb{}}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{else}  \PYG{c+c1}{// There is a map to read in.}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{toret}\PYG{p}{.}\PYG{n}{import}\PYG{p}{(}\PYG{n}{fileinput}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{mapxsize}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{j} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{j} \PYG{o}{\PYGZlt{}} \PYG{n}{mapysize}\PYG{p}{;} \PYG{n}{j}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{pristine\PYGZus{}coarse\PYGZus{}map}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{=} \PYG{n}{round}\PYG{p}{(}\PYG{n}{toret}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{*} \PYG{n}{deme} \PYG{o}{*} \PYG{n}{scale} \PYG{o}{*} \PYG{n}{scale}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
    \PYG{p}{\PYGZcb{}}

    \PYG{k}{return}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{void} \PYG{n}{Map}\PYG{o}{:}\PYG{o}{:}\PYG{n}{setTimeVars}\PYG{p}{(}\PYG{k+kt}{double} \PYG{n}{dPristinein}\PYG{p}{,} \PYG{k+kt}{double} \PYG{n}{dForestTransformin}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{n}{dUpdateTime} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
    \PYG{n}{dPristine} \PYG{o}{=} \PYG{n}{dPristinein}\PYG{p}{;}
    \PYG{n}{dForestTransform} \PYG{o}{=} \PYG{n}{dForestTransformin}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{void} \PYG{n}{Map}\PYG{o}{:}\PYG{o}{:}\PYG{n}{calcOffset}\PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k}{if}\PYG{p}{(}\PYG{n}{mapvars}\PYG{p}{.}\PYG{n}{autocorrel\PYGZus{}file} \PYG{o}{!}\PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{null}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{mapvars}\PYG{p}{.}\PYG{n}{setPristine}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
\PYG{c+c1}{//  cout \PYGZlt{}\PYGZlt{} mapvars.autocorrel\PYGZus{}file \PYGZlt{}\PYGZlt{} endl;}
    \PYG{k}{if}\PYG{p}{(}\PYG{n}{fine\PYGZus{}map}\PYG{p}{.}\PYG{n}{GetCols}\PYG{p}{(}\PYG{p}{)} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{0} \PYG{o}{\textbar{}}\PYG{o}{\textbar{}} \PYG{n}{fine\PYGZus{}map}\PYG{p}{.}\PYG{n}{GetRows}\PYG{p}{(}\PYG{p}{)} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{throw} \PYG{n}{Map\PYGZus{}Exception}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ERROR\PYGZus{}MAP\PYGZus{}004: fine map not set.}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{if}\PYG{p}{(}\PYG{n}{coarse\PYGZus{}map}\PYG{p}{.}\PYG{n}{GetCols}\PYG{p}{(}\PYG{p}{)} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{0} \PYG{o}{\textbar{}}\PYG{o}{\textbar{}} \PYG{n}{coarse\PYGZus{}map}\PYG{p}{.}\PYG{n}{GetRows}\PYG{p}{(}\PYG{p}{)} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{coarse\PYGZus{}map}\PYG{p}{.}\PYG{n}{SetSize}\PYG{p}{(}\PYG{n}{fine\PYGZus{}map}\PYG{p}{.}\PYG{n}{GetRows}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{n}{fine\PYGZus{}map}\PYG{p}{.}\PYG{n}{GetCols}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{c+c1}{//      throw Map\PYGZus{}Exception(\PYGZdq{}ERROR\PYGZus{}MAP\PYGZus{}004: coarse map not set.\PYGZdq{});}
    \PYG{p}{\PYGZcb{}}
    \PYG{n}{finexoffset} \PYG{o}{=} \PYG{n}{mapvars}\PYG{p}{.}\PYG{n}{varfinemapxoffset}\PYG{p}{;}
    \PYG{n}{fineyoffset} \PYG{o}{=} \PYG{n}{mapvars}\PYG{p}{.}\PYG{n}{varfinemapyoffset}\PYG{p}{;}
    \PYG{n}{coarsexoffset} \PYG{o}{=} \PYG{n}{mapvars}\PYG{p}{.}\PYG{n}{varcoarsemapxoffset}\PYG{p}{;}
    \PYG{n}{coarseyoffset} \PYG{o}{=} \PYG{n}{mapvars}\PYG{p}{.}\PYG{n}{varcoarsemapyoffset}\PYG{p}{;}
    \PYG{n}{scale} \PYG{o}{=} \PYG{n}{mapvars}\PYG{p}{.}\PYG{n}{varcoarsemapscale}\PYG{p}{;}
    \PYG{c+c1}{// this is the location of the top left (or north west) corner of the respective map}
    \PYG{c+c1}{// and the x and y distance from the top left of the grid object that contains the initial lineages.}
    \PYG{n}{finexmin} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{n}{finexoffset}\PYG{p}{;}
    \PYG{n}{fineymin} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{n}{fineyoffset}\PYG{p}{;}
    \PYG{n}{finexmax} \PYG{o}{=} \PYG{n}{finexmin} \PYG{o}{+} \PYG{p}{(}\PYG{n}{fine\PYGZus{}map}\PYG{p}{.}\PYG{n}{GetCols}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{fineymax} \PYG{o}{=} \PYG{n}{fineymin} \PYG{o}{+} \PYG{p}{(}\PYG{n}{fine\PYGZus{}map}\PYG{p}{.}\PYG{n}{GetRows}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{coarsexmin} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{n}{coarsexoffset} \PYG{o}{\PYGZhy{}} \PYG{n}{finexoffset}\PYG{p}{;}
    \PYG{n}{coarseymin} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{n}{coarseyoffset} \PYG{o}{\PYGZhy{}} \PYG{n}{fineyoffset}\PYG{p}{;}
    \PYG{n}{coarsexmax} \PYG{o}{=} \PYG{n}{coarsexmin} \PYG{o}{+} \PYG{n}{scale} \PYG{o}{*} \PYG{p}{(}\PYG{n}{coarse\PYGZus{}map}\PYG{p}{.}\PYG{n}{GetCols}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{coarseymax} \PYG{o}{=} \PYG{n}{coarseymin} \PYG{o}{+} \PYG{n}{scale} \PYG{o}{*} \PYG{p}{(}\PYG{n}{coarse\PYGZus{}map}\PYG{p}{.}\PYG{n}{GetRows}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{lambda} \PYG{o}{=} \PYG{n}{mapvars}\PYG{p}{.}\PYG{n}{lambda}\PYG{p}{;}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifdef DEBUG}
    \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{finex: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{finexmin} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{,}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{finexmax} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
    \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{finey: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{fineymin} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{,}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{fineymax} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
    \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{coarsex: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{coarsexmin} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{,}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{coarsexmax} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
    \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{coarsey: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{coarseymin} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{,}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{coarseymax} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
    \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{offsets: }\PYG{l+s}{\PYGZdq{}}
         \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{(}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{finexoffset} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{,}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{fineyoffset} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{)(}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{coarsexoffset} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{,}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{coarseyoffset} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{)}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
    \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{pristine fine file: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{pristine\PYGZus{}fine\PYGZus{}map} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
    \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{pristine coarse file: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{pristine\PYGZus{}coarse\PYGZus{}map} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif}
    \PYG{c+c1}{//      cout \PYGZlt{}\PYGZlt{} \PYGZdq{}fine variables: \PYGZdq{} \PYGZlt{}\PYGZlt{} finexmin \PYGZlt{}\PYGZlt{} \PYGZdq{},\PYGZdq{} \PYGZlt{}\PYGZlt{} finexmax \PYGZlt{}\PYGZlt{} endl;}
    \PYG{c+c1}{//      cout \PYGZlt{}\PYGZlt{} \PYGZdq{}coarse variabes: \PYGZdq{} \PYGZlt{}\PYGZlt{} coarsexmin \PYGZlt{}\PYGZlt{} \PYGZdq{},\PYGZdq{} \PYGZlt{}\PYGZlt{} coarsexmax \PYGZlt{}\PYGZlt{} endl;}
    \PYG{k}{if}\PYG{p}{(}\PYG{n}{finexmin} \PYG{o}{\PYGZlt{}} \PYG{n}{coarsexmin} \PYG{o}{\textbar{}}\PYG{o}{\textbar{}} \PYG{n}{finexmax} \PYG{o}{\PYGZgt{}} \PYG{n}{coarsexmax} \PYG{o}{\textbar{}}\PYG{o}{\textbar{}} \PYG{p}{(}\PYG{n}{finexmax} \PYG{o}{\PYGZhy{}} \PYG{n}{finexmin}\PYG{p}{)} \PYG{o}{\PYGZlt{}} \PYG{n}{xdim} \PYG{o}{\textbar{}}\PYG{o}{\textbar{}} \PYG{p}{(}\PYG{n}{fineymax} \PYG{o}{\PYGZhy{}} \PYG{n}{fineymin}\PYG{p}{)} \PYG{o}{\PYGZlt{}} \PYG{n}{ydim}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{throw} \PYG{n}{Map\PYGZus{}Fatal\PYGZus{}Exception}\PYG{p}{(}
            \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ERROR\PYGZus{}MAP\PYGZus{}006: FATAL \PYGZhy{} fine map extremes outside coarse map or sample grid larger than fine map}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{return}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{void} \PYG{n}{Map}\PYG{o}{:}\PYG{o}{:}\PYG{n}{validateMaps}\PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}r}\PYG{l+s}{Validating maps...}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{flush}\PYG{p}{;}
    \PYG{k}{if}\PYG{p}{(}\PYG{n}{fine\PYGZus{}map}\PYG{p}{.}\PYG{n}{GetCols}\PYG{p}{(}\PYG{p}{)} \PYG{o}{=}\PYG{o}{=} \PYG{n}{pristine\PYGZus{}fine\PYGZus{}map}\PYG{p}{.}\PYG{n}{GetCols}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{n}{fine\PYGZus{}map}\PYG{p}{.}\PYG{n}{GetRows}\PYG{p}{(}\PYG{p}{)} \PYG{o}{=}\PYG{o}{=} \PYG{n}{pristine\PYGZus{}fine\PYGZus{}map}\PYG{p}{.}\PYG{n}{GetRows}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}}
       \PYG{n}{coarse\PYGZus{}map}\PYG{p}{.}\PYG{n}{GetCols}\PYG{p}{(}\PYG{p}{)} \PYG{o}{=}\PYG{o}{=} \PYG{n}{pristine\PYGZus{}coarse\PYGZus{}map}\PYG{p}{.}\PYG{n}{GetCols}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{n}{coarse\PYGZus{}map}\PYG{p}{.}\PYG{n}{GetRows}\PYG{p}{(}\PYG{p}{)} \PYG{o}{=}\PYG{o}{=} \PYG{n}{pristine\PYGZus{}coarse\PYGZus{}map}\PYG{p}{.}\PYG{n}{GetRows}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}r}\PYG{l+s}{Validating maps...map sizes okay}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{flush}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{else}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{throw} \PYG{n}{Map\PYGZus{}Fatal\PYGZus{}Exception}\PYG{p}{(}
            \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ERROR\PYGZus{}MAP\PYGZus{}009: Map validation failed \PYGZhy{} modern and pristine maps are not the same dimensions.}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{k+kt}{double} \PYG{n}{dTotal} \PYG{o}{=} \PYG{n}{fine\PYGZus{}map}\PYG{p}{.}\PYG{n}{GetCols}\PYG{p}{(}\PYG{p}{)} \PYG{o}{+} \PYG{n}{coarse\PYGZus{}map}\PYG{p}{.}\PYG{n}{GetCols}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{iCounter} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
    \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{fine\PYGZus{}map}\PYG{p}{.}\PYG{n}{GetCols}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{j} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{j} \PYG{o}{\PYGZlt{}} \PYG{n}{fine\PYGZus{}map}\PYG{p}{.}\PYG{n}{GetRows}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{n}{j}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{k}{if}\PYG{p}{(}\PYG{n}{fine\PYGZus{}map}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{\PYGZgt{}} \PYG{n}{pristine\PYGZus{}fine\PYGZus{}map}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{n}{cerr} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{fine map: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{fine\PYGZus{}map}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{pristine map: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{pristine\PYGZus{}fine\PYGZus{}map}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}
                     \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
                \PYG{n}{cerr} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{x,y: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{i} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{,}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{j} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
                \PYG{k}{throw} \PYG{n+nf}{Map\PYGZus{}Fatal\PYGZus{}Exception}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ERROR\PYGZus{}MAP\PYGZus{}007: Map validation failed \PYGZhy{} fine map value larger }\PYG{l+s}{\PYGZdq{}}
                                          \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{than pristine fine map value.}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
        \PYG{p}{\PYGZcb{}}
        \PYG{k+kt}{double} \PYG{n}{dPercentComplete} \PYG{o}{=} \PYG{l+m+mi}{100} \PYG{o}{*} \PYG{p}{(}\PYG{p}{(}\PYG{k+kt}{double}\PYG{p}{)}\PYG{p}{(}\PYG{n}{i} \PYG{o}{+} \PYG{n}{iCounter}\PYG{p}{)} \PYG{o}{/} \PYG{n}{dTotal}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{i} \PYG{o}{\PYGZpc{}} \PYG{l+m+mi}{1000} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}r}\PYG{l+s}{Validating maps...}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{dPercentComplete} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZpc{}                }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{flush}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
    \PYG{p}{\PYGZcb{}}
    \PYG{n}{iCounter} \PYG{o}{=} \PYG{n}{fine\PYGZus{}map}\PYG{p}{.}\PYG{n}{GetCols}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
    \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{coarse\PYGZus{}map}\PYG{p}{.}\PYG{n}{GetCols}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{j} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{j} \PYG{o}{\PYGZlt{}} \PYG{n}{coarse\PYGZus{}map}\PYG{p}{.}\PYG{n}{GetRows}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{n}{j}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{k}{if}\PYG{p}{(}\PYG{n}{coarse\PYGZus{}map}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{\PYGZgt{}} \PYG{n}{pristine\PYGZus{}coarse\PYGZus{}map}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{n}{cerr} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{coarse map: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{coarse\PYGZus{}map}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ pristine map: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{pristine\PYGZus{}coarse\PYGZus{}map}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}
                     \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
                \PYG{n}{cerr} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{coarse map x+1: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{coarse\PYGZus{}map}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{p}{[}\PYG{n}{i} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{p}{]}
                     \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ pristine map: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{pristine\PYGZus{}coarse\PYGZus{}map}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{p}{[}\PYG{n}{i} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
                \PYG{n}{cerr} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{x,y: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{i} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{,}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{j} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
                \PYG{k}{throw} \PYG{n+nf}{Map\PYGZus{}Fatal\PYGZus{}Exception}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ERROR\PYGZus{}MAP\PYGZus{}008: Map validation failed \PYGZhy{} coarse map value larger }\PYG{l+s}{\PYGZdq{}}
                                          \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{than pristine coarse map value.}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
        \PYG{p}{\PYGZcb{}}
        \PYG{k+kt}{double} \PYG{n}{dPercentComplete} \PYG{o}{=} \PYG{l+m+mi}{100} \PYG{o}{*} \PYG{p}{(}\PYG{p}{(}\PYG{k+kt}{double}\PYG{p}{)}\PYG{p}{(}\PYG{n}{i} \PYG{o}{+} \PYG{n}{iCounter}\PYG{p}{)} \PYG{o}{/} \PYG{n}{dTotal}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{i} \PYG{o}{\PYGZpc{}} \PYG{l+m+mi}{1000} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}r}\PYG{l+s}{Validating maps...}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{dPercentComplete} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZpc{}                }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{flush}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
    \PYG{p}{\PYGZcb{}}
    \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}r}\PYG{l+s}{Validating maps complete                                       }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{void} \PYG{n}{Map}\PYG{o}{:}\PYG{o}{:}\PYG{n}{updateMap}\PYG{p}{(}\PYG{k+kt}{double} \PYG{n}{generation}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{c+c1}{// only update the map if the pristine state has not been reached.}
    \PYG{k}{if}\PYG{p}{(}\PYG{o}{!}\PYG{n}{mapvars}\PYG{p}{.}\PYG{n}{bPristine}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{mapvars}\PYG{p}{.}\PYG{n}{dPristine} \PYG{o}{\PYGZlt{}} \PYG{n}{generation}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{fine\PYGZus{}map} \PYG{o}{=} \PYG{n}{pristine\PYGZus{}fine\PYGZus{}map}\PYG{p}{;}
            \PYG{n}{nUpdate}\PYG{o}{+}\PYG{o}{+}\PYG{p}{;}
            \PYG{n}{mapvars}\PYG{p}{.}\PYG{n}{setPristine}\PYG{p}{(}\PYG{n}{nUpdate}\PYG{p}{)}\PYG{p}{;}
            \PYG{c+c1}{// pristine\PYGZus{}fine\PYGZus{}map = mapvars.pristinefinemapfile;}
            \PYG{c+c1}{// pristine\PYGZus{}coarse\PYGZus{}map = mapvars.pristinecoarsemapfile;}
            \PYG{n}{dCurrent} \PYG{o}{=} \PYG{n}{dPristine}\PYG{p}{;}
            \PYG{n}{dPristine} \PYG{o}{=} \PYG{n}{mapvars}\PYG{p}{.}\PYG{n}{dPristine}\PYG{p}{;}
            \PYG{n}{dForestTransform} \PYG{o}{=} \PYG{n}{mapvars}\PYG{p}{.}\PYG{n}{dForestTransform}\PYG{p}{;}
            \PYG{n}{calcPristineCoarseMap}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
            \PYG{n}{calcPristineFineMap}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
    \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}

\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifdef infinite\PYGZus{}landscape}
\PYG{k+kt}{unsigned} \PYG{k+kt}{short} \PYG{n}{Map}\PYG{o}{:}\PYG{o}{:}\PYG{n}{getVal}\PYG{p}{(}
    \PYG{k}{const} \PYG{k+kt}{double}\PYG{o}{\PYGZam{}} \PYG{n}{x}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{double}\PYG{o}{\PYGZam{}} \PYG{n}{y}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{long}\PYG{o}{\PYGZam{}} \PYG{n}{xwrap}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{long}\PYG{o}{\PYGZam{}} \PYG{n}{ywrap}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{double}\PYG{o}{\PYGZam{}} \PYG{n}{dCurrentGen}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k}{return} \PYG{n}{deme}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif}

\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifndef infinite\PYGZus{}landscape}
\PYG{k+kt}{unsigned} \PYG{k+kt}{short} \PYG{n}{Map}\PYG{o}{:}\PYG{o}{:}\PYG{n}{getVal}\PYG{p}{(}
    \PYG{k}{const} \PYG{k+kt}{double}\PYG{o}{\PYGZam{}} \PYG{n}{x}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{double}\PYG{o}{\PYGZam{}} \PYG{n}{y}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{long}\PYG{o}{\PYGZam{}} \PYG{n}{xwrap}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{long}\PYG{o}{\PYGZam{}} \PYG{n}{ywrap}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{double}\PYG{o}{\PYGZam{}} \PYG{n}{dCurrentGen}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k+kt}{double} \PYG{n}{currentTime} \PYG{o}{=} \PYG{n}{dCurrentGen} \PYG{o}{\PYGZhy{}} \PYG{n}{dCurrent}\PYG{p}{;}
    \PYG{k+kt}{double} \PYG{n}{xval}\PYG{p}{,} \PYG{n}{yval}\PYG{p}{;}
    \PYG{n}{xval} \PYG{o}{=} \PYG{n}{x} \PYG{o}{+} \PYG{p}{(}\PYG{n}{xdim} \PYG{o}{*} \PYG{n}{xwrap}\PYG{p}{)}\PYG{p}{;}  \PYG{c+c1}{//}
    \PYG{n}{yval} \PYG{o}{=} \PYG{n}{y} \PYG{o}{+} \PYG{p}{(}\PYG{n}{ydim} \PYG{o}{*} \PYG{n}{ywrap}\PYG{p}{)}\PYG{p}{;}
    \PYG{c+c1}{//      // return 0 if the requested coordinate is completely outside the map}
    \PYG{k}{if}\PYG{p}{(}\PYG{n}{xval} \PYG{o}{\PYGZlt{}} \PYG{n}{coarsexmin} \PYG{o}{\textbar{}}\PYG{o}{\textbar{}} \PYG{n}{xval} \PYG{o}{\PYGZgt{}}\PYG{o}{=} \PYG{n}{coarsexmax} \PYG{o}{\textbar{}}\PYG{o}{\textbar{}} \PYG{n}{yval} \PYG{o}{\PYGZlt{}} \PYG{n}{coarseymin} \PYG{o}{\textbar{}}\PYG{o}{\textbar{}} \PYG{n}{yval} \PYG{o}{\PYGZgt{}}\PYG{o}{=} \PYG{n}{coarseymax}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
\PYG{c+c1}{//                  cout \PYGZlt{}\PYGZlt{} \PYGZdq{}OUTSIDE: \PYGZdq{} \PYGZlt{}\PYGZlt{} endl;}
        \PYG{k}{return} \PYG{l+m+mi}{0}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{if}\PYG{p}{(}\PYG{n}{xval} \PYG{o}{\PYGZlt{}} \PYG{n}{finexmin} \PYG{o}{\textbar{}}\PYG{o}{\textbar{}} \PYG{n}{xval} \PYG{o}{\PYGZgt{}}\PYG{o}{=} \PYG{n}{finexmax} \PYG{o}{\textbar{}}\PYG{o}{\textbar{}} \PYG{n}{yval} \PYG{o}{\PYGZlt{}} \PYG{n}{fineymin} \PYG{o}{\textbar{}}\PYG{o}{\textbar{}}
       \PYG{n}{yval} \PYG{o}{\PYGZgt{}}\PYG{o}{=} \PYG{n}{fineymax}\PYG{p}{)}  \PYG{c+c1}{// check if the coordinate comes from the coarse resolution map.}
    \PYG{p}{\PYGZob{}}
\PYG{c+c1}{//                  cout \PYGZlt{}\PYGZlt{}\PYGZdq{}COARSE\PYGZdq{} \PYGZlt{}\PYGZlt{} endl;}
        \PYG{c+c1}{//          double tmp;}
        \PYG{c+c1}{// take in to account the fine map offsetting}
        \PYG{n}{xval} \PYG{o}{+}\PYG{o}{=} \PYG{n}{finexoffset}\PYG{p}{;}
        \PYG{n}{yval} \PYG{o}{+}\PYG{o}{=} \PYG{n}{fineyoffset}\PYG{p}{;}
        \PYG{c+c1}{// take in to account the coarse map offsetting and the increased scale of the larger map.}
        \PYG{n}{xval} \PYG{o}{=} \PYG{n}{floor}\PYG{p}{(}\PYG{k+kt}{double}\PYG{p}{(}\PYG{p}{(}\PYG{n}{xval} \PYG{o}{+} \PYG{n}{coarsexoffset}\PYG{p}{)} \PYG{o}{/} \PYG{n}{scale}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{yval} \PYG{o}{=} \PYG{n}{floor}\PYG{p}{(}\PYG{k+kt}{double}\PYG{p}{(}\PYG{p}{(}\PYG{n}{yval} \PYG{o}{+} \PYG{n}{coarseyoffset}\PYG{p}{)} \PYG{o}{/} \PYG{n}{scale}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
        \PYG{k+kt}{double} \PYG{n}{retval} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{bPristine} \PYG{o}{\textbar{}}\PYG{o}{\textbar{}} \PYG{n}{pristine\PYGZus{}coarse\PYGZus{}map}\PYG{p}{[}\PYG{n}{yval}\PYG{p}{]}\PYG{p}{[}\PYG{n}{xval}\PYG{p}{]} \PYG{o}{=}\PYG{o}{=} \PYG{n}{coarse\PYGZus{}map}\PYG{p}{[}\PYG{n}{yval}\PYG{p}{]}\PYG{p}{[}\PYG{n}{xval}\PYG{p}{]}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{retval} \PYG{o}{=} \PYG{n}{pristine\PYGZus{}coarse\PYGZus{}map}\PYG{p}{[}\PYG{n}{yval}\PYG{p}{]}\PYG{p}{[}\PYG{n}{xval}\PYG{p}{]}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{else}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{retval} \PYG{o}{=} \PYG{n}{coarse\PYGZus{}map}\PYG{p}{[}\PYG{n}{yval}\PYG{p}{]}\PYG{p}{[}\PYG{n}{xval}\PYG{p}{]} \PYG{o}{+}
                     \PYG{p}{(}\PYG{n}{dForestTransform} \PYG{o}{*}
                      \PYG{p}{(}\PYG{p}{(}\PYG{n}{pristine\PYGZus{}coarse\PYGZus{}map}\PYG{p}{[}\PYG{n}{yval}\PYG{p}{]}\PYG{p}{[}\PYG{n}{xval}\PYG{p}{]} \PYG{o}{\PYGZhy{}} \PYG{n}{coarse\PYGZus{}map}\PYG{p}{[}\PYG{n}{yval}\PYG{p}{]}\PYG{p}{[}\PYG{n}{xval}\PYG{p}{]}\PYG{p}{)} \PYG{o}{/} \PYG{n}{dPristine}\PYG{p}{)} \PYG{o}{*} \PYG{n}{currentTime}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
\PYG{c+c1}{//          cout \PYGZlt{}\PYGZlt{} retval \PYGZlt{}\PYGZlt{} endl;}
\PYG{c+c1}{//          cout \PYGZlt{}\PYGZlt{} retval \PYGZlt{}\PYGZlt{} endl;}
\PYG{c+c1}{// Note that debug mode will throw an exception if the returned value is less than the pristine state}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifdef pristine\PYGZus{}mode}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{retval} \PYG{o}{\PYGZgt{}} \PYG{n}{pristine\PYGZus{}coarse\PYGZus{}map}\PYG{p}{[}\PYG{n}{yval}\PYG{p}{]}\PYG{p}{[}\PYG{n}{xval}\PYG{p}{]}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{string} \PYG{n}{ec} \PYG{o}{=}
                \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Returned value greater than pristine value. Check file input. (or disable this error before }\PYG{l+s}{\PYGZdq{}}
                \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{compilation.}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
            \PYG{n}{ec} \PYG{o}{+}\PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{pristine value: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{+} \PYG{n}{to\PYGZus{}string}\PYG{p}{(}\PYG{p}{(}\PYG{k+kt}{long} \PYG{k+kt}{long}\PYG{p}{)}\PYG{n}{pristine\PYGZus{}coarse\PYGZus{}map}\PYG{p}{[}\PYG{n}{yval}\PYG{p}{]}\PYG{p}{[}\PYG{n}{xval}\PYG{p}{]}\PYG{p}{)} \PYG{o}{+}
                  \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ returned value: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{+} \PYG{n}{to\PYGZus{}string}\PYG{p}{(}\PYG{p}{(}\PYG{k+kt}{long} \PYG{k+kt}{long}\PYG{p}{)}\PYG{n}{retval}\PYG{p}{)}\PYG{p}{;}
            \PYG{k}{throw} \PYG{n+nf}{Map\PYGZus{}Fatal\PYGZus{}Exception}\PYG{p}{(}\PYG{n}{ec}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif}
        \PYG{k}{return} \PYG{n}{floor}\PYG{p}{(}\PYG{n}{retval}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{c+c1}{//      cout \PYGZlt{}\PYGZlt{} \PYGZdq{}fine\PYGZus{}map val: \PYGZdq{} \PYGZlt{}\PYGZlt{} fine\PYGZus{}map[yval][xval] \PYGZlt{}\PYGZlt{} endl;}
    \PYG{c+c1}{// take in to account the fine map offsetting}
    \PYG{c+c1}{// this is done twice to avoid having all the comparisons involve additions.}
    \PYG{n}{xval} \PYG{o}{+}\PYG{o}{=} \PYG{n}{finexoffset}\PYG{p}{;}
    \PYG{n}{yval} \PYG{o}{+}\PYG{o}{=} \PYG{n}{fineyoffset}\PYG{p}{;}
    \PYG{k+kt}{double} \PYG{n}{retval} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
    \PYG{k}{if}\PYG{p}{(}\PYG{n}{bPristine} \PYG{o}{\textbar{}}\PYG{o}{\textbar{}} \PYG{n}{pristine\PYGZus{}fine\PYGZus{}map}\PYG{p}{[}\PYG{n}{yval}\PYG{p}{]}\PYG{p}{[}\PYG{n}{xval}\PYG{p}{]} \PYG{o}{=}\PYG{o}{=} \PYG{n}{fine\PYGZus{}map}\PYG{p}{[}\PYG{n}{yval}\PYG{p}{]}\PYG{p}{[}\PYG{n}{xval}\PYG{p}{]}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{retval} \PYG{o}{=} \PYG{n}{pristine\PYGZus{}fine\PYGZus{}map}\PYG{p}{[}\PYG{n}{yval}\PYG{p}{]}\PYG{p}{[}\PYG{n}{xval}\PYG{p}{]}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{else}
    \PYG{p}{\PYGZob{}}
\PYG{c+c1}{//      cout \PYGZlt{}\PYGZlt{} pristine\PYGZus{}fine\PYGZus{}map[yval][xval] \PYGZlt{}\PYGZlt{} endl;}
\PYG{c+c1}{//      cout \PYGZlt{}\PYGZlt{} fine\PYGZus{}map[yval][xval] \PYGZlt{}\PYGZlt{} endl;}
        \PYG{n}{retval} \PYG{o}{=} \PYG{n}{fine\PYGZus{}map}\PYG{p}{[}\PYG{n}{yval}\PYG{p}{]}\PYG{p}{[}\PYG{n}{xval}\PYG{p}{]} \PYG{o}{+}
                 \PYG{p}{(}\PYG{n}{dForestTransform} \PYG{o}{*} \PYG{p}{(}\PYG{p}{(}\PYG{n}{pristine\PYGZus{}fine\PYGZus{}map}\PYG{p}{[}\PYG{n}{yval}\PYG{p}{]}\PYG{p}{[}\PYG{n}{xval}\PYG{p}{]} \PYG{o}{\PYGZhy{}} \PYG{n}{fine\PYGZus{}map}\PYG{p}{[}\PYG{n}{yval}\PYG{p}{]}\PYG{p}{[}\PYG{n}{xval}\PYG{p}{]}\PYG{p}{)} \PYG{o}{/} \PYG{p}{(}\PYG{n}{dPristine}\PYG{p}{)}\PYG{p}{)} \PYG{o}{*}
                  \PYG{n}{currentTime}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
\PYG{c+c1}{// cout \PYGZlt{}\PYGZlt{}fine\PYGZus{}map[yval][xval] \PYGZlt{}\PYGZlt{} \PYGZdq{}\PYGZhy{}\PYGZdq{}\PYGZlt{}\PYGZlt{} retval \PYGZlt{}\PYGZlt{} endl;}
\PYG{c+c1}{// Note that debug mode will throw an exception if the returned value is less than the pristine state}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifdef pristine\PYGZus{}mode}
    \PYG{k}{if}\PYG{p}{(}\PYG{n}{retval} \PYG{o}{\PYGZgt{}} \PYG{n}{pristine\PYGZus{}fine\PYGZus{}map}\PYG{p}{[}\PYG{n}{yval}\PYG{p}{]}\PYG{p}{[}\PYG{n}{xval}\PYG{p}{]}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{throw} \PYG{n}{Map\PYGZus{}Fatal\PYGZus{}Exception}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Returned value greater than pristine value. Check file input. (or disable this }\PYG{l+s}{\PYGZdq{}}
                                  \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{error before compilation.}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif}
    \PYG{k}{return} \PYG{n}{floor}\PYG{p}{(}\PYG{n}{retval}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif}
\PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{Map}\PYG{o}{:}\PYG{o}{:}\PYG{n}{getInitialCount}\PYG{p}{(}\PYG{k+kt}{double} \PYG{n}{dSample}\PYG{p}{,} \PYG{n}{Datamask}\PYG{o}{\PYGZam{}} \PYG{n}{samplemask}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{toret}\PYG{p}{;}
    \PYG{n}{toret} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{c+c1}{//  cout \PYGZlt{}\PYGZlt{} xdim \PYGZlt{}\PYGZlt{} \PYGZdq{}, \PYGZdq{} \PYGZlt{}\PYGZlt{} ydim \PYGZlt{}\PYGZlt{} endl;}
    \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{long} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{xdim}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{long} \PYG{n}{j} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{j} \PYG{o}{\PYGZlt{}} \PYG{n}{ydim}\PYG{p}{;} \PYG{n}{j}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{add} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
            \PYG{k}{if}\PYG{p}{(}\PYG{n}{samplemask}\PYG{p}{.}\PYG{n}{getVal}\PYG{p}{(}\PYG{n}{i}\PYG{p}{,} \PYG{n}{j}\PYG{p}{)}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}

                \PYG{n}{add} \PYG{o}{=} \PYG{n}{floor}\PYG{p}{(}\PYG{n}{dSample} \PYG{o}{*} \PYG{n}{getVal}\PYG{p}{(}\PYG{n}{i}\PYG{p}{,} \PYG{n}{j}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{c+c1}{//              cout \PYGZlt{}\PYGZlt{} add \PYGZlt{}\PYGZlt{} endl;}
\PYG{c+c1}{//              cout \PYGZlt{}\PYGZlt{} getVal(i, j, 0, 0, 0) \PYGZlt{}\PYGZlt{} endl;}
            \PYG{p}{\PYGZcb{}}
            \PYG{n}{toret} \PYG{o}{+}\PYG{o}{=} \PYG{n}{add}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{return} \PYG{n}{toret}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{bool} \PYG{n}{Map}\PYG{o}{:}\PYG{o}{:}\PYG{n}{checkMap}\PYG{p}{(}\PYG{k}{const} \PYG{k+kt}{double}\PYG{o}{\PYGZam{}} \PYG{n}{x}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{double}\PYG{o}{\PYGZam{}} \PYG{n}{y}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{long}\PYG{o}{\PYGZam{}} \PYG{n}{xwrap}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{long}\PYG{o}{\PYGZam{}} \PYG{n}{ywrap}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{double} \PYG{n}{generation}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{c+c1}{//       cout \PYGZlt{}\PYGZlt{} \PYGZdq{}CHECK: \PYGZdq{} \PYGZlt{}\PYGZlt{} getVal(x,y,xwrap,ywrap) \PYGZlt{}\PYGZlt{} endl;}
    \PYG{k}{if}\PYG{p}{(}\PYG{n}{getVal}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,} \PYG{n}{y}\PYG{p}{,} \PYG{n}{xwrap}\PYG{p}{,} \PYG{n}{ywrap}\PYG{p}{,} \PYG{n}{generation}\PYG{p}{)} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{return} \PYG{n+nb}{false}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{else}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{return} \PYG{n+nb}{true}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{bool} \PYG{n}{Map}\PYG{o}{:}\PYG{o}{:}\PYG{n}{checkFine}\PYG{p}{(}\PYG{k}{const} \PYG{k+kt}{double}\PYG{o}{\PYGZam{}} \PYG{n}{x}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{double}\PYG{o}{\PYGZam{}} \PYG{n}{y}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{long}\PYG{o}{\PYGZam{}} \PYG{n}{xwrap}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{long}\PYG{o}{\PYGZam{}} \PYG{n}{ywrap}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k+kt}{double} \PYG{n}{tmpx}\PYG{p}{,} \PYG{n}{tmpy}\PYG{p}{;}
    \PYG{n}{tmpx} \PYG{o}{=} \PYG{n}{x} \PYG{o}{+} \PYG{n}{xwrap} \PYG{o}{*} \PYG{n}{xdim}\PYG{p}{;}
    \PYG{n}{tmpy} \PYG{o}{=} \PYG{n}{y} \PYG{o}{+} \PYG{n}{ywrap} \PYG{o}{*} \PYG{n}{ydim}\PYG{p}{;}
    \PYG{k}{if}\PYG{p}{(}\PYG{n}{tmpx} \PYG{o}{\PYGZlt{}} \PYG{n}{finexmin} \PYG{o}{\textbar{}}\PYG{o}{\textbar{}} \PYG{n}{tmpx} \PYG{o}{\PYGZgt{}}\PYG{o}{=} \PYG{n}{finexmax} \PYG{o}{\textbar{}}\PYG{o}{\textbar{}} \PYG{n}{tmpy} \PYG{o}{\PYGZlt{}} \PYG{n}{fineymin} \PYG{o}{\textbar{}}\PYG{o}{\textbar{}} \PYG{n}{tmpy} \PYG{o}{\PYGZgt{}}\PYG{o}{=} \PYG{n}{fineymax}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{return} \PYG{n+nb}{false}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{else}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{return} \PYG{n+nb}{true}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{void} \PYG{n}{Map}\PYG{o}{:}\PYG{o}{:}\PYG{n}{convertCoordinates}\PYG{p}{(}\PYG{k+kt}{double}\PYG{o}{\PYGZam{}} \PYG{n}{x}\PYG{p}{,} \PYG{k+kt}{double}\PYG{o}{\PYGZam{}} \PYG{n}{y}\PYG{p}{,} \PYG{k+kt}{long}\PYG{o}{\PYGZam{}} \PYG{n}{xwrap}\PYG{p}{,} \PYG{k+kt}{long}\PYG{o}{\PYGZam{}} \PYG{n}{ywrap}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{c+c1}{//      cout \PYGZlt{}\PYGZlt{} \PYGZdq{}CONVERT START: \PYGZdq{} \PYGZlt{}\PYGZlt{} x \PYGZlt{}\PYGZlt{} \PYGZdq{},\PYGZdq{} \PYGZlt{}\PYGZlt{} y \PYGZlt{}\PYGZlt{} \PYGZdq{},\PYGZdq{} \PYGZlt{}\PYGZlt{} xwrap \PYGZlt{}\PYGZlt{} \PYGZdq{},\PYGZdq{} \PYGZlt{}\PYGZlt{} ywrap \PYGZlt{}\PYGZlt{} endl;}
    \PYG{c+c1}{// quick check}
    \PYG{c+c1}{//      bool bCheck = false;}
    \PYG{c+c1}{//      if(x \PYGZlt{} \PYGZhy{}1 \textbar{}\textbar{} y \PYGZlt{} \PYGZhy{}1)}
    \PYG{c+c1}{//      \PYGZob{}}
    \PYG{c+c1}{//          bCheck = true;}
    \PYG{c+c1}{//          cout \PYGZlt{}\PYGZlt{} \PYGZdq{}this is good\PYGZdq{} \PYGZlt{}\PYGZlt{} endl;}
    \PYG{c+c1}{//      \PYGZcb{}}
    \PYG{n}{xwrap} \PYG{o}{+}\PYG{o}{=} \PYG{n}{floor}\PYG{p}{(}\PYG{n}{x} \PYG{o}{/} \PYG{n}{xdim}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{ywrap} \PYG{o}{+}\PYG{o}{=} \PYG{n}{floor}\PYG{p}{(}\PYG{n}{y} \PYG{o}{/} \PYG{n}{ydim}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{x} \PYG{o}{=} \PYG{n}{x} \PYG{o}{\PYGZhy{}} \PYG{n}{xwrap} \PYG{o}{*} \PYG{n}{xdim}\PYG{p}{;}
    \PYG{n}{y} \PYG{o}{=} \PYG{n}{y} \PYG{o}{\PYGZhy{}} \PYG{n}{ywrap} \PYG{o}{*} \PYG{n}{ydim}\PYG{p}{;}
    \PYG{c+c1}{//      if(bCheck)}
    \PYG{c+c1}{//      \PYGZob{}}
    \PYG{c+c1}{//          cout \PYGZlt{}\PYGZlt{} \PYGZdq{}x,y \PYGZdq{} \PYGZlt{}\PYGZlt{} x \PYGZlt{}\PYGZlt{} \PYGZdq{},\PYGZdq{} \PYGZlt{}\PYGZlt{} y \PYGZlt{}\PYGZlt{}endl;}
    \PYG{c+c1}{//          cout \PYGZlt{}\PYGZlt{} \PYGZdq{}x,y wrap \PYGZdq{} \PYGZlt{}\PYGZlt{} xwrap \PYGZlt{}\PYGZlt{} \PYGZdq{},\PYGZdq{} \PYGZlt{}\PYGZlt{}ywrap \PYGZlt{}\PYGZlt{} endl;}
    \PYG{c+c1}{//}
    \PYG{c+c1}{//      \PYGZcb{}}
    \PYG{c+c1}{//      cout \PYGZlt{}\PYGZlt{} \PYGZdq{}CONVERT END: \PYGZdq{} \PYGZlt{}\PYGZlt{} x \PYGZlt{}\PYGZlt{} \PYGZdq{},\PYGZdq{} \PYGZlt{}\PYGZlt{} y \PYGZlt{}\PYGZlt{} \PYGZdq{},\PYGZdq{} \PYGZlt{}\PYGZlt{} xwrap \PYGZlt{}\PYGZlt{} \PYGZdq{},\PYGZdq{} \PYGZlt{}\PYGZlt{} ywrap \PYGZlt{}\PYGZlt{} endl;}
    \PYG{k}{return}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{void} \PYG{n}{Map}\PYG{o}{:}\PYG{o}{:}\PYG{n}{runDispersal}\PYG{p}{(}\PYG{k}{const} \PYG{k+kt}{double}\PYG{o}{\PYGZam{}} \PYG{n}{dist}\PYG{p}{,}
                       \PYG{k}{const} \PYG{k+kt}{double}\PYG{o}{\PYGZam{}} \PYG{n}{angle}\PYG{p}{,}
                       \PYG{k+kt}{long}\PYG{o}{\PYGZam{}} \PYG{n}{startx}\PYG{p}{,}
                       \PYG{k+kt}{long}\PYG{o}{\PYGZam{}} \PYG{n}{starty}\PYG{p}{,}
                       \PYG{k+kt}{long}\PYG{o}{\PYGZam{}} \PYG{n}{startxwrap}\PYG{p}{,}
                       \PYG{k+kt}{long}\PYG{o}{\PYGZam{}} \PYG{n}{startywrap}\PYG{p}{,}
                       \PYG{k+kt}{bool}\PYG{o}{\PYGZam{}} \PYG{n}{disp\PYGZus{}comp}\PYG{p}{,}
                       \PYG{k}{const} \PYG{k+kt}{double}\PYG{o}{\PYGZam{}} \PYG{n}{generation}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
\PYG{c+c1}{//      if(startxwrap \PYGZlt{} \PYGZhy{}1 \textbar{}\textbar{} startywrap \PYGZlt{} \PYGZhy{}1)}
\PYG{c+c1}{//      \PYGZob{}}
\PYG{c+c1}{//          cout \PYGZlt{}\PYGZlt{} \PYGZdq{}good1!\PYGZdq{} \PYGZlt{}\PYGZlt{} endl;}
\PYG{c+c1}{//          cout \PYGZlt{}\PYGZlt{} startxwrap \PYGZlt{}\PYGZlt{} endl;}
\PYG{c+c1}{//          cout \PYGZlt{}\PYGZlt{} startywrap \PYGZlt{}\PYGZlt{} endl;}
\PYG{c+c1}{//      \PYGZcb{}}
\PYG{c+c1}{// Checks that the start point is not out of matrix \PYGZhy{} this might have to be disabled to ensure that when updating the}
\PYG{c+c1}{// map, it doesn\PYGZsq{}t cause problems.}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifdef pristine\PYGZus{}mode}
    \PYG{k}{if}\PYG{p}{(}\PYG{o}{!}\PYG{n}{checkMap}\PYG{p}{(}\PYG{n}{startx}\PYG{p}{,} \PYG{n}{starty}\PYG{p}{,} \PYG{n}{startxwrap}\PYG{p}{,} \PYG{n}{startywrap}\PYG{p}{,} \PYG{n}{generation}\PYG{p}{)}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{disp\PYGZus{}comp} \PYG{o}{=} \PYG{n+nb}{true}\PYG{p}{;}
        \PYG{k}{return}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif}

    \PYG{c+c1}{// Different calculations for each quadrant to ensure that the dispersal reads the probabilities correctly.}
    \PYG{k+kt}{double} \PYG{n}{newx}\PYG{p}{,} \PYG{n}{newy}\PYG{p}{;}

    \PYG{n}{newx} \PYG{o}{=} \PYG{n}{startx} \PYG{o}{+} \PYG{p}{(}\PYG{n}{xdim} \PYG{o}{*} \PYG{n}{startxwrap}\PYG{p}{)} \PYG{o}{+} \PYG{l+m+mf}{0.5}\PYG{p}{;}
    \PYG{n}{newy} \PYG{o}{=} \PYG{n}{starty} \PYG{o}{+} \PYG{p}{(}\PYG{n}{ydim} \PYG{o}{*} \PYG{n}{startywrap}\PYG{p}{)} \PYG{o}{+} \PYG{l+m+mf}{0.5}\PYG{p}{;}
    \PYG{k}{if}\PYG{p}{(}\PYG{n}{lambda} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{)}  \PYG{c+c1}{// then nothing complicated is required and we can jump straight to the final point.}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{newx} \PYG{o}{+}\PYG{o}{=} \PYG{k+kt}{double}\PYG{p}{(}\PYG{n}{dist} \PYG{o}{*} \PYG{n}{cos}\PYG{p}{(}\PYG{n}{angle}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{newy} \PYG{o}{+}\PYG{o}{=} \PYG{k+kt}{double}\PYG{p}{(}\PYG{n}{dist} \PYG{o}{*} \PYG{n}{sin}\PYG{p}{(}\PYG{n}{angle}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
        \PYG{c+c1}{// cout \PYGZlt{}\PYGZlt{} \PYGZdq{}new x,y: \PYGZdq{} \PYGZlt{}\PYGZlt{} newx \PYGZlt{}\PYGZlt{} \PYGZdq{},\PYGZdq{} \PYGZlt{}\PYGZlt{} newy \PYGZlt{}\PYGZlt{} endl;}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{else}  \PYG{c+c1}{// we need to see which deforested patches we pass over}
    \PYG{p}{\PYGZob{}}
        \PYG{k+kt}{long} \PYG{n}{boost}\PYG{p}{;}
        \PYG{n}{boost} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;}
        \PYG{k+kt}{double} \PYG{n}{cur\PYGZus{}dist}\PYG{p}{,} \PYG{n}{tot\PYGZus{}dist}\PYG{p}{,} \PYG{n}{l}\PYG{p}{;}
        \PYG{n}{cur\PYGZus{}dist} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
        \PYG{n}{tot\PYGZus{}dist} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
        \PYG{c+c1}{// Four different calculations for the different quadrants.}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{angle} \PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{7} \PYG{o}{*} \PYG{n}{M\PYGZus{}PI\PYGZus{}4} \PYG{o}{\textbar{}}\PYG{o}{\textbar{}} \PYG{n}{angle} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{n}{M\PYGZus{}PI\PYGZus{}4}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{c+c1}{// Continue while the dist travelled is less than the dist energy}
            \PYG{k}{while}\PYG{p}{(}\PYG{n}{cur\PYGZus{}dist} \PYG{o}{\PYGZlt{}} \PYG{n}{dist}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{c+c1}{// Check if the starting position of the loop is in the fine map or not.}
                \PYG{k}{if}\PYG{p}{(}\PYG{n}{checkFine}\PYG{p}{(}\PYG{n}{newx}\PYG{p}{,} \PYG{n}{newy}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{)}
                \PYG{p}{\PYGZob{}}
                    \PYG{c+c1}{// Keep the standard movement rate}
                    \PYG{n}{boost} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;}
                \PYG{p}{\PYGZcb{}}
                \PYG{k}{else}
                \PYG{p}{\PYGZob{}}
                    \PYG{c+c1}{// Accellerate the travel speed if the point is outside the fine grid.}
                    \PYG{c+c1}{// Note this means that lineages travelling from outside the fine grid to within the}
                    \PYG{c+c1}{// fine grid may}
                    \PYG{c+c1}{// see 1 grid\PYGZsq{}s worth of approximation, rather than exact values.}
                    \PYG{c+c1}{// This is an acceptable approximation!}
                    \PYG{n}{boost} \PYG{o}{=} \PYG{n}{deme}\PYG{p}{;}
                \PYG{p}{\PYGZcb{}}

                \PYG{c+c1}{// Add the value to the new x and y values.}
                \PYG{n}{newx} \PYG{o}{=} \PYG{n}{newx} \PYG{o}{+} \PYG{n}{boost}\PYG{p}{;}
                \PYG{n}{newy} \PYG{o}{=} \PYG{n}{newy} \PYG{o}{+} \PYG{n}{boost} \PYG{o}{*} \PYG{n}{tan}\PYG{p}{(}\PYG{n}{angle}\PYG{p}{)}\PYG{p}{;}
                \PYG{c+c1}{// Check if the new point is within forest.}
                \PYG{k}{if}\PYG{p}{(}\PYG{n}{checkMap}\PYG{p}{(}\PYG{n}{newx}\PYG{p}{,} \PYG{n}{newy}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{generation}\PYG{p}{)}\PYG{p}{)}
                \PYG{p}{\PYGZob{}}
                    \PYG{n}{l} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;}
                \PYG{p}{\PYGZcb{}}
                \PYG{k}{else}
                \PYG{p}{\PYGZob{}}
                    \PYG{n}{l} \PYG{o}{=} \PYG{n}{lambda}\PYG{p}{;}
                \PYG{p}{\PYGZcb{}}
                \PYG{c+c1}{// Move forward different dists based on the difficulty of moving through forest.}
                \PYG{n}{cur\PYGZus{}dist} \PYG{o}{=} \PYG{n}{cur\PYGZus{}dist} \PYG{o}{+} \PYG{n}{l} \PYG{o}{*} \PYG{n}{boost} \PYG{o}{*} \PYG{p}{(}\PYG{l+m+mi}{1} \PYG{o}{/} \PYG{n}{cos}\PYG{p}{(}\PYG{n}{angle}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
                \PYG{n}{tot\PYGZus{}dist} \PYG{o}{=} \PYG{n}{tot\PYGZus{}dist} \PYG{o}{+} \PYG{n}{boost} \PYG{o}{*} \PYG{p}{(}\PYG{l+m+mi}{1} \PYG{o}{/} \PYG{n}{cos}\PYG{p}{(}\PYG{n}{angle}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{else} \PYG{k}{if}\PYG{p}{(}\PYG{n}{angle} \PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{3} \PYG{o}{*} \PYG{n}{M\PYGZus{}PI\PYGZus{}4} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{n}{angle} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{l+m+mi}{5} \PYG{o}{*} \PYG{n}{M\PYGZus{}PI\PYGZus{}4}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{k}{while}\PYG{p}{(}\PYG{n}{cur\PYGZus{}dist} \PYG{o}{\PYGZlt{}} \PYG{n}{dist}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{k}{if}\PYG{p}{(}\PYG{n}{checkFine}\PYG{p}{(}\PYG{n}{newx}\PYG{p}{,} \PYG{n}{newy}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{)}
                \PYG{p}{\PYGZob{}}
                    \PYG{n}{boost} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;}
                \PYG{p}{\PYGZcb{}}
                \PYG{k}{else}
                \PYG{p}{\PYGZob{}}
                    \PYG{n}{boost} \PYG{o}{=} \PYG{n}{deme}\PYG{p}{;}
                \PYG{p}{\PYGZcb{}}
                \PYG{c+c1}{// Add the change to the new x and y values.}
                \PYG{n}{newx} \PYG{o}{=} \PYG{n}{newx} \PYG{o}{\PYGZhy{}} \PYG{n}{boost}\PYG{p}{;}
                \PYG{n}{newy} \PYG{o}{=} \PYG{n}{newy} \PYG{o}{+} \PYG{n}{boost} \PYG{o}{*} \PYG{n}{tan}\PYG{p}{(}\PYG{n}{M\PYGZus{}PI} \PYG{o}{\PYGZhy{}} \PYG{n}{angle}\PYG{p}{)}\PYG{p}{;}
                \PYG{k}{if}\PYG{p}{(}\PYG{n}{checkMap}\PYG{p}{(}\PYG{n}{newx}\PYG{p}{,} \PYG{n}{newy}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{generation}\PYG{p}{)}\PYG{p}{)}
                \PYG{p}{\PYGZob{}}
                    \PYG{n}{l} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;}
                \PYG{p}{\PYGZcb{}}
                \PYG{k}{else}
                \PYG{p}{\PYGZob{}}
                    \PYG{n}{l} \PYG{o}{=} \PYG{n}{lambda}\PYG{p}{;}
                \PYG{p}{\PYGZcb{}}
                \PYG{n}{cur\PYGZus{}dist} \PYG{o}{=} \PYG{n}{cur\PYGZus{}dist} \PYG{o}{+} \PYG{n}{boost} \PYG{o}{*} \PYG{n}{l} \PYG{o}{*} \PYG{p}{(}\PYG{l+m+mi}{1} \PYG{o}{/} \PYG{n}{cos}\PYG{p}{(}\PYG{n}{M\PYGZus{}PI} \PYG{o}{\PYGZhy{}} \PYG{n}{angle}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
                \PYG{n}{tot\PYGZus{}dist} \PYG{o}{=} \PYG{n}{tot\PYGZus{}dist} \PYG{o}{+} \PYG{n}{boost} \PYG{o}{*} \PYG{p}{(}\PYG{l+m+mi}{1} \PYG{o}{/} \PYG{n}{cos}\PYG{p}{(}\PYG{n}{M\PYGZus{}PI} \PYG{o}{\PYGZhy{}} \PYG{n}{angle}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{else} \PYG{k}{if}\PYG{p}{(}\PYG{n}{angle} \PYG{o}{\PYGZgt{}} \PYG{n}{M\PYGZus{}PI\PYGZus{}4} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{n}{angle} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{l+m+mi}{3} \PYG{o}{*} \PYG{n}{M\PYGZus{}PI\PYGZus{}4}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{k}{while}\PYG{p}{(}\PYG{n}{cur\PYGZus{}dist} \PYG{o}{\PYGZlt{}} \PYG{n}{dist}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{k}{if}\PYG{p}{(}\PYG{n}{checkFine}\PYG{p}{(}\PYG{n}{newx}\PYG{p}{,} \PYG{n}{newy}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{)}
                \PYG{p}{\PYGZob{}}
                    \PYG{n}{boost} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;}
                \PYG{p}{\PYGZcb{}}
                \PYG{k}{else}
                \PYG{p}{\PYGZob{}}
                    \PYG{n}{boost} \PYG{o}{=} \PYG{n}{deme}\PYG{p}{;}
                \PYG{p}{\PYGZcb{}}
                \PYG{c+c1}{// Add the change to the new x and y values.}
                \PYG{n}{newx} \PYG{o}{=} \PYG{n}{newx} \PYG{o}{+} \PYG{n}{boost} \PYG{o}{*} \PYG{n}{tan}\PYG{p}{(}\PYG{n}{angle} \PYG{o}{\PYGZhy{}} \PYG{n}{M\PYGZus{}PI\PYGZus{}2}\PYG{p}{)}\PYG{p}{;}
                \PYG{n}{newy} \PYG{o}{=} \PYG{n}{newy} \PYG{o}{+} \PYG{n}{boost}\PYG{p}{;}
                \PYG{k}{if}\PYG{p}{(}\PYG{n}{checkMap}\PYG{p}{(}\PYG{n}{newx}\PYG{p}{,} \PYG{n}{newy}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{generation}\PYG{p}{)}\PYG{p}{)}
                \PYG{p}{\PYGZob{}}
                    \PYG{n}{l} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;}
                \PYG{p}{\PYGZcb{}}
                \PYG{k}{else}
                \PYG{p}{\PYGZob{}}
                    \PYG{n}{l} \PYG{o}{=} \PYG{n}{lambda}\PYG{p}{;}
                \PYG{p}{\PYGZcb{}}
                \PYG{n}{cur\PYGZus{}dist} \PYG{o}{=} \PYG{n}{cur\PYGZus{}dist} \PYG{o}{+} \PYG{n}{l} \PYG{o}{*} \PYG{n}{boost} \PYG{o}{/} \PYG{n}{cos}\PYG{p}{(}\PYG{n}{angle} \PYG{o}{\PYGZhy{}} \PYG{n}{M\PYGZus{}PI\PYGZus{}2}\PYG{p}{)}\PYG{p}{;}
                \PYG{n}{tot\PYGZus{}dist} \PYG{o}{=} \PYG{n}{tot\PYGZus{}dist} \PYG{o}{+} \PYG{n}{boost} \PYG{o}{/} \PYG{n}{cos}\PYG{p}{(}\PYG{n}{angle} \PYG{o}{\PYGZhy{}} \PYG{n}{M\PYGZus{}PI\PYGZus{}2}\PYG{p}{)}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{else} \PYG{k}{if}\PYG{p}{(}\PYG{n}{angle} \PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{5} \PYG{o}{*} \PYG{n}{M\PYGZus{}PI\PYGZus{}4} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{n}{angle} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{l+m+mi}{7} \PYG{o}{*} \PYG{n}{M\PYGZus{}PI\PYGZus{}4}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{c+c1}{//              cout \PYGZlt{}\PYGZlt{} \PYGZdq{}...ang4...\PYGZdq{} \PYGZlt{}\PYGZlt{}  flush;}
            \PYG{k}{while}\PYG{p}{(}\PYG{n}{cur\PYGZus{}dist} \PYG{o}{\PYGZlt{}} \PYG{n}{dist}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{k}{if}\PYG{p}{(}\PYG{n}{checkFine}\PYG{p}{(}\PYG{n}{newx}\PYG{p}{,} \PYG{n}{newy}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{)}
                \PYG{p}{\PYGZob{}}
                    \PYG{n}{boost} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;}
                \PYG{p}{\PYGZcb{}}
                \PYG{k}{else}
                \PYG{p}{\PYGZob{}}
                    \PYG{n}{boost} \PYG{o}{=} \PYG{n}{deme}\PYG{p}{;}
                \PYG{p}{\PYGZcb{}}
                \PYG{n}{newx} \PYG{o}{=} \PYG{n}{newx} \PYG{o}{+} \PYG{n}{boost} \PYG{o}{*} \PYG{n}{tan}\PYG{p}{(}\PYG{l+m+mi}{3} \PYG{o}{*} \PYG{n}{M\PYGZus{}PI\PYGZus{}2} \PYG{o}{\PYGZhy{}} \PYG{n}{angle}\PYG{p}{)}\PYG{p}{;}
                \PYG{n}{newy} \PYG{o}{=} \PYG{n}{newy} \PYG{o}{\PYGZhy{}} \PYG{n}{boost}\PYG{p}{;}
                \PYG{k}{if}\PYG{p}{(}\PYG{n}{checkMap}\PYG{p}{(}\PYG{n}{newx}\PYG{p}{,} \PYG{n}{newy}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{generation}\PYG{p}{)}\PYG{p}{)}
                \PYG{p}{\PYGZob{}}
                    \PYG{n}{l} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;}
                \PYG{p}{\PYGZcb{}}
                \PYG{k}{else}
                \PYG{p}{\PYGZob{}}
                    \PYG{n}{l} \PYG{o}{=} \PYG{n}{lambda}\PYG{p}{;}
                \PYG{p}{\PYGZcb{}}
                \PYG{n}{cur\PYGZus{}dist} \PYG{o}{=} \PYG{n}{cur\PYGZus{}dist} \PYG{o}{+} \PYG{n}{l} \PYG{o}{*} \PYG{n}{boost} \PYG{o}{/} \PYG{n}{cos}\PYG{p}{(}\PYG{l+m+mi}{3} \PYG{o}{*} \PYG{n}{M\PYGZus{}PI\PYGZus{}2} \PYG{o}{\PYGZhy{}} \PYG{n}{angle}\PYG{p}{)}\PYG{p}{;}
                \PYG{n}{tot\PYGZus{}dist} \PYG{o}{=} \PYG{n}{tot\PYGZus{}dist} \PYG{o}{+} \PYG{n}{boost} \PYG{o}{/} \PYG{n}{cos}\PYG{p}{(}\PYG{l+m+mi}{3} \PYG{o}{*} \PYG{n}{M\PYGZus{}PI\PYGZus{}2} \PYG{o}{\PYGZhy{}} \PYG{n}{angle}\PYG{p}{)}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
        \PYG{p}{\PYGZcb{}}
        \PYG{c+c1}{// Move the point back to get the exact placement}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{checkMap}\PYG{p}{(}\PYG{n}{newx}\PYG{p}{,} \PYG{n}{newy}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{generation}\PYG{p}{)}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{tot\PYGZus{}dist} \PYG{o}{=} \PYG{n}{tot\PYGZus{}dist} \PYG{o}{\PYGZhy{}} \PYG{n}{min}\PYG{p}{(}\PYG{n}{cur\PYGZus{}dist} \PYG{o}{\PYGZhy{}} \PYG{n}{dist}\PYG{p}{,} \PYG{p}{(}\PYG{k+kt}{double}\PYG{p}{(}\PYG{n}{boost}\PYG{p}{)} \PYG{o}{\PYGZhy{}} \PYG{l+m+mf}{0.001}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{else}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{disp\PYGZus{}comp} \PYG{o}{=} \PYG{n+nb}{true}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{n}{newx} \PYG{o}{=} \PYG{n}{startx} \PYG{o}{+} \PYG{l+m+mf}{0.5} \PYG{o}{+} \PYG{n}{tot\PYGZus{}dist} \PYG{o}{*} \PYG{n}{cos}\PYG{p}{(}\PYG{n}{angle}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{newy} \PYG{o}{=} \PYG{n}{starty} \PYG{o}{+} \PYG{l+m+mf}{0.5} \PYG{o}{+} \PYG{n}{tot\PYGZus{}dist} \PYG{o}{*} \PYG{n}{sin}\PYG{p}{(}\PYG{n}{angle}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{if}\PYG{p}{(}\PYG{n}{checkMap}\PYG{p}{(}\PYG{n}{newx}\PYG{p}{,} \PYG{n}{newy}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{generation}\PYG{p}{)}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k+kt}{long} \PYG{n}{newxwrap}\PYG{p}{,} \PYG{n}{newywrap}\PYG{p}{;}
        \PYG{n}{newxwrap} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
        \PYG{n}{newywrap} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
        \PYG{c+c1}{//          cout \PYGZlt{}\PYGZlt{} \PYGZdq{}new x,y: \PYGZdq{} \PYGZlt{}\PYGZlt{} newx \PYGZlt{}\PYGZlt{} \PYGZdq{},\PYGZdq{} \PYGZlt{}\PYGZlt{} newy \PYGZlt{}\PYGZlt{} endl;}
        \PYG{c+c1}{//          cout \PYGZlt{}\PYGZlt{}\PYGZdq{}BEFORE CHECK: \PYGZdq{} \PYGZlt{}\PYGZlt{}endl;}
        \PYG{c+c1}{//          cout \PYGZlt{}\PYGZlt{} \PYGZdq{}start \PYGZdq{} \PYGZlt{}\PYGZlt{} newxwrap \PYGZlt{}\PYGZlt{} endl;}
        \PYG{n}{convertCoordinates}\PYG{p}{(}\PYG{n}{newx}\PYG{p}{,} \PYG{n}{newy}\PYG{p}{,} \PYG{n}{newxwrap}\PYG{p}{,} \PYG{n}{newywrap}\PYG{p}{)}\PYG{p}{;}
        \PYG{c+c1}{//          cout \PYGZlt{}\PYGZlt{} \PYGZdq{}end \PYGZdq{} \PYGZlt{}\PYGZlt{} newxwrap \PYGZlt{}\PYGZlt{} endl;}

        \PYG{c+c1}{//          if(newxwrap \PYGZlt{} \PYGZhy{}1 \textbar{}\textbar{} newywrap \PYGZlt{} \PYGZhy{}1)}
        \PYG{c+c1}{//          \PYGZob{}}
        \PYG{c+c1}{//              cout \PYGZlt{}\PYGZlt{} \PYGZdq{}good2!\PYGZdq{} \PYGZlt{}\PYGZlt{} endl;}
        \PYG{c+c1}{//              cout \PYGZlt{}\PYGZlt{} newxwrap \PYGZlt{}\PYGZlt{} endl;}
        \PYG{c+c1}{//              cout \PYGZlt{}\PYGZlt{} newywrap \PYGZlt{}\PYGZlt{} endl;}
        \PYG{c+c1}{//          \PYGZcb{}}
        \PYG{k}{if}\PYG{p}{(}\PYG{o}{!}\PYG{n}{checkMap}\PYG{p}{(}\PYG{n}{newx}\PYG{p}{,} \PYG{n}{newy}\PYG{p}{,} \PYG{n}{newxwrap}\PYG{p}{,} \PYG{n}{newywrap}\PYG{p}{,} \PYG{n}{generation}\PYG{p}{)}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{k}{throw} \PYG{n}{Map\PYGZus{}Fatal\PYGZus{}Exception}\PYG{p}{(}\PYG{n}{string}\PYG{p}{(}
                \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ERROR\PYGZus{}MOVE\PYGZus{}007: Dispersal attempted to non\PYGZhy{}forest. Check dispersal function. Forest cover: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{+}
                \PYG{n}{to\PYGZus{}string}\PYG{p}{(}\PYG{p}{(}\PYG{k+kt}{long} \PYG{k+kt}{long}\PYG{p}{)}\PYG{n}{getVal}\PYG{p}{(}\PYG{n}{newx}\PYG{p}{,} \PYG{n}{newy}\PYG{p}{,} \PYG{n}{newxwrap}\PYG{p}{,} \PYG{n}{newywrap}\PYG{p}{,} \PYG{n}{generation}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{c+c1}{//          cout \PYGZlt{}\PYGZlt{} \PYGZdq{}new x,y: \PYGZdq{} \PYGZlt{}\PYGZlt{} newx \PYGZlt{}\PYGZlt{} \PYGZdq{},\PYGZdq{} \PYGZlt{}\PYGZlt{} newy \PYGZlt{}\PYGZlt{} endl;}
        \PYG{n}{startx} \PYG{o}{=} \PYG{n}{newx}\PYG{p}{;}
        \PYG{n}{starty} \PYG{o}{=} \PYG{n}{newy}\PYG{p}{;}
        \PYG{n}{startxwrap} \PYG{o}{=} \PYG{n}{newxwrap}\PYG{p}{;}
        \PYG{n}{startywrap} \PYG{o}{=} \PYG{n}{newywrap}\PYG{p}{;}
        \PYG{n}{disp\PYGZus{}comp} \PYG{o}{=} \PYG{n+nb}{false}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{else}
    \PYG{p}{\PYGZob{}}
        \PYG{c+c1}{// cout \PYGZlt{}\PYGZlt{} \PYGZdq{}OUT!\PYGZdq{} \PYGZlt{}\PYGZlt{} endl;}
        \PYG{c+c1}{// cout \PYGZlt{}\PYGZlt{} \PYGZdq{}x,y : \PYGZdq{} \PYGZlt{}\PYGZlt{} newx \PYGZlt{}\PYGZlt{} \PYGZdq{},\PYGZdq{} \PYGZlt{}\PYGZlt{} newy \PYGZlt{}\PYGZlt{} endl;}
        \PYG{n}{disp\PYGZus{}comp} \PYG{o}{=} \PYG{n+nb}{true}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{c+c1}{//      if(startxwrap \PYGZlt{} \PYGZhy{}1 \textbar{}\textbar{} startywrap \PYGZlt{} \PYGZhy{}1)}
    \PYG{c+c1}{//      \PYGZob{}}
    \PYG{c+c1}{//          cout \PYGZlt{}\PYGZlt{} \PYGZdq{}good2!\PYGZdq{} \PYGZlt{}\PYGZlt{} endl;}
    \PYG{c+c1}{//          cout \PYGZlt{}\PYGZlt{} startxwrap \PYGZlt{}\PYGZlt{} endl;}
    \PYG{c+c1}{//          cout \PYGZlt{}\PYGZlt{} startywrap \PYGZlt{}\PYGZlt{} endl;}
    \PYG{c+c1}{//      \PYGZcb{}}
    \PYG{k}{return}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}

\PYG{k+kt}{void} \PYG{n}{Map}\PYG{o}{:}\PYG{o}{:}\PYG{n}{clearMap}\PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{n}{dCurrent} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
    \PYG{n}{checksetdim} \PYG{o}{=} \PYG{n+nb}{false}\PYG{p}{;}
    \PYG{n}{bPristine} \PYG{o}{=} \PYG{n+nb}{false}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{void} \PYG{n}{Map}\PYG{o}{:}\PYG{o}{:}\PYG{n}{printVars}\PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{fine x limits: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{finexmin} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ , }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{finexmax} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
    \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{fine y limits: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{fineymin} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ , }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{fineymax} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
    \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{fine map offset: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{finexoffset} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ , }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{fineyoffset} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
    \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{coarse x limits: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{coarsexmin} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ , }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{coarsexmax} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
    \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{coarse y limits: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{coarseymin} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ , }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{coarseymax} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
    \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{x,y dims: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{xdim} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ , }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{ydim} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}


\subparagraph{Includes}
\label{\detokenize{Exhaled/exhale_file_Map.cpp:includes}}\begin{itemize}
\item {} 
\sphinxcode{Map.h} ({\hyperref[\detokenize{Exhaled/exhale_file_Map.h:file-map-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File Map.h}}}})

\item {} 
\sphinxcode{Setup.h} ({\hyperref[\detokenize{Exhaled/exhale_file_Setup.h:file-setup-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File Setup.h}}}})

\end{itemize}


\paragraph{File Map.h}
\label{\detokenize{Exhaled/exhale_file_Map.h:file-map-h}}\label{\detokenize{Exhaled/exhale_file_Map.h::doc}}\label{\detokenize{Exhaled/exhale_file_Map.h:id1}}

\subparagraph{Definition (\sphinxstyleliteralintitle{Map.h})}
\label{\detokenize{Exhaled/exhale_file_Map.h:definition-map-h}}

\subparagraph{Program Listing for File Map.h}
\label{\detokenize{Exhaled/exhale_program_listing_file_Map.h:program-listing-for-file-map-h}}\label{\detokenize{Exhaled/exhale_program_listing_file_Map.h:program-listing-file-map-h}}\label{\detokenize{Exhaled/exhale_program_listing_file_Map.h::doc}}\begin{itemize}
\item {} 
Return to documentation for {\hyperref[\detokenize{Exhaled/exhale_file_Map.h:file-map-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File Map.h}}}}

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{//This file is part of NECSim project which is released under BSD\PYGZhy{}3 license.}
\PYG{c+c1}{//See file **LICENSE.txt** or visit https://opensource.org/licenses/BSD\PYGZhy{}3\PYGZhy{}Clause) for full license details}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifndef MAP}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define MAP}
 \PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ include \PYGZlt{}string\PYGZgt{}}
 \PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ include \PYGZlt{}stdio.h\PYGZgt{}}
 \PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}vector\PYGZgt{}}
 \PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ include \PYGZlt{}iostream\PYGZgt{}}
 \PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ include \PYGZlt{}fstream\PYGZgt{}}
 \PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ include \PYGZlt{}math.h\PYGZgt{}}
 \PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ include \PYGZlt{}stdexcept\PYGZgt{}}
 \PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ include \PYGZdq{}Config.h\PYGZdq{}}
 \PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ include \PYGZlt{}boost}\PYG{c+cp}{/}\PYG{c+cp}{filesystem.hpp\PYGZgt{}}

 \PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZdq{}Matrix.h\PYGZdq{}}
 \PYG{c+c1}{//\PYGZsh{}include \PYGZlt{}Setup.h\PYGZgt{}}
 \PYG{c+c1}{//\PYGZsh{} include \PYGZdq{}Fattaildeviate.cpp\PYGZdq{}}
 \PYG{k}{using} \PYG{k}{namespace} \PYG{n}{std}\PYG{p}{;}




\PYG{c+cm}{/************************************************************}
\PYG{c+cm}{                    MAPVARS STRUCTURE}
\PYG{c+cm}{ ************************************************************/}
\PYG{k}{struct} \PYG{n}{Mapvars}
\PYG{p}{\PYGZob{}}
    \PYG{n}{string} \PYG{n}{finemapfile}\PYG{p}{,} \PYG{n}{coarsemapfile}\PYG{p}{,}\PYG{n}{outdirectory}\PYG{p}{,}\PYG{n}{pristinefinemapfile}\PYG{p}{,}\PYG{n}{pristinecoarsemapfile}\PYG{p}{,} \PYG{n}{samplemaskfile}\PYG{p}{;}
     \PYG{c+c1}{// for file naming purposes.}
    \PYG{k+kt}{long} \PYG{n}{the\PYGZus{}task}\PYG{p}{;}
    \PYG{c+c1}{// the variables for the grid containing the initial individuals.}
    \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{vargridxsize}\PYG{p}{,} \PYG{n}{vargridysize}\PYG{p}{;}
    \PYG{c+c1}{// The fine map variables at the same resolution as the grid.}
    \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{varfinemapxsize}\PYG{p}{,} \PYG{n}{varfinemapysize}\PYG{p}{,} \PYG{n}{varfinemapxoffset}\PYG{p}{,} \PYG{n}{varfinemapyoffset}\PYG{p}{;}
    \PYG{c+c1}{// the coarse map variables at a scaled resolution of the fine map.}
    \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{varcoarsemapxsize}\PYG{p}{,} \PYG{n}{varcoarsemapysize}\PYG{p}{,} \PYG{n}{varcoarsemapxoffset}\PYG{p}{,} \PYG{n}{varcoarsemapyoffset}\PYG{p}{,}\PYG{n}{varcoarsemapscale}\PYG{p}{;}
    \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{desired\PYGZus{}specnum}\PYG{p}{;}
    \PYG{c+c1}{// the relative cost of moving through non\PYGZhy{}forest}
    \PYG{k+kt}{double} \PYG{n}{lambda}\PYG{p}{;}
    \PYG{c+c1}{// the size of each square of habitat in numbers of individuals}
    \PYG{k+kt}{long} \PYG{n}{deme}\PYG{p}{;}
    \PYG{c+c1}{// the sample proportion,}
     \PYG{k+kt}{double} \PYG{n}{deme\PYGZus{}sample}\PYG{p}{;}
    \PYG{c+c1}{// the speciation rate.}
    \PYG{k+kt}{long} \PYG{k+kt}{double}  \PYG{n}{spec}\PYG{p}{;}
    \PYG{c+c1}{// the fatness of the dispersal kernel.}
    \PYG{k+kt}{double} \PYG{n}{zfat}\PYG{p}{;}
    \PYG{c+c1}{// max time to run for}
    \PYG{k+kt}{double} \PYG{n}{maxtime}\PYG{p}{;}
    \PYG{c+c1}{// the number of generations since a pristine landscape was encountered.}
    \PYG{k+kt}{double} \PYG{n}{dPristine}\PYG{p}{;}
    \PYG{c+c1}{// the transform rate of the forest from pristine to modern forest.}
    \PYG{k+kt}{double} \PYG{n}{dForestTransform}\PYG{p}{;}
    \PYG{c+c1}{// the dispersal L value (the width of the fat\PYGZhy{}tailed kernel).}
    \PYG{k+kt}{double} \PYG{n}{dLvalue}\PYG{p}{;}
    \PYG{c+c1}{// file containing the points to record data from}
    \PYG{n}{string} \PYG{n}{autocorrel\PYGZus{}file}\PYG{p}{;}
    \PYG{c+c1}{// Stores the full list of configs imported from file}
    \PYG{n}{ConfigOption} \PYG{n}{configs}\PYG{p}{;}
    \PYG{c+c1}{// Set to true if the completely pristine state has been reached.}
    \PYG{k+kt}{bool} \PYG{n}{bPristine}\PYG{p}{;}


    \PYG{k+kt}{void} \PYG{n+nf}{import}\PYG{p}{(}\PYG{k}{const} \PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{n}{string}\PYG{o}{\PYGZgt{}} \PYG{o}{\PYGZam{}}\PYG{n}{comargs}\PYG{p}{,} \PYG{k+kt}{bool} \PYG{n}{fullmode}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{finemapfile} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{null}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
        \PYG{n}{coarsemapfile} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{null}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
        \PYG{n}{pristinefinemapfile} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{null}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
        \PYG{n}{pristinecoarsemapfile} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{null}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{fullmode}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{vargridxsize} \PYG{o}{=} \PYG{n}{stol}\PYG{p}{(}\PYG{n}{comargs}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
            \PYG{n}{vargridysize} \PYG{o}{=} \PYG{n}{stol}\PYG{p}{(}\PYG{n}{comargs}\PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
            \PYG{n}{finemapfile} \PYG{o}{=} \PYG{n}{comargs}\PYG{p}{[}\PYG{l+m+mi}{4}\PYG{p}{]}\PYG{p}{;}
            \PYG{n}{varfinemapxsize} \PYG{o}{=} \PYG{n}{stol}\PYG{p}{(}\PYG{n}{comargs}\PYG{p}{[}\PYG{l+m+mi}{5}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
            \PYG{n}{varfinemapysize} \PYG{o}{=} \PYG{n}{stol}\PYG{p}{(}\PYG{n}{comargs}\PYG{p}{[}\PYG{l+m+mi}{6}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
            \PYG{n}{varfinemapxoffset} \PYG{o}{=} \PYG{n}{stol}\PYG{p}{(}\PYG{n}{comargs}\PYG{p}{[}\PYG{l+m+mi}{7}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
            \PYG{n}{varfinemapyoffset} \PYG{o}{=} \PYG{n}{stol}\PYG{p}{(}\PYG{n}{comargs}\PYG{p}{[}\PYG{l+m+mi}{8}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
            \PYG{n}{coarsemapfile} \PYG{o}{=} \PYG{n}{comargs}\PYG{p}{[}\PYG{l+m+mi}{9}\PYG{p}{]}\PYG{p}{;}
            \PYG{n}{varcoarsemapxsize} \PYG{o}{=} \PYG{n}{stol}\PYG{p}{(}\PYG{n}{comargs}\PYG{p}{[}\PYG{l+m+mi}{10}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
            \PYG{n}{varcoarsemapysize} \PYG{o}{=} \PYG{n}{stol}\PYG{p}{(}\PYG{n}{comargs}\PYG{p}{[}\PYG{l+m+mi}{11}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
            \PYG{n}{varcoarsemapxoffset} \PYG{o}{=} \PYG{n}{stol}\PYG{p}{(}\PYG{n}{comargs}\PYG{p}{[}\PYG{l+m+mi}{12}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
            \PYG{n}{varcoarsemapyoffset} \PYG{o}{=} \PYG{n}{stol}\PYG{p}{(}\PYG{n}{comargs}\PYG{p}{[}\PYG{l+m+mi}{13}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
            \PYG{n}{varcoarsemapscale} \PYG{o}{=} \PYG{n}{stol}\PYG{p}{(}\PYG{n}{comargs}\PYG{p}{[}\PYG{l+m+mi}{14}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
            \PYG{n}{outdirectory} \PYG{o}{=} \PYG{n}{comargs}\PYG{p}{[}\PYG{l+m+mi}{15}\PYG{p}{]}\PYG{p}{;}
            \PYG{n}{lambda} \PYG{o}{=} \PYG{n}{stod}\PYG{p}{(}\PYG{n}{comargs}\PYG{p}{[}\PYG{l+m+mi}{21}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
            \PYG{n}{the\PYGZus{}task} \PYG{o}{=} \PYG{n}{stol}\PYG{p}{(}\PYG{n}{comargs}\PYG{p}{[}\PYG{l+m+mi}{22}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
            \PYG{n}{desired\PYGZus{}specnum} \PYG{o}{=} \PYG{n}{stol}\PYG{p}{(}\PYG{n}{comargs}\PYG{p}{[}\PYG{l+m+mi}{23}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
            \PYG{n}{pristinefinemapfile} \PYG{o}{=} \PYG{n}{comargs}\PYG{p}{[}\PYG{l+m+mi}{24}\PYG{p}{]}\PYG{p}{;}
            \PYG{n}{pristinecoarsemapfile} \PYG{o}{=} \PYG{n}{comargs}\PYG{p}{[}\PYG{l+m+mi}{25}\PYG{p}{]}\PYG{p}{;}
            \PYG{n}{dForestTransform} \PYG{o}{=} \PYG{n}{stod}\PYG{p}{(}\PYG{n}{comargs}\PYG{p}{[}\PYG{l+m+mi}{26}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
            \PYG{n}{dPristine} \PYG{o}{=} \PYG{n}{stod}\PYG{p}{(}\PYG{n}{comargs}\PYG{p}{[}\PYG{l+m+mi}{27}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
            \PYG{n}{deme} \PYG{o}{=} \PYG{n}{stol}\PYG{p}{(}\PYG{n}{comargs}\PYG{p}{[}\PYG{l+m+mi}{18}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
            \PYG{n}{deme\PYGZus{}sample} \PYG{o}{=} \PYG{n}{stod}\PYG{p}{(}\PYG{n}{comargs}\PYG{p}{[}\PYG{l+m+mi}{19}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
            \PYG{n}{spec} \PYG{o}{=} \PYG{n}{stold}\PYG{p}{(}\PYG{n}{comargs}\PYG{p}{[}\PYG{l+m+mi}{16}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
            \PYG{n}{zfat} \PYG{o}{=} \PYG{n}{stod}\PYG{p}{(}\PYG{n}{comargs}\PYG{p}{[}\PYG{l+m+mi}{17}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
            \PYG{n}{maxtime} \PYG{o}{=} \PYG{n}{stod}\PYG{p}{(}\PYG{n}{comargs}\PYG{p}{[}\PYG{l+m+mi}{20}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
            \PYG{n}{dLvalue} \PYG{o}{=} \PYG{n}{stod}\PYG{p}{(}\PYG{n}{comargs}\PYG{p}{[}\PYG{l+m+mi}{28}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
            \PYG{n}{samplemaskfile} \PYG{o}{=} \PYG{n}{comargs}\PYG{p}{[}\PYG{l+m+mi}{29}\PYG{p}{]}\PYG{p}{;}
            \PYG{n}{autocorrel\PYGZus{}file} \PYG{o}{=} \PYG{n}{comargs}\PYG{p}{[}\PYG{l+m+mi}{30}\PYG{p}{]}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{else}
        \PYG{p}{\PYGZob{}}
            \PYG{c+c1}{// do the import of the values from combination of command\PYGZhy{}line arguments and file.}
            \PYG{n}{configs}\PYG{p}{.}\PYG{n}{setConfig}\PYG{p}{(}\PYG{n}{comargs}\PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{,}\PYG{n+nb}{false}\PYG{p}{,}\PYG{n+nb}{true}\PYG{p}{)}\PYG{p}{;}
            \PYG{n}{configs}\PYG{p}{.}\PYG{n}{parseConfig}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
            \PYG{n}{vargridxsize} \PYG{o}{=} \PYG{n}{stol}\PYG{p}{(}\PYG{n}{configs}\PYG{p}{.}\PYG{n}{getSectionOptions}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{sample\PYGZus{}grid}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{x}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
            \PYG{n}{vargridysize} \PYG{o}{=} \PYG{n}{stol}\PYG{p}{(}\PYG{n}{configs}\PYG{p}{.}\PYG{n}{getSectionOptions}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{sample\PYGZus{}grid}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{y}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
            \PYG{n}{samplemaskfile} \PYG{o}{=} \PYG{n}{configs}\PYG{p}{.}\PYG{n}{getSectionOptions}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{sample\PYGZus{}grid}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{mask}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
            \PYG{n}{finemapfile} \PYG{o}{=} \PYG{n}{configs}\PYG{p}{.}\PYG{n}{getSectionOptions}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{fine\PYGZus{}map}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{path}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
            \PYG{n}{varfinemapxsize} \PYG{o}{=} \PYG{n}{stol}\PYG{p}{(}\PYG{n}{configs}\PYG{p}{.}\PYG{n}{getSectionOptions}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{fine\PYGZus{}map}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{x}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
            \PYG{n}{varfinemapysize} \PYG{o}{=} \PYG{n}{stol}\PYG{p}{(}\PYG{n}{configs}\PYG{p}{.}\PYG{n}{getSectionOptions}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{fine\PYGZus{}map}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{y}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
            \PYG{n}{varfinemapxoffset} \PYG{o}{=} \PYG{n}{stol}\PYG{p}{(}\PYG{n}{configs}\PYG{p}{.}\PYG{n}{getSectionOptions}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{fine\PYGZus{}map}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{x\PYGZus{}off}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
            \PYG{n}{varfinemapyoffset} \PYG{o}{=} \PYG{n}{stol}\PYG{p}{(}\PYG{n}{configs}\PYG{p}{.}\PYG{n}{getSectionOptions}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{fine\PYGZus{}map}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{y\PYGZus{}off}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
            \PYG{n}{coarsemapfile} \PYG{o}{=} \PYG{n}{configs}\PYG{p}{.}\PYG{n}{getSectionOptions}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{coarse\PYGZus{}map}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{path}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
            \PYG{n}{varcoarsemapxsize} \PYG{o}{=} \PYG{n}{stol}\PYG{p}{(}\PYG{n}{configs}\PYG{p}{.}\PYG{n}{getSectionOptions}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{coarse\PYGZus{}map}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{x}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
            \PYG{n}{varcoarsemapysize} \PYG{o}{=} \PYG{n}{stol}\PYG{p}{(}\PYG{n}{configs}\PYG{p}{.}\PYG{n}{getSectionOptions}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{coarse\PYGZus{}map}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{y}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
            \PYG{n}{varcoarsemapxoffset} \PYG{o}{=} \PYG{n}{stol}\PYG{p}{(}\PYG{n}{configs}\PYG{p}{.}\PYG{n}{getSectionOptions}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{coarse\PYGZus{}map}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{x\PYGZus{}off}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
            \PYG{n}{varcoarsemapyoffset} \PYG{o}{=} \PYG{n}{stol}\PYG{p}{(}\PYG{n}{configs}\PYG{p}{.}\PYG{n}{getSectionOptions}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{coarse\PYGZus{}map}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{y\PYGZus{}off}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
            \PYG{n}{varcoarsemapscale} \PYG{o}{=} \PYG{n}{stol}\PYG{p}{(}\PYG{n}{configs}\PYG{p}{.}\PYG{n}{getSectionOptions}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{coarse\PYGZus{}map}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{scale}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
            \PYG{n}{pristinefinemapfile} \PYG{o}{=} \PYG{n}{configs}\PYG{p}{.}\PYG{n}{getSectionOptions}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{pristine\PYGZus{}fine0}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{path}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
            \PYG{n}{pristinecoarsemapfile} \PYG{o}{=} \PYG{n}{configs}\PYG{p}{.}\PYG{n}{getSectionOptions}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{pristine\PYGZus{}coarse0}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{path}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
            \PYG{n}{outdirectory} \PYG{o}{=} \PYG{n}{comargs}\PYG{p}{[}\PYG{l+m+mi}{4}\PYG{p}{]}\PYG{p}{;}
            \PYG{n}{the\PYGZus{}task} \PYG{o}{=} \PYG{n}{stol}\PYG{p}{(}\PYG{n}{comargs}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
             \PYG{c+c1}{//= stol(comargs[5]);}
            \PYG{n}{zfat} \PYG{o}{=} \PYG{n}{stod}\PYG{p}{(}\PYG{n}{comargs}\PYG{p}{[}\PYG{l+m+mi}{6}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
            \PYG{n}{dLvalue} \PYG{o}{=} \PYG{n}{stod}\PYG{p}{(}\PYG{n}{comargs}\PYG{p}{[}\PYG{l+m+mi}{7}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
            \PYG{n}{deme} \PYG{o}{=} \PYG{n}{stol}\PYG{p}{(}\PYG{n}{comargs}\PYG{p}{[}\PYG{l+m+mi}{8}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
            \PYG{n}{deme\PYGZus{}sample} \PYG{o}{=} \PYG{n}{stod}\PYG{p}{(}\PYG{n}{comargs}\PYG{p}{[}\PYG{l+m+mi}{9}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
            \PYG{n}{maxtime} \PYG{o}{=} \PYG{n}{stod}\PYG{p}{(}\PYG{n}{comargs}\PYG{p}{[}\PYG{l+m+mi}{10}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
            \PYG{n}{lambda} \PYG{o}{=} \PYG{n}{stod}\PYG{p}{(}\PYG{n}{comargs}\PYG{p}{[}\PYG{l+m+mi}{11}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
            \PYG{n}{autocorrel\PYGZus{}file} \PYG{o}{=} \PYG{n}{comargs}\PYG{p}{[}\PYG{l+m+mi}{12}\PYG{p}{]}\PYG{p}{;}
            \PYG{n}{spec} \PYG{o}{=} \PYG{n}{stod}\PYG{p}{(}\PYG{n}{comargs}\PYG{p}{[}\PYG{l+m+mi}{5}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\PYG{c+c1}{//          cout \PYGZlt{}\PYGZlt{} spec\PYGZlt{}\PYGZlt{} endl;}
\PYG{c+c1}{//          cout \PYGZlt{}\PYGZlt{} comargs[5] \PYGZlt{}\PYGZlt{} endl;}
\PYG{c+c1}{//          cout \PYGZlt{}\PYGZlt{} \PYGZdq{}auto\PYGZdq{} \PYGZlt{}\PYGZlt{} autocorrel\PYGZus{}file \PYGZlt{}\PYGZlt{} endl;}
            \PYG{n}{desired\PYGZus{}specnum} \PYG{o}{=} \PYG{n}{stol}\PYG{p}{(}\PYG{n}{comargs}\PYG{p}{[}\PYG{l+m+mi}{13}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\PYG{c+c1}{//          printVars();}
        \PYG{p}{\PYGZcb{}}
    \PYG{p}{\PYGZcb{}}

    \PYG{k+kt}{void} \PYG{n+nf}{setPristine}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{int} \PYG{n}{n}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{bPristine} \PYG{o}{=} \PYG{n+nb}{true}\PYG{p}{;}
        \PYG{c+c1}{// Loop over each element in the config file (each line) and check if it is pristine fine or pristine coarse.}
        \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{configs}\PYG{p}{.}\PYG{n}{getSectionOptionsSize}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{n}{i} \PYG{o}{+}\PYG{o}{+} \PYG{p}{)}
        \PYG{p}{\PYGZob{}}

            \PYG{k}{if}\PYG{p}{(}\PYG{n}{configs}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{section}\PYG{p}{.}\PYG{n}{find}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{pristine\PYGZus{}fine}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{c+c1}{// Then loop over each element to find the number, and check if it is equal to our input number.}
                \PYG{k}{if}\PYG{p}{(}\PYG{n}{stol}\PYG{p}{(}\PYG{n}{configs}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getOption}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{number}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{)} \PYG{o}{=}\PYG{o}{=} \PYG{n}{n}\PYG{p}{)}
                \PYG{p}{\PYGZob{}}
                    \PYG{n}{bPristine} \PYG{o}{=} \PYG{n+nb}{false}\PYG{p}{;}
                    \PYG{n}{pristinefinemapfile} \PYG{o}{=} \PYG{n}{configs}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getOption}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{path}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
                    \PYG{n}{dForestTransform} \PYG{o}{=} \PYG{n}{stod}\PYG{p}{(}\PYG{n}{configs}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getOption}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{rate}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
                    \PYG{n}{dPristine} \PYG{o}{=} \PYG{n}{stod}\PYG{p}{(}\PYG{n}{configs}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getOption}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{time}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
                \PYG{p}{\PYGZcb{}}
            \PYG{p}{\PYGZcb{}}
            \PYG{k}{else} \PYG{k}{if}\PYG{p}{(}\PYG{n}{configs}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{section}\PYG{p}{.}\PYG{n}{find}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{pristine\PYGZus{}coarse}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{k}{if}\PYG{p}{(}\PYG{n}{stol}\PYG{p}{(}\PYG{n}{configs}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getOption}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{number}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{)} \PYG{o}{=}\PYG{o}{=} \PYG{n}{n}\PYG{p}{)}
                \PYG{p}{\PYGZob{}}
                    \PYG{n}{bPristine} \PYG{o}{=} \PYG{n+nb}{false}\PYG{p}{;}
                    \PYG{n}{pristinefinemapfile} \PYG{o}{=} \PYG{n}{configs}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getOption}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{path}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
                    \PYG{c+c1}{// check matches}
                    \PYG{k}{if}\PYG{p}{(}\PYG{n}{dForestTransform} \PYG{o}{!}\PYG{o}{=} \PYG{n}{stod}\PYG{p}{(}\PYG{n}{configs}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getOption}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{rate}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{)} \PYG{o}{\textbar{}}\PYG{o}{\textbar{}} \PYG{n}{dPristine} \PYG{o}{!}\PYG{o}{=} \PYG{n}{stod}\PYG{p}{(}\PYG{n}{configs}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getOption}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{time}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
                    \PYG{p}{\PYGZob{}}
                        \PYG{n}{cerr} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Forest transform values do not match between fine and coarse maps. Using fine values.}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
                    \PYG{p}{\PYGZcb{}}
                \PYG{p}{\PYGZcb{}}
            \PYG{p}{\PYGZcb{}}
        \PYG{p}{\PYGZcb{}}
    \PYG{p}{\PYGZcb{}}
    \PYG{k+kt}{void} \PYG{n+nf}{printVars}\PYG{p}{(}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{task: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{the\PYGZus{}task} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
        \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Fine input file: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{finemapfile}  \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
        \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZhy{}dimensions: (}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{varfinemapxsize} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{,}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{varfinemapysize} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{)}\PYG{l+s}{\PYGZdq{}}\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
        \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZhy{}offset: (}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{varfinemapxoffset} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{,}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{varfinemapyoffset} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{)}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
        \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Coarse input file: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{coarsemapfile}  \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
        \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZhy{}dimensions: (}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{varcoarsemapxsize} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{,}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{varcoarsemapysize} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{)}\PYG{l+s}{\PYGZdq{}}\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
        \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZhy{}offset: (}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{varcoarsemapxoffset} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{,}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{varcoarsemapyoffset} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{)}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
        \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZhy{}scale: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{varcoarsemapscale} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
        \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Sample grid}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
        \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZhy{}dimensions: (}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{vargridxsize} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{,}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{vargridysize} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{)}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
        \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZhy{}deme: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{deme} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
        \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZhy{}deme sample: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{deme\PYGZus{}sample} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
        \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Output directory: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{outdirectory} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
        \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Lambda: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{lambda} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}

    \PYG{p}{\PYGZcb{}}

    \PYG{k}{friend} \PYG{n}{ostream}\PYG{o}{\PYGZam{}} \PYG{k}{operator}\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{p}{(}\PYG{n}{ostream}\PYG{o}{\PYGZam{}} \PYG{n}{os}\PYG{p}{,}\PYG{k}{const} \PYG{n}{Mapvars}\PYG{o}{\PYGZam{}} \PYG{n}{m}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{os} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{m}\PYG{p}{.}\PYG{n}{finemapfile} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{m}\PYG{p}{.}\PYG{n}{coarsemapfile} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{m}\PYG{p}{.}\PYG{n}{pristinefinemapfile} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{m}\PYG{p}{.}\PYG{n}{pristinecoarsemapfile} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{m}\PYG{p}{.}\PYG{n}{samplemaskfile} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
        \PYG{n}{os} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{m}\PYG{p}{.}\PYG{n}{the\PYGZus{}task} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}  \PYG{n}{m}\PYG{p}{.}\PYG{n}{vargridxsize} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{m}\PYG{p}{.}\PYG{n}{vargridysize} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{m}\PYG{p}{.}\PYG{n}{varfinemapxsize} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{m}\PYG{p}{.}\PYG{n}{varfinemapysize} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
        \PYG{n}{os} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{m}\PYG{p}{.}\PYG{n}{varfinemapxoffset} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{m}\PYG{p}{.}\PYG{n}{varfinemapyoffset} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{m}\PYG{p}{.}\PYG{n}{varcoarsemapxsize} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{m}\PYG{p}{.}\PYG{n}{varcoarsemapysize} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{m}\PYG{p}{.}\PYG{n}{varcoarsemapxoffset} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
        \PYG{n}{os} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{m}\PYG{p}{.}\PYG{n}{varcoarsemapyoffset} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{m}\PYG{p}{.}\PYG{n}{varcoarsemapscale} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{m}\PYG{p}{.}\PYG{n}{desired\PYGZus{}specnum} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{m}\PYG{p}{.}\PYG{n}{lambda} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{m}\PYG{p}{.}\PYG{n}{deme} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{m}\PYG{p}{.}\PYG{n}{deme\PYGZus{}sample}\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
        \PYG{n}{os} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{m}\PYG{p}{.}\PYG{n}{spec} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{m}\PYG{p}{.}\PYG{n}{zfat} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{m}\PYG{p}{.}\PYG{n}{maxtime} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{m}\PYG{p}{.}\PYG{n}{dPristine} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{m}\PYG{p}{.} \PYG{n}{dForestTransform} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{m}\PYG{p}{.}\PYG{n}{dLvalue} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{m}\PYG{p}{.}\PYG{n}{autocorrel\PYGZus{}file} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
        \PYG{n}{os} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{m}\PYG{p}{.}\PYG{n}{configs}\PYG{p}{;}
        \PYG{k}{return} \PYG{n}{os}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{k}{friend} \PYG{n}{istream}\PYG{o}{\PYGZam{}} \PYG{k}{operator}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{n}{istream}\PYG{o}{\PYGZam{}} \PYG{n}{is}\PYG{p}{,} \PYG{n}{Mapvars}\PYG{o}{\PYGZam{}} \PYG{n}{m}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{c+c1}{//os \PYGZlt{}\PYGZlt{} m.numRows\PYGZlt{}\PYGZlt{}\PYGZdq{} , \PYGZdq{}\PYGZlt{}\PYGZlt{}m.numCols\PYGZlt{}\PYGZlt{}\PYGZdq{} , \PYGZdq{}\PYGZlt{}\PYGZlt{}endl;}
        \PYG{c+c1}{//char delim;}
        \PYG{c+c1}{//cout \PYGZlt{}\PYGZlt{} \PYGZdq{}check\PYGZdq{} \PYGZlt{}\PYGZlt{} endl;}
        \PYG{n}{is} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{m}\PYG{p}{.}\PYG{n}{finemapfile} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{m}\PYG{p}{.}\PYG{n}{coarsemapfile} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{m}\PYG{p}{.}\PYG{n}{pristinefinemapfile} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{m}\PYG{p}{.}\PYG{n}{pristinecoarsemapfile} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{m}\PYG{p}{.}\PYG{n}{samplemaskfile} \PYG{p}{;}
        \PYG{n}{is} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{m}\PYG{p}{.}\PYG{n}{the\PYGZus{}task} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}}  \PYG{n}{m}\PYG{p}{.}\PYG{n}{vargridxsize} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{m}\PYG{p}{.}\PYG{n}{vargridysize} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{m}\PYG{p}{.}\PYG{n}{varfinemapxsize} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{m}\PYG{p}{.}\PYG{n}{varfinemapysize} \PYG{p}{;}
        \PYG{n}{is} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{m}\PYG{p}{.}\PYG{n}{varfinemapxoffset} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{m}\PYG{p}{.}\PYG{n}{varfinemapyoffset} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{m}\PYG{p}{.}\PYG{n}{varcoarsemapxsize} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{m}\PYG{p}{.}\PYG{n}{varcoarsemapysize} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{m}\PYG{p}{.}\PYG{n}{varcoarsemapxoffset} \PYG{p}{;}
        \PYG{n}{is} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{m}\PYG{p}{.}\PYG{n}{varcoarsemapyoffset} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{m}\PYG{p}{.}\PYG{n}{varcoarsemapscale} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{m}\PYG{p}{.}\PYG{n}{desired\PYGZus{}specnum} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{m}\PYG{p}{.}\PYG{n}{lambda} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{m}\PYG{p}{.}\PYG{n}{deme} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{m}\PYG{p}{.}\PYG{n}{deme\PYGZus{}sample}\PYG{p}{;}
        \PYG{n}{is} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{m}\PYG{p}{.}\PYG{n}{spec} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{m}\PYG{p}{.}\PYG{n}{zfat} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{m}\PYG{p}{.}\PYG{n}{maxtime} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{m}\PYG{p}{.}\PYG{n}{dPristine} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{m}\PYG{p}{.} \PYG{n}{dForestTransform} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{m}\PYG{p}{.}\PYG{n}{dLvalue} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{m}\PYG{p}{.}\PYG{n}{autocorrel\PYGZus{}file}\PYG{p}{;}
        \PYG{c+c1}{//cout \PYGZlt{}\PYGZlt{} \PYGZdq{}2\PYGZdq{} \PYGZlt{}\PYGZlt{} endl;}
        \PYG{n}{is} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{m}\PYG{p}{.}\PYG{n}{configs}\PYG{p}{;}
        \PYG{c+c1}{//cout \PYGZlt{}\PYGZlt{} \PYGZdq{}mate\PYGZdq{} \PYGZlt{}\PYGZlt{} endl;}
        \PYG{k}{return} \PYG{n}{is}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}

\PYG{c+c1}{// Class which contains the Datamask object, telling us where to sample from within the habitat map.}
\PYG{k}{class} \PYG{n+nc}{Datamask}
\PYG{p}{\PYGZob{}}
\PYG{k}{private}\PYG{o}{:}
    \PYG{n}{string} \PYG{n}{inputfile}\PYG{p}{;} \PYG{c+c1}{// the file to read in from}
    \PYG{k+kt}{bool} \PYG{n}{bDefault}\PYG{p}{;}
\PYG{k}{public}\PYG{o}{:}
    \PYG{n}{Matrix}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{bool}\PYG{o}{\PYGZgt{}} \PYG{n}{sample\PYGZus{}mask}\PYG{p}{;}
    \PYG{n}{Datamask}\PYG{p}{(}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{bDefault} \PYG{o}{=} \PYG{n+nb}{true}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{k+kt}{void} \PYG{n}{importDatamask}\PYG{p}{(}\PYG{n}{Mapvars}\PYG{o}{\PYGZam{}} \PYG{n}{mapvarin}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{inputfile} \PYG{o}{=} \PYG{n}{mapvarin}\PYG{p}{.}\PYG{n}{samplemaskfile}\PYG{p}{;}
\PYG{c+c1}{//      cout \PYGZlt{}\PYGZlt{} \PYGZdq{}inputfile: \PYGZdq{} \PYGZlt{}\PYGZlt{} inputfile;}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{inputfile} \PYG{o}{=}\PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{null}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{bDefault} \PYG{o}{=} \PYG{n+nb}{true}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{else}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{sample\PYGZus{}mask}\PYG{p}{.}\PYG{n}{SetSize}\PYG{p}{(}\PYG{n}{mapvarin}\PYG{p}{.}\PYG{n}{vargridysize}\PYG{p}{,}\PYG{n}{mapvarin}\PYG{p}{.}\PYG{n}{vargridxsize}\PYG{p}{)}\PYG{p}{;}
            \PYG{n}{bDefault} \PYG{o}{=} \PYG{n+nb}{false}\PYG{p}{;}
            \PYG{n}{sample\PYGZus{}mask}\PYG{p}{.}\PYG{n}{import}\PYG{p}{(}\PYG{n}{inputfile}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
    \PYG{p}{\PYGZcb{}}

    \PYG{k+kt}{bool} \PYG{n}{getVal}\PYG{p}{(}\PYG{k+kt}{long} \PYG{n}{x}\PYG{p}{,} \PYG{k+kt}{long} \PYG{n}{y}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{bDefault}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{k}{return} \PYG{n+nb}{true}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{else}
        \PYG{p}{\PYGZob{}}
            \PYG{k}{return} \PYG{n}{sample\PYGZus{}mask}\PYG{p}{[}\PYG{n}{y}\PYG{p}{]}\PYG{p}{[}\PYG{n}{x}\PYG{p}{]}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
    \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{c+cm}{/************************************************************}
\PYG{c+cm}{                    MAP OBJECT}
\PYG{c+cm}{ ************************************************************/}
 \PYG{c+c1}{// Object containing both the maps (the coarse and fine version) and routines for easy setting up and switching between the different coordinate systems.}
 \PYG{k}{class} \PYG{n+nc}{Map}
 \PYG{p}{\PYGZob{}}
\PYG{k}{private}\PYG{o}{:}
    \PYG{c+c1}{// The map files which are read in (or generated if running with \PYGZdq{}null\PYGZdq{} as the map file\PYGZdq{}.}
    \PYG{c+c1}{// Pristine maps are meant for before any deforestation occured, whereas the other maps are intended for modern day maps.}
    \PYG{c+c1}{// A linear transformation from modern to pristine maps is used, approaching the dForestTransform variable times the difference between the pristine and modern maps.}
    \PYG{c+c1}{// Once the dPristine number of generations has been reached, the map will jump to the pristine condition.}
     \PYG{n}{Matrix}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{unsigned} \PYG{k+kt}{short}\PYG{o}{\PYGZgt{}} \PYG{n}{fine\PYGZus{}map}\PYG{p}{;} \PYG{c+c1}{// the finer grid for the area around the sample area.}
     \PYG{n}{Matrix}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{unsigned} \PYG{k+kt}{short}\PYG{o}{\PYGZgt{}} \PYG{n}{pristine\PYGZus{}fine\PYGZus{}map}\PYG{p}{;} \PYG{c+c1}{// the pristine finer map.}
     \PYG{n}{Matrix}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{unsigned} \PYG{k+kt}{short}\PYG{o}{\PYGZgt{}} \PYG{n}{coarse\PYGZus{}map}\PYG{p}{;} \PYG{c+c1}{// the coarser grid for the wider zone.}
     \PYG{n}{Matrix}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{unsigned} \PYG{k+kt}{short}\PYG{o}{\PYGZgt{}} \PYG{n}{pristine\PYGZus{}coarse\PYGZus{}map}\PYG{p}{;} \PYG{c+c1}{// the pristine coarser map.}
     \PYG{n}{Mapvars} \PYG{n}{mapvars}\PYG{p}{;} \PYG{c+c1}{// for importing and storing the simulation set\PYGZhy{}up options.}
     \PYG{k+kt}{long} \PYG{n}{finexmin}\PYG{p}{,}\PYG{n}{fineymin}\PYG{p}{,}\PYG{n}{coarsexmin}\PYG{p}{,}\PYG{n}{coarseymin}\PYG{p}{;} \PYG{c+c1}{// the minimum values for each dimension for offsetting.}
     \PYG{k+kt}{long} \PYG{n}{finexmax}\PYG{p}{,}\PYG{n}{fineymax}\PYG{p}{,}\PYG{n}{coarsexmax}\PYG{p}{,}\PYG{n}{coarseymax}\PYG{p}{;} \PYG{c+c1}{// the maximum values for each dimension for offsetting.}
     \PYG{k+kt}{long} \PYG{n}{finexoffset}\PYG{p}{,} \PYG{n}{fineyoffset}\PYG{p}{,} \PYG{n}{coarsexoffset}\PYG{p}{,} \PYG{n}{coarseyoffset}\PYG{p}{;} \PYG{c+c1}{// the offsetting of the map in FINE map units.}
     \PYG{k+kt}{int} \PYG{n}{scale}\PYG{p}{;} \PYG{c+c1}{// the scale of the coarse map compared with the smaller map.}
     \PYG{k+kt}{long} \PYG{n}{xdim}\PYG{p}{;} \PYG{c+c1}{// the length of the grid where the species start.}
     \PYG{k+kt}{long} \PYG{n}{ydim}\PYG{p}{;} \PYG{c+c1}{// the height of the grid where the species start.}
     \PYG{k+kt}{long} \PYG{n}{deme}\PYG{p}{;}
     \PYG{k+kt}{bool} \PYG{n}{checksetdim}\PYG{p}{;} \PYG{c+c1}{// for checking that the dimensions have been set before attempting to import the maps.}
     \PYG{k+kt}{double} \PYG{n}{lambda}\PYG{p}{;} \PYG{c+c1}{// for setting the movement cost through forest.}

    \PYG{k+kt}{double} \PYG{n}{dUpdateTime}\PYG{p}{;} \PYG{c+c1}{// the last time the map was updated, in generations.}
    \PYG{k+kt}{double} \PYG{n}{dForestTransform}\PYG{p}{;} \PYG{c+c1}{// the rate at which the forest transforms from the modern forest map to the pristine forest map. A value of 1 will give a smooth curve from the present day to pristine forest.}
    \PYG{k+kt}{double} \PYG{n}{dPristine}\PYG{p}{;} \PYG{c+c1}{// the number of generations at which point the forest becomes entirely pristine.}
    \PYG{k+kt}{double} \PYG{n}{dCurrent}\PYG{p}{;} \PYG{c+c1}{// the time the current map was updated.}
    \PYG{k+kt}{bool} \PYG{n}{bPristine}\PYG{p}{;} \PYG{c+c1}{// checks whether the simulation has already been set to the pristine state.}

     \PYG{n}{string} \PYG{n}{NextMap}\PYG{p}{;}
     \PYG{k+kt}{unsigned} \PYG{k+kt}{int} \PYG{n}{nUpdate}\PYG{p}{;} \PYG{c+c1}{// the number of updates to have occured.}

\PYG{k}{public}\PYG{o}{:}
    \PYG{n}{Map}\PYG{p}{(}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{checksetdim} \PYG{o}{=} \PYG{n+nb}{false}\PYG{p}{;} \PYG{c+c1}{// sets the check to false.}
        \PYG{n}{bPristine} \PYG{o}{=} \PYG{n+nb}{false}\PYG{p}{;}
        \PYG{n}{dCurrent} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{k+kt}{void} \PYG{n}{setDims}\PYG{p}{(}\PYG{n}{Mapvars} \PYG{n}{mapvarsin}\PYG{p}{)}\PYG{p}{;}

    \PYG{k+kt}{bool} \PYG{n+nf}{checkMapExists}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

    \PYG{c+cm}{/********************************************}
\PYG{c+cm}{     * CALC MAP FUNCTIONS}
\PYG{c+cm}{     ********************************************/}

     \PYG{k+kt}{void} \PYG{n+nf}{calcFineMap}\PYG{p}{(}\PYG{p}{)} \PYG{p}{;}

    \PYG{k+kt}{void} \PYG{n+nf}{calcPristineFineMap}\PYG{p}{(}\PYG{p}{)} \PYG{p}{;}

    \PYG{k+kt}{void} \PYG{n+nf}{calcCoarseMap}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

    \PYG{k+kt}{void} \PYG{n+nf}{calcPristineCoarseMap}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

    \PYG{c+c1}{// Map setters}
    \PYG{k+kt}{void} \PYG{n+nf}{setTimeVars}\PYG{p}{(}\PYG{k+kt}{double} \PYG{n}{dPristinein}\PYG{p}{,} \PYG{k+kt}{double} \PYG{n}{dForestTransformin}\PYG{p}{)}\PYG{p}{;}


    \PYG{k+kt}{void} \PYG{n+nf}{calcOffset}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
    \PYG{c+cm}{/********************************************}
\PYG{c+cm}{     * VALIDATE MAPS}
\PYG{c+cm}{     ********************************************/}

    \PYG{k+kt}{void} \PYG{n+nf}{validateMaps}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

    \PYG{c+cm}{/********************************************}
\PYG{c+cm}{     * CHANGE MAP FUNCTIONS}
\PYG{c+cm}{     ********************************************/}

    \PYG{k+kt}{void} \PYG{n+nf}{updateMap}\PYG{p}{(}\PYG{k+kt}{double} \PYG{n}{generation}\PYG{p}{)}\PYG{p}{;}

    \PYG{k+kt}{bool} \PYG{n+nf}{isPristine}\PYG{p}{(}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{return} \PYG{n}{bPristine}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{k+kt}{void} \PYG{n+nf}{setPristine}\PYG{p}{(}\PYG{k}{const} \PYG{k+kt}{bool} \PYG{o}{\PYGZam{}}\PYG{n}{bPristinein}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{bPristine} \PYG{o}{=} \PYG{n}{bPristinein}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{c+c1}{//}
    \PYG{c+cm}{/********************************************}
\PYG{c+cm}{     * GET VAL FUNCTIONS}
\PYG{c+cm}{     ********************************************/}


    \PYG{c+c1}{// Function for getting the val at a particular coordinate from either the coarse or fine map}
    \PYG{c+c1}{// altered to use the current generation as well to determine the value.}
    \PYG{k+kt}{unsigned} \PYG{k+kt}{short} \PYG{n+nf}{getVal}\PYG{p}{(}\PYG{k}{const} \PYG{k+kt}{double} \PYG{o}{\PYGZam{}}\PYG{n}{x}\PYG{p}{,}\PYG{k}{const} \PYG{k+kt}{double} \PYG{o}{\PYGZam{}}\PYG{n}{y}\PYG{p}{,}\PYG{k}{const} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{xwrap}\PYG{p}{,}\PYG{k}{const} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{ywrap}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{double} \PYG{o}{\PYGZam{}}\PYG{n}{dCurrentGen}\PYG{p}{)}\PYG{p}{;}

    \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n+nf}{getInitialCount}\PYG{p}{(}\PYG{k+kt}{double} \PYG{n}{dSample}\PYG{p}{,} \PYG{n}{Datamask}\PYG{o}{\PYGZam{}} \PYG{n}{samplemask}\PYG{p}{)}\PYG{p}{;}

    \PYG{c+cm}{/********************************************}
\PYG{c+cm}{     * CHECK MAP FUNCTIONS}
\PYG{c+cm}{     ********************************************/}
     \PYG{k+kt}{bool} \PYG{n+nf}{checkMap}\PYG{p}{(}\PYG{k}{const} \PYG{k+kt}{double} \PYG{o}{\PYGZam{}}\PYG{n}{x}\PYG{p}{,}\PYG{k}{const} \PYG{k+kt}{double} \PYG{o}{\PYGZam{}}\PYG{n}{y}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{xwrap}\PYG{p}{,}\PYG{k}{const} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{ywrap}\PYG{p}{,}\PYG{k}{const} \PYG{k+kt}{double} \PYG{n}{generation}\PYG{p}{)}\PYG{p}{;}


     \PYG{k+kt}{bool} \PYG{n+nf}{checkFine}\PYG{p}{(}\PYG{k}{const} \PYG{k+kt}{double} \PYG{o}{\PYGZam{}}\PYG{n}{x}\PYG{p}{,}\PYG{k}{const} \PYG{k+kt}{double} \PYG{o}{\PYGZam{}}\PYG{n}{y}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{xwrap}\PYG{p}{,}\PYG{k}{const} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{ywrap}\PYG{p}{)}\PYG{p}{;}


    \PYG{k+kt}{void} \PYG{n+nf}{convertCoordinates}\PYG{p}{(}\PYG{k+kt}{double} \PYG{o}{\PYGZam{}}\PYG{n}{x}\PYG{p}{,} \PYG{k+kt}{double} \PYG{o}{\PYGZam{}}\PYG{n}{y}\PYG{p}{,} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{xwrap}\PYG{p}{,} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{ywrap}\PYG{p}{)}\PYG{p}{;}

    \PYG{c+cm}{/********************************************}
\PYG{c+cm}{     * MAIN DISPERSAL FUNCTION}
\PYG{c+cm}{     ********************************************/}
    \PYG{k+kt}{void} \PYG{n+nf}{runDispersal}\PYG{p}{(}\PYG{k}{const} \PYG{k+kt}{double} \PYG{o}{\PYGZam{}}\PYG{n}{dist}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{double} \PYG{o}{\PYGZam{}}\PYG{n}{angle}\PYG{p}{,} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{startx} \PYG{p}{,}\PYG{k+kt}{long}  \PYG{o}{\PYGZam{}}\PYG{n}{starty} \PYG{p}{,} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{startxwrap}\PYG{p}{,} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{startywrap}\PYG{p}{,} \PYG{k+kt}{bool} \PYG{o}{\PYGZam{}}\PYG{n}{disp\PYGZus{}comp}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{double} \PYG{o}{\PYGZam{}}\PYG{n}{generation}\PYG{p}{)}\PYG{p}{;}


    \PYG{k}{friend} \PYG{n}{ostream}\PYG{o}{\PYGZam{}} \PYG{k}{operator}\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{p}{(}\PYG{n}{ostream}\PYG{o}{\PYGZam{}} \PYG{n}{os}\PYG{p}{,}\PYG{k}{const} \PYG{n}{Map}\PYG{o}{\PYGZam{}} \PYG{n}{r}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{os} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{r}\PYG{p}{.}\PYG{n}{mapvars} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{r}\PYG{p}{.}\PYG{n}{finexmin} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{r}\PYG{p}{.}\PYG{n}{finexmax} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{r}\PYG{p}{.}\PYG{n}{coarsexmin} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{r}\PYG{p}{.}\PYG{n}{coarsexmax} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{r}\PYG{p}{.}\PYG{n}{fineymin} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{r}\PYG{p}{.}\PYG{n}{fineymax} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{r}\PYG{p}{.}\PYG{n}{coarseymin} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{r}\PYG{p}{.}\PYG{n}{coarseymax} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
        \PYG{n}{os} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{r}\PYG{p}{.}\PYG{n}{finexoffset} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{r}\PYG{p}{.}\PYG{n}{fineyoffset} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{r}\PYG{p}{.}\PYG{n}{coarsexoffset} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{r}\PYG{p}{.}\PYG{n}{coarseyoffset} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{r}\PYG{p}{.}\PYG{n}{scale} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{r}\PYG{p}{.}\PYG{n}{xdim} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{r}\PYG{p}{.}\PYG{n}{ydim} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{r}\PYG{p}{.}\PYG{n}{deme} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{r}\PYG{p}{.}\PYG{n}{checksetdim} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{r}\PYG{p}{.}\PYG{n}{lambda} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
        \PYG{n}{os} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{r}\PYG{p}{.}\PYG{n}{dUpdateTime} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{r}\PYG{p}{.}\PYG{n}{dForestTransform} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{r}\PYG{p}{.}\PYG{n}{dPristine} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{r}\PYG{p}{.}\PYG{n}{dCurrent} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{r}\PYG{p}{.}\PYG{n}{bPristine} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{r}\PYG{p}{.}\PYG{n}{NextMap} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{r}\PYG{p}{.}\PYG{n}{nUpdate} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
        \PYG{k}{return} \PYG{n}{os}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{k}{friend} \PYG{n}{istream}\PYG{o}{\PYGZam{}} \PYG{k}{operator}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{n}{istream}\PYG{o}{\PYGZam{}} \PYG{n}{is}\PYG{p}{,} \PYG{n}{Map}\PYG{o}{\PYGZam{}} \PYG{n}{r}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{c+c1}{//double temp1,temp2;}
        \PYG{c+c1}{//is \PYGZlt{}\PYGZlt{} m.numRows\PYGZlt{}\PYGZlt{}\PYGZdq{} , \PYGZdq{}\PYGZlt{}\PYGZlt{}m.numCols\PYGZlt{}\PYGZlt{}\PYGZdq{} , \PYGZdq{}\PYGZlt{}\PYGZlt{}endl;}
        \PYG{n}{is} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{r}\PYG{p}{.}\PYG{n}{mapvars} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{r}\PYG{p}{.}\PYG{n}{finexmin} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{r}\PYG{p}{.}\PYG{n}{finexmax} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{r}\PYG{p}{.}\PYG{n}{coarsexmin} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{r}\PYG{p}{.}\PYG{n}{coarsexmax} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{r}\PYG{p}{.}\PYG{n}{fineymin} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{r}\PYG{p}{.}\PYG{n}{fineymax} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{r}\PYG{p}{.}\PYG{n}{coarseymin} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{r}\PYG{p}{.}\PYG{n}{coarseymax}\PYG{p}{;}
        \PYG{n}{is} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{r}\PYG{p}{.}\PYG{n}{finexoffset} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{r}\PYG{p}{.}\PYG{n}{fineyoffset} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{r}\PYG{p}{.}\PYG{n}{coarsexoffset} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{r}\PYG{p}{.}\PYG{n}{coarseyoffset} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{r}\PYG{p}{.}\PYG{n}{scale} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{r}\PYG{p}{.}\PYG{n}{xdim} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{r}\PYG{p}{.}\PYG{n}{ydim} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{r}\PYG{p}{.}\PYG{n}{deme} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{r}\PYG{p}{.}\PYG{n}{checksetdim} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{r}\PYG{p}{.}\PYG{n}{lambda}\PYG{p}{;}
        \PYG{n}{is} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{r}\PYG{p}{.}\PYG{n}{dUpdateTime} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{r}\PYG{p}{.}\PYG{n}{dForestTransform} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{r}\PYG{p}{.}\PYG{n}{dPristine} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{r}\PYG{p}{.}\PYG{n}{dCurrent} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{r}\PYG{p}{.}\PYG{n}{bPristine} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{r}\PYG{p}{.}\PYG{n}{NextMap} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{r}\PYG{p}{.}\PYG{n}{nUpdate}\PYG{p}{;}
        \PYG{n}{r}\PYG{p}{.}\PYG{n}{calcFineMap}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{r}\PYG{p}{.}\PYG{n}{calcCoarseMap}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{r}\PYG{p}{.}\PYG{n}{calcPristineFineMap}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{r}\PYG{p}{.}\PYG{n}{calcPristineCoarseMap}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{return} \PYG{n}{is}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{k+kt}{void} \PYG{n}{printVars}\PYG{p}{(}\PYG{p}{)}
    \PYG{p}{;}

    \PYG{k+kt}{void} \PYG{n+nf}{clearMap}\PYG{p}{(}\PYG{p}{)}
    \PYG{p}{;}
 \PYG{p}{\PYGZcb{}}\PYG{p}{;}
 \PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif}
\end{sphinxVerbatim}


\subparagraph{Includes}
\label{\detokenize{Exhaled/exhale_file_Map.h:includes}}\begin{itemize}
\item {} 
\sphinxcode{Config.h} ({\hyperref[\detokenize{Exhaled/exhale_file_Config.h:file-config-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File Config.h}}}})

\item {} 
\sphinxcode{Matrix.h} ({\hyperref[\detokenize{Exhaled/exhale_file_Matrix.h:file-matrix-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File Matrix.h}}}})

\item {} 
\sphinxcode{boost/filesystem.hpp}

\item {} 
\sphinxcode{fstream}

\item {} 
\sphinxcode{iostream}

\item {} 
\sphinxcode{math.h}

\item {} 
\sphinxcode{stdexcept}

\item {} 
\sphinxcode{stdio.h}

\item {} 
\sphinxcode{string}

\item {} 
\sphinxcode{vector}

\end{itemize}


\subparagraph{Included By}
\label{\detokenize{Exhaled/exhale_file_Map.h:included-by}}\begin{itemize}
\item {} 
{\hyperref[\detokenize{Exhaled/exhale_file_Tree.h:file-tree-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File Tree.h}}}}

\item {} 
{\hyperref[\detokenize{Exhaled/exhale_file_Map.cpp:file-map-cpp}]{\sphinxcrossref{\DUrole{std,std-ref}{File Map.cpp}}}}

\end{itemize}


\subparagraph{Classes}
\label{\detokenize{Exhaled/exhale_file_Map.h:classes}}\begin{itemize}
\item {} 
{\hyperref[\detokenize{Exhaled/exhale_struct_Mapvars:struct-mapvars}]{\sphinxcrossref{\DUrole{std,std-ref}{Struct Mapvars}}}}

\item {} 
{\hyperref[\detokenize{Exhaled/exhale_class_Datamask:class-datamask}]{\sphinxcrossref{\DUrole{std,std-ref}{Class Datamask}}}}

\item {} 
{\hyperref[\detokenize{Exhaled/exhale_class_Map:class-map}]{\sphinxcrossref{\DUrole{std,std-ref}{Class Map}}}}

\end{itemize}


\paragraph{File Matrix.h}
\label{\detokenize{Exhaled/exhale_file_Matrix.h:file-matrix-h}}\label{\detokenize{Exhaled/exhale_file_Matrix.h::doc}}\label{\detokenize{Exhaled/exhale_file_Matrix.h:id1}}

\subparagraph{Definition (\sphinxstyleliteralintitle{Matrix.h})}
\label{\detokenize{Exhaled/exhale_file_Matrix.h:definition-matrix-h}}

\subparagraph{Program Listing for File Matrix.h}
\label{\detokenize{Exhaled/exhale_program_listing_file_Matrix.h:program-listing-for-file-matrix-h}}\label{\detokenize{Exhaled/exhale_program_listing_file_Matrix.h:program-listing-file-matrix-h}}\label{\detokenize{Exhaled/exhale_program_listing_file_Matrix.h::doc}}\begin{itemize}
\item {} 
Return to documentation for {\hyperref[\detokenize{Exhaled/exhale_file_Matrix.h:file-matrix-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File Matrix.h}}}}

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{//This file is part of NECSim project which is released under BSD\PYGZhy{}3 license.}
\PYG{c+c1}{//See file **LICENSE.txt** or visit https://opensource.org/licenses/BSD\PYGZhy{}3\PYGZhy{}Clause) for full license details.}
\PYG{c+c1}{// Matrix.cpp version 1.12}
\PYG{c+c1}{// Author \PYGZhy{} James Rosindell Leeds University, modified to include additional functionality by Samuel Thompson, Imperial College London}
\PYG{c+c1}{// but with large usage of reference http://www.devarticles.com/c/a/Cplusplus/Operator\PYGZhy{}Overloading\PYGZhy{}in\PYGZhy{}C\PYGZhy{}plus/1}
\PYG{c+c1}{//}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ define version1\PYGZus{}11}
\PYG{c+c1}{// \PYGZsh{} define version1\PYGZus{}1}

\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifndef MATRIX}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ define MATRIX}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ define null 0}
\PYG{c+c1}{//\PYGZsh{} include \PYGZdq{}stdiostream.h\PYGZdq{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ include \PYGZlt{}stdio.h\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}iostream\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}sstream\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}fstream\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}cstdlib\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}cstring\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}stdexcept\PYGZgt{}}
\PYG{c+c1}{//\PYGZsh{}define NDEBUG // uncomment this to disable all asserts.}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}assert.h\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifdef use\PYGZus{}csv}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{c+cpf}{\PYGZlt{}cmath\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}stdexcept\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZdq{}fast\PYGZhy{}cpp\PYGZhy{}csv\PYGZhy{}parser/csv.h\PYGZdq{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifdef with\PYGZus{}gdal}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}gdal\PYGZus{}priv.h\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}cpl\PYGZus{}conv.h\PYGZgt{} // for CPLMalloc()}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}stdint.h\PYGZgt{}}
\PYG{k}{using} \PYG{k}{namespace} \PYG{n}{std}\PYG{p}{;}

\PYG{c+c1}{// Array of data sizes for importing tif files.}
\PYG{k}{const} \PYG{k+kt}{int} \PYG{n}{gdal\PYGZus{}data\PYGZus{}sizes}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{8}\PYG{p}{,}\PYG{l+m+mi}{16}\PYG{p}{,}\PYG{l+m+mi}{16}\PYG{p}{,}\PYG{l+m+mi}{32}\PYG{p}{,}\PYG{l+m+mi}{32}\PYG{p}{,}\PYG{l+m+mi}{32}\PYG{p}{,}\PYG{l+m+mi}{64}\PYG{p}{\PYGZcb{}}\PYG{p}{;}

\PYG{c+c1}{// Template class Row}
\PYG{k}{template}\PYG{o}{\PYGZlt{}}\PYG{k}{class} \PYG{n+nc}{T}\PYG{o}{\PYGZgt{}}
\PYG{k}{class} \PYG{n+nc}{Row} \PYG{p}{\PYGZob{}}
    \PYG{c+c1}{// private variables}
\PYG{k}{private}\PYG{o}{:}
    \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{numCols}\PYG{p}{;} \PYG{c+c1}{// stores the number of columns in the row}
    \PYG{n}{T}\PYG{o}{*} \PYG{n}{row}\PYG{p}{;} \PYG{c+c1}{// an array to store the row}

    \PYG{c+c1}{// public variables}
    \PYG{k}{public}\PYG{o}{:}

    \PYG{n}{Row}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{cols} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{o}{:}\PYG{n}{row}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{SetRowSize}\PYG{p}{(}\PYG{n}{cols}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{o}{\PYGZti{}}\PYG{n}{Row}\PYG{p}{(}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{delete}\PYG{p}{[}\PYG{p}{]} \PYG{n}{row}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{n}{Row}\PYG{p}{(}\PYG{k}{const} \PYG{n}{Row} \PYG{o}{\PYGZam{}}\PYG{n}{r}\PYG{p}{)}\PYG{o}{:}\PYG{n}{row}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{SetRowSize}\PYG{p}{(}\PYG{n}{r}\PYG{p}{.}\PYG{n}{numCols}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{int} \PYG{n}{i}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;}\PYG{n}{i}\PYG{o}{\PYGZlt{}}\PYG{n}{numCols}\PYG{p}{;}\PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{row}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{o}{=}\PYG{n}{r}\PYG{p}{.}\PYG{n}{row}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
    \PYG{p}{\PYGZcb{}}

    \PYG{c+c1}{// setter for row size}

    \PYG{k+kt}{void} \PYG{n}{SetRowSize}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{n}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{row}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{k}{delete}\PYG{p}{[}\PYG{p}{]} \PYG{n}{row}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{if} \PYG{p}{(}\PYG{n}{n}\PYG{o}{\PYGZgt{}}\PYG{l+m+mi}{0}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{row}\PYG{o}{=}\PYG{k}{new} \PYG{n}{T}\PYG{p}{[}\PYG{n}{n}\PYG{p}{]}\PYG{p}{;}
            \PYG{c+c1}{// FIX THIS LATER!!!!!  memset(row,0,sizeof(T)*n/sizeof(char));}
            \PYG{c+c1}{// The call to memset() just zeroes out the array after figuring out how many bytes the row uses and}
            \PYG{c+c1}{// dividing this by the size of character, because memset() works in terms of chars.}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{else}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{row}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{n}{numCols}\PYG{o}{=}\PYG{n}{n}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{k+kt}{void} \PYG{n}{changeSize}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{n}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{try}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{T}\PYG{o}{*} \PYG{n}{tmprow} \PYG{o}{=} \PYG{k}{new} \PYG{n}{T}\PYG{p}{[}\PYG{n}{n}\PYG{p}{]}\PYG{p}{;}
            \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;}\PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{numCols}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{n}{tmprow}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{=} \PYG{n}{row}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
            \PYG{k}{delete}\PYG{p}{[}\PYG{p}{]} \PYG{n}{row}\PYG{p}{;}
            \PYG{n}{row} \PYG{o}{=} \PYG{n}{tmprow}\PYG{p}{;}
    \PYG{c+c1}{//      tmprow = NULL;}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{catch}\PYG{p}{(}\PYG{n}{bad\PYGZus{}alloc} \PYG{o}{\PYGZam{}} \PYG{n}{ba}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{cerr} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{ba}\PYG{p}{.}\PYG{n}{what}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
            \PYG{n}{cerr} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{numCols: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{numCols} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
            \PYG{n}{cerr} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{n: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{n} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
            \PYG{n}{exit}\PYG{p}{(}\PYG{n}{EXIT\PYGZus{}FAILURE}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{n}{numCols} \PYG{o}{=} \PYG{n}{n}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{size}\PYG{p}{(}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{return} \PYG{n}{numCols}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{n}{T}\PYG{o}{\PYGZam{}} \PYG{k}{operator}\PYG{p}{[}\PYG{p}{]}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{column}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{c+c1}{// assert(column\PYGZlt{}numCols);}
        \PYG{c+c1}{// check we are within bounds}

      \PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ ifdef version1\PYGZus{}1}
        \PYG{k}{if} \PYG{p}{(}\PYG{n}{column} \PYG{o}{\PYGZgt{}}\PYG{o}{=} \PYG{n}{numCols}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{column} \PYG{o}{=} \PYG{n}{numCols} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{if} \PYG{p}{(}\PYG{n}{column} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{0}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{column} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
      \PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ endif}
      \PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ ifdef version1\PYGZus{}11}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{column} \PYG{o}{\PYGZlt{}}\PYG{l+m+mi}{0} \PYG{o}{\textbar{}}\PYG{o}{\textbar{}} \PYG{n}{column} \PYG{o}{\PYGZgt{}}\PYG{o}{=} \PYG{n}{numCols}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{string} \PYG{n}{err} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ERROR\PYGZus{}MAIN\PYGZus{}013b: Tried to call an indices that was out of range of the row. Check row size definition. numCols: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{+} \PYG{n}{to\PYGZus{}string}\PYG{p}{(}\PYG{p}{(}\PYG{k+kt}{long} \PYG{k+kt}{long}\PYG{p}{)} \PYG{n}{numCols}\PYG{p}{)} \PYG{o}{+} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ index: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{+} \PYG{n}{to\PYGZus{}string}\PYG{p}{(}\PYG{p}{(}\PYG{k+kt}{long} \PYG{k+kt}{long}\PYG{p}{)} \PYG{n}{column}\PYG{p}{)}\PYG{p}{;}
            \PYG{k}{throw} \PYG{n+nf}{out\PYGZus{}of\PYGZus{}range}\PYG{p}{(}\PYG{n}{err}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
\PYG{c+c1}{//      if (column \PYGZlt{} 0)}
\PYG{c+c1}{//        \PYGZob{}}
\PYG{c+c1}{//          column = \PYGZhy{}1 * column;}
\PYG{c+c1}{//          column = column \PYGZpc{} numCols;}
\PYG{c+c1}{//          column = numCols \PYGZhy{} column;}
\PYG{c+c1}{//        \PYGZcb{}}
        \PYG{n}{column} \PYG{o}{=} \PYG{n}{column} \PYG{o}{\PYGZpc{}} \PYG{n}{numCols}\PYG{p}{;}
      \PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ endif}

        \PYG{k}{return} \PYG{n}{row}\PYG{p}{[}\PYG{n}{column}\PYG{p}{]}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{c+c1}{// Overloading = operator}
    \PYG{n}{Row}\PYG{o}{\PYGZam{}}  \PYG{k}{operator}\PYG{o}{=}\PYG{p}{(}\PYG{k}{const} \PYG{n}{Row}\PYG{o}{\PYGZam{}} \PYG{n}{r}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{SetRowSize}\PYG{p}{(}\PYG{n}{r}\PYG{p}{.}\PYG{n}{numCols}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{int} \PYG{n}{i}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;}\PYG{n}{i}\PYG{o}{\PYGZlt{}}\PYG{n}{numCols}\PYG{p}{;}\PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{row}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{o}{=}\PYG{n}{r}\PYG{p}{.}\PYG{n}{row}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}

        \PYG{c+c1}{//we return a reference, but this time it\PYGZsq{}s a reference to itself.}
        \PYG{c+c1}{//First we set the size of the current row equal to that of the source row, then we copy its values.}
        \PYG{c+c1}{//There is an important note here. Notice that I\PYGZsq{}m using [] on the primitive T array itself}
        \PYG{c+c1}{//\PYGZhy{}\PYGZhy{}NOT the overloaded []s of Row. Remember that Row\PYGZsq{}s [] returns a reference, thus if we had written row[i]=r[i],}
        \PYG{c+c1}{//we would get a row that references the exact same data in memory, so that when we changed one the other would change}
        \PYG{c+c1}{//\PYGZhy{}\PYGZhy{}this isn\PYGZsq{}t what we want at all, so we need to access the raw data in the Row class.}

        \PYG{k}{return} \PYG{o}{*}\PYG{k}{this}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{k}{friend} \PYG{n}{ostream}\PYG{o}{\PYGZam{}} \PYG{k}{operator}\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{p}{(}\PYG{n}{ostream}\PYG{o}{\PYGZam{}} \PYG{n}{os}\PYG{p}{,}\PYG{k}{const} \PYG{n}{Row}\PYG{o}{\PYGZam{}} \PYG{n}{r}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{c+c1}{//os \PYGZlt{}\PYGZlt{} m.numRows\PYGZlt{}\PYGZlt{}\PYGZdq{} , \PYGZdq{}\PYGZlt{}\PYGZlt{}m.numCols\PYGZlt{}\PYGZlt{}\PYGZdq{} , \PYGZdq{}\PYGZlt{}\PYGZlt{}endl;}
        \PYG{n}{os} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{r}\PYG{p}{.}\PYG{n}{numCols} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{,}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
        \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{int} \PYG{n}{c}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;}\PYG{n}{c}\PYG{o}{\PYGZlt{}}\PYG{n}{r}\PYG{p}{.}\PYG{n}{numCols}\PYG{p}{;}\PYG{n}{c}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{n}{os} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{r}\PYG{p}{.}\PYG{n}{row}\PYG{p}{[}\PYG{n}{c}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{,}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
        \PYG{k}{return} \PYG{n}{os}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{k}{friend} \PYG{n}{istream}\PYG{o}{\PYGZam{}} \PYG{k}{operator}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{n}{istream}\PYG{o}{\PYGZam{}} \PYG{n}{is}\PYG{p}{,} \PYG{n}{Row}\PYG{o}{\PYGZam{}} \PYG{n}{r}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{c+c1}{//os \PYGZlt{}\PYGZlt{} m.numRows\PYGZlt{}\PYGZlt{}\PYGZdq{} , \PYGZdq{}\PYGZlt{}\PYGZlt{}m.numCols\PYGZlt{}\PYGZlt{}\PYGZdq{} , \PYGZdq{}\PYGZlt{}\PYGZlt{}endl;}
        \PYG{k+kt}{char} \PYG{n}{delim}\PYG{p}{;}
        \PYG{k+kt}{int} \PYG{n}{n}\PYG{p}{;}
        \PYG{n}{is} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{n}\PYG{p}{;}
        \PYG{n}{r}\PYG{p}{.}\PYG{n}{SetRowSize}\PYG{p}{(}\PYG{n}{n}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{is} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{delim}\PYG{p}{;}
        \PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{int} \PYG{n}{c}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;}\PYG{n}{c}\PYG{o}{\PYGZlt{}}\PYG{n}{r}\PYG{p}{.}\PYG{n}{numCols}\PYG{p}{;}\PYG{n}{c}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{n}{is} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{r}\PYG{p}{.}\PYG{n}{row}\PYG{p}{[}\PYG{n}{c}\PYG{p}{]}\PYG{p}{;}
                \PYG{n}{is} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{delim}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
        \PYG{k}{return} \PYG{n}{is}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}


\PYG{c+c1}{// Template class Matrix as an array of rows}
\PYG{k}{template}\PYG{o}{\PYGZlt{}}\PYG{k}{class} \PYG{n+nc}{T}\PYG{o}{\PYGZgt{}}
\PYG{k}{class} \PYG{n+nc}{Matrix} \PYG{p}{\PYGZob{}}

\PYG{k}{protected}\PYG{o}{:}

    \PYG{c+c1}{// number of rows and columns}
    \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{numCols}\PYG{p}{,} \PYG{n}{numRows}\PYG{p}{;}
    \PYG{c+c1}{// a matrix is an array of rows}
    \PYG{n}{Row}\PYG{o}{\PYGZlt{}}\PYG{n}{T}\PYG{o}{\PYGZgt{}}\PYG{o}{*} \PYG{n}{matrix}\PYG{p}{;}

\PYG{k}{public}\PYG{o}{:}

    \PYG{n}{Matrix}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{rows}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{k+kt}{int} \PYG{n}{cols}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{o}{:} \PYG{n}{matrix}\PYG{p}{(}\PYG{n}{null}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{SetSize}\PYG{p}{(}\PYG{n}{rows}\PYG{p}{,}\PYG{n}{cols}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{n}{Matrix}\PYG{p}{(}\PYG{k}{const} \PYG{n}{Matrix}\PYG{o}{\PYGZam{}} \PYG{n}{m}\PYG{p}{)}\PYG{o}{:} \PYG{n}{matrix}\PYG{p}{(}\PYG{n}{null}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{SetSize}\PYG{p}{(}\PYG{n}{m}\PYG{p}{.}\PYG{n}{numRows}\PYG{p}{,}\PYG{n}{m}\PYG{p}{.}\PYG{n}{numCols}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{r}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;}\PYG{n}{r}\PYG{o}{\PYGZlt{}}\PYG{n}{numRows}\PYG{p}{;}\PYG{n}{r}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
        \PYG{n}{matrix}\PYG{p}{[}\PYG{n}{r}\PYG{p}{]}\PYG{o}{=}\PYG{n}{Row}\PYG{o}{\PYGZlt{}}\PYG{n}{T}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{n}{m}\PYG{p}{.}\PYG{n}{matrix}\PYG{p}{[}\PYG{n}{r}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}\PYG{c+c1}{//assign to primitive array, NOT overloaded []\PYGZhy{}\PYGZhy{}to get a copy}
    \PYG{p}{\PYGZcb{}}

    \PYG{c+c1}{// HAD TO FIX NASTY MEMEORY LEAK HERE SINCE DOWLOADING!!}
    \PYG{o}{\PYGZti{}}\PYG{n}{Matrix}\PYG{p}{(}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{delete}\PYG{p}{[}\PYG{p}{]} \PYG{n}{matrix}\PYG{p}{;}

    \PYG{p}{\PYGZcb{}}

    \PYG{k+kt}{void} \PYG{n}{SetSize}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{rows}\PYG{p}{,} \PYG{k+kt}{int} \PYG{n}{cols}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{if} \PYG{p}{(}\PYG{n}{matrix}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{k}{delete}\PYG{p}{[}\PYG{p}{]}\PYG{n}{matrix}\PYG{p}{;}
            \PYG{c+c1}{//if (rows) delete[]matrix; \PYGZhy{} was in original code \PYGZhy{} seems silly so changed to the above}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{if} \PYG{p}{(}\PYG{n}{cols} \PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{0} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{n}{rows} \PYG{o}{\PYGZgt{}}\PYG{l+m+mi}{0}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{matrix}\PYG{o}{=}\PYG{k}{new} \PYG{n}{Row}\PYG{o}{\PYGZlt{}}\PYG{n}{T}\PYG{o}{\PYGZgt{}}\PYG{p}{[}\PYG{n}{rows}\PYG{p}{]}\PYG{p}{;}
            \PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;}\PYG{n}{i}\PYG{o}{\PYGZlt{}}\PYG{n}{rows}\PYG{p}{;}\PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{n}{matrix}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{SetRowSize}\PYG{p}{(}\PYG{n}{cols}\PYG{p}{)}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{else}
        \PYG{p}{\PYGZob{}}
        \PYG{n}{rows}\PYG{o}{=}\PYG{n}{null}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{n}{numCols}\PYG{o}{=}\PYG{n}{cols}\PYG{p}{;}
        \PYG{n}{numRows}\PYG{o}{=}\PYG{n}{rows}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{k+kt}{int} \PYG{n}{GetCols}\PYG{p}{(}\PYG{p}{)} \PYG{k}{const}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{return} \PYG{n}{numCols}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{k+kt}{int} \PYG{n}{GetRows}\PYG{p}{(}\PYG{p}{)}  \PYG{k}{const}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{return} \PYG{n}{numRows}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{c+c1}{// This whole piece so far follows similarly to that of the Row Class}
    \PYG{c+c1}{// now we go on to overload all the operators}

    \PYG{n}{Row}\PYG{o}{\PYGZlt{}}\PYG{n}{T}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZam{}} \PYG{k}{operator}\PYG{p}{[}\PYG{p}{]}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{index}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}

        \PYG{c+c1}{//assert(index\PYGZlt{}numRows);}
         \PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ ifdef version1\PYGZus{}1}
        \PYG{k}{if} \PYG{p}{(}\PYG{n}{index} \PYG{o}{\PYGZgt{}}\PYG{o}{=} \PYG{n}{numRows}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{index} \PYG{o}{=} \PYG{n}{numRows} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{if} \PYG{p}{(}\PYG{n}{index} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{0}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{index} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ endif}
    \PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ ifdef version1\PYGZus{}11}
\PYG{c+c1}{//      if (index \PYGZlt{} 0)}
\PYG{c+c1}{//      \PYGZob{}}
\PYG{c+c1}{//              index = \PYGZhy{}1 * index;}
\PYG{c+c1}{//              index = index \PYGZpc{} numRows;}
\PYG{c+c1}{//              index = numRows \PYGZhy{} index;}
\PYG{c+c1}{//      \PYGZcb{}}
\PYG{c+c1}{//      These asserts were lazy \PYGZhy{} changed to exceptions and proper error reporting now.}
\PYG{c+c1}{//      assert(index\PYGZlt{}numRows \PYGZam{}\PYGZam{} \PYGZdq{}out of range \PYGZhy{} index greater than the number of rows\PYGZdq{});}
\PYG{c+c1}{//      assert(index\PYGZgt{}=0 \PYGZam{}\PYGZam{} \PYGZdq{}out of range \PYGZhy{} index less than 0\PYGZdq{});}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{index} \PYG{o}{\PYGZlt{}}\PYG{l+m+mi}{0} \PYG{o}{\textbar{}}\PYG{o}{\textbar{}} \PYG{n}{index} \PYG{o}{\PYGZgt{}}\PYG{o}{=} \PYG{n}{numRows}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{string} \PYG{n}{err} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ERROR\PYGZus{}MAIN\PYGZus{}013: Tried to call an indices that was out of range of the matrix. Check matrix size definition. numRows: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{+} \PYG{n}{to\PYGZus{}string}\PYG{p}{(}\PYG{p}{(}\PYG{k+kt}{long} \PYG{k+kt}{long}\PYG{p}{)} \PYG{n}{numRows}\PYG{p}{)} \PYG{o}{+} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ index: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{+} \PYG{n}{to\PYGZus{}string}\PYG{p}{(}\PYG{p}{(}\PYG{k+kt}{long} \PYG{k+kt}{long}\PYG{p}{)} \PYG{n}{index}\PYG{p}{)}\PYG{p}{;}
            \PYG{k}{throw} \PYG{n+nf}{out\PYGZus{}of\PYGZus{}range}\PYG{p}{(}\PYG{n}{err}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{n}{index} \PYG{o}{=} \PYG{n}{index} \PYG{o}{\PYGZpc{}} \PYG{n}{numRows}\PYG{p}{;}
        \PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ endif}

        \PYG{k}{return} \PYG{n}{matrix}\PYG{p}{[}\PYG{n}{index}\PYG{p}{]}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{n}{Matrix}\PYG{o}{\PYGZam{}} \PYG{k}{operator}\PYG{o}{=}\PYG{p}{(}\PYG{k}{const} \PYG{n}{Matrix}\PYG{o}{\PYGZam{}} \PYG{n}{m}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{SetSize}\PYG{p}{(}\PYG{n}{m}\PYG{p}{.}\PYG{n}{numRows}\PYG{p}{,}\PYG{n}{m}\PYG{p}{.}\PYG{n}{numCols}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{r}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;}\PYG{n}{r}\PYG{o}{\PYGZlt{}}\PYG{n}{numRows}\PYG{p}{;}\PYG{n}{r}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{matrix}\PYG{p}{[}\PYG{n}{r}\PYG{p}{]}\PYG{o}{=}\PYG{n}{Row}\PYG{o}{\PYGZlt{}}\PYG{n}{T}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{n}{m}\PYG{p}{.}\PYG{n}{matrix}\PYG{p}{[}\PYG{n}{r}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
            \PYG{c+c1}{//assign to primitive array, NOT overloaded []\PYGZhy{}\PYGZhy{}to get a copy}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{return} \PYG{o}{*}\PYG{k}{this}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}


    \PYG{k}{const} \PYG{n}{Matrix} \PYG{k}{operator}\PYG{o}{+}\PYG{p}{(} \PYG{k}{const} \PYG{n}{Matrix}\PYG{o}{\PYGZam{}} \PYG{n}{m}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{c+c1}{//Since addition creates a new matrix, we don\PYGZsq{}t want to return a reference, but an actual matrix object.}

        \PYG{c+c1}{//assert(numCols==m.numCols \PYGZam{}\PYGZam{} numRows==m.numRows);}
        \PYG{k+kt}{int} \PYG{n}{newnumcols} \PYG{p}{,} \PYG{n}{newnumrows} \PYG{p}{;}
        \PYG{k}{if} \PYG{p}{(}\PYG{n}{numCols} \PYG{o}{\PYGZgt{}} \PYG{n}{m}\PYG{p}{.}\PYG{n}{numCols}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{newnumcols} \PYG{o}{=} \PYG{n}{m}\PYG{p}{.}\PYG{n}{numCols}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{else}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{newnumcols} \PYG{o}{=} \PYG{n}{numCols}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{if} \PYG{p}{(}\PYG{n}{numRows} \PYG{o}{\PYGZgt{}} \PYG{n}{m}\PYG{p}{.}\PYG{n}{numRows}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{newnumrows} \PYG{o}{=} \PYG{n}{m}\PYG{p}{.}\PYG{n}{numRows}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{else}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{newnumrows} \PYG{o}{=} \PYG{n}{numRows}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}

        \PYG{n}{Matrix} \PYG{n}{result}\PYG{p}{(}\PYG{n}{newnumrows}\PYG{p}{,}\PYG{n}{newnumcols}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{r}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;}\PYG{n}{r}\PYG{o}{\PYGZlt{}}\PYG{n}{newnumrows}\PYG{p}{;}\PYG{n}{r}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{c}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;}\PYG{n}{c}\PYG{o}{\PYGZlt{}}\PYG{n}{newnumcols}\PYG{p}{;}\PYG{n}{c}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{n}{result}\PYG{p}{[}\PYG{n}{r}\PYG{p}{]}\PYG{p}{[}\PYG{n}{c}\PYG{p}{]}\PYG{o}{=}\PYG{n}{matrix}\PYG{p}{[}\PYG{n}{r}\PYG{p}{]}\PYG{p}{[}\PYG{n}{c}\PYG{p}{]}\PYG{o}{+}\PYG{n}{m}\PYG{p}{.}\PYG{n}{matrix}\PYG{p}{[}\PYG{n}{r}\PYG{p}{]}\PYG{p}{[}\PYG{n}{c}\PYG{p}{]}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{return} \PYG{n}{result}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{k}{const} \PYG{n}{Matrix} \PYG{k}{operator}\PYG{o}{\PYGZhy{}}\PYG{p}{(} \PYG{k}{const} \PYG{n}{Matrix}\PYG{o}{\PYGZam{}} \PYG{n}{m}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}

        \PYG{c+c1}{//assert(numCols==m.numCols \PYGZam{}\PYGZam{} numRows==m.numRows);}
        \PYG{k+kt}{int} \PYG{n}{newnumcols} \PYG{p}{,} \PYG{n}{newnumrows} \PYG{p}{;}
        \PYG{k}{if} \PYG{p}{(}\PYG{n}{numCols} \PYG{o}{\PYGZgt{}} \PYG{n}{m}\PYG{p}{.}\PYG{n}{numCols}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{newnumcols} \PYG{o}{=} \PYG{n}{m}\PYG{p}{.}\PYG{n}{numCols}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{else}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{newnumcols} \PYG{o}{=} \PYG{n}{numCols}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{if} \PYG{p}{(}\PYG{n}{numRows} \PYG{o}{\PYGZgt{}} \PYG{n}{m}\PYG{p}{.}\PYG{n}{numRows}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{newnumrows} \PYG{o}{=} \PYG{n}{m}\PYG{p}{.}\PYG{n}{numRows}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{else}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{newnumrows} \PYG{o}{=} \PYG{n}{numRows}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}

        \PYG{n}{Matrix} \PYG{n}{result}\PYG{p}{(}\PYG{n}{newnumrows}\PYG{p}{,}\PYG{n}{newnumcols}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{r}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;}\PYG{n}{r}\PYG{o}{\PYGZlt{}}\PYG{n}{newnumrows}\PYG{p}{;}\PYG{n}{r}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{c}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;}\PYG{n}{c}\PYG{o}{\PYGZlt{}}\PYG{n}{newnumcols}\PYG{p}{;}\PYG{n}{c}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{n}{result}\PYG{p}{[}\PYG{n}{r}\PYG{p}{]}\PYG{p}{[}\PYG{n}{c}\PYG{p}{]}\PYG{o}{=}\PYG{n}{matrix}\PYG{p}{[}\PYG{n}{r}\PYG{p}{]}\PYG{p}{[}\PYG{n}{c}\PYG{p}{]}\PYG{o}{\PYGZhy{}}\PYG{n}{m}\PYG{p}{.}\PYG{n}{matrix}\PYG{p}{[}\PYG{n}{r}\PYG{p}{]}\PYG{p}{[}\PYG{n}{c}\PYG{p}{]}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{return} \PYG{n}{result}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{n}{Matrix}\PYG{o}{\PYGZam{}} \PYG{k}{operator}\PYG{o}{+}\PYG{o}{=}\PYG{p}{(}\PYG{k}{const} \PYG{n}{Matrix}\PYG{o}{\PYGZam{}} \PYG{n}{m}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{c+c1}{// don\PYGZsq{}t want to create a new object}
        \PYG{c+c1}{// just add whatever is currently in it to the other matrix, and return a reference to itself:}

        \PYG{c+c1}{//assert(numCols==m.numCols \PYGZam{}\PYGZam{} numRows==m.numRows);}
        \PYG{k+kt}{int} \PYG{n}{newnumcols} \PYG{p}{,} \PYG{n}{newnumrows} \PYG{p}{;}
        \PYG{k}{if} \PYG{p}{(}\PYG{n}{numCols} \PYG{o}{\PYGZgt{}} \PYG{n}{m}\PYG{p}{.}\PYG{n}{numCols}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{newnumcols} \PYG{o}{=} \PYG{n}{m}\PYG{p}{.}\PYG{n}{numCols}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{else}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{newnumcols} \PYG{o}{=} \PYG{n}{numCols}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{if} \PYG{p}{(}\PYG{n}{numRows} \PYG{o}{\PYGZgt{}} \PYG{n}{m}\PYG{p}{.}\PYG{n}{numRows}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{newnumrows} \PYG{o}{=} \PYG{n}{m}\PYG{p}{.}\PYG{n}{numRows}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{else}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{newnumrows} \PYG{o}{=} \PYG{n}{numRows}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}

        \PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{r}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;}\PYG{n}{r}\PYG{o}{\PYGZlt{}}\PYG{n}{newnumrows}\PYG{p}{;}\PYG{n}{r}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{c}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;}\PYG{n}{c}\PYG{o}{\PYGZlt{}}\PYG{n}{newnumcols}\PYG{p}{;}\PYG{n}{c}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{n}{matrix}\PYG{p}{[}\PYG{n}{r}\PYG{p}{]}\PYG{p}{[}\PYG{n}{c}\PYG{p}{]}\PYG{o}{+}\PYG{o}{=}\PYG{n}{m}\PYG{p}{.}\PYG{n}{matrix}\PYG{p}{[}\PYG{n}{r}\PYG{p}{]}\PYG{p}{[}\PYG{n}{c}\PYG{p}{]}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{return} \PYG{o}{*}\PYG{k}{this}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}


    \PYG{n}{Matrix}\PYG{o}{\PYGZam{}} \PYG{k}{operator}\PYG{o}{\PYGZhy{}}\PYG{o}{=}\PYG{p}{(} \PYG{k}{const} \PYG{n}{Matrix}\PYG{o}{\PYGZam{}} \PYG{n}{m}\PYG{p}{)} \PYG{p}{\PYGZob{}}
        \PYG{c+c1}{// don\PYGZsq{}t want to create a new object}
        \PYG{c+c1}{// just subtractthe other matrix from whatever is currently in it, and return a reference to itself:}

        \PYG{c+c1}{//assert(numCols==m.numCols \PYGZam{}\PYGZam{} numRows==m.numRows);}
        \PYG{k+kt}{int} \PYG{n}{newnumcols} \PYG{p}{,} \PYG{n}{newnumrows} \PYG{p}{;}
        \PYG{k}{if} \PYG{p}{(}\PYG{n}{numCols} \PYG{o}{\PYGZgt{}} \PYG{n}{m}\PYG{p}{.}\PYG{n}{numCols}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{newnumcols} \PYG{o}{=} \PYG{n}{m}\PYG{p}{.}\PYG{n}{numCols}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{else}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{newnumcols} \PYG{o}{=} \PYG{n}{numCols}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{if} \PYG{p}{(}\PYG{n}{numRows} \PYG{o}{\PYGZgt{}} \PYG{n}{m}\PYG{p}{.}\PYG{n}{numRows}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{newnumrows} \PYG{o}{=} \PYG{n}{m}\PYG{p}{.}\PYG{n}{numRows}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{else}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{newnumrows} \PYG{o}{=} \PYG{n}{numRows}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}

        \PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{r}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;}\PYG{n}{r}\PYG{o}{\PYGZlt{}}\PYG{n}{newnumrows}\PYG{p}{;}\PYG{n}{r}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{c}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;}\PYG{n}{c}\PYG{o}{\PYGZlt{}}\PYG{n}{newnumcols}\PYG{p}{;}\PYG{n}{c}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{n}{matrix}\PYG{p}{[}\PYG{n}{r}\PYG{p}{]}\PYG{p}{[}\PYG{n}{c}\PYG{p}{]}\PYG{o}{\PYGZhy{}}\PYG{o}{=}\PYG{n}{m}\PYG{p}{.}\PYG{n}{matrix}\PYG{p}{[}\PYG{n}{r}\PYG{p}{]}\PYG{p}{[}\PYG{n}{c}\PYG{p}{]}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{return} \PYG{o}{*}\PYG{k}{this}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{k}{const} \PYG{n}{Matrix} \PYG{k}{operator}\PYG{o}{*}\PYG{p}{(}\PYG{k}{const} \PYG{k+kt}{double} \PYG{n}{s}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{Matrix} \PYG{n}{result}\PYG{p}{(}\PYG{n}{numRows}\PYG{p}{,}\PYG{n}{numCols}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{r}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;}\PYG{n}{r}\PYG{o}{\PYGZlt{}}\PYG{n}{numRows}\PYG{p}{;}\PYG{n}{r}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{c}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;}\PYG{n}{c}\PYG{o}{\PYGZlt{}}\PYG{n}{numCols}\PYG{p}{;}\PYG{n}{c}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{n}{result}\PYG{p}{[}\PYG{n}{r}\PYG{p}{]}\PYG{p}{[}\PYG{n}{c}\PYG{p}{]}\PYG{o}{=}\PYG{n}{matrix}\PYG{p}{[}\PYG{n}{r}\PYG{p}{]}\PYG{p}{[}\PYG{n}{c}\PYG{p}{]}\PYG{o}{*}\PYG{n}{s}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{return} \PYG{n}{result}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

        \PYG{k}{const} \PYG{n}{Matrix} \PYG{k}{operator}\PYG{o}{*}\PYG{p}{(}\PYG{n}{Matrix}\PYG{o}{\PYGZam{}} \PYG{n}{m}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{c+c1}{//assert(numCols==m.numRows);}
        \PYG{k+kt}{int} \PYG{n}{newnumcols}\PYG{p}{;}
        \PYG{k}{if} \PYG{p}{(}\PYG{n}{numCols} \PYG{o}{\PYGZgt{}} \PYG{n}{m}\PYG{p}{.}\PYG{n}{numRows}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{newnumcols} \PYG{o}{=} \PYG{n}{m}\PYG{p}{.}\PYG{n}{numRows}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{else}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{newnumcols} \PYG{o}{=} \PYG{n}{numCols}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}

        \PYG{n}{Matrix} \PYG{n}{result}\PYG{p}{(}\PYG{n}{numRows}\PYG{p}{,}\PYG{n}{m}\PYG{p}{.}\PYG{n}{numCols}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{r}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;}\PYG{n}{r}\PYG{o}{\PYGZlt{}}\PYG{n}{numRows}\PYG{p}{;}\PYG{n}{r}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{c}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;}\PYG{n}{c}\PYG{o}{\PYGZlt{}}\PYG{n}{m}\PYG{p}{.}\PYG{n}{numCols}\PYG{p}{;}\PYG{n}{c}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;}\PYG{n}{i}\PYG{o}{\PYGZlt{}}\PYG{n}{newnumcols}\PYG{p}{;}\PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
                \PYG{p}{\PYGZob{}}
                    \PYG{n}{result}\PYG{p}{[}\PYG{n}{r}\PYG{p}{]}\PYG{p}{[}\PYG{n}{c}\PYG{p}{]}\PYG{o}{+}\PYG{o}{=}\PYG{n}{matrix}\PYG{p}{[}\PYG{n}{r}\PYG{p}{]}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{o}{*}\PYG{n}{m}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{[}\PYG{n}{c}\PYG{p}{]}\PYG{p}{;}
                \PYG{p}{\PYGZcb{}}
            \PYG{p}{\PYGZcb{}}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{return} \PYG{n}{result}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}


    \PYG{c+c1}{// The streaming operators \PYGZlt{}\PYGZlt{} and \PYGZgt{}\PYGZgt{} allow your object to be saved and restored from any}
    \PYG{c+c1}{// stream, be it console, network, or file.}
    \PYG{c+c1}{// There is a slight additional challenge with these operators because we must allow the stream access to our object\PYGZsq{}s private data.}
    \PYG{c+c1}{// Therefore, these functions must be declared as friends inside the Matrix class.}

    \PYG{k}{friend} \PYG{n}{ostream}\PYG{o}{\PYGZam{}} \PYG{k}{operator}\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{p}{(}\PYG{n}{ostream}\PYG{o}{\PYGZam{}} \PYG{n}{os}\PYG{p}{,}\PYG{k}{const} \PYG{n}{Matrix}\PYG{o}{\PYGZam{}} \PYG{n}{m}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
      \PYG{c+c1}{//os \PYGZlt{}\PYGZlt{} m.numRows\PYGZlt{}\PYGZlt{}\PYGZdq{} , \PYGZdq{}\PYGZlt{}\PYGZlt{}m.numCols\PYGZlt{}\PYGZlt{}\PYGZdq{} , \PYGZdq{}\PYGZlt{}\PYGZlt{}endl;}
        \PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{r}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;}\PYG{n}{r}\PYG{o}{\PYGZlt{}}\PYG{n}{m}\PYG{p}{.}\PYG{n}{numRows}\PYG{p}{;}\PYG{n}{r}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{c}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;}\PYG{n}{c}\PYG{o}{\PYGZlt{}}\PYG{n}{m}\PYG{p}{.}\PYG{n}{numCols}\PYG{p}{;}\PYG{n}{c}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{n}{os} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{m}\PYG{p}{.}\PYG{n}{matrix}\PYG{p}{[}\PYG{n}{r}\PYG{p}{]}\PYG{p}{[}\PYG{n}{c}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{,}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
            \PYG{n}{os} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{return} \PYG{n}{os}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{k}{friend} \PYG{n}{istream}\PYG{o}{\PYGZam{}} \PYG{k}{operator}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{n}{istream}\PYG{o}{\PYGZam{}} \PYG{n}{is}\PYG{p}{,} \PYG{n}{Matrix}\PYG{o}{\PYGZam{}} \PYG{n}{m}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{c+c1}{//is \PYGZlt{}\PYGZlt{} m.numRows\PYGZlt{}\PYGZlt{}\PYGZdq{} , \PYGZdq{}\PYGZlt{}\PYGZlt{}m.numCols\PYGZlt{}\PYGZlt{}\PYGZdq{} , \PYGZdq{}\PYGZlt{}\PYGZlt{}endl;}
        \PYG{k+kt}{char} \PYG{n}{delim}\PYG{p}{;}
        \PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{r}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;}\PYG{n}{r}\PYG{o}{\PYGZlt{}}\PYG{n}{m}\PYG{p}{.}\PYG{n}{numRows}\PYG{p}{;}\PYG{n}{r}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
\PYG{c+c1}{//          string line;}
\PYG{c+c1}{//          getline(is, line);}
\PYG{c+c1}{//          if ( !is.good() )}
\PYG{c+c1}{//          \PYGZob{}}
\PYG{c+c1}{//              break;}
\PYG{c+c1}{//          \PYGZcb{}}
\PYG{c+c1}{//          stringstream iss(line);}
\PYG{c+c1}{//}
\PYG{c+c1}{//          for (int c = 0; c \PYGZlt{} m.numRows; c++)}
\PYG{c+c1}{//          \PYGZob{}}
\PYG{c+c1}{//              std::string val;}
\PYG{c+c1}{//              std::getline(iss, val, \PYGZsq{},\PYGZsq{});}
\PYG{c+c1}{//              if ( !iss.good() )}
\PYG{c+c1}{//                  break;}
\PYG{c+c1}{//}
\PYG{c+c1}{//              std::stringstream convertor(val);}
\PYG{c+c1}{//              convertor \PYGZgt{}\PYGZgt{} m.matrix[r][c];}
\PYG{c+c1}{//          \PYGZcb{}}
            \PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{c}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;}\PYG{n}{c}\PYG{o}{\PYGZlt{}}\PYG{n}{m}\PYG{p}{.}\PYG{n}{numCols}\PYG{p}{;}\PYG{n}{c}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{n}{is} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{m}\PYG{p}{.}\PYG{n}{matrix}\PYG{p}{[}\PYG{n}{r}\PYG{p}{]}\PYG{p}{[}\PYG{n}{c}\PYG{p}{]}\PYG{p}{;}
                \PYG{n}{is} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{delim}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{return} \PYG{n}{is}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{k+kt}{bool} \PYG{n}{symmetric}\PYG{p}{(}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k+kt}{bool} \PYG{n}{result} \PYG{o}{=} \PYG{n+nb}{true}\PYG{p}{;}
        \PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{c}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;}\PYG{n}{c}\PYG{o}{\PYGZlt{}}\PYG{n}{numCols}\PYG{p}{;}\PYG{n}{c}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{r}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;}\PYG{n}{r}\PYG{o}{\PYGZlt{}}\PYG{n}{c}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{;}\PYG{n}{r}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{k}{if} \PYG{p}{(}\PYG{n}{matrix}\PYG{p}{[}\PYG{n}{r}\PYG{p}{]}\PYG{p}{[}\PYG{n}{c}\PYG{p}{]} \PYG{o}{!}\PYG{o}{=} \PYG{n}{matrix}\PYG{p}{[}\PYG{n}{c}\PYG{p}{]}\PYG{p}{[}\PYG{n}{r}\PYG{p}{]}\PYG{p}{)}
                \PYG{p}{\PYGZob{}}
                    \PYG{n}{result} \PYG{o}{=} \PYG{n+nb}{false}\PYG{p}{;}
                    \PYG{k}{break}\PYG{p}{;}
                \PYG{p}{\PYGZcb{}}
            \PYG{p}{\PYGZcb{}}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{return} \PYG{n}{result}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{k+kt}{void} \PYG{n}{setValue}\PYG{p}{(}\PYG{k}{const} \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{x}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{y}\PYG{p}{,} \PYG{k+kt}{char}\PYG{o}{*} \PYG{n}{value}\PYG{p}{,}\PYG{k}{const} \PYG{k+kt}{double} \PYG{o}{\PYGZam{}} \PYG{n}{t}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{matrix}\PYG{p}{[}\PYG{n}{y}\PYG{p}{]}\PYG{p}{[}\PYG{n}{x}\PYG{p}{]} \PYG{o}{=} \PYG{n}{atof}\PYG{p}{(}\PYG{n}{value}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{return}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{k+kt}{void} \PYG{n}{setValue}\PYG{p}{(}\PYG{k}{const} \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{x}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{y}\PYG{p}{,} \PYG{k+kt}{char}\PYG{o}{*} \PYG{n}{value}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{char} \PYG{o}{\PYGZam{}} \PYG{n}{t}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{matrix}\PYG{p}{[}\PYG{n}{y}\PYG{p}{]}\PYG{p}{[}\PYG{n}{x}\PYG{p}{]} \PYG{o}{=} \PYG{o}{*}\PYG{n}{value}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{k+kt}{void} \PYG{n}{setValue}\PYG{p}{(}\PYG{k}{const} \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{x}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{y}\PYG{p}{,} \PYG{k+kt}{char}\PYG{o}{*} \PYG{n}{value}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{int8\PYGZus{}t} \PYG{o}{\PYGZam{}} \PYG{n}{t}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{matrix}\PYG{p}{[}\PYG{n}{y}\PYG{p}{]}\PYG{p}{[}\PYG{n}{x}\PYG{p}{]} \PYG{o}{=} \PYG{o}{*}\PYG{n}{value}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{k+kt}{void} \PYG{n}{setValue}\PYG{p}{(}\PYG{k}{const} \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{x}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{y}\PYG{p}{,} \PYG{k+kt}{char}\PYG{o}{*} \PYG{n}{value}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{uint8\PYGZus{}t} \PYG{o}{\PYGZam{}} \PYG{n}{t}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{matrix}\PYG{p}{[}\PYG{n}{y}\PYG{p}{]}\PYG{p}{[}\PYG{n}{x}\PYG{p}{]} \PYG{o}{=} \PYG{o}{*}\PYG{n}{value}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{k+kt}{void} \PYG{n}{setValue}\PYG{p}{(}\PYG{k}{const} \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{x}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{y}\PYG{p}{,} \PYG{k+kt}{char}\PYG{o}{*} \PYG{n}{value}\PYG{p}{,}\PYG{k}{const} \PYG{k+kt}{bool} \PYG{o}{\PYGZam{}} \PYG{n}{t}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{matrix}\PYG{p}{[}\PYG{n}{y}\PYG{p}{]}\PYG{p}{[}\PYG{n}{x}\PYG{p}{]} \PYG{o}{=} \PYG{k+kt}{bool}\PYG{p}{(}\PYG{n}{atoi}\PYG{p}{(}\PYG{n}{value}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{return}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{k+kt}{void} \PYG{n}{setValue}\PYG{p}{(}\PYG{k}{const} \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{x}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{y}\PYG{p}{,} \PYG{k+kt}{char}\PYG{o}{*} \PYG{n}{value}\PYG{p}{,}\PYG{k}{const} \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{t}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{matrix}\PYG{p}{[}\PYG{n}{y}\PYG{p}{]}\PYG{p}{[}\PYG{n}{x}\PYG{p}{]} \PYG{o}{=} \PYG{k+kt}{long}\PYG{p}{(}\PYG{n}{value}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{return}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{k+kt}{void} \PYG{n}{setValue}\PYG{p}{(}\PYG{k}{const} \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{x}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{y}\PYG{p}{,} \PYG{k+kt}{char} \PYG{o}{*} \PYG{n}{value}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{t}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{matrix}\PYG{p}{[}\PYG{n}{y}\PYG{p}{]}\PYG{p}{[}\PYG{n}{x}\PYG{p}{]} \PYG{o}{=} \PYG{k+kt}{long}\PYG{p}{(}\PYG{n}{value}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{return}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

     \PYG{k+kt}{void} \PYG{n}{import}\PYG{p}{(}\PYG{n}{string} \PYG{n}{filename}\PYG{p}{)}
     \PYG{p}{\PYGZob{}}
         \PYG{k}{if}\PYG{p}{(}\PYG{n}{filename}\PYG{p}{.}\PYG{n}{find}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{.csv}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)} \PYG{o}{!}\PYG{o}{=} \PYG{n}{string}\PYG{o}{:}\PYG{o}{:}\PYG{n}{npos}\PYG{p}{)}
         \PYG{p}{\PYGZob{}}
             \PYG{n}{importCsv}\PYG{p}{(}\PYG{n}{filename}\PYG{p}{)}\PYG{p}{;}
         \PYG{p}{\PYGZcb{}}
         \PYG{k}{else} \PYG{k}{if}\PYG{p}{(}\PYG{n}{filename}\PYG{p}{.}\PYG{n}{find}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{.tif}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)} \PYG{o}{!}\PYG{o}{=} \PYG{n}{string}\PYG{o}{:}\PYG{o}{:}\PYG{n}{npos}\PYG{p}{)}
         \PYG{p}{\PYGZob{}}
             \PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifdef with\PYGZus{}gdal}
             \PYG{n}{importTif}\PYG{p}{(}\PYG{n}{filename}\PYG{p}{)}\PYG{p}{;}
             \PYG{k}{return}\PYG{p}{;}
             \PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif}
             \PYG{n}{cerr} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Tif file specified, but program not compiled with gdal libraries. Please recompile  with  \PYGZhy{}D with\PYGZus{}gdal or edit your code to include \PYGZsh{}define with\PYGZus{}gdal.}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
             \PYG{n}{exit}\PYG{p}{(}\PYG{n}{EXIT\PYGZus{}FAILURE}\PYG{p}{)}\PYG{p}{;}
         \PYG{p}{\PYGZcb{}}
         \PYG{k}{else}
         \PYG{p}{\PYGZob{}}
            \PYG{n}{string} \PYG{n}{s} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Type detection failed for }\PYG{l+s}{\PYGZdq{}} \PYG{o}{+} \PYG{n}{filename} \PYG{o}{+} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{. Check filename is correct.}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
            \PYG{k}{throw} \PYG{n+nf}{runtime\PYGZus{}error}\PYG{p}{(}\PYG{n}{s}\PYG{p}{)}\PYG{p}{;}
         \PYG{p}{\PYGZcb{}}
     \PYG{p}{\PYGZcb{}}

    \PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifdef with\PYGZus{}gdal}
    \PYG{k+kt}{void} \PYG{n}{importTif}\PYG{p}{(}\PYG{n}{string} \PYG{n}{filename}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{cout}  \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}r}\PYG{l+s}{Importing }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{filename} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{...}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{0\PYGZpc{}}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{                  }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{flush}\PYG{p}{;}
         \PYG{n}{GDALDataset}  \PYG{o}{*}\PYG{n}{poDataset}\PYG{p}{;}
         \PYG{n}{GDALAllRegister}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
         \PYG{n}{poDataset} \PYG{o}{=} \PYG{p}{(}\PYG{n}{GDALDataset} \PYG{o}{*}\PYG{p}{)} \PYG{n}{GDALOpen}\PYG{p}{(} \PYG{n}{filename}\PYG{p}{.}\PYG{n}{c\PYGZus{}str}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{n}{GA\PYGZus{}ReadOnly} \PYG{p}{)}\PYG{p}{;}
         \PYG{k}{if}\PYG{p}{(} \PYG{n}{poDataset} \PYG{o}{=}\PYG{o}{=} \PYG{n+nb}{NULL} \PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{string} \PYG{n}{s} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{File }\PYG{l+s}{\PYGZdq{}} \PYG{o}{+} \PYG{n}{filename} \PYG{o}{+} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ not found.}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
            \PYG{k}{throw} \PYG{n+nf}{runtime\PYGZus{}error}\PYG{p}{(}\PYG{n}{s}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{n}{GDALRasterBand}  \PYG{o}{*}\PYG{n}{poBand}\PYG{p}{;}
        \PYG{k+kt}{int} \PYG{n}{nBlockXSize}\PYG{p}{,} \PYG{n}{nBlockYSize}\PYG{p}{;}
        \PYG{c+c1}{// Import the raster band 1}
        \PYG{n}{poBand} \PYG{o}{=} \PYG{n}{poDataset}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{GetRasterBand}\PYG{p}{(} \PYG{l+m+mi}{1} \PYG{p}{)}\PYG{p}{;}
        \PYG{n}{nBlockXSize} \PYG{o}{=} \PYG{n}{poDataset}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{GetRasterXSize}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{nBlockYSize} \PYG{o}{=} \PYG{n}{poDataset}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{GetRasterYSize}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
        \PYG{c+c1}{// Check sizes}
                    \PYG{c+c1}{//cerr \PYGZlt{}\PYGZlt{} \PYGZdq{}X dimension: \PYGZdq{} \PYGZlt{}\PYGZlt{} nBlockXSize \PYGZlt{}\PYGZlt{} endl;}
            \PYG{c+c1}{//cerr \PYGZlt{}\PYGZlt{} \PYGZdq{}Y dimension: \PYGZdq{} \PYGZlt{}\PYGZlt{} nBlockYSize \PYGZlt{}\PYGZlt{} endl;}
        \PYG{k}{if} \PYG{p}{(} \PYG{p}{(}\PYG{n}{numCols} \PYG{o}{!}\PYG{o}{=} \PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{long}\PYG{p}{)} \PYG{n}{nBlockXSize} \PYG{o}{\textbar{}}\PYG{o}{\textbar{}} \PYG{n}{numRows} \PYG{o}{!}\PYG{o}{=} \PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{long}\PYG{p}{)} \PYG{n}{nBlockYSize}\PYG{p}{)} \PYG{o}{\textbar{}}\PYG{o}{\textbar{}} \PYG{n}{numCols} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{0} \PYG{o}{\textbar{}}\PYG{o}{\textbar{}} \PYG{n}{numRows} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{cerr} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Raster data size does not match inputted dimensions. Using raster sizes.}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
            \PYG{n}{cerr} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Old dimensions: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{numCols} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{, }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{numRows} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
            \PYG{n}{cerr} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{New dimensions: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{nBlockXSize} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{, }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{nBlockYSize} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
            \PYG{n}{SetSize}\PYG{p}{(}\PYG{n}{nBlockYSize}\PYG{p}{,}\PYG{n}{nBlockXSize}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{c+c1}{// Check sizes match}
        \PYG{n}{GDALDataType} \PYG{n}{dt} \PYG{o}{=} \PYG{n}{poBand}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{GetRasterDataType}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
        \PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifdef DEBUG}
        \PYG{k}{if}\PYG{p}{(}\PYG{k}{sizeof}\PYG{p}{(}\PYG{n}{T}\PYG{p}{)}\PYG{o}{*}\PYG{l+m+mi}{8} \PYG{o}{!}\PYG{o}{=} \PYG{n}{gdal\PYGZus{}data\PYGZus{}sizes}\PYG{p}{[}\PYG{n}{dt}\PYG{p}{]}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{cerr} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Object data size: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k}{sizeof}\PYG{p}{(}\PYG{n}{T}\PYG{p}{)}\PYG{o}{*}\PYG{l+m+mi}{8} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
            \PYG{n}{cerr} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Tif data size: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{gdal\PYGZus{}data\PYGZus{}sizes}\PYG{p}{[}\PYG{n}{dt}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
            \PYG{k}{throw} \PYG{n+nf}{runtime\PYGZus{}error}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Tif data type does not match object data size.}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{// Should this be a warning? I think this should be a warning...}
        \PYG{p}{\PYGZcb{}}
        \PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif}
        \PYG{c+c1}{// Iterate over rows, reading each data segment into the matrix row.}
        \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{int} \PYG{n}{j} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{j} \PYG{o}{\PYGZlt{}} \PYG{n}{numRows}\PYG{p}{;} \PYG{n}{j} \PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{k+kt}{double} \PYG{n}{dComplete} \PYG{o}{=} \PYG{p}{(}\PYG{p}{(}\PYG{k+kt}{double}\PYG{p}{)}\PYG{n}{j}\PYG{o}{/}\PYG{p}{(}\PYG{k+kt}{double}\PYG{p}{)}\PYG{n}{numRows}\PYG{p}{)}\PYG{o}{*}\PYG{l+m+mi}{100}\PYG{p}{;}
            \PYG{n}{cout}  \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}r}\PYG{l+s}{Importing }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{filename} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{...}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{dComplete} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZpc{}}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{                  }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{flush}\PYG{p}{;}
            \PYG{n}{CPLErr} \PYG{n}{r} \PYG{o}{=} \PYG{n}{poBand}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{RasterIO}\PYG{p}{(} \PYG{n}{GF\PYGZus{}Read}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{j}\PYG{p}{,} \PYG{n}{nBlockXSize}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{matrix}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{n}{nBlockXSize}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{dt}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0} \PYG{p}{)}\PYG{p}{;}
            \PYG{k}{if}\PYG{p}{(}\PYG{n}{r} \PYG{o}{=}\PYG{o}{=} \PYG{n}{CE\PYGZus{}Failure}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{k}{throw} \PYG{n}{runtime\PYGZus{}error}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{CPL error during tif import: CE\PYGZus{}Failure.}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
        \PYG{p}{\PYGZcb{}}
        \PYG{n}{cout}  \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}r}\PYG{l+s}{Importing }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{filename} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{...done!}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{                  }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif}

    \PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifdef use\PYGZus{}csv}
    \PYG{k+kt}{void} \PYG{n}{importCsv}\PYG{p}{(}\PYG{n}{string} \PYG{n}{filename}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{cout}  \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}r}\PYG{l+s}{Importing }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{filename} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{...}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{0\PYGZpc{}}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{                  }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{flush}\PYG{p}{;}
        \PYG{c+c1}{// LineReader option}
        \PYG{n}{io}\PYG{o}{:}\PYG{o}{:}\PYG{n}{LineReader} \PYG{n}{in}\PYG{p}{(}\PYG{n}{filename}\PYG{p}{)}\PYG{p}{;}
        \PYG{c+c1}{// Keep track of whether we\PYGZsq{}ve printed to terminal or not.}
        \PYG{k+kt}{bool} \PYG{n}{bPrint} \PYG{o}{=} \PYG{n+nb}{false}\PYG{p}{;}
        \PYG{c+c1}{// Initialies empty variable so that the setValue operator overloading works properly.}
        \PYG{n}{T} \PYG{n}{type\PYGZus{}reference} \PYG{o}{=} \PYG{n}{null}\PYG{p}{;}
        \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{i} \PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i}\PYG{o}{\PYGZlt{}}\PYG{n}{numRows}\PYG{p}{;}\PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{k+kt}{char}\PYG{o}{*} \PYG{n}{line} \PYG{o}{=} \PYG{n}{in}\PYG{p}{.}\PYG{n}{next\PYGZus{}line}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
            \PYG{k}{if}\PYG{p}{(}\PYG{n}{line} \PYG{o}{=}\PYG{o}{=} \PYG{k}{nullptr}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{k}{if}\PYG{p}{(}\PYG{o}{!}\PYG{n}{bPrint}\PYG{p}{)}
                \PYG{p}{\PYGZob{}}
                    \PYG{n}{cerr} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Input dimensions incorrect \PYGZhy{} read past end of file.}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
                    \PYG{n}{bPrint} \PYG{o}{=} \PYG{n+nb}{true}\PYG{p}{;}
                \PYG{p}{\PYGZcb{}}
                \PYG{k}{break}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
            \PYG{k}{else}
            \PYG{p}{\PYGZob{}}
                \PYG{k+kt}{char} \PYG{o}{*}\PYG{n}{dToken}\PYG{p}{;}
                \PYG{n}{dToken} \PYG{o}{=} \PYG{n}{strtok}\PYG{p}{(}\PYG{n}{line}\PYG{p}{,}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{,}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
                \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{j} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}\PYG{n}{j}\PYG{o}{\PYGZlt{}}\PYG{n}{numCols}\PYG{p}{;}\PYG{n}{j}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
                \PYG{p}{\PYGZob{}}
                    \PYG{k}{if}\PYG{p}{(}\PYG{n}{dToken} \PYG{o}{=}\PYG{o}{=} \PYG{k}{nullptr}\PYG{p}{)}
                    \PYG{p}{\PYGZob{}}
                        \PYG{k}{if}\PYG{p}{(}\PYG{o}{!}\PYG{n}{bPrint}\PYG{p}{)}
                        \PYG{p}{\PYGZob{}}
                            \PYG{n}{cerr} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Input dimensions incorrect \PYGZhy{} read past end of file.}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
                            \PYG{n}{bPrint} \PYG{o}{=} \PYG{n+nb}{true}\PYG{p}{;}
                        \PYG{p}{\PYGZcb{}}
                        \PYG{k}{break}\PYG{p}{;}
                    \PYG{p}{\PYGZcb{}}
                    \PYG{k}{else}
                    \PYG{p}{\PYGZob{}}
                        \PYG{c+c1}{// This function is overloaded to correctly determine the type of the template}
                        \PYG{n}{setValue}\PYG{p}{(}\PYG{n}{j}\PYG{p}{,}\PYG{n}{i}\PYG{p}{,}\PYG{n}{dToken}\PYG{p}{,}\PYG{n}{type\PYGZus{}reference}\PYG{p}{)}\PYG{p}{;}
                        \PYG{n}{dToken} \PYG{o}{=} \PYG{n}{strtok}\PYG{p}{(}\PYG{n+nb}{NULL}\PYG{p}{,}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{,}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
                    \PYG{p}{\PYGZcb{}}
                \PYG{p}{\PYGZcb{}}
                \PYG{c+c1}{// output the percentage complete}
                \PYG{k+kt}{double} \PYG{n}{dComplete} \PYG{o}{=} \PYG{p}{(}\PYG{p}{(}\PYG{k+kt}{double}\PYG{p}{)}\PYG{n}{i}\PYG{o}{/}\PYG{p}{(}\PYG{k+kt}{double}\PYG{p}{)}\PYG{n}{numRows}\PYG{p}{)}\PYG{o}{*}\PYG{l+m+mi}{100}\PYG{p}{;}
                \PYG{k}{if}\PYG{p}{(}\PYG{n}{i}\PYG{o}{\PYGZpc{}}\PYG{l+m+mi}{40}\PYG{o}{=}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
                \PYG{p}{\PYGZob{}}
                    \PYG{n}{cout}  \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}r}\PYG{l+s}{Importing}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{filename} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{...}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{floor}\PYG{p}{(}\PYG{n}{dComplete}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZpc{}}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{                  }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{flush}\PYG{p}{;}
                \PYG{p}{\PYGZcb{}}
            \PYG{p}{\PYGZcb{}}
        \PYG{p}{\PYGZcb{}}
        \PYG{n}{cout}  \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}r}\PYG{l+s}{Importing}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{filename} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{...}\PYG{l+s}{\PYGZdq{}}  \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{done!}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{           }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif}
    \PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifndef use\PYGZus{}csv}
    \PYG{c+c1}{// OLD VERSION \PYGZhy{} currently unused)}
    \PYG{k+kt}{void} \PYG{n}{importCsv}\PYG{p}{(}\PYG{n}{string} \PYG{n}{filename}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{cout}  \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}r}\PYG{l+s}{Importing}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{filename} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{...}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{0\PYGZpc{}}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{                  }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{flush}\PYG{p}{;}
         \PYG{n}{ifstream} \PYG{n}{inputstream}\PYG{p}{;}
         \PYG{n}{inputstream}\PYG{p}{.}\PYG{n}{open}\PYG{p}{(}\PYG{n}{filename}\PYG{p}{.}\PYG{n}{c\PYGZus{}str}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{j} \PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;}\PYG{n}{j}\PYG{o}{\PYGZlt{}}\PYG{n}{numRows}\PYG{p}{;}\PYG{n}{j}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{string} \PYG{n}{line}\PYG{p}{;}
            \PYG{n}{getline}\PYG{p}{(}\PYG{n}{inputstream}\PYG{p}{,}\PYG{n}{line}\PYG{p}{)}\PYG{p}{;}
\PYG{c+c1}{//          cout \PYGZlt{}\PYGZlt{} \PYGZdq{}got line\PYGZdq{} \PYGZlt{}\PYGZlt{} endl;}
\PYG{c+c1}{//          cout \PYGZlt{}\PYGZlt{} line \PYGZlt{}\PYGZlt{} endl;}
            \PYG{n}{istringstream} \PYG{n+nf}{iss}\PYG{p}{(}\PYG{n}{line}\PYG{p}{)}\PYG{p}{;}
\PYG{c+c1}{//          cout \PYGZlt{}\PYGZlt{} numCols \PYGZlt{}\PYGZlt{} endl;}
\PYG{c+c1}{//          string sam;}
\PYG{c+c1}{//          cin \PYGZgt{}\PYGZgt{} sam;}

\PYG{c+c1}{//          getline(inputstream,line);}
\PYG{c+c1}{//          cout \PYGZlt{}\PYGZlt{} line \PYGZlt{}\PYGZlt{} endl;}
\PYG{c+c1}{//          cin \PYGZgt{}\PYGZgt{} sam;}
            \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i}\PYG{o}{\PYGZlt{}}\PYG{n}{numCols}\PYG{p}{;}\PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{k+kt}{char} \PYG{n}{delim}\PYG{p}{;}
                \PYG{n}{T} \PYG{n}{val}\PYG{p}{;}
                \PYG{n}{iss} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{val} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{delim}\PYG{p}{;}
                \PYG{n}{matrix}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{=}\PYG{n}{val}\PYG{p}{;}
\PYG{c+c1}{//              cout \PYGZlt{}\PYGZlt{} i  \PYGZlt{}\PYGZlt{} \PYGZdq{}\PYGZhy{}\PYGZdq{}\PYGZlt{}\PYGZlt{} matrix[j][i] \PYGZlt{}\PYGZlt{} endl;}
            \PYG{p}{\PYGZcb{}}
            \PYG{k+kt}{double} \PYG{n}{dComplete} \PYG{o}{=} \PYG{p}{(}\PYG{p}{(}\PYG{k+kt}{double}\PYG{p}{)}\PYG{n}{j}\PYG{o}{/}\PYG{p}{(}\PYG{k+kt}{double}\PYG{p}{)}\PYG{n}{numRows}\PYG{p}{)}\PYG{o}{*}\PYG{l+m+mi}{100}\PYG{p}{;}
            \PYG{n}{cout}  \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}r}\PYG{l+s}{Importing}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{filename} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{...}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{dComplete} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZpc{}}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{                  }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{flush}\PYG{p}{;}
\PYG{c+c1}{//          cout \PYGZlt{}\PYGZlt{} j \PYGZlt{}\PYGZlt{} endl;}
\PYG{c+c1}{//          iss.clear();}
        \PYG{p}{\PYGZcb{}}
        \PYG{n}{cout}  \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}r}\PYG{l+s}{Importing}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{filename} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{...}\PYG{l+s}{\PYGZdq{}}  \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{done!}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{                          }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
        \PYG{n}{inputstream}\PYG{p}{.}\PYG{n}{close}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{return}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}

\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif}

\PYG{c+c1}{// THE END OF THE CODE}
\end{sphinxVerbatim}


\subparagraph{Includes}
\label{\detokenize{Exhaled/exhale_file_Matrix.h:includes}}\begin{itemize}
\item {} 
\sphinxcode{assert.h}

\item {} 
\sphinxcode{cstdlib}

\item {} 
\sphinxcode{cstring}

\item {} 
\sphinxcode{fstream}

\item {} 
\sphinxcode{iostream}

\item {} 
\sphinxcode{sstream}

\item {} 
\sphinxcode{stdexcept}

\item {} 
\sphinxcode{stdint.h}

\item {} 
\sphinxcode{stdio.h}

\end{itemize}


\subparagraph{Included By}
\label{\detokenize{Exhaled/exhale_file_Matrix.h:included-by}}\begin{itemize}
\item {} 
{\hyperref[\detokenize{Exhaled/exhale_file_Tree.h:file-tree-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File Tree.h}}}}

\item {} 
{\hyperref[\detokenize{Exhaled/exhale_file_Map.h:file-map-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File Map.h}}}}

\item {} 
{\hyperref[\detokenize{Exhaled/exhale_file_Treelist.h:file-treelist-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File Treelist.h}}}}

\end{itemize}


\subparagraph{Classes}
\label{\detokenize{Exhaled/exhale_file_Matrix.h:classes}}\begin{itemize}
\item {} 
{\hyperref[\detokenize{Exhaled/exhale_class_Matrix:class-matrix}]{\sphinxcrossref{\DUrole{std,std-ref}{Class Matrix}}}}

\item {} 
{\hyperref[\detokenize{Exhaled/exhale_class_Row:class-row}]{\sphinxcrossref{\DUrole{std,std-ref}{Class Row}}}}

\end{itemize}


\subparagraph{Defines}
\label{\detokenize{Exhaled/exhale_file_Matrix.h:defines}}\begin{itemize}
\item {} 
{\hyperref[\detokenize{Exhaled/exhale_define_MATRIX:define-matrix}]{\sphinxcrossref{\DUrole{std,std-ref}{Define MATRIX}}}}

\item {} 
{\hyperref[\detokenize{Exhaled/exhale_define_null:define-null}]{\sphinxcrossref{\DUrole{std,std-ref}{Define null}}}}

\item {} 
{\hyperref[\detokenize{Exhaled/exhale_define_version1_11:define-version1-11}]{\sphinxcrossref{\DUrole{std,std-ref}{Define version1\_11}}}}

\end{itemize}


\subparagraph{Variables}
\label{\detokenize{Exhaled/exhale_file_Matrix.h:variables}}\begin{itemize}
\item {} 
{\hyperref[\detokenize{Exhaled/exhale_variable_gdal_data_sizes:variable-gdal-data-sizes}]{\sphinxcrossref{\DUrole{std,std-ref}{Variable gdal\_data\_sizes}}}}

\end{itemize}


\paragraph{File Setup.cpp}
\label{\detokenize{Exhaled/exhale_file_Setup.cpp:file-setup-cpp}}\label{\detokenize{Exhaled/exhale_file_Setup.cpp::doc}}\label{\detokenize{Exhaled/exhale_file_Setup.cpp:id1}}

\subparagraph{Definition (\sphinxstyleliteralintitle{Setup.cpp})}
\label{\detokenize{Exhaled/exhale_file_Setup.cpp:definition-setup-cpp}}

\subparagraph{Program Listing for File Setup.cpp}
\label{\detokenize{Exhaled/exhale_program_listing_file_Setup.cpp:program-listing-file-setup-cpp}}\label{\detokenize{Exhaled/exhale_program_listing_file_Setup.cpp::doc}}\label{\detokenize{Exhaled/exhale_program_listing_file_Setup.cpp:program-listing-for-file-setup-cpp}}\begin{itemize}
\item {} 
Return to documentation for {\hyperref[\detokenize{Exhaled/exhale_file_Setup.cpp:file-setup-cpp}]{\sphinxcrossref{\DUrole{std,std-ref}{File Setup.cpp}}}}

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{//This file is part of NECSim project which is released under BSD\PYGZhy{}3 license.}
\PYG{c+c1}{//See file **LICENSE.txt** or visit https://opensource.org/licenses/BSD\PYGZhy{}3\PYGZhy{}Clause) for full license details.}
\PYG{c+c1}{//}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZdq{}Setup.h\PYGZdq{}}

\PYG{c+c1}{// Global variables}
\PYG{c+c1}{// store the log file name for access anywhere.}
\PYG{n}{string} \PYG{n}{log\PYGZus{}name} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{null}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
\PYG{c+c1}{// the old stdout}
\PYG{k+kt}{int} \PYG{n}{saved\PYGZus{}stdout}\PYG{p}{;}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifndef verbose}

\PYG{k+kt}{void} \PYG{n+nf}{openLogFile}\PYG{p}{(}\PYG{k+kt}{bool} \PYG{n}{append}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{c+c1}{// If verbose mode is not defined, we output to a log file instead of to the terminal}
    \PYG{c+c1}{// Get the current time}
    \PYG{n}{saved\PYGZus{}stdout} \PYG{o}{=} \PYG{n}{dup}\PYG{p}{(}\PYG{n}{fileno}\PYG{p}{(}\PYG{n}{stdout}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
    \PYG{c+c1}{//dup2(stdout, 1);}
    \PYG{k}{auto} \PYG{n}{t} \PYG{o}{=} \PYG{n}{time}\PYG{p}{(}\PYG{k}{nullptr}\PYG{p}{)}\PYG{p}{;}
    \PYG{k}{auto} \PYG{n}{tm} \PYG{o}{=} \PYG{o}{*}\PYG{n}{localtime}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{t}\PYG{p}{)}\PYG{p}{;}
    \PYG{c+c1}{// get the time string}
    \PYG{n}{ostringstream} \PYG{n}{oss}\PYG{p}{;}
    \PYG{n}{oss} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{put\PYGZus{}time}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{tm}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZpc{}d\PYGZhy{}\PYGZpc{}m\PYGZhy{}\PYGZpc{}Y\PYGZhy{}\PYGZpc{}H:\PYGZpc{}M:\PYGZpc{}S}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{k}{if}\PYG{p}{(}\PYG{n}{log\PYGZus{}name} \PYG{o}{=}\PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{null}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{log\PYGZus{}name} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Logs/Log\PYGZus{}}\PYG{l+s}{\PYGZdq{}}\PYG{o}{+}\PYG{n}{oss}\PYG{p}{.}\PYG{n}{str}\PYG{p}{(}\PYG{p}{)} \PYG{o}{+} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{.txt}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{c+c1}{// Check that the Log folder exists, and create if necessary.}
    \PYG{k}{if}\PYG{p}{(}\PYG{o}{!}\PYG{n}{boost}\PYG{o}{:}\PYG{o}{:}\PYG{n}{filesystem}\PYG{o}{:}\PYG{o}{:}\PYG{n}{exists}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Logs}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{if}\PYG{p}{(}\PYG{o}{!}\PYG{n}{boost}\PYG{o}{:}\PYG{o}{:}\PYG{n}{filesystem}\PYG{o}{:}\PYG{o}{:}\PYG{n}{create\PYGZus{}directory}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Logs}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{cerr} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Cannot create log directory (check write access) \PYGZhy{} defaulting to terminal.}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{if}\PYG{p}{(}\PYG{n}{boost}\PYG{o}{:}\PYG{o}{:}\PYG{n}{filesystem}\PYG{o}{:}\PYG{o}{:}\PYG{n}{exists}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Logs}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{c+c1}{// Open the log file for writing to.}
        \PYG{k+kt}{FILE} \PYG{o}{*} \PYG{n}{tmpfileptr}\PYG{p}{;}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{append}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{tmpfileptr} \PYG{o}{=} \PYG{n}{freopen}\PYG{p}{(}\PYG{n}{log\PYGZus{}name}\PYG{p}{.}\PYG{n}{c\PYGZus{}str}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{a}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{stdout}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{else}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{tmpfileptr} \PYG{o}{=} \PYG{n}{freopen}\PYG{p}{(}\PYG{n}{log\PYGZus{}name}\PYG{p}{.}\PYG{n}{c\PYGZus{}str}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{w}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{stdout}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{stdout} \PYG{o}{=}\PYG{o}{=} \PYG{k}{nullptr} \PYG{o}{\textbar{}}\PYG{o}{\textbar{}} \PYG{n}{tmpfileptr} \PYG{o}{=}\PYG{o}{=} \PYG{k}{nullptr}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{cerr} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Cannot create log file (check write access) \PYGZhy{} defaulting to terminal.}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
            \PYG{n}{dup2}\PYG{p}{(}\PYG{n}{saved\PYGZus{}stdout}\PYG{p}{,} \PYG{n}{fileno}\PYG{p}{(}\PYG{n}{stdout}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
            \PYG{n}{close}\PYG{p}{(}\PYG{n}{saved\PYGZus{}stdout}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
    \PYG{p}{\PYGZcb{}}
    \PYG{c+c1}{//cerr\PYGZlt{}\PYGZlt{} \PYGZdq{}logfile2 : \PYGZdq{} \PYGZlt{}\PYGZlt{} log\PYGZus{}name \PYGZlt{}\PYGZlt{} endl;}
\PYG{p}{\PYGZcb{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif}

\PYG{k+kt}{long} \PYG{n+nf}{charconvertor}\PYG{p}{(}\PYG{k+kt}{char} \PYG{n}{charin}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k}{switch} \PYG{p}{(}\PYG{n}{charin}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{case} \PYG{l+s+sc}{\PYGZsq{}}\PYG{l+s+sc}{0}\PYG{l+s+sc}{\PYGZsq{}}\PYG{o}{:} \PYG{k}{return} \PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{case} \PYG{l+s+sc}{\PYGZsq{}}\PYG{l+s+sc}{1}\PYG{l+s+sc}{\PYGZsq{}}\PYG{o}{:} \PYG{k}{return} \PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{case} \PYG{l+s+sc}{\PYGZsq{}}\PYG{l+s+sc}{2}\PYG{l+s+sc}{\PYGZsq{}}\PYG{o}{:} \PYG{k}{return} \PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{case} \PYG{l+s+sc}{\PYGZsq{}}\PYG{l+s+sc}{3}\PYG{l+s+sc}{\PYGZsq{}}\PYG{o}{:} \PYG{k}{return} \PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{case} \PYG{l+s+sc}{\PYGZsq{}}\PYG{l+s+sc}{4}\PYG{l+s+sc}{\PYGZsq{}}\PYG{o}{:} \PYG{k}{return} \PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{case} \PYG{l+s+sc}{\PYGZsq{}}\PYG{l+s+sc}{5}\PYG{l+s+sc}{\PYGZsq{}}\PYG{o}{:} \PYG{k}{return} \PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{case} \PYG{l+s+sc}{\PYGZsq{}}\PYG{l+s+sc}{6}\PYG{l+s+sc}{\PYGZsq{}}\PYG{o}{:} \PYG{k}{return} \PYG{p}{(}\PYG{l+m+mi}{6}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{case} \PYG{l+s+sc}{\PYGZsq{}}\PYG{l+s+sc}{7}\PYG{l+s+sc}{\PYGZsq{}}\PYG{o}{:} \PYG{k}{return} \PYG{p}{(}\PYG{l+m+mi}{7}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{case} \PYG{l+s+sc}{\PYGZsq{}}\PYG{l+s+sc}{8}\PYG{l+s+sc}{\PYGZsq{}}\PYG{o}{:} \PYG{k}{return} \PYG{p}{(}\PYG{l+m+mi}{8}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{case} \PYG{l+s+sc}{\PYGZsq{}}\PYG{l+s+sc}{9}\PYG{l+s+sc}{\PYGZsq{}}\PYG{o}{:} \PYG{k}{return} \PYG{p}{(}\PYG{l+m+mi}{9}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{default}\PYG{o}{:} \PYG{k}{return} \PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{long} \PYG{n+nf}{jobConvertor}\PYG{p}{(}\PYG{k+kt}{char}\PYG{o}{*} \PYG{n}{argin}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k+kt}{long} \PYG{n}{maxind} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
    \PYG{k}{while} \PYG{p}{(}\PYG{n}{charconvertor}\PYG{p}{(}\PYG{n}{argin}\PYG{p}{[}\PYG{n}{maxind}\PYG{p}{]}\PYG{p}{)} \PYG{o}{!}\PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{maxind} \PYG{o}{+}\PYG{o}{+}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{k+kt}{long} \PYG{n}{jobtoret} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
    \PYG{k+kt}{long} \PYG{n}{pow10} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;}
    \PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{long} \PYG{n}{i} \PYG{o}{=} \PYG{n}{maxind}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1} \PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZgt{}}\PYG{o}{=}\PYG{l+m+mi}{0} \PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{jobtoret} \PYG{o}{+}\PYG{o}{=} \PYG{p}{(}\PYG{n}{pow10}\PYG{o}{*}\PYG{n}{charconvertor}\PYG{p}{(}\PYG{n}{argin}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{pow10} \PYG{o}{=} \PYG{n}{pow10}\PYG{o}{*}\PYG{l+m+mi}{10}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{return} \PYG{n}{jobtoret}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{c+c1}{//}
\PYG{k+kt}{bool} \PYG{n+nf}{checkSims}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{the\PYGZus{}task}\PYG{p}{,}\PYG{k+kt}{int} \PYG{n}{the\PYGZus{}seed}\PYG{p}{,}\PYG{n}{string} \PYG{n}{outdirect}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Checking for unfinished simulations...}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{flush}\PYG{p}{;}
    \PYG{n}{ifstream} \PYG{n}{out}\PYG{p}{;}
    \PYG{n}{string} \PYG{n}{file\PYGZus{}to\PYGZus{}open}\PYG{p}{;}
\PYG{c+c1}{//  char file\PYGZus{}to\PYGZus{}open[100];}
\PYG{c+c1}{//  sprintf (file\PYGZus{}to\PYGZus{}open, \PYGZdq{}\PYGZpc{}s/Pause/Data\PYGZus{}\PYGZpc{}i.csv\PYGZdq{},outdirect,int(the\PYGZus{}task));}
    \PYG{n}{file\PYGZus{}to\PYGZus{}open} \PYG{o}{=} \PYG{n}{outdirect} \PYG{o}{+} \PYG{n}{string}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{/Pause/Dump\PYGZus{}active\PYGZus{}}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)} \PYG{o}{+} \PYG{n}{to\PYGZus{}string}\PYG{p}{(}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{k+kt}{long}\PYG{p}{)}\PYG{n}{the\PYGZus{}task}\PYG{p}{)}\PYG{o}{+}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZus{}}\PYG{l+s}{\PYGZdq{}}\PYG{o}{+}\PYG{n}{to\PYGZus{}string}\PYG{p}{(}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{k+kt}{long}\PYG{p}{)}\PYG{n}{the\PYGZus{}seed}\PYG{p}{)} \PYG{o}{+} \PYG{n}{string}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{.csv}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{out}\PYG{p}{.}\PYG{n}{open}\PYG{p}{(}\PYG{n}{file\PYGZus{}to\PYGZus{}open}\PYG{p}{)}\PYG{p}{;}
    \PYG{k}{if}\PYG{p}{(}\PYG{n}{out}\PYG{p}{.}\PYG{n}{good}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{done!}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{File found containing unfinished simulations.}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
        \PYG{k}{return}\PYG{p}{(}\PYG{n+nb}{true}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{else}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{done!}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{No files found containing unfinished simulations.}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
        \PYG{k}{return}\PYG{p}{(}\PYG{n+nb}{false}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}


\PYG{k+kt}{void} \PYG{n+nf}{checkFolders}\PYG{p}{(}\PYG{n}{string} \PYG{n}{sFineMap}\PYG{p}{,} \PYG{n}{string} \PYG{n}{sCoarseMap}\PYG{p}{,} \PYG{n}{string} \PYG{n}{sFineMapPristine}\PYG{p}{,} \PYG{n}{string} \PYG{n}{sCoarseMapPristine}\PYG{p}{,} \PYG{n}{string} \PYG{n}{sOutputFolder}\PYG{p}{,}\PYG{n}{string} \PYG{n}{sSampleMask}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Checking folder existance...}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{flush}\PYG{p}{;}
    \PYG{k+kt}{bool} \PYG{n}{bFineMap}\PYG{p}{,} \PYG{n}{bCoarseMap}\PYG{p}{,} \PYG{n}{bFineMapPristine}\PYG{p}{,} \PYG{n}{bCoarseMapPristine}\PYG{p}{,} \PYG{n}{bOutputfolder}\PYG{p}{,} \PYG{n}{bSampleMask}\PYG{p}{;}
    \PYG{k}{try}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{bFineMap} \PYG{o}{=} \PYG{n}{doesExistNull}\PYG{p}{(}\PYG{n}{sFineMap}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{catch}\PYG{p}{(}\PYG{n}{Fatal\PYGZus{}Exception}\PYG{o}{\PYGZam{}} \PYG{n}{fe}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{cerr} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{fe}\PYG{p}{.}\PYG{n}{what}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
        \PYG{n}{bFineMap} \PYG{o}{=} \PYG{n+nb}{false}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{try}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{bCoarseMap} \PYG{o}{=} \PYG{n}{doesExistNull}\PYG{p}{(}\PYG{n}{sCoarseMap}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{catch}\PYG{p}{(}\PYG{n}{Fatal\PYGZus{}Exception}\PYG{o}{\PYGZam{}} \PYG{n}{fe}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{cerr} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{fe}\PYG{p}{.}\PYG{n}{what}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
        \PYG{n}{bCoarseMap} \PYG{o}{=} \PYG{n+nb}{false}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{try}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{bFineMapPristine} \PYG{o}{=} \PYG{n}{doesExistNull}\PYG{p}{(}\PYG{n}{sFineMapPristine}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{catch}\PYG{p}{(}\PYG{n}{Fatal\PYGZus{}Exception}\PYG{o}{\PYGZam{}} \PYG{n}{fe}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{cerr} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{fe}\PYG{p}{.}\PYG{n}{what}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
        \PYG{n}{bFineMapPristine} \PYG{o}{=} \PYG{n+nb}{false}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{try}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{bCoarseMapPristine} \PYG{o}{=} \PYG{n}{doesExistNull}\PYG{p}{(}\PYG{n}{sCoarseMapPristine}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{catch}\PYG{p}{(}\PYG{n}{Fatal\PYGZus{}Exception}\PYG{o}{\PYGZam{}} \PYG{n}{fe}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{cerr} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{fe}\PYG{p}{.}\PYG{n}{what}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
        \PYG{n}{bCoarseMapPristine} \PYG{o}{=} \PYG{n+nb}{false}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{if}\PYG{p}{(}\PYG{n}{sOutputFolder} \PYG{o}{!}\PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{null}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{try}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{bOutputfolder} \PYG{o}{=} \PYG{n}{doesExist}\PYG{p}{(}\PYG{n}{sOutputFolder}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{catch}\PYG{p}{(}\PYG{n}{runtime\PYGZus{}error} \PYG{o}{\PYGZam{}}\PYG{n}{re}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{cerr} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Output folder does not exist... creating...}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{flush}\PYG{p}{;}
            \PYG{n}{bOutputfolder} \PYG{o}{=} \PYG{n}{boost}\PYG{o}{:}\PYG{o}{:}\PYG{n}{filesystem}\PYG{o}{:}\PYG{o}{:}\PYG{n}{create\PYGZus{}directory}\PYG{p}{(}\PYG{n}{sOutputFolder}\PYG{p}{)}\PYG{p}{;}
            \PYG{k}{if}\PYG{p}{(} \PYG{n}{bOutputfolder}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{n}{cerr} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{done!}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
            \PYG{k}{else}
            \PYG{p}{\PYGZob{}}
                \PYG{n}{cerr} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{re}\PYG{p}{.}\PYG{n}{what}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
        \PYG{p}{\PYGZcb{}}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{else}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{throw} \PYG{n}{Fatal\PYGZus{}Exception}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ERROR\PYGZus{}MAIN\PYGZus{}009: FATAL. Output folder cannot be null.}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{try}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{bSampleMask} \PYG{o}{=} \PYG{n}{doesExistNull}\PYG{p}{(}\PYG{n}{sSampleMask}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{catch}\PYG{p}{(}\PYG{n}{Fatal\PYGZus{}Exception}\PYG{o}{\PYGZam{}} \PYG{n}{fe}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{cerr} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{fe}\PYG{p}{.}\PYG{n}{what}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
        \PYG{n}{bSampleMask} \PYG{o}{=} \PYG{n+nb}{false}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{if}\PYG{p}{(}\PYG{n}{bFineMap} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{n}{bCoarseMap} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{n}{bFineMapPristine} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{n}{bCoarseMapPristine} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{n}{bOutputfolder} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{n}{bSampleMask}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}r}\PYG{l+s}{Checking folder existance...done!                                                                }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
        \PYG{k}{return}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{else}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{throw} \PYG{n}{Fatal\PYGZus{}Exception}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{void} \PYG{n+nf}{runAsDefault}\PYG{p}{(}\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{n}{string}\PYG{o}{\PYGZgt{}} \PYG{o}{\PYGZam{}}\PYG{n}{comargs}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Setting default variables on small grid...}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{flush}\PYG{p}{;}
    \PYG{n}{comargs}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZhy{}f}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{comargs}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{1}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{comargs}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{10}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{comargs}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{10}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{comargs}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{null}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{comargs}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{150}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{comargs}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{150}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{comargs}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{25}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{comargs}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{25}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{comargs}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{null}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{comargs}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{2000}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{comargs}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{2000}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{comargs}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{500}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{comargs}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{500}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{comargs}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{100}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{comargs}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Default/}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{comargs}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{0.000009}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{comargs}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{4}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{comargs}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{1}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{comargs}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{1}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{comargs}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{3600}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{comargs}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{1}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{comargs}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{0}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{comargs}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{100}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{comargs}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{null}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{comargs}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{null}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{comargs}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{0.5}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{comargs}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{20.0}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{comargs}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{1.0}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{comargs}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{null}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{comargs}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{null}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{comargs}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{0.000009}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{done!}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{void} \PYG{n+nf}{runLarge}\PYG{p}{(}\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{n}{string}\PYG{o}{\PYGZgt{}} \PYG{o}{\PYGZam{}}\PYG{n}{comargs}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Setting default variables on large grid...}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{flush}\PYG{p}{;}
    \PYG{n}{comargs}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZhy{}f}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{comargs}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{1}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{comargs}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{500}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{comargs}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{500}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{comargs}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{null}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{comargs}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{500}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{comargs}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{500}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{comargs}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{0}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{comargs}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{0}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{comargs}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{null}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{comargs}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{100}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{comargs}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{100}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{comargs}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{2500}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{comargs}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{2500}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{comargs}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{100}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{comargs}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Default/}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{comargs}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{0.00001}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{comargs}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{8}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{comargs}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{10}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{comargs}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{1}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{comargs}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{3600}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{comargs}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{1}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{comargs}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{1}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{comargs}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{50000}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{comargs}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{null}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{comargs}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{null}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{comargs}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{0.5}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{comargs}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{20.0}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{comargs}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{1.0}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{comargs}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{null}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{comargs}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{null}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{comargs}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{0.000009}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{done!}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{void} \PYG{n+nf}{runXL}\PYG{p}{(}\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{n}{string}\PYG{o}{\PYGZgt{}} \PYG{o}{\PYGZam{}}\PYG{n}{comargs}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Setting default variables on large grid...}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{flush}\PYG{p}{;}
    \PYG{n}{comargs}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZhy{}f}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{comargs}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{1}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{comargs}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{6000}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{comargs}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{6400}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{comargs}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{null}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{comargs}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{34000}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{comargs}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{28000}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{comargs}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{8800}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{comargs}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{14800}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{comargs}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{null}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{comargs}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{24000}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{comargs}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{20000}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{comargs}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{10320}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{comargs}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{8080}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{comargs}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{10}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{comargs}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Default/}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{comargs}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{0.0000001}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{comargs}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{2}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{comargs}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{49}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{comargs}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{0.2}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{comargs}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{21600}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{comargs}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{1}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{comargs}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{3}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{comargs}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{600}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{comargs}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{null}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{comargs}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{null}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{comargs}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{0}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{comargs}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{2.2}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{comargs}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{1.0}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{comargs}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{null}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{comargs}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{null}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{comargs}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{0.000009}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{done!}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}


\PYG{c+c1}{//}
\PYG{c+c1}{//}
\PYG{k+kt}{void} \PYG{n+nf}{removeComOption}\PYG{p}{(}\PYG{k+kt}{int} \PYG{o}{\PYGZam{}}\PYG{n}{argc}\PYG{p}{,} \PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{n}{string}\PYG{o}{\PYGZgt{}} \PYG{o}{\PYGZam{}}\PYG{n}{comargs}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{c+c1}{// stupidly long list of possible arguments, but can\PYGZsq{}t think of a better way to check this.}
    \PYG{k}{if}\PYG{p}{(}\PYG{n}{comargs}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{=}\PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZhy{}d}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\textbar{}}\PYG{o}{\textbar{}} \PYG{n}{comargs}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{=}\PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZhy{}D}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\textbar{}}\PYG{o}{\textbar{}}  \PYG{n}{comargs}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{=}\PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZhy{}dl}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\textbar{}}\PYG{o}{\textbar{}}  \PYG{n}{comargs}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{=}\PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZhy{}dL}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\textbar{}}\PYG{o}{\textbar{}}  \PYG{n}{comargs}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{=}\PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ \PYGZhy{}Dl}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\textbar{}}\PYG{o}{\textbar{}}  \PYG{n}{comargs}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{=}\PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZhy{}DL}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\textbar{}}\PYG{o}{\textbar{}}
        \PYG{n}{comargs}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{=}\PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZhy{}dx}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\textbar{}}\PYG{o}{\textbar{}} \PYG{n}{comargs}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{=}\PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZhy{}dX}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\textbar{}}\PYG{o}{\textbar{}}  \PYG{n}{comargs}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{=}\PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZhy{}DX}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\textbar{}}\PYG{o}{\textbar{}}  \PYG{n}{comargs}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{=}\PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ \PYGZhy{}Dx}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\textbar{}}\PYG{o}{\textbar{}}  \PYG{n}{comargs}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{=}\PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZhy{}c}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\textbar{}}\PYG{o}{\textbar{}}  \PYG{n}{comargs}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{=}\PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZhy{}C}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\textbar{}}\PYG{o}{\textbar{}}
        \PYG{n}{comargs}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{=}\PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZhy{}config}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\textbar{}}\PYG{o}{\textbar{}}  \PYG{n}{comargs}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{=}\PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZhy{}Config}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\textbar{}}\PYG{o}{\textbar{}} \PYG{n}{comargs}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{=}\PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZhy{}f}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\textbar{}}\PYG{o}{\textbar{}} \PYG{n}{comargs}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{=}\PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZhy{}h}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\textbar{}}\PYG{o}{\textbar{}} \PYG{n}{comargs}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{=}\PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZhy{}H}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\textbar{}}\PYG{o}{\textbar{}} \PYG{n}{comargs}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{=}\PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZhy{}F)}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{comargs}\PYG{p}{.}\PYG{n}{erase}\PYG{p}{(}\PYG{n}{comargs}\PYG{p}{.}\PYG{n}{begin}\PYG{p}{(}\PYG{p}{)} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{argc} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{return}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{n}{string}\PYG{o}{\PYGZgt{}} \PYG{n}{importConfig}\PYG{p}{(}\PYG{n}{string} \PYG{n}{configfile}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{n}{ConfigOption} \PYG{n}{conf}\PYG{p}{;}
    \PYG{n}{conf}\PYG{p}{.}\PYG{n}{setConfig}\PYG{p}{(}\PYG{n}{configfile}\PYG{p}{,}\PYG{n+nb}{true}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{conf}\PYG{p}{.}\PYG{n}{parseConfig}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{n}{string}\PYG{o}{\PYGZgt{}} \PYG{n}{sections} \PYG{o}{=} \PYG{n}{conf}\PYG{p}{.}\PYG{n}{getSections}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{n}{string}\PYG{o}{\PYGZgt{}} \PYG{n}{comargs}\PYG{p}{;}
    \PYG{k+kt}{bool} \PYG{n}{maincheck} \PYG{o}{=} \PYG{n+nb}{false}\PYG{p}{;}
    \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{sections}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{sections}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{=}\PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{main}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{maincheck} \PYG{o}{=} \PYG{n+nb}{true}\PYG{p}{;}
            \PYG{k}{break}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{if}\PYG{p}{(}\PYG{n}{maincheck}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{comargs}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{n}{conf}\PYG{p}{.}\PYG{n}{getSectionOptions}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{main}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{job\PYGZus{}num}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{comargs}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{n}{conf}\PYG{p}{.}\PYG{n}{getSectionOptions}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{main}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{job\PYGZus{}type}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{comargs}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{n}{conf}\PYG{p}{.}\PYG{n}{getSectionOptions}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{main}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{map\PYGZus{}config}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{comargs}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{n}{conf}\PYG{p}{.}\PYG{n}{getSectionOptions}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{main}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{output\PYGZus{}directory}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{comargs}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{n}{conf}\PYG{p}{.}\PYG{n}{getSectionOptions}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{main}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{min\PYGZus{}spec\PYGZus{}rate}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{comargs}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{n}{conf}\PYG{p}{.}\PYG{n}{getSectionOptions}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{main}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{zfat}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{comargs}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{n}{conf}\PYG{p}{.}\PYG{n}{getSectionOptions}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{main}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{lval}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{comargs}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{n}{conf}\PYG{p}{.}\PYG{n}{getSectionOptions}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{main}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{deme}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{comargs}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{n}{conf}\PYG{p}{.}\PYG{n}{getSectionOptions}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{main}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{sample\PYGZus{}size}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{comargs}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{n}{conf}\PYG{p}{.}\PYG{n}{getSectionOptions}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{main}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{max\PYGZus{}time}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{comargs}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{n}{conf}\PYG{p}{.}\PYG{n}{getSectionOptions}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{main}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{lambda}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{comargs}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{n}{conf}\PYG{p}{.}\PYG{n}{getSectionOptions}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{main}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{time\PYGZus{}config}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{comargs}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{n}{conf}\PYG{p}{.}\PYG{n}{getSectionOptions}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{main}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{min\PYGZus{}species}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{conf}\PYG{p}{.}\PYG{n}{hasSection}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{spec\PYGZus{}rates}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{n}{string}\PYG{o}{\PYGZgt{}} \PYG{n}{spec\PYGZus{}rates} \PYG{o}{=} \PYG{n}{conf}\PYG{p}{.}\PYG{n}{getSectionValues}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{spec\PYGZus{}rates}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
            \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{spec\PYGZus{}rates}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{n}{i} \PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{n}{comargs}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{n}{spec\PYGZus{}rates}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{return}\PYG{p}{(}\PYG{n}{comargs}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{else}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{throw} \PYG{n}{Config\PYGZus{}Exception}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Could not find main section in config file. Aborting}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

\PYG{p}{\PYGZcb{}}

\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifndef infinite\PYGZus{}landscape}

\PYG{k+kt}{bool} \PYG{n}{parseArgs}\PYG{p}{(}\PYG{k+kt}{int} \PYG{o}{\PYGZam{}}\PYG{n}{argc}\PYG{p}{,} \PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{n}{string}\PYG{o}{\PYGZgt{}} \PYG{o}{\PYGZam{}}\PYG{n}{comargs}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k+kt}{bool} \PYG{n}{bCheckUser}\PYG{o}{=}\PYG{n+nb}{false}\PYG{p}{;}
    \PYG{k}{if}\PYG{p}{(}\PYG{n}{argc}\PYG{o}{=}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{comargs}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZhy{}e}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{comargs}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{o}{!}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{cerr} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ERROR\PYGZus{}MAIN\PYGZus{}010: Incorrect command line parsing.}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{if}\PYG{p}{(}\PYG{n}{comargs}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{=}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZhy{}h}\PYG{l+s}{\PYGZdq{}}\PYG{o}{\textbar{}}\PYG{o}{\textbar{}}\PYG{n}{comargs}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{=}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZhy{}H}\PYG{l+s}{\PYGZdq{}}\PYG{o}{\textbar{}}\PYG{o}{\textbar{}}\PYG{n}{argc}\PYG{o}{=}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{o}{\textbar{}}\PYG{o}{\textbar{}}\PYG{n}{comargs}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{=}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZhy{}help}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\textbar{}}\PYG{o}{\textbar{}} \PYG{n}{comargs}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{=}\PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZhy{}e}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{c+c1}{// Sort out piping to terminal if verbose has not been defined.}
        \PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifndef verbose}
        \PYG{n}{dup2}\PYG{p}{(}\PYG{n}{saved\PYGZus{}stdout}\PYG{p}{,} \PYG{n}{fileno}\PYG{p}{(}\PYG{n}{stdout}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
        \PYG{c+c1}{//close(saved\PYGZus{}stdout);}
        \PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{argc}\PYG{o}{=}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{No arguments supplied: expected 30. These are: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{else}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{30 command line arguments are required. These are: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{1: the seed for the simulation.}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
        \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{2: the simulation task (for file reference).}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
        \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{3: the map config file.}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
        \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{4: the output directory.}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
        \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{5: the minimum speciation rate.}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
        \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{6: the dispersal z\PYGZus{}fat value.}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
        \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{7: the dispersal L value.}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
        \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{8: the deme size.}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
        \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{9: the deme sample size.}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
        \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{10: the maximum simulation time (in seconds).}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
        \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{11: the lambda value for moving through non\PYGZhy{}habitat.}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
        \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{12: the temporal sampling file containing tab\PYGZhy{}separated generation values for sampling points in time (null for only sampling the present).}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
        \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{13: the minimum number of species known to exist. (Currently has no effect).}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
        \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{14 onwards: speciation rates to apply after simulation.}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
        \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{There is also a full\PYGZhy{}command line mode, (flag \PYGZhy{}f), which allows for more options to be specified via the command line.}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
        \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Would you like to see these options? Y/N: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{flush}\PYG{p}{;}
        \PYG{n}{string} \PYG{n}{fullopts}\PYG{p}{;}
        \PYG{n}{cin} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{fullopts}\PYG{p}{;}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{fullopts} \PYG{o}{=}\PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Y}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\textbar{}}\PYG{o}{\textbar{}} \PYG{n}{fullopts} \PYG{o}{=}\PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{y}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{1: the task\PYGZus{}iter used for setting the seed.}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
            \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{2: the sample grid x dimension.}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
            \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{3: the sample grid y dimension.}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
            \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{4: the fine map file relative path.}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
            \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{5: the fine map x dimension.}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
            \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{6: the fine map y dimension.}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
            \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{7: the fine map x offset.}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
            \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{8 the fine map y offset.}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
            \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{9: the coarse map file relative path.}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
            \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{10: the coarse map x dimension.}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
            \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{11: the coarse map y dimension.}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
            \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{12: the coarse map x offset.}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
            \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{13: the coarse map y offset.}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
            \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{14: the scale of the coarse map compared to the fine (10 means resolution of coarse map = 10 x resolution of fine map).}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
            \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{15: the output directory.}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
            \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{16: the speciation rate.}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
            \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{17: the dispersal distance (zfat).}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
            \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{18: the deme size.}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
            \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{19: the deme sample size (as a proportion of deme size).}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
            \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{20: the time to run the simulation (in seconds).}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
            \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{21: lambda \PYGZhy{} the relative cost of moving through non\PYGZhy{}forest.}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
            \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{22: the\PYGZus{}task \PYGZhy{} for referencing the specific task later on.}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
            \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{23: the minimum number of species the system is known to contain.}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
            \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{24: the pristine fine map file to use.}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
            \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{25: the pristine coarse map file to use.}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
            \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{26: the rate of forest change from pristine.}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
            \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{27: the time (in generations) since the pristine forest was seen.}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
            \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{28: the dispersal L value (the width of the kernel.}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
            \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{29: the sample mask, with binary 1:0 values for areas that we want to sample from. If this is not provided then this will default to mapping the entire grid.}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
            \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{30: a file containing a tab\PYGZhy{}separated list of sample points in time (in generations). If this is null then only the present day will be sampled.}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
            \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{31\PYGZhy{}onwards: speciation rates to be applied at the end of the simulation}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
            \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Note that using the \PYGZhy{}f flag prohibits more than one two historic maps being used.}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Would you like to run with the default settings? (Y/N)}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{flush}\PYG{p}{;}
        \PYG{n}{string} \PYG{n}{cDef}\PYG{p}{;}
        \PYG{n}{cin} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{cDef}\PYG{p}{;}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{cDef} \PYG{o}{=}\PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Y}\PYG{l+s}{\PYGZdq{}}\PYG{o}{\textbar{}}\PYG{o}{\textbar{}}\PYG{n}{cDef}\PYG{o}{=}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{y}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{bCheckUser} \PYG{o}{=} \PYG{n+nb}{true}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{else}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{bCheckUser} \PYG{o}{=} \PYG{n+nb}{false}\PYG{p}{;}
            \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Possible command line arguments: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
            \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZhy{}h/\PYGZhy{}help: Show the help file.}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
            \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZhy{}d/\PYGZhy{}D: Run with default small parameters.}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
            \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZhy{}dl/\PYGZhy{}DL: Run with default large parameters.}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
            \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZhy{}dx/\PYGZhy{}DX: Run with the default very large parameters.}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
            \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZhy{}c/\PYGZhy{}config: Run with the supplied config file.}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
            \PYG{n}{exit}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{// exit the program right away as there is no need to continue if there is no simulation to run!}
        \PYG{p}{\PYGZcb{}}
        \PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifndef verbose}
        \PYG{n}{openLogFile}\PYG{p}{(}\PYG{n+nb}{true}\PYG{p}{)}\PYG{p}{;}
        \PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif}
    \PYG{p}{\PYGZcb{}}
    \PYG{c+c1}{// Import the default parameters if required.}
    \PYG{k}{if}\PYG{p}{(}\PYG{n}{comargs}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{=}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZhy{}d}\PYG{l+s}{\PYGZdq{}}\PYG{o}{\textbar{}}\PYG{o}{\textbar{}}\PYG{n}{comargs}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{=}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZhy{}D}\PYG{l+s}{\PYGZdq{}}\PYG{o}{\textbar{}}\PYG{o}{\textbar{}}\PYG{n}{bCheckUser}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{runAsDefault}\PYG{p}{(}\PYG{n}{comargs}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{bCheckUser}\PYG{o}{=}\PYG{n+nb}{true}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{if}\PYG{p}{(}\PYG{n}{comargs}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{=}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZhy{}dl}\PYG{l+s}{\PYGZdq{}}\PYG{o}{\textbar{}}\PYG{o}{\textbar{}}\PYG{n}{comargs}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{=}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZhy{}DL}\PYG{l+s}{\PYGZdq{}}\PYG{o}{\textbar{}}\PYG{o}{\textbar{}}\PYG{n}{comargs}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{=}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZhy{}dL}\PYG{l+s}{\PYGZdq{}}\PYG{o}{\textbar{}}\PYG{o}{\textbar{}}\PYG{n}{comargs}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{=}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZhy{}Dl}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{runLarge}\PYG{p}{(}\PYG{n}{comargs}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{bCheckUser} \PYG{o}{=} \PYG{n+nb}{true}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{if}\PYG{p}{(}\PYG{n}{comargs}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{=}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZhy{}dx}\PYG{l+s}{\PYGZdq{}}\PYG{o}{\textbar{}}\PYG{o}{\textbar{}}\PYG{n}{comargs}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{=}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZhy{}dX}\PYG{l+s}{\PYGZdq{}}\PYG{o}{\textbar{}}\PYG{o}{\textbar{}}\PYG{n}{comargs}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{=}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZhy{}DX}\PYG{l+s}{\PYGZdq{}}\PYG{o}{\textbar{}}\PYG{o}{\textbar{}}\PYG{n}{comargs}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{=}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZhy{}Dx}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{runXL}\PYG{p}{(}\PYG{n}{comargs}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{bCheckUser} \PYG{o}{=} \PYG{n+nb}{true}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{k+kt}{bool} \PYG{n}{bConfig} \PYG{o}{=} \PYG{n+nb}{false}\PYG{p}{;}
    \PYG{k}{if}\PYG{p}{(}\PYG{n}{comargs}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{=}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZhy{}c}\PYG{l+s}{\PYGZdq{}}\PYG{o}{\textbar{}}\PYG{o}{\textbar{}}\PYG{n}{comargs}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{=}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZhy{}C}\PYG{l+s}{\PYGZdq{}}\PYG{o}{\textbar{}}\PYG{o}{\textbar{}}\PYG{n}{comargs}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{=}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZhy{}config}\PYG{l+s}{\PYGZdq{}}\PYG{o}{\textbar{}}\PYG{o}{\textbar{}} \PYG{n}{comargs}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{=}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZhy{}Config}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{c+c1}{// Check that the config file is supplied.}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{argc}\PYG{o}{!}\PYG{o}{=}\PYG{l+m+mi}{3}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{k}{throw} \PYG{n}{Main\PYGZus{}Exception}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ERROR\PYGZus{}MAIN\PYGZus{}011: FATAL. \PYGZhy{}c or \PYGZhy{}config used to attempt import from config file, but no config file provided.}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{n}{bConfig} \PYG{o}{=} \PYG{n+nb}{true}\PYG{p}{;}
        \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Importing values from config file }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{comargs}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{....}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{flush}\PYG{p}{;}
        \PYG{k}{try}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{n}{string}\PYG{o}{\PYGZgt{}} \PYG{n}{tmp\PYGZus{}comargs} \PYG{o}{=} \PYG{n}{importConfig}\PYG{p}{(}\PYG{n}{comargs}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
            \PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{n}{string}\PYG{o}{\PYGZgt{}} \PYG{n}{tmp2\PYGZus{}comargs}\PYG{p}{;}
            \PYG{n}{tmp2\PYGZus{}comargs}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{n}{comargs}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
            \PYG{n}{tmp2\PYGZus{}comargs}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{n}{comargs}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
            \PYG{n}{tmp2\PYGZus{}comargs}\PYG{p}{.}\PYG{n}{insert}\PYG{p}{(}\PYG{n}{tmp2\PYGZus{}comargs}\PYG{p}{.}\PYG{n}{end}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{n}{tmp\PYGZus{}comargs}\PYG{p}{.}\PYG{n}{begin}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{n}{tmp\PYGZus{}comargs}\PYG{p}{.}\PYG{n}{end}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
            \PYG{n}{comargs} \PYG{o}{=} \PYG{n}{tmp2\PYGZus{}comargs}\PYG{p}{;}
\PYG{c+c1}{//          for(unsigned i = 0; i \PYGZlt{} tmp2\PYGZus{}comargs.size(); i++)}
\PYG{c+c1}{//          \PYGZob{}}
\PYG{c+c1}{//              cout \PYGZlt{}\PYGZlt{} tmp2\PYGZus{}comargs[i] \PYGZlt{}\PYGZlt{} endl;}
\PYG{c+c1}{//          \PYGZcb{}}
            \PYG{n}{argc} \PYG{o}{=} \PYG{n}{comargs}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{c+c1}{//          argc = conf.importConfig(comargs);}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{catch}\PYG{p}{(}\PYG{n}{Config\PYGZus{}Exception}\PYG{o}{\PYGZam{}} \PYG{n}{c\PYGZus{}e}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{cerr} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{c\PYGZus{}e}\PYG{p}{.}\PYG{n}{what}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
            \PYG{k}{throw} \PYG{n+nf}{Fatal\PYGZus{}Exception}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{c+c1}{//cout \PYGZlt{}\PYGZlt{} \PYGZdq{}test\PYGZdq{} \PYGZlt{}\PYGZlt{} endl;}
        \PYG{c+c1}{//cout \PYGZlt{}\PYGZlt{} endl \PYGZlt{}\PYGZlt{} comargs[0] \PYGZlt{}\PYGZlt{} endl;}
        \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{done!}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{k+kt}{bool} \PYG{n}{bFullMode} \PYG{o}{=} \PYG{n+nb}{false}\PYG{p}{;}
    \PYG{k}{if}\PYG{p}{(}\PYG{n}{comargs}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{=}\PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZhy{}f}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\textbar{}}\PYG{o}{\textbar{}} \PYG{n}{comargs}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]} \PYG{o}{=}\PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZhy{}f}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Full command\PYGZhy{}line mode enabled.}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
        \PYG{n}{bFullMode} \PYG{o}{=} \PYG{n+nb}{true}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{n}{removeComOption}\PYG{p}{(}\PYG{n}{argc}\PYG{p}{,} \PYG{n}{comargs}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{removeComOption}\PYG{p}{(}\PYG{n}{argc}\PYG{p}{,} \PYG{n}{comargs}\PYG{p}{)}\PYG{p}{;}
    \PYG{k}{if}\PYG{p}{(}\PYG{n}{argc} \PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{12} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{o}{!}\PYG{n}{bFullMode}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{return}\PYG{p}{(}\PYG{n+nb}{false}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{if}\PYG{p}{(}\PYG{n}{argc}\PYG{o}{\PYGZlt{}}\PYG{l+m+mi}{31}\PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}}\PYG{o}{!}\PYG{n}{bCheckUser} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}}\PYG{o}{!}\PYG{n}{bConfig}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{string} \PYG{n}{err} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ERROR\PYGZus{}MAIN\PYGZus{}000: FATAL.  Incorrect arguments supplied (}\PYG{l+s}{\PYGZdq{}} \PYG{o}{+} \PYG{n}{to\PYGZus{}string}\PYG{p}{(}\PYG{p}{(}\PYG{k+kt}{long} \PYG{k+kt}{long}\PYG{p}{)}\PYG{n}{argc}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)} \PYG{o}{+} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ supplied; expected 30).}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
        \PYG{k}{throw} \PYG{n+nf}{Main\PYGZus{}Exception}\PYG{p}{(}\PYG{n}{err}\PYG{p}{)}\PYG{p}{;}
        \PYG{c+c1}{// note argc\PYGZhy{}1 which takes in to account the automatic generation of one command line argument which is the number of arguments.}
    \PYG{p}{\PYGZcb{}}
    \PYG{n}{argc} \PYG{o}{=} \PYG{n}{comargs}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
    \PYG{k}{return}\PYG{p}{(}\PYG{n+nb}{true}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif}

\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifdef infinite\PYGZus{}landscape}

\PYG{k+kt}{bool} \PYG{n}{parseArgs}\PYG{p}{(}\PYG{k+kt}{int} \PYG{o}{\PYGZam{}}\PYG{n}{argc}\PYG{p}{,} \PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{n}{string}\PYG{o}{\PYGZgt{}} \PYG{o}{\PYGZam{}}\PYG{n}{comargs}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{c+c1}{//bool bCheckUser=false;}
    \PYG{k}{if}\PYG{p}{(}\PYG{n}{argc}\PYG{o}{=}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{comargs}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZhy{}e}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{comargs}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{o}{!}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{cerr} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ERROR\PYGZus{}MAIN\PYGZus{}010: Incorrect command line parsing.}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
    \PYG{p}{\PYGZcb{}}
    \PYG{k+kt}{bool} \PYG{n}{rundef} \PYG{o}{=} \PYG{n+nb}{false}\PYG{p}{;}
    \PYG{k}{if}\PYG{p}{(}\PYG{n}{comargs}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{=}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZhy{}h}\PYG{l+s}{\PYGZdq{}}\PYG{o}{\textbar{}}\PYG{o}{\textbar{}}\PYG{n}{comargs}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{=}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZhy{}H}\PYG{l+s}{\PYGZdq{}}\PYG{o}{\textbar{}}\PYG{o}{\textbar{}}\PYG{n}{argc}\PYG{o}{=}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{o}{\textbar{}}\PYG{o}{\textbar{}}\PYG{n}{comargs}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{=}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZhy{}help}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\textbar{}}\PYG{o}{\textbar{}} \PYG{n}{comargs}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{=}\PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZhy{}e}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifndef verbose}
        \PYG{n}{dup2}\PYG{p}{(}\PYG{n}{saved\PYGZus{}stdout}\PYG{p}{,} \PYG{n}{fileno}\PYG{p}{(}\PYG{n}{stdout}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
        \PYG{c+c1}{//close(saved\PYGZus{}stdout);}
        \PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{argc}\PYG{o}{=}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{No arguments supplied: expected 30. These are: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{else}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{6 command line arguments are required. These are: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{1: the seed for the simulation.}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
        \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{2: the simulation task (for file reference).}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
        \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{3: the output directory.}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
        \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{4: the minimum speciation rate.}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
        \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{5: the dispersal sigma value.}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
        \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{6: the size (width and length) of the simulation.}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
        \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Would you like to run with default variables? Y/N: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{flush}\PYG{p}{;}
        \PYG{n}{string} \PYG{n}{user\PYGZus{}default}\PYG{p}{;}
        \PYG{n}{cin} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{user\PYGZus{}default}\PYG{p}{;}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{user\PYGZus{}default} \PYG{o}{=}\PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Y}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\textbar{}}\PYG{o}{\textbar{}} \PYG{n}{user\PYGZus{}default} \PYG{o}{=}\PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{y}\PYG{l+s}{\PYGZdq{}} \PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{rundef} \PYG{o}{=} \PYG{n+nb}{true}\PYG{p}{;}
            \PYG{n}{comargs}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{1}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
            \PYG{n}{comargs}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{0}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
            \PYG{n}{comargs}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Default}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
            \PYG{n}{comargs}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{0.01}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
            \PYG{n}{comargs}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{4}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
            \PYG{n}{comargs}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{100}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{else}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Nothing to do, exiting.}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
            \PYG{n}{exit}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifndef verbose}
        \PYG{n}{openLogFile}\PYG{p}{(}\PYG{n+nb}{true}\PYG{p}{)}\PYG{p}{;}
        \PYG{c+c1}{//close(saved\PYGZus{}stdout);}
        \PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{if}\PYG{p}{(} \PYG{n}{comargs}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{=}\PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZhy{}d}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\textbar{}}\PYG{o}{\textbar{}} \PYG{n}{comargs}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{=}\PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZhy{}D}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\textbar{}}\PYG{o}{\textbar{}} \PYG{n}{comargs}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{=}\PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZhy{}DX}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\textbar{}}\PYG{o}{\textbar{}} \PYG{n}{comargs}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{=}\PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZhy{}Dx}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\textbar{}}\PYG{o}{\textbar{}} \PYG{n}{comargs}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{=}\PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZhy{}dX}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\textbar{}}\PYG{o}{\textbar{}} \PYG{n}{comargs}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{=}\PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZhy{}dx}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\textbar{}}\PYG{o}{\textbar{}}\PYG{n}{comargs}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{=}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZhy{}dl}\PYG{l+s}{\PYGZdq{}}\PYG{o}{\textbar{}}\PYG{o}{\textbar{}}\PYG{n}{comargs}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{=}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZhy{}DL}\PYG{l+s}{\PYGZdq{}}\PYG{o}{\textbar{}}\PYG{o}{\textbar{}}\PYG{n}{comargs}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{=}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZhy{}dL}\PYG{l+s}{\PYGZdq{}}\PYG{o}{\textbar{}}\PYG{o}{\textbar{}}\PYG{n}{comargs}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{=}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZhy{}Dl}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{n}{string}\PYG{o}{\PYGZgt{}} \PYG{n}{newcomargs}\PYG{p}{;}
        \PYG{n}{runAsDefault}\PYG{p}{(}\PYG{n}{newcomargs}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{comargs} \PYG{o}{=} \PYG{n}{newcomargs}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{if}\PYG{p}{(} \PYG{n}{comargs}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{7}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{n}{string}\PYG{o}{\PYGZgt{}} \PYG{n}{newcomargs}\PYG{p}{;}
        \PYG{n}{runAsDefault}\PYG{p}{(}\PYG{n}{newcomargs}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{newcomargs}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{=} \PYG{n}{comargs}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{;}
        \PYG{n}{newcomargs}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]} \PYG{o}{=} \PYG{n}{comargs}\PYG{p}{[}\PYG{l+m+mi}{6}\PYG{p}{]}\PYG{p}{;}
        \PYG{n}{newcomargs}\PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{]} \PYG{o}{=} \PYG{n}{comargs}\PYG{p}{[}\PYG{l+m+mi}{6}\PYG{p}{]}\PYG{p}{;}
        \PYG{n}{newcomargs}\PYG{p}{[}\PYG{l+m+mi}{5}\PYG{p}{]} \PYG{o}{=} \PYG{n}{comargs}\PYG{p}{[}\PYG{l+m+mi}{6}\PYG{p}{]}\PYG{p}{;}
        \PYG{n}{newcomargs}\PYG{p}{[}\PYG{l+m+mi}{6}\PYG{p}{]} \PYG{o}{=} \PYG{n}{comargs}\PYG{p}{[}\PYG{l+m+mi}{6}\PYG{p}{]}\PYG{p}{;}
        \PYG{n}{newcomargs}\PYG{p}{[}\PYG{l+m+mi}{7}\PYG{p}{]} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{0.0}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
        \PYG{n}{newcomargs}\PYG{p}{[}\PYG{l+m+mi}{8}\PYG{p}{]} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{0.0}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
        \PYG{n}{newcomargs}\PYG{p}{[}\PYG{l+m+mi}{10}\PYG{p}{]} \PYG{o}{=} \PYG{n}{comargs}\PYG{p}{[}\PYG{l+m+mi}{6}\PYG{p}{]}\PYG{p}{;}
        \PYG{n}{newcomargs}\PYG{p}{[}\PYG{l+m+mi}{11}\PYG{p}{]} \PYG{o}{=} \PYG{n}{comargs}\PYG{p}{[}\PYG{l+m+mi}{6}\PYG{p}{]}\PYG{p}{;}
        \PYG{n}{newcomargs}\PYG{p}{[}\PYG{l+m+mi}{12}\PYG{p}{]} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{0.0}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
        \PYG{n}{newcomargs}\PYG{p}{[}\PYG{l+m+mi}{13}\PYG{p}{]} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{0.0}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
        \PYG{n}{newcomargs}\PYG{p}{[}\PYG{l+m+mi}{14}\PYG{p}{]} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{1}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
        \PYG{n}{newcomargs}\PYG{p}{[}\PYG{l+m+mi}{15}\PYG{p}{]} \PYG{o}{=} \PYG{n}{comargs}\PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{;}
        \PYG{n}{newcomargs}\PYG{p}{[}\PYG{l+m+mi}{16}\PYG{p}{]} \PYG{o}{=} \PYG{n}{comargs}\PYG{p}{[}\PYG{l+m+mi}{4}\PYG{p}{]}\PYG{p}{;}
        \PYG{n}{newcomargs}\PYG{p}{[}\PYG{l+m+mi}{17}\PYG{p}{]} \PYG{o}{=} \PYG{n}{comargs}\PYG{p}{[}\PYG{l+m+mi}{5}\PYG{p}{]}\PYG{p}{;}
        \PYG{n}{newcomargs}\PYG{p}{[}\PYG{l+m+mi}{18}\PYG{p}{]} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{1.0}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
        \PYG{n}{newcomargs}\PYG{p}{[}\PYG{l+m+mi}{19}\PYG{p}{]} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{1.0}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
        \PYG{n}{newcomargs}\PYG{p}{[}\PYG{l+m+mi}{20}\PYG{p}{]} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{172800}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
        \PYG{n}{newcomargs}\PYG{p}{[}\PYG{l+m+mi}{22}\PYG{p}{]} \PYG{o}{=} \PYG{n}{comargs}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{;}
        \PYG{n}{newcomargs}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{n}{comargs}\PYG{p}{[}\PYG{l+m+mi}{4}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{string} \PYG{n}{firstcom} \PYG{o}{=} \PYG{n}{comargs}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{;}
        \PYG{n}{comargs}\PYG{p}{.}\PYG{n}{clear}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{comargs}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{n}{firstcom}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{comargs}\PYG{p}{.}\PYG{n}{insert}\PYG{p}{(}\PYG{n}{comargs}\PYG{p}{.}\PYG{n}{end}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{n}{newcomargs}\PYG{p}{.}\PYG{n}{begin}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{n}{newcomargs}\PYG{p}{.}\PYG{n}{end}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
        \PYG{c+c1}{//cout \PYGZlt{}\PYGZlt{} \PYGZdq{}argc: \PYGZsq{}\PYGZdq{} \PYGZlt{}\PYGZlt{} argc \PYGZlt{}\PYGZlt{} endl;}
        \PYG{n}{argc} \PYG{o}{=} \PYG{n}{comargs}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
        \PYG{c+c1}{//cout \PYGZlt{}\PYGZlt{} \PYGZdq{}argc: \PYGZsq{}\PYGZdq{} \PYGZlt{}\PYGZlt{} argc \PYGZlt{}\PYGZlt{} endl;}
    \PYG{p}{\PYGZcb{}}

    \PYG{k+kt}{bool} \PYG{n}{bFullMode} \PYG{o}{=} \PYG{n+nb}{false}\PYG{p}{;}
    \PYG{k}{if}\PYG{p}{(}\PYG{n}{comargs}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{=}\PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZhy{}f}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\textbar{}}\PYG{o}{\textbar{}} \PYG{n}{comargs}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]} \PYG{o}{=}\PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZhy{}f}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Full command\PYGZhy{}line mode enabled.}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
        \PYG{n}{bFullMode} \PYG{o}{=} \PYG{n+nb}{true}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{n}{removeComOption}\PYG{p}{(}\PYG{n}{argc}\PYG{p}{,} \PYG{n}{comargs}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{removeComOption}\PYG{p}{(}\PYG{n}{argc}\PYG{p}{,} \PYG{n}{comargs}\PYG{p}{)}\PYG{p}{;}

    \PYG{k}{if}\PYG{p}{(}\PYG{n}{argc} \PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{12} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{o}{!}\PYG{n}{bFullMode}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{return}\PYG{p}{(}\PYG{n+nb}{false}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{return}\PYG{p}{(}\PYG{n+nb}{true}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif}

\PYG{k+kt}{void} \PYG{n}{getSR}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{argc}\PYG{p}{,}\PYG{k}{const}  \PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{n}{string}\PYG{o}{\PYGZgt{}} \PYG{o}{\PYGZam{}} \PYG{n}{comargs}\PYG{p}{,} \PYG{n}{Tree} \PYG{o}{\PYGZam{}} \PYG{n}{t}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k}{if}\PYG{p}{(}\PYG{n}{argc}\PYG{o}{\PYGZgt{}}\PYG{l+m+mi}{31}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k+kt}{unsigned} \PYG{k+kt}{int} \PYG{n}{iMultiNumber} \PYG{o}{=} \PYG{n}{argc} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{31}\PYG{p}{;}
        \PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{double}\PYG{o}{\PYGZgt{}} \PYG{n}{dSpecArray}\PYG{p}{;}
        \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=}\PYG{l+m+mi}{31}\PYG{p}{;}\PYG{n}{i}\PYG{o}{\PYGZlt{}}\PYG{n}{argc}\PYG{p}{;}\PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{dSpecArray}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{n}{stod}\PYG{p}{(}\PYG{n}{comargs}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Speciation rate}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{flush}\PYG{p}{;}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{dSpecArray}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{1}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{s are: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{flush}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{else}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ is: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{flush}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{int} \PYG{n}{i}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;}\PYG{n}{i}\PYG{o}{\PYGZlt{}}\PYG{n}{iMultiNumber}\PYG{p}{;}\PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{dSpecArray}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{flush}\PYG{p}{;}
            \PYG{k}{if}\PYG{p}{(}\PYG{n}{i} \PYG{o}{+}\PYG{l+m+mi}{1} \PYG{o}{=}\PYG{o}{=} \PYG{n}{iMultiNumber}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{.}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
            \PYG{k}{else}
            \PYG{p}{\PYGZob{}}
                \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{, }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{flush}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
        \PYG{p}{\PYGZcb{}}
        \PYG{c+c1}{// Now check to make sure repeat speciation rates aren\PYGZsq{}t done twice (this is done to avoid the huge number of errors SQL throws if you try to add identical data}
        \PYG{k+kt}{double} \PYG{n}{dUniqueSpec}\PYG{p}{[}\PYG{n}{iMultiNumber}\PYG{p}{]}\PYG{p}{;}
        \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{spec\PYGZus{}upto} \PYG{o}{=} \PYG{n}{t}\PYG{p}{.}\PYG{n}{sortData}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{t}\PYG{p}{.}\PYG{n}{sqlCreate}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;}\PYG{n}{i}\PYG{o}{\PYGZlt{}}\PYG{n}{iMultiNumber}\PYG{p}{;}\PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{k+kt}{bool} \PYG{n}{bCont} \PYG{o}{=} \PYG{n+nb}{true}\PYG{p}{;}
            \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{int} \PYG{n}{j} \PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;}\PYG{n}{j}\PYG{o}{\PYGZlt{}}\PYG{n}{iMultiNumber}\PYG{p}{;}\PYG{n}{j}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{k}{if}\PYG{p}{(}\PYG{n}{dUniqueSpec}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{o}{=}\PYG{o}{=}\PYG{n}{dSpecArray}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}
                \PYG{p}{\PYGZob{}}
                    \PYG{n}{bCont} \PYG{o}{=} \PYG{n+nb}{false}\PYG{p}{;}
                \PYG{p}{\PYGZcb{}}
            \PYG{p}{\PYGZcb{}}
            \PYG{k}{if}\PYG{p}{(}\PYG{n}{bCont}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{double}\PYG{o}{\PYGZgt{}} \PYG{n}{temp\PYGZus{}sampling} \PYG{o}{=} \PYG{n}{t}\PYG{p}{.}\PYG{n}{getTemporalSampling}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
                \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{n}{k} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{k} \PYG{o}{\PYGZlt{}} \PYG{n}{temp\PYGZus{}sampling}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{n}{k}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
                \PYG{p}{\PYGZob{}}
                    \PYG{k}{try}
                    \PYG{p}{\PYGZob{}}
                        \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Calculating generation }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{temp\PYGZus{}sampling}\PYG{p}{[}\PYG{n}{k}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
                        \PYG{n}{t}\PYG{p}{.}\PYG{n}{applySpecRates}\PYG{p}{(}\PYG{n}{dSpecArray}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{,} \PYG{n}{temp\PYGZus{}sampling}\PYG{p}{[}\PYG{n}{k}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
                    \PYG{p}{\PYGZcb{}}
                    \PYG{k}{catch}\PYG{p}{(}\PYG{k}{const} \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{exception} \PYG{o}{\PYGZam{}} \PYG{n}{e}\PYG{p}{)}
                    \PYG{p}{\PYGZob{}}
                        \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{e}\PYG{p}{.}\PYG{n}{what}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
                    \PYG{p}{\PYGZcb{}}
                \PYG{p}{\PYGZcb{}}
            \PYG{p}{\PYGZcb{}}
            \PYG{k}{else}
            \PYG{p}{\PYGZob{}}
                \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Repeat speciation rate... ignoring}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
        \PYG{p}{\PYGZcb{}}
        \PYG{n}{t}\PYG{p}{.}\PYG{n}{outputData}\PYG{p}{(}\PYG{n}{spec\PYGZus{}upto}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{else}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{t}\PYG{p}{.}\PYG{n}{sqlCreate}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{t}\PYG{p}{.}\PYG{n}{outputData}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{return}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}


\PYG{k+kt}{bool} \PYG{n}{doesExist}\PYG{p}{(}\PYG{n}{string} \PYG{n}{testfile}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k}{if}\PYG{p}{(}\PYG{n}{boost}\PYG{o}{:}\PYG{o}{:}\PYG{n}{filesystem}\PYG{o}{:}\PYG{o}{:}\PYG{n}{exists}\PYG{p}{(}\PYG{n}{testfile}\PYG{p}{)}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
            \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}r}\PYG{l+s}{Checking folder existance...}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{testfile} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ exists!               }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{flush}\PYG{p}{;}
        \PYG{k}{return} \PYG{n+nb}{true}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{else}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{testfile} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ does not exist!               }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
        \PYG{k}{throw} \PYG{n+nf}{runtime\PYGZus{}error}\PYG{p}{(}\PYG{n}{string}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ERROR\PYGZus{}MAIN\PYGZus{}008: FATAL. Input or output folder does not exist: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{+} \PYG{n}{testfile} \PYG{o}{+} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{.}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{return} \PYG{n+nb}{false}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{bool} \PYG{n}{doesExistNull}\PYG{p}{(}\PYG{n}{string} \PYG{n}{testfile}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k}{if}\PYG{p}{(}\PYG{n}{testfile}\PYG{o}{=}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{null}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{return}\PYG{p}{(}\PYG{n+nb}{true}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{else}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{return}\PYG{p}{(}\PYG{n}{doesExist}\PYG{p}{(}\PYG{n}{testfile}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}


\subparagraph{Includes}
\label{\detokenize{Exhaled/exhale_file_Setup.cpp:includes}}\begin{itemize}
\item {} 
\sphinxcode{Setup.h} ({\hyperref[\detokenize{Exhaled/exhale_file_Setup.h:file-setup-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File Setup.h}}}})

\end{itemize}


\subparagraph{Functions}
\label{\detokenize{Exhaled/exhale_file_Setup.cpp:functions}}\begin{itemize}
\item {} 
{\hyperref[\detokenize{Exhaled/exhale_function_charconvertor:function-charconvertor}]{\sphinxcrossref{\DUrole{std,std-ref}{Function charconvertor}}}}

\item {} 
{\hyperref[\detokenize{Exhaled/exhale_function_checkFolders:function-checkfolders}]{\sphinxcrossref{\DUrole{std,std-ref}{Function checkFolders}}}}

\item {} 
{\hyperref[\detokenize{Exhaled/exhale_function_checkSims:function-checksims}]{\sphinxcrossref{\DUrole{std,std-ref}{Function checkSims}}}}

\item {} 
{\hyperref[\detokenize{Exhaled/exhale_function_doesExist:function-doesexist}]{\sphinxcrossref{\DUrole{std,std-ref}{Function doesExist}}}}

\item {} 
{\hyperref[\detokenize{Exhaled/exhale_function_doesExistNull:function-doesexistnull}]{\sphinxcrossref{\DUrole{std,std-ref}{Function doesExistNull}}}}

\item {} 
{\hyperref[\detokenize{Exhaled/exhale_function_getSR:function-getsr}]{\sphinxcrossref{\DUrole{std,std-ref}{Function getSR}}}}

\item {} 
{\hyperref[\detokenize{Exhaled/exhale_function_importConfig:function-importconfig}]{\sphinxcrossref{\DUrole{std,std-ref}{Function importConfig}}}}

\item {} 
{\hyperref[\detokenize{Exhaled/exhale_function_jobConvertor:function-jobconvertor}]{\sphinxcrossref{\DUrole{std,std-ref}{Function jobConvertor}}}}

\item {} 
{\hyperref[\detokenize{Exhaled/exhale_function_openLogFile:function-openlogfile}]{\sphinxcrossref{\DUrole{std,std-ref}{Function openLogFile}}}}

\item {} 
{\hyperref[\detokenize{Exhaled/exhale_function_parseArgs:function-parseargs}]{\sphinxcrossref{\DUrole{std,std-ref}{Function parseArgs}}}}

\item {} 
{\hyperref[\detokenize{Exhaled/exhale_function_removeComOption:function-removecomoption}]{\sphinxcrossref{\DUrole{std,std-ref}{Function removeComOption}}}}

\item {} 
{\hyperref[\detokenize{Exhaled/exhale_function_runAsDefault:function-runasdefault}]{\sphinxcrossref{\DUrole{std,std-ref}{Function runAsDefault}}}}

\item {} 
{\hyperref[\detokenize{Exhaled/exhale_function_runLarge:function-runlarge}]{\sphinxcrossref{\DUrole{std,std-ref}{Function runLarge}}}}

\item {} 
{\hyperref[\detokenize{Exhaled/exhale_function_runXL:function-runxl}]{\sphinxcrossref{\DUrole{std,std-ref}{Function runXL}}}}

\end{itemize}


\subparagraph{Variables}
\label{\detokenize{Exhaled/exhale_file_Setup.cpp:variables}}\begin{itemize}
\item {} 
{\hyperref[\detokenize{Exhaled/exhale_variable_log_name:variable-log-name}]{\sphinxcrossref{\DUrole{std,std-ref}{Variable log\_name}}}}

\item {} 
{\hyperref[\detokenize{Exhaled/exhale_variable_saved_stdout:variable-saved-stdout}]{\sphinxcrossref{\DUrole{std,std-ref}{Variable saved\_stdout}}}}

\end{itemize}


\paragraph{File Setup.h}
\label{\detokenize{Exhaled/exhale_file_Setup.h:file-setup-h}}\label{\detokenize{Exhaled/exhale_file_Setup.h::doc}}\label{\detokenize{Exhaled/exhale_file_Setup.h:id1}}

\subparagraph{Definition (\sphinxstyleliteralintitle{Setup.h})}
\label{\detokenize{Exhaled/exhale_file_Setup.h:definition-setup-h}}

\subparagraph{Program Listing for File Setup.h}
\label{\detokenize{Exhaled/exhale_program_listing_file_Setup.h:program-listing-file-setup-h}}\label{\detokenize{Exhaled/exhale_program_listing_file_Setup.h::doc}}\label{\detokenize{Exhaled/exhale_program_listing_file_Setup.h:program-listing-for-file-setup-h}}\begin{itemize}
\item {} 
Return to documentation for {\hyperref[\detokenize{Exhaled/exhale_file_Setup.h:file-setup-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File Setup.h}}}}

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{//This file is part of NECSim project which is released under BSD\PYGZhy{}3 license.}
\PYG{c+c1}{//See file **LICENSE.txt** or visit https://opensource.org/licenses/BSD\PYGZhy{}3\PYGZhy{}Clause) for full license details.}
\PYG{c+c1}{//}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifndef SETUP}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define SETUP}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}string\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}vector\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}unistd.h\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}sstream\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}ctime\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}boost/filesystem.hpp\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}stdio.h\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}time.h\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}iostream\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}iomanip\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZdq{}Tree.h\PYGZdq{}}

\PYG{c+c1}{// Forward declaring the global variables}
\PYG{c+c1}{// store the log file name for access anywhere.}
\PYG{k}{extern} \PYG{n}{string} \PYG{n}{log\PYGZus{}name}\PYG{p}{;}
\PYG{c+c1}{// the old stdout}
\PYG{k}{extern} \PYG{k+kt}{int} \PYG{n}{saved\PYGZus{}stdout}\PYG{p}{;}
\PYG{k}{using} \PYG{k}{namespace} \PYG{n}{std}\PYG{p}{;}
\PYG{k+kt}{long} \PYG{n+nf}{charconvertor}\PYG{p}{(}\PYG{k+kt}{char} \PYG{n}{charin}\PYG{p}{)}\PYG{p}{;}

\PYG{k+kt}{long} \PYG{n+nf}{jobConvertor}\PYG{p}{(}\PYG{k+kt}{char} \PYG{o}{*} \PYG{n}{argin}\PYG{p}{)}\PYG{p}{;}

\PYG{k+kt}{void} \PYG{n+nf}{checkFolders}\PYG{p}{(}\PYG{n}{string} \PYG{n}{sFineMap}\PYG{p}{,} \PYG{n}{string} \PYG{n}{sCoarseMap}\PYG{p}{,} \PYG{n}{string} \PYG{n}{sFineMapPristine}\PYG{p}{,} \PYG{n}{string} \PYG{n}{sCoarseMapPristine}\PYG{p}{,} \PYG{n}{string} \PYG{n}{sOutputFolder}\PYG{p}{,} \PYG{n}{string} \PYG{n}{sSampleMask}\PYG{p}{)}\PYG{p}{;}

\PYG{k+kt}{bool} \PYG{n+nf}{checkSims}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{the\PYGZus{}task}\PYG{p}{,} \PYG{k+kt}{int} \PYG{n}{the\PYGZus{}seed}\PYG{p}{,} \PYG{n}{string} \PYG{n}{outdirect}\PYG{p}{)}\PYG{p}{;}

\PYG{k+kt}{void} \PYG{n+nf}{getSR}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{argc}\PYG{p}{,} \PYG{k}{const} \PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{n}{string}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZam{}}\PYG{n}{comargs}\PYG{p}{,}\PYG{n}{Tree}\PYG{o}{\PYGZam{}}\PYG{n}{t}\PYG{p}{)}\PYG{p}{;}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifndef verbose}
\PYG{k+kt}{void} \PYG{n+nf}{openLogFile}\PYG{p}{(}\PYG{k+kt}{bool} \PYG{n}{append}\PYG{p}{)}\PYG{p}{;}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif}
\PYG{k+kt}{bool} \PYG{n+nf}{parseArgs}\PYG{p}{(}\PYG{k+kt}{int}\PYG{o}{\PYGZam{}} \PYG{n}{argc}\PYG{p}{,} \PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{n}{string}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZam{}} \PYG{n}{comargs}\PYG{p}{)}\PYG{p}{;}

\PYG{k+kt}{void} \PYG{n+nf}{removeComOption}\PYG{p}{(}\PYG{k+kt}{int}\PYG{o}{\PYGZam{}} \PYG{n}{argc}\PYG{p}{,} \PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{n}{string}\PYG{o}{\PYGZgt{}} \PYG{o}{\PYGZam{}} \PYG{n}{comargs}\PYG{p}{)}\PYG{p}{;}

\PYG{k+kt}{void} \PYG{n+nf}{runAsDefault}\PYG{p}{(}\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{n}{string}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZam{}}\PYG{n}{comargs}\PYG{p}{)}\PYG{p}{;}

\PYG{k+kt}{void} \PYG{n+nf}{runLarge}\PYG{p}{(}\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{n}{string}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZam{}}\PYG{n}{comargs}\PYG{p}{)}\PYG{p}{;}

\PYG{k+kt}{void} \PYG{n+nf}{runXL}\PYG{p}{(}\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{n}{string}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZam{}}\PYG{n}{comargs}\PYG{p}{)}\PYG{p}{;}

\PYG{k+kt}{bool} \PYG{n+nf}{doesExist}\PYG{p}{(}\PYG{n}{string} \PYG{n}{testfile}\PYG{p}{)}\PYG{p}{;}

\PYG{k+kt}{bool} \PYG{n+nf}{doesExistNull}\PYG{p}{(}\PYG{n}{string} \PYG{n}{testfile}\PYG{p}{)}\PYG{p}{;}

\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif }\PYG{c+c1}{// SETUP}
\end{sphinxVerbatim}


\subparagraph{Includes}
\label{\detokenize{Exhaled/exhale_file_Setup.h:includes}}\begin{itemize}
\item {} 
\sphinxcode{Tree.h} ({\hyperref[\detokenize{Exhaled/exhale_file_Tree.h:file-tree-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File Tree.h}}}})

\item {} 
\sphinxcode{boost/filesystem.hpp}

\item {} 
\sphinxcode{ctime}

\item {} 
\sphinxcode{iomanip}

\item {} 
\sphinxcode{iostream}

\item {} 
\sphinxcode{sstream}

\item {} 
\sphinxcode{stdio.h}

\item {} 
\sphinxcode{string}

\item {} 
\sphinxcode{time.h}

\item {} 
\sphinxcode{unistd.h}

\item {} 
\sphinxcode{vector}

\end{itemize}


\subparagraph{Included By}
\label{\detokenize{Exhaled/exhale_file_Setup.h:included-by}}\begin{itemize}
\item {} 
{\hyperref[\detokenize{Exhaled/exhale_file_main.cpp:file-main-cpp}]{\sphinxcrossref{\DUrole{std,std-ref}{File main.cpp}}}}

\item {} 
{\hyperref[\detokenize{Exhaled/exhale_file_Map.cpp:file-map-cpp}]{\sphinxcrossref{\DUrole{std,std-ref}{File Map.cpp}}}}

\item {} 
{\hyperref[\detokenize{Exhaled/exhale_file_Setup.cpp:file-setup-cpp}]{\sphinxcrossref{\DUrole{std,std-ref}{File Setup.cpp}}}}

\item {} 
{\hyperref[\detokenize{Exhaled/exhale_file_SpeciationCounter.cpp:file-speciationcounter-cpp}]{\sphinxcrossref{\DUrole{std,std-ref}{File SpeciationCounter.cpp}}}}

\end{itemize}


\subparagraph{Functions}
\label{\detokenize{Exhaled/exhale_file_Setup.h:functions}}\begin{itemize}
\item {} 
{\hyperref[\detokenize{Exhaled/exhale_function_charconvertor:function-charconvertor}]{\sphinxcrossref{\DUrole{std,std-ref}{Function charconvertor}}}}

\item {} 
{\hyperref[\detokenize{Exhaled/exhale_function_checkFolders:function-checkfolders}]{\sphinxcrossref{\DUrole{std,std-ref}{Function checkFolders}}}}

\item {} 
{\hyperref[\detokenize{Exhaled/exhale_function_checkSims:function-checksims}]{\sphinxcrossref{\DUrole{std,std-ref}{Function checkSims}}}}

\item {} 
{\hyperref[\detokenize{Exhaled/exhale_function_doesExist:function-doesexist}]{\sphinxcrossref{\DUrole{std,std-ref}{Function doesExist}}}}

\item {} 
{\hyperref[\detokenize{Exhaled/exhale_function_doesExistNull:function-doesexistnull}]{\sphinxcrossref{\DUrole{std,std-ref}{Function doesExistNull}}}}

\item {} 
{\hyperref[\detokenize{Exhaled/exhale_function_getSR:function-getsr}]{\sphinxcrossref{\DUrole{std,std-ref}{Function getSR}}}}

\item {} 
{\hyperref[\detokenize{Exhaled/exhale_function_jobConvertor:function-jobconvertor}]{\sphinxcrossref{\DUrole{std,std-ref}{Function jobConvertor}}}}

\item {} 
{\hyperref[\detokenize{Exhaled/exhale_function_openLogFile:function-openlogfile}]{\sphinxcrossref{\DUrole{std,std-ref}{Function openLogFile}}}}

\item {} 
{\hyperref[\detokenize{Exhaled/exhale_function_parseArgs:function-parseargs}]{\sphinxcrossref{\DUrole{std,std-ref}{Function parseArgs}}}}

\item {} 
{\hyperref[\detokenize{Exhaled/exhale_function_removeComOption:function-removecomoption}]{\sphinxcrossref{\DUrole{std,std-ref}{Function removeComOption}}}}

\item {} 
{\hyperref[\detokenize{Exhaled/exhale_function_runAsDefault:function-runasdefault}]{\sphinxcrossref{\DUrole{std,std-ref}{Function runAsDefault}}}}

\item {} 
{\hyperref[\detokenize{Exhaled/exhale_function_runLarge:function-runlarge}]{\sphinxcrossref{\DUrole{std,std-ref}{Function runLarge}}}}

\item {} 
{\hyperref[\detokenize{Exhaled/exhale_function_runXL:function-runxl}]{\sphinxcrossref{\DUrole{std,std-ref}{Function runXL}}}}

\end{itemize}


\subparagraph{Variables}
\label{\detokenize{Exhaled/exhale_file_Setup.h:variables}}\begin{itemize}
\item {} 
{\hyperref[\detokenize{Exhaled/exhale_variable_log_name:variable-log-name}]{\sphinxcrossref{\DUrole{std,std-ref}{Variable log\_name}}}}

\item {} 
{\hyperref[\detokenize{Exhaled/exhale_variable_saved_stdout:variable-saved-stdout}]{\sphinxcrossref{\DUrole{std,std-ref}{Variable saved\_stdout}}}}

\end{itemize}


\paragraph{File SpeciationCounter.cpp}
\label{\detokenize{Exhaled/exhale_file_SpeciationCounter.cpp:file-speciationcounter-cpp}}\label{\detokenize{Exhaled/exhale_file_SpeciationCounter.cpp::doc}}\label{\detokenize{Exhaled/exhale_file_SpeciationCounter.cpp:id1}}

\subparagraph{Definition (\sphinxstyleliteralintitle{SpeciationCounter.cpp})}
\label{\detokenize{Exhaled/exhale_file_SpeciationCounter.cpp:definition-speciationcounter-cpp}}

\subparagraph{Program Listing for File SpeciationCounter.cpp}
\label{\detokenize{Exhaled/exhale_program_listing_file_SpeciationCounter.cpp:program-listing-file-speciationcounter-cpp}}\label{\detokenize{Exhaled/exhale_program_listing_file_SpeciationCounter.cpp::doc}}\label{\detokenize{Exhaled/exhale_program_listing_file_SpeciationCounter.cpp:program-listing-for-file-speciationcounter-cpp}}\begin{itemize}
\item {} 
Return to documentation for {\hyperref[\detokenize{Exhaled/exhale_file_SpeciationCounter.cpp:file-speciationcounter-cpp}]{\sphinxcrossref{\DUrole{std,std-ref}{File SpeciationCounter.cpp}}}}

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{//This file is part of NECSim project which is released under BSD\PYGZhy{}3 license.}
\PYG{c+c1}{//See file **LICENSE.txt** or visit https://opensource.org/licenses/BSD\PYGZhy{}3\PYGZhy{}Clause) for full license details.}

\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}stdio.h\PYGZgt{}}
\PYG{c+c1}{//\PYGZsh{}include \PYGZdq{}fast\PYGZhy{}cpp\PYGZhy{}csv\PYGZhy{}parser/csv.h\PYGZdq{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZdq{}Treelist.h\PYGZdq{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZdq{}Config.h\PYGZdq{} // Just for the importing of command\PYGZhy{}line arguments for now. Later on parsing parameters from a file might be implemented.}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZdq{}Setup.h\PYGZdq{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}boost/filesystem.hpp\PYGZgt{}}


\PYG{k}{using} \PYG{k}{namespace} \PYG{n}{std}\PYG{p}{;}
\PYG{c+c1}{// INPUTS}
\PYG{c+c1}{// requires a SQL database file containing the the Treenode objects from a coalescence simulations.}
\PYG{c+c1}{// the required speciation rate.}

\PYG{c+c1}{// OUTPUTS}
\PYG{c+c1}{// An updated database file that contains the species richness and species abundances of the intended lineage.}

\PYG{k}{struct} \PYG{n}{simParameters}
\PYG{p}{\PYGZob{}}
    \PYG{k+kt}{bool} \PYG{n}{RecordSpatial}\PYG{p}{;}
    \PYG{k+kt}{bool} \PYG{n}{bMultiRun}\PYG{p}{;}
    \PYG{k+kt}{bool} \PYG{n}{RecordFragments}\PYG{p}{;}
    \PYG{n}{string} \PYG{n}{filename}\PYG{p}{;}
    \PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{double}\PYG{o}{\PYGZgt{}} \PYG{n}{vSpecRates}\PYG{p}{;}
    \PYG{n}{string} \PYG{n}{samplemask}\PYG{p}{;}
    \PYG{n}{string} \PYG{n}{autocorrel\PYGZus{}file}\PYG{p}{;}
    \PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{double}\PYG{o}{\PYGZgt{}} \PYG{n}{autocorrel\PYGZus{}times}\PYG{p}{;}
    \PYG{k+kt}{bool} \PYG{n}{bAuto}\PYG{p}{;}
    \PYG{n}{string} \PYG{n}{fragment\PYGZus{}config\PYGZus{}file}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}

\PYG{k+kt}{void} \PYG{n+nf}{parseArgs}\PYG{p}{(}\PYG{k+kt}{int} \PYG{o}{\PYGZam{}}\PYG{n}{argc}\PYG{p}{,} \PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{n}{string}\PYG{o}{\PYGZgt{}} \PYG{o}{\PYGZam{}}\PYG{n}{comargs}\PYG{p}{,} \PYG{n}{simParameters} \PYG{o}{\PYGZam{}}\PYG{n}{sp}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k+kt}{bool} \PYG{n}{bRunDefault}\PYG{o}{=}\PYG{n+nb}{false}\PYG{p}{;}
    \PYG{k+kt}{bool} \PYG{n}{bInvalidArguments} \PYG{o}{=} \PYG{n+nb}{false}\PYG{p}{;}
    \PYG{k+kt}{bool} \PYG{n}{bAskHelp} \PYG{o}{=} \PYG{n+nb}{false}\PYG{p}{;}
    \PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifndef verbose}
    \PYG{n}{dup2}\PYG{p}{(}\PYG{n}{saved\PYGZus{}stdout}\PYG{p}{,} \PYG{n}{fileno}\PYG{p}{(}\PYG{n}{stdout}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
    \PYG{c+c1}{//close(saved\PYGZus{}stdout);}
    \PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif}
    \PYG{k}{if}\PYG{p}{(}\PYG{n}{argc}\PYG{o}{\PYGZlt{}}\PYG{l+m+mi}{7}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{argc} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{bInvalidArguments} \PYG{o}{=} \PYG{n+nb}{true}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{n}{bInvalidArguments} \PYG{o}{=} \PYG{n+nb}{true}\PYG{p}{;}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{argc}\PYG{o}{=}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{k}{if}\PYG{p}{(}\PYG{p}{(}\PYG{n}{comargs}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}\PYG{o}{=}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZhy{}d}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{n}{bInvalidArguments} \PYG{o}{=} \PYG{n+nb}{false}\PYG{p}{;}
                \PYG{n}{bRunDefault} \PYG{o}{=} \PYG{n+nb}{true}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
            \PYG{k}{if}\PYG{p}{(}\PYG{n}{comargs}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{=}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZhy{}h}\PYG{l+s}{\PYGZdq{}}\PYG{o}{\textbar{}}\PYG{o}{\textbar{}}\PYG{n}{comargs}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{=}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZhy{}help}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{n}{bInvalidArguments} \PYG{o}{=} \PYG{n+nb}{false}\PYG{p}{;}
                \PYG{n}{bAskHelp} \PYG{o}{=} \PYG{n+nb}{true}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{bInvalidArguments}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Incorrect number of arguments.}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
            \PYG{n}{bInvalidArguments} \PYG{o}{=} \PYG{n+nb}{true}\PYG{p}{;}
            \PYG{k}{if}\PYG{p}{(}\PYG{n}{argc} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{n}{comargs}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZhy{}e}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
            \PYG{k}{else}
            \PYG{p}{\PYGZob{}}
                \PYG{n}{comargs}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZhy{}e}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
        \PYG{p}{\PYGZcb{}}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{else}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{sp}\PYG{p}{.}\PYG{n}{samplemask} \PYG{o}{=} \PYG{n}{comargs}\PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{;}
        \PYG{n}{sp}\PYG{p}{.}\PYG{n}{filename} \PYG{o}{=} \PYG{n}{comargs}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{;}
        \PYG{n}{sp}\PYG{p}{.}\PYG{n}{autocorrel\PYGZus{}file} \PYG{o}{=} \PYG{n}{comargs}\PYG{p}{[}\PYG{l+m+mi}{4}\PYG{p}{]}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{if}\PYG{p}{(}\PYG{n}{argc}\PYG{o}{\PYGZgt{}}\PYG{l+m+mi}{7}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{sp}\PYG{p}{.}\PYG{n}{bMultiRun} \PYG{o}{=} \PYG{n+nb}{true}\PYG{p}{;}
        \PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{6}\PYG{p}{;}
        \PYG{k}{while}\PYG{p}{(}\PYG{n}{i}\PYG{o}{\PYGZlt{}}\PYG{n}{argc}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{sp}\PYG{p}{.}\PYG{n}{vSpecRates}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{n}{stof}\PYG{p}{(}\PYG{n}{comargs}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
            \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{else} \PYG{k}{if}\PYG{p}{(}\PYG{n}{argc} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{7} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{o}{!}\PYG{n}{bInvalidArguments} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{o}{!}\PYG{n}{bAskHelp}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{sp}\PYG{p}{.}\PYG{n}{bMultiRun} \PYG{o}{=} \PYG{n+nb}{false}\PYG{p}{;}
        \PYG{n}{sp}\PYG{p}{.}\PYG{n}{vSpecRates}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{n}{stod}\PYG{p}{(}\PYG{n}{comargs}\PYG{p}{[}\PYG{l+m+mi}{6}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{if}\PYG{p}{(}\PYG{o}{!}\PYG{n}{bInvalidArguments} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{o}{!}\PYG{n}{bAskHelp} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{o}{!}\PYG{n}{bRunDefault}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{comargs}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]} \PYG{o}{=}\PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{true}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\textbar{}}\PYG{o}{\textbar{}} \PYG{n}{comargs}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]} \PYG{o}{=}\PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{True}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\textbar{}}\PYG{o}{\textbar{}} \PYG{n}{comargs}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]} \PYG{o}{=}\PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{T}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\textbar{}}\PYG{o}{\textbar{}} \PYG{n}{comargs}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]} \PYG{o}{=}\PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{TRUE}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\textbar{}}\PYG{o}{\textbar{}} \PYG{n}{comargs}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]} \PYG{o}{=}\PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{t}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{sp}\PYG{p}{.}\PYG{n}{RecordSpatial} \PYG{o}{=} \PYG{n+nb}{true}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{else}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{sp}\PYG{p}{.}\PYG{n}{RecordSpatial} \PYG{o}{=} \PYG{n+nb}{false}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{comargs}\PYG{p}{[}\PYG{l+m+mi}{5}\PYG{p}{]} \PYG{o}{=}\PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{false}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\textbar{}}\PYG{o}{\textbar{}} \PYG{n}{comargs}\PYG{p}{[}\PYG{l+m+mi}{5}\PYG{p}{]} \PYG{o}{=}\PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{False}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\textbar{}}\PYG{o}{\textbar{}} \PYG{n}{comargs}\PYG{p}{[}\PYG{l+m+mi}{5}\PYG{p}{]} \PYG{o}{=}\PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{F}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\textbar{}}\PYG{o}{\textbar{}} \PYG{n}{comargs}\PYG{p}{[}\PYG{l+m+mi}{5}\PYG{p}{]} \PYG{o}{=}\PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{FALSE}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\textbar{}}\PYG{o}{\textbar{}} \PYG{n}{comargs}\PYG{p}{[}\PYG{l+m+mi}{5}\PYG{p}{]} \PYG{o}{=}\PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{f}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{sp}\PYG{p}{.}\PYG{n}{RecordFragments} \PYG{o}{=} \PYG{n+nb}{false}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{else}
        \PYG{p}{\PYGZob{}}
            \PYG{k}{if}\PYG{p}{(}\PYG{n}{comargs}\PYG{p}{[}\PYG{l+m+mi}{5}\PYG{p}{]} \PYG{o}{=}\PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{true}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\textbar{}}\PYG{o}{\textbar{}} \PYG{n}{comargs}\PYG{p}{[}\PYG{l+m+mi}{5}\PYG{p}{]} \PYG{o}{=}\PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{True}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\textbar{}}\PYG{o}{\textbar{}} \PYG{n}{comargs}\PYG{p}{[}\PYG{l+m+mi}{5}\PYG{p}{]} \PYG{o}{=}\PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{T}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\textbar{}}\PYG{o}{\textbar{}} \PYG{n}{comargs}\PYG{p}{[}\PYG{l+m+mi}{5}\PYG{p}{]} \PYG{o}{=}\PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{TRUE}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\textbar{}}\PYG{o}{\textbar{}} \PYG{n}{comargs}\PYG{p}{[}\PYG{l+m+mi}{5}\PYG{p}{]} \PYG{o}{=}\PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{t}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{n}{sp}\PYG{p}{.}\PYG{n}{fragment\PYGZus{}config\PYGZus{}file} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{null}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
            \PYG{k}{else}
            \PYG{p}{\PYGZob{}}
                \PYG{n}{sp}\PYG{p}{.}\PYG{n}{fragment\PYGZus{}config\PYGZus{}file} \PYG{o}{=} \PYG{n}{comargs}\PYG{p}{[}\PYG{l+m+mi}{5}\PYG{p}{]}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
            \PYG{n}{sp}\PYG{p}{.}\PYG{n}{RecordFragments} \PYG{o}{=} \PYG{n+nb}{true}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{if}\PYG{p}{(}\PYG{n}{bInvalidArguments}\PYG{o}{\textbar{}}\PYG{o}{\textbar{}}\PYG{n}{bAskHelp}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{At least six command\PYGZhy{}line arguments are expected.}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
        \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{1 \PYGZhy{} Path to SQL database file.}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
        \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{2 \PYGZhy{} T/F of whether to record full spatial data.}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
        \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{3 \PYGZhy{} the sample mask to use (use null if no mask is to be used)}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
        \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{4 \PYGZhy{} the file containing tempororal points of interest. If null, the present is used for all calculations.}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
        \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{5 \PYGZhy{} T/F of whether to calculate abundances for each rectangular fragment. Alternatively, provide a csv file with fragment data to be read.}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
        \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{6 \PYGZhy{} Speciation rate.}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
        \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{7 \PYGZhy{} onwards \PYGZhy{} Further speciation rates. [OPTIONAL]}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
        \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Would you like to run with the default paramenters?}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
        \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{       (This requires a SQL database file at ../../Data/Coal\PYGZus{}sim/Test\PYGZus{}output/SQL\PYGZus{}data/data\PYGZus{}0\PYGZus{}1.db)}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
        \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Enter Y/N: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{flush}\PYG{p}{;}
        \PYG{n}{string} \PYG{n}{sDef}\PYG{p}{;}
        \PYG{n}{cin} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{sDef}\PYG{p}{;}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{sDef}\PYG{o}{=}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Y}\PYG{l+s}{\PYGZdq{}}\PYG{o}{\textbar{}}\PYG{o}{\textbar{}}\PYG{n}{sDef}\PYG{o}{=}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{y}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{bRunDefault} \PYG{o}{=} \PYG{n+nb}{true}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{else}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{bRunDefault} \PYG{o}{=} \PYG{n+nb}{false}\PYG{p}{;}
            \PYG{n}{exit}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{if}\PYG{p}{(}\PYG{n}{comargs}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{=}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZhy{}d}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\textbar{}}\PYG{o}{\textbar{}} \PYG{n}{bRunDefault}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{sp}\PYG{p}{.}\PYG{n}{filename}\PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{../../Data/Coal\PYGZus{}sim/Test\PYGZus{}output/SQL\PYGZus{}data/data\PYGZus{}0\PYGZus{}1.db}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
        \PYG{n}{sp}\PYG{p}{.}\PYG{n}{vSpecRates}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{l+m+mf}{0.001}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{sp}\PYG{p}{.}\PYG{n}{samplemask} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{null}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
        \PYG{n}{sp}\PYG{p}{.}\PYG{n}{autocorrel\PYGZus{}file} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{null}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
        \PYG{n}{sp}\PYG{p}{.}\PYG{n}{fragment\PYGZus{}config\PYGZus{}file} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{null}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
        \PYG{n}{sp}\PYG{p}{.}\PYG{n}{RecordFragments} \PYG{o}{=} \PYG{n+nb}{false}\PYG{p}{;}
        \PYG{n}{sp}\PYG{p}{.}\PYG{n}{RecordSpatial} \PYG{o}{=} \PYG{n+nb}{true}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{try}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{sp}\PYG{p}{.}\PYG{n}{autocorrel\PYGZus{}file} \PYG{o}{=}\PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{null}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{sp}\PYG{p}{.}\PYG{n}{bAuto} \PYG{o}{=} \PYG{n+nb}{false}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{else}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{sp}\PYG{p}{.}\PYG{n}{bAuto} \PYG{o}{=} \PYG{n+nb}{true}\PYG{p}{;}
            \PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{n}{string}\PYG{o}{\PYGZgt{}} \PYG{n}{tmpimport}\PYG{p}{;}
            \PYG{n}{ConfigOption} \PYG{n}{tmpconfig}\PYG{p}{;}
            \PYG{n}{tmpconfig}\PYG{p}{.}\PYG{n}{setConfig}\PYG{p}{(}\PYG{n}{sp}\PYG{p}{.}\PYG{n}{autocorrel\PYGZus{}file}\PYG{p}{,}\PYG{n+nb}{false}\PYG{p}{)}\PYG{p}{;}
            \PYG{n}{tmpconfig}\PYG{p}{.}\PYG{n}{importConfig}\PYG{p}{(}\PYG{n}{tmpimport}\PYG{p}{)}\PYG{p}{;}
            \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}\PYG{n}{i}\PYG{o}{\PYGZlt{}}\PYG{n}{tmpimport}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}\PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{n}{sp}\PYG{p}{.}\PYG{n}{autocorrel\PYGZus{}times}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{n}{stod}\PYG{p}{(}\PYG{n}{tmpimport}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{c+c1}{//                  cout \PYGZlt{}\PYGZlt{} \PYGZdq{}t\PYGZus{}i: \PYGZdq{} \PYGZlt{}\PYGZlt{} sp.autocorrel\PYGZus{}times[i] \PYGZlt{}\PYGZlt{} endl;}
            \PYG{p}{\PYGZcb{}}
        \PYG{p}{\PYGZcb{}}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{catch}\PYG{p}{(}\PYG{n}{Config\PYGZus{}Exception}\PYG{o}{\PYGZam{}} \PYG{n}{ce}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{cerr} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{ce}\PYG{p}{.}\PYG{n}{what}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifndef verbose}
    \PYG{n}{openLogFile}\PYG{p}{(}\PYG{n+nb}{true}\PYG{p}{)}\PYG{p}{;}
    \PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif}
\PYG{p}{\PYGZcb{}}



\PYG{k+kt}{int} \PYG{n+nf}{main}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{argc}\PYG{p}{,} \PYG{k+kt}{char} \PYG{o}{*}\PYG{o}{*}\PYG{n}{argv}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k+kt}{time\PYGZus{}t} \PYG{n}{tStart}\PYG{p}{,}\PYG{n}{tEnd}\PYG{p}{;}
    \PYG{n}{time}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{tStart}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{simParameters} \PYG{n}{sp}\PYG{p}{;}
    \PYG{n}{Row}\PYG{o}{\PYGZlt{}}\PYG{n}{Treenode}\PYG{o}{\PYGZgt{}} \PYG{n}{data}\PYG{p}{;}
\PYG{c+c1}{//  sqlite3 * database;}
    \PYG{n}{string} \PYG{n}{inputfile}\PYG{p}{;}
    \PYG{k+kt}{unsigned} \PYG{k+kt}{int} \PYG{n}{iMultiNumber} \PYG{o}{=} \PYG{n}{argc}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{6}\PYG{p}{;}
    \PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifndef verbose}
    \PYG{n}{openLogFile}\PYG{p}{(}\PYG{n+nb}{false}\PYG{p}{)}\PYG{p}{;}
    \PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif}
    \PYG{c+c1}{// vector to store the command\PYGZhy{}line arguments}
    \PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{n}{string}\PYG{o}{\PYGZgt{}} \PYG{n}{comargs}\PYG{p}{;}
    \PYG{n}{importArgs}\PYG{p}{(}\PYG{n}{argc}\PYG{p}{,}\PYG{n}{argv}\PYG{p}{,}\PYG{n}{comargs}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{parseArgs}\PYG{p}{(}\PYG{n}{argc}\PYG{p}{,}\PYG{n}{comargs}\PYG{p}{,}\PYG{n}{sp}\PYG{p}{)}\PYG{p}{;}
    \PYG{c+c1}{// Import the arguments}
\PYG{c+c1}{//  for(int i =0;i \PYGZlt{} comargs.size();i++)}
\PYG{c+c1}{//  \PYGZob{}}
\PYG{c+c1}{//      cout \PYGZlt{}\PYGZlt{} comargs[i] \PYGZlt{}\PYGZlt{} endl;}
\PYG{c+c1}{//  \PYGZcb{}}


    \PYG{c+c1}{// Now do the actual calculation}
    \PYG{c+c1}{// First print the variables}
    \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{***************************}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
    \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{STARTING CALCULATIONS}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
    \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Input file is }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{sp}\PYG{p}{.}\PYG{n}{filename} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
    \PYG{k}{if}\PYG{p}{(}\PYG{o}{!}\PYG{n}{sp}\PYG{p}{.}\PYG{n}{bMultiRun}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Speciation rate is }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{sp}\PYG{p}{.}\PYG{n}{vSpecRates}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{else}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Speciation rates are: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{flush}\PYG{p}{;}
        \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{int} \PYG{n}{i}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;}\PYG{n}{i}\PYG{o}{\PYGZlt{}}\PYG{n}{iMultiNumber}\PYG{p}{;}\PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{sp}\PYG{p}{.}\PYG{n}{vSpecRates}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{flush}\PYG{p}{;}
            \PYG{k}{if}\PYG{p}{(}\PYG{n}{i} \PYG{o}{+}\PYG{l+m+mi}{1} \PYG{o}{=}\PYG{o}{=} \PYG{n}{iMultiNumber}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{.}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
            \PYG{k}{else}
            \PYG{p}{\PYGZob{}}
                \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{, }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{flush}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
        \PYG{p}{\PYGZcb{}}
    \PYG{p}{\PYGZcb{}}


    \PYG{c+c1}{// Set up the objects}
    \PYG{n}{Treelist} \PYG{n}{nodes}\PYG{p}{(}\PYG{n}{data}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{nodes}\PYG{p}{.}\PYG{n}{setList}\PYG{p}{(}\PYG{n}{data}\PYG{p}{)}\PYG{p}{;}
\PYG{c+c1}{//  unsigned long iCount;}
    \PYG{c+c1}{// Import the data from the file into the Row\PYGZlt{}Treenode\PYGZgt{} object.}
    \PYG{k}{try}
    \PYG{p}{\PYGZob{}}
\PYG{c+c1}{//      nodes.detectDimensions(sp.filename);}
        \PYG{n}{nodes}\PYG{p}{.}\PYG{n}{importSamplemask}\PYG{p}{(}\PYG{n}{sp}\PYG{p}{.}\PYG{n}{samplemask}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{nodes}\PYG{p}{.}\PYG{n}{importData}\PYG{p}{(}\PYG{n}{sp}\PYG{p}{.}\PYG{n}{filename}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{if}\PYG{p}{(} \PYG{n}{sp}\PYG{p}{.}\PYG{n}{RecordFragments}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{nodes}\PYG{p}{.}\PYG{n}{calcFragments}\PYG{p}{(}\PYG{n}{sp}\PYG{p}{.}\PYG{n}{fragment\PYGZus{}config\PYGZus{}file}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{catch}\PYG{p}{(}\PYG{n}{exception}\PYG{o}{\PYGZam{}} \PYG{n}{se}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{cerr} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{se}\PYG{p}{.}\PYG{n}{what}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
        \PYG{n}{exit}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{c+c1}{// Get rid of any previous speciation calculations}
    \PYG{n}{nodes}\PYG{p}{.}\PYG{n}{resetTree}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{nodes}\PYG{p}{.}\PYG{n}{setGeneration}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}
    \PYG{c+c1}{// Calculate the new tree structure.}
    \PYG{k}{if}\PYG{p}{(}\PYG{n}{sp}\PYG{p}{.}\PYG{n}{bMultiRun}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{double}\PYG{o}{\PYGZgt{}} \PYG{n}{dUniqueSpec}\PYG{p}{;}
        \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;}\PYG{n}{i}\PYG{o}{\PYGZlt{}}\PYG{n}{iMultiNumber}\PYG{p}{;}\PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{k+kt}{bool} \PYG{n}{bCont} \PYG{o}{=} \PYG{n+nb}{true}\PYG{p}{;}
            \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{int} \PYG{n}{j} \PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;}\PYG{n}{j}\PYG{o}{\PYGZlt{}}\PYG{n}{dUniqueSpec}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}\PYG{n}{j}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{k}{if}\PYG{p}{(}\PYG{n}{dUniqueSpec}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{o}{=}\PYG{o}{=}\PYG{n}{sp}\PYG{p}{.}\PYG{n}{vSpecRates}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}
                \PYG{p}{\PYGZob{}}
                    \PYG{n}{bCont} \PYG{o}{=} \PYG{n+nb}{false}\PYG{p}{;}
                \PYG{p}{\PYGZcb{}}
            \PYG{p}{\PYGZcb{}}
            \PYG{k}{if}\PYG{p}{(}\PYG{n}{bCont}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{k}{if}\PYG{p}{(}\PYG{n}{sp}\PYG{p}{.}\PYG{n}{bAuto}\PYG{p}{)}
                \PYG{p}{\PYGZob{}}
                    \PYG{n}{dUniqueSpec}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{n}{sp}\PYG{p}{.}\PYG{n}{vSpecRates}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
                    \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{int} \PYG{n}{k} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}\PYG{n}{k} \PYG{o}{\PYGZlt{}} \PYG{n}{sp}\PYG{p}{.}\PYG{n}{autocorrel\PYGZus{}times}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{n}{k}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
                    \PYG{p}{\PYGZob{}}
                        \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Calculating generation }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{sp}\PYG{p}{.}\PYG{n}{autocorrel\PYGZus{}times}\PYG{p}{[}\PYG{n}{k}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
                        \PYG{n}{nodes}\PYG{p}{.}\PYG{n}{setGeneration}\PYG{p}{(}\PYG{n}{sp}\PYG{p}{.}\PYG{n}{autocorrel\PYGZus{}times}\PYG{p}{[}\PYG{n}{k}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
                        \PYG{n}{nodes}\PYG{p}{.}\PYG{n}{resetTree}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
                        \PYG{k}{try}
                        \PYG{p}{\PYGZob{}}
                            \PYG{n}{nodes}\PYG{p}{.}\PYG{n}{createDatabase}\PYG{p}{(}\PYG{n}{sp}\PYG{p}{.}\PYG{n}{vSpecRates}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
                            \PYG{k}{if}\PYG{p}{(}\PYG{n}{sp}\PYG{p}{.}\PYG{n}{RecordSpatial}\PYG{p}{)}
                            \PYG{p}{\PYGZob{}}
                                \PYG{n}{nodes}\PYG{p}{.}\PYG{n}{recordSpatial}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
                            \PYG{p}{\PYGZcb{}}
                            \PYG{k}{if}\PYG{p}{(}\PYG{n}{sp}\PYG{p}{.}\PYG{n}{RecordFragments}\PYG{p}{)}
                            \PYG{p}{\PYGZob{}}
                                \PYG{n}{nodes}\PYG{p}{.}\PYG{n}{applyFragments}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
                            \PYG{p}{\PYGZcb{}}
                        \PYG{p}{\PYGZcb{}}
                        \PYG{k}{catch}\PYG{p}{(}\PYG{n}{SpeciesException} \PYG{o}{\PYGZam{}}\PYG{n}{se}\PYG{p}{)}
                        \PYG{p}{\PYGZob{}}
                            \PYG{n}{cerr} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{se}\PYG{p}{.}\PYG{n}{what}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
                        \PYG{p}{\PYGZcb{}}
                    \PYG{p}{\PYGZcb{}}
                \PYG{p}{\PYGZcb{}}
                \PYG{k}{else}
                \PYG{p}{\PYGZob{}}
                    \PYG{n}{dUniqueSpec}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{n}{sp}\PYG{p}{.}\PYG{n}{vSpecRates}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
                    \PYG{n}{nodes}\PYG{p}{.}\PYG{n}{resetTree}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
                    \PYG{k}{try}
                    \PYG{p}{\PYGZob{}}
                        \PYG{n}{nodes}\PYG{p}{.}\PYG{n}{createDatabase}\PYG{p}{(}\PYG{n}{sp}\PYG{p}{.}\PYG{n}{vSpecRates}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
                        \PYG{k}{if}\PYG{p}{(}\PYG{n}{sp}\PYG{p}{.}\PYG{n}{RecordSpatial}\PYG{p}{)}
                        \PYG{p}{\PYGZob{}}
                            \PYG{n}{nodes}\PYG{p}{.}\PYG{n}{recordSpatial}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
                        \PYG{p}{\PYGZcb{}}
                        \PYG{k}{if}\PYG{p}{(}\PYG{n}{sp}\PYG{p}{.}\PYG{n}{RecordFragments}\PYG{p}{)}
                        \PYG{p}{\PYGZob{}}
                            \PYG{n}{nodes}\PYG{p}{.}\PYG{n}{applyFragments}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
                        \PYG{p}{\PYGZcb{}}

                    \PYG{p}{\PYGZcb{}}
                    \PYG{k}{catch}\PYG{p}{(}\PYG{n}{SpeciesException} \PYG{o}{\PYGZam{}}\PYG{n}{se}\PYG{p}{)}
                    \PYG{p}{\PYGZob{}}
                        \PYG{n}{cerr} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{se}\PYG{p}{.}\PYG{n}{what}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
                    \PYG{p}{\PYGZcb{}}
                \PYG{p}{\PYGZcb{}}
            \PYG{p}{\PYGZcb{}}
            \PYG{k}{else}
            \PYG{p}{\PYGZob{}}
                \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Repeat speciation rate... ignoring}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
        \PYG{p}{\PYGZcb{}}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{else}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{sp}\PYG{p}{.}\PYG{n}{bAuto}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{int} \PYG{n}{k} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}\PYG{n}{k} \PYG{o}{\PYGZlt{}} \PYG{n}{sp}\PYG{p}{.}\PYG{n}{autocorrel\PYGZus{}times}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{n}{k}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Calculating generation }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{sp}\PYG{p}{.}\PYG{n}{autocorrel\PYGZus{}times}\PYG{p}{[}\PYG{n}{k}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
                \PYG{n}{nodes}\PYG{p}{.}\PYG{n}{setGeneration}\PYG{p}{(}\PYG{n}{sp}\PYG{p}{.}\PYG{n}{autocorrel\PYGZus{}times}\PYG{p}{[}\PYG{n}{k}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
                \PYG{n}{nodes}\PYG{p}{.}\PYG{n}{resetTree}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
                \PYG{k}{try}
                \PYG{p}{\PYGZob{}}
                    \PYG{n}{nodes}\PYG{p}{.}\PYG{n}{createDatabase}\PYG{p}{(}\PYG{n}{sp}\PYG{p}{.}\PYG{n}{vSpecRates}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
                    \PYG{k}{if}\PYG{p}{(}\PYG{n}{sp}\PYG{p}{.}\PYG{n}{RecordSpatial}\PYG{p}{)}
                    \PYG{p}{\PYGZob{}}
                        \PYG{n}{nodes}\PYG{p}{.}\PYG{n}{recordSpatial}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
                    \PYG{p}{\PYGZcb{}}
                    \PYG{k}{if}\PYG{p}{(}\PYG{n}{sp}\PYG{p}{.}\PYG{n}{RecordFragments}\PYG{p}{)}
                    \PYG{p}{\PYGZob{}}
                        \PYG{n}{nodes}\PYG{p}{.}\PYG{n}{applyFragments}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
                    \PYG{p}{\PYGZcb{}}
                \PYG{p}{\PYGZcb{}}
                \PYG{k}{catch}\PYG{p}{(}\PYG{n}{SpeciesException} \PYG{o}{\PYGZam{}}\PYG{n}{se}\PYG{p}{)}
                \PYG{p}{\PYGZob{}}
                    \PYG{n}{cerr} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{se}\PYG{p}{.}\PYG{n}{what}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{n}{endl}\PYG{p}{;}
                \PYG{p}{\PYGZcb{}}
            \PYG{p}{\PYGZcb{}}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{else}
        \PYG{p}{\PYGZob{}}
            \PYG{k}{try}
            \PYG{p}{\PYGZob{}}
                \PYG{n}{nodes}\PYG{p}{.}\PYG{n}{createDatabase}\PYG{p}{(}\PYG{n}{sp}\PYG{p}{.}\PYG{n}{vSpecRates}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
                \PYG{k}{if}\PYG{p}{(}\PYG{n}{sp}\PYG{p}{.}\PYG{n}{RecordSpatial}\PYG{p}{)}
                \PYG{p}{\PYGZob{}}
                    \PYG{n}{nodes}\PYG{p}{.}\PYG{n}{recordSpatial}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
                \PYG{p}{\PYGZcb{}}
                \PYG{k}{if}\PYG{p}{(}\PYG{n}{sp}\PYG{p}{.}\PYG{n}{RecordFragments}\PYG{p}{)}
                \PYG{p}{\PYGZob{}}
                    \PYG{n}{nodes}\PYG{p}{.}\PYG{n}{applyFragments}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
                \PYG{p}{\PYGZcb{}}
            \PYG{p}{\PYGZcb{}}
            \PYG{k}{catch}\PYG{p}{(}\PYG{n}{SpeciesException} \PYG{o}{\PYGZam{}}\PYG{n}{se}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{n}{cerr} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{se}\PYG{p}{.}\PYG{n}{what}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
        \PYG{p}{\PYGZcb{}}
    \PYG{p}{\PYGZcb{}}
    \PYG{n}{nodes}\PYG{p}{.}\PYG{n}{exportDatabase}\PYG{p}{(}\PYG{n}{sp}\PYG{p}{.}\PYG{n}{filename}\PYG{p}{)}\PYG{p}{;}
\PYG{c+c1}{//  cout \PYGZlt{}\PYGZlt{} \PYGZdq{}speciation rate of 0.0001: \PYGZdq{} \PYGZlt{}\PYGZlt{} list.calcSpecies(0.0001);}
\PYG{c+c1}{//  list.resetTree();}
\PYG{c+c1}{//  cout \PYGZlt{}\PYGZlt{} \PYGZdq{}speciation rate of 0.001: \PYGZdq{} \PYGZlt{}\PYGZlt{} list.calcSpecies(0.001);}
\PYG{c+c1}{//  list.resetTree();}
\PYG{c+c1}{//  cout \PYGZlt{}\PYGZlt{} \PYGZdq{}speciation rate of 0.01: \PYGZdq{} \PYGZlt{}\PYGZlt{} list.calcSpecies(0.01);}
    \PYG{n}{time}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{tEnd}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Calculations complete.}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
    \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Time taken was }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{n}{floor}\PYG{p}{(}\PYG{p}{(}\PYG{n}{tEnd} \PYG{o}{\PYGZhy{}} \PYG{n}{tStart}\PYG{p}{)}\PYG{o}{/}\PYG{l+m+mi}{3600}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ hours }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{p}{(}\PYG{n}{floor}\PYG{p}{(}\PYG{p}{(}\PYG{n}{tEnd} \PYG{o}{\PYGZhy{}} \PYG{n}{tStart}\PYG{p}{)}\PYG{o}{/}\PYG{l+m+mi}{60}\PYG{p}{)}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{60}\PYG{o}{*}\PYG{n}{floor}\PYG{p}{(}\PYG{p}{(}\PYG{n}{tEnd} \PYG{o}{\PYGZhy{}} \PYG{n}{tStart}\PYG{p}{)}\PYG{o}{/}\PYG{l+m+mi}{3600}\PYG{p}{)}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ minutes }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{p}{(}\PYG{n}{tEnd}\PYG{o}{\PYGZhy{}}\PYG{n}{tStart}\PYG{p}{)}\PYG{o}{\PYGZpc{}}\PYG{l+m+mi}{60}\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ seconds}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}

    \PYG{k}{return} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}


\subparagraph{Includes}
\label{\detokenize{Exhaled/exhale_file_SpeciationCounter.cpp:includes}}\begin{itemize}
\item {} 
\sphinxcode{Config.h} ({\hyperref[\detokenize{Exhaled/exhale_file_Config.h:file-config-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File Config.h}}}})

\item {} 
\sphinxcode{Setup.h} ({\hyperref[\detokenize{Exhaled/exhale_file_Setup.h:file-setup-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File Setup.h}}}})

\item {} 
\sphinxcode{Treelist.h} ({\hyperref[\detokenize{Exhaled/exhale_file_Treelist.h:file-treelist-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File Treelist.h}}}})

\item {} 
\sphinxcode{boost/filesystem.hpp}

\item {} 
\sphinxcode{stdio.h}

\end{itemize}


\subparagraph{Classes}
\label{\detokenize{Exhaled/exhale_file_SpeciationCounter.cpp:classes}}\begin{itemize}
\item {} 
{\hyperref[\detokenize{Exhaled/exhale_class_simParameters:class-simparameters}]{\sphinxcrossref{\DUrole{std,std-ref}{Class simParameters}}}}

\end{itemize}


\subparagraph{Functions}
\label{\detokenize{Exhaled/exhale_file_SpeciationCounter.cpp:functions}}\begin{itemize}
\item {} 
{\hyperref[\detokenize{Exhaled/exhale_function_main:function-main}]{\sphinxcrossref{\DUrole{std,std-ref}{Function main}}}}

\item {} 
{\hyperref[\detokenize{Exhaled/exhale_function_parseArgs:function-parseargs}]{\sphinxcrossref{\DUrole{std,std-ref}{Function parseArgs}}}}

\end{itemize}


\paragraph{File SpeciesList.h}
\label{\detokenize{Exhaled/exhale_file_SpeciesList.h::doc}}\label{\detokenize{Exhaled/exhale_file_SpeciesList.h:file-specieslist-h}}\label{\detokenize{Exhaled/exhale_file_SpeciesList.h:id1}}

\subparagraph{Definition (\sphinxstyleliteralintitle{SpeciesList.h})}
\label{\detokenize{Exhaled/exhale_file_SpeciesList.h:definition-specieslist-h}}

\subparagraph{Program Listing for File SpeciesList.h}
\label{\detokenize{Exhaled/exhale_program_listing_file_SpeciesList.h:program-listing-for-file-specieslist-h}}\label{\detokenize{Exhaled/exhale_program_listing_file_SpeciesList.h::doc}}\label{\detokenize{Exhaled/exhale_program_listing_file_SpeciesList.h:program-listing-file-specieslist-h}}\begin{itemize}
\item {} 
Return to documentation for {\hyperref[\detokenize{Exhaled/exhale_file_SpeciesList.h:file-specieslist-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File SpeciesList.h}}}}

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{//This file is part of NECSim project which is released under BSD\PYGZhy{}3 license.}
\PYG{c+c1}{//See file **LICENSE.txt** or visit https://opensource.org/licenses/BSD\PYGZhy{}3\PYGZhy{}Clause) for full license details.}

\PYG{c+cm}{/************************************************************}
\PYG{c+cm}{                    SPECIES LIST OBJECT}
\PYG{c+cm}{ ************************************************************/}
 \PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifndef SPECIESLIST}
 \PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define SPECIESLIST}
 \PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}iostream\PYGZgt{}}
\PYG{k}{using} \PYG{k}{namespace} \PYG{n}{std}\PYG{p}{;}
\PYG{k}{class} \PYG{n+nc}{SpeciesList}
\PYG{p}{\PYGZob{}}
\PYG{k}{private}\PYG{o}{:}
    \PYG{k+kt}{unsigned} \PYG{k+kt}{short} \PYG{n}{list\PYGZus{}size}\PYG{p}{,}\PYG{n}{maxsize}\PYG{p}{;} \PYG{c+c1}{// List size and maximum size of the cell (based on percentage cover).}
    \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{next\PYGZus{}active}\PYG{p}{;} \PYG{c+c1}{// For calculating the wrapping, using the next and last system.}
    \PYG{n}{Row}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{unsigned} \PYG{k+kt}{long}\PYG{o}{\PYGZgt{}} \PYG{n}{list}\PYG{p}{;} \PYG{c+c1}{// list of the active reference number, with zeros for empty cells.}
    \PYG{k+kt}{unsigned} \PYG{k+kt}{short} \PYG{n}{nwrap}\PYG{p}{;} \PYG{c+c1}{// The number of wrapping (next and last possibilities) that there are.}
\PYG{k}{public}\PYG{o}{:}
    \PYG{n}{SpeciesList}\PYG{p}{(}\PYG{p}{)} \PYG{o}{:} \PYG{n}{list\PYGZus{}size}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{,}\PYG{n}{maxsize}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{,}\PYG{n}{next\PYGZus{}active}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{,}\PYG{n}{nwrap}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{list}\PYG{p}{.}\PYG{n}{SetRowSize}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{o}{\PYGZti{}}\PYG{n}{SpeciesList}\PYG{p}{(}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}

    \PYG{p}{\PYGZcb{}}
    \PYG{c+c1}{// Sets the list size to the required length.}
    \PYG{c+c1}{// Note this will delete any species currently stored in the list}

    \PYG{c+c1}{// Fill the list with empty 0s.}
    \PYG{k+kt}{void} \PYG{n}{fillList}\PYG{p}{(}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{maxsize}\PYG{o}{=}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{k}{return}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}\PYG{n}{i}\PYG{o}{\PYGZlt{}}\PYG{n}{maxsize}\PYG{p}{;}\PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{list}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
    \PYG{p}{\PYGZcb{}}

    \PYG{c+c1}{// Standard setters}
    \PYG{k+kt}{void} \PYG{n}{initialise}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{short} \PYG{n}{maxsizein}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{maxsize} \PYG{o}{=} \PYG{n}{maxsizein}\PYG{p}{;}
        \PYG{n}{nwrap} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
        \PYG{n}{list\PYGZus{}size} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
        \PYG{n}{list}\PYG{p}{.}\PYG{n}{SetRowSize}\PYG{p}{(}\PYG{n}{maxsize}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{return}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{c+c1}{// special case if just the maxsize wants to be change, but want to maintain the list variables.}
    \PYG{k+kt}{void} \PYG{n}{setMaxsize}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{short} \PYG{n}{maxsizein}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{maxsize} \PYG{o}{=} \PYG{n}{maxsizein}\PYG{p}{;}
        \PYG{k}{return}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{k+kt}{void} \PYG{n}{setSpecies}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{index}\PYG{p}{,} \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{new\PYGZus{}val}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{list}\PYG{p}{[}\PYG{n}{index}\PYG{p}{]} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{cerr} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{index: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{index} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
            \PYG{n}{cerr} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{list[index]: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{n}{list}\PYG{p}{[}\PYG{n}{index}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
            \PYG{n}{cerr} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{list.maxsize(): }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{maxsize} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
            \PYG{k}{throw} \PYG{n+nf}{runtime\PYGZus{}error}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ERROR\PYGZus{}MOVE\PYGZus{}027: List position to be replaced is zero. Check list assignment.}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{n}{list}\PYG{p}{[}\PYG{n}{index}\PYG{p}{]} \PYG{o}{=} \PYG{n}{new\PYGZus{}val}\PYG{p}{;}
        \PYG{k}{return}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{k+kt}{void} \PYG{n}{setNext}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{n}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{next\PYGZus{}active} \PYG{o}{=} \PYG{n}{n}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}


    \PYG{k+kt}{void} \PYG{n}{setNwrap}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{short} \PYG{n}{nr}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{nwrap} \PYG{o}{=} \PYG{n}{nr}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{k+kt}{unsigned} \PYG{k+kt}{short} \PYG{n}{addSpecies}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{new\PYGZus{}spec}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{c+cm}{/*}
\PYG{c+cm}{        list\PYGZus{}size ++;}
\PYG{c+cm}{        if(list\PYGZus{}size\PYGZgt{}maxsize)}
\PYG{c+cm}{        \PYGZob{}}
\PYG{c+cm}{            list\PYGZus{}size \PYGZhy{}\PYGZhy{};}
\PYG{c+cm}{            return;}
\PYG{c+cm}{        \PYGZcb{}}
\PYG{c+cm}{        else}
\PYG{c+cm}{        \PYGZob{}}
\PYG{c+cm}{            list[list\PYGZus{}size] = new\PYGZus{}spec;}
\PYG{c+cm}{        \PYGZcb{}}
\PYG{c+cm}{         * */}
        \PYG{c+c1}{// Alternative method}
        \PYG{c+c1}{// loop until an empty space is found and place the new species in the empty space.}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{list\PYGZus{}size} \PYG{o}{+} \PYG{l+m+mi}{1} \PYG{o}{\PYGZgt{}} \PYG{n}{maxsize}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{cerr} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{maxsize: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{maxsize} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
            \PYG{k}{throw} \PYG{n+nf}{out\PYGZus{}of\PYGZus{}range}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Could not add species \PYGZhy{} no empty space}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{short} \PYG{n}{i} \PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i}\PYG{o}{\PYGZlt{}}\PYG{n}{list}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{k}{if}\PYG{p}{(}\PYG{n}{list}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{n}{list\PYGZus{}size}\PYG{o}{+}\PYG{o}{+}\PYG{p}{;}
                \PYG{n}{list}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{=} \PYG{n}{new\PYGZus{}spec}\PYG{p}{;}
                \PYG{k}{return} \PYG{n}{i}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}

        \PYG{p}{\PYGZcb{}}
        \PYG{n}{cerr} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{maxsize: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{maxsize} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
        \PYG{k}{throw} \PYG{n+nf}{out\PYGZus{}of\PYGZus{}range}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Could not add species \PYGZhy{} no empty space}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{k+kt}{void} \PYG{n}{addSpeciesSilent}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{new\PYGZus{}spec}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{c+cm}{/*}
\PYG{c+cm}{        list\PYGZus{}size ++;}
\PYG{c+cm}{        if(list\PYGZus{}size\PYGZgt{}maxsize)}
\PYG{c+cm}{        \PYGZob{}}
\PYG{c+cm}{            list\PYGZus{}size \PYGZhy{}\PYGZhy{};}
\PYG{c+cm}{            return;}
\PYG{c+cm}{        \PYGZcb{}}
\PYG{c+cm}{        else}
\PYG{c+cm}{        \PYGZob{}}
\PYG{c+cm}{            list[list\PYGZus{}size] = new\PYGZus{}spec;}
\PYG{c+cm}{        \PYGZcb{}}
\PYG{c+cm}{         * */}
        \PYG{c+c1}{// Alternative method}
        \PYG{c+c1}{// loop until an empty space is found and place the new species in the empty space.}
        \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;}\PYG{n}{i}\PYG{o}{\PYGZlt{}}\PYG{n}{maxsize}\PYG{p}{;}\PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{k}{if}\PYG{p}{(}\PYG{n}{list}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{n}{list\PYGZus{}size}\PYG{o}{+}\PYG{o}{+}\PYG{p}{;}
                \PYG{n}{list}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{=} \PYG{n}{new\PYGZus{}spec}\PYG{p}{;}
                \PYG{k}{return}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}

        \PYG{p}{\PYGZcb{}}
        \PYG{k}{throw} \PYG{n}{out\PYGZus{}of\PYGZus{}range}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Could not add species \PYGZhy{} no empty space}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{k+kt}{void} \PYG{n}{deleteSpecies}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{index}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
\PYG{c+c1}{//      cout \PYGZlt{}\PYGZlt{} \PYGZdq{}deleted species index: \PYGZdq{} \PYGZlt{}\PYGZlt{} index \PYGZlt{}\PYGZlt{} \PYGZdq{} value: \PYGZdq{} \PYGZlt{}\PYGZlt{} list[index] \PYGZlt{}\PYGZlt{} \PYGZdq{} list size: \PYGZdq{} \PYGZlt{}\PYGZlt{} list\PYGZus{}size \PYGZlt{}\PYGZlt{} endl;}
        \PYG{n}{list}\PYG{p}{[}\PYG{n}{index}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
        \PYG{n}{list\PYGZus{}size} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{p}{;}

        \PYG{c+c1}{// alternative version}
        \PYG{c+cm}{/*for(int i = index;i\PYGZlt{}list\PYGZus{}size;i++)}
\PYG{c+cm}{        \PYGZob{}}
\PYG{c+cm}{            list[i] = list[i+1];}
\PYG{c+cm}{        \PYGZcb{}}
\PYG{c+cm}{        list[list\PYGZus{}size]=0;}
\PYG{c+cm}{        list\PYGZus{}size \PYGZhy{}\PYGZhy{};*/}
    \PYG{p}{\PYGZcb{}}

    \PYG{k+kt}{void} \PYG{n}{decreaseNwrap}\PYG{p}{(}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{nwrap} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{k}{throw} \PYG{n}{runtime\PYGZus{}error}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Nwrap should never be decreased less than 0}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{else} \PYG{k}{if}\PYG{p}{(}\PYG{n}{nwrap} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{k}{if}\PYG{p}{(} \PYG{n}{next\PYGZus{}active} \PYG{o}{!}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{k}{throw} \PYG{n}{runtime\PYGZus{}error}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Nwrap is being set at 0 when an wrapped lineage is still present}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
        \PYG{p}{\PYGZcb{}}
        \PYG{n}{nwrap} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{k+kt}{void} \PYG{n}{increaseNwrap}\PYG{p}{(}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{nwrap} \PYG{o}{+}\PYG{o}{+}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{k+kt}{void} \PYG{n}{changePercentCover}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{short} \PYG{n}{newmaxsize}\PYG{p}{)} \PYG{c+c1}{// THIS NEEDS TO BE CHANGED TO TAKE ACCOUNT OF THE NEW REFERENCING METHOD}
    \PYG{p}{\PYGZob{}}
\PYG{c+c1}{//      cout \PYGZlt{}\PYGZlt{} \PYGZdq{}1\PYGZdq{} \PYGZlt{}\PYGZlt{} endl;}
        \PYG{n}{Row}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{unsigned} \PYG{k+kt}{long}\PYG{o}{\PYGZgt{}} \PYG{n}{templist}\PYG{p}{(}\PYG{n}{list}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{maxsize} \PYG{o}{=} \PYG{n}{newmaxsize}\PYG{p}{;}
        \PYG{n}{list}\PYG{p}{.}\PYG{n}{SetRowSize}\PYG{p}{(}\PYG{n}{newmaxsize}\PYG{p}{)}\PYG{p}{;}
\PYG{c+c1}{//      cout \PYGZlt{}\PYGZlt{} \PYGZdq{}2\PYGZdq{} \PYGZlt{}\PYGZlt{} endl;}
\PYG{c+c1}{//      cout \PYGZlt{}\PYGZlt{} \PYGZdq{}templist.size: \PYGZdq{} \PYGZlt{}\PYGZlt{} templist.size() \PYGZlt{}\PYGZlt{} endl;}
\PYG{c+c1}{//      cout \PYGZlt{}\PYGZlt{} \PYGZdq{}list.size: \PYGZdq{} \PYGZlt{}\PYGZlt{} list.size() \PYGZlt{}\PYGZlt{} endl;}
\PYG{c+c1}{//      cout \PYGZlt{}\PYGZlt{} \PYGZdq{}list\PYGZus{}size: \PYGZdq{} \PYGZlt{}\PYGZlt{} list\PYGZus{}size \PYGZlt{}\PYGZlt{} endl;}
\PYG{c+c1}{//      cout \PYGZlt{}\PYGZlt{} \PYGZdq{}maxsize: \PYGZdq{} \PYGZlt{}\PYGZlt{} maxsize \PYGZlt{}\PYGZlt{} endl;}
\PYG{c+c1}{//      cout \PYGZlt{}\PYGZlt{} \PYGZdq{}newmaxsize: \PYGZdq{} \PYGZlt{}\PYGZlt{} newmaxsize \PYGZlt{}\PYGZlt{} endl;}
\PYG{c+c1}{//      cout \PYGZlt{}\PYGZlt{} \PYGZdq{}templist[0]: \PYGZdq{} \PYGZlt{}\PYGZlt{} templist[0] \PYGZlt{}\PYGZlt{} endl;}
        \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{int} \PYG{n}{i}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;}\PYG{n}{i}\PYG{o}{\PYGZlt{}}\PYG{n}{newmaxsize}\PYG{p}{;}\PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
\PYG{c+c1}{//          cout \PYGZlt{}\PYGZlt{} i \PYGZlt{}\PYGZlt{} endl;}
            \PYG{k}{if}\PYG{p}{(}\PYG{n}{i}\PYG{o}{\PYGZlt{}}\PYG{n}{templist}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)} \PYG{c+c1}{// DOUBLE CHECK THIS LATER}
            \PYG{p}{\PYGZob{}}
\PYG{c+c1}{//              cout \PYGZlt{}\PYGZlt{} i \PYGZlt{}\PYGZlt{} endl;}
                \PYG{n}{list}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{=} \PYG{n}{templist}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{;}
\PYG{c+c1}{//              cout \PYGZlt{}\PYGZlt{} \PYGZdq{}assignment done\PYGZdq{} \PYGZlt{}\PYGZlt{} endl;}
            \PYG{p}{\PYGZcb{}}
            \PYG{k}{else}
            \PYG{p}{\PYGZob{}}
\PYG{c+c1}{//              cout \PYGZlt{}\PYGZlt{} \PYGZdq{}alt: \PYGZdq{} \PYGZlt{}\PYGZlt{} i \PYGZlt{}\PYGZlt{} endl;}
                \PYG{n}{list}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{list}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZgt{}} \PYG{n}{maxsize}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{cerr} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{list.size(): }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{list}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
            \PYG{n}{cerr} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{maxsize: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{maxsize} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
            \PYG{k}{throw} \PYG{n+nf}{out\PYGZus{}of\PYGZus{}range}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{List size not equal to maxsize}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
\PYG{c+c1}{//      cout \PYGZlt{}\PYGZlt{} \PYGZdq{}3\PYGZdq{} \PYGZlt{}\PYGZlt{} endl;}
        \PYG{c+c1}{// Alternative method}
\PYG{c+c1}{//      maxsize = newmaxsize;}
    \PYG{p}{\PYGZcb{}}

    \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{getRandLineage}\PYG{p}{(}\PYG{n}{NRrand} \PYG{o}{\PYGZam{}}\PYG{n}{rand\PYGZus{}no}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k+kt}{double} \PYG{n}{rand\PYGZus{}index}\PYG{p}{;}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{maxsize} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{n}{list\PYGZus{}size}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{c+c1}{// Then the list size is larger than the actual size. This means we must return a lineage.}
            \PYG{k}{try}
            \PYG{p}{\PYGZob{}}
                \PYG{k}{do}
                \PYG{p}{\PYGZob{}}
                    \PYG{n}{rand\PYGZus{}index} \PYG{o}{=} \PYG{n}{rand\PYGZus{}no}\PYG{p}{.}\PYG{n}{d01}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
                    \PYG{n}{rand\PYGZus{}index} \PYG{o}{*}\PYG{o}{=} \PYG{n}{list}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
                    \PYG{c+c1}{//cout \PYGZlt{}\PYGZlt{} \PYGZdq{}ref: \PYGZdq{} \PYGZlt{}\PYGZlt{} rand\PYGZus{}index \PYGZlt{}\PYGZlt{} \PYGZdq{}, \PYGZdq{} \PYGZlt{}\PYGZlt{} list[round(rand\PYGZus{}index)] \PYGZlt{}\PYGZlt{} endl;}
                \PYG{p}{\PYGZcb{}} \PYG{k}{while}\PYG{p}{(}\PYG{n}{list}\PYG{p}{[}\PYG{n}{floor}\PYG{p}{(}\PYG{n}{rand\PYGZus{}index}\PYG{p}{)}\PYG{p}{]} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}
                \PYG{c+c1}{//cout \PYGZlt{}\PYGZlt{} \PYGZdq{}RETURNING!\PYGZdq{} \PYGZlt{}\PYGZlt{} endl;}
                \PYG{k}{return}\PYG{p}{(}\PYG{n}{list}\PYG{p}{[}\PYG{n}{floor}\PYG{p}{(}\PYG{n}{rand\PYGZus{}index}\PYG{p}{)}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
            \PYG{k}{catch}\PYG{p}{(}\PYG{n}{out\PYGZus{}of\PYGZus{}range} \PYG{o}{\PYGZam{}}\PYG{n}{oor}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{n}{cerr} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{oor}\PYG{p}{.}\PYG{n}{what}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
                \PYG{k}{throw} \PYG{n+nf}{runtime\PYGZus{}error}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ERROR\PYGZus{}MOVE\PYGZus{}001b: Listpos outside maxsize.}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{else}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{rand\PYGZus{}index} \PYG{o}{=}  \PYG{n}{rand\PYGZus{}no}\PYG{p}{.}\PYG{n}{d01}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{c+c1}{//      cout \PYGZlt{}\PYGZlt{} \PYGZdq{}rand\PYGZus{}index: \PYGZdq{} \PYGZlt{}\PYGZlt{} rand\PYGZus{}index \PYGZlt{}\PYGZlt{} endl;}
            \PYG{n}{rand\PYGZus{}index}  \PYG{o}{*}\PYG{o}{=} \PYG{n}{maxsize}\PYG{p}{;}
        \PYG{c+c1}{// Dynamically resize the list if required. Otherwise, to save memory, the list will not be resized;}
            \PYG{k}{if}\PYG{p}{(}\PYG{n}{rand\PYGZus{}index}\PYG{o}{\PYGZgt{}}\PYG{o}{=}\PYG{n}{list}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
    \PYG{c+c1}{//          cout \PYGZlt{}\PYGZlt{} \PYGZdq{}changing: \PYGZdq{} \PYGZlt{}\PYGZlt{} endl;}
                \PYG{n}{changePercentCover}\PYG{p}{(}\PYG{n}{maxsize}\PYG{p}{)}\PYG{p}{;}
    \PYG{c+c1}{//          string sam;}
    \PYG{c+c1}{//          cin \PYGZgt{}\PYGZgt{} sam;}
            \PYG{p}{\PYGZcb{}}
            \PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifdef DEBUG}
\PYG{c+c1}{//          if(list.size() \PYGZgt{} 1 \textbar{}\textbar{} list\PYGZus{}size \PYGZgt{} 1 \textbar{}\textbar{} maxsize != 1)}
\PYG{c+c1}{//          \PYGZob{}}
\PYG{c+c1}{//              throw runtime\PYGZus{}error(\PYGZdq{}HELP!\PYGZdq{});}
\PYG{c+c1}{//          \PYGZcb{}}
            \PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif}
            \PYG{c+c1}{// now get the correctly placed lineage (returning 0s when necessary)}
            \PYG{c+cm}{/*int j =0; // this counts the number of 0s we\PYGZsq{}ve seen (included)}
\PYG{c+cm}{            int i = 0; // this counts the total number we\PYGZsq{}ve passed}
\PYG{c+cm}{            int k =0; // this counts the  number of 0s seen (skipped)}
\PYG{c+cm}{            int zeroes = maxsize \PYGZhy{} list\PYGZus{}size;}
\PYG{c+cm}{            while(i\PYGZhy{}k \PYGZlt{} rand\PYGZus{}index)}
\PYG{c+cm}{            \PYGZob{}}
\PYG{c+cm}{                i++;}
\PYG{c+cm}{                // then we need to return a lineage}
\PYG{c+cm}{                if(list[i] == 0)}
\PYG{c+cm}{                \PYGZob{}}
\PYG{c+cm}{                    if(j \PYGZlt{} zeroes)}
\PYG{c+cm}{                    \PYGZob{}}
\PYG{c+cm}{                        j ++;}
\PYG{c+cm}{                    \PYGZcb{}}
\PYG{c+cm}{                    else}
\PYG{c+cm}{                    \PYGZob{}}
\PYG{c+cm}{                        k++;}
\PYG{c+cm}{                    \PYGZcb{}}
\PYG{c+cm}{                \PYGZcb{}}
\PYG{c+cm}{            \PYGZcb{}*/}

            \PYG{c+c1}{// test new version}
            \PYG{k+kt}{unsigned} \PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{n}{floor}\PYG{p}{(}\PYG{n}{rand\PYGZus{}index}\PYG{p}{)}\PYG{p}{;}

            \PYG{c+c1}{// REMOVE THIS LATER}
            \PYG{k}{if}\PYG{p}{(}\PYG{n}{rand\PYGZus{}index}\PYG{o}{\PYGZgt{}}\PYG{n}{maxsize}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ERROR IN INDEX}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
                \PYG{n}{string} \PYG{n}{sam}\PYG{p}{;}
                \PYG{n}{cin} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{sam}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
            \PYG{k}{return} \PYG{n}{list}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
    \PYG{p}{\PYGZcb{}}

    \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{getSpecies}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{short} \PYG{n}{index}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{return} \PYG{n}{list}\PYG{p}{[}\PYG{n}{index}\PYG{p}{]}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{getNext}\PYG{p}{(}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{return} \PYG{n}{next\PYGZus{}active}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{k+kt}{unsigned} \PYG{k+kt}{short} \PYG{n}{getNwrap}\PYG{p}{(}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{return} \PYG{n}{nwrap}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{k+kt}{int} \PYG{n}{getListsize}\PYG{p}{(}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{return} \PYG{n}{list\PYGZus{}size}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{k+kt}{int} \PYG{n}{getMaxsize}\PYG{p}{(}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{return} \PYG{n}{maxsize}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{k+kt}{void} \PYG{n}{wipeList}\PYG{p}{(}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{fillList}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{next\PYGZus{}active}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;}
        \PYG{n}{nwrap} \PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;}
        \PYG{n}{list\PYGZus{}size}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{k}{friend} \PYG{n}{ostream}\PYG{o}{\PYGZam{}} \PYG{k}{operator}\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{p}{(}\PYG{n}{ostream}\PYG{o}{\PYGZam{}} \PYG{n}{os}\PYG{p}{,}\PYG{k}{const} \PYG{n}{SpeciesList}\PYG{o}{\PYGZam{}} \PYG{n}{r}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{c+c1}{//os \PYGZlt{}\PYGZlt{} m.numRows\PYGZlt{}\PYGZlt{}\PYGZdq{} , \PYGZdq{}\PYGZlt{}\PYGZlt{}m.numCols\PYGZlt{}\PYGZlt{}\PYGZdq{} , \PYGZdq{}\PYGZlt{}\PYGZlt{}endl;}
        \PYG{n}{os} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{r}\PYG{p}{.}\PYG{n}{list} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{,}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
        \PYG{n}{os} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{r}\PYG{p}{.}\PYG{n}{list\PYGZus{}size} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{,}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
        \PYG{n}{os} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{r}\PYG{p}{.}\PYG{n}{maxsize} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{,}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
        \PYG{n}{os} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{r}\PYG{p}{.}\PYG{n}{next\PYGZus{}active} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{,}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
        \PYG{n}{os} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{r}\PYG{p}{.}\PYG{n}{nwrap} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{,}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
        \PYG{k}{return} \PYG{n}{os}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{k}{friend} \PYG{n}{istream}\PYG{o}{\PYGZam{}} \PYG{k}{operator}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{n}{istream}\PYG{o}{\PYGZam{}} \PYG{n}{is}\PYG{p}{,} \PYG{n}{SpeciesList}\PYG{o}{\PYGZam{}} \PYG{n}{r}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k+kt}{char} \PYG{n}{delim}\PYG{p}{;}
        \PYG{c+c1}{//double temp1,temp2;}
        \PYG{c+c1}{//is \PYGZlt{}\PYGZlt{} m.numRows\PYGZlt{}\PYGZlt{}\PYGZdq{} , \PYGZdq{}\PYGZlt{}\PYGZlt{}m.numCols\PYGZlt{}\PYGZlt{}\PYGZdq{} , \PYGZdq{}\PYGZlt{}\PYGZlt{}endl;}
        \PYG{n}{is} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{r}\PYG{p}{.}\PYG{n}{list}\PYG{p}{;}
        \PYG{n}{is} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{delim}\PYG{p}{;}
        \PYG{n}{is} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{r}\PYG{p}{.}\PYG{n}{list\PYGZus{}size}\PYG{p}{;}
        \PYG{n}{is} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{delim}\PYG{p}{;}
        \PYG{n}{is} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{r}\PYG{p}{.}\PYG{n}{maxsize}\PYG{p}{;}
        \PYG{n}{is} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{delim}\PYG{p}{;}
        \PYG{n}{is} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{r}\PYG{p}{.}\PYG{n}{next\PYGZus{}active}\PYG{p}{;}
        \PYG{n}{is} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{delim}\PYG{p}{;}
        \PYG{n}{is} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{r}\PYG{p}{.}\PYG{n}{nwrap}\PYG{p}{;}
        \PYG{n}{is} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{delim}\PYG{p}{;}
        \PYG{k}{return} \PYG{n}{is}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}

\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif}
\end{sphinxVerbatim}


\subparagraph{Includes}
\label{\detokenize{Exhaled/exhale_file_SpeciesList.h:includes}}\begin{itemize}
\item {} 
\sphinxcode{iostream}

\end{itemize}


\subparagraph{Included By}
\label{\detokenize{Exhaled/exhale_file_SpeciesList.h:included-by}}\begin{itemize}
\item {} 
{\hyperref[\detokenize{Exhaled/exhale_file_Tree.h:file-tree-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File Tree.h}}}}

\end{itemize}


\subparagraph{Classes}
\label{\detokenize{Exhaled/exhale_file_SpeciesList.h:classes}}\begin{itemize}
\item {} 
{\hyperref[\detokenize{Exhaled/exhale_class_SpeciesList:class-specieslist}]{\sphinxcrossref{\DUrole{std,std-ref}{Class SpeciesList}}}}

\end{itemize}


\paragraph{File Tree.h}
\label{\detokenize{Exhaled/exhale_file_Tree.h:id1}}\label{\detokenize{Exhaled/exhale_file_Tree.h::doc}}\label{\detokenize{Exhaled/exhale_file_Tree.h:file-tree-h}}

\subparagraph{Definition (\sphinxstyleliteralintitle{Tree.h})}
\label{\detokenize{Exhaled/exhale_file_Tree.h:definition-tree-h}}

\subparagraph{Program Listing for File Tree.h}
\label{\detokenize{Exhaled/exhale_program_listing_file_Tree.h::doc}}\label{\detokenize{Exhaled/exhale_program_listing_file_Tree.h:program-listing-for-file-tree-h}}\label{\detokenize{Exhaled/exhale_program_listing_file_Tree.h:program-listing-file-tree-h}}\begin{itemize}
\item {} 
Return to documentation for {\hyperref[\detokenize{Exhaled/exhale_file_Tree.h:file-tree-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File Tree.h}}}}

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{//This file is part of NECSim project which is released under BSD\PYGZhy{}3 license.}
\PYG{c+c1}{//See file **LICENSE.txt** or visit https://opensource.org/licenses/BSD\PYGZhy{}3\PYGZhy{}Clause) for full license details.}
\PYG{c+c1}{//}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifndef TREE}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define TREE}


\PYG{c+cm}{/************************************************************}
\PYG{c+cm}{                        INCLUDES}
\PYG{c+cm}{ ************************************************************/}
\PYG{c+c1}{// standard includes}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ include \PYGZlt{}stdio.h\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ include \PYGZlt{}fstream\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ include \PYGZlt{}vector\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ include \PYGZlt{}iostream\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ include \PYGZlt{}string\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ include \PYGZlt{}cstring\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ include \PYGZlt{}math.h\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ include \PYGZlt{}iomanip\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ include \PYGZlt{}cmath\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ include \PYGZlt{}time.h\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ include \PYGZlt{}ctime\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ include \PYGZlt{}sqlite3.h\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}string\PYGZgt{}}
\PYG{c+c1}{//\PYGZsh{} include \PYGZlt{}sqlite.h\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ include \PYGZlt{}unistd.h\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ include \PYGZlt{}algorithm\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ include \PYGZlt{}stdexcept\PYGZgt{}}
\PYG{c+c1}{//\PYGZsh{}define with\PYGZus{}gdal}
\PYG{c+c1}{// extra boost include \PYGZhy{} this requires the installation of boost on the system}
\PYG{c+c1}{// note that this requires compilation with the \PYGZhy{}lboost\PYGZus{}filesystem and \PYGZhy{}lboost\PYGZus{}system linkers.}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ include \PYGZlt{}boost}\PYG{c+cp}{/}\PYG{c+cp}{filesystem.hpp\PYGZgt{}}

\PYG{c+c1}{// include fast\PYGZhy{}csv\PYGZhy{}parser by Ben Strasser (available from https://github.com/ben\PYGZhy{}strasser/fast\PYGZhy{}cpp\PYGZhy{}csv\PYGZhy{}parser)}
\PYG{c+c1}{// for fast file reading}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifdef use\PYGZus{}csv}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZdq{}fast\PYGZhy{}cpp\PYGZhy{}csv\PYGZhy{}parser/csv.h\PYGZdq{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif}

\PYG{c+c1}{//\PYGZsh{}define use\PYGZus{}csv // for integration with the matrix header file}
\PYG{c+c1}{//\PYGZsh{}include \PYGZdq{}fast\PYGZhy{}cpp\PYGZhy{}csv\PYGZhy{}parser/csv.h\PYGZdq{}}
\PYG{c+c1}{//\PYGZsh{}define record\PYGZus{}space // tells the compiler whether to include the routines for outputting full spatial data of lineages. Usually this will not be required.}

\PYG{c+c1}{// this uses the RAM for the storage of the active SQL database.}
\PYG{c+c1}{// If the RAM requirements get too huge, comment this out to instead write directly to disc.}
\PYG{c+c1}{// For HPC systems, it is recommended to use this option as write speeds are generally fast and large simulations don\PYGZsq{}t}
\PYG{c+c1}{// have a linear increase in the SQL database size (at least in RAM).}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define sql\PYGZus{}ram}


\PYG{c+c1}{// other includes for required files}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ include \PYGZdq{}Matrix.h\PYGZdq{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ include \PYGZdq{}Fattaildeviate.h\PYGZdq{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ include \PYGZdq{}Datapoint.h\PYGZdq{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ include \PYGZdq{}Treenode.h\PYGZdq{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ include \PYGZdq{}SpeciesList.h\PYGZdq{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ include \PYGZdq{}Map.h\PYGZdq{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ include \PYGZdq{}Treelist.h\PYGZdq{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ include \PYGZdq{}Config.h\PYGZdq{}}


\PYG{k}{using} \PYG{k}{namespace} \PYG{n}{std}\PYG{p}{;}

\PYG{c+cm}{/************************************************************}
\PYG{c+cm}{                        MAIN TREE OBJECT}
\PYG{c+cm}{ ************************************************************/}

\PYG{k}{class} \PYG{n+nc}{Tree}
\PYG{p}{\PYGZob{}}

\PYG{c+c1}{// declare private variables}
\PYG{k}{private}\PYG{o}{:}
    \PYG{c+c1}{// storing the coalescence tree itself}
    \PYG{n}{Row}\PYG{o}{\PYGZlt{}}\PYG{n}{Treenode}\PYG{o}{\PYGZgt{}} \PYG{n}{data}\PYG{p}{;}
    \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{enddata}\PYG{p}{;}
    \PYG{c+c1}{// for storing the command line parameters and parsing the required information.}
    \PYG{n}{Mapvars} \PYG{n}{mapvarsin}\PYG{p}{;}
    \PYG{c+c1}{// random number generator}
    \PYG{n}{NRrand} \PYG{n}{NR}\PYG{p}{;}
    \PYG{k+kt}{bool} \PYG{n}{seeded}\PYG{p}{;}
    \PYG{c+c1}{// random seed}
    \PYG{k+kt}{long} \PYG{k+kt}{long} \PYG{n}{the\PYGZus{}seed}\PYG{p}{;}

    \PYG{c+c1}{// for general debugging use}
    \PYG{k+kt}{bool} \PYG{n}{debug}\PYG{p}{;}

    \PYG{c+c1}{// for enabling the logging mode}
    \PYG{k+kt}{bool} \PYG{n}{log\PYGZus{}all}\PYG{p}{;}
    \PYG{c+c1}{// note: in earlier versions I had the minspecsetup variable here}
    \PYG{c+c1}{// I\PYGZsq{}ve removed it because this version implements speciation as it goes rather than on the tree later}
    \PYG{c+c1}{// I\PYGZsq{}ve also removed sim\PYGZus{}counter which recorded the number of repeat simulations}
    \PYG{c+c1}{// because each job will be 1 simulation in this implementation}

    \PYG{c+c1}{// for file naming \PYGZhy{} good to know which task in a series is being executed here}
    \PYG{k+kt}{long} \PYG{k+kt}{long} \PYG{n}{the\PYGZus{}task}\PYG{p}{;}

    \PYG{c+c1}{// The map file containing the times that we want to expand the model and record all lineages again.}
    \PYG{c+c1}{// If this is null, bAutocorrel will be false and the vector will be empty.}
    \PYG{n}{string} \PYG{n}{autocorrel\PYGZus{}file}\PYG{p}{;}
    \PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{double}\PYG{o}{\PYGZgt{}} \PYG{n}{autocorrel\PYGZus{}times}\PYG{p}{;}
    \PYG{c+c1}{// Set to true if we are recording at times other than the present day.}
    \PYG{k+kt}{bool} \PYG{n}{bAutocorrel}\PYG{p}{;}
    \PYG{c+c1}{// the map files // these are now removed from the class object and replaced with a function fed by a series of strings serving the same purpose.}
    \PYG{c+cm}{/*vector\PYGZlt{}string\PYGZgt{} map\PYGZus{}list;}
\PYG{c+cm}{    // the sizes of the same map files}
\PYG{c+cm}{    vector\PYGZlt{}long\PYGZgt{} map\PYGZus{}x\PYGZus{}size;}
\PYG{c+cm}{    vector\PYGZlt{}long\PYGZgt{} map\PYGZus{}y\PYGZus{}size;}
\PYG{c+cm}{    // The list of size of the grid within the map and the dimensions of the offset.}
\PYG{c+cm}{    vector\PYGZlt{}long\PYGZgt{} grid\PYGZus{}x\PYGZus{}size;}
\PYG{c+cm}{    vector\PYGZlt{}long\PYGZgt{}grid\PYGZus{}y\PYGZus{}size;}
\PYG{c+cm}{    vector\PYGZlt{}long\PYGZgt{} grid\PYGZus{}x\PYGZus{}offset;}
\PYG{c+cm}{    vector\PYGZlt{}long\PYGZgt{}grid\PYGZus{}y\PYGZus{}offset;}
\PYG{c+cm}{     * */}
     \PYG{c+c1}{//tmp debugging}
     \PYG{k+kt}{bool} \PYG{n}{bSpec}\PYG{p}{;}
    \PYG{c+c1}{// A list of new variables which will contain the relevant information for maps and grids.}
    \PYG{n}{string} \PYG{n}{finemapinput}\PYG{p}{,} \PYG{n}{coarsemapinput}\PYG{p}{,} \PYG{n}{outdirectory}\PYG{p}{;} \PYG{c+c1}{//  strings containing the file names to be imported.}
    \PYG{n}{string} \PYG{n}{pristinefinemapinput}\PYG{p}{,} \PYG{n}{pristinecoarsemapinput}\PYG{p}{;}
    \PYG{k+kt}{double} \PYG{n}{dPristine}\PYG{p}{,} \PYG{n}{dForestTransform}\PYG{p}{;} \PYG{c+c1}{// the time since pristine forest and the rate of change of the rainforest.}
    \PYG{k+kt}{long} \PYG{n}{gridxsize}\PYG{p}{,} \PYG{n}{gridysize}\PYG{p}{;} \PYG{c+c1}{// the variables for the grid containing the initial individuals.}
    \PYG{k+kt}{long} \PYG{n}{finemapxsize}\PYG{p}{,} \PYG{n}{finemapysize}\PYG{p}{,} \PYG{n}{finemapxoffset}\PYG{p}{,} \PYG{n}{finemapyoffset}\PYG{p}{;} \PYG{c+c1}{// The fine map variables at the same resolution as the grid.}
    \PYG{k+kt}{long} \PYG{n}{coarsemapxsize}\PYG{p}{,} \PYG{n}{coarsemapysize}\PYG{p}{,} \PYG{n}{coarsemapxoffset}\PYG{p}{,} \PYG{n}{coarsemapyoffset}\PYG{p}{,}\PYG{n}{coarsemapscale}\PYG{p}{;} \PYG{c+c1}{// the coarse map variables at a scaled resolution of the fine map.}
    \PYG{k+kt}{bool} \PYG{n}{varimport}\PYG{p}{;} \PYG{c+c1}{// Used to check whether the map variables have already been imported.}
    \PYG{c+c1}{// New private vectors}
    \PYG{c+c1}{// The time variables (for timing the simulation in real time)}
    \PYG{k+kt}{time\PYGZus{}t} \PYG{n}{start}\PYG{p}{,} \PYG{n}{sim\PYGZus{}start}\PYG{p}{,}\PYG{n}{sim\PYGZus{}end}\PYG{p}{,}\PYG{n}{now}\PYG{p}{,}\PYG{n}{tCheckSpec}\PYG{p}{,}\PYG{n}{sim\PYGZus{}finish}\PYG{p}{,} \PYG{n}{out\PYGZus{}finish}\PYG{p}{;}
    \PYG{c+c1}{// Map object containing both the coarse and fine maps for checking whether or not there is forest at a particular location.}
    \PYG{n}{Map} \PYG{n}{forestmap}\PYG{p}{;}
    \PYG{c+c1}{// An indexing spread for the lineages}
    \PYG{n}{Matrix}\PYG{o}{\PYGZlt{}}\PYG{n}{SpeciesList}\PYG{o}{\PYGZgt{}} \PYG{n}{grid}\PYG{p}{;}
    \PYG{n}{Row}\PYG{o}{\PYGZlt{}}\PYG{n}{Datapoint}\PYG{o}{\PYGZgt{}} \PYG{n}{active}\PYG{p}{;}
    \PYG{c+c1}{// Active lineages stored as a row of datapoints}
    \PYG{c+c1}{// Stores the point of the end of the active vector}
    \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{endactive}\PYG{p}{;} \PYG{c+c1}{// 0 is reserved as null}
    \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{startendactive}\PYG{p}{;} \PYG{c+c1}{// the maximum size of endactive}
    \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{maxsimsize}\PYG{p}{;} \PYG{c+c1}{// the maximum simulated number of individuals in the present day.}
    \PYG{c+c1}{//This might need to be updated for simulations that have large changes in maximum population size over time.}

    \PYG{c+c1}{// number of simulation steps}
    \PYG{k+kt}{long} \PYG{n}{steps}\PYG{p}{;}
    \PYG{c+c1}{// number of generations passed, dispersal and zfat references}
    \PYG{k+kt}{double} \PYG{n}{generation}\PYG{p}{,} \PYG{n}{zfat}\PYG{p}{,} \PYG{n}{dLvalue}\PYG{p}{,} \PYG{n}{maxtime}\PYG{p}{,} \PYG{n}{deme\PYGZus{}sample}\PYG{p}{;}
    \PYG{k+kt}{long} \PYG{k+kt}{double} \PYG{n}{spec}\PYG{p}{;}
    \PYG{k+kt}{double} \PYG{n}{lambda}\PYG{p}{;} \PYG{c+c1}{// the cost for moving through non\PYGZhy{}forest. 1.0 means there is no cost. 10 means that movement is 10x slower through forest.}
    \PYG{k+kt}{long} \PYG{n}{deme}\PYG{p}{;}
    \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{desired\PYGZus{}specnum}\PYG{p}{;} \PYG{c+c1}{// the desired number of species we are aiming for. If it is 0, we will carry on forever.}
    \PYG{c+c1}{//sqlite3 object that stores all the data}
    \PYG{n}{sqlite3} \PYG{o}{*}\PYG{n}{database}\PYG{p}{;}
    \PYG{c+c1}{// If sql database is written first to memory, then need another object to contain the in\PYGZhy{}memory database.}
    \PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifdef sql\PYGZus{}ram}
    \PYG{n}{sqlite3} \PYG{o}{*}\PYG{n}{outdatabase}\PYG{p}{;}
    \PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif}
    \PYG{n}{string} \PYG{n}{sqloutname}\PYG{p}{;}
    \PYG{n}{Treelist} \PYG{n}{tl}\PYG{p}{;} \PYG{c+c1}{// for create the link to the speciationcounter object which handles everything.}
    \PYG{n}{Datamask} \PYG{n}{samplegrid}\PYG{p}{;} \PYG{c+c1}{// contains the Datamask for where we should start lineages from.}
\PYG{k}{public}\PYG{o}{:}

    \PYG{c+c1}{// constructor}
    \PYG{n}{Tree}\PYG{p}{(}\PYG{p}{)} \PYG{o}{:} \PYG{n}{tl}\PYG{p}{(}\PYG{n}{data}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{enddata} \PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;}
        \PYG{n}{seeded} \PYG{o}{=} \PYG{n+nb}{false}\PYG{p}{;}
        \PYG{n}{the\PYGZus{}seed} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{10}\PYG{p}{;}
        \PYG{n}{debug} \PYG{o}{=} \PYG{n+nb}{false}\PYG{p}{;} \PYG{c+c1}{// set this equal to true if you want to enable debugging}
        \PYG{n}{log\PYGZus{}all} \PYG{o}{=} \PYG{n+nb}{true}\PYG{p}{;} \PYG{c+c1}{//set this equal to true if you want to log every 5 seconds to a logfile.}
        \PYG{n}{the\PYGZus{}task} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{;}
        \PYG{n}{varimport} \PYG{o}{=} \PYG{n+nb}{false}\PYG{p}{;}
        \PYG{n}{sqloutname} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{null}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}


    \PYG{k+kt}{void} \PYG{n}{setMapVars}\PYG{p}{(}\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{n}{string}\PYG{o}{\PYGZgt{}} \PYG{n}{comargs}\PYG{p}{,} \PYG{k+kt}{bool} \PYG{n}{fullmode}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{mapvarsin}\PYG{p}{.}\PYG{n}{import}\PYG{p}{(}\PYG{n}{comargs}\PYG{p}{,} \PYG{n}{fullmode}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{mapvarsin}\PYG{p}{.}\PYG{n}{printVars}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{if}\PYG{p}{(}\PYG{o}{!}\PYG{n}{varimport}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}

            \PYG{c+c1}{// Set the variables equal to the value from the Mapvars object.}
            \PYG{n}{finemapinput} \PYG{o}{=} \PYG{n}{mapvarsin}\PYG{p}{.}\PYG{n}{finemapfile}\PYG{p}{;}
            \PYG{n}{coarsemapinput} \PYG{o}{=} \PYG{n}{mapvarsin}\PYG{p}{.}\PYG{n}{coarsemapfile}\PYG{p}{;}
            \PYG{n}{gridxsize} \PYG{o}{=} \PYG{n}{mapvarsin}\PYG{p}{.}\PYG{n}{vargridxsize}\PYG{p}{;}
            \PYG{n}{gridysize} \PYG{o}{=} \PYG{n}{mapvarsin}\PYG{p}{.}\PYG{n}{vargridysize}\PYG{p}{;}

            \PYG{n}{finemapxsize} \PYG{o}{=} \PYG{n}{mapvarsin}\PYG{p}{.}\PYG{n}{varfinemapxsize}\PYG{p}{;}
            \PYG{n}{finemapysize} \PYG{o}{=} \PYG{n}{mapvarsin}\PYG{p}{.}\PYG{n}{varfinemapysize}\PYG{p}{;}
            \PYG{n}{finemapxoffset} \PYG{o}{=} \PYG{n}{mapvarsin}\PYG{p}{.}\PYG{n}{varfinemapxoffset}\PYG{p}{;}
            \PYG{n}{finemapyoffset} \PYG{o}{=} \PYG{n}{mapvarsin}\PYG{p}{.}\PYG{n}{varfinemapyoffset}\PYG{p}{;}

            \PYG{n}{coarsemapxsize}  \PYG{o}{=} \PYG{n}{mapvarsin}\PYG{p}{.}\PYG{n}{varcoarsemapxsize}\PYG{p}{;}
            \PYG{n}{coarsemapysize} \PYG{o}{=} \PYG{n}{mapvarsin}\PYG{p}{.}\PYG{n}{varcoarsemapysize}\PYG{p}{;}
            \PYG{n}{coarsemapxoffset} \PYG{o}{=} \PYG{n}{mapvarsin}\PYG{p}{.}\PYG{n}{varcoarsemapxoffset}\PYG{p}{;}
            \PYG{n}{coarsemapyoffset} \PYG{o}{=} \PYG{n}{mapvarsin}\PYG{p}{.}\PYG{n}{varcoarsemapyoffset}\PYG{p}{;}
            \PYG{n}{coarsemapscale} \PYG{o}{=} \PYG{n}{mapvarsin}\PYG{p}{.}\PYG{n}{varcoarsemapscale}\PYG{p}{;}

            \PYG{n}{outdirectory} \PYG{o}{=} \PYG{n}{mapvarsin}\PYG{p}{.}\PYG{n}{outdirectory}\PYG{p}{;}

            \PYG{n}{lambda} \PYG{o}{=} \PYG{n}{mapvarsin}\PYG{p}{.}\PYG{n}{lambda}\PYG{p}{;}
            \PYG{n}{the\PYGZus{}task} \PYG{o}{=} \PYG{n}{mapvarsin}\PYG{p}{.}\PYG{n}{the\PYGZus{}task}\PYG{p}{;}
            \PYG{n}{desired\PYGZus{}specnum} \PYG{o}{=} \PYG{n}{mapvarsin}\PYG{p}{.}\PYG{n}{desired\PYGZus{}specnum}\PYG{p}{;}

            \PYG{c+c1}{// pristine map information}
            \PYG{n}{pristinefinemapinput} \PYG{o}{=} \PYG{n}{mapvarsin}\PYG{p}{.}\PYG{n}{pristinefinemapfile}\PYG{p}{;}
            \PYG{n}{pristinecoarsemapinput} \PYG{o}{=} \PYG{n}{mapvarsin}\PYG{p}{.}\PYG{n}{pristinecoarsemapfile}\PYG{p}{;}
            \PYG{n}{dPristine} \PYG{o}{=} \PYG{n}{mapvarsin}\PYG{p}{.}\PYG{n}{dPristine}\PYG{p}{;}
            \PYG{n}{dForestTransform} \PYG{o}{=} \PYG{n}{mapvarsin}\PYG{p}{.}\PYG{n}{dForestTransform}\PYG{p}{;}

            \PYG{n}{deme} \PYG{o}{=} \PYG{n}{mapvarsin}\PYG{p}{.}\PYG{n}{deme}\PYG{p}{;}
            \PYG{n}{deme\PYGZus{}sample} \PYG{o}{=} \PYG{n}{mapvarsin}\PYG{p}{.}\PYG{n}{deme\PYGZus{}sample}\PYG{p}{;}
            \PYG{n}{spec} \PYG{o}{=} \PYG{n}{mapvarsin}\PYG{p}{.}\PYG{n}{spec}\PYG{p}{;}
            \PYG{n}{zfat} \PYG{o}{=} \PYG{n}{mapvarsin}\PYG{p}{.}\PYG{n}{zfat}\PYG{p}{;}
            \PYG{n}{dLvalue} \PYG{o}{=} \PYG{n}{mapvarsin}\PYG{p}{.}\PYG{n}{dLvalue}\PYG{p}{;}
            \PYG{n}{maxtime} \PYG{o}{=} \PYG{n}{mapvarsin}\PYG{p}{.}\PYG{n}{maxtime}\PYG{p}{;}
            \PYG{n}{autocorrel\PYGZus{}file} \PYG{o}{=} \PYG{n}{mapvarsin}\PYG{p}{.}\PYG{n}{autocorrel\PYGZus{}file}\PYG{p}{;}
            \PYG{n}{varimport} \PYG{o}{=} \PYG{n+nb}{true}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{else}
        \PYG{p}{\PYGZob{}}
            \PYG{k}{throw} \PYG{n}{Main\PYGZus{}Exception}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ERROR\PYGZus{}MAIN\PYGZus{}001: Variables already imported.}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{return}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{double}\PYG{o}{\PYGZgt{}} \PYG{n}{getTemporalSampling}\PYG{p}{(}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{bAutocorrel}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{k}{return}\PYG{p}{(}\PYG{n}{autocorrel\PYGZus{}times}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{else}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{double}\PYG{o}{\PYGZgt{}} \PYG{n}{tmp}\PYG{p}{;}
            \PYG{n}{tmp}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{l+m+mf}{0.0}\PYG{p}{)}\PYG{p}{;}
            \PYG{k}{return}\PYG{p}{(}\PYG{n}{tmp}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
    \PYG{p}{\PYGZcb{}}

    \PYG{c+c1}{// Imports the maps using the variables stored in the class. This function must be run after the set\PYGZus{}mapvars() in order to function correctly.}
    \PYG{k+kt}{void} \PYG{n}{importMaps}\PYG{p}{(}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{varimport}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{c+c1}{// Set the dimensions}
            \PYG{k}{try}
            \PYG{p}{\PYGZob{}}
                \PYG{n}{forestmap}\PYG{p}{.}\PYG{n}{setDims}\PYG{p}{(}\PYG{n}{mapvarsin}\PYG{p}{)}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
            \PYG{k}{catch}\PYG{p}{(}\PYG{n}{Map\PYGZus{}Fatal\PYGZus{}Exception}\PYG{o}{\PYGZam{}} \PYG{n}{mf}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{n}{cerr} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{mf}\PYG{p}{.}\PYG{n}{what}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
                \PYG{n}{exit}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
            \PYG{k}{try}
            \PYG{p}{\PYGZob{}}
                \PYG{c+c1}{// Set the time variables}
                \PYG{n}{forestmap}\PYG{p}{.}\PYG{n}{checkMapExists}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
                \PYG{c+c1}{//forestmap.setTimeVars(dPristine,dForestTransform);}
                \PYG{c+c1}{// Import the fine map}
                \PYG{n}{forestmap}\PYG{p}{.}\PYG{n}{calcFineMap}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
                \PYG{c+c1}{// Import the coarse map}
                \PYG{n}{forestmap}\PYG{p}{.}\PYG{n}{calcCoarseMap}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
                \PYG{c+c1}{// Calculate the offset for the extremeties of each map}
                \PYG{n}{forestmap}\PYG{p}{.}\PYG{n}{calcOffset}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
                \PYG{c+c1}{// Import the pristine maps;}
                \PYG{n}{forestmap}\PYG{p}{.}\PYG{n}{calcPristineFineMap}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
                \PYG{n}{forestmap}\PYG{p}{.}\PYG{n}{calcPristineCoarseMap}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
            \PYG{k}{catch}\PYG{p}{(}\PYG{n}{Map\PYGZus{}Exception}\PYG{o}{\PYGZam{}} \PYG{n}{me}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{n}{cerr} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{me}\PYG{p}{.}\PYG{n}{what}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
                \PYG{n}{cerr} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{No dimensions set \PYGZhy{} can\PYGZsq{}t start simulations}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
                \PYG{n}{exit}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
            \PYG{k}{catch}\PYG{p}{(}\PYG{n}{Map\PYGZus{}Fatal\PYGZus{}Exception}\PYG{o}{\PYGZam{}} \PYG{n}{mfe}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{n}{cerr} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{mfe}\PYG{p}{.}\PYG{n}{what}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
                \PYG{n}{exit}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}

        \PYG{p}{\PYGZcb{}}
        \PYG{k}{else}
        \PYG{p}{\PYGZob{}}
            \PYG{k}{throw} \PYG{n}{Fatal\PYGZus{}Exception}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ERROR\PYGZus{}MAIN\PYGZus{}002: Variables not imported.}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
    \PYG{p}{\PYGZcb{}}

    \PYG{k+kt}{long} \PYG{k+kt}{long} \PYG{n}{getSeed}\PYG{p}{(}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{return} \PYG{n}{the\PYGZus{}seed}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}


    \PYG{k+kt}{void} \PYG{n}{setSeed}\PYG{p}{(}\PYG{k+kt}{long} \PYG{k+kt}{long} \PYG{n}{theseedin}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{if} \PYG{p}{(}\PYG{o}{!}\PYG{n}{seeded}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{NR}\PYG{p}{.}\PYG{n}{setSeed}\PYG{p}{(}\PYG{n}{theseedin}\PYG{p}{)}\PYG{p}{;}
            \PYG{n}{the\PYGZus{}seed} \PYG{o}{=} \PYG{n}{theseedin}\PYG{p}{;}
            \PYG{n}{seeded} \PYG{o}{=} \PYG{n+nb}{true}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
    \PYG{p}{\PYGZcb{}}

    \PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{long}\PYG{o}{\PYGZgt{}} \PYG{n}{randomList}\PYG{p}{(}\PYG{k+kt}{long} \PYG{n}{maxnum} \PYG{p}{,} \PYG{k+kt}{long} \PYG{n}{numnum}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{long}\PYG{o}{\PYGZgt{}} \PYG{n}{isin}\PYG{p}{;}
        \PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{long}\PYG{o}{\PYGZgt{}} \PYG{n}{isout}\PYG{p}{;}
        \PYG{n}{isin}\PYG{p}{.}\PYG{n}{clear}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{isout}\PYG{p}{.}\PYG{n}{clear}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
        \PYG{k+kt}{long} \PYG{n}{endisout} \PYG{o}{=} \PYG{n}{maxnum} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{p}{;}
        \PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{long} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0} \PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{n}{maxnum} \PYG{p}{;} \PYG{n}{i} \PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{isout}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{n}{i}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{while} \PYG{p}{(}\PYG{k+kt}{unsigned}\PYG{p}{(}\PYG{n}{isin}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)} \PYG{o}{\PYGZlt{}} \PYG{n}{numnum}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{k+kt}{long} \PYG{n}{chosen} \PYG{o}{=} \PYG{n}{NR}\PYG{p}{.}\PYG{n}{i0}\PYG{p}{(}\PYG{n}{endisout}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
            \PYG{n}{isin}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{n}{isout}\PYG{p}{[}\PYG{n}{chosen}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
            \PYG{n}{isout}\PYG{p}{[}\PYG{n}{chosen}\PYG{p}{]} \PYG{o}{=} \PYG{n}{isout}\PYG{p}{[}\PYG{n}{endisout}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{;}
            \PYG{n}{endisout} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}

        \PYG{k}{return} \PYG{n}{isin}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{c+c1}{// New setup routine}
    \PYG{c+c1}{// This performs all set up jobs, importing the relevant files and creating the in\PYGZhy{}memory objects for simulation start.}
    \PYG{k+kt}{void} \PYG{n}{setup}\PYG{p}{(}\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{n}{string}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZam{}} \PYG{n}{comargs}\PYG{p}{,} \PYG{k+kt}{bool} \PYG{n}{fullmode}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{*************************************************}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
        \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Setting up simulation...}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
        \PYG{c+c1}{// deme = square root of Deme size \PYGZhy{} note deme*deme*number of demes is the total size of the system.  Number of demes is given by the map scenario}
        \PYG{c+c1}{// deme\PYGZus{}sample = number of individuals to be sampled from each deme (cannot be more than deme\PYGZca{}2)}
        \PYG{c+c1}{// spec = speciation rate required}
        \PYG{c+c1}{// dispersal = dispersal distance (double)}
        \PYG{c+c1}{// typeflag = 2 normal}
        \PYG{c+c1}{// typeflag != 2 fat}
        \PYG{c+c1}{// zfat = kernel fatness}
        \PYG{c+c1}{// map\PYGZus{}scenario gives the index of the predefined map list vectors that will indicate which habitat map to load}
        \PYG{c+c1}{// generations\PYGZus{}since = number of generations since disturbance at present day of sampling}
        \PYG{c+c1}{// equilibrium mask = do we ignore the generations\PYGZus{}since tag and simply run all the way to equilibrium on the fragmented landscape?}
        \PYG{c+c1}{// max time allowed for this simulation (useful for HPC runs)}
        \PYG{c+c1}{// Set the private variables for the simulation}
        \PYG{c+c1}{// Start the timer}
        \PYG{n}{time}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{start}\PYG{p}{)}\PYG{p}{;}
        \PYG{c+c1}{// Use the Mapvars object to import the necessary information}
         \PYG{n}{setMapVars}\PYG{p}{(}\PYG{n}{comargs}\PYG{p}{,} \PYG{n}{fullmode}\PYG{p}{)}\PYG{p}{;}

        \PYG{k}{try}
        \PYG{p}{\PYGZob{}}
            \PYG{k}{if}\PYG{p}{(}\PYG{n}{autocorrel\PYGZus{}file} \PYG{o}{=}\PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{null}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{n}{bAutocorrel} \PYG{o}{=} \PYG{n+nb}{false}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
            \PYG{k}{else}
            \PYG{p}{\PYGZob{}}
                \PYG{n}{bAutocorrel} \PYG{o}{=} \PYG{n+nb}{true}\PYG{p}{;}
                \PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{n}{string}\PYG{o}{\PYGZgt{}} \PYG{n}{tmpimport}\PYG{p}{;}
                \PYG{n}{ConfigOption} \PYG{n}{tmpconfig}\PYG{p}{;}
                \PYG{n}{tmpconfig}\PYG{p}{.}\PYG{n}{setConfig}\PYG{p}{(}\PYG{n}{autocorrel\PYGZus{}file}\PYG{p}{,}\PYG{n+nb}{false}\PYG{p}{)}\PYG{p}{;}
                \PYG{n}{tmpconfig}\PYG{p}{.}\PYG{n}{importConfig}\PYG{p}{(}\PYG{n}{tmpimport}\PYG{p}{)}\PYG{p}{;}
                \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}\PYG{n}{i}\PYG{o}{\PYGZlt{}}\PYG{n}{tmpimport}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}\PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
                \PYG{p}{\PYGZob{}}
                    \PYG{n}{autocorrel\PYGZus{}times}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{n}{stod}\PYG{p}{(}\PYG{n}{tmpimport}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{c+c1}{//                  cout \PYGZlt{}\PYGZlt{} \PYGZdq{}t\PYGZus{}i: \PYGZdq{} \PYGZlt{}\PYGZlt{} autocorrel\PYGZus{}times[i] \PYGZlt{}\PYGZlt{} endl;}
                \PYG{p}{\PYGZcb{}}
            \PYG{p}{\PYGZcb{}}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{catch}\PYG{p}{(}\PYG{n}{Config\PYGZus{}Exception}\PYG{o}{\PYGZam{}} \PYG{n}{ce}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{cerr} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{ce}\PYG{p}{.}\PYG{n}{what}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{c+c1}{// Make the mask map with 1 entry in each deme}
        \PYG{c+c1}{// Previous versions worked with 1 entry per individual.}
        \PYG{k}{try}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{importMaps}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{// This will import the fine and coarse maps using the routine specified in the Map class.}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{catch}\PYG{p}{(}\PYG{n}{Fatal\PYGZus{}Exception}\PYG{o}{\PYGZam{}} \PYG{n}{fe}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{cerr} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{fe}\PYG{p}{.}\PYG{n}{what}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
            \PYG{k}{throw} \PYG{n+nf}{Fatal\PYGZus{}Exception}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{c+c1}{// Set up the map recording information}

        \PYG{c+c1}{// Set the map dispersal values (so they don\PYGZsq{}t have to be passed with every function call).}
        \PYG{n}{NR}\PYG{p}{.}\PYG{n}{setDispersalParams}\PYG{p}{(}\PYG{n}{zfat}\PYG{p}{,}\PYG{n}{dLvalue}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{zfat} \PYG{o}{\PYGZlt{}} \PYG{l+m+mf}{2.0}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{cerr} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{WARNING: zfat value is less than 2. This is likely to cause severe problems with dispersal distances.}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{c+c1}{//forestmap.validateMaps();}
        \PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifdef debug\PYGZus{}mode}
        \PYG{n}{forestmap}\PYG{p}{.}\PYG{n}{validateMaps}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{// If you\PYGZsq{}re having problems with the maps generating errors, run this line to check the maps are correctly formatted.}
        \PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif}
        \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{initcount}\PYG{p}{;}
        \PYG{c+c1}{// import the grid file}
        \PYG{n}{samplegrid}\PYG{p}{.}\PYG{n}{importDatamask}\PYG{p}{(}\PYG{n}{mapvarsin}\PYG{p}{)}\PYG{p}{;}
        \PYG{c+c1}{// Get a count of the number of individuals on the grid.}
        \PYG{k}{try}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{initcount} \PYG{o}{=} \PYG{n}{forestmap}\PYG{p}{.}\PYG{n}{getInitialCount}\PYG{p}{(}\PYG{n}{deme\PYGZus{}sample}\PYG{p}{,} \PYG{n}{samplegrid}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{catch}\PYG{p}{(}\PYG{n}{exception}\PYG{o}{\PYGZam{}} \PYG{n}{e}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{cerr} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{e}\PYG{p}{.}\PYG{n}{what}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
            \PYG{k}{throw} \PYG{n+nf}{Fatal\PYGZus{}Exception}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{c+c1}{// Set active and data at the correct sizes.}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{initcount} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Initial count is 0. No individuals to simulate. Exiting program.}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
            \PYG{n}{exit}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{n}{active}\PYG{p}{.}\PYG{n}{SetRowSize}\PYG{p}{(}\PYG{n}{initcount}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{data}\PYG{p}{.}\PYG{n}{SetRowSize}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{initcount}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
        \PYG{c+c1}{// Make the grid size with 1 entry per deme.}
        \PYG{c+c1}{// Previous versions used 1 entry per individual for increased spatial movement. However, with percentage cover, this was now deemed unneccessary.}
        \PYG{n}{grid}\PYG{p}{.}\PYG{n}{SetSize}\PYG{p}{(}\PYG{n}{gridysize}\PYG{p}{,}\PYG{n}{gridxsize}\PYG{p}{)}\PYG{p}{;}
        \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{numstart}\PYG{p}{;}
        \PYG{n}{numstart} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
        \PYG{n}{endactive} \PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;}
        \PYG{n}{active}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{.}\PYG{n}{setup}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}
\PYG{c+c1}{//      data[0].setSpec(1.0);}
        \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}r}\PYG{l+s}{Setting up simulation...filling grid                           }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{flush}\PYG{p}{;}

        \PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{long} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0} \PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{gridxsize} \PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{long} \PYG{n}{j} \PYG{o}{=} \PYG{l+m+mi}{0} \PYG{p}{;} \PYG{n}{j} \PYG{o}{\PYGZlt{}} \PYG{n}{gridysize} \PYG{p}{;} \PYG{n}{j}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{n}{grid}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{initialise}\PYG{p}{(}\PYG{n}{forestmap}\PYG{p}{.}\PYG{n}{getVal}\PYG{p}{(}\PYG{n}{i}\PYG{p}{,}\PYG{n}{j}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
                \PYG{n}{grid}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{fillList}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
                \PYG{n}{grid}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{setNwrap}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}
                \PYG{n}{grid}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{setNext}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}
                \PYG{c+c1}{// loop over the species list, adding the correct number of species in each placement.}
                \PYG{c+c1}{// Use the sampling to determine how many individuals to start in each position.}
                \PYG{k}{if}\PYG{p}{(}\PYG{n}{samplegrid}\PYG{p}{.}\PYG{n}{getVal}\PYG{p}{(}\PYG{n}{i}\PYG{p}{,}\PYG{n}{j}\PYG{p}{)}\PYG{p}{)}
                \PYG{p}{\PYGZob{}}
                    \PYG{k+kt}{double} \PYG{n}{dSample\PYGZus{}amount} \PYG{o}{=} \PYG{n}{floor}\PYG{p}{(}\PYG{n}{deme\PYGZus{}sample}\PYG{o}{*}\PYG{n}{grid}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getMaxsize}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
                    \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{k}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;}\PYG{n}{k}\PYG{o}{\PYGZlt{}}\PYG{n}{dSample\PYGZus{}amount}\PYG{p}{;}\PYG{n}{k}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
                    \PYG{p}{\PYGZob{}}
                        \PYG{k}{if}\PYG{p}{(}\PYG{n}{k}\PYG{o}{\PYGZgt{}}\PYG{o}{=}\PYG{n}{grid}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getMaxsize}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
                        \PYG{p}{\PYGZob{}}
                            \PYG{k}{break}\PYG{p}{;}
                        \PYG{p}{\PYGZcb{}}
                        \PYG{k}{else}
                        \PYG{p}{\PYGZob{}}
                            \PYG{n}{numstart} \PYG{o}{+}\PYG{o}{+}\PYG{p}{;}
                            \PYG{k+kt}{int} \PYG{n}{listpos} \PYG{o}{=} \PYG{n}{grid}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{addSpecies}\PYG{p}{(}\PYG{n}{numstart}\PYG{p}{)}\PYG{p}{;}
                            \PYG{c+c1}{// Add the species to active}
                            \PYG{n}{active}\PYG{p}{[}\PYG{n}{numstart}\PYG{p}{]}\PYG{p}{.}\PYG{n}{setup}\PYG{p}{(}\PYG{n}{i}\PYG{p}{,}\PYG{n}{j}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{n}{numstart}\PYG{p}{,}\PYG{n}{listpos}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
                            \PYG{c+c1}{// Add a tip in the Treenode for calculation of the coalescence tree at the end of the simulation.}
                            \PYG{c+c1}{// This also contains the start x and y position of the species.}
                            \PYG{n}{data}\PYG{p}{[}\PYG{n}{numstart}\PYG{p}{]}\PYG{p}{.}\PYG{n}{setup}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{i}\PYG{p}{,}\PYG{n}{j}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}
                            \PYG{n}{data}\PYG{p}{[}\PYG{n}{numstart}\PYG{p}{]}\PYG{p}{.}\PYG{n}{setSpec}\PYG{p}{(}\PYG{n}{NR}\PYG{p}{.}\PYG{n}{d01}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
                            \PYG{n}{endactive} \PYG{o}{+}\PYG{o}{+}\PYG{p}{;}
                            \PYG{n}{enddata} \PYG{o}{+}\PYG{o}{+}\PYG{p}{;}
                        \PYG{p}{\PYGZcb{}}
                    \PYG{p}{\PYGZcb{}}
                \PYG{p}{\PYGZcb{}}
            \PYG{p}{\PYGZcb{}}
        \PYG{p}{\PYGZcb{}}
\PYG{c+c1}{//      cout \PYGZlt{}\PYGZlt{} \PYGZdq{}check!\PYGZdq{} \PYGZlt{}\PYGZlt{} endl;}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{numstart} \PYG{o}{=}\PYG{o}{=} \PYG{n}{initcount}\PYG{p}{)} \PYG{c+c1}{// Check that the two counting methods match up.}
        \PYG{p}{\PYGZob{}}

        \PYG{p}{\PYGZcb{}}
        \PYG{k}{else}
        \PYG{p}{\PYGZob{}}
            \PYG{k}{if}\PYG{p}{(}\PYG{n}{initcount} \PYG{o}{\PYGZgt{}} \PYG{l+m+mf}{1.1}\PYG{o}{*}\PYG{n}{numstart}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{n}{cerr} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Data usage higher than neccessary \PYGZhy{} check allocation of individuals to the grid.}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
            \PYG{c+c1}{// this error is silenced as of v3.1 due to a difference in the counting methods of initcount and numstart when taking into account the sampling.}
\PYG{c+c1}{//          cout \PYGZlt{}\PYGZlt{} \PYGZdq{}ERROR\PYGZus{}MAIN\PYGZus{}004: numstart not equal to initcount\PYGZdq{} \PYGZlt{}\PYGZlt{} endl;}
\PYG{c+c1}{//          cout \PYGZlt{}\PYGZlt{} \PYGZdq{}numstart: \PYGZdq{} \PYGZlt{}\PYGZlt{} numstart \PYGZlt{}\PYGZlt{} \PYGZdq{} initcount: \PYGZdq{} \PYGZlt{}\PYGZlt{} initcount \PYGZlt{}\PYGZlt{} endl;}
\PYG{c+c1}{//          cout \PYGZlt{}\PYGZlt{} \PYGZdq{}endactive: \PYGZdq{} \PYGZlt{}\PYGZlt{} endactive \PYGZlt{}\PYGZlt{} \PYGZdq{} enddata: \PYGZdq{} \PYGZlt{}\PYGZlt{} enddata \PYGZlt{}\PYGZlt{} endl;}
        \PYG{p}{\PYGZcb{}}
        \PYG{c+c1}{// other variables}
        \PYG{n}{steps} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
        \PYG{n}{generation} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
        \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}r}\PYG{l+s}{Setting up simulation...done!                           }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
        \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Number of individuals simulated: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endactive}  \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
        \PYG{n}{maxsimsize} \PYG{o}{=} \PYG{n}{enddata}\PYG{p}{;}
\PYG{c+c1}{//      cout \PYGZlt{}\PYGZlt{} \PYGZdq{}Endactive: \PYGZdq{} \PYGZlt{}\PYGZlt{} endactive \PYGZlt{}\PYGZlt{} endl;}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{active}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{o}{\PYGZlt{}}\PYG{n}{endactive} \PYG{o}{\textbar{}}\PYG{o}{\textbar{}} \PYG{n}{endactive} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{cerr} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{endactive: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endactive} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
            \PYG{n}{cerr} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{active.size: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{active}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
            \PYG{n}{cerr} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{initcount: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{initcount} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
            \PYG{n}{cerr} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{numstart: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{n}{numstart} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
            \PYG{k}{if}\PYG{p}{(}\PYG{n}{endactive} \PYG{o}{=}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{No individuals to simulate! Check map set up. Exiting...}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
                \PYG{n}{exit}\PYG{p}{(}\PYG{n}{EXIT\PYGZus{}SUCCESS}\PYG{p}{)}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
            \PYG{k}{else}
            \PYG{p}{\PYGZob{}}
                \PYG{k}{throw} \PYG{n}{Fatal\PYGZus{}Exception}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ERROR\PYGZus{}MAIN\PYGZus{}007: FATAL. Sizing error \PYGZhy{} endactive is greater than the size of active.}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
        \PYG{p}{\PYGZcb{}}
        \PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifdef debug\PYGZus{}mode}
        \PYG{c+c1}{// Checks that each lineage is placed in a legal place.}
        \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{int} \PYG{n}{i}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;}\PYG{n}{i}\PYG{o}{\PYGZlt{}}\PYG{o}{=}\PYG{n}{endactive}\PYG{p}{;}\PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{k}{if}\PYG{p}{(}\PYG{n}{forestmap}\PYG{p}{.}\PYG{n}{getVal}\PYG{p}{(}\PYG{n}{active}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getXpos}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,}\PYG{n}{active}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getYpos}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{o}{=}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{k}{throw} \PYG{n}{Fatal\PYGZus{}Exception}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ERROR\PYGZus{}MAIN\PYGZus{}006: FATAL.  Setup is placing lineages in areas with no forest.}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
            \PYG{k}{if}\PYG{p}{(}\PYG{n}{active}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getListpos}\PYG{p}{(}\PYG{p}{)}\PYG{o}{\PYGZgt{}}\PYG{n}{grid}\PYG{p}{[}\PYG{n}{active}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getYpos}\PYG{p}{(}\PYG{p}{)}\PYG{p}{]}\PYG{p}{[}\PYG{n}{active}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getXpos}\PYG{p}{(}\PYG{p}{)}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getMaxsize}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{FAIL2 IN }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{i} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
                \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{x,y: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{active}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getXpos}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{,}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{active}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getYpos}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ \PYGZhy{} listpos: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{active}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getListpos}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ maxsize: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{grid}\PYG{p}{[}\PYG{n}{active}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getYpos}\PYG{p}{(}\PYG{p}{)}\PYG{p}{]}\PYG{p}{[}\PYG{n}{active}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getYpos}\PYG{p}{(}\PYG{p}{)}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getMaxsize}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
                \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{forestmap count: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{forestmap}\PYG{p}{.}\PYG{n}{getVal}\PYG{p}{(}\PYG{n}{active}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getXpos}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,}\PYG{n}{active}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getYpos}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
                \PYG{n}{exit}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
        \PYG{p}{\PYGZcb{}}

        \PYG{c+c1}{// validate all lineages}
        \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;}\PYG{n}{i}\PYG{o}{\PYGZlt{}}\PYG{o}{=}\PYG{n}{endactive}\PYG{p}{;}\PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{validationCheck}\PYG{p}{(}\PYG{n}{i}\PYG{p}{,}\PYG{l+m+mi}{200}\PYG{p}{,}\PYG{n}{i}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif}
    \PYG{p}{\PYGZcb{}}


    \PYG{k+kt}{void} \PYG{n}{removeOldPos}\PYG{p}{(}\PYG{k}{const} \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{chosen}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k+kt}{long} \PYG{n}{nwrap} \PYG{o}{=} \PYG{n}{active}\PYG{p}{[}\PYG{n}{chosen}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getNwrap}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
        \PYG{k+kt}{long} \PYG{n}{oldx} \PYG{o}{=} \PYG{n}{active}\PYG{p}{[}\PYG{n}{chosen}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getXpos}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
        \PYG{k+kt}{long} \PYG{n}{oldy} \PYG{o}{=} \PYG{n}{active}\PYG{p}{[}\PYG{n}{chosen}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getYpos}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{if}\PYG{p}{(} \PYG{n}{nwrap}\PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{k}{if}\PYG{p}{(}\PYG{n}{active}\PYG{p}{[}\PYG{n}{chosen}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getXwrap}\PYG{p}{(}\PYG{p}{)} \PYG{o}{!}\PYG{o}{=} \PYG{l+m+mi}{0} \PYG{o}{\textbar{}}\PYG{o}{\textbar{}} \PYG{n}{active}\PYG{p}{[}\PYG{n}{chosen}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getYwrap}\PYG{p}{(}\PYG{p}{)} \PYG{o}{!}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{n}{cerr} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{chosen: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}  \PYG{n}{chosen} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
                \PYG{n}{cerr} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{x,y wrap: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{active}\PYG{p}{[}\PYG{n}{chosen}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getXwrap}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{,}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{active}\PYG{p}{[}\PYG{n}{chosen}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getYwrap}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
                \PYG{k}{throw} \PYG{n+nf}{Fatal\PYGZus{}Exception}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ERROR\PYGZus{}MOVE\PYGZus{}015: Nwrap not set correctly. Nwrap 0, but x and y wrap not 0. }\PYG{l+s}{\PYGZdq{}} \PYG{p}{)}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
            \PYG{c+c1}{// Then the lineage exists in the main list;}
            \PYG{c+c1}{// debug (can be removed later)}
            \PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifdef pristine\PYGZus{}mode}
            \PYG{k}{if}\PYG{p}{(}\PYG{n}{grid}\PYG{p}{[}\PYG{n}{oldy}\PYG{p}{]}\PYG{p}{[}\PYG{n}{oldx}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getMaxsize}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZlt{}} \PYG{n}{active}\PYG{p}{[}\PYG{n}{chosen}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getListpos}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{n}{cerr} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{grid maxsize: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{grid}\PYG{p}{[}\PYG{n}{oldy}\PYG{p}{]}\PYG{p}{[}\PYG{n}{oldx}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getMaxsize}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
                \PYG{k}{throw} \PYG{n+nf}{Fatal\PYGZus{}Exception}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ERROR\PYGZus{}MOVE\PYGZus{}001: Listpos outside maxsize. Check move programming function.}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
            \PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif}
            \PYG{c+c1}{// delete the species from the list}
            \PYG{n}{grid}\PYG{p}{[}\PYG{n}{oldy}\PYG{p}{]}\PYG{p}{[}\PYG{n}{oldx}\PYG{p}{]}\PYG{p}{.}\PYG{n}{deleteSpecies}\PYG{p}{(}\PYG{n}{active}\PYG{p}{[}\PYG{n}{chosen}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getListpos}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
            \PYG{c+c1}{// clear out the variables.}
            \PYG{n}{active}\PYG{p}{[}\PYG{n}{chosen}\PYG{p}{]}\PYG{p}{.}\PYG{n}{setNext}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}
            \PYG{n}{active}\PYG{p}{[}\PYG{n}{chosen}\PYG{p}{]}\PYG{p}{.}\PYG{n}{setNwrap}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}
            \PYG{n}{active}\PYG{p}{[}\PYG{n}{chosen}\PYG{p}{]}\PYG{p}{.}\PYG{n}{setListpos}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{else} \PYG{c+c1}{// need to loop over the nwrap to check nexts}
        \PYG{p}{\PYGZob{}}
            \PYG{k}{if}\PYG{p}{(}\PYG{n}{nwrap}\PYG{o}{=}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{n}{grid}\PYG{p}{[}\PYG{n}{oldy}\PYG{p}{]}\PYG{p}{[}\PYG{n}{oldx}\PYG{p}{]}\PYG{p}{.}\PYG{n}{setNext}\PYG{p}{(}\PYG{n}{active}\PYG{p}{[}\PYG{n}{chosen}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getNext}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
                \PYG{c+c1}{// Now reduce the nwrap of the lineages that have been effected.}
                \PYG{k+kt}{long} \PYG{n}{nextpos} \PYG{o}{=} \PYG{n}{active}\PYG{p}{[}\PYG{n}{chosen}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getNext}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
                \PYG{c+c1}{// loop over the rest of the list, reducing the nwrap}
                \PYG{k}{while}\PYG{p}{(}\PYG{n}{nextpos}\PYG{o}{!}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
                \PYG{p}{\PYGZob{}}
                    \PYG{n}{active}\PYG{p}{[}\PYG{n}{nextpos}\PYG{p}{]}\PYG{p}{.}\PYG{n}{decreaseNwrap}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
                    \PYG{n}{nextpos} \PYG{o}{=} \PYG{n}{active}\PYG{p}{[}\PYG{n}{nextpos}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getNext}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
                \PYG{p}{\PYGZcb{}}
                \PYG{c+c1}{// decrease the nwrap}
                \PYG{n}{grid}\PYG{p}{[}\PYG{n}{oldy}\PYG{p}{]}\PYG{p}{[}\PYG{n}{oldx}\PYG{p}{]}\PYG{p}{.}\PYG{n}{decreaseNwrap}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
                \PYG{n}{active}\PYG{p}{[}\PYG{n}{chosen}\PYG{p}{]}\PYG{p}{.}\PYG{n}{setNwrap}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}
                \PYG{n}{active}\PYG{p}{[}\PYG{n}{chosen}\PYG{p}{]}\PYG{p}{.}\PYG{n}{setNext}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}
                \PYG{n}{active}\PYG{p}{[}\PYG{n}{chosen}\PYG{p}{]}\PYG{p}{.}\PYG{n}{setListpos}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}
                \PYG{n}{nwrap} \PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
            \PYG{k}{else}
            \PYG{p}{\PYGZob{}}
                \PYG{k+kt}{long} \PYG{n}{lastpos} \PYG{o}{=} \PYG{n}{grid}\PYG{p}{[}\PYG{n}{oldy}\PYG{p}{]}\PYG{p}{[}\PYG{n}{oldx}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getNext}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
                \PYG{k}{while}\PYG{p}{(}\PYG{n}{active}\PYG{p}{[}\PYG{n}{lastpos}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getNext}\PYG{p}{(}\PYG{p}{)}\PYG{o}{!}\PYG{o}{=}\PYG{n}{chosen}\PYG{p}{)} \PYG{c+c1}{// loop until we reach the next, then set the next correctly.}
                \PYG{p}{\PYGZob{}}
                    \PYG{n}{lastpos} \PYG{o}{=} \PYG{n}{active}\PYG{p}{[}\PYG{n}{lastpos}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getNext}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
                \PYG{p}{\PYGZcb{}}
                \PYG{k}{if}\PYG{p}{(}\PYG{n}{lastpos}\PYG{o}{!}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
                \PYG{p}{\PYGZob{}}
                    \PYG{n}{active}\PYG{p}{[}\PYG{n}{lastpos}\PYG{p}{]}\PYG{p}{.}\PYG{n}{setNext}\PYG{p}{(}\PYG{n}{active}\PYG{p}{[}\PYG{n}{chosen}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getNext}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
                    \PYG{c+c1}{// check}
                    \PYG{k}{if}\PYG{p}{(}\PYG{n}{active}\PYG{p}{[}\PYG{n}{lastpos}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getNwrap}\PYG{p}{(}\PYG{p}{)}\PYG{o}{!}\PYG{o}{=}\PYG{p}{(}\PYG{n}{active}\PYG{p}{[}\PYG{n}{chosen}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getNwrap}\PYG{p}{(}\PYG{p}{)}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{)}
                    \PYG{p}{\PYGZob{}}
                        \PYG{n}{cerr} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{lastpos : }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{lastpos} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ lastpos nwrap: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{active}\PYG{p}{[}\PYG{n}{lastpos}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getNwrap}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
                        \PYG{n}{cerr} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{chosen: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{chosen} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ chosen nwrap: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{active}\PYG{p}{[}\PYG{n}{chosen}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getNwrap}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
                        \PYG{k}{throw} \PYG{n+nf}{Fatal\PYGZus{}Exception}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ERROR\PYGZus{}MOVE\PYGZus{}022: nwrap setting of either chosen or the lineage wrapped before chosen. Check move function.}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
                    \PYG{p}{\PYGZcb{}}
                    \PYG{n}{lastpos} \PYG{o}{=} \PYG{n}{active}\PYG{p}{[}\PYG{n}{lastpos}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getNext}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
                    \PYG{k}{while}\PYG{p}{(}\PYG{n}{lastpos}\PYG{o}{!}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
                    \PYG{p}{\PYGZob{}}
                        \PYG{n}{active}\PYG{p}{[}\PYG{n}{lastpos}\PYG{p}{]}\PYG{p}{.}\PYG{n}{decreaseNwrap}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
                        \PYG{n}{lastpos} \PYG{o}{=} \PYG{n}{active}\PYG{p}{[}\PYG{n}{lastpos}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getNext}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
                    \PYG{p}{\PYGZcb{}}
                \PYG{p}{\PYGZcb{}}
                \PYG{k}{else}
                \PYG{p}{\PYGZob{}}
                    \PYG{n}{cerr} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{lastpos: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{lastpos} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ endactive: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endactive} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ chosen: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{chosen} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
                    \PYG{k}{throw} \PYG{n+nf}{Fatal\PYGZus{}Exception}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ERROR\PYGZus{}MOVE\PYGZus{}024: Last position before chosen is 0 \PYGZhy{} this is impossible.}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
                \PYG{p}{\PYGZcb{}}
                \PYG{n}{grid}\PYG{p}{[}\PYG{n}{oldy}\PYG{p}{]}\PYG{p}{[}\PYG{n}{oldx}\PYG{p}{]}\PYG{p}{.}\PYG{n}{decreaseNwrap}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
                \PYG{n}{active}\PYG{p}{[}\PYG{n}{chosen}\PYG{p}{]}\PYG{p}{.}\PYG{n}{setNwrap}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}
                \PYG{n}{active}\PYG{p}{[}\PYG{n}{chosen}\PYG{p}{]}\PYG{p}{.}\PYG{n}{setNext}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}
                \PYG{n}{active}\PYG{p}{[}\PYG{n}{chosen}\PYG{p}{]}\PYG{p}{.}\PYG{n}{setListpos}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}
                \PYG{n}{nwrap} \PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
            \PYG{k+kt}{unsigned} \PYG{k+kt}{short} \PYG{n}{iCount} \PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;}
            \PYG{k+kt}{long} \PYG{n}{pos} \PYG{o}{=} \PYG{n}{grid}\PYG{p}{[}\PYG{n}{oldy}\PYG{p}{]}\PYG{p}{[}\PYG{n}{oldx}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getNext}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
            \PYG{k}{if}\PYG{p}{(}\PYG{n}{pos}\PYG{o}{=}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{n}{iCount} \PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
            \PYG{k}{else}
            \PYG{p}{\PYGZob{}}
                \PYG{k+kt}{int} \PYG{n}{c}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;}
                \PYG{k}{while}\PYG{p}{(}\PYG{n}{active}\PYG{p}{[}\PYG{n}{pos}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getNext}\PYG{p}{(}\PYG{p}{)}\PYG{o}{!}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
                \PYG{p}{\PYGZob{}}
                    \PYG{n}{c}\PYG{o}{+}\PYG{o}{+}\PYG{p}{;}
                    \PYG{n}{iCount} \PYG{o}{+}\PYG{o}{+}\PYG{p}{;}
                    \PYG{n}{pos} \PYG{o}{=} \PYG{n}{active}\PYG{p}{[}\PYG{n}{pos}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getNext}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
                    \PYG{k}{if}\PYG{p}{(}\PYG{n}{c}\PYG{o}{\PYGZgt{}}\PYG{l+m+mi}{10000}\PYG{p}{)}
                    \PYG{p}{\PYGZob{}}
                        \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{pos} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
                        \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{active}\PYG{p}{[}\PYG{n}{pos}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getNext}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
                        \PYG{k}{break}\PYG{p}{;}
                    \PYG{p}{\PYGZcb{}}
                \PYG{p}{\PYGZcb{}}
            \PYG{p}{\PYGZcb{}}

            \PYG{k}{if}\PYG{p}{(}\PYG{n}{iCount} \PYG{o}{!}\PYG{o}{=} \PYG{n}{grid}\PYG{p}{[}\PYG{n}{oldy}\PYG{p}{]}\PYG{p}{[}\PYG{n}{oldx}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getNwrap}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{n}{cerr} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Nwrap: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{grid}\PYG{p}{[}\PYG{n}{oldy}\PYG{p}{]}\PYG{p}{[}\PYG{n}{oldx}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getNwrap}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ Counted lineages: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{iCount} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
                 \PYG{k}{throw} \PYG{n+nf}{Fatal\PYGZus{}Exception}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ERROR\PYGZus{}MOVE\PYGZus{}014: Nwrap not set correctly after move for grid cell}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}

        \PYG{p}{\PYGZcb{}}
    \PYG{p}{\PYGZcb{}}


    \PYG{k+kt}{void} \PYG{n}{calcMove}\PYG{p}{(}\PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{oldx}\PYG{p}{,} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{oldy}\PYG{p}{,} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{oldxwrap}\PYG{p}{,} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{oldywrap}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{c+c1}{// initiate the move variables (distance and angle of movement)}

        \PYG{k+kt}{bool} \PYG{n}{fail}\PYG{p}{;}
        \PYG{n}{fail} \PYG{o}{=} \PYG{n+nb}{true}\PYG{p}{;}
        \PYG{c+c1}{// keep looping until we reach a viable place to move from.}
        \PYG{k}{while}\PYG{p}{(}\PYG{n}{fail}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifdef restrict\PYGZus{}self}
            \PYG{k+kt}{long} \PYG{n}{startx}\PYG{p}{,} \PYG{n}{starty}\PYG{p}{,} \PYG{n}{startxwrap}\PYG{p}{,} \PYG{n}{startywrap}\PYG{p}{;}
            \PYG{n}{startx} \PYG{o}{=} \PYG{n}{oldx}\PYG{p}{;}
            \PYG{n}{starty} \PYG{o}{=} \PYG{n}{oldy}\PYG{p}{;}
            \PYG{n}{startxwrap} \PYG{o}{=} \PYG{n}{oldxwrap}\PYG{p}{;}
            \PYG{n}{startywrap} \PYG{o}{=} \PYG{n}{oldywrap}\PYG{p}{;}
            \PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif}

            \PYG{k+kt}{double} \PYG{n}{dist}\PYG{p}{,} \PYG{n}{angle}\PYG{p}{;}
            \PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifndef normal\PYGZus{}dispersal}
            \PYG{n}{dist} \PYG{o}{=} \PYG{n}{NR}\PYG{p}{.}\PYG{n}{fattail}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}


            \PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif}
            \PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifdef normal\PYGZus{}dispersal}
            \PYG{n}{dist} \PYG{o}{=} \PYG{n}{zfat} \PYG{o}{*} \PYG{n}{NR}\PYG{p}{.}\PYG{n}{norm}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
            \PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif}
\PYG{c+c1}{//          if(dist \PYGZgt{} 1000)}
\PYG{c+c1}{//          \PYGZob{}}
\PYG{c+c1}{//              cout \PYGZlt{}\PYGZlt{} dist \PYGZlt{}\PYGZlt{} endl;}
\PYG{c+c1}{//          \PYGZcb{}}
\PYG{c+c1}{//          long startx = oldx;}
\PYG{c+c1}{//          long starty = oldy;}
\PYG{c+c1}{//          angle = fmod(NR.direction(),2*M\PYGZus{}PI);}
            \PYG{c+c1}{// Test different angle version \PYGZhy{} this is more correct (but for some reason massively increases compute time).}
            \PYG{n}{angle} \PYG{o}{=} \PYG{n}{NR}\PYG{p}{.}\PYG{n}{d01}\PYG{p}{(}\PYG{p}{)} \PYG{o}{*} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{M\PYGZus{}PI}\PYG{p}{;}
            \PYG{c+c1}{// check angle}
\PYG{c+c1}{//          if(angle \PYGZlt{} M\PYGZus{}PI)}
\PYG{c+c1}{//          \PYGZob{}}
\PYG{c+c1}{//              cout \PYGZlt{}\PYGZlt{} \PYGZdq{}angle \PYGZlt{} pi\PYGZdq{} \PYGZlt{}\PYGZlt{} endl;}
\PYG{c+c1}{//          \PYGZcb{}}
\PYG{c+c1}{//          else if(angle \PYGZlt{} 2*M\PYGZus{}PI)}
\PYG{c+c1}{//          \PYGZob{}}
\PYG{c+c1}{//              cout \PYGZlt{}\PYGZlt{} \PYGZdq{}angle \PYGZlt{} 2*pi\PYGZdq{} \PYGZlt{}\PYGZlt{}endl;}
\PYG{c+c1}{//          \PYGZcb{}}
\PYG{c+c1}{//          else}
\PYG{c+c1}{//          \PYGZob{}}
\PYG{c+c1}{//              cout \PYGZlt{}\PYGZlt{} \PYGZdq{}angle \PYGZgt{} 2pi\PYGZdq{} \PYGZlt{}\PYGZlt{} endl;}
\PYG{c+c1}{//          \PYGZcb{}}
\PYG{c+c1}{//          if(oldx \PYGZlt{}\PYGZhy{}1)}
\PYG{c+c1}{//          \PYGZob{}}
\PYG{c+c1}{//              cout \PYGZlt{}\PYGZlt{}\PYGZdq{}x1: \PYGZdq{} \PYGZlt{}\PYGZlt{} oldx \PYGZlt{}\PYGZlt{} endl;}
\PYG{c+c1}{//          \PYGZcb{}}
            \PYG{n}{forestmap}\PYG{p}{.}\PYG{n}{runDispersal}\PYG{p}{(}\PYG{n}{dist}\PYG{p}{,}\PYG{n}{angle}\PYG{p}{,}\PYG{n}{oldx}\PYG{p}{,}\PYG{n}{oldy}\PYG{p}{,}\PYG{n}{oldxwrap}\PYG{p}{,}\PYG{n}{oldywrap}\PYG{p}{,}\PYG{n}{fail}\PYG{p}{,}\PYG{n}{generation}\PYG{p}{)}\PYG{p}{;}
\PYG{c+c1}{//          if(oldx \PYGZlt{}\PYGZhy{}1)}
\PYG{c+c1}{//          \PYGZob{}}
\PYG{c+c1}{//              cout \PYGZlt{}\PYGZlt{}\PYGZdq{}x1: \PYGZdq{} \PYGZlt{}\PYGZlt{} oldx \PYGZlt{}\PYGZlt{} endl;}
\PYG{c+c1}{//          \PYGZcb{}}
\PYG{c+c1}{//          if(dist \PYGZgt{} 1000)}
\PYG{c+c1}{//          \PYGZob{}}
\PYG{c+c1}{//              cout \PYGZlt{}\PYGZlt{} \PYGZdq{}start: \PYGZdq{} \PYGZlt{}\PYGZlt{} startx \PYGZlt{}\PYGZlt{} \PYGZdq{},\PYGZdq{} \PYGZlt{}\PYGZlt{} starty \PYGZlt{}\PYGZlt{} \PYGZdq{}pos: \PYGZdq{} \PYGZlt{}\PYGZlt{} oldx \PYGZlt{}\PYGZlt{} \PYGZdq{},\PYGZdq{} \PYGZlt{}\PYGZlt{} oldy \PYGZlt{}\PYGZlt{} \PYGZdq{} wrap: \PYGZdq{} \PYGZlt{}\PYGZlt{} oldxwrap \PYGZlt{}\PYGZlt{} \PYGZdq{},\PYGZdq{} \PYGZlt{}\PYGZlt{} oldywrap \PYGZlt{}\PYGZlt{} \PYGZdq{}fail: \PYGZdq{} \PYGZlt{}\PYGZlt{} fail \PYGZlt{}\PYGZlt{} endl;}
\PYG{c+c1}{//          \PYGZcb{}}
            \PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifdef restrict\PYGZus{}self}
            \PYG{k}{if}\PYG{p}{(}\PYG{n}{startx} \PYG{o}{=}\PYG{o}{=} \PYG{n}{oldx} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{n}{starty} \PYG{o}{=}\PYG{o}{=} \PYG{n}{oldy} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{n}{startxwrap} \PYG{o}{=}\PYG{o}{=} \PYG{n}{oldxwrap} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{n}{startywrap} \PYG{o}{=}\PYG{o}{=} \PYG{n}{oldywrap}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{n}{fail} \PYG{o}{=} \PYG{n+nb}{true}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
            \PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif}
            \PYG{k}{if}\PYG{p}{(}\PYG{n}{forestmap}\PYG{p}{.}\PYG{n}{getVal}\PYG{p}{(}\PYG{n}{oldx}\PYG{p}{,}\PYG{n}{oldy}\PYG{p}{,}\PYG{n}{oldxwrap}\PYG{p}{,}\PYG{n}{oldywrap}\PYG{p}{,}\PYG{n}{generation}\PYG{p}{)}\PYG{o}{=}\PYG{o}{=}\PYG{l+m+mi}{0} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{o}{!}\PYG{n}{fail}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{n}{cerr} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{x,y: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{oldx} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{,}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{oldy} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ x,y wrap: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{oldxwrap} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{,}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{oldywrap} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Forest cover: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{forestmap}\PYG{p}{.}\PYG{n}{getVal}\PYG{p}{(}\PYG{n}{oldx}\PYG{p}{,}\PYG{n}{oldy}\PYG{p}{,}\PYG{n}{oldxwrap}\PYG{p}{,}\PYG{n}{oldywrap}\PYG{p}{,}\PYG{n}{generation}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
                \PYG{k}{throw} \PYG{n+nf}{Fatal\PYGZus{}Exception}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ERROR\PYGZus{}MOVE\PYGZus{}007: Dispersal attempted to non\PYGZhy{}forest. Check dispersal function.}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
        \PYG{p}{\PYGZcb{}}
    \PYG{p}{\PYGZcb{}}

    \PYG{c+c1}{//}
    \PYG{c+c1}{//}
    \PYG{k+kt}{long} \PYG{k+kt}{double} \PYG{n}{calcMinMax}\PYG{p}{(}\PYG{k}{const} \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{current}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{c+c1}{// this formula calculates the speciation rate required for speciation to have occured on this branch.}
        \PYG{c+c1}{// need to allow for the case that the number of gens was 0}
        \PYG{k+kt}{long} \PYG{k+kt}{double} \PYG{n}{newminmax} \PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;}
        \PYG{k+kt}{long} \PYG{k+kt}{double} \PYG{n}{oldminmax} \PYG{o}{=} \PYG{n}{active}\PYG{p}{[}\PYG{n}{current}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getMinmax}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{data}\PYG{p}{[}\PYG{n}{active}\PYG{p}{[}\PYG{n}{current}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getMpos}\PYG{p}{(}\PYG{p}{)}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getGenRate}\PYG{p}{(}\PYG{p}{)}\PYG{o}{=}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{newminmax} \PYG{o}{=} \PYG{n}{data}\PYG{p}{[}\PYG{n}{active}\PYG{p}{[}\PYG{n}{current}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getMpos}\PYG{p}{(}\PYG{p}{)}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getSpecRate}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{else}
        \PYG{p}{\PYGZob{}}
            \PYG{c+c1}{// variables need to be defined separately for the decimal division to function properly.}
            \PYG{k+kt}{long} \PYG{k+kt}{double} \PYG{n}{tmpdSpec} \PYG{o}{=} \PYG{n}{data}\PYG{p}{[}\PYG{n}{active}\PYG{p}{[}\PYG{n}{current}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getMpos}\PYG{p}{(}\PYG{p}{)}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getSpecRate}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
            \PYG{k+kt}{long} \PYG{k+kt}{double} \PYG{n}{tmpiGen} \PYG{o}{=} \PYG{n}{data}\PYG{p}{[}\PYG{n}{active}\PYG{p}{[}\PYG{n}{current}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getMpos}\PYG{p}{(}\PYG{p}{)}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getGenRate}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
            \PYG{n}{newminmax} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{o}{\PYGZhy{}}\PYG{p}{(}\PYG{n}{pow}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{o}{\PYGZhy{}}\PYG{n}{tmpdSpec}\PYG{p}{,}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{o}{/}\PYG{n}{tmpiGen}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{k+kt}{long} \PYG{k+kt}{double} \PYG{n}{toret} \PYG{o}{=} \PYG{n}{min}\PYG{p}{(}\PYG{n}{newminmax}\PYG{p}{,}\PYG{n}{oldminmax}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{return} \PYG{n}{toret}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{k+kt}{void} \PYG{n}{coalescenceEvent}\PYG{p}{(}\PYG{k}{const} \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{chosen}\PYG{p}{,} \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{coalchosen}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{c+c1}{// coalescence occured, so we need to adjust the data appropriatedly}
        \PYG{c+c1}{// our chosen lineage has merged with the coalchosen lineage, so we need to sync up the data.}
        \PYG{n}{enddata} \PYG{o}{+}\PYG{o}{+}\PYG{p}{;}
        \PYG{n}{data}\PYG{p}{[}\PYG{n}{enddata}\PYG{p}{]}\PYG{p}{.}\PYG{n}{setup}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{n}{active}\PYG{p}{[}\PYG{n}{chosen}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getXpos}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,}\PYG{n}{active}\PYG{p}{[}\PYG{n}{chosen}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getYpos}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,}\PYG{n}{active}\PYG{p}{[}\PYG{n}{chosen}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getXwrap}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,}\PYG{n}{active}\PYG{p}{[}\PYG{n}{chosen}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getYwrap}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}

        \PYG{c+c1}{// First perform the move}
        \PYG{n}{data}\PYG{p}{[}\PYG{n}{active}\PYG{p}{[}\PYG{n}{chosen}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getMpos}\PYG{p}{(}\PYG{p}{)}\PYG{p}{]}\PYG{p}{.}\PYG{n}{setParent}\PYG{p}{(}\PYG{n}{enddata}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{data}\PYG{p}{[}\PYG{n}{active}\PYG{p}{[}\PYG{n}{coalchosen}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getMpos}\PYG{p}{(}\PYG{p}{)}\PYG{p}{]}\PYG{p}{.}\PYG{n}{setParent}\PYG{p}{(}\PYG{n}{enddata}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{active}\PYG{p}{[}\PYG{n}{coalchosen}\PYG{p}{]}\PYG{p}{.}\PYG{n}{setMinmax}\PYG{p}{(}\PYG{n}{max}\PYG{p}{(}\PYG{n}{active}\PYG{p}{[}\PYG{n}{coalchosen}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getMinmax}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,}\PYG{n}{active}\PYG{p}{[}\PYG{n}{chosen}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getMinmax}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{// set the new minmax to the maximum of the two minimums.}
        \PYG{n}{active}\PYG{p}{[}\PYG{n}{chosen}\PYG{p}{]}\PYG{p}{.}\PYG{n}{setMinmax}\PYG{p}{(}\PYG{n}{active}\PYG{p}{[}\PYG{n}{coalchosen}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getMinmax}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{data}\PYG{p}{[}\PYG{n}{enddata}\PYG{p}{]}\PYG{p}{.}\PYG{n}{setIGen}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{data}\PYG{p}{[}\PYG{n}{enddata}\PYG{p}{]}\PYG{p}{.}\PYG{n}{setSpec}\PYG{p}{(}\PYG{n}{NR}\PYG{p}{.}\PYG{n}{d01}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{active}\PYG{p}{[}\PYG{n}{chosen}\PYG{p}{]}\PYG{p}{.}\PYG{n}{setMpos}\PYG{p}{(}\PYG{n}{enddata}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{active}\PYG{p}{[}\PYG{n}{coalchosen}\PYG{p}{]}\PYG{p}{.}\PYG{n}{setMpos}\PYG{p}{(}\PYG{n}{enddata}\PYG{p}{)}\PYG{p}{;}
\PYG{c+c1}{//      removeOldPos(chosen);}
        \PYG{n}{switchPositions}\PYG{p}{(}\PYG{n}{chosen}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}


    \PYG{c+c1}{//}
    \PYG{c+c1}{//}
    \PYG{k+kt}{void} \PYG{n}{calcNewPos}\PYG{p}{(}\PYG{k+kt}{bool} \PYG{o}{\PYGZam{}}\PYG{n}{coal}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{chosen}\PYG{p}{,}\PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{coalchosen}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{oldx}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{oldy}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{oldxwrap}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{oldywrap}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{c+c1}{// Calculate the new position of the move, whilst also calculating the probability of coalescence.}
        \PYG{k+kt}{unsigned} \PYG{k+kt}{short} \PYG{n}{nwrap} \PYG{o}{=} \PYG{n}{active}\PYG{p}{[}\PYG{n}{chosen}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getNwrap}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{oldxwrap} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{0} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{n}{oldywrap} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{c+c1}{// Debug check (to remove later)}
            \PYG{k}{if}\PYG{p}{(}\PYG{n}{nwrap}\PYG{o}{!}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{k}{throw} \PYG{n}{Fatal\PYGZus{}Exception}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ERROR\PYGZus{}MOVE\PYGZus{}006: NON FATAL. Nwrap not set correctly. Check move programming function.}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
            \PYG{c+c1}{// then the procedure is relatively simple.}
            \PYG{c+c1}{// check for coalescence}
            \PYG{c+c1}{// check if the grid needs to be updated.}
            \PYG{k}{if}\PYG{p}{(}\PYG{n}{grid}\PYG{p}{[}\PYG{n}{oldy}\PYG{p}{]}\PYG{p}{[}\PYG{n}{oldx}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getMaxsize}\PYG{p}{(}\PYG{p}{)}\PYG{o}{!}\PYG{o}{=}\PYG{n}{forestmap}\PYG{p}{.}\PYG{n}{getVal}\PYG{p}{(}\PYG{n}{oldx}\PYG{p}{,}\PYG{n}{oldy}\PYG{p}{,}\PYG{n}{oldxwrap}\PYG{p}{,}\PYG{n}{oldywrap}\PYG{p}{,}\PYG{n}{generation}\PYG{p}{)}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{n}{grid}\PYG{p}{[}\PYG{n}{oldy}\PYG{p}{]}\PYG{p}{[}\PYG{n}{oldx}\PYG{p}{]}\PYG{p}{.}\PYG{n}{setMaxsize}\PYG{p}{(}\PYG{n}{forestmap}\PYG{p}{.}\PYG{n}{getVal}\PYG{p}{(}\PYG{n}{oldx}\PYG{p}{,}\PYG{n}{oldy}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{n}{generation}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
            \PYG{n}{coalchosen} \PYG{o}{=} \PYG{n}{grid}\PYG{p}{[}\PYG{n}{oldy}\PYG{p}{]}\PYG{p}{[}\PYG{n}{oldx}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getRandLineage}\PYG{p}{(}\PYG{n}{NR}\PYG{p}{)}\PYG{p}{;}
            \PYG{c+c1}{//\PYGZsh{}ifdef DEBUG}
            \PYG{k}{if}\PYG{p}{(}\PYG{n}{coalchosen} \PYG{o}{!}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{k}{if}\PYG{p}{(}\PYG{n}{active}\PYG{p}{[}\PYG{n}{coalchosen}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getXpos}\PYG{p}{(}\PYG{p}{)} \PYG{o}{!}\PYG{o}{=} \PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{long}\PYG{p}{)} \PYG{n}{oldx} \PYG{o}{\textbar{}}\PYG{o}{\textbar{}} \PYG{n}{active}\PYG{p}{[}\PYG{n}{coalchosen}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getYpos}\PYG{p}{(}\PYG{p}{)} \PYG{o}{!}\PYG{o}{=} \PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{long}\PYG{p}{)} \PYG{n}{oldy} \PYG{o}{\textbar{}}\PYG{o}{\textbar{}} \PYG{n}{active}\PYG{p}{[}\PYG{n}{coalchosen}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getXwrap}\PYG{p}{(}\PYG{p}{)} \PYG{o}{!}\PYG{o}{=} \PYG{n}{oldxwrap} \PYG{o}{\textbar{}}\PYG{o}{\textbar{}} \PYG{n}{active}\PYG{p}{[}\PYG{n}{coalchosen}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getYwrap}\PYG{p}{(}\PYG{p}{)} \PYG{o}{!}\PYG{o}{=} \PYG{n}{oldywrap}\PYG{p}{)}
                \PYG{p}{\PYGZob{}}
                    \PYG{n}{cerr} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{chosen} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{,}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{coalchosen} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
                    \PYG{n}{cerr} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{chosen \PYGZhy{} x,y: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{oldx} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{,}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{oldy} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{x, y wrap: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{oldxwrap} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{,}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{oldywrap} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
                    \PYG{n}{cerr} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{coalchosen \PYGZhy{} x,y:}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{active}\PYG{p}{[}\PYG{n}{coalchosen}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getXpos}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{,}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{active}\PYG{p}{[}\PYG{n}{coalchosen}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getYpos}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
                    \PYG{n}{cerr} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ x,y wrap: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{active}\PYG{p}{[}\PYG{n}{coalchosen}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getXwrap}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{,}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{active}\PYG{p}{[}\PYG{n}{coalchosen}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getYwrap}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
                    \PYG{k}{throw} \PYG{n+nf}{Fatal\PYGZus{}Exception}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ERROR\PYGZus{}MOVE\PYGZus{}006: NON FATAL. Nwrap not set correctly. Check move programming function.}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
                \PYG{p}{\PYGZcb{}}
            \PYG{p}{\PYGZcb{}}
            \PYG{c+c1}{//\PYGZsh{}endif}
            \PYG{k}{if}\PYG{p}{(}\PYG{n}{coalchosen} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)} \PYG{c+c1}{// then the lineage can be placed in the empty space.}
            \PYG{p}{\PYGZob{}}
                \PYG{k+kt}{long} \PYG{n}{tmplistindex} \PYG{o}{=} \PYG{n}{grid}\PYG{p}{[}\PYG{n}{oldy}\PYG{p}{]}\PYG{p}{[}\PYG{n}{oldx}\PYG{p}{]}\PYG{p}{.}\PYG{n}{addSpecies}\PYG{p}{(}\PYG{n}{chosen}\PYG{p}{)}\PYG{p}{;}
                \PYG{c+c1}{//check}
                \PYG{k}{if}\PYG{p}{(}\PYG{n}{grid}\PYG{p}{[}\PYG{n}{oldy}\PYG{p}{]}\PYG{p}{[}\PYG{n}{oldx}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getSpecies}\PYG{p}{(}\PYG{n}{tmplistindex}\PYG{p}{)}\PYG{o}{!}\PYG{o}{=}\PYG{n}{chosen}\PYG{p}{)}
                \PYG{p}{\PYGZob{}}
                    \PYG{k}{throw} \PYG{n}{Fatal\PYGZus{}Exception}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ERROR\PYGZus{}MOVE\PYGZus{}005: Grid index not set correctly for species. Check move programming function.}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
                \PYG{p}{\PYGZcb{}}
                \PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifdef pristine\PYGZus{}mode}
                \PYG{k}{if}\PYG{p}{(}\PYG{n}{grid}\PYG{p}{[}\PYG{n}{oldy}\PYG{p}{]}\PYG{p}{[}\PYG{n}{oldx}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getListsize}\PYG{p}{(}\PYG{p}{)}\PYG{o}{\PYGZgt{}} \PYG{n}{grid}\PYG{p}{[}\PYG{n}{oldy}\PYG{p}{]}\PYG{p}{[}\PYG{n}{oldx}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getMaxsize}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
                \PYG{p}{\PYGZob{}}
                    \PYG{k}{throw} \PYG{n}{Fatal\PYGZus{}Exception}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ERROR\PYGZus{}MOVE\PYGZus{}001: Listpos outside maxsize. Check move programming function.}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
                \PYG{p}{\PYGZcb{}}
                \PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif}
                \PYG{n}{active}\PYG{p}{[}\PYG{n}{chosen}\PYG{p}{]}\PYG{p}{.}\PYG{n}{setNwrap}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}
                \PYG{n}{active}\PYG{p}{[}\PYG{n}{chosen}\PYG{p}{]}\PYG{p}{.}\PYG{n}{setListpos}\PYG{p}{(}\PYG{n}{tmplistindex}\PYG{p}{)}\PYG{p}{;}
                \PYG{n}{coal}\PYG{o}{=}\PYG{n+nb}{false}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
            \PYG{k}{else} \PYG{c+c1}{// then coalescence has occured}
            \PYG{p}{\PYGZob{}}
                \PYG{n}{active}\PYG{p}{[}\PYG{n}{chosen}\PYG{p}{]}\PYG{p}{.}\PYG{n}{setNwrap}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}
                \PYG{n}{active}\PYG{p}{[}\PYG{n}{chosen}\PYG{p}{]}\PYG{p}{.}\PYG{n}{setListpos}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}
                \PYG{c+c1}{// DO THE COALESCENCE STUFF}
                \PYG{n}{coal} \PYG{o}{=} \PYG{n+nb}{true}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{else} \PYG{c+c1}{// need to check all the possible places the lineage could be.}
        \PYG{p}{\PYGZob{}}
            \PYG{k}{if}\PYG{p}{(}\PYG{n}{nwrap}\PYG{o}{!}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{k}{throw} \PYG{n}{Fatal\PYGZus{}Exception}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ERROR\PYGZus{}MOVE\PYGZus{}022: Nwrap not set correctly in move.}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
            \PYG{n}{nwrap} \PYG{o}{=} \PYG{n}{grid}\PYG{p}{[}\PYG{n}{oldy}\PYG{p}{]}\PYG{p}{[}\PYG{n}{oldx}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getNwrap}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
            \PYG{k}{if}\PYG{p}{(}\PYG{n}{nwrap} \PYG{o}{!}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)} \PYG{c+c1}{// then coalescence is possible and we need to loop over the nexts to check those that are in the same position}
            \PYG{p}{\PYGZob{}}
                \PYG{c+c1}{// Count the possible matches of the position.}
                \PYG{k+kt}{int} \PYG{n}{matches}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;}
                \PYG{c+c1}{// Create an array containing the list of active references for those that match as}
                \PYG{c+c1}{// this stops us having to loop twice over the same list.}
                \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{matchlist} \PYG{p}{[}\PYG{n}{nwrap}\PYG{p}{]}\PYG{p}{;}
                \PYG{k+kt}{long} \PYG{n}{next\PYGZus{}active}\PYG{p}{;}
                \PYG{n}{next\PYGZus{}active} \PYG{o}{=} \PYG{n}{grid}\PYG{p}{[}\PYG{n}{oldy}\PYG{p}{]}\PYG{p}{[}\PYG{n}{oldx}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getNext}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
                \PYG{c+c1}{// Count if the first \PYGZdq{}next\PYGZdq{} matches}
                \PYG{k}{if}\PYG{p}{(}\PYG{n}{active}\PYG{p}{[}\PYG{n}{next\PYGZus{}active}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getXwrap}\PYG{p}{(}\PYG{p}{)}\PYG{o}{=}\PYG{o}{=}\PYG{n}{oldxwrap} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{n}{active}\PYG{p}{[}\PYG{n}{next\PYGZus{}active}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getYwrap}\PYG{p}{(}\PYG{p}{)}\PYG{o}{=}\PYG{o}{=}\PYG{n}{oldywrap}\PYG{p}{)}
                \PYG{p}{\PYGZob{}}
                    \PYG{c+c1}{// check}
                    \PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifdef DEBUG}
                    \PYG{k}{if}\PYG{p}{(}\PYG{n}{active}\PYG{p}{[}\PYG{n}{next\PYGZus{}active}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getNwrap}\PYG{p}{(}\PYG{p}{)} \PYG{o}{!}\PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{)}
                    \PYG{p}{\PYGZob{}}
                        \PYG{k}{throw} \PYG{n}{Fatal\PYGZus{}Exception}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ERROR\PYGZus{}MOVE\PYGZus{}022a: Nwrap not set correctly in move.}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
                    \PYG{p}{\PYGZcb{}}
                    \PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif}
                    \PYG{n}{matchlist}\PYG{p}{[}\PYG{n}{matches}\PYG{p}{]} \PYG{o}{=} \PYG{n}{next\PYGZus{}active}\PYG{p}{;} \PYG{c+c1}{// add the match to the list of matches.}
                    \PYG{n}{matches} \PYG{o}{+}\PYG{o}{+}\PYG{p}{;}
                \PYG{p}{\PYGZcb{}}
                \PYG{c+c1}{// Now loop over the remaining nexts counting matches}
                \PYG{c+c1}{//\PYGZsh{}ifdef DEBUG}
                \PYG{k+kt}{unsigned} \PYG{k+kt}{int} \PYG{n}{ncount} \PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;}
                \PYG{c+c1}{//\PYGZsh{}endif}
                \PYG{k}{while}\PYG{p}{(}\PYG{n}{active}\PYG{p}{[}\PYG{n}{next\PYGZus{}active}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getNext}\PYG{p}{(}\PYG{p}{)}\PYG{o}{!}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
                \PYG{p}{\PYGZob{}}
                    \PYG{n}{next\PYGZus{}active} \PYG{o}{=} \PYG{n}{active}\PYG{p}{[}\PYG{n}{next\PYGZus{}active}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getNext}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
                    \PYG{k}{if}\PYG{p}{(}\PYG{n}{active}\PYG{p}{[}\PYG{n}{next\PYGZus{}active}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getXwrap}\PYG{p}{(}\PYG{p}{)}\PYG{o}{=}\PYG{o}{=}\PYG{n}{oldxwrap} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{n}{active}\PYG{p}{[}\PYG{n}{next\PYGZus{}active}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getYwrap}\PYG{p}{(}\PYG{p}{)}\PYG{o}{=}\PYG{o}{=}\PYG{n}{oldywrap}\PYG{p}{)}
                    \PYG{p}{\PYGZob{}}
                        \PYG{n}{matchlist}\PYG{p}{[}\PYG{n}{matches}\PYG{p}{]} \PYG{o}{=} \PYG{n}{next\PYGZus{}active}\PYG{p}{;}
                        \PYG{n}{matches} \PYG{o}{+}\PYG{o}{+}\PYG{p}{;}
                    \PYG{p}{\PYGZcb{}}
                    \PYG{c+c1}{// check}
                    \PYG{c+c1}{//\PYGZsh{}ifdef DEBUG}
                    \PYG{n}{ncount} \PYG{o}{+}\PYG{o}{+}\PYG{p}{;}
                    \PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifdef DEBUG}
                    \PYG{k}{if}\PYG{p}{(}\PYG{n}{active}\PYG{p}{[}\PYG{n}{next\PYGZus{}active}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getNwrap}\PYG{p}{(}\PYG{p}{)} \PYG{o}{!}\PYG{o}{=} \PYG{n}{ncount}\PYG{p}{)}
                    \PYG{p}{\PYGZob{}}
                        \PYG{k}{throw} \PYG{n}{Fatal\PYGZus{}Exception}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ERROR\PYGZus{}MOVE\PYGZus{}022d: Nwrap not set correctly in move.}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
                    \PYG{p}{\PYGZcb{}}
                    \PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif}
                \PYG{p}{\PYGZcb{}}
                \PYG{k}{if}\PYG{p}{(}\PYG{n}{nwrap} \PYG{o}{!}\PYG{o}{=} \PYG{n}{ncount}\PYG{p}{)}
                \PYG{p}{\PYGZob{}}
                    \PYG{k}{throw} \PYG{n}{Fatal\PYGZus{}Exception}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ERROR\PYGZus{}MOVE\PYGZus{}022c: Nwrap not set correctly in move.}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
                \PYG{p}{\PYGZcb{}}
                \PYG{c+c1}{// Matches now contains the number of lineages at the exact x,y, xwrap and ywrap position.}
                \PYG{c+c1}{// Check if there were no matches at all}
                \PYG{k}{if}\PYG{p}{(}\PYG{n}{matches}\PYG{o}{=}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
                \PYG{p}{\PYGZob{}}
                    \PYG{n}{coalchosen} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
                    \PYG{n}{coal} \PYG{o}{=} \PYG{n+nb}{false}\PYG{p}{;}
                    \PYG{n}{active}\PYG{p}{[}\PYG{n}{next\PYGZus{}active}\PYG{p}{]}\PYG{p}{.}\PYG{n}{setNext}\PYG{p}{(}\PYG{n}{chosen}\PYG{p}{)}\PYG{p}{;}
                    \PYG{n}{grid}\PYG{p}{[}\PYG{n}{oldy}\PYG{p}{]}\PYG{p}{[}\PYG{n}{oldx}\PYG{p}{]}\PYG{p}{.}\PYG{n}{increaseNwrap}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
                    \PYG{n}{active}\PYG{p}{[}\PYG{n}{chosen}\PYG{p}{]}\PYG{p}{.}\PYG{n}{setNwrap}\PYG{p}{(}\PYG{n}{grid}\PYG{p}{[}\PYG{n}{oldy}\PYG{p}{]}\PYG{p}{[}\PYG{n}{oldx}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getNwrap}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
                    \PYG{n}{active}\PYG{p}{[}\PYG{n}{chosen}\PYG{p}{]}\PYG{p}{.}\PYG{n}{setListpos}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}
                \PYG{p}{\PYGZcb{}}
                \PYG{k}{else} \PYG{c+c1}{// if there were matches, generate a random number to see if coalescence occured or not}
                \PYG{p}{\PYGZob{}}
                    \PYG{k+kt}{unsigned} \PYG{k+kt}{short} \PYG{n}{randwrap} \PYG{o}{=} \PYG{n}{floor}\PYG{p}{(}\PYG{n}{NR}\PYG{p}{.}\PYG{n}{d01}\PYG{p}{(}\PYG{p}{)}\PYG{o}{*}\PYG{p}{(}\PYG{n}{forestmap}\PYG{p}{.}\PYG{n}{getVal}\PYG{p}{(}\PYG{n}{oldx}\PYG{p}{,}\PYG{n}{oldy}\PYG{p}{,}\PYG{n}{oldxwrap}\PYG{p}{,}\PYG{n}{oldywrap}\PYG{p}{,}\PYG{n}{generation}\PYG{p}{)}\PYG{p}{)}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
                    \PYG{c+c1}{// Get the random reference from the match list.}
                    \PYG{c+c1}{// If the movement is to an empty space, then we can update the chain to include the new lineage.}
                    \PYG{k}{if}\PYG{p}{(}\PYG{n}{randwrap} \PYG{o}{\PYGZgt{}} \PYG{n}{forestmap}\PYG{p}{.}\PYG{n}{getVal}\PYG{p}{(}\PYG{n}{oldx}\PYG{p}{,}\PYG{n}{oldy}\PYG{p}{,}\PYG{n}{oldxwrap}\PYG{p}{,}\PYG{n}{oldywrap}\PYG{p}{,}\PYG{n}{generation}\PYG{p}{)}\PYG{p}{)}
                    \PYG{p}{\PYGZob{}}
                        \PYG{k}{throw} \PYG{n}{Fatal\PYGZus{}Exception}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ERROR\PYGZus{}MOVE\PYGZus{}004: Randpos outside maxsize. Check move programming function}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
                    \PYG{p}{\PYGZcb{}}
                    \PYG{k}{if}\PYG{p}{(}\PYG{n}{matches} \PYG{o}{\PYGZgt{}} \PYG{n}{forestmap}\PYG{p}{.}\PYG{n}{getVal}\PYG{p}{(}\PYG{n}{oldx}\PYG{p}{,}\PYG{n}{oldy}\PYG{p}{,}\PYG{n}{oldxwrap}\PYG{p}{,}\PYG{n}{oldywrap}\PYG{p}{,}\PYG{n}{generation}\PYG{p}{)}\PYG{p}{)}
                    \PYG{p}{\PYGZob{}}
                        \PYG{n}{cerr} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{matches: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{matches} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{forestmap value: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{forestmap}\PYG{p}{.}\PYG{n}{getVal}\PYG{p}{(}\PYG{n}{oldx}\PYG{p}{,}\PYG{n}{oldy}\PYG{p}{,}\PYG{n}{oldxwrap}\PYG{p}{,}\PYG{n}{oldywrap}\PYG{p}{,}\PYG{n}{generation}\PYG{p}{)}\PYG{p}{;}
                        \PYG{k}{throw} \PYG{n+nf}{Fatal\PYGZus{}Exception}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ERROR\PYGZus{}MOVE\PYGZus{}004: matches outside maxsize. Check move programming function}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
                    \PYG{p}{\PYGZcb{}}
                    \PYG{k}{if}\PYG{p}{(}\PYG{n}{randwrap} \PYG{o}{\PYGZgt{}} \PYG{n}{matches}\PYG{p}{)} \PYG{c+c1}{// coalescence has not occured}
                    \PYG{p}{\PYGZob{}}
                        \PYG{c+c1}{//cout \PYGZlt{}\PYGZlt{} \PYGZdq{}This shouldn\PYGZsq{}t happen\PYGZdq{} \PYGZlt{}\PYGZlt{} endl;}
                        \PYG{n}{coalchosen} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
                        \PYG{n}{coal} \PYG{o}{=} \PYG{n+nb}{false}\PYG{p}{;}
                        \PYG{n}{active}\PYG{p}{[}\PYG{n}{next\PYGZus{}active}\PYG{p}{]}\PYG{p}{.}\PYG{n}{setNext}\PYG{p}{(}\PYG{n}{chosen}\PYG{p}{)}\PYG{p}{;}
                        \PYG{n}{grid}\PYG{p}{[}\PYG{n}{oldy}\PYG{p}{]}\PYG{p}{[}\PYG{n}{oldx}\PYG{p}{]}\PYG{p}{.}\PYG{n}{increaseNwrap}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
                        \PYG{n}{active}\PYG{p}{[}\PYG{n}{chosen}\PYG{p}{]}\PYG{p}{.}\PYG{n}{setNwrap}\PYG{p}{(}\PYG{n}{grid}\PYG{p}{[}\PYG{n}{oldy}\PYG{p}{]}\PYG{p}{[}\PYG{n}{oldx}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getNwrap}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
                        \PYG{n}{active}\PYG{p}{[}\PYG{n}{chosen}\PYG{p}{]}\PYG{p}{.}\PYG{n}{setListpos}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}
                    \PYG{p}{\PYGZcb{}}
                    \PYG{k}{else} \PYG{c+c1}{// coalescence has occured}
                    \PYG{p}{\PYGZob{}}
                        \PYG{n}{coal} \PYG{o}{=} \PYG{n+nb}{true}\PYG{p}{;}
                        \PYG{n}{coalchosen} \PYG{o}{=} \PYG{n}{matchlist}\PYG{p}{[}\PYG{n}{randwrap}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{;}
                        \PYG{n}{active}\PYG{p}{[}\PYG{n}{chosen}\PYG{p}{]}\PYG{p}{.}\PYG{n}{setEndpoint}\PYG{p}{(}\PYG{n}{oldx}\PYG{p}{,}\PYG{n}{oldy}\PYG{p}{,}\PYG{n}{oldxwrap}\PYG{p}{,}\PYG{n}{oldywrap}\PYG{p}{)}\PYG{p}{;}
                        \PYG{k}{if}\PYG{p}{(}\PYG{n}{coalchosen}\PYG{o}{=}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
                        \PYG{p}{\PYGZob{}}
                            \PYG{k}{throw} \PYG{n}{Fatal\PYGZus{}Exception}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ERROR\PYGZus{}MOVE\PYGZus{}025: Coalescence attempted with lineage of 0.}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
                        \PYG{p}{\PYGZcb{}}
                    \PYG{p}{\PYGZcb{}}
                \PYG{p}{\PYGZcb{}}
                \PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifdef pristine\PYGZus{}mode}
                \PYG{k}{if}\PYG{p}{(}\PYG{n}{grid}\PYG{p}{[}\PYG{n}{oldy}\PYG{p}{]}\PYG{p}{[}\PYG{n}{oldx}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getMaxsize}\PYG{p}{(}\PYG{p}{)}\PYG{o}{\PYGZlt{}}\PYG{n}{active}\PYG{p}{[}\PYG{n}{chosen}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getListpos}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
                \PYG{p}{\PYGZob{}}
                    \PYG{k}{throw} \PYG{n}{Fatal\PYGZus{}Exception}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ERROR\PYGZus{}MOVE\PYGZus{}001: Listpos outside maxsize. Check move programming function.}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
                \PYG{p}{\PYGZcb{}}
                \PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif}
            \PYG{p}{\PYGZcb{}}
            \PYG{k}{else} \PYG{c+c1}{// just add the lineage to next.}
            \PYG{p}{\PYGZob{}}
                \PYG{k}{if}\PYG{p}{(}\PYG{n}{grid}\PYG{p}{[}\PYG{n}{oldy}\PYG{p}{]}\PYG{p}{[}\PYG{n}{oldx}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getNext}\PYG{p}{(}\PYG{p}{)}\PYG{o}{!}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
                \PYG{p}{\PYGZob{}}
                    \PYG{k}{throw} \PYG{n}{Fatal\PYGZus{}Exception}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ERROR\PYGZus{}MOVE\PYGZus{}026: No nwrap recorded, but next is non\PYGZhy{}zero.}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
                \PYG{p}{\PYGZcb{}}
                \PYG{n}{coalchosen} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
                \PYG{n}{coal} \PYG{o}{=} \PYG{n+nb}{false}\PYG{p}{;}
\PYG{c+c1}{//              if(chosen==3893119)}
\PYG{c+c1}{//              \PYGZob{}}
\PYG{c+c1}{//                  validationCheck(31556348,12,chosen);}
\PYG{c+c1}{//                  cout \PYGZlt{}\PYGZlt{} \PYGZdq{}test1...\PYGZdq{} \PYGZlt{}\PYGZlt{} endl;}
\PYG{c+c1}{//              \PYGZcb{}}
\PYG{c+c1}{//              debug\PYGZus{}504(chosen,12);}
                \PYG{n}{grid}\PYG{p}{[}\PYG{n}{oldy}\PYG{p}{]}\PYG{p}{[}\PYG{n}{oldx}\PYG{p}{]}\PYG{p}{.}\PYG{n}{setNext}\PYG{p}{(}\PYG{n}{chosen}\PYG{p}{)}\PYG{p}{;}
                \PYG{n}{active}\PYG{p}{[}\PYG{n}{chosen}\PYG{p}{]}\PYG{p}{.}\PYG{n}{setNwrap}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
                \PYG{n}{active}\PYG{p}{[}\PYG{n}{chosen}\PYG{p}{]}\PYG{p}{.}\PYG{n}{setNext}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}
                \PYG{n}{grid}\PYG{p}{[}\PYG{n}{oldy}\PYG{p}{]}\PYG{p}{[}\PYG{n}{oldx}\PYG{p}{]}\PYG{p}{.}\PYG{n}{increaseNwrap}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
                \PYG{c+c1}{// check}
                \PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifdef DEBUG}
                 \PYG{k}{if}\PYG{p}{(}\PYG{n}{grid}\PYG{p}{[}\PYG{n}{oldy}\PYG{p}{]}\PYG{p}{[}\PYG{n}{oldx}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getNwrap}\PYG{p}{(}\PYG{p}{)} \PYG{o}{!}\PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{)}
                 \PYG{p}{\PYGZob{}}
                     \PYG{k}{throw} \PYG{n}{Fatal\PYGZus{}Exception}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ERROR\PYGZus{}MOVE\PYGZus{}022b: Nwrap not set correctly in move.}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
                 \PYG{p}{\PYGZcb{}}
                 \PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif}
\PYG{c+c1}{//              debug\PYGZus{}504(chosen,11);}
\PYG{c+c1}{//              if(chosen==3893119)}
\PYG{c+c1}{//              \PYGZob{}}
\PYG{c+c1}{//                  validationCheck(31556348,13,chosen);}
\PYG{c+c1}{//                  cout \PYGZlt{}\PYGZlt{} \PYGZdq{}test2...\PYGZdq{} \PYGZlt{}\PYGZlt{} endl;}
\PYG{c+c1}{//              \PYGZcb{}}
            \PYG{p}{\PYGZcb{}}
            \PYG{c+c1}{//\PYGZsh{}ifdef DEBUG}
            \PYG{k}{if}\PYG{p}{(}\PYG{n}{coalchosen} \PYG{o}{!}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{k}{if}\PYG{p}{(}\PYG{n}{active}\PYG{p}{[}\PYG{n}{coalchosen}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getXpos}\PYG{p}{(}\PYG{p}{)} \PYG{o}{!}\PYG{o}{=} \PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{long}\PYG{p}{)} \PYG{n}{oldx} \PYG{o}{\textbar{}}\PYG{o}{\textbar{}} \PYG{n}{active}\PYG{p}{[}\PYG{n}{coalchosen}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getYpos}\PYG{p}{(}\PYG{p}{)} \PYG{o}{!}\PYG{o}{=} \PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{long}\PYG{p}{)}  \PYG{n}{oldy} \PYG{o}{\textbar{}}\PYG{o}{\textbar{}} \PYG{n}{active}\PYG{p}{[}\PYG{n}{coalchosen}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getXwrap}\PYG{p}{(}\PYG{p}{)} \PYG{o}{!}\PYG{o}{=} \PYG{n}{oldxwrap} \PYG{o}{\textbar{}}\PYG{o}{\textbar{}} \PYG{n}{active}\PYG{p}{[}\PYG{n}{coalchosen}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getYwrap}\PYG{p}{(}\PYG{p}{)} \PYG{o}{!}\PYG{o}{=} \PYG{n}{oldywrap}\PYG{p}{)}
                \PYG{p}{\PYGZob{}}
                    \PYG{n}{cerr} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{chosen} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{,}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{coalchosen} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
                    \PYG{n}{cerr} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{chosen \PYGZhy{} x,y: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{oldx} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{,}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{oldy} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{x, y wrap: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{oldxwrap} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{,}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{oldywrap} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
                    \PYG{n}{cerr} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{coalchosen \PYGZhy{} x,y:}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{active}\PYG{p}{[}\PYG{n}{coalchosen}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getXpos}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{,}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{active}\PYG{p}{[}\PYG{n}{coalchosen}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getYpos}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
                    \PYG{n}{cerr} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ x,y wrap: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{active}\PYG{p}{[}\PYG{n}{coalchosen}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getXwrap}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{,}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{active}\PYG{p}{[}\PYG{n}{coalchosen}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getYwrap}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
                    \PYG{k}{throw} \PYG{n+nf}{Fatal\PYGZus{}Exception}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ERROR\PYGZus{}MOVE\PYGZus{}006b: NON FATAL. Nwrap not set correctly. Check move programming function.}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
                \PYG{p}{\PYGZcb{}}
            \PYG{p}{\PYGZcb{}}
            \PYG{c+c1}{//\PYGZsh{}endif}
        \PYG{p}{\PYGZcb{}}
    \PYG{p}{\PYGZcb{}}
    \PYG{c+c1}{// This function is useless now (as it was only useful for debugging purposes) and will be removed in later versions.}
    \PYG{c+cm}{/*}
\PYG{c+cm}{    \PYGZob{}}
\PYG{c+cm}{        long nwrap = grid[504][0].getNwrap();}
\PYG{c+cm}{        unsigned long gridnext = grid[504][0].getNext();}
\PYG{c+cm}{        unsigned short tmpnwrap =0;}
\PYG{c+cm}{        while(gridnext!=0)}
\PYG{c+cm}{        \PYGZob{}}
\PYG{c+cm}{            tmpnwrap++;}
\PYG{c+cm}{            gridnext = active[gridnext].getNext();}
\PYG{c+cm}{        \PYGZcb{}}
\PYG{c+cm}{        if(tmpnwrap!=nwrap)}
\PYG{c+cm}{        \PYGZob{}}
\PYG{c+cm}{            cout \PYGZlt{}\PYGZlt{} \PYGZdq{}TMP: \PYGZdq{} \PYGZlt{}\PYGZlt{} endl;}
\PYG{c+cm}{            cout \PYGZlt{}\PYGZlt{} \PYGZdq{}nwrap: \PYGZdq{} \PYGZlt{}\PYGZlt{} nwrap \PYGZlt{}\PYGZlt{} endl;}
\PYG{c+cm}{            cout \PYGZlt{}\PYGZlt{} \PYGZdq{}tmpnwrap: \PYGZdq{} \PYGZlt{}\PYGZlt{} tmpnwrap \PYGZlt{}\PYGZlt{} endl;}
\PYG{c+cm}{            cout \PYGZlt{}\PYGZlt{} \PYGZdq{}next: \PYGZdq{} \PYGZlt{}\PYGZlt{} gridnext \PYGZlt{}\PYGZlt{} endl;}
\PYG{c+cm}{            cout \PYGZlt{}\PYGZlt{} \PYGZdq{}c: \PYGZdq{} \PYGZlt{}\PYGZlt{} c \PYGZlt{}\PYGZlt{} endl;}
\PYG{c+cm}{            string sam;}
\PYG{c+cm}{            cin \PYGZgt{}\PYGZgt{} sam;}
\PYG{c+cm}{        \PYGZcb{}}
\PYG{c+cm}{    \PYGZcb{}}
\PYG{c+cm}{     //*/}
    \PYG{c+c1}{//}
    \PYG{k+kt}{void} \PYG{n}{switchPositions}\PYG{p}{(}\PYG{k}{const} \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{chosen}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{chosen}\PYG{o}{\PYGZgt{}}\PYG{n}{endactive}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{cerr} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{chosen: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{chosen} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ endactive: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endactive} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
            \PYG{k}{throw} \PYG{n+nf}{Fatal\PYGZus{}Exception}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ERROR\PYGZus{}MOVE\PYGZus{}023: Chosen is greater than endactive. Check move function.}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{chosen}\PYG{o}{!}\PYG{o}{=}\PYG{n}{endactive}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{c+c1}{// This routine assumes that the previous chosen position has already been deleted.}
            \PYG{n}{Datapoint} \PYG{n}{tmpdatactive}\PYG{p}{;}
            \PYG{n}{tmpdatactive}\PYG{p}{.}\PYG{n}{setup}\PYG{p}{(}\PYG{n}{active}\PYG{p}{[}\PYG{n}{chosen}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
            \PYG{c+c1}{// now need to remove the chosen lineage from memory, by replacing it with the lineage that lies in the last place.}
            \PYG{k}{if}\PYG{p}{(}\PYG{n}{active}\PYG{p}{[}\PYG{n}{endactive}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getXwrap}\PYG{p}{(}\PYG{p}{)} \PYG{o}{=}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}}\PYG{n}{active}\PYG{p}{[}\PYG{n}{endactive}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getYwrap}\PYG{p}{(}\PYG{p}{)}\PYG{o}{=}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)} \PYG{c+c1}{// if the end lineage is simple, we can just copy it across.}
            \PYG{p}{\PYGZob{}}
                \PYG{c+c1}{// check endactive}
                \PYG{k}{if}\PYG{p}{(}\PYG{n}{active}\PYG{p}{[}\PYG{n}{endactive}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getNwrap}\PYG{p}{(}\PYG{p}{)}\PYG{o}{!}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
                \PYG{p}{\PYGZob{}}
                    \PYG{n}{cerr} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ERROR\PYGZus{}MOVE\PYGZus{}020: NON FATAL. Nwrap is not set correctly for endactive (nwrap should be 0, but is }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{active}\PYG{p}{[}\PYG{n}{endactive}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getNwrap}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ ). Identified during switch of positions.}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
                \PYG{p}{\PYGZcb{}}
                \PYG{n}{grid}\PYG{p}{[}\PYG{n}{active}\PYG{p}{[}\PYG{n}{endactive}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getYpos}\PYG{p}{(}\PYG{p}{)}\PYG{p}{]}\PYG{p}{[}\PYG{n}{active}\PYG{p}{[}\PYG{n}{endactive}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getXpos}\PYG{p}{(}\PYG{p}{)}\PYG{p}{]}\PYG{p}{.}\PYG{n}{setSpecies}\PYG{p}{(}\PYG{n}{active}\PYG{p}{[}\PYG{n}{endactive}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getListpos}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,}\PYG{n}{chosen}\PYG{p}{)}\PYG{p}{;}
                \PYG{n}{active}\PYG{p}{[}\PYG{n}{chosen}\PYG{p}{]}\PYG{p}{.}\PYG{n}{setup}\PYG{p}{(}\PYG{n}{active}\PYG{p}{[}\PYG{n}{endactive}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
                \PYG{n}{active}\PYG{p}{[}\PYG{n}{endactive}\PYG{p}{]}\PYG{p}{.}\PYG{n}{setup}\PYG{p}{(}\PYG{n}{tmpdatactive}\PYG{p}{)}\PYG{p}{;}
                \PYG{n}{active}\PYG{p}{[}\PYG{n}{endactive}\PYG{p}{]}\PYG{p}{.}\PYG{n}{setNwrap}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}
                \PYG{n}{active}\PYG{p}{[}\PYG{n}{endactive}\PYG{p}{]}\PYG{p}{.}\PYG{n}{setNext}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}

            \PYG{p}{\PYGZcb{}}
            \PYG{k}{else} \PYG{c+c1}{// else the end lineage is wrapped, and needs to be processed including the wrapping routines.}
            \PYG{p}{\PYGZob{}}
                \PYG{k}{if}\PYG{p}{(}\PYG{n}{active}\PYG{p}{[}\PYG{n}{endactive}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getNwrap}\PYG{p}{(}\PYG{p}{)}\PYG{o}{=}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
                \PYG{p}{\PYGZob{}}
                    \PYG{n}{cerr} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ERROR\PYGZus{}MOVE\PYGZus{}021: NON FATAL. Nwrap is not set correctly for endactive (nwrap incorrectly 0). Identified during switch of positions.}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
                \PYG{p}{\PYGZcb{}}
\PYG{c+c1}{//              cout \PYGZlt{}\PYGZlt{} \PYGZdq{}wrap\PYGZdq{}\PYGZlt{}\PYGZlt{}endl;}
                \PYG{k+kt}{long} \PYG{n}{tmpactive} \PYG{o}{=} \PYG{n}{grid}\PYG{p}{[}\PYG{n}{active}\PYG{p}{[}\PYG{n}{endactive}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getYpos}\PYG{p}{(}\PYG{p}{)}\PYG{p}{]}\PYG{p}{[}\PYG{n}{active}\PYG{p}{[}\PYG{n}{endactive}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getXpos}\PYG{p}{(}\PYG{p}{)}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getNext}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
                \PYG{k+kt}{int}  \PYG{n}{tmpnwrap} \PYG{o}{=} \PYG{n}{active}\PYG{p}{[}\PYG{n}{endactive}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getNwrap}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

                \PYG{c+c1}{// if the wrapping is just once, we need to set the grid next to the chosen variable.}
                \PYG{k}{if}\PYG{p}{(}\PYG{n}{tmpnwrap}\PYG{o}{=}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}
                \PYG{p}{\PYGZob{}}
                    \PYG{c+c1}{// check}
                    \PYG{k}{if}\PYG{p}{(}\PYG{n}{grid}\PYG{p}{[}\PYG{n}{active}\PYG{p}{[}\PYG{n}{endactive}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getYpos}\PYG{p}{(}\PYG{p}{)}\PYG{p}{]}\PYG{p}{[}\PYG{n}{active}\PYG{p}{[}\PYG{n}{endactive}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getXpos}\PYG{p}{(}\PYG{p}{)}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getNext}\PYG{p}{(}\PYG{p}{)}\PYG{o}{!}\PYG{o}{=}\PYG{n}{endactive}\PYG{p}{)}
                    \PYG{p}{\PYGZob{}}
                        \PYG{k}{throw} \PYG{n}{Fatal\PYGZus{}Exception}\PYG{p}{(}\PYG{n}{string}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ERROR\PYGZus{}MOVE\PYGZus{}019: FATAL. Nwrap for endactive not set correctly. Nwrap is 1, but lineage at 1st position is }\PYG{l+s}{\PYGZdq{}} \PYG{o}{+}
                        \PYG{n}{to\PYGZus{}string}\PYG{p}{(}\PYG{p}{(}\PYG{k+kt}{long} \PYG{k+kt}{long}\PYG{p}{)}\PYG{n}{grid}\PYG{p}{[}\PYG{n}{active}\PYG{p}{[}\PYG{n}{endactive}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getYpos}\PYG{p}{(}\PYG{p}{)}\PYG{p}{]}\PYG{p}{[}\PYG{n}{active}\PYG{p}{[}\PYG{n}{endactive}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getXpos}\PYG{p}{(}\PYG{p}{)}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getNext}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)} \PYG{o}{+} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{. Identified during the move.}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
                    \PYG{p}{\PYGZcb{}}
                    \PYG{n}{grid}\PYG{p}{[}\PYG{n}{active}\PYG{p}{[}\PYG{n}{endactive}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getYpos}\PYG{p}{(}\PYG{p}{)}\PYG{p}{]}\PYG{p}{[}\PYG{n}{active}\PYG{p}{[}\PYG{n}{endactive}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getXpos}\PYG{p}{(}\PYG{p}{)}\PYG{p}{]}\PYG{p}{.}\PYG{n}{setNext}\PYG{p}{(}\PYG{n}{chosen}\PYG{p}{)}\PYG{p}{;}
                \PYG{p}{\PYGZcb{}}
                \PYG{k}{else} \PYG{c+c1}{// otherwise, we just set the next to chosen instead of endactive.}
                \PYG{p}{\PYGZob{}}
                    \PYG{k+kt}{int} \PYG{n}{tmpcount} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
                    \PYG{c+c1}{// loop over nexts until we reach the right lineage.}
                    \PYG{k}{while}\PYG{p}{(}\PYG{n}{active}\PYG{p}{[}\PYG{n}{tmpactive}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getNext}\PYG{p}{(}\PYG{p}{)}\PYG{o}{!}\PYG{o}{=}\PYG{n}{endactive}\PYG{p}{)}
                    \PYG{p}{\PYGZob{}}
                        \PYG{n}{tmpactive} \PYG{o}{=} \PYG{n}{active}\PYG{p}{[}\PYG{n}{tmpactive}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getNext}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
                        \PYG{n}{tmpcount} \PYG{o}{+}\PYG{o}{+}\PYG{p}{;}
                        \PYG{c+c1}{// debug check}
                        \PYG{k}{if}\PYG{p}{(}\PYG{n}{tmpcount} \PYG{o}{\PYGZgt{}} \PYG{n}{tmpnwrap}\PYG{p}{)}
                        \PYG{p}{\PYGZob{}}
                            \PYG{n}{cerr} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ERROR\PYGZus{}MOVE\PYGZus{}013: NON FATAL. Looping has not encountered a match, despite going further than required. Check nwrap counting.}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
                            \PYG{k}{if}\PYG{p}{(}\PYG{n}{tmpactive}\PYG{o}{=}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
                            \PYG{p}{\PYGZob{}}
                                \PYG{n}{cerr} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{gridnext: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{grid}\PYG{p}{[}\PYG{n}{active}\PYG{p}{[}\PYG{n}{endactive}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getYpos}\PYG{p}{(}\PYG{p}{)}\PYG{p}{]}\PYG{p}{[}\PYG{n}{active}\PYG{p}{[}\PYG{n}{endactive}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getXpos}\PYG{p}{(}\PYG{p}{)}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getNext}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
                                \PYG{n}{cerr} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{x,y: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{active}\PYG{p}{[}\PYG{n}{endactive}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getXpos}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{,}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{active}\PYG{p}{[}\PYG{n}{endactive}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getYpos}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
                                \PYG{n}{cerr} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{xwrap,ywrap: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{active}\PYG{p}{[}\PYG{n}{endactive}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getXwrap}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{,}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{active}\PYG{p}{[}\PYG{n}{endactive}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getYwrap}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
                                \PYG{n}{cerr} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{endactive: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endactive} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
                                \PYG{n}{cerr} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{tmpactive: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{tmpactive} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
                                \PYG{n}{cerr} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{bSpec: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{bSpec} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
                                \PYG{n}{cerr} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{tmpnwrap: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}  \PYG{n}{tmpnwrap} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ tmpcount: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{tmpcount} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
                                \PYG{n}{cerr} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{FATAL!}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
                                \PYG{k}{throw} \PYG{n+nf}{Fatal\PYGZus{}Exception}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
                            \PYG{p}{\PYGZcb{}}
                        \PYG{p}{\PYGZcb{}}

                    \PYG{p}{\PYGZcb{}}
                    \PYG{n}{active}\PYG{p}{[}\PYG{n}{tmpactive}\PYG{p}{]}\PYG{p}{.}\PYG{n}{setNext}\PYG{p}{(}\PYG{n}{chosen}\PYG{p}{)}\PYG{p}{;}
                \PYG{p}{\PYGZcb{}}
                \PYG{n}{active}\PYG{p}{[}\PYG{n}{chosen}\PYG{p}{]}\PYG{p}{.}\PYG{n}{setup}\PYG{p}{(}\PYG{n}{active}\PYG{p}{[}\PYG{n}{endactive}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
                \PYG{n}{active}\PYG{p}{[}\PYG{n}{endactive}\PYG{p}{]}\PYG{p}{.}\PYG{n}{setup}\PYG{p}{(}\PYG{n}{tmpdatactive}\PYG{p}{)}\PYG{p}{;}

                \PYG{c+c1}{// check \PYGZhy{} debugging}
                \PYG{k+kt}{long} \PYG{n}{testwrap} \PYG{o}{=} \PYG{n}{active}\PYG{p}{[}\PYG{n}{chosen}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getNwrap}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
                \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{testnext} \PYG{o}{=} \PYG{n}{grid}\PYG{p}{[}\PYG{n}{active}\PYG{p}{[}\PYG{n}{chosen}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getYpos}\PYG{p}{(}\PYG{p}{)}\PYG{p}{]}\PYG{p}{[}\PYG{n}{active}\PYG{p}{[}\PYG{n}{chosen}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getXpos}\PYG{p}{(}\PYG{p}{)}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getNext}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
                \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;}\PYG{n}{i}\PYG{o}{\PYGZlt{}}\PYG{n}{testwrap}\PYG{p}{;}\PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
                \PYG{p}{\PYGZob{}}
                    \PYG{n}{testnext} \PYG{o}{=} \PYG{n}{active}\PYG{p}{[}\PYG{n}{testnext}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getNext}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
                \PYG{p}{\PYGZcb{}}

                \PYG{k}{if}\PYG{p}{(}\PYG{n}{testnext}\PYG{o}{!}\PYG{o}{=}\PYG{n}{chosen}\PYG{p}{)}
                \PYG{p}{\PYGZob{}}
                    \PYG{k}{throw} \PYG{n}{Fatal\PYGZus{}Exception}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ERROR\PYGZus{}MOVE\PYGZus{}009: Nwrap position not set correctly after coalescence. Check move process.}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
                \PYG{p}{\PYGZcb{}}
            \PYG{p}{\PYGZcb{}}
        \PYG{p}{\PYGZcb{}}
        \PYG{n}{endactive} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{k+kt}{void} \PYG{n}{speciation}\PYG{p}{(}\PYG{k}{const} \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{chosen}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{c+c1}{// alter the data such that it reflects the speciation event.}
        \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{tmpmpos} \PYG{o}{=} \PYG{n}{active}\PYG{p}{[}\PYG{n}{chosen}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getMpos}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
        \PYG{c+c1}{//data[tmpmpos].increaseGen();}
        \PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifdef DEBUG}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{data}\PYG{p}{[}\PYG{n}{tmpmpos}\PYG{p}{]}\PYG{p}{.}\PYG{n}{hasSpeciated}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{k}{throw} \PYG{n}{Fatal\PYGZus{}Exception}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ERROR\PYGZus{}MOVE\PYGZus{}028: Attempting to speciate a speciated species.}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif}
        \PYG{n}{data}\PYG{p}{[}\PYG{n}{tmpmpos}\PYG{p}{]}\PYG{p}{.}\PYG{n}{speciate}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
        \PYG{c+c1}{// TEST REMOVE THIS WHEN TESTING COMPLETE!! done}
\PYG{c+c1}{//      data[tmpmpos].setPosition(active[chosen].getXpos(),active[chosen].getYpos(),active[chosen].getXwrap(),active[chosen].getYwrap());}
        \PYG{c+c1}{// Now remove the old chosen lineage from the active directory.}
        \PYG{n}{removeOldPos}\PYG{p}{(}\PYG{n}{chosen}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{switchPositions}\PYG{p}{(}\PYG{n}{chosen}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}


    \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{estSpecnum}\PYG{p}{(}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k+kt}{long} \PYG{k+kt}{double} \PYG{n}{dMinmax} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
        \PYG{c+c1}{// first loop to find the maximum speciation rate required}
        \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;}\PYG{n}{i}\PYG{o}{\PYGZlt{}}\PYG{o}{=}\PYG{n}{endactive}\PYG{p}{;}\PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{k+kt}{long} \PYG{k+kt}{double} \PYG{n}{tmpminmax} \PYG{o}{=} \PYG{n}{calcMinMax}\PYG{p}{(}\PYG{n}{i}\PYG{p}{)}\PYG{p}{;}
            \PYG{n}{active}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{setMinmax}\PYG{p}{(}\PYG{n}{tmpminmax}\PYG{p}{)}\PYG{p}{;}
            \PYG{n}{dMinmax} \PYG{o}{=} \PYG{p}{(}\PYG{k+kt}{long} \PYG{k+kt}{double}\PYG{p}{)}\PYG{n}{max}\PYG{p}{(}\PYG{n}{dMinmax}\PYG{p}{,}\PYG{n}{tmpminmax}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{int} \PYG{n}{i}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;}\PYG{n}{i}\PYG{o}{\PYGZlt{}}\PYG{o}{=}\PYG{n}{enddata}\PYG{p}{;}\PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{k}{if}\PYG{p}{(}\PYG{n}{data}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{isTip}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{n}{data}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{setExistance}\PYG{p}{(}\PYG{n+nb}{true}\PYG{p}{)}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
            \PYG{k+kt}{double} \PYG{n}{maxret} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;}
            \PYG{k}{if}\PYG{p}{(}\PYG{n}{data}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getGenRate}\PYG{p}{(}\PYG{p}{)}\PYG{o}{=}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{n}{maxret} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
            \PYG{k}{else}
            \PYG{p}{\PYGZob{}}
                \PYG{n}{maxret} \PYG{o}{=} \PYG{n}{data}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getGenRate}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
            \PYG{c+c1}{// This is the line that compares the individual random numbers against the speciation rate.}
            \PYG{k}{if}\PYG{p}{(}\PYG{n}{data}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getSpecRate}\PYG{p}{(}\PYG{p}{)}\PYG{o}{\PYGZlt{}}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{o}{\PYGZhy{}}\PYG{n}{pow}\PYG{p}{(}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{o}{\PYGZhy{}}\PYG{n}{dMinmax}\PYG{p}{)}\PYG{p}{,}\PYG{n}{maxret}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{n}{data}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{speciate}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
        \PYG{p}{\PYGZcb{}}
        \PYG{k+kt}{bool} \PYG{n}{loop}\PYG{o}{=}\PYG{n+nb}{true}\PYG{p}{;}
        \PYG{k}{while}\PYG{p}{(}\PYG{n}{loop}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{loop}\PYG{o}{=}\PYG{n+nb}{false}\PYG{p}{;}
            \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{int} \PYG{n}{i}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;}\PYG{n}{i}\PYG{o}{\PYGZlt{}}\PYG{o}{=}\PYG{n}{enddata}\PYG{p}{;}\PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{k}{if}\PYG{p}{(}\PYG{n}{data}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getExistance}\PYG{p}{(}\PYG{p}{)}\PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}}\PYG{o}{!}\PYG{n}{data}\PYG{p}{[}\PYG{n}{data}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getParent}\PYG{p}{(}\PYG{p}{)}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getExistance}\PYG{p}{(}\PYG{p}{)}\PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}}\PYG{o}{!}\PYG{n}{data}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{hasSpeciated}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
                \PYG{p}{\PYGZob{}}
                    \PYG{n}{loop} \PYG{o}{=} \PYG{n+nb}{true}\PYG{p}{;}
                    \PYG{n}{data}\PYG{p}{[}\PYG{n}{data}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getParent}\PYG{p}{(}\PYG{p}{)}\PYG{p}{]}\PYG{p}{.}\PYG{n}{setExistance}\PYG{p}{(}\PYG{n+nb}{true}\PYG{p}{)}\PYG{p}{;}
                \PYG{p}{\PYGZcb{}}
            \PYG{p}{\PYGZcb{}}
        \PYG{p}{\PYGZcb{}}
        \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{iSpecies}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;}
        \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{int} \PYG{n}{i}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;}\PYG{n}{i}\PYG{o}{\PYGZlt{}}\PYG{o}{=}\PYG{n}{enddata}\PYG{p}{;}\PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{k}{if}\PYG{p}{(}\PYG{n}{data}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getExistance}\PYG{p}{(}\PYG{p}{)}\PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}}\PYG{n}{data}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{hasSpeciated}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{n}{iSpecies} \PYG{o}{+}\PYG{o}{+}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{int} \PYG{n}{i}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;}\PYG{n}{i}\PYG{o}{\PYGZlt{}}\PYG{o}{=}\PYG{n}{enddata}\PYG{p}{;}\PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{data}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{qReset}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
\PYG{c+c1}{//      cout \PYGZlt{}\PYGZlt{} \PYGZdq{}Estimated species number is: \PYGZdq{} \PYGZlt{}\PYGZlt{} iSpecies \PYGZlt{}\PYGZlt{} endl;}
        \PYG{k}{return} \PYG{n}{iSpecies}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}


    \PYG{k+kt}{void} \PYG{n}{runChecks}\PYG{p}{(}\PYG{k}{const} \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{chosen}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{coalchosen}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{c+c1}{// final checks}
        \PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifdef pristine\PYGZus{}mode}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{active}\PYG{p}{[}\PYG{n}{chosen}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getListpos}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZgt{}} \PYG{n}{grid}\PYG{p}{[}\PYG{n}{active}\PYG{p}{[}\PYG{n}{chosen}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getYpos}\PYG{p}{(}\PYG{p}{)}\PYG{p}{]}\PYG{p}{[}\PYG{n}{active}\PYG{p}{[}\PYG{n}{chosen}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getXpos}\PYG{p}{(}\PYG{p}{)}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getMaxsize}\PYG{p}{(}\PYG{p}{)}\PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}}\PYG{n}{active}\PYG{p}{[}\PYG{n}{chosen}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getNwrap}\PYG{p}{(}\PYG{p}{)}\PYG{o}{=}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
\PYG{c+c1}{//              usleep(1);}
            \PYG{n}{cerr} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{listpos: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{active}\PYG{p}{[}\PYG{n}{chosen}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getListpos}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ maxsize: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{grid}\PYG{p}{[}\PYG{n}{active}\PYG{p}{[}\PYG{n}{chosen}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getYpos}\PYG{p}{(}\PYG{p}{)}\PYG{p}{]}\PYG{p}{[}\PYG{n}{active}\PYG{p}{[}\PYG{n}{chosen}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getXpos}\PYG{p}{(}\PYG{p}{)}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getMaxsize}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{n}{endl}\PYG{p}{;}
            \PYG{k}{throw} \PYG{n+nf}{Fatal\PYGZus{}Exception}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ERROR\PYGZus{}MOVE\PYGZus{}001: Listpos outside maxsize.}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}

        \PYG{k}{if}\PYG{p}{(}\PYG{n}{active}\PYG{p}{[}\PYG{n}{coalchosen}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getListpos}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZgt{}} \PYG{n}{grid}\PYG{p}{[}\PYG{n}{active}\PYG{p}{[}\PYG{n}{coalchosen}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getYpos}\PYG{p}{(}\PYG{p}{)}\PYG{p}{]}\PYG{p}{[}\PYG{n}{active}\PYG{p}{[}\PYG{n}{coalchosen}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getXpos}\PYG{p}{(}\PYG{p}{)}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getMaxsize}\PYG{p}{(}\PYG{p}{)}\PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}}\PYG{n}{active}\PYG{p}{[}\PYG{n}{coalchosen}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getNwrap}\PYG{p}{(}\PYG{p}{)}\PYG{o}{=}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}}\PYG{n}{coalchosen}\PYG{o}{!}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
\PYG{c+c1}{//              usleep(1);}
            \PYG{k}{throw} \PYG{n}{Fatal\PYGZus{}Exception}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ERROR\PYGZus{}MOVE\PYGZus{}002: Coalchosen listpos outside maxsize.}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{active}\PYG{p}{[}\PYG{n}{chosen}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getNwrap}\PYG{p}{(}\PYG{p}{)}\PYG{o}{!}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{tmpactive} \PYG{o}{=} \PYG{n}{grid}\PYG{p}{[}\PYG{n}{active}\PYG{p}{[}\PYG{n}{chosen}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getYpos}\PYG{p}{(}\PYG{p}{)}\PYG{p}{]}\PYG{p}{[}\PYG{n}{active}\PYG{p}{[}\PYG{n}{chosen}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getXpos}\PYG{p}{(}\PYG{p}{)}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getNext}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
            \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{lastactive} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
            \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;}\PYG{n}{i}\PYG{o}{\PYGZlt{}}\PYG{n}{active}\PYG{p}{[}\PYG{n}{chosen}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getNwrap}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}\PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{n}{lastactive} \PYG{o}{=} \PYG{n}{tmpactive}\PYG{p}{;}
                \PYG{n}{tmpactive} \PYG{o}{=} \PYG{n}{active}\PYG{p}{[}\PYG{n}{tmpactive}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getNext}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
            \PYG{k}{if}\PYG{p}{(}\PYG{n}{tmpactive}\PYG{o}{!}\PYG{o}{=}\PYG{n}{chosen}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{n}{cerr} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{nwrap: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{active}\PYG{p}{[}\PYG{n}{chosen}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getNwrap}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
                \PYG{n}{cerr} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{gridnwrap: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{grid}\PYG{p}{[}\PYG{n}{active}\PYG{p}{[}\PYG{n}{chosen}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getYpos}\PYG{p}{(}\PYG{p}{)}\PYG{p}{]}\PYG{p}{[}\PYG{n}{active}\PYG{p}{[}\PYG{n}{chosen}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getXpos}\PYG{p}{(}\PYG{p}{)}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getNwrap}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
                \PYG{n}{cerr} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{chosen: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{chosen} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
                \PYG{n}{cerr} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{active x,y}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{active}\PYG{p}{[}\PYG{n}{chosen}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getXpos}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{,}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{active}\PYG{p}{[}\PYG{n}{chosen}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getYpos}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
                \PYG{n}{cerr} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{wrap x,y: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{active}\PYG{p}{[}\PYG{n}{chosen}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getXwrap}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{,}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{active}\PYG{p}{[}\PYG{n}{chosen}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getYwrap}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
                \PYG{n}{cerr} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{tmpactive: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{tmpactive} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ chosen: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{chosen} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ chosennext: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{active}\PYG{p}{[}\PYG{n}{chosen}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getNext}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{lastactive: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{lastactive}\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
                \PYG{k}{throw} \PYG{n+nf}{Fatal\PYGZus{}Exception}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ERROR\PYGZus{}MOVE\PYGZus{}003: Nwrap not set correctly.}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
        \PYG{p}{\PYGZcb{}}

        \PYG{k}{if}\PYG{p}{(}\PYG{n}{active}\PYG{p}{[}\PYG{n}{chosen}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getNwrap}\PYG{p}{(}\PYG{p}{)}\PYG{o}{!}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{k}{if}\PYG{p}{(}\PYG{n}{active}\PYG{p}{[}\PYG{n}{chosen}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getXwrap}\PYG{p}{(}\PYG{p}{)}\PYG{o}{=}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}}\PYG{n}{active}\PYG{p}{[}\PYG{n}{chosen}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getYwrap}\PYG{p}{(}\PYG{p}{)}\PYG{o}{=}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{k}{throw} \PYG{n}{Fatal\PYGZus{}Exception}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ERROR\PYGZus{}MOVE\PYGZus{}10: Nwrap set to non\PYGZhy{}zero, but x and y wrap 0.}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{active}\PYG{p}{[}\PYG{n}{endactive}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getNwrap}\PYG{p}{(}\PYG{p}{)}\PYG{o}{!}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{k+kt}{int} \PYG{n}{nwrap} \PYG{o}{=} \PYG{n}{active}\PYG{p}{[}\PYG{n}{endactive}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getNwrap}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
            \PYG{k}{if}\PYG{p}{(}\PYG{n}{nwrap}\PYG{o}{=}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{k}{if}\PYG{p}{(}\PYG{n}{grid}\PYG{p}{[}\PYG{n}{active}\PYG{p}{[}\PYG{n}{endactive}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getYpos}\PYG{p}{(}\PYG{p}{)}\PYG{p}{]}\PYG{p}{[}\PYG{n}{active}\PYG{p}{[}\PYG{n}{endactive}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getXpos}\PYG{p}{(}\PYG{p}{)}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getNext}\PYG{p}{(}\PYG{p}{)}\PYG{o}{!}\PYG{o}{=}\PYG{n}{endactive}\PYG{p}{)}
                \PYG{p}{\PYGZob{}}
                    \PYG{n}{cerr} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Lineage at 1st position: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{grid}\PYG{p}{[}\PYG{n}{active}\PYG{p}{[}\PYG{n}{endactive}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getYpos}\PYG{p}{(}\PYG{p}{)}\PYG{p}{]}\PYG{p}{[}\PYG{n}{active}\PYG{p}{[}\PYG{n}{endactive}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getXpos}\PYG{p}{(}\PYG{p}{)}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getNext}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
                    \PYG{n}{cerr} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{endactive: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endactive} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{nwrap: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{nwrap} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{x,y: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{active}\PYG{p}{[}\PYG{n}{endactive}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getXpos}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{,}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{active}\PYG{p}{[}\PYG{n}{endactive}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getYpos}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
                    \PYG{n}{cerr} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{chosen: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{chosen} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
                    \PYG{k}{throw} \PYG{n+nf}{Fatal\PYGZus{}Exception}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ERROR\PYGZus{}MOVE\PYGZus{}016: Nwrap for endactive not set correctly. Nwrap is 1, but the lineage at 1st position is not endactive.}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
                \PYG{p}{\PYGZcb{}}
            \PYG{p}{\PYGZcb{}}
            \PYG{k}{else}
            \PYG{p}{\PYGZob{}}
                \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{tmpcheck} \PYG{o}{=} \PYG{n}{grid}\PYG{p}{[}\PYG{n}{active}\PYG{p}{[}\PYG{n}{endactive}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getYpos}\PYG{p}{(}\PYG{p}{)}\PYG{p}{]}\PYG{p}{[}\PYG{n}{active}\PYG{p}{[}\PYG{n}{endactive}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getXpos}\PYG{p}{(}\PYG{p}{)}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getNext}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
                \PYG{k+kt}{int} \PYG{n}{tmpnwrap} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;}
                \PYG{k}{while}\PYG{p}{(}\PYG{n}{tmpcheck}\PYG{o}{!}\PYG{o}{=}\PYG{n}{endactive}\PYG{p}{)}
                \PYG{p}{\PYGZob{}}
                    \PYG{n}{tmpnwrap} \PYG{o}{+}\PYG{o}{+}\PYG{p}{;}
                    \PYG{n}{tmpcheck} \PYG{o}{=} \PYG{n}{active}\PYG{p}{[}\PYG{n}{tmpcheck}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getNext}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
                    \PYG{k}{if}\PYG{p}{(}\PYG{n}{tmpnwrap}\PYG{o}{\PYGZgt{}}\PYG{n}{nwrap}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{)}
                    \PYG{p}{\PYGZob{}}
                        \PYG{n}{cerr} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ERROR\PYGZus{}MOVE\PYGZus{}017: NON FATAL. Nrap for endactive not set correctly; looped beyond nwrap and not yet found enactive.}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
                        \PYG{n}{cerr} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{endactive: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endactive} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{nwrap: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{nwrap} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{x,y: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{active}\PYG{p}{[}\PYG{n}{endactive}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getXpos}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{,}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{active}\PYG{p}{[}\PYG{n}{endactive}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getYpos}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
                        \PYG{n}{cerr} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{chosen: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{chosen} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
                    \PYG{p}{\PYGZcb{}}
                \PYG{p}{\PYGZcb{}}
                \PYG{k}{if}\PYG{p}{(}\PYG{n}{tmpnwrap}\PYG{o}{!}\PYG{o}{=}\PYG{n}{nwrap}\PYG{p}{)}
                \PYG{p}{\PYGZob{}}
                    \PYG{n}{cerr} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ERROR\PYGZus{}MOVE\PYGZus{}018: NON FATAL. Nwrap for endactive not set correctly. Nwrap is }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{nwrap} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ but endactive is at position }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{tmpnwrap} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
                    \PYG{n}{cerr} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{endactive: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endactive} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{nwrap: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{nwrap} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{x,y: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{active}\PYG{p}{[}\PYG{n}{endactive}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getXpos}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{,}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{active}\PYG{p}{[}\PYG{n}{endactive}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getYpos}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
                    \PYG{n}{cerr} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{chosen: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{chosen} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
                \PYG{p}{\PYGZcb{}}

            \PYG{p}{\PYGZcb{}}
        \PYG{p}{\PYGZcb{}}
    \PYG{p}{\PYGZcb{}}

    \PYG{k+kt}{void} \PYG{n}{validationCheck}\PYG{p}{(}\PYG{k}{const} \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{chosen}\PYG{p}{,}\PYG{k+kt}{int} \PYG{n}{o}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{current}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{bool} \PYG{o}{\PYGZam{}}\PYG{n}{coal}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{c+c1}{//if(active[chosen].getNwrap()!=0\textbar{}\textbar{}chosen\PYGZgt{}endactive)}
        \PYG{c+c1}{//\PYGZob{}}
        \PYG{c+c1}{//  return;}
        \PYG{c+c1}{//\PYGZcb{}}
\PYG{c+c1}{//      cout \PYGZlt{}\PYGZlt{} \PYGZdq{}check...\PYGZdq{} \PYGZlt{}\PYGZlt{} endl;}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{active}\PYG{p}{[}\PYG{n}{chosen}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getListpos}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZgt{}} \PYG{n}{grid}\PYG{p}{[}\PYG{n}{active}\PYG{p}{[}\PYG{n}{chosen}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getYpos}\PYG{p}{(}\PYG{p}{)}\PYG{p}{]}\PYG{p}{[}\PYG{n}{active}\PYG{p}{[}\PYG{n}{chosen}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getXpos}\PYG{p}{(}\PYG{p}{)}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getMaxsize}\PYG{p}{(}\PYG{p}{)}\PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}}\PYG{n}{active}\PYG{p}{[}\PYG{n}{chosen}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getNwrap}\PYG{p}{(}\PYG{p}{)}\PYG{o}{=}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
\PYG{c+c1}{//              usleep(1);}
            \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{listpos: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{active}\PYG{p}{[}\PYG{n}{chosen}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getListpos}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ maxsize: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{grid}\PYG{p}{[}\PYG{n}{active}\PYG{p}{[}\PYG{n}{chosen}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getYpos}\PYG{p}{(}\PYG{p}{)}\PYG{p}{]}\PYG{p}{[}\PYG{n}{active}\PYG{p}{[}\PYG{n}{chosen}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getXpos}\PYG{p}{(}\PYG{p}{)}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getMaxsize}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{n}{endl}\PYG{p}{;}
            \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{VALIDATION\PYGZus{}001: Listpos outside maxsize.}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
            \PYG{k}{throw} \PYG{n+nf}{Fatal\PYGZus{}Exception}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{VALIDATION\PYGZus{}001: Listpos outside maxsize.}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{if}\PYG{p}{(}\PYG{o}{!}\PYG{n}{coal} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{o}{!}\PYG{n}{data}\PYG{p}{[}\PYG{n}{active}\PYG{p}{[}\PYG{n}{chosen}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getMpos}\PYG{p}{(}\PYG{p}{)}\PYG{p}{]}\PYG{p}{.}\PYG{n}{hasSpeciated}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{n}{active}\PYG{p}{[}\PYG{n}{chosen}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getNwrap}\PYG{p}{(}\PYG{p}{)} \PYG{o}{=}\PYG{o}{=}\PYG{l+m+mi}{0} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{n}{chosen}\PYG{o}{!}\PYG{o}{=}\PYG{n}{grid}\PYG{p}{[}\PYG{n}{active}\PYG{p}{[}\PYG{n}{chosen}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getYpos}\PYG{p}{(}\PYG{p}{)}\PYG{p}{]}\PYG{p}{[}\PYG{n}{active}\PYG{p}{[}\PYG{n}{chosen}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getXpos}\PYG{p}{(}\PYG{p}{)}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getSpecies}\PYG{p}{(}\PYG{n}{active}\PYG{p}{[}\PYG{n}{chosen}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getListpos}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{nwrap: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{active}\PYG{p}{[}\PYG{n}{chosen}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getNwrap}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
            \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{gridnwrap: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{grid}\PYG{p}{[}\PYG{n}{active}\PYG{p}{[}\PYG{n}{chosen}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getYpos}\PYG{p}{(}\PYG{p}{)}\PYG{p}{]}\PYG{p}{[}\PYG{n}{active}\PYG{p}{[}\PYG{n}{chosen}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getXpos}\PYG{p}{(}\PYG{p}{)}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getNwrap}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
            \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{chosen: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{chosen} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
            \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{active x,y: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{active}\PYG{p}{[}\PYG{n}{chosen}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getXpos}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{,}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{active}\PYG{p}{[}\PYG{n}{chosen}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getYpos}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
            \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{wrap x,y: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{active}\PYG{p}{[}\PYG{n}{chosen}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getXwrap}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{,}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{active}\PYG{p}{[}\PYG{n}{chosen}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getYwrap}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
            \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ chosen: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{chosen} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ chosennext: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{active}\PYG{p}{[}\PYG{n}{chosen}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getNext}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
             \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{listpos: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{active}\PYG{p}{[}\PYG{n}{chosen}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getListpos}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
             \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{lineage at pos }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{active}\PYG{p}{[}\PYG{n}{chosen}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getListpos}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{grid}\PYG{p}{[}\PYG{n}{active}\PYG{p}{[}\PYG{n}{chosen}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getYpos}\PYG{p}{(}\PYG{p}{)}\PYG{p}{]}\PYG{p}{[}\PYG{n}{active}\PYG{p}{[}\PYG{n}{chosen}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getXpos}\PYG{p}{(}\PYG{p}{)}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getSpecies}\PYG{p}{(}\PYG{n}{active}\PYG{p}{[}\PYG{n}{chosen}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getListpos}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
            \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{o: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{o} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
            \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{current chosen: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{current} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
            \PYG{k}{throw} \PYG{n+nf}{Fatal\PYGZus{}Exception}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{VALIDATION\PYGZus{}003: Listpos not set correctly.}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{active}\PYG{p}{[}\PYG{n}{chosen}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getNwrap}\PYG{p}{(}\PYG{p}{)}\PYG{o}{!}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
\PYG{c+c1}{//              cout \PYGZlt{}\PYGZlt{} \PYGZdq{}nwrap1: \PYGZdq{} \PYGZlt{}\PYGZlt{} active[chosen].getNwrap() \PYGZlt{}\PYGZlt{} endl;}
            \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{tmpactive} \PYG{o}{=} \PYG{n}{grid}\PYG{p}{[}\PYG{n}{active}\PYG{p}{[}\PYG{n}{chosen}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getYpos}\PYG{p}{(}\PYG{p}{)}\PYG{p}{]}\PYG{p}{[}\PYG{n}{active}\PYG{p}{[}\PYG{n}{chosen}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getXpos}\PYG{p}{(}\PYG{p}{)}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getNext}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
            \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{lastactive} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
            \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;}\PYG{n}{i}\PYG{o}{\PYGZlt{}}\PYG{n}{active}\PYG{p}{[}\PYG{n}{chosen}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getNwrap}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}\PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{n}{lastactive} \PYG{o}{=} \PYG{n}{tmpactive}\PYG{p}{;}
                \PYG{n}{tmpactive} \PYG{o}{=} \PYG{n}{active}\PYG{p}{[}\PYG{n}{tmpactive}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getNext}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
            \PYG{k}{if}\PYG{p}{(}\PYG{n}{tmpactive}\PYG{o}{!}\PYG{o}{=}\PYG{n}{chosen}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{nwrap: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{active}\PYG{p}{[}\PYG{n}{chosen}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getNwrap}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
                \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{gridnwrap: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{grid}\PYG{p}{[}\PYG{n}{active}\PYG{p}{[}\PYG{n}{chosen}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getYpos}\PYG{p}{(}\PYG{p}{)}\PYG{p}{]}\PYG{p}{[}\PYG{n}{active}\PYG{p}{[}\PYG{n}{chosen}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getXpos}\PYG{p}{(}\PYG{p}{)}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getNwrap}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
\end{sphinxVerbatim}
\begin{sphinxVerbatim}[commandchars=\\\{\}]                
\PYG{c+c1}{//              cout \PYGZlt{}\PYGZlt{} \PYGZdq{}speccounter: \PYGZdq{} \PYGZlt{}\PYGZlt{} spec\PYGZus{}counter \PYGZlt{}\PYGZlt{} endl;}
\PYG{c+c1}{//              cout \PYGZlt{}\PYGZlt{} \PYGZdq{}startnwrap: \PYGZdq{} \PYGZlt{}\PYGZlt{} startnwrap \PYGZlt{}\PYGZlt{} endl;}
                \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{chosen: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{chosen} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
\PYG{c+c1}{//              cout \PYGZlt{}\PYGZlt{} \PYGZdq{}start x,y: \PYGZdq{} \PYGZlt{}\PYGZlt{} startx \PYGZlt{}\PYGZlt{} \PYGZdq{},\PYGZdq{} \PYGZlt{}\PYGZlt{} starty \PYGZlt{}\PYGZlt{} endl;}
\PYG{c+c1}{//              cout \PYGZlt{}\PYGZlt{} \PYGZdq{}end x,y: \PYGZdq{} \PYGZlt{}\PYGZlt{} oldx \PYGZlt{}\PYGZlt{} \PYGZdq{},\PYGZdq{} \PYGZlt{}\PYGZlt{} oldy \PYGZlt{}\PYGZlt{} endl;}
                \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{active x,y: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{active}\PYG{p}{[}\PYG{n}{chosen}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getXpos}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{,}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{active}\PYG{p}{[}\PYG{n}{chosen}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getYpos}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
                \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{wrap x,y: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{active}\PYG{p}{[}\PYG{n}{chosen}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getXwrap}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{,}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{active}\PYG{p}{[}\PYG{n}{chosen}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getYwrap}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
                \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{tmpactive: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{tmpactive} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ chosen: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{chosen} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ chosennext: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{active}\PYG{p}{[}\PYG{n}{chosen}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getNext}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{lastactive: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{lastactive}\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
                \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{VALIDATION\PYGZus{}002: Nwrap not set correctly.}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
                \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{o: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{o} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
                \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{current chosen: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{current} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
                \PYG{k}{throw} \PYG{n+nf}{Fatal\PYGZus{}Exception}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{VALIDATION\PYGZus{}001: Listpos outside maxsize.}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
        \PYG{p}{\PYGZcb{}}
    \PYG{p}{\PYGZcb{}}


    \PYG{k+kt}{void} \PYG{n}{checkSimSize}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{req\PYGZus{}data}\PYG{p}{,}\PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{req\PYGZus{}active}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
\PYG{c+c1}{//      cout \PYGZlt{}\PYGZlt{} \PYGZdq{}Started change size\PYGZdq{} \PYGZlt{}\PYGZlt{} endl;}
        \PYG{c+c1}{// need to be double the size of the maximum number of individuals plus enddata}
        \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{min\PYGZus{}data} \PYG{o}{=} \PYG{p}{(}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{req\PYGZus{}data}\PYG{p}{)} \PYG{o}{+} \PYG{n}{enddata}\PYG{p}{;}
        \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{min\PYGZus{}active} \PYG{o}{=} \PYG{n}{endactive} \PYG{o}{+} \PYG{n}{req\PYGZus{}active}\PYG{p}{;}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{data}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZlt{}} \PYG{n}{min\PYGZus{}data}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{c+c1}{// change the size of data}
            \PYG{n}{data}\PYG{p}{.}\PYG{n}{changeSize}\PYG{p}{(}\PYG{n}{min\PYGZus{}data}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}

        \PYG{k}{if}\PYG{p}{(}\PYG{n}{active}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZlt{}} \PYG{n}{min\PYGZus{}active}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{c+c1}{// change the size of active.}
            \PYG{n}{active}\PYG{p}{.}\PYG{n}{changeSize}\PYG{p}{(}\PYG{n}{min\PYGZus{}active}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
\PYG{c+c1}{//      cout \PYGZlt{}\PYGZlt{} \PYGZdq{}finished change size\PYGZdq{} \PYGZlt{}\PYGZlt{} endl;}
    \PYG{p}{\PYGZcb{}}

    \PYG{k+kt}{bool} \PYG{n}{runSim}\PYG{p}{(}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{c+c1}{// now do the calculations required to build the tree}
        \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{*************************************************}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
        \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Beginning simulations...}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{flush}\PYG{p}{;}
\PYG{c+c1}{//      double current\PYGZus{}gen =0;}
        \PYG{n}{startendactive} \PYG{o}{=} \PYG{n}{endactive}\PYG{p}{;}
        \PYG{c+c1}{// check time}
        \PYG{n}{time}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{sim\PYGZus{}start}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{time}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{sim\PYGZus{}end}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{time}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{now}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{time}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{tCheckSpec}\PYG{p}{)}\PYG{p}{;}
        \PYG{k+kt}{bool} \PYG{n}{bContinueSim}\PYG{o}{=}\PYG{n+nb}{true}\PYG{p}{;}
        \PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifdef verbose}
        \PYG{k+kt}{double} \PYG{n}{dPercentComplete}\PYG{p}{;}
        \PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif}
        \PYG{k+kt}{unsigned} \PYG{k+kt}{int} \PYG{n}{iAutoComplete} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{c+c1}{//      time\PYGZus{}t loopend;}
        \PYG{c+c1}{// Main while loop to process while there is still time left and the simulation is not complete.}
        \PYG{k}{while} \PYG{p}{(}\PYG{p}{(}\PYG{n}{endactive} \PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}}\PYG{p}{(}\PYG{n}{difftime}\PYG{p}{(}\PYG{n}{sim\PYGZus{}end}\PYG{p}{,}\PYG{n}{start}\PYG{p}{)} \PYG{o}{\PYGZlt{}} \PYG{n}{maxtime}\PYG{p}{)}\PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}}\PYG{n}{bContinueSim}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{c+c1}{// check the size of the simulations \PYGZhy{} decided this doesn\PYGZsq{}t need to be here if the check is performed properly at map expansion.}
\PYG{c+c1}{//          checkSimSize(100,false,0);}
\PYG{c+c1}{//          time(\PYGZam{}loopstart);}
            \PYG{n}{steps} \PYG{o}{+}\PYG{o}{+}\PYG{p}{;}
            \PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifdef verbose}
            \PYG{k}{if} \PYG{p}{(}\PYG{p}{(}\PYG{n}{steps}\PYG{o}{\PYGZpc{}}\PYG{l+m+mi}{10000}\PYG{o}{=}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{o}{\textbar{}}\PYG{o}{\textbar{}}\PYG{n}{debug}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{n}{time}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{sim\PYGZus{}end}\PYG{p}{)}\PYG{p}{;}
                \PYG{k}{if}\PYG{p}{(}\PYG{n}{sim\PYGZus{}end}\PYG{o}{\PYGZhy{}}\PYG{n}{now} \PYG{o}{\PYGZgt{}} \PYG{l+m+mf}{0.2}\PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}}\PYG{n}{log\PYGZus{}all}\PYG{p}{)} \PYG{c+c1}{// output every 0.2 seconds}
                \PYG{p}{\PYGZob{}}

                    \PYG{n}{dPercentComplete} \PYG{o}{=} \PYG{l+m+mi}{100}\PYG{o}{*}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{o}{\PYGZhy{}}\PYG{p}{(}\PYG{k+kt}{double}\PYG{p}{(}\PYG{n}{endactive}\PYG{p}{)}\PYG{o}{/}\PYG{k+kt}{double}\PYG{p}{(}\PYG{n}{startendactive}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
                    \PYG{n}{time}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{now}\PYG{p}{)}\PYG{p}{;}

                    \PYG{n}{cout}  \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}r}\PYG{l+s}{Beginning simulations...}\PYG{l+s}{\PYGZdq{}}\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{n}{endactive} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ lineages remaining: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{dPercentComplete} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZpc{}                                                     }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{flush}\PYG{p}{;}

                \PYG{p}{\PYGZcb{}}
            \PYG{p}{\PYGZcb{}}
            \PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif}
            \PYG{c+c1}{// increment generation counter}
            \PYG{n}{generation} \PYG{o}{+}\PYG{o}{=} \PYG{l+m+mf}{2.0}\PYG{o}{/}\PYG{p}{(}\PYG{k+kt}{double}\PYG{p}{(}\PYG{n}{endactive}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
            \PYG{k}{if}\PYG{p}{(}\PYG{n}{bAutocorrel} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{n}{iAutoComplete} \PYG{o}{\PYGZlt{}} \PYG{n}{autocorrel\PYGZus{}times}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{c+c1}{//cout \PYGZlt{}\PYGZlt{} \PYGZdq{}Check1\PYGZdq{} \PYGZlt{}\PYGZlt{} endl;}
\PYG{c+c1}{//              cout \PYGZlt{}\PYGZlt{} iAutoComplete \PYGZlt{}\PYGZlt{} endl;}
\PYG{c+c1}{//              cout \PYGZlt{}\PYGZlt{} autocorrel\PYGZus{}file \PYGZlt{}\PYGZlt{} endl;}
\PYG{c+c1}{//              for (int i = 0;i\PYGZlt{}autocorrel\PYGZus{}times.size(); i ++)}
\PYG{c+c1}{//              \PYGZob{}}
\PYG{c+c1}{//                  cout \PYGZlt{}\PYGZlt{} autocorrel\PYGZus{}times[i] \PYGZlt{}\PYGZlt{} endl;}
\PYG{c+c1}{//              \PYGZcb{}}
                \PYG{c+c1}{// check if we need to update}
                \PYG{k}{if}\PYG{p}{(}\PYG{n}{autocorrel\PYGZus{}times}\PYG{p}{[}\PYG{n}{iAutoComplete}\PYG{p}{]}\PYG{o}{\PYGZlt{}}\PYG{o}{=}\PYG{n}{generation}\PYG{p}{)}
                \PYG{p}{\PYGZob{}}
\PYG{c+c1}{//                  cout \PYGZlt{}\PYGZlt{} \PYGZdq{}check2\PYGZdq{} \PYGZlt{}\PYGZlt{} endl;}
                    \PYG{k}{if}\PYG{p}{(}\PYG{n}{autocorrel\PYGZus{}times}\PYG{p}{[}\PYG{n}{iAutoComplete}\PYG{p}{]}\PYG{o}{\PYGZgt{}}\PYG{l+m+mf}{0.0}\PYG{p}{)}
                    \PYG{p}{\PYGZob{}}
                        \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{expanding map at generation }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{generation} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{...}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{flush}\PYG{p}{;}
                        \PYG{n}{expandMap}\PYG{p}{(}\PYG{n}{autocorrel\PYGZus{}times}\PYG{p}{[}\PYG{n}{iAutoComplete}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
                        \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{done!}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
                    \PYG{p}{\PYGZcb{}}
                    \PYG{n}{iAutoComplete} \PYG{o}{+}\PYG{o}{+}\PYG{p}{;}
                \PYG{p}{\PYGZcb{}}
            \PYG{p}{\PYGZcb{}}
            \PYG{c+c1}{// check if the map is pristine yet}
            \PYG{k}{if}\PYG{p}{(}\PYG{n}{generation}\PYG{o}{\PYGZgt{}}\PYG{o}{=}\PYG{n}{dPristine}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{n}{forestmap}\PYG{p}{.}\PYG{n}{setPristine}\PYG{p}{(}\PYG{n+nb}{true}\PYG{p}{)}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
            \PYG{c+c1}{// choose a random lineage to die and be reborn out of those currently active}
            \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{chosen} \PYG{o}{=} \PYG{n}{NR}\PYG{p}{.}\PYG{n}{i0}\PYG{p}{(}\PYG{n}{endactive}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{;} \PYG{c+c1}{// cannot be 0}
            \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{coalchosen} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
            \PYG{c+c1}{// record old position of lineage}
            \PYG{k+kt}{long} \PYG{n}{oldx} \PYG{o}{=} \PYG{n}{active}\PYG{p}{[}\PYG{n}{chosen}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getXpos}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
            \PYG{k+kt}{long} \PYG{n}{oldy} \PYG{o}{=} \PYG{n}{active}\PYG{p}{[}\PYG{n}{chosen}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getYpos}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{c+c1}{//          long startxpos, startypos;}
\PYG{c+c1}{//          startxpos = oldx;}
\PYG{c+c1}{//          startypos = oldy;}
            \PYG{k+kt}{long} \PYG{n}{oldxwrap} \PYG{o}{=} \PYG{n}{active}\PYG{p}{[}\PYG{n}{chosen}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getXwrap}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
            \PYG{k+kt}{long} \PYG{n}{oldywrap} \PYG{o}{=} \PYG{n}{active}\PYG{p}{[}\PYG{n}{chosen}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getYwrap}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
            \PYG{k+kt}{bool} \PYG{n}{coal} \PYG{o}{=} \PYG{n+nb}{false}\PYG{p}{;}
            \PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifdef pristine\PYGZus{}mode}
            \PYG{k}{if}\PYG{p}{(}\PYG{n}{forestmap}\PYG{p}{.}\PYG{n}{getVal}\PYG{p}{(}\PYG{n}{oldx}\PYG{p}{,}\PYG{n}{oldy}\PYG{p}{,}\PYG{n}{oldxwrap}\PYG{p}{,}\PYG{n}{oldywrap}\PYG{p}{,}\PYG{n}{generation}\PYG{p}{)}\PYG{o}{=}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{n}{cerr} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{x,y: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{oldx} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{,}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{oldy} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ xwrap, ywrap: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{oldxwrap} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{,}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{oldywrap} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
                \PYG{n}{cerr} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{listsize: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{grid}\PYG{p}{[}\PYG{n}{oldy}\PYG{p}{]}\PYG{p}{[}\PYG{n}{oldx}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getListsize}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{maxsize: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{grid}\PYG{p}{[}\PYG{n}{oldy}\PYG{p}{]}\PYG{p}{[}\PYG{n}{oldx}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getMaxsize}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
                \PYG{k}{throw} \PYG{n+nf}{Fatal\PYGZus{}Exception}\PYG{p}{(}\PYG{n}{string}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ERROR\PYGZus{}MOVE\PYGZus{}008: Dispersal attempted from non\PYGZhy{}forest. Check dispersal function. Forest cover: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{+} \PYG{n}{to\PYGZus{}string}\PYG{p}{(}\PYG{p}{(}\PYG{k+kt}{long} \PYG{k+kt}{long}\PYG{p}{)}\PYG{n}{forestmap}\PYG{p}{.}\PYG{n}{getVal}\PYG{p}{(}\PYG{n}{oldx}\PYG{p}{,}\PYG{n}{oldy}\PYG{p}{,}\PYG{n}{oldxwrap}\PYG{p}{,}\PYG{n}{oldywrap}\PYG{p}{,}\PYG{n}{generation}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
            \PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif}
            \PYG{c+c1}{// This bit has been removed as it has a very significant performance hit and is not required for most simulations. As of version 3.2 it was fully compatible with the rest of the simulation, however.}
            \PYG{c+cm}{/*}
\PYG{c+cm}{            if(steps\PYGZpc{}1000000==0)}
\PYG{c+cm}{            \PYGZob{}}
\PYG{c+cm}{                time(\PYGZam{}now);}
\PYG{c+cm}{                if(now \PYGZhy{} tCheckSpec\PYGZgt{}200\PYGZam{}\PYGZam{}dPercentComplete\PYGZgt{}95)}
\PYG{c+cm}{                \PYGZob{}}
\PYG{c+cm}{                    time(\PYGZam{}tCheckSpec);}
\PYG{c+cm}{                    unsigned long specnum = est\PYGZus{}specnum();}
\PYG{c+cm}{                    cout \PYGZlt{}\PYGZlt{} \PYGZdq{}Estimated number of species: \PYGZdq{} \PYGZlt{}\PYGZlt{} specnum \PYGZlt{}\PYGZlt{} flush;}
\PYG{c+cm}{                    if(specnum\PYGZlt{}desired\PYGZus{}specnum)}
\PYG{c+cm}{                    \PYGZob{}}
\PYG{c+cm}{                        cout \PYGZlt{}\PYGZlt{} \PYGZdq{} \PYGZhy{} desired number of species reached.\PYGZdq{} \PYGZlt{}\PYGZlt{} endl \PYGZlt{}\PYGZlt{} \PYGZdq{}Halting simulations...\PYGZdq{} \PYGZlt{}\PYGZlt{} endl;}
\PYG{c+cm}{                        bContinueSim = false;}
\PYG{c+cm}{                    \PYGZcb{}}
\PYG{c+cm}{                    else}
\PYG{c+cm}{                    \PYGZob{}}
\PYG{c+cm}{                        cout \PYGZlt{}\PYGZlt{} endl;}
\PYG{c+cm}{                    \PYGZcb{}}
\PYG{c+cm}{                \PYGZcb{}}
\PYG{c+cm}{            \PYGZcb{}}
\PYG{c+cm}{            //*/}
            \PYG{c+c1}{// LIST OF POTENTIAL IMPROVEMENTS FOR THE FUTURE}
            \PYG{c+c1}{// 1 \PYGZhy{} Improve the SpeciesList referencing method when a species is deleted from the list.}
            \PYG{c+c1}{// 2 \PYGZhy{} Improve how the looping over next and last occurs so that the loop only needs to be performed once. This could have major speed implications.}
            \PYG{c+c1}{// decide if speciation occured}
            \PYG{c+c1}{// Include alteration of forestmap over time.}
            \PYG{c+c1}{// Continue the simulation if the conditions are met for bContinueSim (in test scenarios this will always be true until all lineages have coalesced.}
            \PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifdef DEBUG}
            \PYG{n}{string} \PYG{n}{location} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{none}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
            \PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif}
            \PYG{k}{try}
            \PYG{p}{\PYGZob{}}
                \PYG{k}{if}\PYG{p}{(}\PYG{n}{bContinueSim}\PYG{p}{)}
                \PYG{p}{\PYGZob{}}
                    \PYG{c+c1}{//cout \PYGZlt{}\PYGZlt{} \PYGZdq{}check1\PYGZdq{} \PYGZlt{}\PYGZlt{} endl;}
                    \PYG{n}{coal} \PYG{o}{=} \PYG{n+nb}{false}\PYG{p}{;}
                    \PYG{c+c1}{// increase the counter of the number of moves (or generations) the lineage has undergone.}
                    \PYG{n}{data}\PYG{p}{[}\PYG{n}{active}\PYG{p}{[}\PYG{n}{chosen}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getMpos}\PYG{p}{(}\PYG{p}{)}\PYG{p}{]}\PYG{p}{.}\PYG{n}{increaseGen}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
                    \PYG{c+c1}{// Check if speciation happens}
                    \PYG{k}{if}\PYG{p}{(}\PYG{n}{checkSpeciation}\PYG{p}{(}\PYG{n}{data}\PYG{p}{[}\PYG{n}{active}\PYG{p}{[}\PYG{n}{chosen}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getMpos}\PYG{p}{(}\PYG{p}{)}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getSpecRate}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{n}{spec}\PYG{p}{,} \PYG{n}{data}\PYG{p}{[}\PYG{n}{active}\PYG{p}{[}\PYG{n}{chosen}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getMpos}\PYG{p}{(}\PYG{p}{)}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getGenRate}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
                    \PYG{p}{\PYGZob{}}
                        \PYG{c+c1}{//cout \PYGZlt{}\PYGZlt{} \PYGZdq{}spec: \PYGZdq{} \PYGZlt{}\PYGZlt{} spec \PYGZlt{}\PYGZlt{} endl;}
                        \PYG{c+c1}{//cout \PYGZlt{}\PYGZlt{} \PYGZdq{}data spec rate: \PYGZdq{} \PYGZlt{}\PYGZlt{} data[active[chosen].getMpos()].getSpecRate() \PYGZlt{}\PYGZlt{} endl;}
                        \PYG{c+c1}{//cout \PYGZlt{}\PYGZlt{} \PYGZdq{}iGen: \PYGZdq{} \PYGZlt{}\PYGZlt{} data[active[chosen].getMpos()].getGenRate() \PYGZlt{}\PYGZlt{} endl;}
                        \PYG{c+c1}{//string sam;}
                        \PYG{c+c1}{//cin \PYGZgt{}\PYGZgt{} sam;}
                        \PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifdef DEBUG}
                        \PYG{n}{location} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{speciation}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
                        \PYG{c+c1}{//if ( data[active[chosen].getMpos()].)}
                        \PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif}
                        \PYG{n}{speciation}\PYG{p}{(}\PYG{n}{chosen}\PYG{p}{)}\PYG{p}{;}
                    \PYG{p}{\PYGZcb{}}
                    \PYG{k}{else}
                    \PYG{p}{\PYGZob{}}
                        \PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifdef DEBUG}
                        \PYG{n}{location} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{standard: oldpos }\PYG{l+s}{\PYGZdq{}} \PYG{o}{+} \PYG{n}{to\PYGZus{}string}\PYG{p}{(}\PYG{n}{oldx}\PYG{p}{)} \PYG{o}{+} \PYG{n}{to\PYGZus{}string}\PYG{p}{(}\PYG{n}{oldy}\PYG{p}{)}\PYG{p}{;}
                        \PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif}
                        \PYG{n}{removeOldPos}\PYG{p}{(}\PYG{n}{chosen}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{// remove the species data from the species list to be placed somewhere new.}
\PYG{c+c1}{//                      long oldoldxwrap = oldxwrap;}
                                            \PYG{c+c1}{//cout \PYGZlt{}\PYGZlt{} \PYGZdq{}check1.b\PYGZdq{} \PYGZlt{}\PYGZlt{} endl;}

                        \PYG{n}{calcMove}\PYG{p}{(}\PYG{n}{oldx}\PYG{p}{,}\PYG{n}{oldy}\PYG{p}{,}\PYG{n}{oldxwrap}\PYG{p}{,}\PYG{n}{oldywrap}\PYG{p}{)}\PYG{p}{;}
\PYG{c+c1}{//                      if(oldoldxwrap != oldxwrap)}
\PYG{c+c1}{//                      \PYGZob{}}
\PYG{c+c1}{//                          cout \PYGZlt{}\PYGZlt{} \PYGZdq{}CHANGED!\PYGZdq{} \PYGZlt{}\PYGZlt{} oldoldxwrap \PYGZlt{}\PYGZlt{} \PYGZdq{},\PYGZdq{} \PYGZlt{}\PYGZlt{} oldxwrap \PYGZlt{}\PYGZlt{} endl;}
\PYG{c+c1}{//                      \PYGZcb{}}
                                            \PYG{c+c1}{//cout \PYGZlt{}\PYGZlt{} \PYGZdq{}check2.a\PYGZdq{} \PYGZlt{}\PYGZlt{} endl;}

                        \PYG{c+c1}{// Calculate the new position, perform the move if coalescence doesn\PYGZsq{}t occur or return the variables for the coalescence event if coalescence does occur.}
                        \PYG{n}{active}\PYG{p}{[}\PYG{n}{chosen}\PYG{p}{]}\PYG{p}{.}\PYG{n}{setEndpoint}\PYG{p}{(}\PYG{n}{oldx}\PYG{p}{,}\PYG{n}{oldy}\PYG{p}{,}\PYG{n}{oldxwrap}\PYG{p}{,}\PYG{n}{oldywrap}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{// the \PYGZdq{}old\PYGZdq{} variables have been updated, so we can just input them back in to the function.}
                        \PYG{n}{calcNewPos}\PYG{p}{(}\PYG{n}{coal}\PYG{p}{,}\PYG{n}{chosen}\PYG{p}{,}\PYG{n}{coalchosen}\PYG{p}{,}\PYG{n}{oldx}\PYG{p}{,}\PYG{n}{oldy}\PYG{p}{,}\PYG{n}{oldxwrap}\PYG{p}{,}\PYG{n}{oldywrap}\PYG{p}{)}\PYG{p}{;}
                        \PYG{c+c1}{//cout \PYGZlt{}\PYGZlt{} \PYGZdq{}check2.b\PYGZdq{} \PYGZlt{}\PYGZlt{} endl;}
                        \PYG{k}{if}\PYG{p}{(}\PYG{n}{coal}\PYG{p}{)} \PYG{c+c1}{// coalescence occured, so we need to adjust the data appropriatedly}
                        \PYG{p}{\PYGZob{}}
                            \PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifdef DEBUG}
                            \PYG{n}{location} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{coalescence: coalchosen \PYGZhy{} }\PYG{l+s}{\PYGZdq{}} \PYG{o}{+} \PYG{n}{to\PYGZus{}string}\PYG{p}{(}\PYG{n}{coalchosen}\PYG{p}{)}\PYG{p}{;}
                            \PYG{k}{if}\PYG{p}{(}\PYG{n}{active}\PYG{p}{[}\PYG{n}{coalchosen}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getXpos}\PYG{p}{(}\PYG{p}{)} \PYG{o}{!}\PYG{o}{=} \PYG{n}{active}\PYG{p}{[}\PYG{n}{chosen}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getXpos}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\textbar{}}\PYG{o}{\textbar{}} \PYG{n}{active}\PYG{p}{[}\PYG{n}{coalchosen}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getYpos}\PYG{p}{(}\PYG{p}{)} \PYG{o}{!}\PYG{o}{=} \PYG{n}{active}\PYG{p}{[}\PYG{n}{chosen}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getYpos}\PYG{p}{(}\PYG{p}{)}
                                \PYG{o}{\textbar{}}\PYG{o}{\textbar{}} \PYG{n}{active}\PYG{p}{[}\PYG{n}{coalchosen}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getXwrap}\PYG{p}{(}\PYG{p}{)} \PYG{o}{!}\PYG{o}{=} \PYG{n}{active}\PYG{p}{[}\PYG{n}{chosen}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getXwrap}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\textbar{}}\PYG{o}{\textbar{}} \PYG{n}{active}\PYG{p}{[}\PYG{n}{coalchosen}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getYwrap}\PYG{p}{(}\PYG{p}{)} \PYG{o}{!}\PYG{o}{=} \PYG{n}{active}\PYG{p}{[}\PYG{n}{chosen}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getYwrap}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
                            \PYG{p}{\PYGZob{}}
                                \PYG{n}{cerr} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{chosen} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{,}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{coalchosen} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
                                \PYG{n}{cerr} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{chosen \PYGZhy{} x,y: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{active}\PYG{p}{[}\PYG{n}{chosen}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getXpos}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{,}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{active}\PYG{p}{[}\PYG{n}{chosen}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getYpos}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{x, y wrap: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{active}\PYG{p}{[}\PYG{n}{chosen}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getXwrap}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
                                \PYG{n}{cerr} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{,}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{active}\PYG{p}{[}\PYG{n}{chosen}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getYwrap}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
                                \PYG{n}{cerr} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{coalchosen \PYGZhy{} x,y:}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{active}\PYG{p}{[}\PYG{n}{coalchosen}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getXpos}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{,}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{active}\PYG{p}{[}\PYG{n}{coalchosen}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getYpos}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
                                \PYG{n}{cerr} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ x,y wrap: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{active}\PYG{p}{[}\PYG{n}{coalchosen}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getXwrap}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{,}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{active}\PYG{p}{[}\PYG{n}{coalchosen}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getYwrap}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
                                \PYG{k}{throw} \PYG{n+nf}{Fatal\PYGZus{}Exception}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ERROR\PYGZus{}MOVE\PYGZus{}006: NON FATAL. Nwrap not set correctly. Check move programming function.}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
                            \PYG{p}{\PYGZcb{}}
                            \PYG{k}{if}\PYG{p}{(}\PYG{n}{active}\PYG{p}{[}\PYG{n}{coalchosen}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getXpos}\PYG{p}{(}\PYG{p}{)} \PYG{o}{!}\PYG{o}{=} \PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{long}\PYG{p}{)} \PYG{n}{oldx} \PYG{o}{\textbar{}}\PYG{o}{\textbar{}} \PYG{n}{active}\PYG{p}{[}\PYG{n}{coalchosen}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getYpos}\PYG{p}{(}\PYG{p}{)} \PYG{o}{!}\PYG{o}{=} \PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{long}\PYG{p}{)} \PYG{n}{oldy} \PYG{o}{\textbar{}}\PYG{o}{\textbar{}} \PYG{n}{active}\PYG{p}{[}\PYG{n}{coalchosen}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getXwrap}\PYG{p}{(}\PYG{p}{)} \PYG{o}{!}\PYG{o}{=} \PYG{n}{oldxwrap} \PYG{o}{\textbar{}}\PYG{o}{\textbar{}} \PYG{n}{active}\PYG{p}{[}\PYG{n}{coalchosen}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getYwrap}\PYG{p}{(}\PYG{p}{)} \PYG{o}{!}\PYG{o}{=} \PYG{n}{oldywrap}\PYG{p}{)}
                            \PYG{p}{\PYGZob{}}
                                \PYG{n}{cerr} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{chosen} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{,}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{coalchosen} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
                                \PYG{n}{cerr} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{chosen \PYGZhy{} x,y: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{oldx} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{,}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{oldy} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{x, y wrap: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{oldxwrap} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{,}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{oldywrap} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
                                \PYG{n}{cerr} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{coalchosen \PYGZhy{} x,y:}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{active}\PYG{p}{[}\PYG{n}{coalchosen}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getXpos}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{,}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{active}\PYG{p}{[}\PYG{n}{coalchosen}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getYpos}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
                                \PYG{n}{cerr} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ x,y wrap: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{active}\PYG{p}{[}\PYG{n}{coalchosen}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getXwrap}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{,}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{active}\PYG{p}{[}\PYG{n}{coalchosen}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getYwrap}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
                                \PYG{k}{throw} \PYG{n+nf}{Fatal\PYGZus{}Exception}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ERROR\PYGZus{}MOVE\PYGZus{}006: NON FATAL. Nwrap not set correctly. Check move programming function.}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
                            \PYG{p}{\PYGZcb{}}
                            \PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif}
                            \PYG{n}{coalescenceEvent}\PYG{p}{(}\PYG{n}{chosen}\PYG{p}{,}\PYG{n}{coalchosen}\PYG{p}{)}\PYG{p}{;}
                        \PYG{p}{\PYGZcb{}}
                        \PYG{k}{else} \PYG{c+c1}{// debugging only now as the move process has been incorportated into calcNewPos().}
                        \PYG{p}{\PYGZob{}}
                            \PYG{c+c1}{// for debugging only}
                            \PYG{k}{if}\PYG{p}{(}\PYG{n}{forestmap}\PYG{p}{.}\PYG{n}{getVal}\PYG{p}{(}\PYG{n}{oldx}\PYG{p}{,}\PYG{n}{oldy}\PYG{p}{,}\PYG{n}{oldxwrap}\PYG{p}{,}\PYG{n}{oldywrap}\PYG{p}{,}\PYG{n}{generation}\PYG{p}{)}\PYG{o}{=}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
                            \PYG{p}{\PYGZob{}}
                                \PYG{k}{throw} \PYG{n}{Fatal\PYGZus{}Exception}\PYG{p}{(}\PYG{n}{string}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ERROR\PYGZus{}MOVE\PYGZus{}007: Dispersal attempted to non\PYGZhy{}forest. Check dispersal function. Forest cover: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{+} \PYG{n}{to\PYGZus{}string}\PYG{p}{(}\PYG{p}{(}\PYG{k+kt}{long} \PYG{k+kt}{long}\PYG{p}{)}\PYG{n}{forestmap}\PYG{p}{.}\PYG{n}{getVal}\PYG{p}{(}\PYG{n}{oldx}\PYG{p}{,}\PYG{n}{oldy}\PYG{p}{,}\PYG{n}{oldxwrap}\PYG{p}{,}\PYG{n}{oldywrap}\PYG{p}{,}\PYG{n}{generation}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
                            \PYG{p}{\PYGZcb{}}
                        \PYG{p}{\PYGZcb{}}
                    \PYG{p}{\PYGZcb{}}

                \PYG{p}{\PYGZcb{}}
            \PYG{p}{\PYGZcb{}}
            \PYG{k}{catch}\PYG{p}{(}\PYG{n}{Fatal\PYGZus{}Exception}\PYG{o}{\PYGZam{}} \PYG{n}{fe}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{n}{cerr} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{fe}\PYG{p}{.}\PYG{n}{what}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
                \PYG{n}{exit}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
            \PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifdef DEBUG}
            \PYG{k}{try}
            \PYG{p}{\PYGZob{}}
                \PYG{n}{validationCheck}\PYG{p}{(}\PYG{n}{chosen}\PYG{p}{,}\PYG{l+m+mi}{112}\PYG{p}{,}\PYG{n}{chosen}\PYG{p}{,} \PYG{n}{coal}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{// this can probably be removed now}
            \PYG{p}{\PYGZcb{}}
            \PYG{k}{catch}\PYG{p}{(}\PYG{n}{Fatal\PYGZus{}Exception} \PYG{o}{\PYGZam{}}\PYG{n}{fe}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{n}{cerr} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{fe}\PYG{p}{.}\PYG{n}{what}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
                \PYG{n}{cerr} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Location tag: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{location} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
                \PYG{k}{throw} \PYG{n+nf}{Fatal\PYGZus{}Exception}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
            \PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif}
            \PYG{k}{try}
            \PYG{p}{\PYGZob{}}
                \PYG{c+c1}{//cout \PYGZlt{}\PYGZlt{} \PYGZdq{}check3\PYGZdq{} \PYGZlt{}\PYGZlt{} endl;}
                \PYG{n}{runChecks}\PYG{p}{(}\PYG{n}{chosen}\PYG{p}{,}\PYG{n}{coalchosen}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{// as can this (but there is likely minimal performance hit and it does prevent errors).}
                \PYG{c+c1}{// if debug mode is enabled, run a full debug every single time step (this will have  a massive performance hit)}
                \PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifdef debug\PYGZus{}mode}
                \PYG{c+c1}{// runs the debug every 10,000 time steps}
                \PYG{k}{if}\PYG{p}{(}\PYG{n}{steps}\PYG{o}{\PYGZpc{}}\PYG{l+m+mi}{10000} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{0} \PYG{p}{)}
                \PYG{p}{\PYGZob{}}
                    \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i}\PYG{o}{\PYGZlt{}}\PYG{o}{=}\PYG{n}{endactive}\PYG{p}{;}\PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
                    \PYG{p}{\PYGZob{}}
                        \PYG{n}{runChecks}\PYG{p}{(}\PYG{n}{i}\PYG{p}{,}\PYG{n}{i}\PYG{p}{)}\PYG{p}{;}
                    \PYG{p}{\PYGZcb{}}
                \PYG{p}{\PYGZcb{}}
                \PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif}
            \PYG{p}{\PYGZcb{}}
            \PYG{k}{catch}\PYG{p}{(}\PYG{n}{Fatal\PYGZus{}Exception}\PYG{o}{\PYGZam{}} \PYG{n}{fe}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{n}{cerr} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{fe}\PYG{p}{.}\PYG{n}{what}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
                \PYG{n}{cerr} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{dumping data file...}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
                \PYG{n}{sqlCreate}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
                \PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifdef sql\PYGZus{}ram}
                \PYG{n}{sqlOutput}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
                \PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif}
                \PYG{n}{cerr} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{done!}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
        \PYG{p}{\PYGZcb{}}
        \PYG{c+c1}{// If the simulations finish correctly, output the completed data.}
        \PYG{c+c1}{// Otherwise, pause the simulation and save objects to file.}

        \PYG{k}{if}\PYG{p}{(}\PYG{n}{endactive}\PYG{o}{\PYGZgt{}}\PYG{l+m+mi}{1}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{........out of time!}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Pausing simulation: add extra time or re\PYGZhy{}run to ensure simulation completion.}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
            \PYG{n}{time}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{sim\PYGZus{}finish}\PYG{p}{)}\PYG{p}{;}
            \PYG{n}{simPause}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
            \PYG{k}{return} \PYG{n+nb}{false}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{else}
        \PYG{p}{\PYGZob{}}
            \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{int} \PYG{n}{i}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;}\PYG{n}{i}\PYG{o}{\PYGZlt{}}\PYG{o}{=}\PYG{n}{endactive}\PYG{p}{;}\PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{n}{data}\PYG{p}{[}\PYG{n}{active}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getMpos}\PYG{p}{(}\PYG{p}{)}\PYG{p}{]}\PYG{p}{.}\PYG{n}{speciate}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
                \PYG{n}{data}\PYG{p}{[}\PYG{n}{active}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getMpos}\PYG{p}{(}\PYG{p}{)}\PYG{p}{]}\PYG{p}{.}\PYG{n}{setSpec}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
            \PYG{k}{if}\PYG{p}{(}\PYG{o}{!}\PYG{n}{bContinueSim}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}r}\PYG{l+s}{Beginning simulations........done \PYGZhy{} desired number of species achieved!}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
                \PYG{n}{time}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{sim\PYGZus{}finish}\PYG{p}{)}\PYG{p}{;}
                \PYG{k}{return} \PYG{n+nb}{true}\PYG{p}{;}
\PYG{c+c1}{//              sqlCreate();}
            \PYG{p}{\PYGZcb{}}
            \PYG{k}{else}
            \PYG{p}{\PYGZob{}}
                \PYG{n}{time}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{sim\PYGZus{}finish}\PYG{p}{)}\PYG{p}{;}
                \PYG{n}{cout}  \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}r}\PYG{l+s}{Beginning simulations........done!                                                                    }\PYG{l+s}{\PYGZdq{}}\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{n}{endl}\PYG{p}{;}
                \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Exiting main loop}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
                \PYG{k}{return} \PYG{n+nb}{true}\PYG{p}{;}
\PYG{c+c1}{//              sqlCreate();}
            \PYG{p}{\PYGZcb{}}
        \PYG{p}{\PYGZcb{}}
    \PYG{p}{\PYGZcb{}}


    \PYG{k+kt}{void} \PYG{n}{expandMap}\PYG{p}{(}\PYG{k+kt}{double} \PYG{n}{generationin}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
\PYG{c+c1}{//      cout \PYGZlt{}\PYGZlt{} \PYGZdq{}expanding...\PYGZdq{} \PYGZlt{}\PYGZlt{} endl;}
\PYG{c+c1}{//  / loop over the grid first to check how many we need to add}
\PYG{c+c1}{//      cout \PYGZlt{}\PYGZlt{} \PYGZdq{}enddata: \PYGZdq{} \PYGZlt{}\PYGZlt{} enddata \PYGZlt{}\PYGZlt{} endl;}
\PYG{c+c1}{//      cout \PYGZlt{}\PYGZlt{} \PYGZdq{}endactive: \PYGZdq{} \PYGZlt{}\PYGZlt{} endactive \PYGZlt{}\PYGZlt{} endl;}
        \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{added\PYGZus{}active} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
        \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{added\PYGZus{}data} \PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;}
        \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}\PYG{n}{i}\PYG{o}{\PYGZlt{}} \PYG{n}{grid}\PYG{p}{.}\PYG{n}{GetCols}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}\PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
\PYG{c+c1}{//          cout \PYGZlt{}\PYGZlt{} i \PYGZlt{}\PYGZlt{} endl;}
            \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{j} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}\PYG{n}{j} \PYG{o}{\PYGZlt{}} \PYG{n}{grid}\PYG{p}{.}\PYG{n}{GetRows}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}\PYG{n}{j}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{k}{if}\PYG{p}{(}\PYG{n}{samplegrid}\PYG{p}{.}\PYG{n}{getVal}\PYG{p}{(}\PYG{n}{i}\PYG{p}{,}\PYG{n}{j}\PYG{p}{)}\PYG{p}{)}
                \PYG{p}{\PYGZob{}}
                    \PYG{n}{added\PYGZus{}active} \PYG{o}{+}\PYG{o}{=} \PYG{p}{(}\PYG{k+kt}{long}\PYG{p}{(}\PYG{n}{forestmap}\PYG{p}{.}\PYG{n}{getVal}\PYG{p}{(}\PYG{n}{i}\PYG{p}{,}\PYG{n}{j}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{n}{generationin}\PYG{p}{)}\PYG{p}{)} \PYG{o}{\PYGZhy{}} \PYG{n}{grid}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getListsize}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
                \PYG{p}{\PYGZcb{}}
            \PYG{p}{\PYGZcb{}}
        \PYG{p}{\PYGZcb{}}
\PYG{c+c1}{//      cout \PYGZlt{}\PYGZlt{} \PYGZdq{}added\PYGZus{}data: \PYGZdq{} \PYGZlt{}\PYGZlt{} added\PYGZus{}data \PYGZlt{}\PYGZlt{} endl;}
\PYG{c+c1}{//      cout \PYGZlt{}\PYGZlt{} \PYGZdq{}added\PYGZus{}active: \PYGZdq{} \PYGZlt{}\PYGZlt{} added\PYGZus{}active \PYGZlt{}\PYGZlt{} endl;}
        \PYG{n}{added\PYGZus{}data} \PYG{o}{=} \PYG{n}{added\PYGZus{}active}\PYG{p}{;}
        \PYG{c+c1}{// count all the tips}
        \PYG{k}{for}\PYG{p}{(} \PYG{k+kt}{unsigned} \PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{enddata}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{k}{if}\PYG{p}{(}\PYG{n}{samplegrid}\PYG{p}{.}\PYG{n}{getVal}\PYG{p}{(}\PYG{n}{data}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getXpos}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{n}{data}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getYpos}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{n}{data}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getXwrap}\PYG{p}{(}\PYG{p}{)} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{0} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{n}{data}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getYwrap}\PYG{p}{(}\PYG{p}{)} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{c+c1}{// if the lineage isn\PYGZsq{}t yet a tip, we can just make it a tip.}
                \PYG{k}{if}\PYG{p}{(}\PYG{n}{data}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{isTip}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
                \PYG{p}{\PYGZob{}}
                    \PYG{n}{added\PYGZus{}data} \PYG{o}{+}\PYG{o}{+}\PYG{p}{;}
                \PYG{p}{\PYGZcb{}}
            \PYG{p}{\PYGZcb{}}
        \PYG{p}{\PYGZcb{}}
\PYG{c+c1}{//      cout \PYGZlt{}\PYGZlt{} \PYGZdq{}added\PYGZus{}data: \PYGZdq{} \PYGZlt{}\PYGZlt{} added\PYGZus{}data \PYGZlt{}\PYGZlt{} endl;}
\PYG{c+c1}{//      cout \PYGZlt{}\PYGZlt{} \PYGZdq{}added\PYGZus{}active: \PYGZdq{} \PYGZlt{}\PYGZlt{} added\PYGZus{}active \PYGZlt{}\PYGZlt{} endl;}
        \PYG{c+c1}{// now resize data and active if necessary}
        \PYG{n}{checkSimSize}\PYG{p}{(}\PYG{n}{added\PYGZus{}data}\PYG{p}{,} \PYG{n}{added\PYGZus{}active}\PYG{p}{)}\PYG{p}{;}
        \PYG{c+c1}{// set the lineages that currently exist within sample area to a tip}
        \PYG{k}{for}\PYG{p}{(} \PYG{k+kt}{unsigned} \PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{endactive}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
\PYG{c+c1}{//          if(samplegrid.getVal(data[active[i].getMpos()].getXpos(), data[active[i].getMpos()].getYpos()) \PYGZam{}\PYGZam{} data[active[i].getMpos()].getXwrap() == 0 \PYGZam{}\PYGZam{} data[active[i].getMpos()].getYwrap() == 0)}
            \PYG{c+c1}{// TEST new method}
            \PYG{k}{if}\PYG{p}{(}\PYG{n}{samplegrid}\PYG{p}{.}\PYG{n}{getVal}\PYG{p}{(}\PYG{n}{active}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getXpos}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{n}{active}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getYpos}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{n}{active}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getXwrap}\PYG{p}{(}\PYG{p}{)} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{0} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{n}{active}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getYwrap}\PYG{p}{(}\PYG{p}{)} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{c+c1}{// if the lineage isn\PYGZsq{}t yet a tip, we can just make it a tip.}
                \PYG{k}{if}\PYG{p}{(}\PYG{o}{!}\PYG{n}{data}\PYG{p}{[}\PYG{n}{active}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getMpos}\PYG{p}{(}\PYG{p}{)}\PYG{p}{]}\PYG{p}{.}\PYG{n}{isTip}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
                \PYG{p}{\PYGZob{}}
                    \PYG{n}{data}\PYG{p}{[}\PYG{n}{active}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getMpos}\PYG{p}{(}\PYG{p}{)}\PYG{p}{]}\PYG{p}{.}\PYG{n}{setGeneration}\PYG{p}{(}\PYG{n}{generationin}\PYG{p}{)}\PYG{p}{;}
                    \PYG{n}{data}\PYG{p}{[}\PYG{n}{active}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getMpos}\PYG{p}{(}\PYG{p}{)}\PYG{p}{]}\PYG{p}{.}\PYG{n}{setTip}\PYG{p}{(}\PYG{n+nb}{true}\PYG{p}{)}\PYG{p}{;}
                \PYG{p}{\PYGZcb{}}
                \PYG{c+c1}{// if the lineage is already a tip, we must create a new tip to allow for the simulation building afterwards.}
                \PYG{k}{else}
                \PYG{p}{\PYGZob{}}
                    \PYG{n}{enddata} \PYG{o}{+}\PYG{o}{+}\PYG{p}{;}
                    \PYG{c+c1}{// need to change the species list reference}
                    \PYG{k}{try}
                    \PYG{p}{\PYGZob{}}
                        \PYG{n}{grid}\PYG{p}{[}\PYG{n}{active}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getYpos}\PYG{p}{(}\PYG{p}{)}\PYG{p}{]}\PYG{p}{[}\PYG{n}{active}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getXpos}\PYG{p}{(}\PYG{p}{)}\PYG{p}{]}\PYG{p}{.}\PYG{n}{setSpecies}\PYG{p}{(}\PYG{n}{active}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getListpos}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,}\PYG{n}{i}\PYG{p}{)}\PYG{p}{;}
                    \PYG{p}{\PYGZcb{}}
                    \PYG{k}{catch}\PYG{p}{(}\PYG{n}{runtime\PYGZus{}error} \PYG{o}{\PYGZam{}}\PYG{n}{re}\PYG{p}{)}
                    \PYG{p}{\PYGZob{}}
                        \PYG{n}{cerr} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{RP\PYGZus{}01}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
                        \PYG{n}{cerr} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{re}\PYG{p}{.}\PYG{n}{what}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
                        \PYG{n}{exit}\PYG{p}{(}\PYG{n}{EXIT\PYGZus{}FAILURE}\PYG{p}{)}\PYG{p}{;}
                    \PYG{p}{\PYGZcb{}}
                    \PYG{n}{data}\PYG{p}{[}\PYG{n}{enddata}\PYG{p}{]}\PYG{p}{.}\PYG{n}{setup}\PYG{p}{(}\PYG{n+nb}{true}\PYG{p}{,}\PYG{n}{active}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getXpos}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,}\PYG{n}{active}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getYpos}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,}\PYG{n}{active}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getXwrap}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,}\PYG{n}{active}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getYwrap}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,}\PYG{n}{generationin}\PYG{p}{)}\PYG{p}{;}
                    \PYG{c+c1}{// Now link the old tip to the new tip}
                    \PYG{n}{data}\PYG{p}{[}\PYG{n}{active}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getMpos}\PYG{p}{(}\PYG{p}{)}\PYG{p}{]}\PYG{p}{.}\PYG{n}{setParent}\PYG{p}{(}\PYG{n}{enddata}\PYG{p}{)}\PYG{p}{;}
                    \PYG{n}{data}\PYG{p}{[}\PYG{n}{enddata}\PYG{p}{]}\PYG{p}{.}\PYG{n}{setIGen}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}
                    \PYG{n}{data}\PYG{p}{[}\PYG{n}{enddata}\PYG{p}{]}\PYG{p}{.}\PYG{n}{setSpec}\PYG{p}{(}\PYG{n}{NR}\PYG{p}{.}\PYG{n}{d01}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
                    \PYG{n}{active}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{setMpos}\PYG{p}{(}\PYG{n}{enddata}\PYG{p}{)}\PYG{p}{;}
            \PYG{c+c1}{//      removeOldPos(chosen);}
                \PYG{p}{\PYGZcb{}}
            \PYG{p}{\PYGZcb{}}
        \PYG{p}{\PYGZcb{}}

        \PYG{c+c1}{// add new lineages.}
        \PYG{k}{for}\PYG{p}{(} \PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}\PYG{n}{i}\PYG{o}{\PYGZlt{}} \PYG{n}{grid}\PYG{p}{.}\PYG{n}{GetCols}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}\PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
\PYG{c+c1}{//          cout \PYGZlt{}\PYGZlt{} i \PYGZlt{}\PYGZlt{} endl;}
            \PYG{k}{for}\PYG{p}{(} \PYG{k+kt}{int} \PYG{n}{j} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}\PYG{n}{j} \PYG{o}{\PYGZlt{}} \PYG{n}{grid}\PYG{p}{.}\PYG{n}{GetRows}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}\PYG{n}{j}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{k}{if}\PYG{p}{(}\PYG{n}{samplegrid}\PYG{p}{.}\PYG{n}{getVal}\PYG{p}{(}\PYG{n}{i}\PYG{p}{,}\PYG{n}{j}\PYG{p}{)}\PYG{p}{)}
                \PYG{p}{\PYGZob{}}
                    \PYG{k+kt}{unsigned} \PYG{k+kt}{short} \PYG{n}{mapcover} \PYG{o}{=} \PYG{n}{forestmap}\PYG{p}{.}\PYG{n}{getVal}\PYG{p}{(}\PYG{n}{i}\PYG{p}{,}\PYG{n}{j}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{n}{generationin}\PYG{p}{)} \PYG{o}{*} \PYG{n}{deme\PYGZus{}sample}\PYG{p}{;}
                    \PYG{k+kt}{int} \PYG{n}{num\PYGZus{}to\PYGZus{}add} \PYG{o}{=} \PYG{n}{mapcover} \PYG{o}{\PYGZhy{}} \PYG{n}{grid}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getListsize}\PYG{p}{(}\PYG{p}{)} \PYG{p}{;}
                    \PYG{k}{if}\PYG{p}{(}\PYG{n}{num\PYGZus{}to\PYGZus{}add} \PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{0}\PYG{p}{)}
                    \PYG{p}{\PYGZob{}}
                        \PYG{k}{if}\PYG{p}{(}\PYG{n}{mapcover} \PYG{o}{\PYGZgt{}}\PYG{o}{=} \PYG{n}{grid}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getMaxsize}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
                        \PYG{p}{\PYGZob{}}
                            \PYG{n}{grid}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{changePercentCover}\PYG{p}{(}\PYG{n}{mapcover}\PYG{p}{)}\PYG{p}{;}
                        \PYG{p}{\PYGZcb{}}
                        \PYG{k}{if}\PYG{p}{(} \PYG{n}{num\PYGZus{}to\PYGZus{}add} \PYG{o}{+} \PYG{n}{grid}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getListsize}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZgt{}} \PYG{n}{mapcover}\PYG{p}{)}
                        \PYG{p}{\PYGZob{}}
                            \PYG{k}{throw} \PYG{n}{Fatal\PYGZus{}Exception}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Shouldn\PYGZsq{}t add more than the mapcover.}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
                        \PYG{p}{\PYGZcb{}}
                        \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{k} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{k} \PYG{o}{\PYGZlt{}} \PYG{n}{num\PYGZus{}to\PYGZus{}add}\PYG{p}{;} \PYG{n}{k}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
                        \PYG{p}{\PYGZob{}}
                            \PYG{n}{endactive} \PYG{o}{+}\PYG{o}{+}\PYG{p}{;}
                            \PYG{n}{enddata} \PYG{o}{+}\PYG{o}{+}\PYG{p}{;}
                            \PYG{k+kt}{int} \PYG{n}{listpos} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
                            \PYG{k}{try}
                            \PYG{p}{\PYGZob{}}
                                \PYG{n}{listpos} \PYG{o}{=} \PYG{n}{grid}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{addSpecies}\PYG{p}{(}\PYG{n}{endactive}\PYG{p}{)}\PYG{p}{;}
                            \PYG{p}{\PYGZcb{}}
                            \PYG{k}{catch}\PYG{p}{(}\PYG{n}{out\PYGZus{}of\PYGZus{}range} \PYG{o}{\PYGZam{}} \PYG{n}{oor}\PYG{p}{)}
                            \PYG{p}{\PYGZob{}}
                                \PYG{n}{cerr} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{k: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{k} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
                                \PYG{n}{cerr} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{num\PYGZus{}to\PYGZus{}add: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{num\PYGZus{}to\PYGZus{}add} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{n}{endl}\PYG{p}{;}
                                \PYG{n}{cerr} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{mapcover: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{mapcover} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
                                \PYG{n}{cerr} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{maxsize: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{grid}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getMaxsize}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
                                \PYG{n}{cerr} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{listsize: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{grid}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getListsize}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
                                \PYG{n}{cerr} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{oor}\PYG{p}{.}\PYG{n}{what}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
                                \PYG{n}{exit}\PYG{p}{(}\PYG{n}{EXIT\PYGZus{}FAILURE}\PYG{p}{)}\PYG{p}{;}
                            \PYG{p}{\PYGZcb{}}
                            \PYG{c+c1}{// Add the species to active}
                            \PYG{n}{active}\PYG{p}{[}\PYG{n}{endactive}\PYG{p}{]}\PYG{p}{.}\PYG{n}{setup}\PYG{p}{(}\PYG{n}{i}\PYG{p}{,}\PYG{n}{j}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{n}{enddata}\PYG{p}{,}\PYG{n}{listpos}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
                            \PYG{c+c1}{// Add a tip in the Treenode for calculation of the coalescence tree at the end of the simulation.}
                            \PYG{c+c1}{// This also contains the start x and y position of the species.}
                            \PYG{n}{data}\PYG{p}{[}\PYG{n}{enddata}\PYG{p}{]}\PYG{p}{.}\PYG{n}{setup}\PYG{p}{(}\PYG{n+nb}{true}\PYG{p}{,}\PYG{n}{i}\PYG{p}{,}\PYG{n}{j}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{n}{generationin}\PYG{p}{)}\PYG{p}{;}
                            \PYG{n}{data}\PYG{p}{[}\PYG{n}{enddata}\PYG{p}{]}\PYG{p}{.}\PYG{n}{setSpec}\PYG{p}{(}\PYG{n}{NR}\PYG{p}{.}\PYG{n}{d01}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
                        \PYG{p}{\PYGZcb{}}
                    \PYG{p}{\PYGZcb{}}
                \PYG{p}{\PYGZcb{}}
            \PYG{p}{\PYGZcb{}}
        \PYG{p}{\PYGZcb{}}
        \PYG{c+c1}{// double check sizes}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{enddata} \PYG{o}{\PYGZgt{}} \PYG{n}{data}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\textbar{}}\PYG{o}{\textbar{}} \PYG{n}{endactive} \PYG{o}{\PYGZgt{}} \PYG{n}{active}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{cerr} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Enddata: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{enddata} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
            \PYG{n}{cerr} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{data.size : }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{data}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
            \PYG{n}{cerr} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Endactive: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endactive} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
            \PYG{n}{cerr} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{active.size: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{active}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
            \PYG{k}{throw} \PYG{n+nf}{Fatal\PYGZus{}Exception}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ERROR\PYGZus{}MAIN\PYGZus{}012: FATAL. Enddata or endactive is greater than the size of the relevant object. Programming error likely.}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{endactive} \PYG{o}{\PYGZgt{}} \PYG{n}{startendactive}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{startendactive} \PYG{o}{=} \PYG{n}{endactive}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
    \PYG{p}{\PYGZcb{}}

    \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{sortData}\PYG{p}{(}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{c+c1}{// Sort and process the species list so that the useful information can be extracted from it.}
        \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Finalising data...}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{flush}\PYG{p}{;}
        \PYG{c+c1}{// coalescence finished \PYGZhy{} process speciation}
        \PYG{c+c1}{// check the data structure}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{enddata} \PYG{o}{\PYGZgt{}}\PYG{n}{data}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{cerr} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{enddata: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{enddata} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
            \PYG{n}{cerr} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{data.size(): }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{data}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
            \PYG{k}{throw} \PYG{n+nf}{Fatal\PYGZus{}Exception}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Enddata greater than data size. Programming error likely.}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
         \PYG{c+c1}{// Now make sure those left in endactive will definitely speciate.}
        \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{int} \PYG{n}{i}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;}\PYG{n}{i}\PYG{o}{\PYGZlt{}}\PYG{o}{=}\PYG{n}{endactive}\PYG{p}{;}\PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{c+c1}{// check}
            \PYG{n}{data}\PYG{p}{[}\PYG{n}{active}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getMpos}\PYG{p}{(}\PYG{p}{)}\PYG{p}{]}\PYG{p}{.}\PYG{n}{setSpec}\PYG{p}{(}\PYG{l+m+mf}{0.0}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{c+c1}{// Double check speciation events have been counted.}
        \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{spec\PYGZus{}up\PYGZus{}to} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
        \PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{n}{enddata}\PYG{p}{;}\PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{k}{if}\PYG{p}{(}\PYG{n}{checkSpeciation}\PYG{p}{(}\PYG{n}{data}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getSpecRate}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{n}{spec}\PYG{p}{,} \PYG{n}{data}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getGenRate}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{n}{spec\PYGZus{}up\PYGZus{}to} \PYG{o}{+}\PYG{o}{+}\PYG{p}{;}
                \PYG{n}{data}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{speciate}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
        \PYG{p}{\PYGZcb{}}
        \PYG{c+c1}{//cout \PYGZlt{}\PYGZlt{} \PYGZdq{}Precount1: \PYGZdq{} \PYGZlt{}\PYGZlt{} lineages.countSpecies() \PYGZlt{}\PYGZlt{} endl;}
        \PYG{c+c1}{//lineages.resetTree();}
        \PYG{c+c1}{// Calculates the lineage data for the minimum speciation rate. // removed this process as output data is not required to be as a calculated tree.}
        \PYG{c+c1}{//unsigned long spec\PYGZus{}up\PYGZus{}to = 1;}
        \PYG{c+c1}{// disabled checks...}
        \PYG{c+c1}{// here we check the data is valid \PYGZhy{} only required for debugging}
        \PYG{k}{try}
        \PYG{p}{\PYGZob{}}
            \PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{1} \PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{n}{enddata} \PYG{p}{;} \PYG{n}{i} \PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{k}{if} \PYG{p}{(}\PYG{p}{(}\PYG{o}{!}\PYG{p}{(}\PYG{n}{data}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{hasSpeciated}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}\PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}}\PYG{p}{(}\PYG{n}{data}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getParent}\PYG{p}{(}\PYG{p}{)}\PYG{o}{=}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}}\PYG{n}{data}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getExistance}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
                \PYG{p}{\PYGZob{}}
                    \PYG{k}{throw} \PYG{n}{Main\PYGZus{}Exception}\PYG{p}{(}\PYG{n}{string}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ERROR\PYGZus{}MAIN\PYGZus{}004: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{+}\PYG{n}{to\PYGZus{}string}\PYG{p}{(}\PYG{p}{(}\PYG{k+kt}{long} \PYG{k+kt}{long}\PYG{p}{)}\PYG{n}{i}\PYG{p}{)} \PYG{o}{+}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ has not speciated and parent is 0.}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
                \PYG{p}{\PYGZcb{}}
                \PYG{k}{if}\PYG{p}{(}\PYG{n}{data}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{isTip}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{o}{!}\PYG{n}{samplegrid}\PYG{p}{.}\PYG{n}{getVal}\PYG{p}{(}\PYG{n}{data}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getXpos}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,}\PYG{n}{data}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getYpos}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
                \PYG{p}{\PYGZob{}}
                    \PYG{n}{cerr} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ERROR\PYGZus{}MAIN\PYGZus{}014: Tip assignment error. Samplemask is not correctly assigning tips. Check samplemask programming.}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{n}{endl}\PYG{p}{;}
                \PYG{p}{\PYGZcb{}}
            \PYG{p}{\PYGZcb{}}

            \PYG{c+c1}{// here we check the data is valid \PYGZhy{} alternative validity check.}
            \PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{1} \PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{n}{enddata} \PYG{p}{;} \PYG{n}{i} \PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{k}{if} \PYG{p}{(}\PYG{o}{!}\PYG{p}{(}\PYG{n}{data}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{hasSpeciated}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}}\PYG{n}{data}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getExistance}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
                \PYG{p}{\PYGZob{}}
                    \PYG{k+kt}{long} \PYG{n}{j} \PYG{o}{=} \PYG{n}{i}\PYG{p}{;}
                    \PYG{k}{while} \PYG{p}{(}\PYG{o}{!}\PYG{p}{(}\PYG{n}{data}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{p}{.}\PYG{n}{hasSpeciated}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
                    \PYG{p}{\PYGZob{}}
                        \PYG{n}{j} \PYG{o}{=} \PYG{n}{data}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getParent}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
                        \PYG{k}{if} \PYG{p}{(}\PYG{n}{j} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)}
                        \PYG{p}{\PYGZob{}}
                            \PYG{k}{throw} \PYG{n}{Main\PYGZus{}Exception}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ERROR\PYGZus{}MAIN\PYGZus{}005:0 found in parent while following speciation trail.}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
                            \PYG{c+c1}{//string james;}
                            \PYG{c+c1}{//cin \PYGZgt{}\PYGZgt{} james;}
                        \PYG{p}{\PYGZcb{}}
                    \PYG{p}{\PYGZcb{}}
                \PYG{p}{\PYGZcb{}}
            \PYG{p}{\PYGZcb{}}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{catch}\PYG{p}{(}\PYG{n}{Main\PYGZus{}Exception}\PYG{o}{\PYGZam{}} \PYG{n}{me}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{cerr} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{me}\PYG{p}{.}\PYG{n}{what}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
            \PYG{n}{cerr} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Returning max possible size (may cause RAM issues).}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
            \PYG{k}{return} \PYG{n}{data}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{done!}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
        \PYG{k}{return} \PYG{n}{spec\PYGZus{}up\PYGZus{}to}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{k+kt}{void} \PYG{n}{outputData}\PYG{p}{(}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{species\PYGZus{}richness} \PYG{o}{=} \PYG{n}{sortData}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{outputData}\PYG{p}{(}\PYG{n}{species\PYGZus{}richness}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{return}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{k+kt}{void} \PYG{n}{outputData}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{species\PYGZus{}richness}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{c+c1}{// Run the data sorting functions and output the data into the correct format.}
        \PYG{c+c1}{// sort the data}
\PYG{c+c1}{//          bool loopon;}
        \PYG{c+c1}{// Write the data to the first file}
        \PYG{c+c1}{// species richness data}
        \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Writing results to file...}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{flush}\PYG{p}{;}
        \PYG{n}{ofstream} \PYG{n}{out}\PYG{p}{;}
        \PYG{n}{out}\PYG{p}{.}\PYG{n}{precision}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{string} \PYG{n}{filename\PYGZus{}ab}\PYG{p}{;}
        \PYG{c+c1}{// sprintf (filename\PYGZus{}ab, \PYGZdq{}\PYGZpc{}s/Data\PYGZus{}\PYGZpc{}i.csv\PYGZdq{},outdirectory, int(the\PYGZus{}task)); // altered in v3.0}
        \PYG{n}{filename\PYGZus{}ab} \PYG{o}{=} \PYG{n}{outdirectory} \PYG{o}{+} \PYG{n}{string}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{/Data\PYGZus{}}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)} \PYG{o}{+} \PYG{n}{to\PYGZus{}string}\PYG{p}{(}\PYG{p}{(}\PYG{k+kt}{long} \PYG{k+kt}{long}\PYG{p}{)}\PYG{n}{the\PYGZus{}task}\PYG{p}{)}\PYG{o}{+}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZus{}}\PYG{l+s}{\PYGZdq{}}\PYG{o}{+}\PYG{n}{to\PYGZus{}string}\PYG{p}{(}\PYG{p}{(}\PYG{k+kt}{long} \PYG{k+kt}{long}\PYG{p}{)}\PYG{n}{the\PYGZus{}seed}\PYG{p}{)} \PYG{o}{+} \PYG{n}{string}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{.csv}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{out}\PYG{p}{.}\PYG{n}{open}\PYG{p}{(}\PYG{n}{filename\PYGZus{}ab}\PYG{p}{)}\PYG{p}{;}
        \PYG{c+c1}{// Simulation fixed variables}
        \PYG{n}{out} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{random\PYGZus{}seed=,}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{the\PYGZus{}seed} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
        \PYG{n}{out} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{fine map=,}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{finemapinput}\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
        \PYG{n}{out} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{fine map x y,}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{finemapxsize} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ \PYGZhy{} }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{finemapysize} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
        \PYG{n}{out} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{coarse map=,}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{coarsemapinput}\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
        \PYG{n}{out} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{coarse map x y,}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{coarsemapxsize}\PYG{o}{*}\PYG{n}{deme} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ \PYGZhy{} }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{coarsemapysize}\PYG{o}{*}\PYG{n}{deme} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
        \PYG{n}{out} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{deme=,}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{deme} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
        \PYG{n}{out} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{deme\PYGZus{}sample=,}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{deme\PYGZus{}sample} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
        \PYG{n}{out} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{spec=,}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{spec} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
        \PYG{n}{out} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{zfat=,}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{zfat} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
        \PYG{n}{out} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{maxtime=,}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{maxtime} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
        \PYG{n}{out} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{species\PYGZus{}richness=,}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{species\PYGZus{}richness} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
        \PYG{n}{out}\PYG{p}{.}\PYG{n}{close}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

        \PYG{c+c1}{// now we sort the map output and store to another file}
        \PYG{c+c1}{// removed the sparse output format \PYGZhy{} v3.0}
         \PYG{c+c1}{// this bit is now uneccessary and has been removed.}
        \PYG{c+cm}{/*}
\PYG{c+cm}{        if(false)}
\PYG{c+cm}{        \PYGZob{}}
\PYG{c+cm}{            // output data as matrix}
\PYG{c+cm}{            string filename\PYGZus{}map;}
\PYG{c+cm}{//              char filename\PYGZus{}map[100];}
\PYG{c+cm}{//              sprintf (filename\PYGZus{}ab, \PYGZdq{}\PYGZpc{}s/Map\PYGZus{}dense\PYGZpc{}i.csv\PYGZdq{},outdirectory, int(the\PYGZus{}task));}
\PYG{c+cm}{            filename\PYGZus{}map = outdirectory + string(\PYGZdq{}/Map\PYGZus{}dense\PYGZdq{}) + to\PYGZus{}string(the\PYGZus{}task)+\PYGZdq{}\PYGZus{}\PYGZdq{}+to\PYGZus{}string(the\PYGZus{}seed) + string(\PYGZdq{}.csv\PYGZdq{});}

\PYG{c+cm}{            out.open(filename\PYGZus{}map);}

\PYG{c+cm}{            Matrix\PYGZlt{}unsigned short\PYGZgt{} toret;}
\PYG{c+cm}{            toret.SetSize(finemapysize,finemapxsize);}
\PYG{c+cm}{            for (long i = 0 ; i \PYGZlt{} finemapysize; i ++)}
\PYG{c+cm}{            \PYGZob{}}
\PYG{c+cm}{                for (long j = 0 ; j \PYGZlt{} finemapxsize; j ++)}
\PYG{c+cm}{                \PYGZob{}}
\PYG{c+cm}{                    toret[i][j] = 0;}
\PYG{c+cm}{                \PYGZcb{}}
\PYG{c+cm}{            \PYGZcb{}}

\PYG{c+cm}{            for (unsigned long i = 1 ; i \PYGZlt{}= enddata ; i ++)}
\PYG{c+cm}{            \PYGZob{}}
\PYG{c+cm}{                if (data[i].isTip())}
\PYG{c+cm}{                \PYGZob{}}
\PYG{c+cm}{                    // Write data to a toret object.}
\PYG{c+cm}{                    toret[data[i].getYpos()][data[i].getXpos()]++;}

\PYG{c+cm}{                \PYGZcb{}}
\PYG{c+cm}{            \PYGZcb{}}
\PYG{c+cm}{            // Write toret object to a file.}
\PYG{c+cm}{            out \PYGZlt{}\PYGZlt{} toret \PYGZlt{}\PYGZlt{} \PYGZdq{}\PYGZbs{}n\PYGZdq{};}
\PYG{c+cm}{            out.close();}
\PYG{c+cm}{        \PYGZcb{}}
\PYG{c+cm}{        //*/}
        \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{done!              }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
        \PYG{n}{time}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{out\PYGZus{}finish}\PYG{p}{)}\PYG{p}{;}
        \PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifdef sql\PYGZus{}ram}
        \PYG{n}{sqlOutput}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
        \PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif}
        \PYG{n}{time}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{sim\PYGZus{}end}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{writeTimes}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{k+kt}{void} \PYG{n}{writeTimes}\PYG{p}{(}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Total generations simulated (steps): }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{generation} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ (}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{steps} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{)}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{n}{endl}\PYG{p}{;}
        \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Setup time was }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{floor}\PYG{p}{(}\PYG{p}{(}\PYG{n}{sim\PYGZus{}start} \PYG{o}{\PYGZhy{}} \PYG{n}{start}\PYG{p}{)}\PYG{o}{/}\PYG{l+m+mi}{60}\PYG{p}{)}\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ minutes }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{p}{(}\PYG{n}{sim\PYGZus{}start}\PYG{o}{\PYGZhy{}}\PYG{n}{start}\PYG{p}{)}\PYG{o}{\PYGZpc{}}\PYG{l+m+mi}{60}\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ seconds}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
        \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Simulation time was }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{n}{floor}\PYG{p}{(}\PYG{p}{(}\PYG{n}{sim\PYGZus{}finish} \PYG{o}{\PYGZhy{}} \PYG{n}{sim\PYGZus{}start}\PYG{p}{)}\PYG{o}{/}\PYG{l+m+mi}{3600}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ hours }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{p}{(}\PYG{n}{floor}\PYG{p}{(}\PYG{p}{(}\PYG{n}{sim\PYGZus{}finish} \PYG{o}{\PYGZhy{}} \PYG{n}{sim\PYGZus{}start}\PYG{p}{)}\PYG{o}{/}\PYG{l+m+mi}{60}\PYG{p}{)}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{60}\PYG{o}{*}\PYG{n}{floor}\PYG{p}{(}\PYG{p}{(}\PYG{n}{sim\PYGZus{}finish} \PYG{o}{\PYGZhy{}} \PYG{n}{sim\PYGZus{}start}\PYG{p}{)}\PYG{o}{/}\PYG{l+m+mi}{3600}\PYG{p}{)}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ minutes }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{p}{(}\PYG{n}{sim\PYGZus{}finish}\PYG{o}{\PYGZhy{}}\PYG{n}{sim\PYGZus{}start}\PYG{p}{)}\PYG{o}{\PYGZpc{}}\PYG{l+m+mi}{60}\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ seconds}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
        \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{File output and species calculation time was }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{floor}\PYG{p}{(}\PYG{p}{(}\PYG{n}{out\PYGZus{}finish} \PYG{o}{\PYGZhy{}} \PYG{n}{sim\PYGZus{}finish}\PYG{p}{)}\PYG{o}{/}\PYG{l+m+mi}{60}\PYG{p}{)}\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ minutes }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{p}{(}\PYG{n}{out\PYGZus{}finish}\PYG{o}{\PYGZhy{}}\PYG{n}{sim\PYGZus{}finish}\PYG{p}{)}\PYG{o}{\PYGZpc{}}\PYG{l+m+mi}{60}\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ seconds}\PYG{l+s}{\PYGZdq{}}\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
        \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{SQL output time was }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{floor}\PYG{p}{(}\PYG{p}{(}\PYG{n}{sim\PYGZus{}end} \PYG{o}{\PYGZhy{}} \PYG{n}{out\PYGZus{}finish}\PYG{p}{)}\PYG{o}{/}\PYG{l+m+mi}{60}\PYG{p}{)}\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ minutes }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{p}{(}\PYG{n}{sim\PYGZus{}end}\PYG{o}{\PYGZhy{}}\PYG{n}{out\PYGZus{}finish}\PYG{p}{)}\PYG{o}{\PYGZpc{}}\PYG{l+m+mi}{60}\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ seconds}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
         \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Total time taken was }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{floor}\PYG{p}{(}\PYG{p}{(}\PYG{n}{sim\PYGZus{}end} \PYG{o}{\PYGZhy{}} \PYG{n}{start}\PYG{p}{)}\PYG{o}{/}\PYG{l+m+mi}{3600}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ hours }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{p}{(}\PYG{n}{floor}\PYG{p}{(}\PYG{p}{(}\PYG{n}{sim\PYGZus{}end} \PYG{o}{\PYGZhy{}} \PYG{n}{start}\PYG{p}{)}\PYG{o}{/}\PYG{l+m+mi}{60}\PYG{p}{)}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{60}\PYG{o}{*}\PYG{n}{floor}\PYG{p}{(}\PYG{p}{(}\PYG{n}{sim\PYGZus{}end} \PYG{o}{\PYGZhy{}} \PYG{n}{start}\PYG{p}{)}\PYG{o}{/}\PYG{l+m+mi}{3600}\PYG{p}{)}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ minutes }\PYG{l+s}{\PYGZdq{}}\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{p}{(}\PYG{n}{sim\PYGZus{}end}\PYG{o}{\PYGZhy{}}\PYG{n}{start}\PYG{p}{)}\PYG{o}{\PYGZpc{}}\PYG{l+m+mi}{60}\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ seconds}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{k+kt}{void} \PYG{n}{simPause}\PYG{p}{(}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{c+c1}{// Completely changed how this sections works \PYGZhy{} it won\PYGZsq{}t currently allow restarting of the simulations, but will dump the data file to memory. \PYGZhy{} simply calls sqlCreate and sqlOutput.}
        \PYG{c+c1}{//sqlCreate();}
        \PYG{c+c1}{//sqlOutput();}

        \PYG{c+c1}{// This function saves the data to 4 files. One contains the main simulation parameters, the other 3 contain the simulation results thus far}
        \PYG{c+c1}{// including the grid object, data object and active object.}
        \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Pausing simulation...}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Saving data to temp file in }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{outdirectory} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{/Pause/ ...}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{flush}\PYG{p}{;}
        \PYG{n}{ofstream} \PYG{n}{out}\PYG{p}{;}
        \PYG{n}{out}\PYG{p}{.}\PYG{n}{precision}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{string} \PYG{n}{file\PYGZus{}to\PYGZus{}open}\PYG{p}{;}
        \PYG{c+c1}{// Create the pause directory}
        \PYG{n}{string} \PYG{n}{pause\PYGZus{}folder} \PYG{o}{=} \PYG{n}{outdirectory} \PYG{o}{+} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{/Pause/}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
        \PYG{n}{boost}\PYG{o}{:}\PYG{o}{:}\PYG{n}{filesystem}\PYG{o}{:}\PYG{o}{:}\PYG{n}{path} \PYG{n}{pause\PYGZus{}dir}\PYG{p}{(}\PYG{n}{pause\PYGZus{}folder}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{if}\PYG{p}{(}\PYG{o}{!}\PYG{n}{boost}\PYG{o}{:}\PYG{o}{:}\PYG{n}{filesystem}\PYG{o}{:}\PYG{o}{:}\PYG{n}{exists}\PYG{p}{(}\PYG{n}{pause\PYGZus{}dir}\PYG{p}{)}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{k}{try}
            \PYG{p}{\PYGZob{}}
                \PYG{n}{boost}\PYG{o}{:}\PYG{o}{:}\PYG{n}{filesystem}\PYG{o}{:}\PYG{o}{:}\PYG{n}{create\PYGZus{}directory}\PYG{p}{(}\PYG{n}{pause\PYGZus{}dir}\PYG{p}{)}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
            \PYG{k}{catch}\PYG{p}{(}\PYG{n}{exception} \PYG{o}{\PYGZam{}}\PYG{n}{e}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{n}{cerr} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Failure to create }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{outdirectory} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{/Pause/}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{.}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
                \PYG{n}{cerr} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{e}\PYG{p}{.}\PYG{n}{what}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
                \PYG{n}{cerr} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Writing directly to output directory.}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
                \PYG{n}{pause\PYGZus{}folder} \PYG{o}{=} \PYG{n}{outdirectory}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{try}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{file\PYGZus{}to\PYGZus{}open} \PYG{o}{=} \PYG{n}{pause\PYGZus{}folder} \PYG{o}{+} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Dump\PYGZus{}main\PYGZus{}}\PYG{l+s}{\PYGZdq{}} \PYG{o}{+} \PYG{n}{to\PYGZus{}string}\PYG{p}{(}\PYG{n}{the\PYGZus{}task}\PYG{p}{)} \PYG{o}{+} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZus{}}\PYG{l+s}{\PYGZdq{}} \PYG{o}{+} \PYG{n}{to\PYGZus{}string}\PYG{p}{(}\PYG{n}{the\PYGZus{}seed}\PYG{p}{)} \PYG{o}{+} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{.csv}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
            \PYG{n}{out}\PYG{p}{.}\PYG{n}{open}\PYG{p}{(}\PYG{n}{file\PYGZus{}to\PYGZus{}open}\PYG{p}{.}\PYG{n}{c\PYGZus{}str}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
            \PYG{c+c1}{// Saving the initial data to one file.}
            \PYG{n}{out} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{enddata} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{seeded}  \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{the\PYGZus{}seed}  \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{the\PYGZus{}task}  \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{autocorrel\PYGZus{}file} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{bAutocorrel}  \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{bSpec}  \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
            \PYG{n}{out} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{finemapinput} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{coarsemapinput} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{n}{outdirectory} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{pristinefinemapinput} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{pristinecoarsemapinput} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
            \PYG{n}{out} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{dPristine} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{dForestTransform} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{gridxsize} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{gridysize} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{finemapxsize} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{finemapysize} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
            \PYG{n}{out} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{finemapxoffset} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{finemapyoffset} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{coarsemapxsize} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{coarsemapysize} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{coarsemapxoffset} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
            \PYG{n}{out} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{coarsemapyoffset} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{coarsemapscale} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{varimport} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{start} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{sim\PYGZus{}start} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{sim\PYGZus{}end} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{now} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
            \PYG{n}{out} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{tCheckSpec} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{sim\PYGZus{}finish} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{out\PYGZus{}finish} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endactive} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{startendactive} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{maxsimsize} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{steps} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
            \PYG{n}{out} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{generation} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{zfat} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{dLvalue} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{maxtime} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{deme\PYGZus{}sample} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{spec} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{lambda} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{deme} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
            \PYG{n}{out} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{desired\PYGZus{}specnum} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{sqloutname} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{NR} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{mapvarsin}\PYG{p}{;}
            \PYG{n}{out}\PYG{p}{.}\PYG{n}{close}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{catch}\PYG{p}{(}\PYG{n}{exception} \PYG{o}{\PYGZam{}}\PYG{n}{e}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{cerr} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{e}\PYG{p}{.}\PYG{n}{what}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
            \PYG{n}{cerr} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Failed to perform main dump to }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{pause\PYGZus{}folder} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{try}
        \PYG{p}{\PYGZob{}}
            \PYG{c+c1}{// Saving the larger data in single files for simpler reading in.}
            \PYG{c+c1}{// Output the grid object}
            \PYG{n}{ofstream} \PYG{n}{out2}\PYG{p}{;}
            \PYG{n}{file\PYGZus{}to\PYGZus{}open} \PYG{o}{=} \PYG{n}{pause\PYGZus{}folder} \PYG{o}{+} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Dump\PYGZus{}grid\PYGZus{}}\PYG{l+s}{\PYGZdq{}} \PYG{o}{+} \PYG{n}{to\PYGZus{}string}\PYG{p}{(}\PYG{n}{the\PYGZus{}task}\PYG{p}{)} \PYG{o}{+} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZus{}}\PYG{l+s}{\PYGZdq{}} \PYG{o}{+} \PYG{n}{to\PYGZus{}string}\PYG{p}{(}\PYG{n}{the\PYGZus{}seed}\PYG{p}{)} \PYG{o}{+} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{.csv}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
            \PYG{n}{out2}\PYG{p}{.}\PYG{n}{precision}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{;}
            \PYG{n}{out2}\PYG{p}{.}\PYG{n}{open}\PYG{p}{(}\PYG{n}{file\PYGZus{}to\PYGZus{}open}\PYG{p}{.}\PYG{n}{c\PYGZus{}str}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
            \PYG{n}{out2} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{grid}\PYG{p}{;}
            \PYG{n}{out2}\PYG{p}{.}\PYG{n}{close}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{catch}\PYG{p}{(}\PYG{n}{exception} \PYG{o}{\PYGZam{}}\PYG{n}{e}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{cerr} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{e}\PYG{p}{.}\PYG{n}{what}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
            \PYG{n}{cerr} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Failed to perform grid dump to }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{pause\PYGZus{}folder} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{try}
        \PYG{p}{\PYGZob{}}
            \PYG{c+c1}{// Output the active object}
            \PYG{n}{ofstream} \PYG{n}{out3}\PYG{p}{;}
            \PYG{n}{file\PYGZus{}to\PYGZus{}open} \PYG{o}{=} \PYG{n}{pause\PYGZus{}folder} \PYG{o}{+} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Dump\PYGZus{}active\PYGZus{}}\PYG{l+s}{\PYGZdq{}} \PYG{o}{+} \PYG{n}{to\PYGZus{}string}\PYG{p}{(}\PYG{n}{the\PYGZus{}task}\PYG{p}{)} \PYG{o}{+} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZus{}}\PYG{l+s}{\PYGZdq{}} \PYG{o}{+} \PYG{n}{to\PYGZus{}string}\PYG{p}{(}\PYG{n}{the\PYGZus{}seed}\PYG{p}{)} \PYG{o}{+} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{.csv}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
            \PYG{n}{out3}\PYG{p}{.}\PYG{n}{precision}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{;}
            \PYG{n}{out3}\PYG{p}{.}\PYG{n}{open}\PYG{p}{(}\PYG{n}{file\PYGZus{}to\PYGZus{}open}\PYG{p}{.}\PYG{n}{c\PYGZus{}str}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
            \PYG{n}{out3} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{active}\PYG{p}{;}
            \PYG{n}{out3}\PYG{p}{.}\PYG{n}{close}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{catch}\PYG{p}{(}\PYG{n}{exception} \PYG{o}{\PYGZam{}}\PYG{n}{e}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{cerr} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{e}\PYG{p}{.}\PYG{n}{what}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
            \PYG{n}{cerr} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Failed to perform active dump to }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{pause\PYGZus{}folder} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{try}
        \PYG{p}{\PYGZob{}}
        \PYG{c+c1}{// Output the data object}
            \PYG{n}{ofstream} \PYG{n}{out4}\PYG{p}{;}
            \PYG{n}{file\PYGZus{}to\PYGZus{}open} \PYG{o}{=} \PYG{n}{pause\PYGZus{}folder} \PYG{o}{+} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Dump\PYGZus{}data\PYGZus{}}\PYG{l+s}{\PYGZdq{}} \PYG{o}{+} \PYG{n}{to\PYGZus{}string}\PYG{p}{(}\PYG{n}{the\PYGZus{}task}\PYG{p}{)} \PYG{o}{+} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZus{}}\PYG{l+s}{\PYGZdq{}} \PYG{o}{+} \PYG{n}{to\PYGZus{}string}\PYG{p}{(}\PYG{n}{the\PYGZus{}seed}\PYG{p}{)} \PYG{o}{+} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{.csv}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
            \PYG{n}{out4}\PYG{p}{.}\PYG{n}{precision}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{;}
            \PYG{n}{out4}\PYG{p}{.}\PYG{n}{open}\PYG{p}{(}\PYG{n}{file\PYGZus{}to\PYGZus{}open}\PYG{p}{.}\PYG{n}{c\PYGZus{}str}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
            \PYG{n}{out4} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{data}\PYG{p}{;}
            \PYG{n}{out4}\PYG{p}{.}\PYG{n}{close}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{catch}\PYG{p}{(}\PYG{n}{exception} \PYG{o}{\PYGZam{}}\PYG{n}{e}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{cerr} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{e}\PYG{p}{.}\PYG{n}{what}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
            \PYG{n}{cerr} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Failed to perform data dump to }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{pause\PYGZus{}folder} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{try}
        \PYG{p}{\PYGZob{}}
        \PYG{c+c1}{// Output the data object}
            \PYG{n}{ofstream} \PYG{n}{out4}\PYG{p}{;}
            \PYG{n}{file\PYGZus{}to\PYGZus{}open} \PYG{o}{=} \PYG{n}{pause\PYGZus{}folder} \PYG{o}{+} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Dump\PYGZus{}map\PYGZus{}}\PYG{l+s}{\PYGZdq{}} \PYG{o}{+} \PYG{n}{to\PYGZus{}string}\PYG{p}{(}\PYG{n}{the\PYGZus{}task}\PYG{p}{)} \PYG{o}{+} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZus{}}\PYG{l+s}{\PYGZdq{}} \PYG{o}{+} \PYG{n}{to\PYGZus{}string}\PYG{p}{(}\PYG{n}{the\PYGZus{}seed}\PYG{p}{)} \PYG{o}{+} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{.csv}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
            \PYG{n}{out4}\PYG{p}{.}\PYG{n}{precision}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{;}
            \PYG{n}{out4}\PYG{p}{.}\PYG{n}{open}\PYG{p}{(}\PYG{n}{file\PYGZus{}to\PYGZus{}open}\PYG{p}{.}\PYG{n}{c\PYGZus{}str}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
            \PYG{n}{out4} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{forestmap}\PYG{p}{;}
            \PYG{n}{out4}\PYG{p}{.}\PYG{n}{close}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{catch}\PYG{p}{(}\PYG{n}{exception} \PYG{o}{\PYGZam{}}\PYG{n}{e}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{cerr} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{e}\PYG{p}{.}\PYG{n}{what}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
            \PYG{n}{cerr} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Failed to perform map dump to }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}  \PYG{n}{pause\PYGZus{}folder} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{done!}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
        \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{SQL dump started}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
        \PYG{n}{time}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{out\PYGZus{}finish}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{sqlCreate}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
        \PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifdef sql\PYGZus{}ram}
        \PYG{n}{sqlOutput}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
        \PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif}
        \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Data dump complete}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
        \PYG{n}{time}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{sim\PYGZus{}end}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{writeTimes}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{k+kt}{void} \PYG{n}{simResume}\PYG{p}{(}\PYG{k+kt}{bool} \PYG{n}{cont\PYGZus{}sim}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{c+c1}{// Only resume the simulation if there is a simulation to resume from.}
        \PYG{k}{if}\PYG{p}{(}\PYG{o}{!}\PYG{n}{cont\PYGZus{}sim}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{k}{return}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{c+c1}{// Loads the data from the files into the relevant objects.}
        \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Resuming simulation...}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Loading data from temp file...}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{flush}\PYG{p}{;}
        \PYG{n}{string} \PYG{n}{file\PYGZus{}to\PYGZus{}open}\PYG{p}{;}
        \PYG{k}{try}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}r}\PYG{l+s}{Loading data from temp file...main...}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{flush}\PYG{p}{;}
            \PYG{n}{ifstream} \PYG{n}{in1}\PYG{p}{;}
    \PYG{c+c1}{//      char file\PYGZus{}to\PYGZus{}open[100];}
    \PYG{c+c1}{//      sprintf(file\PYGZus{}to\PYGZus{}open,\PYGZdq{}\PYGZpc{}s/Pause/Data\PYGZus{}\PYGZpc{}i.csv\PYGZdq{},outdirectory,int(the\PYGZus{}task));}
            \PYG{n}{file\PYGZus{}to\PYGZus{}open} \PYG{o}{=} \PYG{n}{outdirectory} \PYG{o}{+} \PYG{n}{string}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{/Pause/Dump\PYGZus{}main\PYGZus{}}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)} \PYG{o}{+} \PYG{n}{to\PYGZus{}string}\PYG{p}{(}\PYG{n}{the\PYGZus{}task}\PYG{p}{)}\PYG{o}{+}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZus{}}\PYG{l+s}{\PYGZdq{}}\PYG{o}{+}\PYG{n}{to\PYGZus{}string}\PYG{p}{(}\PYG{n}{the\PYGZus{}seed}\PYG{p}{)} \PYG{o}{+} \PYG{n}{string}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{.csv}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
            \PYG{n}{in1}\PYG{p}{.}\PYG{n}{open}\PYG{p}{(}\PYG{n}{file\PYGZus{}to\PYGZus{}open}\PYG{p}{)}\PYG{p}{;}
            \PYG{c+c1}{// Reading the initial data}
            \PYG{n}{in1} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{enddata}  \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{seeded}   \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{the\PYGZus{}seed}   \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{the\PYGZus{}task}   \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{autocorrel\PYGZus{}file}  \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{bAutocorrel}   \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{bSpec}  \PYG{p}{;}
            \PYG{n}{in1} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{finemapinput}  \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{coarsemapinput}  \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{outdirectory}  \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{pristinefinemapinput}  \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{pristinecoarsemapinput} \PYG{p}{;}
            \PYG{n}{in1} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{dPristine}  \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{dForestTransform}  \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{gridxsize}  \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{gridysize}  \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{finemapxsize}  \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{finemapysize} \PYG{p}{;}
            \PYG{n}{in1} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{finemapxoffset}  \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{finemapyoffset}  \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{coarsemapxsize}  \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{coarsemapysize}  \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{coarsemapxoffset} \PYG{p}{;}
            \PYG{n}{in1} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{coarsemapyoffset}  \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{coarsemapscale}  \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{varimport}  \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{start}  \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{sim\PYGZus{}start}  \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{sim\PYGZus{}end}  \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{now} \PYG{p}{;}
            \PYG{n}{in1} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{tCheckSpec}  \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{sim\PYGZus{}finish}  \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{sim\PYGZus{}finish}  \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{endactive}  \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{startendactive}  \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{maxsimsize}  \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{steps} \PYG{p}{;}
            \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{tempmaxtime}\PYG{p}{;}
            \PYG{n}{in1} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{generation}  \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{zfat}  \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{dLvalue}  \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{tempmaxtime}  \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{deme\PYGZus{}sample}  \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{spec}  \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{lambda}  \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{deme} \PYG{p}{;}
            \PYG{n}{in1} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{desired\PYGZus{}specnum}  \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{sqloutname}  \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{NR} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{mapvarsin}\PYG{p}{;}
            \PYG{n}{in1}\PYG{p}{.}\PYG{n}{close}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
            \PYG{c+c1}{//cout \PYGZlt{}\PYGZlt{} \PYGZdq{}file closed\PYGZdq{} \PYGZlt{}\PYGZlt{} endl;}
            \PYG{k}{try}
            \PYG{p}{\PYGZob{}}
                \PYG{k}{if}\PYG{p}{(}\PYG{n}{autocorrel\PYGZus{}file} \PYG{o}{=}\PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{null}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}
                \PYG{p}{\PYGZob{}}
                    \PYG{k}{if}\PYG{p}{(}\PYG{n}{bAutocorrel} \PYG{o}{=}\PYG{o}{=} \PYG{n+nb}{true}\PYG{p}{)}
                    \PYG{p}{\PYGZob{}}
                        \PYG{k}{throw} \PYG{n}{runtime\PYGZus{}error}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{bAutocorrel should not be true}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
                    \PYG{p}{\PYGZcb{}}
                \PYG{p}{\PYGZcb{}}
                \PYG{k}{else}
                \PYG{p}{\PYGZob{}}
                    \PYG{k}{if}\PYG{p}{(}\PYG{n}{bAutocorrel} \PYG{o}{=}\PYG{o}{=} \PYG{n+nb}{false}\PYG{p}{)}
                    \PYG{p}{\PYGZob{}}
                        \PYG{k}{throw} \PYG{n}{runtime\PYGZus{}error}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{bAutocorrel should not be false}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
                    \PYG{p}{\PYGZcb{}}
                    \PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{n}{string}\PYG{o}{\PYGZgt{}} \PYG{n}{tmpimport}\PYG{p}{;}
                    \PYG{n}{ConfigOption} \PYG{n}{tmpconfig}\PYG{p}{;}
                    \PYG{n}{tmpconfig}\PYG{p}{.}\PYG{n}{setConfig}\PYG{p}{(}\PYG{n}{autocorrel\PYGZus{}file}\PYG{p}{,}\PYG{n+nb}{false}\PYG{p}{)}\PYG{p}{;}
                    \PYG{n}{tmpconfig}\PYG{p}{.}\PYG{n}{importConfig}\PYG{p}{(}\PYG{n}{tmpimport}\PYG{p}{)}\PYG{p}{;}
                    \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}\PYG{n}{i}\PYG{o}{\PYGZlt{}}\PYG{n}{tmpimport}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}\PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
                    \PYG{p}{\PYGZob{}}
                        \PYG{n}{autocorrel\PYGZus{}times}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{n}{stod}\PYG{p}{(}\PYG{n}{tmpimport}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
    \PYG{c+c1}{//                  cout \PYGZlt{}\PYGZlt{} \PYGZdq{}t\PYGZus{}i: \PYGZdq{} \PYGZlt{}\PYGZlt{} autocorrel\PYGZus{}times[i] \PYGZlt{}\PYGZlt{} endl;}
                    \PYG{p}{\PYGZcb{}}
                \PYG{p}{\PYGZcb{}}
            \PYG{p}{\PYGZcb{}}
            \PYG{k}{catch}\PYG{p}{(}\PYG{n}{Config\PYGZus{}Exception}\PYG{o}{\PYGZam{}} \PYG{n}{ce}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{n}{cerr} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{ce}\PYG{p}{.}\PYG{n}{what}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{catch}\PYG{p}{(}\PYG{n}{exception} \PYG{o}{\PYGZam{}}\PYG{n}{e}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{cerr} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{e}\PYG{p}{.}\PYG{n}{what}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
            \PYG{n}{cerr} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Failure to import from }\PYG{l+s}{\PYGZdq{}}  \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{file\PYGZus{}to\PYGZus{}open} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{try}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}r}\PYG{l+s}{Loading data from temp file...grid...}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{flush}\PYG{p}{;}
            \PYG{c+c1}{// Reading the larger data from individual files.}
            \PYG{c+c1}{// Input the grid object}
            \PYG{n}{ifstream} \PYG{n}{in2}\PYG{p}{;}
    \PYG{c+c1}{//      sprintf(file\PYGZus{}to\PYGZus{}open,\PYGZdq{}\PYGZpc{}s/Pause/Data\PYGZus{}\PYGZpc{}i\PYGZus{}grid.csv\PYGZdq{},outdirectory,int(the\PYGZus{}task));}
            \PYG{n}{file\PYGZus{}to\PYGZus{}open} \PYG{o}{=} \PYG{n}{outdirectory} \PYG{o}{+} \PYG{n}{string}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{/Pause/Dump\PYGZus{}grid\PYGZus{}}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)} \PYG{o}{+} \PYG{n}{to\PYGZus{}string}\PYG{p}{(}\PYG{n}{the\PYGZus{}task}\PYG{p}{)}\PYG{o}{+}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZus{}}\PYG{l+s}{\PYGZdq{}}\PYG{o}{+}\PYG{n}{to\PYGZus{}string}\PYG{p}{(}\PYG{n}{the\PYGZus{}seed}\PYG{p}{)} \PYG{o}{+} \PYG{n}{string}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{.csv}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
            \PYG{n}{in2}\PYG{p}{.}\PYG{n}{open}\PYG{p}{(}\PYG{n}{file\PYGZus{}to\PYGZus{}open}\PYG{p}{)}\PYG{p}{;}
            \PYG{c+c1}{//grid.SetSize(1,400);}
            \PYG{n}{in2} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{grid}\PYG{p}{;}
            \PYG{n}{in2}\PYG{p}{.}\PYG{n}{close}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{catch}\PYG{p}{(}\PYG{n}{exception} \PYG{o}{\PYGZam{}}\PYG{n}{e}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{cerr} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{e}\PYG{p}{.}\PYG{n}{what}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
            \PYG{n}{cerr} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Failure to import from }\PYG{l+s}{\PYGZdq{}}  \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{file\PYGZus{}to\PYGZus{}open} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{c+c1}{//cout \PYGZlt{}\PYGZlt{} grid;}
        \PYG{k}{try}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}r}\PYG{l+s}{Loading data from temp file...active...}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{flush}\PYG{p}{;}
            \PYG{c+c1}{// Input the active object}
            \PYG{n}{ifstream} \PYG{n}{in3}\PYG{p}{;}
    \PYG{c+c1}{//      sprintf(file\PYGZus{}to\PYGZus{}open,\PYGZdq{}\PYGZpc{}s/Pause/Data\PYGZus{}\PYGZpc{}i\PYGZus{}active.csv\PYGZdq{},outdirectory,int(the\PYGZus{}task));}
            \PYG{n}{file\PYGZus{}to\PYGZus{}open} \PYG{o}{=} \PYG{n}{outdirectory} \PYG{o}{+} \PYG{n}{string}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{/Pause/Dump\PYGZus{}active\PYGZus{}}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)} \PYG{o}{+} \PYG{n}{to\PYGZus{}string}\PYG{p}{(}\PYG{n}{the\PYGZus{}task}\PYG{p}{)}\PYG{o}{+}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZus{}}\PYG{l+s}{\PYGZdq{}}\PYG{o}{+}\PYG{n}{to\PYGZus{}string}\PYG{p}{(}\PYG{n}{the\PYGZus{}seed}\PYG{p}{)} \PYG{o}{+} \PYG{n}{string}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{.csv}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
            \PYG{n}{in3}\PYG{p}{.}\PYG{n}{open}\PYG{p}{(}\PYG{n}{file\PYGZus{}to\PYGZus{}open}\PYG{p}{)}\PYG{p}{;}
            \PYG{n}{in3} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{active}\PYG{p}{;}
            \PYG{n}{in3}\PYG{p}{.}\PYG{n}{close}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{catch}\PYG{p}{(}\PYG{n}{exception} \PYG{o}{\PYGZam{}}\PYG{n}{e}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{cerr} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{e}\PYG{p}{.}\PYG{n}{what}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
            \PYG{n}{cerr} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Failure to import from }\PYG{l+s}{\PYGZdq{}}  \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{file\PYGZus{}to\PYGZus{}open} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{c+c1}{// Input the data object}
        \PYG{k}{try}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}r}\PYG{l+s}{Loading data from temp file...data...}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{flush}\PYG{p}{;}
            \PYG{n}{ifstream} \PYG{n}{in4}\PYG{p}{;}
    \PYG{c+c1}{//      sprintf(file\PYGZus{}to\PYGZus{}open,\PYGZdq{}\PYGZpc{}s/Pause/Data\PYGZus{}\PYGZpc{}i\PYGZus{}data.csv\PYGZdq{},outdirectory,int(the\PYGZus{}task));}
            \PYG{n}{file\PYGZus{}to\PYGZus{}open} \PYG{o}{=} \PYG{n}{outdirectory} \PYG{o}{+} \PYG{n}{string}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{/Pause/Dump\PYGZus{}data\PYGZus{}}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)} \PYG{o}{+} \PYG{n}{to\PYGZus{}string}\PYG{p}{(}\PYG{n}{the\PYGZus{}task}\PYG{p}{)}\PYG{o}{+}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZus{}}\PYG{l+s}{\PYGZdq{}}\PYG{o}{+}\PYG{n}{to\PYGZus{}string}\PYG{p}{(}\PYG{n}{the\PYGZus{}seed}\PYG{p}{)} \PYG{o}{+} \PYG{n}{string}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{.csv}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
            \PYG{n}{in4}\PYG{p}{.}\PYG{n}{open}\PYG{p}{(}\PYG{n}{file\PYGZus{}to\PYGZus{}open}\PYG{p}{)}\PYG{p}{;}
            \PYG{n}{in4} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{data}\PYG{p}{;}
            \PYG{n}{in4}\PYG{p}{.}\PYG{n}{close}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
            \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{done!}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}

        \PYG{p}{\PYGZcb{}}
        \PYG{k}{catch}\PYG{p}{(}\PYG{n}{exception} \PYG{o}{\PYGZam{}}\PYG{n}{e}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{cerr} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{e}\PYG{p}{.}\PYG{n}{what}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
            \PYG{n}{cerr} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Failure to import from }\PYG{l+s}{\PYGZdq{}}  \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{file\PYGZus{}to\PYGZus{}open} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{c+c1}{// Input the map object}
        \PYG{k}{try}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}r}\PYG{l+s}{Loading data from temp file...map...}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{flush}\PYG{p}{;}
            \PYG{n}{ifstream} \PYG{n}{in5}\PYG{p}{;}
    \PYG{c+c1}{//      sprintf(file\PYGZus{}to\PYGZus{}open,\PYGZdq{}\PYGZpc{}s/Pause/Data\PYGZus{}\PYGZpc{}i\PYGZus{}data.csv\PYGZdq{},outdirectory,int(the\PYGZus{}task));}
            \PYG{n}{file\PYGZus{}to\PYGZus{}open} \PYG{o}{=} \PYG{n}{outdirectory} \PYG{o}{+} \PYG{n}{string}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{/Pause/Dump\PYGZus{}map\PYGZus{}}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)} \PYG{o}{+} \PYG{n}{to\PYGZus{}string}\PYG{p}{(}\PYG{n}{the\PYGZus{}task}\PYG{p}{)}\PYG{o}{+}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZus{}}\PYG{l+s}{\PYGZdq{}}\PYG{o}{+}\PYG{n}{to\PYGZus{}string}\PYG{p}{(}\PYG{n}{the\PYGZus{}seed}\PYG{p}{)} \PYG{o}{+} \PYG{n}{string}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{.csv}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
            \PYG{n}{in5}\PYG{p}{.}\PYG{n}{open}\PYG{p}{(}\PYG{n}{file\PYGZus{}to\PYGZus{}open}\PYG{p}{)}\PYG{p}{;}
            \PYG{n}{in5} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{forestmap}\PYG{p}{;}
            \PYG{n}{in5}\PYG{p}{.}\PYG{n}{close}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
            \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{done!}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}

        \PYG{p}{\PYGZcb{}}
        \PYG{k}{catch}\PYG{p}{(}\PYG{n}{exception} \PYG{o}{\PYGZam{}}\PYG{n}{e}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{cerr} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{e}\PYG{p}{.}\PYG{n}{what}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
            \PYG{n}{cerr} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Failure to import from }\PYG{l+s}{\PYGZdq{}}  \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{file\PYGZus{}to\PYGZus{}open} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}r}\PYG{l+s}{Loading data from temp file...done!}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}


    \PYG{k+kt}{void} \PYG{n}{sqlCreate}\PYG{p}{(}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{time}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{out\PYGZus{}finish}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Creating SQL database file...}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
        \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{    Checking for existing folders....}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{flush}\PYG{p}{;}
        \PYG{c+c1}{// Create the folder if it doesn\PYGZsq{}t exist}
        \PYG{n}{sqloutname} \PYG{o}{=} \PYG{n}{outdirectory}\PYG{p}{;}
        \PYG{n}{string} \PYG{n}{sqlfolder} \PYG{o}{=} \PYG{n}{outdirectory} \PYG{o}{+} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{/SQL\PYGZus{}data/}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
        \PYG{k}{try}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{boost}\PYG{o}{:}\PYG{o}{:}\PYG{n}{filesystem}\PYG{o}{:}\PYG{o}{:}\PYG{n}{path} \PYG{n}{dir}\PYG{p}{(}\PYG{n}{sqlfolder}\PYG{p}{)}\PYG{p}{;}
            \PYG{k}{if}\PYG{p}{(}\PYG{o}{!}\PYG{n}{boost}\PYG{o}{:}\PYG{o}{:}\PYG{n}{filesystem}\PYG{o}{:}\PYG{o}{:}\PYG{n}{exists}\PYG{p}{(}\PYG{n}{dir}\PYG{p}{)}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}r}\PYG{l+s}{    SQL\PYGZus{}data folder not found....creating...}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{flush}\PYG{p}{;}
                \PYG{k}{if}\PYG{p}{(}\PYG{n}{boost}\PYG{o}{:}\PYG{o}{:}\PYG{n}{filesystem}\PYG{o}{:}\PYG{o}{:}\PYG{n}{create\PYGZus{}directory}\PYG{p}{(}\PYG{n}{sqlfolder}\PYG{p}{)}\PYG{p}{)}
                \PYG{p}{\PYGZob{}}
                    \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}r}\PYG{l+s}{    SQL\PYGZus{}data folder created successfully                             }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{flush}\PYG{p}{;}
                \PYG{p}{\PYGZcb{}}
                \PYG{k}{else}
                \PYG{p}{\PYGZob{}}
                    \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}r}\PYG{l+s}{    SQL\PYGZus{}data folder not created successfully                             }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
                    \PYG{k}{throw} \PYG{n+nf}{Main\PYGZus{}Exception}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ERROR\PYGZus{}SQL\PYGZus{}012: SQL folder could not be created. Check write permissions and that the parent folder is accessible.}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
                \PYG{p}{\PYGZcb{}}
            \PYG{p}{\PYGZcb{}}
            \PYG{k}{else}
            \PYG{p}{\PYGZob{}}
                \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}r}\PYG{l+s}{    Checking for existing folders....done!        }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{flush}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
        \PYG{c+c1}{// create the empty file, deleting if it exists.}
            \PYG{n}{sqloutname} \PYG{o}{+}\PYG{o}{=} \PYG{n}{string}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{/SQL\PYGZus{}data/data\PYGZus{}}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{o}{+}\PYG{n}{to\PYGZus{}string}\PYG{p}{(}\PYG{n}{the\PYGZus{}task}\PYG{p}{)}\PYG{o}{+}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZus{}}\PYG{l+s}{\PYGZdq{}}\PYG{o}{+}\PYG{n}{to\PYGZus{}string}\PYG{p}{(}\PYG{n}{the\PYGZus{}seed}\PYG{p}{)}\PYG{o}{+}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{.db}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{catch}\PYG{p}{(}\PYG{n}{Main\PYGZus{}Exception}\PYG{o}{\PYGZam{}} \PYG{n}{me}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{cerr} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{me}\PYG{p}{.}\PYG{n}{what}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
            \PYG{n}{sqloutname} \PYG{o}{=} \PYG{n}{string}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{data\PYGZus{}}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)} \PYG{o}{+} \PYG{n}{to\PYGZus{}string}\PYG{p}{(}\PYG{n}{the\PYGZus{}task}\PYG{p}{)}\PYG{o}{+}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZus{}}\PYG{l+s}{\PYGZdq{}}\PYG{o}{+}\PYG{n}{to\PYGZus{}string}\PYG{p}{(}\PYG{n}{the\PYGZus{}seed}\PYG{p}{)}\PYG{o}{+}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{.db}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
\PYG{c+c1}{//      remove(sqloutname.c\PYGZus{}str());}
        \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}r}\PYG{l+s}{    Generating species list....              }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{flush}\PYG{p}{;}
        \PYG{c+c1}{// for outputting the full data from the simulation in to a SQL file.}
        \PYG{n}{sqlite3\PYGZus{}stmt} \PYG{o}{*} \PYG{n}{stmt}\PYG{p}{;}
        \PYG{k+kt}{char} \PYG{o}{*} \PYG{n}{sErrMsg}\PYG{p}{;}
        \PYG{k+kt}{int} \PYG{n}{rc} \PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;}
        \PYG{c+c1}{// Open a SQL database in memory. This will be written to disk later.}
        \PYG{c+c1}{// A check here can be done to write to disc directly instead to massively reduce RAM consumption}
        \PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifdef sql\PYGZus{}ram}
        \PYG{n}{sqlite3\PYGZus{}open}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{:memory:}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{o}{\PYGZam{}}\PYG{n}{database}\PYG{p}{)}\PYG{p}{;}
        \PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif}
        \PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifndef sql\PYGZus{}ram}
        \PYG{n}{rc} \PYG{o}{=} \PYG{n}{sqlite3\PYGZus{}open\PYGZus{}v2}\PYG{p}{(}\PYG{n}{sqloutname}\PYG{p}{.}\PYG{n}{c\PYGZus{}str}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,}\PYG{o}{\PYGZam{}}\PYG{n}{database}\PYG{p}{,}\PYG{n}{SQLITE\PYGZus{}OPEN\PYGZus{}READWRITE} \PYG{o}{\textbar{}} \PYG{n}{SQLITE\PYGZus{}OPEN\PYGZus{}CREATE}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{unix\PYGZhy{}dotfile}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}

        \PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif}
        \PYG{c+c1}{// Create the command to be executed by adding to the string.}
        \PYG{n}{string} \PYG{n}{all\PYGZus{}commands}\PYG{p}{;}
        \PYG{n}{all\PYGZus{}commands} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{CREATE TABLE SPECIES\PYGZus{}LIST (ID int PRIMARY KEY NOT NULL, unique\PYGZus{}spec INT NOT NULL, xval INT NOT NULL,}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
        \PYG{n}{all\PYGZus{}commands} \PYG{o}{+}\PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{yval INT NOT NULL, xwrap INT NOT NULL, ywrap INT NOT NULL, tip INT NOT NULL, speciated INT NOT NULL, parent INT NOT NULL,existance INT NOT NULL,randnum DOUBLE NOT NULL, gen\PYGZus{}alive INT NOT NULL,gen\PYGZus{}added DOUBLE NOT NULL);}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}

        \PYG{c+c1}{// Create the table within the SQL database}
        \PYG{n}{rc} \PYG{o}{=} \PYG{n}{sqlite3\PYGZus{}exec}\PYG{p}{(}\PYG{n}{database}\PYG{p}{,}\PYG{n}{all\PYGZus{}commands}\PYG{p}{.}\PYG{n}{c\PYGZus{}str}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,}\PYG{n+nb}{NULL}\PYG{p}{,}\PYG{n+nb}{NULL}\PYG{p}{,}\PYG{o}{\PYGZam{}}\PYG{n}{sErrMsg}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{rc}\PYG{o}{!}\PYG{o}{=}\PYG{n}{SQLITE\PYGZus{}OK}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifndef sql\PYGZus{}ram}
            \PYG{n}{sqlite3\PYGZus{}close}\PYG{p}{(}\PYG{n}{database}\PYG{p}{)}\PYG{p}{;}
\PYG{c+c1}{//          cerr \PYGZlt{}\PYGZlt{} \PYGZdq{}unix\PYGZhy{}dotfile not working \PYGZhy{} attempting default SQL VFS method...\PYGZdq{} \PYGZlt{}\PYGZlt{} flush;}
            \PYG{c+c1}{// delete any old database files \PYGZhy{} this is risky, but there isn\PYGZsq{}t a better way of ensuring that the file actually gets created.}
            \PYG{n}{remove}\PYG{p}{(}\PYG{n}{sqloutname}\PYG{p}{.}\PYG{n}{c\PYGZus{}str}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
            \PYG{n}{rc} \PYG{o}{=} \PYG{n}{sqlite3\PYGZus{}open}\PYG{p}{(}\PYG{n}{sqloutname}\PYG{p}{.}\PYG{n}{c\PYGZus{}str}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,}\PYG{o}{\PYGZam{}}\PYG{n}{database}\PYG{p}{)}\PYG{p}{;}
            \PYG{n}{rc} \PYG{o}{=} \PYG{n}{sqlite3\PYGZus{}exec}\PYG{p}{(}\PYG{n}{database}\PYG{p}{,}\PYG{n}{all\PYGZus{}commands}\PYG{p}{.}\PYG{n}{c\PYGZus{}str}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,}\PYG{n+nb}{NULL}\PYG{p}{,}\PYG{n+nb}{NULL}\PYG{p}{,}\PYG{o}{\PYGZam{}}\PYG{n}{sErrMsg}\PYG{p}{)}\PYG{p}{;}
            \PYG{k}{if}\PYG{p}{(} \PYG{n}{rc} \PYG{o}{=}\PYG{o}{=} \PYG{n}{SQLITE\PYGZus{}OK}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
\PYG{c+c1}{//              cerr \PYGZlt{}\PYGZlt{} \PYGZdq{}done! Default unix VFS method functional.\PYGZdq{} \PYGZlt{}\PYGZlt{} endl;}
            \PYG{p}{\PYGZcb{}}
            \PYG{k}{else}
            \PYG{p}{\PYGZob{}}
                \PYG{n}{cerr} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Database file creation failed. Check file system.}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
                \PYG{n}{cerr} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Error code: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{rc} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
                \PYG{n}{exit}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
            \PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif}
            \PYG{k}{if}\PYG{p}{(}\PYG{n}{rc}\PYG{o}{!}\PYG{o}{=}\PYG{n}{SQLITE\PYGZus{}OK}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{n}{cerr} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ERROR\PYGZus{}SQL\PYGZus{}007: Cannot generate in\PYGZhy{}memory table. Check memory database assignment and SQL commands.}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
                \PYG{n}{cerr} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Error code: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{rc} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
        \PYG{p}{\PYGZcb{}}
        \PYG{c+c1}{// Now create the prepared statement into which we shall insert the values from the table}
        \PYG{n}{all\PYGZus{}commands} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{INSERT INTO SPECIES\PYGZus{}LIST (ID,unique\PYGZus{}spec,xval,yval,xwrap,ywrap,tip,speciated,parent,existance,randnum,gen\PYGZus{}alive,gen\PYGZus{}added) VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?)}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
        \PYG{n}{sqlite3\PYGZus{}prepare\PYGZus{}v2}\PYG{p}{(}\PYG{n}{database}\PYG{p}{,}\PYG{n}{all\PYGZus{}commands}\PYG{p}{.}\PYG{n}{c\PYGZus{}str}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,}\PYG{n}{strlen}\PYG{p}{(}\PYG{n}{all\PYGZus{}commands}\PYG{p}{.}\PYG{n}{c\PYGZus{}str}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{,}\PYG{o}{\PYGZam{}}\PYG{n}{stmt}\PYG{p}{,}\PYG{n+nb}{NULL}\PYG{p}{)}\PYG{p}{;}

        \PYG{c+c1}{// Start the transaction}
        \PYG{n}{rc} \PYG{o}{=} \PYG{n}{sqlite3\PYGZus{}exec}\PYG{p}{(}\PYG{n}{database}\PYG{p}{,}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{BEGIN TRANSACTION;}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{n+nb}{NULL}\PYG{p}{,}\PYG{n+nb}{NULL}\PYG{p}{,}\PYG{o}{\PYGZam{}}\PYG{n}{sErrMsg}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{rc}\PYG{o}{!}\PYG{o}{=}\PYG{n}{SQLITE\PYGZus{}OK}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{cerr} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ERROR\PYGZus{}SQL\PYGZus{}008: Cannot start SQL transaction. Check memory database assignment and SQL commands.}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i}\PYG{o}{\PYGZlt{}}\PYG{o}{=}\PYG{n}{enddata}\PYG{p}{;}\PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{sqlite3\PYGZus{}bind\PYGZus{}int}\PYG{p}{(}\PYG{n}{stmt}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{i}\PYG{p}{)}\PYG{p}{;}
            \PYG{n}{sqlite3\PYGZus{}bind\PYGZus{}int}\PYG{p}{(}\PYG{n}{stmt}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{n}{data}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getSpeciesID}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
            \PYG{n}{sqlite3\PYGZus{}bind\PYGZus{}int}\PYG{p}{(}\PYG{n}{stmt}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{n}{data}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getXpos}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
            \PYG{n}{sqlite3\PYGZus{}bind\PYGZus{}int}\PYG{p}{(}\PYG{n}{stmt}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{n}{data}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getYpos}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
            \PYG{n}{sqlite3\PYGZus{}bind\PYGZus{}int}\PYG{p}{(}\PYG{n}{stmt}\PYG{p}{,}\PYG{l+m+mi}{5}\PYG{p}{,}\PYG{n}{data}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getXwrap}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
            \PYG{n}{sqlite3\PYGZus{}bind\PYGZus{}int}\PYG{p}{(}\PYG{n}{stmt}\PYG{p}{,}\PYG{l+m+mi}{6}\PYG{p}{,}\PYG{n}{data}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getYwrap}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
            \PYG{n}{sqlite3\PYGZus{}bind\PYGZus{}int}\PYG{p}{(}\PYG{n}{stmt}\PYG{p}{,}\PYG{l+m+mi}{7}\PYG{p}{,}\PYG{n}{data}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{isTip}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
            \PYG{n}{sqlite3\PYGZus{}bind\PYGZus{}int}\PYG{p}{(}\PYG{n}{stmt}\PYG{p}{,}\PYG{l+m+mi}{8}\PYG{p}{,}\PYG{n}{data}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{hasSpeciated}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
            \PYG{n}{sqlite3\PYGZus{}bind\PYGZus{}int}\PYG{p}{(}\PYG{n}{stmt}\PYG{p}{,}\PYG{l+m+mi}{9}\PYG{p}{,}\PYG{n}{data}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getParent}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
            \PYG{n}{sqlite3\PYGZus{}bind\PYGZus{}int}\PYG{p}{(}\PYG{n}{stmt}\PYG{p}{,}\PYG{l+m+mi}{10}\PYG{p}{,}\PYG{n}{data}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getExistance}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
            \PYG{n}{sqlite3\PYGZus{}bind\PYGZus{}double}\PYG{p}{(}\PYG{n}{stmt}\PYG{p}{,}\PYG{l+m+mi}{11}\PYG{p}{,}\PYG{n}{data}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getSpecRate}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
            \PYG{n}{sqlite3\PYGZus{}bind\PYGZus{}int}\PYG{p}{(}\PYG{n}{stmt}\PYG{p}{,}\PYG{l+m+mi}{12}\PYG{p}{,}\PYG{n}{data}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getGenRate}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
            \PYG{n}{sqlite3\PYGZus{}bind\PYGZus{}double}\PYG{p}{(}\PYG{n}{stmt}\PYG{p}{,}\PYG{l+m+mi}{13}\PYG{p}{,}\PYG{n}{data}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getGeneration}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
            \PYG{n}{sqlite3\PYGZus{}step}\PYG{p}{(}\PYG{n}{stmt}\PYG{p}{)}\PYG{p}{;}
            \PYG{n}{sqlite3\PYGZus{}clear\PYGZus{}bindings}\PYG{p}{(}\PYG{n}{stmt}\PYG{p}{)}\PYG{p}{;}
            \PYG{n}{sqlite3\PYGZus{}reset}\PYG{p}{(}\PYG{n}{stmt}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}


        \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}r}\PYG{l+s}{    Executing SQL commands....}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{flush}\PYG{p}{;}
        \PYG{c+c1}{// execute the command and close the connection to the database}
        \PYG{n}{rc} \PYG{o}{=} \PYG{n}{sqlite3\PYGZus{}exec}\PYG{p}{(}\PYG{n}{database}\PYG{p}{,}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{END TRANSACTION;}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{n+nb}{NULL}\PYG{p}{,}\PYG{n+nb}{NULL}\PYG{p}{,}\PYG{o}{\PYGZam{}}\PYG{n}{sErrMsg}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{rc}\PYG{o}{!}\PYG{o}{=}\PYG{n}{SQLITE\PYGZus{}OK}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{cerr} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ERROR\PYGZus{}SQL\PYGZus{}008: Cannot complete SQL transaction. Check memory database assignment and SQL commands. Ensure SQL statements are properly cleared.}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
            \PYG{n}{cerr} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Error code: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{rc} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
            \PYG{c+c1}{// try again}
            \PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;}
            \PYG{k}{while}\PYG{p}{(}\PYG{p}{(}\PYG{n}{rc}\PYG{o}{!}\PYG{o}{=}\PYG{n}{SQLITE\PYGZus{}OK} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{n}{rc} \PYG{o}{!}\PYG{o}{=} \PYG{n}{SQLITE\PYGZus{}DONE} \PYG{p}{)}\PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{10}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{n}{sleep}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
                \PYG{n}{i} \PYG{o}{+}\PYG{o}{+}\PYG{p}{;}
                \PYG{n}{rc} \PYG{o}{=} \PYG{n}{sqlite3\PYGZus{}exec}\PYG{p}{(}\PYG{n}{database}\PYG{p}{,}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{END TRANSACTION;}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{n+nb}{NULL}\PYG{p}{,}\PYG{n+nb}{NULL}\PYG{p}{,}\PYG{o}{\PYGZam{}}\PYG{n}{sErrMsg}\PYG{p}{)}\PYG{p}{;}
                \PYG{n}{cerr} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Attempt }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{i} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ failed...}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
                \PYG{n}{cerr} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ERROR\PYGZus{}SQL\PYGZus{}008: Cannot complete SQL transaction. Check memory database assignment and SQL commands. Ensure SQL statements are properly cleared.}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
        \PYG{p}{\PYGZcb{}}
        \PYG{c+c1}{// Need to finalise the statement}
        \PYG{n}{rc} \PYG{o}{=} \PYG{n}{sqlite3\PYGZus{}finalize}\PYG{p}{(}\PYG{n}{stmt}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{rc}\PYG{o}{!}\PYG{o}{=}\PYG{n}{SQLITE\PYGZus{}OK}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{cerr} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ERROR\PYGZus{}SQL\PYGZus{}008: Cannot complete SQL transaction. Check memory database assignment and SQL commands. Ensure SQL statements are properly cleared.}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
            \PYG{n}{cerr} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Error code: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{rc} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{c+c1}{// Vacuum the file so that the file size is reduced (reduces by around 3\PYGZpc{})}
        \PYG{n}{rc} \PYG{o}{=} \PYG{n}{sqlite3\PYGZus{}exec}\PYG{p}{(}\PYG{n}{database}\PYG{p}{,}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{VACUUM;}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{n+nb}{NULL}\PYG{p}{,}\PYG{n+nb}{NULL}\PYG{p}{,}\PYG{o}{\PYGZam{}}\PYG{n}{sErrMsg}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{rc}\PYG{o}{!}\PYG{o}{=}\PYG{n}{SQLITE\PYGZus{}OK}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{cerr} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ERROR\PYGZus{}SQL\PYGZus{}014: Cannot vacuum the database. Error message: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{sErrMsg} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}

        \PYG{c+c1}{// Now additionally store the simulation parameters (extremely useful data)}
        \PYG{n}{string} \PYG{n}{to\PYGZus{}execute} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{CREATE TABLE SIMULATION\PYGZus{}PARAMETERS (job\PYGZus{}num INT PRIMARY KEY not null, job\PYGZus{}type INT NOT NULL,}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
        \PYG{n}{to\PYGZus{}execute} \PYG{o}{+}\PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{output\PYGZus{}dir TEXT NOT NULL, spec\PYGZus{}rate DOUBLE NOT NULL, zfat DOUBLE NOT NULL,dispersal DOUBLE NOT NULL, deme INT NOT NULL, }\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
        \PYG{n}{to\PYGZus{}execute} \PYG{o}{+}\PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{sample\PYGZus{}size DOUBLE NOT NULL, max\PYGZus{}time DOUBLE NOT NULL, lambda DOUBLE NOT NULL, min\PYGZus{}num\PYGZus{}species INT NOT NULL, forest\PYGZus{}change\PYGZus{}param DOUBLE NOT NULL,}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
        \PYG{n}{to\PYGZus{}execute} \PYG{o}{+}\PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{time\PYGZus{}since\PYGZus{}pristine DOUBLE NOT NULL, time\PYGZus{}config\PYGZus{}file TEXT NOT NULL,coarse\PYGZus{}map\PYGZus{}file TEXT NOT NULL, coarse\PYGZus{}map\PYGZus{}x INT NOT NULL, coarse\PYGZus{}map\PYGZus{}y INT NOT NULL,}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
        \PYG{n}{to\PYGZus{}execute} \PYG{o}{+}\PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{coarse\PYGZus{}map\PYGZus{}x\PYGZus{}offset INT NOT NULL, coarse\PYGZus{}map\PYGZus{}y\PYGZus{}offset INT NOT NULL, coarse\PYGZus{}map\PYGZus{}scale DOUBLE NOT NULL, fine\PYGZus{}map\PYGZus{}file TEXT NOT NULL, fine\PYGZus{}map\PYGZus{}x INT NOT NULL,}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
        \PYG{n}{to\PYGZus{}execute} \PYG{o}{+}\PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{fine\PYGZus{}map\PYGZus{}y INT NOT NULL, fine\PYGZus{}map\PYGZus{}x\PYGZus{}offset INT NOT NULL, fine\PYGZus{}map\PYGZus{}y\PYGZus{}offset INT NOT NULL, grid\PYGZus{}x INT NOT NULL, grid\PYGZus{}y INT NOT NULL,}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
        \PYG{n}{to\PYGZus{}execute} \PYG{o}{+}\PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{pristine\PYGZus{}coarse\PYGZus{}map TEXT NOT NULL, pristine\PYGZus{}fine\PYGZus{}map TEXT NOT NULL);}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
        \PYG{n}{rc} \PYG{o}{=} \PYG{n}{sqlite3\PYGZus{}exec}\PYG{p}{(}\PYG{n}{database}\PYG{p}{,}\PYG{n}{to\PYGZus{}execute}\PYG{p}{.}\PYG{n}{c\PYGZus{}str}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,}\PYG{n+nb}{NULL}\PYG{p}{,}\PYG{n+nb}{NULL}\PYG{p}{,}\PYG{o}{\PYGZam{}}\PYG{n}{sErrMsg}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{rc}\PYG{o}{!}\PYG{o}{=}\PYG{n}{SQLITE\PYGZus{}OK}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{cerr} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ERROR\PYGZus{}SQL\PYGZus{}008: Cannot start SQL transaction. Check memory database assignment and SQL commands.}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
            \PYG{n}{cerr} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Error code: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{rc} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{n}{to\PYGZus{}execute} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{INSERT INTO SIMULATION\PYGZus{}PARAMETERS VALUES(}\PYG{l+s}{\PYGZdq{}} \PYG{o}{+} \PYG{n}{to\PYGZus{}string}\PYG{p}{(}\PYG{p}{(}\PYG{k+kt}{long} \PYG{k+kt}{long}\PYG{p}{)}\PYG{n}{the\PYGZus{}task}\PYG{p}{)} \PYG{o}{+} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{,}\PYG{l+s}{\PYGZdq{}} \PYG{o}{+} \PYG{n}{to\PYGZus{}string}\PYG{p}{(}\PYG{p}{(}\PYG{k+kt}{long} \PYG{k+kt}{long}\PYG{p}{)}\PYG{n}{the\PYGZus{}seed}\PYG{p}{)} \PYG{o}{+} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{,\PYGZsq{}}\PYG{l+s}{\PYGZdq{}} \PYG{o}{+} \PYG{n}{outdirectory}\PYG{o}{+} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZsq{},}\PYG{l+s}{\PYGZdq{}} \PYG{o}{+} \PYG{n}{boost}\PYG{o}{:}\PYG{o}{:}\PYG{n}{lexical\PYGZus{}cast}\PYG{o}{\PYGZlt{}}\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{string}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{p}{(}\PYG{k+kt}{long} \PYG{k+kt}{double}\PYG{p}{)} \PYG{n}{spec}\PYG{p}{)} \PYG{o}{+} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{,}\PYG{l+s}{\PYGZdq{}} \PYG{o}{+} \PYG{n}{to\PYGZus{}string}\PYG{p}{(}\PYG{p}{(}\PYG{k+kt}{long} \PYG{k+kt}{double}\PYG{p}{)}\PYG{n}{zfat}\PYG{p}{)} \PYG{o}{+} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{,}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
        \PYG{n}{to\PYGZus{}execute} \PYG{o}{+}\PYG{o}{=} \PYG{n}{to\PYGZus{}string}\PYG{p}{(}\PYG{p}{(}\PYG{k+kt}{long} \PYG{k+kt}{double}\PYG{p}{)}\PYG{n}{dLvalue}\PYG{p}{)} \PYG{o}{+} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{,}\PYG{l+s}{\PYGZdq{}} \PYG{o}{+} \PYG{n}{to\PYGZus{}string}\PYG{p}{(}\PYG{p}{(}\PYG{k+kt}{long} \PYG{k+kt}{long}\PYG{p}{)}\PYG{n}{deme}\PYG{p}{)} \PYG{o}{+} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{,}\PYG{l+s}{\PYGZdq{}} \PYG{o}{+} \PYG{n}{to\PYGZus{}string}\PYG{p}{(}\PYG{p}{(}\PYG{k+kt}{long} \PYG{k+kt}{double}\PYG{p}{)}\PYG{n}{deme\PYGZus{}sample}\PYG{p}{)} \PYG{o}{+} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{,}\PYG{l+s}{\PYGZdq{}} \PYG{o}{+} \PYG{n}{to\PYGZus{}string}\PYG{p}{(}\PYG{p}{(}\PYG{k+kt}{long} \PYG{k+kt}{double}\PYG{p}{)}\PYG{n}{maxtime}\PYG{p}{)} \PYG{o}{+} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{,}\PYG{l+s}{\PYGZdq{}} \PYG{o}{+} \PYG{n}{to\PYGZus{}string}\PYG{p}{(}\PYG{p}{(}\PYG{k+kt}{long} \PYG{k+kt}{double}\PYG{p}{)}\PYG{n}{lambda}\PYG{p}{)} \PYG{o}{+} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{,}\PYG{l+s}{\PYGZdq{}} \PYG{o}{+} \PYG{n}{to\PYGZus{}string}\PYG{p}{(}\PYG{p}{(}\PYG{k+kt}{long} \PYG{k+kt}{long}\PYG{p}{)}\PYG{n}{desired\PYGZus{}specnum}\PYG{p}{)} \PYG{o}{+} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{,}\PYG{l+s}{\PYGZdq{}} \PYG{o}{+} \PYG{n}{to\PYGZus{}string}\PYG{p}{(}\PYG{p}{(}\PYG{k+kt}{long} \PYG{k+kt}{double}\PYG{p}{)}\PYG{n}{mapvarsin}\PYG{p}{.}\PYG{n}{dForestTransform}\PYG{p}{)} \PYG{o}{+} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{,}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
        \PYG{n}{to\PYGZus{}execute} \PYG{o}{+}\PYG{o}{=} \PYG{n}{to\PYGZus{}string}\PYG{p}{(}\PYG{p}{(}\PYG{k+kt}{long} \PYG{k+kt}{double}\PYG{p}{)}\PYG{n}{mapvarsin}\PYG{p}{.}\PYG{n}{dPristine}\PYG{p}{)} \PYG{o}{+} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{,\PYGZsq{}}\PYG{l+s}{\PYGZdq{}} \PYG{o}{+} \PYG{n}{mapvarsin}\PYG{p}{.}\PYG{n}{autocorrel\PYGZus{}file} \PYG{o}{+} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZsq{},\PYGZsq{}}\PYG{l+s}{\PYGZdq{}} \PYG{o}{+} \PYG{n}{coarsemapinput} \PYG{o}{+} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZsq{},}\PYG{l+s}{\PYGZdq{}} \PYG{o}{+} \PYG{n}{to\PYGZus{}string}\PYG{p}{(}\PYG{p}{(}\PYG{k+kt}{long} \PYG{k+kt}{long}\PYG{p}{)} \PYG{n}{coarsemapxsize}\PYG{p}{)} \PYG{o}{+} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{,}\PYG{l+s}{\PYGZdq{}} \PYG{o}{+} \PYG{n}{to\PYGZus{}string}\PYG{p}{(}\PYG{p}{(}\PYG{k+kt}{long} \PYG{k+kt}{long}\PYG{p}{)}\PYG{n}{coarsemapysize}\PYG{p}{)} \PYG{o}{+} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{,}\PYG{l+s}{\PYGZdq{}} \PYG{o}{+} \PYG{n}{to\PYGZus{}string}\PYG{p}{(}\PYG{p}{(}\PYG{k+kt}{long} \PYG{k+kt}{long}\PYG{p}{)} \PYG{n}{coarsemapxoffset}\PYG{p}{)} \PYG{o}{+} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{,}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
        \PYG{n}{to\PYGZus{}execute} \PYG{o}{+}\PYG{o}{=} \PYG{n}{to\PYGZus{}string}\PYG{p}{(}\PYG{p}{(}\PYG{k+kt}{long} \PYG{k+kt}{long}\PYG{p}{)}\PYG{n}{coarsemapyoffset}\PYG{p}{)} \PYG{o}{+} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{,}\PYG{l+s}{\PYGZdq{}} \PYG{o}{+} \PYG{n}{to\PYGZus{}string}\PYG{p}{(}\PYG{p}{(}\PYG{k+kt}{long} \PYG{k+kt}{long}\PYG{p}{)}\PYG{n}{coarsemapscale}\PYG{p}{)} \PYG{o}{+} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{,\PYGZsq{}}\PYG{l+s}{\PYGZdq{}} \PYG{o}{+} \PYG{n}{finemapinput} \PYG{o}{+} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZsq{},}\PYG{l+s}{\PYGZdq{}} \PYG{o}{+}  \PYG{n}{to\PYGZus{}string}\PYG{p}{(}\PYG{p}{(}\PYG{k+kt}{long} \PYG{k+kt}{long}\PYG{p}{)}\PYG{n}{finemapxsize}\PYG{p}{)} \PYG{o}{+} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{,}\PYG{l+s}{\PYGZdq{}} \PYG{o}{+} \PYG{n}{to\PYGZus{}string}\PYG{p}{(}\PYG{p}{(}\PYG{k+kt}{long} \PYG{k+kt}{long}\PYG{p}{)}\PYG{n}{finemapysize}\PYG{p}{)} \PYG{o}{+} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{,}\PYG{l+s}{\PYGZdq{}} \PYG{o}{+}  \PYG{n}{to\PYGZus{}string}\PYG{p}{(}\PYG{p}{(}\PYG{k+kt}{long} \PYG{k+kt}{long}\PYG{p}{)}\PYG{n}{finemapxoffset}\PYG{p}{)} \PYG{o}{+} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{,}\PYG{l+s}{\PYGZdq{}} \PYG{o}{+} \PYG{n}{to\PYGZus{}string}\PYG{p}{(}\PYG{p}{(}\PYG{k+kt}{long} \PYG{k+kt}{long}\PYG{p}{)}\PYG{n}{finemapyoffset}\PYG{p}{)} \PYG{o}{+} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{,}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
        \PYG{n}{to\PYGZus{}execute} \PYG{o}{+}\PYG{o}{=} \PYG{n}{to\PYGZus{}string}\PYG{p}{(}\PYG{p}{(}\PYG{k+kt}{long} \PYG{k+kt}{long}\PYG{p}{)}\PYG{n}{gridxsize}\PYG{p}{)} \PYG{o}{+}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{,}\PYG{l+s}{\PYGZdq{}}\PYG{o}{+} \PYG{n}{to\PYGZus{}string}\PYG{p}{(}\PYG{p}{(}\PYG{k+kt}{long} \PYG{k+kt}{long}\PYG{p}{)}\PYG{n}{gridysize}\PYG{p}{)} \PYG{o}{+} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{,\PYGZsq{}}\PYG{l+s}{\PYGZdq{}} \PYG{o}{+} \PYG{n}{pristinecoarsemapinput} \PYG{o}{+} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZsq{},\PYGZsq{}}\PYG{l+s}{\PYGZdq{}} \PYG{o}{+} \PYG{n}{pristinefinemapinput} \PYG{o}{+}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZsq{});}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
        \PYG{n}{rc} \PYG{o}{=} \PYG{n}{sqlite3\PYGZus{}exec}\PYG{p}{(}\PYG{n}{database}\PYG{p}{,}\PYG{n}{to\PYGZus{}execute}\PYG{p}{.}\PYG{n}{c\PYGZus{}str}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,}\PYG{n+nb}{NULL}\PYG{p}{,}\PYG{n+nb}{NULL}\PYG{p}{,}\PYG{o}{\PYGZam{}}\PYG{n}{sErrMsg}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{rc}\PYG{o}{!}\PYG{o}{=}\PYG{n}{SQLITE\PYGZus{}OK}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{to\PYGZus{}execute} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
            \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{boost}\PYG{o}{:}\PYG{o}{:}\PYG{n}{lexical\PYGZus{}cast}\PYG{o}{\PYGZlt{}}\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{string}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{p}{(}\PYG{k+kt}{double}\PYG{p}{)} \PYG{n}{spec}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
            \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{spec} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
            \PYG{n}{cerr} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ERROR\PYGZus{}SQL\PYGZus{}008: Cannot start SQL transaction. Check memory database assignment and SQL commands.}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
            \PYG{n}{cerr} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Error code: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{rc} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{done!}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{k+kt}{void} \PYG{n}{sqlOutput}\PYG{p}{(}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifdef sql\PYGZus{}ram}
        \PYG{c+c1}{// open connection to the database file}
        \PYG{n}{remove}\PYG{p}{(}\PYG{n}{sqloutname}\PYG{p}{.}\PYG{n}{c\PYGZus{}str}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}r}\PYG{l+s}{    Writing to }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{sqloutname} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ ....     }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{flush}\PYG{p}{;}
        \PYG{k+kt}{int} \PYG{n}{rc} \PYG{o}{=} \PYG{n}{sqlite3\PYGZus{}open\PYGZus{}v2}\PYG{p}{(}\PYG{n}{sqloutname}\PYG{p}{.}\PYG{n}{c\PYGZus{}str}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,}\PYG{o}{\PYGZam{}}\PYG{n}{outdatabase}\PYG{p}{,}\PYG{n}{SQLITE\PYGZus{}OPEN\PYGZus{}READWRITE} \PYG{o}{\textbar{}} \PYG{n}{SQLITE\PYGZus{}OPEN\PYGZus{}CREATE}\PYG{p}{,}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{unix\PYGZhy{}dotfile}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{rc}\PYG{o}{!}\PYG{o}{=}\PYG{n}{SQLITE\PYGZus{}OK} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{n}{rc} \PYG{o}{!}\PYG{o}{=} \PYG{n}{SQLITE\PYGZus{}DONE}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;}
            \PYG{k}{while}\PYG{p}{(}\PYG{p}{(}\PYG{n}{rc}\PYG{o}{!}\PYG{o}{=}\PYG{n}{SQLITE\PYGZus{}OK} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{n}{rc} \PYG{o}{!}\PYG{o}{=} \PYG{n}{SQLITE\PYGZus{}DONE}\PYG{p}{)} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{10}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{;}
                \PYG{n}{sleep}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
                \PYG{n}{rc} \PYG{o}{=} \PYG{n}{sqlite3\PYGZus{}open\PYGZus{}v2}\PYG{p}{(}\PYG{n}{sqloutname}\PYG{p}{.}\PYG{n}{c\PYGZus{}str}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,}\PYG{o}{\PYGZam{}}\PYG{n}{outdatabase}\PYG{p}{,}\PYG{n}{SQLITE\PYGZus{}OPEN\PYGZus{}READWRITE} \PYG{o}{\textbar{}} \PYG{n}{SQLITE\PYGZus{}OPEN\PYGZus{}CREATE}\PYG{p}{,}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{unix\PYGZhy{}dotfile}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{c+c1}{//              cerr \PYGZlt{}\PYGZlt{} \PYGZdq{}Attempt \PYGZdq{} \PYGZlt{}\PYGZlt{} i \PYGZlt{}\PYGZlt{} \PYGZdq{} failed...\PYGZdq{} \PYGZlt{}\PYGZlt{} endl;}
            \PYG{p}{\PYGZcb{}}
            \PYG{c+c1}{// Attempt different opening method if the first fails.}
            \PYG{k+kt}{int} \PYG{n}{j} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
            \PYG{k}{while}\PYG{p}{(}\PYG{p}{(}\PYG{n}{rc}\PYG{o}{!}\PYG{o}{=}\PYG{n}{SQLITE\PYGZus{}OK} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{n}{rc} \PYG{o}{!}\PYG{o}{=} \PYG{n}{SQLITE\PYGZus{}DONE}\PYG{p}{)} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{n}{j} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{10}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{n}{j}\PYG{o}{+}\PYG{o}{+}\PYG{p}{;}
                \PYG{n}{sleep}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
                \PYG{n}{rc} \PYG{o}{=} \PYG{n}{sqlite3\PYGZus{}open}\PYG{p}{(}\PYG{n}{sqloutname}\PYG{p}{.}\PYG{n}{c\PYGZus{}str}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,}\PYG{o}{\PYGZam{}}\PYG{n}{outdatabase}\PYG{p}{)}\PYG{p}{;}
\PYG{c+c1}{//              cerr \PYGZlt{}\PYGZlt{} \PYGZdq{}Attempt \PYGZdq{} \PYGZlt{}\PYGZlt{} i \PYGZlt{}\PYGZlt{} \PYGZdq{} failed...\PYGZdq{} \PYGZlt{}\PYGZlt{} endl;}
            \PYG{p}{\PYGZcb{}}
            \PYG{k}{if}\PYG{p}{(}\PYG{n}{rc} \PYG{o}{!}\PYG{o}{=} \PYG{n}{SQLITE\PYGZus{}OK} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{n}{rc} \PYG{o}{!}\PYG{o}{=} \PYG{n}{SQLITE\PYGZus{}DONE}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{n}{cerr} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}  \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ERROR\PYGZus{}SQL\PYGZus{}010: SQLite database file could not be opened. Check the folder exists and you have write permissions. (REF1) Error code: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{rc} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
                \PYG{n}{cerr} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Attempted call }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{max}\PYG{p}{(}\PYG{n}{i}\PYG{p}{,}\PYG{n}{j}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ times}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
        \PYG{p}{\PYGZcb{}}
        \PYG{c+c1}{// create the backup object to write data to the file from memory.}
        \PYG{n}{sqlite3\PYGZus{}backup} \PYG{o}{*}\PYG{n}{backupdb}\PYG{p}{;}
        \PYG{n}{backupdb} \PYG{o}{=} \PYG{n}{sqlite3\PYGZus{}backup\PYGZus{}init}\PYG{p}{(}\PYG{n}{outdatabase}\PYG{p}{,}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{main}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{database}\PYG{p}{,}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{main}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{if}\PYG{p}{(}\PYG{o}{!}\PYG{n}{backupdb}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{cerr} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ERROR\PYGZus{}SQL\PYGZus{}011: Could not write to the backup database. Check the file exists.}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{c+c1}{// Perform the backup}
        \PYG{n}{rc} \PYG{o}{=} \PYG{n}{sqlite3\PYGZus{}backup\PYGZus{}step}\PYG{p}{(}\PYG{n}{backupdb}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{rc}\PYG{o}{!}\PYG{o}{=}\PYG{n}{SQLITE\PYGZus{}OK} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{n}{rc} \PYG{o}{!}\PYG{o}{=} \PYG{n}{SQLITE\PYGZus{}DONE}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
\PYG{c+c1}{//          cerr \PYGZlt{}\PYGZlt{}  \PYGZdq{}ERROR\PYGZus{}SQL\PYGZus{}010: SQLite database file could not be opened. Check the folder exists and you have write permissions. (REF2) Error code: \PYGZdq{} \PYGZlt{}\PYGZlt{} rc \PYGZlt{}\PYGZlt{} endl;}
            \PYG{c+c1}{// try again}
            \PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;}
            \PYG{k}{while}\PYG{p}{(}\PYG{p}{(}\PYG{n}{rc}\PYG{o}{!}\PYG{o}{=}\PYG{n}{SQLITE\PYGZus{}OK} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{n}{rc} \PYG{o}{!}\PYG{o}{=} \PYG{n}{SQLITE\PYGZus{}DONE}\PYG{p}{)} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{10}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{;}
                \PYG{n}{sleep}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
                \PYG{n}{rc} \PYG{o}{=} \PYG{n}{sqlite3\PYGZus{}backup\PYGZus{}step}\PYG{p}{(}\PYG{n}{backupdb}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
\PYG{c+c1}{//              cerr \PYGZlt{}\PYGZlt{} \PYGZdq{}Attempt \PYGZdq{} \PYGZlt{}\PYGZlt{} i \PYGZlt{}\PYGZlt{} \PYGZdq{} failed...\PYGZdq{} \PYGZlt{}\PYGZlt{} endl;}
            \PYG{p}{\PYGZcb{}}
            \PYG{k}{if}\PYG{p}{(}\PYG{n}{rc} \PYG{o}{!}\PYG{o}{=} \PYG{n}{SQLITE\PYGZus{}OK} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{n}{rc} \PYG{o}{!}\PYG{o}{=} \PYG{n}{SQLITE\PYGZus{}DONE}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{n}{cerr} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}  \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ERROR\PYGZus{}SQL\PYGZus{}010: SQLite database file could not be opened. Check the folder exists and you have write permissions. (REF3) Error code: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{rc} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
                \PYG{n}{cerr} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Attempted call }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{i} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ times}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
        \PYG{p}{\PYGZcb{}}
        \PYG{n}{sqlite3\PYGZus{}backup\PYGZus{}finish}\PYG{p}{(}\PYG{n}{backupdb}\PYG{p}{)}\PYG{p}{;}
\PYG{c+c1}{//      sqlite3\PYGZus{}exec(database,\PYGZdq{}VACUUM;\PYGZdq{},NULL,NULL,\PYGZam{}sErrMsg);}
        \PYG{n}{sqlite3\PYGZus{}close}\PYG{p}{(}\PYG{n}{database}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{sqlite3\PYGZus{}close}\PYG{p}{(}\PYG{n}{outdatabase}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}r}\PYG{l+s}{    Writing to }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{sqloutname} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ ....  done!              }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
        \PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif}
    \PYG{p}{\PYGZcb{}}

    \PYG{k+kt}{void} \PYG{n}{applySpecRates}\PYG{p}{(}\PYG{k+kt}{double} \PYG{n}{sr}\PYG{p}{,} \PYG{k+kt}{double} \PYG{n}{t}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{if}\PYG{p}{(}\PYG{o}{!}\PYG{n}{tl}\PYG{p}{.}\PYG{n}{hasSetMem}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{tl}\PYG{p}{.}\PYG{n}{setDatabase}\PYG{p}{(}\PYG{n}{database}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{c+c1}{//cout \PYGZlt{}\PYGZlt{} \PYGZdq{}Precount: \PYGZdq{} \PYGZlt{}\PYGZlt{} tl.countSpecies() \PYGZlt{}\PYGZlt{} endl;}
        \PYG{n}{tl}\PYG{p}{.}\PYG{n}{setGeneration}\PYG{p}{(}\PYG{n}{t}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{tl}\PYG{p}{.}\PYG{n}{resetTree}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{tl}\PYG{p}{.}\PYG{n}{createDatabase}\PYG{p}{(}\PYG{n}{sr}\PYG{p}{)}\PYG{p}{;}

        \PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifdef record\PYGZus{}space}
        \PYG{n}{tl}\PYG{p}{.}\PYG{n}{recordSpatial}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
        \PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif}
    \PYG{p}{\PYGZcb{}}

    \PYG{k+kt}{void} \PYG{n}{applySpecRates}\PYG{p}{(}\PYG{k+kt}{double} \PYG{n}{sr}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{applySpecRates}\PYG{p}{(}\PYG{n}{sr}\PYG{p}{,} \PYG{l+m+mf}{0.0}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}


\PYG{p}{\PYGZcb{}}\PYG{p}{;}

\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif }\PYG{c+c1}{// TREE}
\end{sphinxVerbatim}


\subparagraph{Includes}
\label{\detokenize{Exhaled/exhale_file_Tree.h:includes}}\begin{itemize}
\item {} 
\sphinxcode{Config.h} ({\hyperref[\detokenize{Exhaled/exhale_file_Config.h:file-config-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File Config.h}}}})

\item {} 
\sphinxcode{Datapoint.h} ({\hyperref[\detokenize{Exhaled/exhale_file_Datapoint.h:file-datapoint-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File Datapoint.h}}}})

\item {} 
\sphinxcode{Fattaildeviate.h} ({\hyperref[\detokenize{Exhaled/exhale_file_Fattaildeviate.h:file-fattaildeviate-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File Fattaildeviate.h}}}})

\item {} 
\sphinxcode{Map.h} ({\hyperref[\detokenize{Exhaled/exhale_file_Map.h:file-map-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File Map.h}}}})

\item {} 
\sphinxcode{Matrix.h} ({\hyperref[\detokenize{Exhaled/exhale_file_Matrix.h:file-matrix-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File Matrix.h}}}})

\item {} 
\sphinxcode{SpeciesList.h} ({\hyperref[\detokenize{Exhaled/exhale_file_SpeciesList.h:file-specieslist-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File SpeciesList.h}}}})

\item {} 
\sphinxcode{Treelist.h} ({\hyperref[\detokenize{Exhaled/exhale_file_Treelist.h:file-treelist-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File Treelist.h}}}})

\item {} 
\sphinxcode{Treenode.h} ({\hyperref[\detokenize{Exhaled/exhale_file_Treenode.h:file-treenode-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File Treenode.h}}}})

\item {} 
\sphinxcode{algorithm}

\item {} 
\sphinxcode{boost/filesystem.hpp}

\item {} 
\sphinxcode{cmath}

\item {} 
\sphinxcode{cstring}

\item {} 
\sphinxcode{ctime}

\item {} 
\sphinxcode{fstream}

\item {} 
\sphinxcode{iomanip}

\item {} 
\sphinxcode{iostream}

\item {} 
\sphinxcode{math.h}

\item {} 
\sphinxcode{sqlite3.h}

\item {} 
\sphinxcode{stdexcept}

\item {} 
\sphinxcode{stdio.h}

\item {} 
\sphinxcode{string}

\item {} 
\sphinxcode{time.h}

\item {} 
\sphinxcode{unistd.h}

\item {} 
\sphinxcode{vector}

\end{itemize}


\subparagraph{Included By}
\label{\detokenize{Exhaled/exhale_file_Tree.h:included-by}}\begin{itemize}
\item {} 
{\hyperref[\detokenize{Exhaled/exhale_file_Setup.h:file-setup-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File Setup.h}}}}

\end{itemize}


\subparagraph{Classes}
\label{\detokenize{Exhaled/exhale_file_Tree.h:classes}}\begin{itemize}
\item {} 
{\hyperref[\detokenize{Exhaled/exhale_class_Tree:class-tree}]{\sphinxcrossref{\DUrole{std,std-ref}{Class Tree}}}}

\end{itemize}


\subparagraph{Defines}
\label{\detokenize{Exhaled/exhale_file_Tree.h:defines}}\begin{itemize}
\item {} 
{\hyperref[\detokenize{Exhaled/exhale_define_sql_ram:define-sql-ram}]{\sphinxcrossref{\DUrole{std,std-ref}{Define sql\_ram}}}}

\end{itemize}


\paragraph{File Treelist.cpp}
\label{\detokenize{Exhaled/exhale_file_Treelist.cpp:file-treelist-cpp}}\label{\detokenize{Exhaled/exhale_file_Treelist.cpp::doc}}\label{\detokenize{Exhaled/exhale_file_Treelist.cpp:id1}}

\subparagraph{Definition (\sphinxstyleliteralintitle{Treelist.cpp})}
\label{\detokenize{Exhaled/exhale_file_Treelist.cpp:definition-treelist-cpp}}

\subparagraph{Program Listing for File Treelist.cpp}
\label{\detokenize{Exhaled/exhale_program_listing_file_Treelist.cpp:program-listing-for-file-treelist-cpp}}\label{\detokenize{Exhaled/exhale_program_listing_file_Treelist.cpp:program-listing-file-treelist-cpp}}\label{\detokenize{Exhaled/exhale_program_listing_file_Treelist.cpp::doc}}\begin{itemize}
\item {} 
Return to documentation for {\hyperref[\detokenize{Exhaled/exhale_file_Treelist.cpp:file-treelist-cpp}]{\sphinxcrossref{\DUrole{std,std-ref}{File Treelist.cpp}}}}

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{// This file is part of NECSim project which is released under BSD\PYGZhy{}3 license.}
\PYG{c+c1}{// See file **LICENSE.txt** or visit https://opensource.org/licenses/BSD\PYGZhy{}3\PYGZhy{}Clause) for full license details.}

\PYG{c+c1}{//\PYGZsh{}define use\PYGZus{}csv}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZdq{}Treelist.h\PYGZdq{}}
\PYG{k+kt}{void} \PYG{n}{Treelist}\PYG{o}{:}\PYG{o}{:}\PYG{n}{setList}\PYG{p}{(}\PYG{n}{Row}\PYG{o}{\PYGZlt{}}\PYG{n}{Treenode}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZam{}} \PYG{n}{l}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{n}{nodes} \PYG{o}{=} \PYG{n}{l}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{void} \PYG{n}{Treelist}\PYG{o}{:}\PYG{o}{:}\PYG{n}{setDatabase}\PYG{p}{(}\PYG{n}{sqlite3}\PYG{o}{*} \PYG{n}{dbin}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k}{if}\PYG{p}{(}\PYG{o}{!}\PYG{n}{bMem}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{database} \PYG{o}{=} \PYG{n}{dbin}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{else}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{throw} \PYG{n}{SpeciesException}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ERROR\PYGZus{}SPEC\PYGZus{}002: Attempt to set database \PYGZhy{} database link has already been set}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{n}{bMem} \PYG{o}{=} \PYG{n+nb}{true}\PYG{p}{;}  \PYG{c+c1}{// this just specifies that the database has been created in memory.}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{bool} \PYG{n}{Treelist}\PYG{o}{:}\PYG{o}{:}\PYG{n}{hasSetMem}\PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k}{return} \PYG{n}{bMem}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{double} \PYG{n}{Treelist}\PYG{o}{:}\PYG{o}{:}\PYG{n}{getMinimumSpeciation}\PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k}{return} \PYG{n}{min\PYGZus{}spec\PYGZus{}rate}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{void} \PYG{n}{Treelist}\PYG{o}{:}\PYG{o}{:}\PYG{n}{importSamplemask}\PYG{p}{(}\PYG{n}{string} \PYG{n}{sSamplemask}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k}{if}\PYG{p}{(}\PYG{o}{!}\PYG{n}{bSample}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{samplemaskfile} \PYG{o}{=} \PYG{n}{sSamplemask}\PYG{p}{;}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{sSamplemask} \PYG{o}{!}\PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{null}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{samplemask}\PYG{p}{.}\PYG{n}{SetSize}\PYG{p}{(}\PYG{n}{grid\PYGZus{}y\PYGZus{}size}\PYG{p}{,} \PYG{n}{grid\PYGZus{}x\PYGZus{}size}\PYG{p}{)}\PYG{p}{;}
            \PYG{c+c1}{//              cout \PYGZlt{}\PYGZlt{} \PYGZdq{}importing samplemask: \PYGZdq{} \PYGZlt{}\PYGZlt{} sSamplemask \PYGZlt{}\PYGZlt{} endl;}
            \PYG{n}{samplemask}\PYG{p}{.}\PYG{n}{setIsNull}\PYG{p}{(}\PYG{n+nb}{false}\PYG{p}{)}\PYG{p}{;}
            \PYG{n}{samplemask}\PYG{p}{.}\PYG{n}{import}\PYG{p}{(}\PYG{n}{sSamplemask}\PYG{p}{)}\PYG{p}{;}
            \PYG{c+c1}{//              Matrix\PYGZlt{}unsigned short\PYGZgt{} tempsampmask;}
            \PYG{c+c1}{//              tempsampmask.SetSize(samplemask.GetRows(),samplemask.GetCols());}
            \PYG{c+c1}{//              tempsampmask.importCsv(sSamplemask);}
            \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{total} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
            \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{samplemask}\PYG{p}{.}\PYG{n}{GetCols}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{j} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{j} \PYG{o}{\PYGZlt{}} \PYG{n}{samplemask}\PYG{p}{.}\PYG{n}{GetRows}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{n}{j}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
                \PYG{p}{\PYGZob{}}
                    \PYG{k}{if}\PYG{p}{(}\PYG{n}{samplemask}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}
                    \PYG{p}{\PYGZob{}}
                        \PYG{n}{total}\PYG{o}{+}\PYG{o}{+}\PYG{p}{;}
                        \PYG{c+c1}{// Check}
                        \PYG{k}{if}\PYG{p}{(}\PYG{o}{!}\PYG{n}{samplemask}\PYG{p}{.}\PYG{n}{getVal}\PYG{p}{(}\PYG{n}{i}\PYG{p}{,} \PYG{n}{j}\PYG{p}{)}\PYG{p}{)}
                        \PYG{p}{\PYGZob{}}
                            \PYG{n}{cerr} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{BUG!}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
                            \PYG{n}{exit}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
                        \PYG{p}{\PYGZcb{}}
                    \PYG{p}{\PYGZcb{}}
                \PYG{p}{\PYGZcb{}}
            \PYG{p}{\PYGZcb{}}
            \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Sampling }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{total} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ cells.}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{else}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{samplemask}\PYG{p}{.}\PYG{n}{setIsNull}\PYG{p}{(}\PYG{n+nb}{true}\PYG{p}{)}\PYG{p}{;}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifdef DEBUG}
            \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Sampling all areas.}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif}
        \PYG{p}{\PYGZcb{}}
        \PYG{n}{bSample} \PYG{o}{=} \PYG{n+nb}{true}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{Treelist}\PYG{o}{:}\PYG{o}{:}\PYG{n}{countSpecies}\PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k+kt}{unsigned} \PYG{k+kt}{int} \PYG{n}{precount} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
    \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{nodes}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{nodes}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{hasSpeciated}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{precount}\PYG{o}{+}\PYG{o}{+}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
    \PYG{p}{\PYGZcb{}}
    \PYG{c+c1}{// cout \PYGZlt{}\PYGZlt{} \PYGZdq{}Precount: \PYGZdq{} \PYGZlt{}\PYGZlt{} precount \PYGZlt{}\PYGZlt{} endl;}
    \PYG{k}{return} \PYG{p}{(}\PYG{n}{precount}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{bool} \PYG{n}{Treelist}\PYG{o}{:}\PYG{o}{:}\PYG{n}{doubleCompare}\PYG{p}{(}\PYG{k+kt}{double} \PYG{n}{d1}\PYG{p}{,} \PYG{k+kt}{double} \PYG{n}{d2}\PYG{p}{,} \PYG{k+kt}{double} \PYG{n}{epsilon}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k}{return} \PYG{p}{(}\PYG{n}{abs}\PYG{p}{(}\PYG{k+kt}{float}\PYG{p}{(}\PYG{n}{d1} \PYG{o}{\PYGZhy{}} \PYG{n}{d2}\PYG{p}{)}\PYG{p}{)} \PYG{o}{\PYGZlt{}} \PYG{n}{epsilon}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{Treelist}\PYG{o}{:}\PYG{o}{:}\PYG{n}{calcSpecies}\PYG{p}{(}\PYG{k+kt}{double} \PYG{n}{s}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{n}{resetTree}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
    \PYG{k}{if}\PYG{p}{(}\PYG{o}{!}\PYG{n}{bSample}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifdef DEBUG}
        \PYG{n}{cerr} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{No samplemask imported. Defaulting to null.}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif}
        \PYG{n}{importSamplemask}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{null}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{c+c1}{//      cout \PYGZlt{}\PYGZlt{} \PYGZdq{}listsize: \PYGZdq{} \PYGZlt{}\PYGZlt{} nodes.size() \PYGZlt{}\PYGZlt{} endl;}
    \PYG{n}{dSpecRate} \PYG{o}{=} \PYG{n}{s}\PYG{p}{;}
    \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{iSpecCount} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}  \PYG{c+c1}{// start at 2 because the last species has been burnt already.}
    \PYG{c+c1}{// check that tips exist within the spatial and temporal frame of interest.}
    \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{nodes}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{nodes}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{isTip}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{o}{!}\PYG{n}{samplemask}\PYG{p}{.}\PYG{n}{getVal}\PYG{p}{(}\PYG{n}{nodes}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getXpos}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{n}{nodes}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getYpos}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Outside sample zone: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{i} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ (}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{nodes}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getXpos}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{,}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{nodes}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getYpos}\PYG{p}{(}\PYG{p}{)}
                 \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{)}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
            \PYG{n}{exit}\PYG{p}{(}\PYG{n}{EXIT\PYGZus{}FAILURE}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{nodes}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getParent}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZgt{}}\PYG{o}{=} \PYG{n}{nodes}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{cerr} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{i: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
            \PYG{n}{cerr} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{parent: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{nodes}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getParent}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
            \PYG{n}{cerr} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{size: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{nodes}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
            \PYG{k}{throw} \PYG{n+nf}{SpeciesException}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ERROR\PYGZus{}SQL\PYGZus{}017: The parent is outside the size of the the data object. Bug }\PYG{l+s}{\PYGZdq{}}
                                   \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{in expansion of data structures or object set up likely.}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{nodes}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{isTip}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{n}{samplemask}\PYG{p}{.}\PYG{n}{getVal}\PYG{p}{(}\PYG{n}{nodes}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getXpos}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{n}{nodes}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getYpos}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}}
           \PYG{n}{doubleCompare}\PYG{p}{(}\PYG{n}{nodes}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getGeneration}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{n}{generation}\PYG{p}{,} \PYG{l+m+mf}{0.0001}\PYG{p}{)}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{c+c1}{// if they exist exactly in the generation of interest.}
            \PYG{n}{nodes}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{setExistance}\PYG{p}{(}\PYG{n+nb}{true}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{else}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{nodes}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{setExistance}\PYG{p}{(}\PYG{n+nb}{false}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{c+c1}{// Calculate if speciation occured at any point in the lineage\PYGZsq{}s branch}
\PYG{c+c1}{//      double maxret ;}
\PYG{c+c1}{//      if(nodes[i].getGenRate() == 0)}
\PYG{c+c1}{//      \PYGZob{}}
\PYG{c+c1}{//          maxret = 1;}
\PYG{c+c1}{//      \PYGZcb{}}
\PYG{c+c1}{//      else}
\PYG{c+c1}{//      \PYGZob{}}
\PYG{c+c1}{//          maxret = nodes[i].getGenRate();}
\PYG{c+c1}{//      \PYGZcb{}}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{checkSpeciation}\PYG{p}{(}\PYG{n}{nodes}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getSpecRate}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{n}{s}\PYG{p}{,} \PYG{n}{nodes}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getGenRate}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{iSpecCount}\PYG{o}{+}\PYG{o}{+}\PYG{p}{;}
            \PYG{n}{nodes}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{speciate}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
            \PYG{c+c1}{//              nodes[i].burnSpecies(iSpecCount);}
        \PYG{p}{\PYGZcb{}}
    \PYG{p}{\PYGZcb{}}
    \PYG{c+c1}{//      cout \PYGZlt{}\PYGZlt{} \PYGZdq{}check2: \PYGZdq{} \PYGZlt{}\PYGZlt{} nodes[1].getExistance() \PYGZlt{}\PYGZlt{} endl;}
    \PYG{c+c1}{//      bool check = nodes[1].getGeneration() == generation;}
    \PYG{c+c1}{//      cout \PYGZlt{}\PYGZlt{} \PYGZdq{}point: \PYGZdq{} \PYGZlt{}\PYGZlt{} samplemask.getVal(nodes[1].getXpos(),nodes[1].getYpos()) \PYGZlt{}\PYGZlt{} endl;}
    \PYG{c+c1}{//      cout \PYGZlt{}\PYGZlt{} \PYGZdq{}tip: \PYGZdq{} \PYGZlt{}\PYGZlt{} nodes[1].isTip() \PYGZlt{}\PYGZlt{} endl;}
    \PYG{c+c1}{//      cout \PYGZlt{}\PYGZlt{} \PYGZdq{}gen: \PYGZdq{} \PYGZlt{}\PYGZlt{} check \PYGZlt{}\PYGZlt{} endl;}
    \PYG{c+c1}{// cout \PYGZlt{}\PYGZlt{} \PYGZdq{}iSpecCount: \PYGZdq{} \PYGZlt{}\PYGZlt{} iSpecCount \PYGZlt{}\PYGZlt{} endl;}
    \PYG{c+c1}{// now continue looping to calculate species identities for lineages given the new speciation probabilities.}
    \PYG{k+kt}{bool} \PYG{n}{bSorter} \PYG{o}{=} \PYG{n+nb}{true}\PYG{p}{;}
    \PYG{k}{while}\PYG{p}{(}\PYG{n}{bSorter}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{bSorter} \PYG{o}{=} \PYG{n+nb}{false}\PYG{p}{;}
        \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{nodes}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{c+c1}{// check if any parents exist}
            \PYG{k}{if}\PYG{p}{(}\PYG{o}{!}\PYG{n}{nodes}\PYG{p}{[}\PYG{n}{nodes}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getParent}\PYG{p}{(}\PYG{p}{)}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getExistance}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{n}{nodes}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getExistance}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}}
               \PYG{o}{!}\PYG{n}{nodes}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{hasSpeciated}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{n}{bSorter} \PYG{o}{=} \PYG{n+nb}{true}\PYG{p}{;}
                \PYG{n}{nodes}\PYG{p}{[}\PYG{n}{nodes}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getParent}\PYG{p}{(}\PYG{p}{)}\PYG{p}{]}\PYG{p}{.}\PYG{n}{setExistance}\PYG{p}{(}\PYG{n+nb}{true}\PYG{p}{)}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
        \PYG{p}{\PYGZcb{}}
    \PYG{p}{\PYGZcb{}}
    \PYG{c+c1}{//      cout \PYGZlt{}\PYGZlt{} \PYGZdq{}2\PYGZdq{} \PYGZlt{}\PYGZlt{} endl;}
    \PYG{c+c1}{// Loop to check that no lineages have a parent that is a tip. If they do, set their existence to false}
    \PYG{c+c1}{// We then need to continue looping to complete}
    \PYG{c+c1}{//      bool loop = true;}
    \PYG{c+c1}{//      cout \PYGZlt{}\PYGZlt{} \PYGZdq{}testloop\PYGZdq{} \PYGZlt{}\PYGZlt{} endl;}
    \PYG{c+c1}{//      while(loop)}
    \PYG{c+c1}{//      \PYGZob{}}
    \PYG{c+c1}{//          for (unsigned int i =1; i\PYGZlt{}=nodes.size(); i++)}
    \PYG{c+c1}{//          \PYGZob{}}
    \PYG{c+c1}{//              loop = false;}
    \PYG{c+c1}{//              if(nodes[i].getExistance() \PYGZam{}\PYGZam{} nodes[nodes[i].getParent()].getExistance() \PYGZam{}\PYGZam{}}
    \PYG{c+c1}{//nodes[nodes[i].getParent()].isTip() \PYGZam{}\PYGZam{} nodes[nodes[i].getParent()].getGeneration() \PYGZlt{}= (generation+0.0001))}
    \PYG{c+c1}{//              \PYGZob{}}
    \PYG{c+c1}{//                  nodes[i].setExistance(false);}
    \PYG{c+c1}{//                  nodes[i].setGeneration(nodes[nodes[i].getParent()].getGeneration());}
    \PYG{c+c1}{//                  loop = true;}
    \PYG{c+c1}{//              \PYGZcb{}}
    \PYG{c+c1}{//              if(nodes[i].getExistance() \PYGZam{}\PYGZam{} nodes[nodes[i].getParent()].getGeneration() \PYGZlt{}= (generation + 0.0001) \PYGZam{}\PYGZam{}}
    \PYG{c+c1}{//              \PYGZob{}}
    \PYG{c+c1}{//                  loop = true;}
    \PYG{c+c1}{//                  nodes[i].setExistance(false);}
    \PYG{c+c1}{//                  nodes[i].setGeneration(nodes[nodes[i].getParent()].getGeneration());}
    \PYG{c+c1}{//              \PYGZcb{}}
    \PYG{c+c1}{//}
    \PYG{c+c1}{//              if(nodes[i].getParent()==0 \PYGZam{}\PYGZam{} nodes[i].getExistance() \PYGZam{}\PYGZam{} !loop \PYGZam{}\PYGZam{}}
    \PYG{c+c1}{//              \PYGZob{}}
    \PYG{c+c1}{//                  cout \PYGZlt{}\PYGZlt{} \PYGZdq{}dSpec: \PYGZdq{} \PYGZlt{}\PYGZlt{} nodes[i].getSpecRate() \PYGZlt{}\PYGZlt{}endl;}
    \PYG{c+c1}{//                  cout \PYGZlt{}\PYGZlt{} \PYGZdq{}tip: \PYGZdq{} \PYGZlt{}\PYGZlt{} nodes[i].isTip() \PYGZlt{}\PYGZlt{} endl;}
    \PYG{c+c1}{//                  cout \PYGZlt{}\PYGZlt{} \PYGZdq{}i: \PYGZdq{} \PYGZlt{}\PYGZlt{} i \PYGZlt{}\PYGZlt{} endl;}
    \PYG{c+c1}{//                  cout \PYGZlt{}\PYGZlt{} \PYGZdq{}parent: \PYGZdq{} \PYGZlt{}\PYGZlt{} nodes[i].getParent() \PYGZlt{}\PYGZlt{} endl;}
    \PYG{c+c1}{//                  cout \PYGZlt{}\PYGZlt{} \PYGZdq{}parent\PYGZus{}id: \PYGZdq{} \PYGZlt{}\PYGZlt{} nodes[nodes[i].getParent()].getSpeciesID() \PYGZlt{}\PYGZlt{} endl;}
    \PYG{c+c1}{//                  cout \PYGZlt{}\PYGZlt{}\PYGZdq{}existance: \PYGZdq{} \PYGZlt{}\PYGZlt{} nodes[i].getExistance() \PYGZlt{}\PYGZlt{} endl;}
    \PYG{c+c1}{//                  cout \PYGZlt{}\PYGZlt{} \PYGZdq{}speciated: \PYGZdq{} \PYGZlt{}\PYGZlt{} nodes[i].hasSpeciated() \PYGZlt{}\PYGZlt{} endl;}
    \PYG{c+c1}{//                  cout \PYGZlt{}\PYGZlt{} \PYGZdq{}nodes.size: \PYGZdq{} \PYGZlt{}\PYGZlt{} nodes.size() \PYGZlt{}\PYGZlt{} endl;}
    \PYG{c+c1}{//                  throw SpeciesException(\PYGZdq{}ERROR\PYGZus{}SPEC\PYGZus{}001: Incorrect setting of speciation rate, as individual exists but}
    \PYG{c+c1}{//has no species identity.\PYGZdq{}); // this needs explaining properly at some point.}
    \PYG{c+c1}{//              \PYGZcb{}}
    \PYG{c+c1}{//          \PYGZcb{}}
    \PYG{c+c1}{//      \PYGZcb{}}
    \PYG{n}{iSpecCount} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
    \PYG{c+c1}{// Now loop again, creating a new species for each species that actually exists.}
    \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{nodes}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{nodes}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getExistance}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{n}{nodes}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{hasSpeciated}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{iSpecCount}\PYG{o}{+}\PYG{o}{+}\PYG{p}{;}
            \PYG{n}{nodes}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{burnSpecies}\PYG{p}{(}\PYG{n}{iSpecCount}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}

        \PYG{c+c1}{//          else if(nodes[i].getExistance()\PYGZam{}\PYGZam{}nodes[i].hasSpeciated())}
        \PYG{c+c1}{//          \PYGZob{}}
        \PYG{c+c1}{//              cout \PYGZlt{}\PYGZlt{} \PYGZdq{}i: \PYGZdq{} \PYGZlt{}\PYGZlt{} i \PYGZlt{}\PYGZlt{} endl;}
        \PYG{c+c1}{//              cout \PYGZlt{}\PYGZlt{} \PYGZdq{}id: \PYGZdq{} \PYGZlt{}\PYGZlt{} nodes[i].getSpeciesID() \PYGZlt{}\PYGZlt{} endl;}
        \PYG{c+c1}{//          \PYGZcb{}}
    \PYG{p}{\PYGZcb{}}
    \PYG{c+c1}{// cout \PYGZlt{}\PYGZlt{} \PYGZdq{}iSpecCount: \PYGZdq{} \PYGZlt{}\PYGZlt{} iSpecCount \PYGZlt{}\PYGZlt{} endl;}
    \PYG{c+c1}{//      cout \PYGZlt{}\PYGZlt{} \PYGZdq{}3\PYGZdq{} \PYGZlt{}\PYGZlt{} endl;}

    \PYG{c+c1}{// now loop to correctly assign each species id}
    \PYG{k+kt}{bool} \PYG{n}{loopon} \PYG{o}{=} \PYG{n+nb}{true}\PYG{p}{;}
    \PYG{k}{while}\PYG{p}{(}\PYG{n}{loopon}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{c+c1}{//          cout \PYGZlt{}\PYGZlt{} \PYGZdq{}while:1\PYGZdq{} \PYGZlt{}\PYGZlt{} endl;}
        \PYG{c+c1}{// These variables are no longer required}
        \PYG{c+cm}{/*long tempdebug = 0;}
\PYG{c+cm}{        long tempdebug1 = 0;*/}

        \PYG{n}{loopon} \PYG{o}{=} \PYG{n+nb}{false}\PYG{p}{;}
        \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{i} \PYG{o}{=} \PYG{p}{(}\PYG{n}{nodes}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{1}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{p}{)}  \PYG{c+c1}{// if we start at the end of the loop and work}
                                                               \PYG{c+c1}{// backwards, we should remove some of the repeat}
                                                               \PYG{c+c1}{// speciation events.}
        \PYG{p}{\PYGZob{}}
            \PYG{c+c1}{//              cout \PYGZlt{}\PYGZlt{} i \PYGZlt{}\PYGZlt{} endl;}
            \PYG{k}{if}\PYG{p}{(}\PYG{n}{nodes}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getSpeciesID}\PYG{p}{(}\PYG{p}{)} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{0} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{n}{nodes}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getExistance}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{c+c1}{//                  cout \PYGZlt{}\PYGZlt{} i \PYGZlt{}\PYGZlt{} endl;}
                \PYG{n}{loopon} \PYG{o}{=} \PYG{n+nb}{true}\PYG{p}{;}
                \PYG{c+c1}{// tempdebug ++;}
                \PYG{n}{nodes}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{burnSpecies}\PYG{p}{(}\PYG{n}{nodes}\PYG{p}{[}\PYG{n}{nodes}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getParent}\PYG{p}{(}\PYG{p}{)}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getSpeciesID}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}

                \PYG{k}{if}\PYG{p}{(}\PYG{n}{nodes}\PYG{p}{[}\PYG{n}{nodes}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getParent}\PYG{p}{(}\PYG{p}{)}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getSpeciesID}\PYG{p}{(}\PYG{p}{)} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{0} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}}
                   \PYG{n}{doubleCompare}\PYG{p}{(}\PYG{n}{nodes}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getGeneration}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{n}{generation}\PYG{p}{,} \PYG{l+m+mf}{0.001}\PYG{p}{)}\PYG{p}{)}
                \PYG{p}{\PYGZob{}}
                    \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{dSpec: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{nodes}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getSpecRate}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
                    \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{tip: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{nodes}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{isTip}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
                    \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{i: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{i} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
                    \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{parent: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{nodes}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getParent}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
                    \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{parent\PYGZus{}id: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{nodes}\PYG{p}{[}\PYG{n}{nodes}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getParent}\PYG{p}{(}\PYG{p}{)}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getSpeciesID}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
                    \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{existance: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{nodes}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getExistance}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
                    \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{speciated: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{nodes}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{hasSpeciated}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
                    \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{generation: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{nodes}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getGeneration}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
                    \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Potential parent ID error \PYGZhy{} press any key to continue: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{flush}\PYG{p}{;}
                    \PYG{n}{string} \PYG{n}{test}\PYG{p}{;}
                    \PYG{n}{cin} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{test}\PYG{p}{;}
                    \PYG{c+c1}{//                      cout \PYGZlt{}\PYGZlt{} \PYGZdq{}i: \PYGZdq{} \PYGZlt{}\PYGZlt{} i \PYGZlt{}\PYGZlt{} endl;}
                \PYG{p}{\PYGZcb{}}
            \PYG{p}{\PYGZcb{}}
        \PYG{p}{\PYGZcb{}}
    \PYG{p}{\PYGZcb{}}
    \PYG{c+c1}{//      cout \PYGZlt{}\PYGZlt{} \PYGZdq{}4\PYGZdq{} \PYGZlt{}\PYGZlt{} endl;}

    \PYG{c+c1}{// count the number of species that have been created}
    \PYG{n}{iSpecCount} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
    \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{nodes}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{nodes}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{hasSpeciated}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{n}{nodes}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getExistance}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}}
           \PYG{n}{nodes}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getSpeciesID}\PYG{p}{(}\PYG{p}{)} \PYG{o}{!}\PYG{o}{=}
               \PYG{l+m+mi}{0}\PYG{p}{)}  \PYG{c+c1}{//\PYGZam{}\PYGZam{}nodes[i].getExistance()) // count all speciation events, not just the ones that exist!}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{iSpecCount}\PYG{o}{+}\PYG{o}{+}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{nodes}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getExistance}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{n}{nodes}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getSpeciesID}\PYG{p}{(}\PYG{p}{)} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{cerr} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ERROR\PYGZus{}SQL\PYGZus{}006: Species exists but hasn\PYGZsq{}t been assigned a species ID. Check the tree }\PYG{l+s}{\PYGZdq{}}
                    \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{speciation calculations.}\PYG{l+s}{\PYGZdq{}}
                 \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
    \PYG{p}{\PYGZcb{}}
    \PYG{n}{iSpecies} \PYG{o}{=} \PYG{n}{iSpecCount}\PYG{p}{;}
    \PYG{c+c1}{//      cout \PYGZlt{}\PYGZlt{} \PYGZdq{}iSpecies: \PYGZdq{} \PYGZlt{}\PYGZlt{} iSpecies \PYGZlt{}\PYGZlt{} endl;}
    \PYG{k}{return} \PYG{n}{iSpecCount}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{void} \PYG{n}{Treelist}\PYG{o}{:}\PYG{o}{:}\PYG{n}{calcSpeciesAbundance}\PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{n}{rOut}\PYG{p}{.}\PYG{n}{SetRowSize}\PYG{p}{(}\PYG{n}{iSpecies} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
    \PYG{c+c1}{//      cout \PYGZlt{}\PYGZlt{} \PYGZdq{}iSpecies: \PYGZdq{} \PYGZlt{}\PYGZlt{} iSpecies \PYGZlt{}\PYGZlt{} endl;}
    \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{rOut}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{rOut}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{nodes}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{nodes}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{isTip}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{n}{doubleCompare}\PYG{p}{(}\PYG{n}{nodes}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getGeneration}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{n}{generation}\PYG{p}{,} \PYG{l+m+mf}{0.0001}\PYG{p}{)} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}}
           \PYG{n}{nodes}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getExistance}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{k}{if}\PYG{p}{(}\PYG{o}{!}\PYG{n}{samplemask}\PYG{p}{.}\PYG{n}{getVal}\PYG{p}{(}\PYG{n}{nodes}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getXpos}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{n}{nodes}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getYpos}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}}
               \PYG{n}{doubleCompare}\PYG{p}{(}\PYG{n}{nodes}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getGeneration}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{n}{generation}\PYG{p}{,} \PYG{l+m+mf}{0.0001}\PYG{p}{)}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{n}{cerr} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{x,y }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{nodes}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getXpos}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{, }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{nodes}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getYpos}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
                \PYG{n}{cerr} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{tip: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{nodes}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{isTip}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ Existance: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{nodes}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getExistance}\PYG{p}{(}\PYG{p}{)}
                     \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ samplemask: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{samplemask}\PYG{p}{.}\PYG{n}{getVal}\PYG{p}{(}\PYG{n}{nodes}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getXpos}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{n}{nodes}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getYpos}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
                     \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
                \PYG{n}{cerr} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ERROR\PYGZus{}SQL\PYGZus{}005: Tip doesn\PYGZsq{}t exist. Something went wrong either in the import or }\PYG{l+s}{\PYGZdq{}}
                        \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{main simulation running.}\PYG{l+s}{\PYGZdq{}}
                     \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
            \PYG{c+c1}{// The line that counts the number of individuals}
            \PYG{n}{rOut}\PYG{p}{[}\PYG{n}{nodes}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getSpeciesID}\PYG{p}{(}\PYG{p}{)}\PYG{p}{]}\PYG{o}{+}\PYG{o}{+}\PYG{p}{;}
            \PYG{k}{if}\PYG{p}{(}\PYG{n}{nodes}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getSpeciesID}\PYG{p}{(}\PYG{p}{)} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{0} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{n}{samplemask}\PYG{p}{.}\PYG{n}{getVal}\PYG{p}{(}\PYG{n}{nodes}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getXpos}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{n}{nodes}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getYpos}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}}
               \PYG{n}{doubleCompare}\PYG{p}{(}\PYG{n}{nodes}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getGeneration}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{n}{generation}\PYG{p}{,} \PYG{l+m+mf}{0.0001}\PYG{p}{)}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{n}{cerr} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{x,y }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{nodes}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getXpos}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{, }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{nodes}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getYpos}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
                \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{generation (point,required): }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{nodes}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getGeneration}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{, }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{generation}
                     \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
                \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{p} \PYG{o}{=} \PYG{n}{nodes}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getParent}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
                \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{samplemasktest: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{samplemask}\PYG{p}{.}\PYG{n}{getTestVal}\PYG{p}{(}\PYG{n}{nodes}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getXpos}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{n}{nodes}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getYpos}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
                     \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
                \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{samplemask: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{samplemask}\PYG{p}{.}\PYG{n}{getVal}\PYG{p}{(}\PYG{n}{nodes}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getXpos}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{n}{nodes}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getYpos}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
                \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{parent (tip, exists, generations): }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{nodes}\PYG{p}{[}\PYG{n}{p}\PYG{p}{]}\PYG{p}{.}\PYG{n}{isTip}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{, }\PYG{l+s}{\PYGZdq{}}
                     \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{nodes}\PYG{p}{[}\PYG{n}{p}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getExistance}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{, }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{nodes}\PYG{p}{[}\PYG{n}{p}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getGeneration}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
                \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{species id zero \PYGZhy{} i: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{i} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ parent: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{nodes}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getParent}\PYG{p}{(}\PYG{p}{)}
                     \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ dSpec: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{nodes}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getSpecRate}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{has speciated: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{nodes}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{hasSpeciated}\PYG{p}{(}\PYG{p}{)}
                     \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
                \PYG{k}{throw} \PYG{n+nf}{runtime\PYGZus{}error}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Fatal, exiting program.}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
        \PYG{p}{\PYGZcb{}}
    \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{void} \PYG{n}{Treelist}\PYG{o}{:}\PYG{o}{:}\PYG{n}{resetTree}\PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{nodes}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{nodes}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{qReset}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{c+c1}{// Speciate the final lineages.}
    \PYG{c+c1}{//      nodes[r].speciate();}
    \PYG{c+c1}{//      nodes[r].burnSpecies(1);}
    \PYG{c+c1}{//      nodes[r].setExistance(true);}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{void} \PYG{n}{Treelist}\PYG{o}{:}\PYG{o}{:}\PYG{n}{detectDimensions}\PYG{p}{(}\PYG{n}{string} \PYG{n}{db}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{n}{sqlite3}\PYG{o}{*} \PYG{n}{tmpdb}\PYG{p}{;}
    \PYG{k+kt}{int} \PYG{n}{rc} \PYG{o}{=} \PYG{n}{sqlite3\PYGZus{}open\PYGZus{}v2}\PYG{p}{(}\PYG{n}{db}\PYG{p}{.}\PYG{n}{c\PYGZus{}str}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{tmpdb}\PYG{p}{,} \PYG{n}{SQLITE\PYGZus{}OPEN\PYGZus{}READWRITE}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{unix\PYGZhy{}dotfile}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{string} \PYG{n}{to\PYGZus{}exec} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{SELECT MAX(xval),MAX(yval) FROM SPECIES\PYGZus{}LIST;}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
    \PYG{n}{sqlite3\PYGZus{}stmt}\PYG{o}{*} \PYG{n}{stmt}\PYG{p}{;}
    \PYG{n}{rc} \PYG{o}{=} \PYG{n}{sqlite3\PYGZus{}prepare\PYGZus{}v2}\PYG{p}{(}\PYG{n}{tmpdb}\PYG{p}{,} \PYG{n}{to\PYGZus{}exec}\PYG{p}{.}\PYG{n}{c\PYGZus{}str}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{n}{strlen}\PYG{p}{(}\PYG{n}{to\PYGZus{}exec}\PYG{p}{.}\PYG{n}{c\PYGZus{}str}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{stmt}\PYG{p}{,} \PYG{n+nb}{NULL}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kt}{unsigned} \PYG{k+kt}{int} \PYG{n}{xvalmax}\PYG{p}{,} \PYG{n}{yvalmax}\PYG{p}{;}
    \PYG{n}{rc} \PYG{o}{=} \PYG{n}{sqlite3\PYGZus{}step}\PYG{p}{(}\PYG{n}{stmt}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{xvalmax} \PYG{o}{=} \PYG{n}{sqlite3\PYGZus{}column\PYGZus{}int}\PYG{p}{(}\PYG{n}{stmt}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{p}{;}
    \PYG{n}{yvalmax} \PYG{o}{=} \PYG{n}{sqlite3\PYGZus{}column\PYGZus{}int}\PYG{p}{(}\PYG{n}{stmt}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{p}{;}
    \PYG{n}{samplemask}\PYG{p}{.}\PYG{n}{SetSize}\PYG{p}{(}\PYG{n}{xvalmax}\PYG{p}{,} \PYG{n}{yvalmax}\PYG{p}{)}\PYG{p}{;}
    \PYG{c+c1}{//      cout \PYGZlt{}\PYGZlt{} \PYGZdq{}xvalmax: \PYGZdq{} \PYGZlt{}\PYGZlt{} xvalmax \PYGZlt{}\PYGZlt{} endl;}
    \PYG{c+c1}{//      cout \PYGZlt{}\PYGZlt{} \PYGZdq{}yvalmax: \PYGZdq{} \PYGZlt{}\PYGZlt{} xvalmax \PYGZlt{}\PYGZlt{} endl;}
    \PYG{c+c1}{// close the old statement}
    \PYG{n}{rc} \PYG{o}{=} \PYG{n}{sqlite3\PYGZus{}finalize}\PYG{p}{(}\PYG{n}{stmt}\PYG{p}{)}\PYG{p}{;}
    \PYG{k}{if}\PYG{p}{(}\PYG{n}{rc} \PYG{o}{!}\PYG{o}{=} \PYG{n}{SQLITE\PYGZus{}OK} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{n}{rc} \PYG{o}{!}\PYG{o}{=} \PYG{n}{SQLITE\PYGZus{}DONE}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{cerr} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{rc: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{rc} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
        \PYG{k}{throw} \PYG{n+nf}{SpeciesException}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Could not detect dimensions}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{void} \PYG{n}{Treelist}\PYG{o}{:}\PYG{o}{:}\PYG{n}{importData}\PYG{p}{(}\PYG{n}{string} \PYG{n}{inputfile}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Beginning data import...}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{flush}\PYG{p}{;}
    \PYG{c+c1}{//  int res = sqlite3\PYGZus{}create\PYGZus{}function(dbRef, \PYGZdq{}SPEC\PYGZus{}CALC\PYGZdq{}, 2, SQLITE\PYGZus{}UTF8, NULL, \PYGZam{}sqlite\PYGZus{}calc\PYGZus{}speciation, NULL,}
    \PYG{c+c1}{//NULL);}
    \PYG{c+c1}{// open the database objects}
    \PYG{n}{sqlite3}\PYG{o}{*} \PYG{n}{outdatabase}\PYG{p}{;}
    \PYG{n}{sqlite3\PYGZus{}backup}\PYG{o}{*} \PYG{n}{backupdb}\PYG{p}{;}
    \PYG{n}{sqlite3\PYGZus{}stmt}\PYG{o}{*} \PYG{n}{stmt}\PYG{p}{;}
    \PYG{c+c1}{// open one db in memory and one from the file.}
    \PYG{k+kt}{int} \PYG{n}{o1} \PYG{o}{=} \PYG{n}{sqlite3\PYGZus{}open}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{:memory:}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{database}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kt}{int} \PYG{n}{o2} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{;}
    \PYG{c+c1}{// Check the outdatabase exists}
    \PYG{k}{if}\PYG{p}{(}\PYG{o}{!}\PYG{n}{boost}\PYG{o}{:}\PYG{o}{:}\PYG{n}{filesystem}\PYG{o}{:}\PYG{o}{:}\PYG{n}{exists}\PYG{p}{(}\PYG{n}{inputfile}\PYG{p}{)}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{throw} \PYG{n}{SpeciesException}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ERROR\PYGZus{}SQL\PYGZus{}015: FATAL. Source file does not exist.}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{n}{o2} \PYG{o}{=} \PYG{n}{sqlite3\PYGZus{}open\PYGZus{}v2}\PYG{p}{(}\PYG{n}{inputfile}\PYG{p}{.}\PYG{n}{c\PYGZus{}str}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{outdatabase}\PYG{p}{,} \PYG{n}{SQLITE\PYGZus{}OPEN\PYGZus{}READWRITE}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{unix\PYGZhy{}dotfile}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{c+c1}{// cout \PYGZlt{}\PYGZlt{} \PYGZdq{}o2: \PYGZdq{} \PYGZlt{}\PYGZlt{} o2 \PYGZlt{}\PYGZlt{} endl;}
    \PYG{k}{if}\PYG{p}{(}\PYG{n}{o2} \PYG{o}{!}\PYG{o}{=} \PYG{n}{SQLITE\PYGZus{}OK} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{n}{o2} \PYG{o}{!}\PYG{o}{=} \PYG{n}{SQLITE\PYGZus{}DONE}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{throw} \PYG{n}{SpeciesException}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ERROR\PYGZus{}SQL\PYGZus{}002: FATAL. Source file cannot be opened.}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{if}\PYG{p}{(}\PYG{n}{sqlite3\PYGZus{}errcode}\PYG{p}{(}\PYG{n}{database}\PYG{p}{)} \PYG{o}{!}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{cerr} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Can\PYGZsq{}t open in\PYGZhy{}memory database. Writing to file instead (this will be slower).}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
        \PYG{n}{bMem} \PYG{o}{=} \PYG{n+nb}{false}\PYG{p}{;}
        \PYG{n}{sqlite3\PYGZus{}close}\PYG{p}{(}\PYG{n}{database}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{sqlite3\PYGZus{}close}\PYG{p}{(}\PYG{n}{outdatabase}\PYG{p}{)}\PYG{p}{;}
        \PYG{k+kt}{int} \PYG{n}{rc} \PYG{o}{=} \PYG{n}{sqlite3\PYGZus{}open\PYGZus{}v2}\PYG{p}{(}\PYG{n}{inputfile}\PYG{p}{.}\PYG{n}{c\PYGZus{}str}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{database}\PYG{p}{,} \PYG{n}{SQLITE\PYGZus{}OPEN\PYGZus{}READWRITE}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{unix\PYGZhy{}dotfile}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{rc} \PYG{o}{!}\PYG{o}{=} \PYG{n}{SQLITE\PYGZus{}OK}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{k}{throw} \PYG{n}{SpeciesException}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ERROR\PYGZus{}SQL\PYGZus{}002: FATAL. Source file cannot be opened.}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{else}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{bMem} \PYG{o}{=} \PYG{n+nb}{true}\PYG{p}{;}
        \PYG{c+c1}{// copy the db from file into memory.}
        \PYG{n}{backupdb} \PYG{o}{=} \PYG{n}{sqlite3\PYGZus{}backup\PYGZus{}init}\PYG{p}{(}\PYG{n}{database}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{main}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{outdatabase}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{main}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
        \PYG{k+kt}{int} \PYG{n}{rc} \PYG{o}{=} \PYG{n}{sqlite3\PYGZus{}backup\PYGZus{}step}\PYG{p}{(}\PYG{n}{backupdb}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
        \PYG{c+c1}{// Revert to different VFS file opening method if the backup hasn\PYGZsq{}t started properly.}
        \PYG{c+c1}{// Two different versions will be attempted before an error will be thrown.}
        \PYG{c+c1}{// A different way of assigning the VFS method and opening the file correctly could be implemented later.}
        \PYG{c+c1}{// Currently \PYGZdq{}unix\PYGZhy{}dotfile\PYGZdq{} works for HPC runs and \PYGZdq{}unix\PYGZdq{} works for PC runs.}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{rc} \PYG{o}{!}\PYG{o}{=} \PYG{n}{SQLITE\PYGZus{}DONE} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{n}{rc} \PYG{o}{!}\PYG{o}{=} \PYG{n}{SQLITE\PYGZus{}OK}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{sqlite3\PYGZus{}close}\PYG{p}{(}\PYG{n}{outdatabase}\PYG{p}{)}\PYG{p}{;}
            \PYG{n}{sqlite3\PYGZus{}open}\PYG{p}{(}\PYG{n}{inputfile}\PYG{p}{.}\PYG{n}{c\PYGZus{}str}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{outdatabase}\PYG{p}{)}\PYG{p}{;}
            \PYG{n}{backupdb} \PYG{o}{=} \PYG{n}{sqlite3\PYGZus{}backup\PYGZus{}init}\PYG{p}{(}\PYG{n}{database}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{main}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{outdatabase}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{main}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{n}{rc} \PYG{o}{=} \PYG{n}{sqlite3\PYGZus{}backup\PYGZus{}finish}\PYG{p}{(}\PYG{n}{backupdb}\PYG{p}{)}\PYG{p}{;}
        \PYG{c+c1}{//          cout \PYGZlt{}\PYGZlt{} \PYGZdq{}rc: \PYGZdq{} \PYGZlt{}\PYGZlt{} rc \PYGZlt{}\PYGZlt{} endl;}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{rc} \PYG{o}{!}\PYG{o}{=} \PYG{n}{SQLITE\PYGZus{}DONE} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{n}{rc} \PYG{o}{!}\PYG{o}{=} \PYG{n}{SQLITE\PYGZus{}OK}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{k}{throw} \PYG{n}{SpeciesException}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ERROR\PYGZus{}SQL\PYGZus{}002: FATAL. Source file cannot be opened.}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
            \PYG{n}{sqlite3\PYGZus{}close}\PYG{p}{(}\PYG{n}{database}\PYG{p}{)}\PYG{p}{;}
            \PYG{n}{sqlite3\PYGZus{}close}\PYG{p}{(}\PYG{n}{outdatabase}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{n}{sqlite3\PYGZus{}close}\PYG{p}{(}\PYG{n}{outdatabase}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{c+c1}{// Now find out the max size of the list, so we have a count to work from}
    \PYG{n}{string} \PYG{n}{count\PYGZus{}command} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{SELECT MAX(ID) FROM SPECIES\PYGZus{}LIST;}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
    \PYG{n}{sqlite3\PYGZus{}prepare\PYGZus{}v2}\PYG{p}{(}\PYG{n}{database}\PYG{p}{,} \PYG{n}{count\PYGZus{}command}\PYG{p}{.}\PYG{n}{c\PYGZus{}str}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{n}{strlen}\PYG{p}{(}\PYG{n}{count\PYGZus{}command}\PYG{p}{.}\PYG{n}{c\PYGZus{}str}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{stmt}\PYG{p}{,} \PYG{n+nb}{NULL}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kt}{unsigned} \PYG{k+kt}{int} \PYG{n}{datasize}\PYG{p}{;}
    \PYG{c+c1}{// skip first row (should be blank)}
    \PYG{n}{sqlite3\PYGZus{}step}\PYG{p}{(}\PYG{n}{stmt}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{datasize} \PYG{o}{=} \PYG{n}{sqlite3\PYGZus{}column\PYGZus{}int}\PYG{p}{(}\PYG{n}{stmt}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}
    \PYG{c+c1}{//      cout \PYGZlt{}\PYGZlt{} \PYGZdq{}datasize: \PYGZdq{} \PYGZlt{}\PYGZlt{} datasize \PYGZlt{}\PYGZlt{} endl;}
    \PYG{c+c1}{// close the old statement}
    \PYG{n}{sqlite3\PYGZus{}finalize}\PYG{p}{(}\PYG{n}{stmt}\PYG{p}{)}\PYG{p}{;}

    \PYG{c+c1}{// Create db query}
    \PYG{n}{string} \PYG{n}{all\PYGZus{}commands} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{SELECT * FROM SPECIES\PYGZus{}LIST;}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
    \PYG{n}{sqlite3\PYGZus{}prepare\PYGZus{}v2}\PYG{p}{(}\PYG{n}{database}\PYG{p}{,} \PYG{n}{all\PYGZus{}commands}\PYG{p}{.}\PYG{n}{c\PYGZus{}str}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{n}{strlen}\PYG{p}{(}\PYG{n}{all\PYGZus{}commands}\PYG{p}{.}\PYG{n}{c\PYGZus{}str}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{stmt}\PYG{p}{,} \PYG{n+nb}{NULL}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{nodes}\PYG{p}{.}\PYG{n}{SetRowSize}\PYG{p}{(}\PYG{n}{datasize} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
    \PYG{c+c1}{//      cout \PYGZlt{}\PYGZlt{} endl \PYGZlt{}\PYGZlt{} \PYGZdq{}size: \PYGZdq{} \PYGZlt{}\PYGZlt{} datasize \PYGZlt{}\PYGZlt{} endl;}
    \PYG{c+c1}{//  sqlite3\PYGZus{}exec(database,\PYGZdq{}BEGIN TRANSACTION;\PYGZdq{},NULL,NULL,NULL);}
    \PYG{c+c1}{// Check that the file opened correclty.}
    \PYG{k}{if}\PYG{p}{(}\PYG{n}{o1} \PYG{o}{!}\PYG{o}{=} \PYG{n}{SQLITE\PYGZus{}OK} \PYG{o}{\textbar{}}\PYG{o}{\textbar{}} \PYG{n}{o2} \PYG{o}{!}\PYG{o}{=} \PYG{n}{SQLITE\PYGZus{}OK}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{throw} \PYG{n}{SpeciesException}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ERROR\PYGZus{}SQL\PYGZus{}002: FATAL. Source file cannot be opened.}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{n}{sqlite3\PYGZus{}step}\PYG{p}{(}\PYG{n}{stmt}\PYG{p}{)}\PYG{p}{;}
    \PYG{c+c1}{// Copy the data across to the Treenode data structure.}
    \PYG{c+c1}{// For storing the number of ignored lineages so this can be subtracted off the parent number.}
    \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{ignored\PYGZus{}lineages} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
    \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{n}{datasize}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{species\PYGZus{}id} \PYG{o}{=} \PYG{n}{sqlite3\PYGZus{}column\PYGZus{}int}\PYG{p}{(}\PYG{n}{stmt}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
        \PYG{c+c1}{//      cout \PYGZlt{}\PYGZlt{} species\PYGZus{}id \PYGZlt{}\PYGZlt{} endl;}
        \PYG{k+kt}{long} \PYG{n}{xval} \PYG{o}{=} \PYG{n}{sqlite3\PYGZus{}column\PYGZus{}int}\PYG{p}{(}\PYG{n}{stmt}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{;}
        \PYG{k+kt}{long} \PYG{n}{yval} \PYG{o}{=} \PYG{n}{sqlite3\PYGZus{}column\PYGZus{}int}\PYG{p}{(}\PYG{n}{stmt}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{;}
        \PYG{k+kt}{long} \PYG{n}{xwrap} \PYG{o}{=} \PYG{n}{sqlite3\PYGZus{}column\PYGZus{}int}\PYG{p}{(}\PYG{n}{stmt}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{;}
        \PYG{k+kt}{long} \PYG{n}{ywrap} \PYG{o}{=} \PYG{n}{sqlite3\PYGZus{}column\PYGZus{}int}\PYG{p}{(}\PYG{n}{stmt}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{;}
        \PYG{k+kt}{bool} \PYG{n}{tip} \PYG{o}{=} \PYG{k+kt}{bool}\PYG{p}{(}\PYG{n}{sqlite3\PYGZus{}column\PYGZus{}int}\PYG{p}{(}\PYG{n}{stmt}\PYG{p}{,} \PYG{l+m+mi}{6}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
        \PYG{k+kt}{bool} \PYG{n}{speciation} \PYG{o}{=} \PYG{k+kt}{bool}\PYG{p}{(}\PYG{n}{sqlite3\PYGZus{}column\PYGZus{}int}\PYG{p}{(}\PYG{n}{stmt}\PYG{p}{,} \PYG{l+m+mi}{7}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
        \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{parent} \PYG{o}{=} \PYG{n}{sqlite3\PYGZus{}column\PYGZus{}int}\PYG{p}{(}\PYG{n}{stmt}\PYG{p}{,} \PYG{l+m+mi}{8}\PYG{p}{)}\PYG{p}{;}
        \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{iGen} \PYG{o}{=} \PYG{n}{sqlite3\PYGZus{}column\PYGZus{}int}\PYG{p}{(}\PYG{n}{stmt}\PYG{p}{,} \PYG{l+m+mi}{11}\PYG{p}{)}\PYG{p}{;}
        \PYG{k+kt}{bool} \PYG{n}{existance} \PYG{o}{=} \PYG{k+kt}{bool}\PYG{p}{(}\PYG{n}{sqlite3\PYGZus{}column\PYGZus{}int}\PYG{p}{(}\PYG{n}{stmt}\PYG{p}{,} \PYG{l+m+mi}{9}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
        \PYG{k+kt}{double} \PYG{n}{dSpec} \PYG{o}{=} \PYG{n}{sqlite3\PYGZus{}column\PYGZus{}double}\PYG{p}{(}\PYG{n}{stmt}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{;}
        \PYG{k+kt}{long} \PYG{k+kt}{double} \PYG{n}{generationin} \PYG{o}{=} \PYG{n}{sqlite3\PYGZus{}column\PYGZus{}double}\PYG{p}{(}\PYG{n}{stmt}\PYG{p}{,} \PYG{l+m+mi}{12}\PYG{p}{)}\PYG{p}{;}
        \PYG{c+c1}{//          cout \PYGZlt{}\PYGZlt{} xval \PYGZlt{}\PYGZlt{} \PYGZdq{}, \PYGZdq{} \PYGZlt{}\PYGZlt{} yval \PYGZlt{}\PYGZlt{} endl;}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{tip} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{o}{!}\PYG{n}{samplemask}\PYG{p}{.}\PYG{n}{getVal}\PYG{p}{(}\PYG{n}{xval}\PYG{p}{,} \PYG{n}{yval}\PYG{p}{)} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{n}{generationin} \PYG{o}{\PYGZgt{}} \PYG{n}{generation} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{n+nb}{false}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{ignored\PYGZus{}lineages}\PYG{o}{+}\PYG{o}{+}\PYG{p}{;}
            \PYG{n}{sqlite3\PYGZus{}step}\PYG{p}{(}\PYG{n}{stmt}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{else}
        \PYG{p}{\PYGZob{}}
            \PYG{c+c1}{// the \PYGZhy{}1 is to ensure that the list includes all lineages, but fills the output from the beginning}
            \PYG{k+kt}{unsigned} \PYG{k+kt}{int} \PYG{n}{index} \PYG{o}{=} \PYG{n}{i} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{1} \PYG{o}{\PYGZhy{}} \PYG{n}{ignored\PYGZus{}lineages}\PYG{p}{;}
            \PYG{n}{nodes}\PYG{p}{[}\PYG{n}{index}\PYG{p}{]}\PYG{p}{.}\PYG{n}{setup}\PYG{p}{(}\PYG{n}{tip}\PYG{p}{,} \PYG{n}{xval}\PYG{p}{,} \PYG{n}{yval}\PYG{p}{,} \PYG{n}{xwrap}\PYG{p}{,} \PYG{n}{ywrap}\PYG{p}{,} \PYG{n}{generationin}\PYG{p}{)}\PYG{p}{;}
            \PYG{n}{nodes}\PYG{p}{[}\PYG{n}{index}\PYG{p}{]}\PYG{p}{.}\PYG{n}{burnSpecies}\PYG{p}{(}\PYG{n}{species\PYGZus{}id}\PYG{p}{)}\PYG{p}{;}
            \PYG{n}{nodes}\PYG{p}{[}\PYG{n}{index}\PYG{p}{]}\PYG{p}{.}\PYG{n}{setSpec}\PYG{p}{(}\PYG{n}{dSpec}\PYG{p}{)}\PYG{p}{;}
            \PYG{n}{nodes}\PYG{p}{[}\PYG{n}{index}\PYG{p}{]}\PYG{p}{.}\PYG{n}{setExistance}\PYG{p}{(}\PYG{n}{existance}\PYG{p}{)}\PYG{p}{;}
            \PYG{n}{nodes}\PYG{p}{[}\PYG{n}{index}\PYG{p}{]}\PYG{p}{.}\PYG{n}{setIGen}\PYG{p}{(}\PYG{n}{iGen}\PYG{p}{)}\PYG{p}{;}
            \PYG{n}{nodes}\PYG{p}{[}\PYG{n}{index}\PYG{p}{]}\PYG{p}{.}\PYG{n}{setParent}\PYG{p}{(}\PYG{n}{parent} \PYG{o}{\PYGZhy{}} \PYG{n}{ignored\PYGZus{}lineages}\PYG{p}{)}\PYG{p}{;}
            \PYG{k}{if}\PYG{p}{(}\PYG{n}{index} \PYG{o}{=}\PYG{o}{=} \PYG{n}{parent} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{n}{parent} \PYG{o}{!}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{n}{cerr} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ i: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{index} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ parent: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{parent} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
                \PYG{n}{cerr} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ERROR\PYGZus{}SQL\PYGZus{}001: Import failed as parent is self. Check import function.}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
            \PYG{n}{nodes}\PYG{p}{[}\PYG{n}{index}\PYG{p}{]}\PYG{p}{.}\PYG{n}{setSpeciation}\PYG{p}{(}\PYG{n}{speciation}\PYG{p}{)}\PYG{p}{;}
            \PYG{n}{sqlite3\PYGZus{}step}\PYG{p}{(}\PYG{n}{stmt}\PYG{p}{)}\PYG{p}{;}
            \PYG{k}{if}\PYG{p}{(}\PYG{n}{parent} \PYG{o}{\PYGZlt{}} \PYG{n}{index} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{o}{!}\PYG{n}{speciation}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{n}{cerr} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{parent: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{parent} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ index: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{index} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
                \PYG{n}{cerr} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Parent before index error. Check program.}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
        \PYG{p}{\PYGZcb{}}
    \PYG{p}{\PYGZcb{}}
    \PYG{c+c1}{// Now we need to blank all objects}
    \PYG{n}{sqlite3\PYGZus{}finalize}\PYG{p}{(}\PYG{n}{stmt}\PYG{p}{)}\PYG{p}{;}
    \PYG{c+c1}{// Now read the useful information from the SIMULATION\PYGZus{}PARAMETERS table}
    \PYG{k}{try}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{sqlite3\PYGZus{}stmt}\PYG{o}{*} \PYG{n}{stmt2}\PYG{p}{;}
        \PYG{n}{string} \PYG{n}{sql\PYGZus{}parameters} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{SELECT spec\PYGZus{}rate, grid\PYGZus{}x,grid\PYGZus{}y FROM SIMULATION\PYGZus{}PARAMETERS;}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
        \PYG{k+kt}{int} \PYG{n}{rc} \PYG{o}{=} \PYG{n}{sqlite3\PYGZus{}prepare\PYGZus{}v2}\PYG{p}{(}\PYG{n}{database}\PYG{p}{,} \PYG{n}{sql\PYGZus{}parameters}\PYG{p}{.}\PYG{n}{c\PYGZus{}str}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{n}{strlen}\PYG{p}{(}\PYG{n}{sql\PYGZus{}parameters}\PYG{p}{.}\PYG{n}{c\PYGZus{}str}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{stmt2}\PYG{p}{,} \PYG{n+nb}{NULL}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{rc} \PYG{o}{!}\PYG{o}{=} \PYG{n}{SQLITE\PYGZus{}DONE} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{n}{rc} \PYG{o}{!}\PYG{o}{=} \PYG{n}{SQLITE\PYGZus{}OK}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{sqlite3\PYGZus{}close}\PYG{p}{(}\PYG{n}{database}\PYG{p}{)}\PYG{p}{;}
            \PYG{n}{sqlite3\PYGZus{}close}\PYG{p}{(}\PYG{n}{outdatabase}\PYG{p}{)}\PYG{p}{;}
            \PYG{k}{throw} \PYG{n+nf}{SpeciesException}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ERROR\PYGZus{}SQL\PYGZus{}020: FATAL. Could not open simulation parameters.}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
            \PYG{c+c1}{//              exit(EXIT\PYGZus{}FAILURE);}
        \PYG{p}{\PYGZcb{}}
        \PYG{n}{sqlite3\PYGZus{}step}\PYG{p}{(}\PYG{n}{stmt2}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{min\PYGZus{}spec\PYGZus{}rate} \PYG{o}{=} \PYG{n}{sqlite3\PYGZus{}column\PYGZus{}double}\PYG{p}{(}\PYG{n}{stmt2}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}
        \PYG{c+c1}{//          cout \PYGZlt{}\PYGZlt{} sql\PYGZus{}parameters \PYGZlt{}\PYGZlt{} endl;}
        \PYG{c+c1}{//          cout \PYGZlt{}\PYGZlt{} sqlite3\PYGZus{}column\PYGZus{}double(stmt2,0) \PYGZlt{}\PYGZlt{} endl;}
        \PYG{c+c1}{//          cout \PYGZlt{}\PYGZlt{} sqlite3\PYGZus{}column\PYGZus{}int(stmt2,2) \PYGZlt{}\PYGZlt{} endl;}
        \PYG{n}{grid\PYGZus{}x\PYGZus{}size} \PYG{o}{=} \PYG{n}{sqlite3\PYGZus{}column\PYGZus{}int}\PYG{p}{(}\PYG{n}{stmt2}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{grid\PYGZus{}y\PYGZus{}size} \PYG{o}{=} \PYG{n}{sqlite3\PYGZus{}column\PYGZus{}int}\PYG{p}{(}\PYG{n}{stmt2}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{;}
        \PYG{c+c1}{//          cout \PYGZlt{}\PYGZlt{} \PYGZdq{}min: \PYGZdq{} \PYGZlt{}\PYGZlt{} min\PYGZus{}spec\PYGZus{}rate \PYGZlt{}\PYGZlt{} endl \PYGZlt{}\PYGZlt{} \PYGZdq{}x,y: \PYGZdq{} \PYGZlt{}\PYGZlt{} grid\PYGZus{}x\PYGZus{}size \PYGZlt{}\PYGZlt{} \PYGZdq{},\PYGZdq{} \PYGZlt{}\PYGZlt{} grid\PYGZus{}y\PYGZus{}size \PYGZlt{}\PYGZlt{}}
        \PYG{c+c1}{//endl;}
        \PYG{n}{sqlite3\PYGZus{}step}\PYG{p}{(}\PYG{n}{stmt2}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{sqlite3\PYGZus{}finalize}\PYG{p}{(}\PYG{n}{stmt2}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}r}\PYG{l+s}{Beginning data import...}\PYG{l+s}{\PYGZdq{}}
             \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{done             }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{catch}\PYG{p}{(}\PYG{n}{exception}\PYG{o}{\PYGZam{}} \PYG{n}{er}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{throw} \PYG{n}{SpeciesException}\PYG{p}{(}\PYG{n}{er}\PYG{p}{.}\PYG{n}{what}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{void} \PYG{n}{Treelist}\PYG{o}{:}\PYG{o}{:}\PYG{n}{setGeneration}\PYG{p}{(}\PYG{k+kt}{long} \PYG{k+kt}{double} \PYG{n}{generationin}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{n}{generation} \PYG{o}{=} \PYG{n}{generationin}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{void} \PYG{n}{Treelist}\PYG{o}{:}\PYG{o}{:}\PYG{n}{createDatabase}\PYG{p}{(}\PYG{k+kt}{double} \PYG{n}{s}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Calculating tree structure...}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{flush}\PYG{p}{;}
    \PYG{k}{if}\PYG{p}{(}\PYG{n}{s} \PYG{o}{\PYGZlt{}} \PYG{n}{min\PYGZus{}spec\PYGZus{}rate} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{n}{s} \PYG{o}{!}\PYG{o}{=} \PYG{n}{min\PYGZus{}spec\PYGZus{}rate}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{cerr} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{s: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{s} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
        \PYG{n}{cerr} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{min\PYGZus{}spec: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{min\PYGZus{}spec\PYGZus{}rate} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
        \PYG{k}{throw} \PYG{n+nf}{SpeciesException}\PYG{p}{(}
            \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ERROR\PYGZus{}SQL\PYGZus{}018: Speciation rate is less than the minimum speciation rate. Skipping.}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{else}
    \PYG{p}{\PYGZob{}}
        \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{nspec} \PYG{o}{=} \PYG{n}{calcSpecies}\PYG{p}{(}\PYG{n}{s}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{calcSpeciesAbundance}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{done!}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
        \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Number of species: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{nspec} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
        \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Generating new SQL table for speciation rate }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{s} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{...}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{flush}\PYG{p}{;}
        \PYG{n}{string} \PYG{n}{table\PYGZus{}command} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{CREATE TABLE IF NOT EXISTS SPECIES\PYGZus{}ABUNDANCES (ID TEXT PRIMARY KEY NOT NULL, }\PYG{l+s}{\PYGZdq{}}
                               \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{species\PYGZus{}id INT NOT NULL, speciation\PYGZus{}rate DOUBLE NOT NULL, no\PYGZus{}individuals INT NOT }\PYG{l+s}{\PYGZdq{}}
                               \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{NULL,generation DOUBLE NOT NULL);}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
        \PYG{k+kt}{int} \PYG{n}{rc} \PYG{o}{=} \PYG{n}{sqlite3\PYGZus{}exec}\PYG{p}{(}\PYG{n}{database}\PYG{p}{,} \PYG{n}{table\PYGZus{}command}\PYG{p}{.}\PYG{n}{c\PYGZus{}str}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{n+nb}{NULL}\PYG{p}{,} \PYG{n+nb}{NULL}\PYG{p}{,} \PYG{n+nb}{NULL}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{rc} \PYG{o}{!}\PYG{o}{=} \PYG{n}{SQLITE\PYGZus{}OK}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{k}{throw} \PYG{n}{SpeciesException}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ERROR\PYGZus{}SQL\PYGZus{}002b: Could not create SPECIES\PYGZus{}ABUNDANCES table.}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}

        \PYG{n}{sqlite3\PYGZus{}stmt}\PYG{o}{*} \PYG{n}{stmt}\PYG{p}{;}
        \PYG{n}{table\PYGZus{}command} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{INSERT INTO SPECIES\PYGZus{}ABUNDANCES (ID,species\PYGZus{}id, speciation\PYGZus{}rate, }\PYG{l+s}{\PYGZdq{}}
                        \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{no\PYGZus{}individuals,generation) VALUES (?,?,?,?,?);}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
        \PYG{n}{sqlite3\PYGZus{}prepare\PYGZus{}v2}\PYG{p}{(}\PYG{n}{database}\PYG{p}{,} \PYG{n}{table\PYGZus{}command}\PYG{p}{.}\PYG{n}{c\PYGZus{}str}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{n}{strlen}\PYG{p}{(}\PYG{n}{table\PYGZus{}command}\PYG{p}{.}\PYG{n}{c\PYGZus{}str}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{stmt}\PYG{p}{,} \PYG{n+nb}{NULL}\PYG{p}{)}\PYG{p}{;}

        \PYG{c+c1}{// Start the transaction}
        \PYG{n}{sqlite3\PYGZus{}exec}\PYG{p}{(}\PYG{n}{database}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{BEGIN TRANSACTION;}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n+nb}{NULL}\PYG{p}{,} \PYG{n+nb}{NULL}\PYG{p}{,} \PYG{n+nb}{NULL}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{rOut}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{c+c1}{// only do all the export itself if the value of i is not 0}
            \PYG{c+c1}{// if(rOut[i] != 0)}
            \PYG{c+c1}{//\PYGZob{}}
            \PYG{n}{string} \PYG{n}{id\PYGZus{}var} \PYG{o}{=} \PYG{n}{boost}\PYG{o}{:}\PYG{o}{:}\PYG{n}{lexical\PYGZus{}cast}\PYG{o}{\PYGZlt{}}\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{string}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{n}{dSpecRate}\PYG{p}{)} \PYG{o}{+} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZhy{}}\PYG{l+s}{\PYGZdq{}} \PYG{o}{+}
                            \PYG{n}{to\PYGZus{}string}\PYG{p}{(}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{k+kt}{long}\PYG{p}{)}\PYG{n}{i}\PYG{p}{)} \PYG{o}{+} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZus{}}\PYG{l+s}{\PYGZdq{}} \PYG{o}{+} \PYG{n}{to\PYGZus{}string}\PYG{p}{(}\PYG{p}{(}\PYG{k+kt}{long} \PYG{k+kt}{double}\PYG{p}{)}\PYG{n}{generation}\PYG{p}{)}\PYG{p}{;}
            \PYG{c+c1}{// fixed precision problem \PYGZhy{} lexical cast allows for printing of very small doubles.}
            \PYG{n}{sqlite3\PYGZus{}bind\PYGZus{}text}\PYG{p}{(}\PYG{n}{stmt}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{id\PYGZus{}var}\PYG{p}{.}\PYG{n}{c\PYGZus{}str}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{SQLITE\PYGZus{}STATIC}\PYG{p}{)}\PYG{p}{;}
            \PYG{n}{sqlite3\PYGZus{}bind\PYGZus{}int}\PYG{p}{(}\PYG{n}{stmt}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{i}\PYG{p}{)}\PYG{p}{;}
            \PYG{n}{sqlite3\PYGZus{}bind\PYGZus{}double}\PYG{p}{(}\PYG{n}{stmt}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{n}{dSpecRate}\PYG{p}{)}\PYG{p}{;}
            \PYG{n}{sqlite3\PYGZus{}bind\PYGZus{}int}\PYG{p}{(}\PYG{n}{stmt}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{n}{rOut}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
            \PYG{n}{sqlite3\PYGZus{}bind\PYGZus{}double}\PYG{p}{(}\PYG{n}{stmt}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{,} \PYG{n}{generation}\PYG{p}{)}\PYG{p}{;}
            \PYG{k+kt}{int} \PYG{n}{step} \PYG{o}{=} \PYG{n}{sqlite3\PYGZus{}step}\PYG{p}{(}\PYG{n}{stmt}\PYG{p}{)}\PYG{p}{;}
            \PYG{c+c1}{// makes sure the while loop doesn\PYGZsq{}t go forever.}
            \PYG{k+kt}{time\PYGZus{}t} \PYG{n}{start\PYGZus{}check}\PYG{p}{,} \PYG{n}{end\PYGZus{}check}\PYG{p}{;}
            \PYG{n}{time}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{start\PYGZus{}check}\PYG{p}{)}\PYG{p}{;}
            \PYG{n}{time}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{end\PYGZus{}check}\PYG{p}{)}\PYG{p}{;}
            \PYG{k}{while}\PYG{p}{(}\PYG{n}{step} \PYG{o}{!}\PYG{o}{=} \PYG{n}{SQLITE\PYGZus{}DONE} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{p}{(}\PYG{n}{end\PYGZus{}check} \PYG{o}{\PYGZhy{}} \PYG{n}{start\PYGZus{}check}\PYG{p}{)} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{1}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{n}{step} \PYG{o}{=} \PYG{n}{sqlite3\PYGZus{}step}\PYG{p}{(}\PYG{n}{stmt}\PYG{p}{)}\PYG{p}{;}
                \PYG{n}{time}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{end\PYGZus{}check}\PYG{p}{)}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
            \PYG{k}{if}\PYG{p}{(}\PYG{n}{step} \PYG{o}{!}\PYG{o}{=} \PYG{n}{SQLITE\PYGZus{}DONE}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
\PYG{c+c1}{//              cout \PYGZlt{}\PYGZlt{} endl \PYGZlt{}\PYGZlt{} rOut[i] \PYGZlt{}\PYGZlt{} endl;}
\PYG{c+c1}{//              cout \PYGZlt{}\PYGZlt{} generation \PYGZlt{}\PYGZlt{} endl;}
\PYG{c+c1}{//              cout \PYGZlt{}\PYGZlt{} i \PYGZlt{}\PYGZlt{} endl;}
\PYG{c+c1}{//              cout \PYGZlt{}\PYGZlt{} dSpecRate \PYGZlt{}\PYGZlt{} endl;}
\PYG{c+c1}{//              cout \PYGZlt{}\PYGZlt{} id\PYGZus{}var \PYGZlt{}\PYGZlt{} endl;}
                \PYG{n}{cerr} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{SQLITE error code: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{step} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
                \PYG{n}{cerr} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ERROR\PYGZus{}SQL\PYGZus{}004: Could not insert into database. Check destination file has not }\PYG{l+s}{\PYGZdq{}}
                        \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{been moved or deleted and that an entry doesn\PYGZsq{}t already exist with the same ID.}\PYG{l+s}{\PYGZdq{}}
                     \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
                \PYG{n}{sqlite3\PYGZus{}clear\PYGZus{}bindings}\PYG{p}{(}\PYG{n}{stmt}\PYG{p}{)}\PYG{p}{;}
                \PYG{n}{sqlite3\PYGZus{}reset}\PYG{p}{(}\PYG{n}{stmt}\PYG{p}{)}\PYG{p}{;}
                \PYG{k}{break}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
            \PYG{n}{sqlite3\PYGZus{}clear\PYGZus{}bindings}\PYG{p}{(}\PYG{n}{stmt}\PYG{p}{)}\PYG{p}{;}
            \PYG{n}{sqlite3\PYGZus{}reset}\PYG{p}{(}\PYG{n}{stmt}\PYG{p}{)}\PYG{p}{;}
            \PYG{c+c1}{//\PYGZcb{}}
        \PYG{p}{\PYGZcb{}}

        \PYG{c+c1}{// execute the command and close the connection to the database}
        \PYG{k+kt}{int} \PYG{n}{rc1} \PYG{o}{=} \PYG{n}{sqlite3\PYGZus{}exec}\PYG{p}{(}\PYG{n}{database}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{END TRANSACTION;}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n+nb}{NULL}\PYG{p}{,} \PYG{n+nb}{NULL}\PYG{p}{,} \PYG{n+nb}{NULL}\PYG{p}{)}\PYG{p}{;}
        \PYG{c+c1}{// Need to finalise the statement}
        \PYG{k+kt}{int} \PYG{n}{rc2} \PYG{o}{=} \PYG{n}{sqlite3\PYGZus{}finalize}\PYG{p}{(}\PYG{n}{stmt}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{rc1} \PYG{o}{!}\PYG{o}{=} \PYG{n}{SQLITE\PYGZus{}OK} \PYG{o}{\textbar{}}\PYG{o}{\textbar{}} \PYG{n}{rc2} \PYG{o}{!}\PYG{o}{=} \PYG{n}{SQLITE\PYGZus{}OK}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{cerr} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ERROR\PYGZus{}SQL\PYGZus{}013: Could not complete SQL transaction. Check memory database assignment and }\PYG{l+s}{\PYGZdq{}}
                    \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{SQL commands. Ensure SQL statements are properly cleared and that you are not attempting }\PYG{l+s}{\PYGZdq{}}
                    \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{to insert repeat IDs into the database.}\PYG{l+s}{\PYGZdq{}}
                 \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{else}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}r}\PYG{l+s}{Generating new SQL table for speciation rate }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{s} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{...done!}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
    \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{void} \PYG{n}{Treelist}\PYG{o}{:}\PYG{o}{:}\PYG{n}{createFragmentDatabase}\PYG{p}{(}\PYG{k}{const} \PYG{n}{Fragment}\PYG{o}{\PYGZam{}} \PYG{n}{f}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{c+c1}{//      cout \PYGZlt{}\PYGZlt{} \PYGZdq{}Generating new SQL table for speciation rate \PYGZdq{} \PYGZlt{}\PYGZlt{} s \PYGZlt{}\PYGZlt{} \PYGZdq{}...\PYGZdq{} \PYGZlt{}\PYGZlt{} flush;}
    \PYG{n}{string} \PYG{n}{table\PYGZus{}command} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{CREATE TABLE IF NOT EXISTS FRAGMENT\PYGZus{}ABUNDANCES (ID TEXT PRIMARY KEY NOT NULL, fragment }\PYG{l+s}{\PYGZdq{}}
                           \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{TEXT NOT NULL, area DOUBLE NOT NULL, size INT NOT NULL,  species\PYGZus{}id INT NOT NULL, }\PYG{l+s}{\PYGZdq{}}
                           \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{speciation\PYGZus{}rate DOUBLE NOT NULL, no\PYGZus{}individuals INT NOT NULL,generation DOUBLE NOT NULL);}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
    \PYG{n}{sqlite3\PYGZus{}exec}\PYG{p}{(}\PYG{n}{database}\PYG{p}{,} \PYG{n}{table\PYGZus{}command}\PYG{p}{.}\PYG{n}{c\PYGZus{}str}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{n+nb}{NULL}\PYG{p}{,} \PYG{n+nb}{NULL}\PYG{p}{,} \PYG{n+nb}{NULL}\PYG{p}{)}\PYG{p}{;}

    \PYG{n}{sqlite3\PYGZus{}stmt}\PYG{o}{*} \PYG{n}{stmt}\PYG{p}{;}
    \PYG{n}{table\PYGZus{}command} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{INSERT INTO FRAGMENT\PYGZus{}ABUNDANCES (ID, fragment, area, size, species\PYGZus{}id, speciation\PYGZus{}rate, }\PYG{l+s}{\PYGZdq{}}
                    \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{no\PYGZus{}individuals,generation) VALUES (?,?,?,?,?,?,?,?);}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
    \PYG{n}{sqlite3\PYGZus{}prepare\PYGZus{}v2}\PYG{p}{(}\PYG{n}{database}\PYG{p}{,} \PYG{n}{table\PYGZus{}command}\PYG{p}{.}\PYG{n}{c\PYGZus{}str}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{n}{strlen}\PYG{p}{(}\PYG{n}{table\PYGZus{}command}\PYG{p}{.}\PYG{n}{c\PYGZus{}str}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{stmt}\PYG{p}{,} \PYG{n+nb}{NULL}\PYG{p}{)}\PYG{p}{;}

    \PYG{c+c1}{// Start the transaction}
    \PYG{n}{sqlite3\PYGZus{}exec}\PYG{p}{(}\PYG{n}{database}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{BEGIN TRANSACTION;}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n+nb}{NULL}\PYG{p}{,} \PYG{n+nb}{NULL}\PYG{p}{,} \PYG{n+nb}{NULL}\PYG{p}{)}\PYG{p}{;}
    \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{rOut}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{rOut}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{!}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{string} \PYG{n}{id\PYGZus{}var} \PYG{o}{=} \PYG{n}{boost}\PYG{o}{:}\PYG{o}{:}\PYG{n}{lexical\PYGZus{}cast}\PYG{o}{\PYGZlt{}}\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{string}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{n}{dSpecRate}\PYG{p}{)} \PYG{o}{+} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZus{}}\PYG{l+s}{\PYGZdq{}} \PYG{o}{+} \PYG{n}{f}\PYG{p}{.}\PYG{n}{name} \PYG{o}{+} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZus{}}\PYG{l+s}{\PYGZdq{}} \PYG{o}{+}
                            \PYG{n}{to\PYGZus{}string}\PYG{p}{(}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{k+kt}{long}\PYG{p}{)}\PYG{n}{i}\PYG{p}{)} \PYG{o}{+} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZus{}}\PYG{l+s}{\PYGZdq{}} \PYG{o}{+} \PYG{n}{to\PYGZus{}string}\PYG{p}{(}\PYG{p}{(}\PYG{k+kt}{long} \PYG{k+kt}{double}\PYG{p}{)}\PYG{n}{generation}\PYG{p}{)}\PYG{p}{;}
            \PYG{c+c1}{// fixed precision problem \PYGZhy{} lexical cast allows for printing of very small doubles.}
            \PYG{n}{sqlite3\PYGZus{}bind\PYGZus{}text}\PYG{p}{(}\PYG{n}{stmt}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{id\PYGZus{}var}\PYG{p}{.}\PYG{n}{c\PYGZus{}str}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{SQLITE\PYGZus{}STATIC}\PYG{p}{)}\PYG{p}{;}
            \PYG{n}{sqlite3\PYGZus{}bind\PYGZus{}text}\PYG{p}{(}\PYG{n}{stmt}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{f}\PYG{p}{.}\PYG{n}{name}\PYG{p}{.}\PYG{n}{c\PYGZus{}str}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{SQLITE\PYGZus{}STATIC}\PYG{p}{)}\PYG{p}{;}
            \PYG{n}{sqlite3\PYGZus{}bind\PYGZus{}double}\PYG{p}{(}\PYG{n}{stmt}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{n}{f}\PYG{p}{.}\PYG{n}{area}\PYG{p}{)}\PYG{p}{;}
            \PYG{n}{sqlite3\PYGZus{}bind\PYGZus{}int}\PYG{p}{(}\PYG{n}{stmt}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{n}{f}\PYG{p}{.}\PYG{n}{num}\PYG{p}{)}\PYG{p}{;}
            \PYG{n}{sqlite3\PYGZus{}bind\PYGZus{}int}\PYG{p}{(}\PYG{n}{stmt}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{,} \PYG{n}{i}\PYG{p}{)}\PYG{p}{;}
            \PYG{n}{sqlite3\PYGZus{}bind\PYGZus{}double}\PYG{p}{(}\PYG{n}{stmt}\PYG{p}{,} \PYG{l+m+mi}{6}\PYG{p}{,} \PYG{n}{dSpecRate}\PYG{p}{)}\PYG{p}{;}
            \PYG{n}{sqlite3\PYGZus{}bind\PYGZus{}int}\PYG{p}{(}\PYG{n}{stmt}\PYG{p}{,} \PYG{l+m+mi}{7}\PYG{p}{,} \PYG{n}{rOut}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
            \PYG{n}{sqlite3\PYGZus{}bind\PYGZus{}double}\PYG{p}{(}\PYG{n}{stmt}\PYG{p}{,} \PYG{l+m+mi}{8}\PYG{p}{,} \PYG{n}{generation}\PYG{p}{)}\PYG{p}{;}
            \PYG{k+kt}{int} \PYG{n}{step} \PYG{o}{=} \PYG{n}{sqlite3\PYGZus{}step}\PYG{p}{(}\PYG{n}{stmt}\PYG{p}{)}\PYG{p}{;}
            \PYG{c+c1}{// makes sure the while loop doesn\PYGZsq{}t go forever.}
            \PYG{k+kt}{time\PYGZus{}t} \PYG{n}{start\PYGZus{}check}\PYG{p}{,} \PYG{n}{end\PYGZus{}check}\PYG{p}{;}
            \PYG{n}{time}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{start\PYGZus{}check}\PYG{p}{)}\PYG{p}{;}
            \PYG{n}{time}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{end\PYGZus{}check}\PYG{p}{)}\PYG{p}{;}
            \PYG{k}{while}\PYG{p}{(}\PYG{n}{step} \PYG{o}{!}\PYG{o}{=} \PYG{n}{SQLITE\PYGZus{}DONE} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{p}{(}\PYG{n}{end\PYGZus{}check} \PYG{o}{\PYGZhy{}} \PYG{n}{start\PYGZus{}check}\PYG{p}{)} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{10}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{n}{step} \PYG{o}{=} \PYG{n}{sqlite3\PYGZus{}step}\PYG{p}{(}\PYG{n}{stmt}\PYG{p}{)}\PYG{p}{;}
                \PYG{n}{time}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{end\PYGZus{}check}\PYG{p}{)}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
            \PYG{k}{if}\PYG{p}{(}\PYG{n}{step} \PYG{o}{!}\PYG{o}{=} \PYG{n}{SQLITE\PYGZus{}DONE}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{n}{cerr} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{SQLITE error code: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{step} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
                \PYG{n}{cerr} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ERROR\PYGZus{}SQL\PYGZus{}004: Could not insert into database. Check destination file has not }\PYG{l+s}{\PYGZdq{}}
                        \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{been moved or deleted and that an entry doesn\PYGZsq{}t already exist with the same ID.}\PYG{l+s}{\PYGZdq{}}
                     \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
                \PYG{n}{sqlite3\PYGZus{}clear\PYGZus{}bindings}\PYG{p}{(}\PYG{n}{stmt}\PYG{p}{)}\PYG{p}{;}
                \PYG{n}{sqlite3\PYGZus{}reset}\PYG{p}{(}\PYG{n}{stmt}\PYG{p}{)}\PYG{p}{;}
                \PYG{k}{break}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
            \PYG{n}{sqlite3\PYGZus{}clear\PYGZus{}bindings}\PYG{p}{(}\PYG{n}{stmt}\PYG{p}{)}\PYG{p}{;}
            \PYG{n}{sqlite3\PYGZus{}reset}\PYG{p}{(}\PYG{n}{stmt}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
    \PYG{p}{\PYGZcb{}}
    \PYG{c+c1}{// execute the command and close the connection to the database}
    \PYG{k+kt}{int} \PYG{n}{rc1} \PYG{o}{=} \PYG{n}{sqlite3\PYGZus{}exec}\PYG{p}{(}\PYG{n}{database}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{END TRANSACTION;}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n+nb}{NULL}\PYG{p}{,} \PYG{n+nb}{NULL}\PYG{p}{,} \PYG{n+nb}{NULL}\PYG{p}{)}\PYG{p}{;}
    \PYG{c+c1}{// Need to finalise the statement}
    \PYG{k+kt}{int} \PYG{n}{rc2} \PYG{o}{=} \PYG{n}{sqlite3\PYGZus{}finalize}\PYG{p}{(}\PYG{n}{stmt}\PYG{p}{)}\PYG{p}{;}
    \PYG{k}{if}\PYG{p}{(}\PYG{n}{rc1} \PYG{o}{!}\PYG{o}{=} \PYG{n}{SQLITE\PYGZus{}OK} \PYG{o}{\textbar{}}\PYG{o}{\textbar{}} \PYG{n}{rc2} \PYG{o}{!}\PYG{o}{=} \PYG{n}{SQLITE\PYGZus{}OK}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{cerr} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ERROR\PYGZus{}SQL\PYGZus{}013: Could not complete SQL transaction. Check memory database assignment and SQL }\PYG{l+s}{\PYGZdq{}}
                \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{commands. Ensure SQL statements are properly cleared and that you are not attempting to insert }\PYG{l+s}{\PYGZdq{}}
                \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{repeat IDs into the database.}\PYG{l+s}{\PYGZdq{}}
             \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{else}
    \PYG{p}{\PYGZob{}}
        \PYG{c+c1}{//          cout \PYGZlt{}\PYGZlt{} \PYGZdq{}\PYGZbs{}rGenerating new SQL table for speciation rate \PYGZdq{} \PYGZlt{}\PYGZlt{} s \PYGZlt{}\PYGZlt{} \PYGZdq{}...done!\PYGZdq{} \PYGZlt{}\PYGZlt{} endl;}
    \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{void} \PYG{n}{Treelist}\PYG{o}{:}\PYG{o}{:}\PYG{n}{exportDatabase}\PYG{p}{(}\PYG{n}{string} \PYG{n}{outputfile}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k}{if}\PYG{p}{(}\PYG{n}{bMem}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Writing out to }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{outputfile} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{...}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{flush}\PYG{p}{;}
        \PYG{c+c1}{// Now write the database to the file object.}
        \PYG{n}{sqlite3}\PYG{o}{*} \PYG{n}{outdatabase}\PYG{p}{;}

        \PYG{k+kt}{int} \PYG{n}{rc} \PYG{o}{=} \PYG{n}{sqlite3\PYGZus{}open\PYGZus{}v2}\PYG{p}{(}\PYG{n}{outputfile}\PYG{p}{.}\PYG{n}{c\PYGZus{}str}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{outdatabase}\PYG{p}{,} \PYG{n}{SQLITE\PYGZus{}OPEN\PYGZus{}READWRITE}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{unix\PYGZhy{}dotfile}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
        \PYG{c+c1}{// check that the connection to file has opened correctly}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{rc} \PYG{o}{!}\PYG{o}{=} \PYG{n}{SQLITE\PYGZus{}OK} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{n}{rc} \PYG{o}{!}\PYG{o}{=} \PYG{n}{SQLITE\PYGZus{}DONE}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{c+c1}{// attempt other output method}
            \PYG{n}{sqlite3\PYGZus{}close}\PYG{p}{(}\PYG{n}{outdatabase}\PYG{p}{)}\PYG{p}{;}
            \PYG{n}{rc} \PYG{o}{=} \PYG{n}{sqlite3\PYGZus{}open}\PYG{p}{(}\PYG{n}{outputfile}\PYG{p}{.}\PYG{n}{c\PYGZus{}str}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{outdatabase}\PYG{p}{)}\PYG{p}{;}
            \PYG{k}{if}\PYG{p}{(}\PYG{n}{rc} \PYG{o}{!}\PYG{o}{=} \PYG{n}{SQLITE\PYGZus{}OK} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{n}{rc} \PYG{o}{!}\PYG{o}{=} \PYG{n}{SQLITE\PYGZus{}DONE}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{n}{cerr} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ERROR\PYGZus{}SQL\PYGZus{}016: Connection to output database cannot be opened. Check write access }\PYG{l+s}{\PYGZdq{}}
                        \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{on output folder. Error code: }\PYG{l+s}{\PYGZdq{}}
                     \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{rc} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{.}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
        \PYG{p}{\PYGZcb{}}

        \PYG{c+c1}{// create the backup object to write data to the file from memory.}

        \PYG{n}{sqlite3\PYGZus{}backup}\PYG{o}{*} \PYG{n}{backupdb}\PYG{p}{;}
        \PYG{n}{backupdb} \PYG{o}{=} \PYG{n}{sqlite3\PYGZus{}backup\PYGZus{}init}\PYG{p}{(}\PYG{n}{outdatabase}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{main}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{database}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{main}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{if}\PYG{p}{(}\PYG{o}{!}\PYG{n}{backupdb}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{cerr} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ERROR\PYGZus{}SQL\PYGZus{}003: Could not backup to SQL database. Check destination file has not been }\PYG{l+s}{\PYGZdq{}}
                    \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{moved or deleted.}\PYG{l+s}{\PYGZdq{}}
                 \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{c+c1}{// Perform the backup}
        \PYG{n}{rc} \PYG{o}{=} \PYG{n}{sqlite3\PYGZus{}backup\PYGZus{}step}\PYG{p}{(}\PYG{n}{backupdb}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{rc} \PYG{o}{!}\PYG{o}{=} \PYG{n}{SQLITE\PYGZus{}OK} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{n}{rc} \PYG{o}{!}\PYG{o}{=} \PYG{n}{SQLITE\PYGZus{}DONE}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{cerr} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ERROR\PYGZus{}SQL\PYGZus{}016: Connection to output database cannot be opened. Check write access on }\PYG{l+s}{\PYGZdq{}}
                    \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{output folder. Error code: }\PYG{l+s}{\PYGZdq{}}
                 \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{rc} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{.}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{n}{rc} \PYG{o}{=} \PYG{n}{sqlite3\PYGZus{}backup\PYGZus{}finish}\PYG{p}{(}\PYG{n}{backupdb}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{rc} \PYG{o}{!}\PYG{o}{=} \PYG{n}{SQLITE\PYGZus{}OK} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{n}{rc} \PYG{o}{!}\PYG{o}{=} \PYG{n}{SQLITE\PYGZus{}DONE}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{cerr} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ERROR\PYGZus{}SQL\PYGZus{}016: Connection to output database cannot be opened. Check write access on }\PYG{l+s}{\PYGZdq{}}
                    \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{output folder. Error code: }\PYG{l+s}{\PYGZdq{}}
                 \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{rc} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{.}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{c+c1}{//          cout \PYGZlt{}\PYGZlt{} \PYGZdq{}rc: \PYGZdq{} \PYGZlt{}\PYGZlt{} rc \PYGZlt{}\PYGZlt{} endl;}
        \PYG{n}{sqlite3\PYGZus{}close}\PYG{p}{(}\PYG{n}{outdatabase}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{sqlite3\PYGZus{}close}\PYG{p}{(}\PYG{n}{database}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{done!}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{else}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Closing file...}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{flush}\PYG{p}{;}
        \PYG{n}{sqlite3\PYGZus{}close}\PYG{p}{(}\PYG{n}{database}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}r}\PYG{l+s}{Closing file...done!}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{c+c1}{//      database}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{void} \PYG{n}{Treelist}\PYG{o}{:}\PYG{o}{:}\PYG{n}{recordSpatial}\PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Recording spatial data for speciation rate }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{dSpecRate} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{...}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{flush}\PYG{p}{;}
    \PYG{n}{string} \PYG{n}{table\PYGZus{}command} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{CREATE TABLE IF NOT EXISTS SPECIES\PYGZus{}LOCATIONS (ID TEXT PRIMARY KEY NOT NULL, species\PYGZus{}id INT }\PYG{l+s}{\PYGZdq{}}
                           \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{NOT NULL, speciation\PYGZus{}rate DOUBLE NOT NULL, x INT NOT NULL, y INT NOT NULL,generation }\PYG{l+s}{\PYGZdq{}}
                           \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{DOUBLE NOT NULL);}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
    \PYG{n}{sqlite3\PYGZus{}exec}\PYG{p}{(}\PYG{n}{database}\PYG{p}{,} \PYG{n}{table\PYGZus{}command}\PYG{p}{.}\PYG{n}{c\PYGZus{}str}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{n+nb}{NULL}\PYG{p}{,} \PYG{n+nb}{NULL}\PYG{p}{,} \PYG{n+nb}{NULL}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{sqlite3\PYGZus{}stmt}\PYG{o}{*} \PYG{n}{stmt}\PYG{p}{;}
    \PYG{n}{table\PYGZus{}command} \PYG{o}{=}
        \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{INSERT INTO SPECIES\PYGZus{}LOCATIONS (ID,species\PYGZus{}id, speciation\PYGZus{}rate, x,y,generation) VALUES (?,?,?,?,?,?);}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
    \PYG{n}{sqlite3\PYGZus{}prepare\PYGZus{}v2}\PYG{p}{(}\PYG{n}{database}\PYG{p}{,} \PYG{n}{table\PYGZus{}command}\PYG{p}{.}\PYG{n}{c\PYGZus{}str}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{n}{strlen}\PYG{p}{(}\PYG{n}{table\PYGZus{}command}\PYG{p}{.}\PYG{n}{c\PYGZus{}str}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{stmt}\PYG{p}{,} \PYG{n+nb}{NULL}\PYG{p}{)}\PYG{p}{;}
    \PYG{c+c1}{//      cout \PYGZlt{}\PYGZlt{} \PYGZdq{}test1\PYGZdq{} \PYGZlt{}\PYGZlt{} endl;}
    \PYG{c+c1}{// Start the transaction}
    \PYG{n}{sqlite3\PYGZus{}exec}\PYG{p}{(}\PYG{n}{database}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{BEGIN TRANSACTION;}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n+nb}{NULL}\PYG{p}{,} \PYG{n+nb}{NULL}\PYG{p}{,} \PYG{n+nb}{NULL}\PYG{p}{)}\PYG{p}{;}
    \PYG{c+c1}{// Make sure only the tips which we want to check are recorded}
    \PYG{c+c1}{//      cout \PYGZlt{}\PYGZlt{} \PYGZdq{}nodes.size(): \PYGZdq{} \PYGZlt{}\PYGZlt{} nodes.size() \PYGZlt{}\PYGZlt{} endl;}
    \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{nodes}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{c+c1}{//          cout \PYGZlt{}\PYGZlt{} nodes[i].getExistance() \PYGZlt{}\PYGZlt{} endl;}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{samplemask}\PYG{p}{.}\PYG{n}{getVal}\PYG{p}{(}\PYG{n}{nodes}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getXpos}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{n}{nodes}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getYpos}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{n}{nodes}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{isTip}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}}
           \PYG{n}{nodes}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getExistance}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{n}{doubleCompare}\PYG{p}{(}\PYG{n}{nodes}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getGeneration}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{n}{generation}\PYG{p}{,} \PYG{l+m+mf}{0.0001}\PYG{p}{)}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{string} \PYG{n}{id\PYGZus{}var} \PYG{o}{=} \PYG{n}{boost}\PYG{o}{:}\PYG{o}{:}\PYG{n}{lexical\PYGZus{}cast}\PYG{o}{\PYGZlt{}}\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{string}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{n}{dSpecRate}\PYG{p}{)} \PYG{o}{+} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZhy{}}\PYG{l+s}{\PYGZdq{}} \PYG{o}{+}
                            \PYG{n}{to\PYGZus{}string}\PYG{p}{(}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{k+kt}{long}\PYG{p}{)}\PYG{n}{i}\PYG{p}{)} \PYG{o}{+} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZus{}}\PYG{l+s}{\PYGZdq{}} \PYG{o}{+} \PYG{n}{to\PYGZus{}string}\PYG{p}{(}\PYG{p}{(}\PYG{k+kt}{long} \PYG{k+kt}{double}\PYG{p}{)}\PYG{n}{generation}\PYG{p}{)}\PYG{p}{;}
            \PYG{c+c1}{//              cout \PYGZlt{}\PYGZlt{} id\PYGZus{}var \PYGZlt{}\PYGZlt{} endl;}
            \PYG{c+c1}{// fixed precision problem \PYGZhy{} lexical cast allows for printing of very small doubles.}
            \PYG{n}{sqlite3\PYGZus{}bind\PYGZus{}text}\PYG{p}{(}\PYG{n}{stmt}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{id\PYGZus{}var}\PYG{p}{.}\PYG{n}{c\PYGZus{}str}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{SQLITE\PYGZus{}STATIC}\PYG{p}{)}\PYG{p}{;}
            \PYG{n}{sqlite3\PYGZus{}bind\PYGZus{}int}\PYG{p}{(}\PYG{n}{stmt}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{nodes}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getSpeciesID}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
            \PYG{n}{sqlite3\PYGZus{}bind\PYGZus{}double}\PYG{p}{(}\PYG{n}{stmt}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{n}{dSpecRate}\PYG{p}{)}\PYG{p}{;}
            \PYG{n}{sqlite3\PYGZus{}bind\PYGZus{}int}\PYG{p}{(}\PYG{n}{stmt}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{n}{nodes}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getXpos}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
            \PYG{n}{sqlite3\PYGZus{}bind\PYGZus{}int}\PYG{p}{(}\PYG{n}{stmt}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{,} \PYG{n}{nodes}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getYpos}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
            \PYG{n}{sqlite3\PYGZus{}bind\PYGZus{}double}\PYG{p}{(}\PYG{n}{stmt}\PYG{p}{,} \PYG{l+m+mi}{6}\PYG{p}{,} \PYG{n}{nodes}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getGeneration}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
            \PYG{k+kt}{int} \PYG{n}{step} \PYG{o}{=} \PYG{n}{sqlite3\PYGZus{}step}\PYG{p}{(}\PYG{n}{stmt}\PYG{p}{)}\PYG{p}{;}
            \PYG{c+c1}{// makes sure the while loop doesn\PYGZsq{}t go forever.}
            \PYG{k+kt}{time\PYGZus{}t} \PYG{n}{start\PYGZus{}check}\PYG{p}{,} \PYG{n}{end\PYGZus{}check}\PYG{p}{;}
            \PYG{n}{time}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{start\PYGZus{}check}\PYG{p}{)}\PYG{p}{;}
            \PYG{n}{time}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{end\PYGZus{}check}\PYG{p}{)}\PYG{p}{;}
            \PYG{k}{while}\PYG{p}{(}\PYG{n}{step} \PYG{o}{!}\PYG{o}{=} \PYG{n}{SQLITE\PYGZus{}DONE} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{p}{(}\PYG{n}{end\PYGZus{}check} \PYG{o}{\PYGZhy{}} \PYG{n}{start\PYGZus{}check}\PYG{p}{)} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{10} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{n}{step} \PYG{o}{!}\PYG{o}{=} \PYG{n}{SQLITE\PYGZus{}OK}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{n}{step} \PYG{o}{=} \PYG{n}{sqlite3\PYGZus{}step}\PYG{p}{(}\PYG{n}{stmt}\PYG{p}{)}\PYG{p}{;}
                \PYG{n}{time}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{end\PYGZus{}check}\PYG{p}{)}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
            \PYG{k}{if}\PYG{p}{(}\PYG{n}{step} \PYG{o}{!}\PYG{o}{=} \PYG{n}{SQLITE\PYGZus{}DONE}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{n}{cerr} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{SQLITE error code: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{step} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
\PYG{c+c1}{//              cerr \PYGZlt{}\PYGZlt{} nodes[i].getSpeciesID() \PYGZlt{}\PYGZlt{} endl;}
\PYG{c+c1}{//              cerr \PYGZlt{}\PYGZlt{} nodes[i].getXpos() \PYGZlt{}\PYGZlt{} endl;}
\PYG{c+c1}{//              cerr \PYGZlt{}\PYGZlt{} id\PYGZus{}var \PYGZlt{}\PYGZlt{} endl;}
                \PYG{n}{cerr} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ERROR\PYGZus{}SQL\PYGZus{}004: Could not insert into database. Check destination file has not }\PYG{l+s}{\PYGZdq{}}
                        \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{been moved or deleted and that an entry doesn\PYGZsq{}t already exist with the same ID.}\PYG{l+s}{\PYGZdq{}}
                     \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
                \PYG{k}{break}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
            \PYG{n}{sqlite3\PYGZus{}clear\PYGZus{}bindings}\PYG{p}{(}\PYG{n}{stmt}\PYG{p}{)}\PYG{p}{;}
            \PYG{n}{sqlite3\PYGZus{}reset}\PYG{p}{(}\PYG{n}{stmt}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
    \PYG{p}{\PYGZcb{}}
    \PYG{c+c1}{//      cout \PYGZlt{}\PYGZlt{} \PYGZdq{}test2\PYGZdq{} \PYGZlt{}\PYGZlt{} endl;}
    \PYG{c+c1}{// execute the command and close the connection to the database}
    \PYG{k+kt}{int} \PYG{n}{rc1} \PYG{o}{=} \PYG{n}{sqlite3\PYGZus{}exec}\PYG{p}{(}\PYG{n}{database}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{END TRANSACTION;}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n+nb}{NULL}\PYG{p}{,} \PYG{n+nb}{NULL}\PYG{p}{,} \PYG{n+nb}{NULL}\PYG{p}{)}\PYG{p}{;}
    \PYG{c+c1}{// Need to finalise the statement}
    \PYG{k+kt}{int} \PYG{n}{rc2} \PYG{o}{=} \PYG{n}{sqlite3\PYGZus{}finalize}\PYG{p}{(}\PYG{n}{stmt}\PYG{p}{)}\PYG{p}{;}
    \PYG{k}{if}\PYG{p}{(}\PYG{n}{rc1} \PYG{o}{!}\PYG{o}{=} \PYG{n}{SQLITE\PYGZus{}OK} \PYG{o}{\textbar{}}\PYG{o}{\textbar{}} \PYG{n}{rc2} \PYG{o}{!}\PYG{o}{=} \PYG{n}{SQLITE\PYGZus{}OK}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{cerr} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ERROR\PYGZus{}SQL\PYGZus{}013: Could not complete SQL transaction. Check memory database assignment and SQL }\PYG{l+s}{\PYGZdq{}}
                \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{commands. Ensure SQL statements are properly cleared and that you are not attempting to insert }\PYG{l+s}{\PYGZdq{}}
                \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{repeat IDs into the database.}\PYG{l+s}{\PYGZdq{}}
             \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{else}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}r}\PYG{l+s}{Recording spatial data for speciation rate }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{dSpecRate} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{...done!}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{void} \PYG{n}{Treelist}\PYG{o}{:}\PYG{o}{:}\PYG{n}{calcFragments}\PYG{p}{(}\PYG{n}{string} \PYG{n}{fragment\PYGZus{}file}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
\PYG{c+c1}{//  for(unsigned int i = 0; i \PYGZlt{} nodes.size(); i++)}
\PYG{c+c1}{//  \PYGZob{}}
\PYG{c+c1}{//      if(nodes[i].isTip() \PYGZam{}\PYGZam{} !samplemask.getVal(nodes[i].getXpos(), nodes[i].getYpos()))}
\PYG{c+c1}{//      \PYGZob{}}
            \PYG{c+c1}{//              cerr \PYGZlt{}\PYGZlt{} \PYGZdq{}ERROR (x,y): \PYGZdq{} \PYGZlt{}\PYGZlt{} nodes[i].getXpos() \PYGZlt{}\PYGZlt{} \PYGZdq{}, \PYGZdq{} \PYGZlt{}\PYGZlt{}nodes[i].getYpos() \PYGZlt{}\PYGZlt{}}
            \PYG{c+c1}{//endl;}
\PYG{c+c1}{//      \PYGZcb{}}
\PYG{c+c1}{//  \PYGZcb{}}
    \PYG{c+c1}{// Loop over every grid cell in the samplemask to determine if it is the start (top left corner) of a fragment.}
    \PYG{c+c1}{// Note that fragment detection only works for squares and rectangles. Adjacent squares and rectangles will be}
    \PYG{c+c1}{// treated as separate fragments if they are different sizes.}
    \PYG{c+c1}{// Downwards shapes are prioritised (i.e. a vertical rectangle on top of a horizontal rectangle will produce 3}
    \PYG{c+c1}{// fragments instead of two \PYGZhy{} this is a known bug).}
    \PYG{k}{if}\PYG{p}{(}\PYG{n}{fragment\PYGZus{}file} \PYG{o}{=}\PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{null}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k+kt}{unsigned} \PYG{k+kt}{int} \PYG{n}{fragment\PYGZus{}number} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
        \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{samplemask}\PYG{p}{.}\PYG{n}{GetCols}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{j} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{j} \PYG{o}{\PYGZlt{}} \PYG{n}{samplemask}\PYG{p}{.}\PYG{n}{GetRows}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{n}{j}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{k+kt}{bool} \PYG{n}{in\PYGZus{}fragment} \PYG{o}{=} \PYG{n+nb}{false}\PYG{p}{;}
                \PYG{c+c1}{// Make sure is isn\PYGZsq{}t on the top or left edge}
                \PYG{k}{if}\PYG{p}{(}\PYG{n}{samplemask}\PYG{p}{.}\PYG{n}{getVal}\PYG{p}{(}\PYG{n}{i}\PYG{p}{,} \PYG{n}{j}\PYG{p}{)}\PYG{p}{)}
                \PYG{p}{\PYGZob{}}
                    \PYG{k}{if}\PYG{p}{(}\PYG{n}{i} \PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{0} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{n}{j} \PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{0}\PYG{p}{)}
                    \PYG{p}{\PYGZob{}}
                        \PYG{c+c1}{// Perform the check}
                        \PYG{k}{if}\PYG{p}{(}\PYG{n}{samplemask}\PYG{p}{.}\PYG{n}{getVal}\PYG{p}{(}\PYG{n}{i} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{j}\PYG{p}{)} \PYG{o}{\textbar{}}\PYG{o}{\textbar{}} \PYG{n}{samplemask}\PYG{p}{.}\PYG{n}{getVal}\PYG{p}{(}\PYG{n}{i}\PYG{p}{,} \PYG{n}{j} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{)}
                        \PYG{p}{\PYGZob{}}
                            \PYG{c+c1}{// then it is not a fragment}
                            \PYG{n}{in\PYGZus{}fragment} \PYG{o}{=} \PYG{n+nb}{false}\PYG{p}{;}
                        \PYG{p}{\PYGZcb{}}
                        \PYG{k}{else}
                        \PYG{p}{\PYGZob{}}
                            \PYG{n}{in\PYGZus{}fragment} \PYG{o}{=} \PYG{n+nb}{true}\PYG{p}{;}
                        \PYG{p}{\PYGZcb{}}
                    \PYG{p}{\PYGZcb{}}
                    \PYG{c+c1}{// if it is on an edge, we need to check the fragment}
                    \PYG{k}{else}
                    \PYG{p}{\PYGZob{}}
                        \PYG{c+c1}{// if it is on the left edge we need to check above it \PYGZhy{} if there is forest}
                        \PYG{c+c1}{// there, it is not a fragment.}
                        \PYG{k}{if}\PYG{p}{(}\PYG{n}{i} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{0} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{n}{j} \PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{0}\PYG{p}{)}
                        \PYG{p}{\PYGZob{}}
                            \PYG{k}{if}\PYG{p}{(}\PYG{o}{!}\PYG{n}{samplemask}\PYG{p}{.}\PYG{n}{getVal}\PYG{p}{(}\PYG{n}{i}\PYG{p}{,} \PYG{n}{j} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{)}
                            \PYG{p}{\PYGZob{}}
                                \PYG{n}{in\PYGZus{}fragment} \PYG{o}{=} \PYG{n+nb}{true}\PYG{p}{;}
                            \PYG{p}{\PYGZcb{}}
                        \PYG{p}{\PYGZcb{}}
                        \PYG{c+c1}{// if it is on the top edge, need to check to the left of it \PYGZhy{}  if there is}
                        \PYG{c+c1}{// forest there, it is not a fragment.}
                        \PYG{k}{else} \PYG{k}{if}\PYG{p}{(}\PYG{n}{j} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{0} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{n}{i} \PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{0}\PYG{p}{)}
                        \PYG{p}{\PYGZob{}}
                            \PYG{k}{if}\PYG{p}{(}\PYG{o}{!}\PYG{n}{samplemask}\PYG{p}{.}\PYG{n}{getVal}\PYG{p}{(}\PYG{n}{i} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{j}\PYG{p}{)}\PYG{p}{)}
                            \PYG{p}{\PYGZob{}}
                                \PYG{n}{in\PYGZus{}fragment} \PYG{o}{=} \PYG{n+nb}{true}\PYG{p}{;}
                            \PYG{p}{\PYGZcb{}}
                        \PYG{p}{\PYGZcb{}}
                        \PYG{k}{else} \PYG{k}{if}\PYG{p}{(}\PYG{n}{i} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{0} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{n}{j} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)}
                        \PYG{p}{\PYGZob{}}
                            \PYG{n}{in\PYGZus{}fragment} \PYG{o}{=} \PYG{n+nb}{true}\PYG{p}{;}
                        \PYG{p}{\PYGZcb{}}
                    \PYG{p}{\PYGZcb{}}
                \PYG{p}{\PYGZcb{}}
                \PYG{k}{if}\PYG{p}{(}\PYG{n}{in\PYGZus{}fragment}\PYG{p}{)}
                \PYG{p}{\PYGZob{}}
                    \PYG{c+c1}{// Now move along the x and y axis (separately) until we hit a non\PYGZhy{}forest patch.}
                    \PYG{c+c1}{// This marks the edge of the fragment and the value is recorded.}
                    \PYG{k+kt}{bool} \PYG{n}{x\PYGZus{}continue} \PYG{o}{=} \PYG{n+nb}{true}\PYG{p}{;}
                    \PYG{k+kt}{bool} \PYG{n}{y\PYGZus{}continue} \PYG{o}{=} \PYG{n+nb}{true}\PYG{p}{;}
                    \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{x}\PYG{p}{,} \PYG{n}{y}\PYG{p}{;}
                    \PYG{n}{x} \PYG{o}{=} \PYG{n}{i}\PYG{p}{;}
                    \PYG{n}{y} \PYG{o}{=} \PYG{n}{j}\PYG{p}{;}
                    \PYG{n}{fragment\PYGZus{}number}\PYG{o}{+}\PYG{o}{+}\PYG{p}{;}
                    \PYG{c+c1}{// Also need to check that fragments that lie partly next to each other aren\PYGZsq{}t}
                    \PYG{c+c1}{// counted twice.}
                    \PYG{c+c1}{// So count along the x axis until we hit non\PYGZhy{}habitat. Then count down the y axis}
                    \PYG{c+c1}{// checking both extremes of the square for non\PYGZhy{}habitat.}
                    \PYG{c+c1}{// Perform a check on the x axis to make sure that the square above is empty, as}
                    \PYG{c+c1}{// fragments give priority in a downwards motion.}
                    \PYG{k}{while}\PYG{p}{(}\PYG{n}{x\PYGZus{}continue}\PYG{p}{)}
                    \PYG{p}{\PYGZob{}}
                        \PYG{n}{x}\PYG{o}{+}\PYG{o}{+}\PYG{p}{;}
                        \PYG{k}{if}\PYG{p}{(}\PYG{n}{samplemask}\PYG{p}{.}\PYG{n}{getVal}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,} \PYG{n}{j}\PYG{p}{)}\PYG{p}{)}
                        \PYG{p}{\PYGZob{}}
                            \PYG{c+c1}{// Check we\PYGZsq{}re not on top edge of the map.}
                            \PYG{k}{if}\PYG{p}{(}\PYG{n}{j} \PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{0}\PYG{p}{)}
                            \PYG{p}{\PYGZob{}}
                                \PYG{c+c1}{// if the cell above is non\PYGZhy{}fragment then we don\PYGZsq{}t need to}
                                \PYG{c+c1}{// continue (downwards fragments get priority).}
                                \PYG{k}{if}\PYG{p}{(}\PYG{n}{samplemask}\PYG{p}{.}\PYG{n}{getVal}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,} \PYG{n}{j} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{)}
                                \PYG{p}{\PYGZob{}}
                                    \PYG{n}{x\PYGZus{}continue} \PYG{o}{=} \PYG{n+nb}{true}\PYG{p}{;}
                                \PYG{p}{\PYGZcb{}}
                                \PYG{k}{else}
                                \PYG{p}{\PYGZob{}}
                                    \PYG{n}{x\PYGZus{}continue} \PYG{o}{=} \PYG{n+nb}{false}\PYG{p}{;}
                                \PYG{p}{\PYGZcb{}}
                            \PYG{p}{\PYGZcb{}}
                            \PYG{k}{else}
                            \PYG{p}{\PYGZob{}}
                                \PYG{n}{x\PYGZus{}continue} \PYG{o}{=} \PYG{n+nb}{true}\PYG{p}{;}
                            \PYG{p}{\PYGZcb{}}
                        \PYG{p}{\PYGZcb{}}
                        \PYG{k}{else}
                        \PYG{p}{\PYGZob{}}
                            \PYG{n}{x\PYGZus{}continue} \PYG{o}{=} \PYG{n+nb}{false}\PYG{p}{;}
                        \PYG{p}{\PYGZcb{}}
                    \PYG{p}{\PYGZcb{}}
                    \PYG{k}{while}\PYG{p}{(}\PYG{n}{y\PYGZus{}continue}\PYG{p}{)}
                    \PYG{p}{\PYGZob{}}
                        \PYG{n}{y}\PYG{o}{+}\PYG{o}{+}\PYG{p}{;}
                        \PYG{c+c1}{// Make sure both extremes of the rectangle are still within patch.}
                        \PYG{k}{if}\PYG{p}{(}\PYG{n}{samplemask}\PYG{p}{.}\PYG{n}{getVal}\PYG{p}{(}\PYG{n}{i}\PYG{p}{,} \PYG{n}{y}\PYG{p}{)} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{n}{samplemask}\PYG{p}{.}\PYG{n}{getVal}\PYG{p}{(}\PYG{n}{x} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{y}\PYG{p}{)}\PYG{p}{)}
                        \PYG{p}{\PYGZob{}}
                            \PYG{n}{y\PYGZus{}continue} \PYG{o}{=} \PYG{n+nb}{true}\PYG{p}{;}
                        \PYG{p}{\PYGZcb{}}
                        \PYG{k}{else}
                        \PYG{p}{\PYGZob{}}
                            \PYG{n}{y\PYGZus{}continue} \PYG{o}{=} \PYG{n+nb}{false}\PYG{p}{;}
                        \PYG{p}{\PYGZcb{}}
                    \PYG{p}{\PYGZcb{}}
                    \PYG{c+c1}{// Create the fragment to add.}
                    \PYG{n}{Fragment} \PYG{n}{to\PYGZus{}add}\PYG{p}{;}
                    \PYG{n}{to\PYGZus{}add}\PYG{p}{.}\PYG{n}{name} \PYG{o}{=} \PYG{n}{to\PYGZus{}string}\PYG{p}{(}\PYG{p}{(}\PYG{k+kt}{long} \PYG{k+kt}{long}\PYG{p}{)}\PYG{n}{fragment\PYGZus{}number}\PYG{p}{)}\PYG{p}{;}
                    \PYG{n}{to\PYGZus{}add}\PYG{p}{.}\PYG{n}{x\PYGZus{}west} \PYG{o}{=} \PYG{n}{i}\PYG{p}{;}
                    \PYG{n}{to\PYGZus{}add}\PYG{p}{.}\PYG{n}{x\PYGZus{}east} \PYG{o}{=} \PYG{n}{x} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{1}\PYG{p}{;}
                    \PYG{n}{to\PYGZus{}add}\PYG{p}{.}\PYG{n}{y\PYGZus{}north} \PYG{o}{=} \PYG{n}{j}\PYG{p}{;}
                    \PYG{n}{to\PYGZus{}add}\PYG{p}{.}\PYG{n}{y\PYGZus{}south} \PYG{o}{=} \PYG{n}{y} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{1}\PYG{p}{;}
                    \PYG{c+c1}{// calculate the square area of the plot and record it.}
                    \PYG{n}{to\PYGZus{}add}\PYG{p}{.}\PYG{n}{area} \PYG{o}{=} \PYG{p}{(}\PYG{n}{x} \PYG{o}{\PYGZhy{}} \PYG{n}{i}\PYG{p}{)} \PYG{o}{*} \PYG{p}{(}\PYG{n}{y} \PYG{o}{\PYGZhy{}} \PYG{n}{j}\PYG{p}{)}\PYG{p}{;}
                    \PYG{c+c1}{// Now store the size of the fragment in the vector.}
                    \PYG{n}{fragments}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{n}{to\PYGZus{}add}\PYG{p}{)}\PYG{p}{;}
                \PYG{p}{\PYGZcb{}}
            \PYG{p}{\PYGZcb{}}
        \PYG{p}{\PYGZcb{}}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{else}
    \PYG{p}{\PYGZob{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifdef use\PYGZus{}csv}
        \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Importing fragments from }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{fragment\PYGZus{}file} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
        \PYG{c+c1}{// There is a config file to import \PYGZhy{} here we use a specific piece of import code to parse the csv file.}
        \PYG{c+c1}{// first count the number of lines}
        \PYG{k+kt}{int} \PYG{n}{number\PYGZus{}of\PYGZus{}lines} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
        \PYG{n}{string} \PYG{n}{line}\PYG{p}{;}
        \PYG{n}{ifstream} \PYG{n+nf}{fragment\PYGZus{}configs}\PYG{p}{(}\PYG{n}{fragment\PYGZus{}file}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{while}\PYG{p}{(}\PYG{n}{getline}\PYG{p}{(}\PYG{n}{fragment\PYGZus{}configs}\PYG{p}{,} \PYG{n}{line}\PYG{p}{)}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{number\PYGZus{}of\PYGZus{}lines}\PYG{o}{+}\PYG{o}{+}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{c+c1}{//          cout \PYGZlt{}\PYGZlt{} \PYGZdq{}Number of lines in text file: \PYGZdq{} \PYGZlt{}\PYGZlt{} number\PYGZus{}of\PYGZus{}lines \PYGZlt{}\PYGZlt{} endl;}
        \PYG{n}{fragment\PYGZus{}configs}\PYG{p}{.}\PYG{n}{close}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{io}\PYG{o}{:}\PYG{o}{:}\PYG{n}{LineReader} \PYG{n}{in}\PYG{p}{(}\PYG{n}{fragment\PYGZus{}file}\PYG{p}{)}\PYG{p}{;}
        \PYG{c+c1}{// Keep track of whether we\PYGZsq{}ve printed to terminal or not.}
        \PYG{k+kt}{bool} \PYG{n}{bPrint} \PYG{o}{=} \PYG{n+nb}{false}\PYG{p}{;}
        \PYG{n}{fragments}\PYG{p}{.}\PYG{n}{resize}\PYG{p}{(}\PYG{n}{number\PYGZus{}of\PYGZus{}lines}\PYG{p}{)}\PYG{p}{;}
\PYG{c+c1}{//      cout \PYGZlt{}\PYGZlt{} \PYGZdq{}size: \PYGZdq{}  \PYGZlt{}\PYGZlt{} fragments.capacity() \PYGZlt{}\PYGZlt{} endl;}
        \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{number\PYGZus{}of\PYGZus{}lines}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}

            \PYG{c+c1}{//              cout \PYGZlt{}\PYGZlt{} i \PYGZlt{}\PYGZlt{} endl;}
            \PYG{k+kt}{char}\PYG{o}{*} \PYG{n}{line} \PYG{o}{=} \PYG{n}{in}\PYG{p}{.}\PYG{n}{next\PYGZus{}line}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{c+c1}{//          cout \PYGZlt{}\PYGZlt{} line \PYGZlt{}\PYGZlt{} endl;}
            \PYG{k}{if}\PYG{p}{(}\PYG{n}{line} \PYG{o}{=}\PYG{o}{=} \PYG{k}{nullptr}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{k}{if}\PYG{p}{(}\PYG{o}{!}\PYG{n}{bPrint}\PYG{p}{)}
                \PYG{p}{\PYGZob{}}
                    \PYG{n}{cerr} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Input dimensions incorrect \PYGZhy{} read past end of file.}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
                    \PYG{n}{bPrint} \PYG{o}{=} \PYG{n+nb}{true}\PYG{p}{;}
                \PYG{p}{\PYGZcb{}}
                \PYG{k}{break}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
            \PYG{k}{else}
            \PYG{p}{\PYGZob{}}
                \PYG{k+kt}{char}\PYG{o}{*} \PYG{n}{dToken}\PYG{p}{;}
                \PYG{n}{dToken} \PYG{o}{=} \PYG{n}{strtok}\PYG{p}{(}\PYG{n}{line}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{,}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
                \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{j} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{j} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{6}\PYG{p}{;} \PYG{n}{j}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
                \PYG{p}{\PYGZob{}}
                    \PYG{c+c1}{//                      cout \PYGZlt{}\PYGZlt{} j \PYGZlt{}\PYGZlt{} endl;}
                    \PYG{k}{if}\PYG{p}{(}\PYG{n}{dToken} \PYG{o}{=}\PYG{o}{=} \PYG{k}{nullptr}\PYG{p}{)}
                    \PYG{p}{\PYGZob{}}
                        \PYG{k}{if}\PYG{p}{(}\PYG{o}{!}\PYG{n}{bPrint}\PYG{p}{)}
                        \PYG{p}{\PYGZob{}}
                            \PYG{n}{cerr} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Input dimensions incorrect \PYGZhy{} read past end of file.}\PYG{l+s}{\PYGZdq{}}
                                 \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
                            \PYG{n}{bPrint} \PYG{o}{=} \PYG{n+nb}{true}\PYG{p}{;}
                        \PYG{p}{\PYGZcb{}}
                        \PYG{k}{break}\PYG{p}{;}
                    \PYG{p}{\PYGZcb{}}
                    \PYG{k}{else}
                    \PYG{p}{\PYGZob{}}
                        \PYG{c+c1}{//                          cout \PYGZlt{}\PYGZlt{} \PYGZdq{}\PYGZhy{}\PYGZdq{} \PYGZlt{}\PYGZlt{} endl;}
                        \PYG{k}{switch}\PYG{p}{(}\PYG{n}{j}\PYG{p}{)}
                        \PYG{p}{\PYGZob{}}
                            \PYG{k}{case} \PYG{l+m+mi}{0}\PYG{o}{:}
                            \PYG{n}{fragments}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{name} \PYG{o}{=} \PYG{n}{string}\PYG{p}{(}\PYG{n}{dToken}\PYG{p}{)}\PYG{p}{;}
                            \PYG{k}{break}\PYG{p}{;}
                            \PYG{k}{case} \PYG{l+m+mi}{1}\PYG{o}{:}
                            \PYG{n}{fragments}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{x\PYGZus{}west} \PYG{o}{=} \PYG{n}{atoi}\PYG{p}{(}\PYG{n}{dToken}\PYG{p}{)}\PYG{p}{;}
                            \PYG{k}{break}\PYG{p}{;}
                            \PYG{k}{case} \PYG{l+m+mi}{2}\PYG{o}{:}
                            \PYG{n}{fragments}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{y\PYGZus{}north} \PYG{o}{=} \PYG{n}{atoi}\PYG{p}{(}\PYG{n}{dToken}\PYG{p}{)}\PYG{p}{;}
                            \PYG{k}{break}\PYG{p}{;}
                            \PYG{k}{case} \PYG{l+m+mi}{3}\PYG{o}{:}
                            \PYG{n}{fragments}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{x\PYGZus{}east} \PYG{o}{=} \PYG{n}{atoi}\PYG{p}{(}\PYG{n}{dToken}\PYG{p}{)}\PYG{p}{;}
                            \PYG{k}{break}\PYG{p}{;}
                            \PYG{k}{case} \PYG{l+m+mi}{4}\PYG{o}{:}
                            \PYG{n}{fragments}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{y\PYGZus{}south} \PYG{o}{=} \PYG{n}{atoi}\PYG{p}{(}\PYG{n}{dToken}\PYG{p}{)}\PYG{p}{;}
                            \PYG{k}{break}\PYG{p}{;}
                            \PYG{k}{case} \PYG{l+m+mi}{5}\PYG{o}{:}
                            \PYG{n}{fragments}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{area} \PYG{o}{=} \PYG{n}{atof}\PYG{p}{(}\PYG{n}{dToken}\PYG{p}{)}\PYG{p}{;}
                            \PYG{k}{break}\PYG{p}{;}
                        \PYG{p}{\PYGZcb{}}
                        \PYG{n}{dToken} \PYG{o}{=} \PYG{n}{strtok}\PYG{p}{(}\PYG{n+nb}{NULL}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{,}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
                    \PYG{p}{\PYGZcb{}}
                \PYG{p}{\PYGZcb{}}
            \PYG{p}{\PYGZcb{}}
        \PYG{p}{\PYGZcb{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifndef use\PYGZus{}csv}
        \PYG{n}{cerr} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Cannot import fragments from }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{fragment\PYGZus{}file} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ without fast\PYGZhy{}cpp\PYGZhy{}csv\PYGZhy{}parser.}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
        \PYG{n}{cerr} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Make sure the program has been compiled with \PYGZhy{}D use\PYGZus{}csv.}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif}
    \PYG{p}{\PYGZcb{}}
    \PYG{c+c1}{// for(unsigned int i =0; i \PYGZlt{} fragments.size(); i++ )}
    \PYG{c+c1}{//\PYGZob{}}
    \PYG{c+c1}{// check samples match}
    \PYG{c+c1}{// if(!samplemask.getVal(fragments[i].x\PYGZus{}west,fragments[i].y\PYGZus{}north))}
    \PYG{c+c1}{//\PYGZob{}}
    \PYG{c+c1}{// cout \PYGZlt{}\PYGZlt{} fragments[i].name \PYGZlt{}\PYGZlt{} \PYGZdq{} \PYGZdq{} \PYGZlt{}\PYGZlt{} fragments[i].x\PYGZus{}west \PYGZlt{}\PYGZlt{} \PYGZdq{} \PYGZdq{} \PYGZlt{}\PYGZlt{} fragments[i].y\PYGZus{}north \PYGZlt{}\PYGZlt{} \PYGZdq{} \PYGZdq{} \PYGZlt{}\PYGZlt{}}
    \PYG{c+c1}{// fragments[i].x\PYGZus{}east \PYGZlt{}\PYGZlt{} \PYGZdq{} \PYGZdq{} \PYGZlt{}\PYGZlt{} fragments[i].y\PYGZus{}south \PYGZlt{}\PYGZlt{} \PYGZdq{} \PYGZdq{} \PYGZlt{}\PYGZlt{} fragments[i].area \PYGZlt{}\PYGZlt{} endl;}
    \PYG{c+c1}{//\PYGZcb{}}
    \PYG{c+c1}{//\PYGZcb{}}
    \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Completed fragmentation analysis: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{fragments}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ fragments identified.}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{void} \PYG{n}{Treelist}\PYG{o}{:}\PYG{o}{:}\PYG{n}{applyFragments}\PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{c+c1}{//      calculateFragments(); // don\PYGZsq{}t need to do this each time \PYGZhy{} just once per simulation.}
    \PYG{c+c1}{// For each fragment in the vector, perform the analysis and record the data in to a new data object, which will}
    \PYG{c+c1}{// then be outputted to an SQL file.}
    \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{fragments}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{c+c1}{//          cout  \PYGZlt{}\PYGZlt{} fragments[i].x\PYGZus{}west \PYGZlt{}\PYGZlt{} endl;}
        \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}r}\PYG{l+s}{Applying fragments... }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{p}{(}\PYG{n}{i} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{/}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{fragments}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{      }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{flush}\PYG{p}{;}
        \PYG{c+c1}{// Set the new samplemask to the fragment}
        \PYG{n}{samplemask}\PYG{p}{.}\PYG{n}{setFragment}\PYG{p}{(}\PYG{n}{fragments}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
        \PYG{c+c1}{// Now filter only those lineages which exist in the fragments.}
        \PYG{c+c1}{// We also want to count the number of individuals that actually exist}
        \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{iSpecCount} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
        \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{j} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{j} \PYG{o}{\PYGZlt{}} \PYG{n}{nodes}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{n}{j}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{k}{if}\PYG{p}{(}\PYG{n}{nodes}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{p}{.}\PYG{n}{isTip}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{n}{samplemask}\PYG{p}{.}\PYG{n}{getVal}\PYG{p}{(}\PYG{n}{nodes}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getXpos}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{n}{nodes}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getYpos}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}}
               \PYG{n}{doubleCompare}\PYG{p}{(}\PYG{n}{nodes}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getGeneration}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{n}{generation}\PYG{p}{,} \PYG{l+m+mf}{0.0001}\PYG{p}{)}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{c+c1}{// if they exist exactly in the generation of interest.}
                \PYG{n}{nodes}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{p}{.}\PYG{n}{setExistance}\PYG{p}{(}\PYG{n+nb}{true}\PYG{p}{)}\PYG{p}{;}
                \PYG{n}{iSpecCount}\PYG{o}{+}\PYG{o}{+}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
            \PYG{k}{else} \PYG{k}{if}\PYG{p}{(}\PYG{n}{nodes}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{p}{.}\PYG{n}{isTip}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{n}{nodes}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{p}{.}\PYG{n}{setExistance}\PYG{p}{(}\PYG{n+nb}{false}\PYG{p}{)}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
        \PYG{p}{\PYGZcb{}}
        \PYG{n}{fragments}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{num} \PYG{o}{=} \PYG{n}{iSpecCount}\PYG{p}{;}
        \PYG{c+cm}{/* NO LONGER REQUIRED DUE TO IMPLEMENTATION CHANGE}
\PYG{c+cm}{        vector\PYGZlt{}unsigned long\PYGZgt{} all\PYGZus{}species;}
\PYG{c+cm}{        all\PYGZus{}species.reserve(iSpecCount);}
\PYG{c+cm}{        for(unsigned int i=0;i\PYGZlt{}=nodes.size();i++)}
\PYG{c+cm}{        \PYGZob{}}
\PYG{c+cm}{                if(nodes[i].isTip() \PYGZam{}\PYGZam{} nodes[i].getExistance())//\PYGZam{}\PYGZam{}nodes[i].getExistance()) // count all speciation}
\PYG{c+cm}{        events, not just the ones that exist!}
\PYG{c+cm}{                \PYGZob{}}
\PYG{c+cm}{                        all\PYGZus{}species.push\PYGZus{}back(nodes[i].getSpeciesID());}
\PYG{c+cm}{                \PYGZcb{}}
\PYG{c+cm}{                if(nodes[i].getExistance()\PYGZam{}\PYGZam{}nodes[i].getSpeciesID()==0)}
\PYG{c+cm}{                \PYGZob{}}
\PYG{c+cm}{                        cerr \PYGZlt{}\PYGZlt{} \PYGZdq{}ERROR\PYGZus{}SQL\PYGZus{}006: Species exists but hasn\PYGZsq{}t been assigned a species ID. Check the tree}
\PYG{c+cm}{        speciation calculations.\PYGZdq{} \PYGZlt{}\PYGZlt{} endl;}
\PYG{c+cm}{                \PYGZcb{}}
\PYG{c+cm}{        \PYGZcb{}}
\PYG{c+cm}{        // sory the vector}
\PYG{c+cm}{        sort(all\PYGZus{}species.begin(),all\PYGZus{}species.end());}
\PYG{c+cm}{        auto last = unique(all\PYGZus{}species.begin(),all\PYGZus{}species.end());}
\PYG{c+cm}{        all\PYGZus{}species.erase(last,all\PYGZus{}species.end());}
\PYG{c+cm}{        iSpecies = all\PYGZus{}species.size();}
\PYG{c+cm}{         * */}
        \PYG{c+c1}{// Now calculate the species abundance. This will create a vector with lots of zeros in it. However, the}
        \PYG{c+c1}{// database creation will filter these out.}
        \PYG{n}{calcSpeciesAbundance}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{createFragmentDatabase}\PYG{p}{(}\PYG{n}{fragments}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
        \PYG{c+c1}{//          cout \PYGZlt{}\PYGZlt{} \PYGZdq{}done!\PYGZdq{} \PYGZlt{}\PYGZlt{} endl;}
    \PYG{p}{\PYGZcb{}}
    \PYG{n}{samplemask}\PYG{p}{.}\PYG{n}{removeFragment}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}r}\PYG{l+s}{Applying fragments... }\PYG{l+s}{\PYGZdq{}}
         \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{done!      }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{bool} \PYG{n}{checkSpeciation}\PYG{p}{(}\PYG{k+kt}{long} \PYG{k+kt}{double} \PYG{n}{random\PYGZus{}number}\PYG{p}{,} \PYG{k+kt}{long} \PYG{k+kt}{double} \PYG{n}{speciation\PYGZus{}rate}\PYG{p}{,} \PYG{k+kt}{int} \PYG{n}{number\PYGZus{}of\PYGZus{}generations}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{c+c1}{// bool result1, result2, result3, result4;}
    \PYG{k+kt}{long} \PYG{k+kt}{double} \PYG{n}{res} \PYG{o}{=} \PYG{k+kt}{double}\PYG{p}{(}\PYG{l+m+mf}{1.0} \PYG{o}{\PYGZhy{}} \PYG{n}{pow}\PYG{p}{(}\PYG{k+kt}{double}\PYG{p}{(}\PYG{l+m+mf}{1.0} \PYG{o}{\PYGZhy{}} \PYG{n}{speciation\PYGZus{}rate}\PYG{p}{)}\PYG{p}{,} \PYG{k+kt}{double}\PYG{p}{(}\PYG{n}{number\PYGZus{}of\PYGZus{}generations}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
    \PYG{k}{if}\PYG{p}{(}\PYG{n}{random\PYGZus{}number} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{n}{res}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{return} \PYG{p}{(}\PYG{n+nb}{true}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{else}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{return} \PYG{p}{(}\PYG{n+nb}{false}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}


\subparagraph{Includes}
\label{\detokenize{Exhaled/exhale_file_Treelist.cpp:includes}}\begin{itemize}
\item {} 
\sphinxcode{Treelist.h} ({\hyperref[\detokenize{Exhaled/exhale_file_Treelist.h:file-treelist-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File Treelist.h}}}})

\end{itemize}


\subparagraph{Functions}
\label{\detokenize{Exhaled/exhale_file_Treelist.cpp:functions}}\begin{itemize}
\item {} 
{\hyperref[\detokenize{Exhaled/exhale_function_checkSpeciation:function-checkspeciation}]{\sphinxcrossref{\DUrole{std,std-ref}{Function checkSpeciation}}}}

\end{itemize}


\paragraph{File Treelist.h}
\label{\detokenize{Exhaled/exhale_file_Treelist.h:id1}}\label{\detokenize{Exhaled/exhale_file_Treelist.h::doc}}\label{\detokenize{Exhaled/exhale_file_Treelist.h:file-treelist-h}}

\subparagraph{Definition (\sphinxstyleliteralintitle{Treelist.h})}
\label{\detokenize{Exhaled/exhale_file_Treelist.h:definition-treelist-h}}

\subparagraph{Program Listing for File Treelist.h}
\label{\detokenize{Exhaled/exhale_program_listing_file_Treelist.h:program-listing-for-file-treelist-h}}\label{\detokenize{Exhaled/exhale_program_listing_file_Treelist.h::doc}}\label{\detokenize{Exhaled/exhale_program_listing_file_Treelist.h:program-listing-file-treelist-h}}\begin{itemize}
\item {} 
Return to documentation for {\hyperref[\detokenize{Exhaled/exhale_file_Treelist.h:file-treelist-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File Treelist.h}}}}

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{//This file is part of NECSim project which is released under BSD\PYGZhy{}3 license.}
\PYG{c+c1}{//See file **LICENSE.txt** or visit https://opensource.org/licenses/BSD\PYGZhy{}3\PYGZhy{}Clause) for full license details.}
\PYG{c+c1}{// This code is a used to analyse a list of Treenode objects to generate species abundances for a given speciation rate.}
\PYG{c+c1}{// For use within Coal\PYGZus{}sim v3.1+}
\PYG{c+c1}{// Author: Samuel Thompson}
\PYG{c+c1}{// Contact: samuel.thompson14@imperial.ac.uk or thompsonsed@gmail.com}
\PYG{c+c1}{// Version 1.1}
\PYG{c+c1}{//\PYGZsh{}include \PYGZdq{}Treenode.h\PYGZdq{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifndef TREELIST}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define TREELIST}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZdq{}Treenode.h\PYGZdq{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZdq{}Matrix.h\PYGZdq{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}math.h\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}sqlite3.h\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}cstring\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}cmath\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}stdexcept\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}string\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ include \PYGZlt{}boost}\PYG{c+cp}{/}\PYG{c+cp}{filesystem.hpp\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}boost/lexical\PYGZus{}cast.hpp\PYGZgt{}}
 \PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZdq{}CustomExceptions.h\PYGZdq{}}

\PYG{k}{using} \PYG{k}{namespace} \PYG{n}{std}\PYG{p}{;}
\PYG{k}{using} \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{string}\PYG{p}{;}

\PYG{k+kt}{bool} \PYG{n+nf}{checkSpeciation}\PYG{p}{(}\PYG{k+kt}{long} \PYG{k+kt}{double} \PYG{n}{random\PYGZus{}number}\PYG{p}{,} \PYG{k+kt}{long} \PYG{k+kt}{double} \PYG{n}{speciation\PYGZus{}rate}\PYG{p}{,} \PYG{k+kt}{int} \PYG{n}{number\PYGZus{}of\PYGZus{}generations}\PYG{p}{)}
\PYG{p}{;}

\PYG{c+c1}{// A class containing the fragment limits as x,y coordinates.}
\PYG{k}{struct} \PYG{n}{Fragment}
\PYG{p}{\PYGZob{}}
    \PYG{c+c1}{// the name for the fragment (for reference purposes)}
    \PYG{n}{string} \PYG{n}{name}\PYG{p}{;}
    \PYG{c+c1}{// coordinates for the extremes of the site}
    \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{x\PYGZus{}east}\PYG{p}{,} \PYG{n}{x\PYGZus{}west}\PYG{p}{,} \PYG{n}{y\PYGZus{}north}\PYG{p}{,} \PYG{n}{y\PYGZus{}south}\PYG{p}{;}
    \PYG{c+c1}{// the number of lineages in the fragment.}
    \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{num}\PYG{p}{;}
    \PYG{k+kt}{double} \PYG{n}{area}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}

\PYG{c+c1}{// Class for creating the sample matrix object for easy referencing}

\PYG{k}{class} \PYG{n+nc}{Samplematrix} \PYG{o}{:}  \PYG{k}{public} \PYG{n}{Matrix}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{bool}\PYG{o}{\PYGZgt{}}
\PYG{p}{\PYGZob{}}
\PYG{k}{private}\PYG{o}{:}
    \PYG{k+kt}{bool} \PYG{n}{bIsNull}\PYG{p}{;}
    \PYG{k+kt}{bool} \PYG{n}{bIsFragment}\PYG{p}{;}
    \PYG{n}{Fragment} \PYG{n}{fragment}\PYG{p}{;}
\PYG{k}{public}\PYG{o}{:}
    \PYG{n}{Samplematrix}\PYG{p}{(}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{bIsFragment} \PYG{o}{=} \PYG{n+nb}{false}\PYG{p}{;}
        \PYG{n}{bIsNull} \PYG{o}{=} \PYG{n+nb}{false}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{k+kt}{void} \PYG{n}{setIsNull}\PYG{p}{(}\PYG{k+kt}{bool} \PYG{n}{b}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{bIsNull} \PYG{o}{=} \PYG{n}{b}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{k+kt}{bool} \PYG{n}{getIsNull}\PYG{p}{(}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{return} \PYG{n}{bIsNull}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{k+kt}{bool} \PYG{n}{getTestVal}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{int} \PYG{n}{xval}\PYG{p}{,} \PYG{k+kt}{unsigned} \PYG{k+kt}{int} \PYG{n}{yval}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{return} \PYG{n}{matrix}\PYG{p}{[}\PYG{n}{yval}\PYG{p}{]}\PYG{p}{[}\PYG{n}{xval}\PYG{p}{]}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{k+kt}{bool} \PYG{n}{getVal}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{int} \PYG{n}{xval}\PYG{p}{,} \PYG{k+kt}{unsigned} \PYG{k+kt}{int} \PYG{n}{yval}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{bIsFragment}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{k}{if}\PYG{p}{(}\PYG{n}{fragment}\PYG{p}{.}\PYG{n}{x\PYGZus{}west} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{n}{xval}  \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{n}{xval} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{n}{fragment}\PYG{p}{.}\PYG{n}{x\PYGZus{}east} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{n}{fragment}\PYG{p}{.}\PYG{n}{y\PYGZus{}north} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{n}{yval}  \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{n}{yval} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{n}{fragment}\PYG{p}{.}\PYG{n}{y\PYGZus{}south}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
\PYG{c+c1}{//              cout \PYGZlt{}\PYGZlt{} \PYGZdq{}FRAGMENT TRUE\PYGZdq{} \PYGZlt{}\PYGZlt{} endl;}
\PYG{c+c1}{//              cout \PYGZlt{}\PYGZlt{} \PYGZdq{}x,y\PYGZdq{} \PYGZlt{}\PYGZlt{} xval \PYGZlt{}\PYGZlt{} \PYGZdq{}, \PYGZdq{} \PYGZlt{}\PYGZlt{} yval \PYGZlt{}\PYGZlt{} \PYGZdq{}frag: w,e,n,s: \PYGZdq{} \PYGZlt{}\PYGZlt{} fragment.x\PYGZus{}west \PYGZlt{}\PYGZlt{} \PYGZdq{}, \PYGZdq{} \PYGZlt{}\PYGZlt{} fragment.x\PYGZus{}east \PYGZlt{}\PYGZlt{} \PYGZdq{}, \PYGZdq{} \PYGZlt{}\PYGZlt{} fragment.y\PYGZus{}north \PYGZlt{}\PYGZlt{} \PYGZdq{}, \PYGZdq{} \PYGZlt{}\PYGZlt{} fragment.y\PYGZus{}south \PYGZlt{}\PYGZlt{} endl;}
                \PYG{k}{return} \PYG{n+nb}{true}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
            \PYG{k}{else}
            \PYG{p}{\PYGZob{}}
\PYG{c+c1}{//              cout \PYGZlt{}\PYGZlt{} \PYGZdq{}FRAGMENT FALSE\PYGZdq{} \PYGZlt{}\PYGZlt{} endl;}
                \PYG{k}{return} \PYG{n+nb}{false}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{bIsNull}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{k}{return} \PYG{n+nb}{true}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{else}
        \PYG{p}{\PYGZob{}}
            \PYG{k}{return} \PYG{n}{matrix}\PYG{p}{[}\PYG{n}{yval}\PYG{p}{]}\PYG{p}{[}\PYG{n}{xval}\PYG{p}{]}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
    \PYG{p}{\PYGZcb{}}

     \PYG{k+kt}{void} \PYG{n}{setFragment}\PYG{p}{(}\PYG{n}{Fragment} \PYG{n}{fragment\PYGZus{}in}\PYG{p}{)}
     \PYG{p}{\PYGZob{}}
            \PYG{n}{fragment} \PYG{o}{=} \PYG{n}{fragment\PYGZus{}in}\PYG{p}{;}
\PYG{c+c1}{//          cout \PYGZlt{}\PYGZlt{} \PYGZdq{}W,E,N,S: \PYGZdq{} \PYGZlt{}\PYGZlt{} fragment.x\PYGZus{}west \PYGZlt{}\PYGZlt{} \PYGZdq{}, \PYGZdq{} \PYGZlt{}\PYGZlt{} fragment.x\PYGZus{}east \PYGZlt{}\PYGZlt{} \PYGZdq{}, \PYGZdq{} \PYGZlt{}\PYGZlt{} fragment.y\PYGZus{}north \PYGZlt{}\PYGZlt{} \PYGZdq{}, \PYGZdq{} \PYGZlt{}\PYGZlt{} fragment.y\PYGZus{}south \PYGZlt{}\PYGZlt{} endl;}
            \PYG{n}{bIsFragment} \PYG{o}{=} \PYG{n+nb}{true}\PYG{p}{;}
     \PYG{p}{\PYGZcb{}}

     \PYG{k+kt}{void} \PYG{n}{removeFragment}\PYG{p}{(}\PYG{p}{)}
     \PYG{p}{\PYGZob{}}
         \PYG{n}{bIsFragment} \PYG{o}{=} \PYG{n+nb}{false}\PYG{p}{;}
     \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}





\PYG{k}{class} \PYG{n+nc}{Treelist}
\PYG{p}{\PYGZob{}}
\PYG{k}{private}\PYG{o}{:}
    \PYG{k+kt}{bool} \PYG{n}{bMem}\PYG{p}{;} \PYG{c+c1}{// boolean for whether the database is in memory or not.}
    \PYG{n}{sqlite3} \PYG{o}{*} \PYG{n}{database}\PYG{p}{;}
    \PYG{n}{Row}\PYG{o}{\PYGZlt{}}\PYG{n}{Treenode}\PYG{o}{\PYGZgt{}} \PYG{o}{\PYGZam{}}\PYG{n}{nodes}\PYG{p}{;} \PYG{c+c1}{// in older versions this was called list. Changed to avoid confusion with the built\PYGZhy{}in class.}
    \PYG{n}{Row}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{unsigned} \PYG{k+kt}{int}\PYG{o}{\PYGZgt{}} \PYG{n}{rOut}\PYG{p}{;}
    \PYG{k+kt}{double} \PYG{n}{dSpecRate}\PYG{p}{;}
    \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{iSpecies}\PYG{p}{;}
    \PYG{k+kt}{long} \PYG{k+kt}{double} \PYG{n}{generation}\PYG{p}{;} \PYG{c+c1}{// the time of interest for the simulation}
    \PYG{k+kt}{bool} \PYG{n}{bSample}\PYG{p}{;} \PYG{c+c1}{// checks whether the samplemask has already been imported.}
    \PYG{n}{string} \PYG{n}{samplemaskfile}\PYG{p}{;} \PYG{c+c1}{// stores the name of the file object for referencing.}
    \PYG{n}{Samplematrix} \PYG{n}{samplemask}\PYG{p}{;} \PYG{c+c1}{// the samplemask object for defining the areas we want to sample from.}
    \PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{n}{Fragment}\PYG{o}{\PYGZgt{}} \PYG{n}{fragments}\PYG{p}{;} \PYG{c+c1}{// a vector of fragments for storing each fragment\PYGZsq{}s coordinates.}
    \PYG{c+c1}{// the minimum speciation rate the original simulation was run with (this is read from the database SIMULATION\PYGZus{}PARAMETERS table)}
    \PYG{k+kt}{double} \PYG{n}{min\PYGZus{}spec\PYGZus{}rate}\PYG{p}{;}
    \PYG{c+c1}{// The dimensions of the sample grid size.}
    \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{grid\PYGZus{}x\PYGZus{}size}\PYG{p}{;}
    \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{grid\PYGZus{}y\PYGZus{}size}\PYG{p}{;}

\PYG{k}{public}\PYG{o}{:}
    \PYG{n}{Treelist}\PYG{p}{(}\PYG{n}{Row}\PYG{o}{\PYGZlt{}}\PYG{n}{Treenode}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZam{}}\PYG{n}{r}\PYG{p}{)}\PYG{o}{:}\PYG{n}{nodes}\PYG{p}{(}\PYG{n}{r}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{bMem} \PYG{o}{=} \PYG{n+nb}{false}\PYG{p}{;}
        \PYG{n}{dSpecRate} \PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;}
        \PYG{n}{iSpecies} \PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;}
        \PYG{n}{bSample} \PYG{o}{=} \PYG{n+nb}{false}\PYG{p}{;}
        \PYG{n}{generation} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{k+kt}{void} \PYG{n}{setList}\PYG{p}{(}\PYG{n}{Row}\PYG{o}{\PYGZlt{}}\PYG{n}{Treenode}\PYG{o}{\PYGZgt{}} \PYG{o}{\PYGZam{}}\PYG{n}{l}\PYG{p}{)}\PYG{p}{;}

    \PYG{k+kt}{void} \PYG{n+nf}{setDatabase}\PYG{p}{(}\PYG{n}{sqlite3} \PYG{o}{*} \PYG{n}{dbin}\PYG{p}{)}\PYG{p}{;}

    \PYG{k+kt}{bool} \PYG{n+nf}{hasSetMem}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

    \PYG{k+kt}{double} \PYG{n+nf}{getMinimumSpeciation}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

    \PYG{k+kt}{void} \PYG{n+nf}{importSamplemask}\PYG{p}{(}\PYG{n}{string} \PYG{n}{sSamplemask}\PYG{p}{)}\PYG{p}{;}

    \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n+nf}{countSpecies}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

    \PYG{k+kt}{bool} \PYG{n+nf}{doubleCompare}\PYG{p}{(}\PYG{k+kt}{double} \PYG{n}{d1}\PYG{p}{,} \PYG{k+kt}{double} \PYG{n}{d2}\PYG{p}{,} \PYG{k+kt}{double} \PYG{n}{epsilon}\PYG{p}{)}\PYG{p}{;}

    \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n+nf}{calcSpecies}\PYG{p}{(}\PYG{k+kt}{double} \PYG{n}{s}\PYG{p}{)}\PYG{p}{;}

    \PYG{k+kt}{void} \PYG{n+nf}{calcSpeciesAbundance}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

    \PYG{k+kt}{void} \PYG{n+nf}{resetTree}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

    \PYG{k+kt}{void} \PYG{n+nf}{detectDimensions}\PYG{p}{(}\PYG{n}{string} \PYG{n}{db}\PYG{p}{)}\PYG{p}{;}


    \PYG{k+kt}{void} \PYG{n+nf}{importData}\PYG{p}{(}\PYG{n}{string} \PYG{n}{inputfile}\PYG{p}{)}\PYG{p}{;}

    \PYG{k+kt}{void} \PYG{n+nf}{setGeneration}\PYG{p}{(}\PYG{k+kt}{long} \PYG{k+kt}{double} \PYG{n}{generationin}\PYG{p}{)}
    \PYG{p}{;}

    \PYG{k+kt}{void} \PYG{n+nf}{createDatabase}\PYG{p}{(}\PYG{k+kt}{double} \PYG{n}{s}\PYG{p}{)}\PYG{p}{;}

    \PYG{k+kt}{void} \PYG{n+nf}{createFragmentDatabase}\PYG{p}{(}\PYG{k}{const} \PYG{n}{Fragment} \PYG{o}{\PYGZam{}}\PYG{n}{f}\PYG{p}{)}\PYG{p}{;}

    \PYG{k+kt}{void} \PYG{n+nf}{exportDatabase}\PYG{p}{(}\PYG{n}{string} \PYG{n}{outputfile}\PYG{p}{)}\PYG{p}{;}

    \PYG{k+kt}{void} \PYG{n+nf}{recordSpatial}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

    \PYG{k+kt}{void} \PYG{n+nf}{calcFragments}\PYG{p}{(}\PYG{n}{string} \PYG{n}{fragment\PYGZus{}file}\PYG{p}{)}\PYG{p}{;}

    \PYG{k+kt}{void} \PYG{n+nf}{applyFragments}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}

\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif}
\end{sphinxVerbatim}


\subparagraph{Includes}
\label{\detokenize{Exhaled/exhale_file_Treelist.h:includes}}\begin{itemize}
\item {} 
\sphinxcode{CustomExceptions.h} ({\hyperref[\detokenize{Exhaled/exhale_file_CustomExceptions.h:file-customexceptions-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File CustomExceptions.h}}}})

\item {} 
\sphinxcode{Matrix.h} ({\hyperref[\detokenize{Exhaled/exhale_file_Matrix.h:file-matrix-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File Matrix.h}}}})

\item {} 
\sphinxcode{Treenode.h} ({\hyperref[\detokenize{Exhaled/exhale_file_Treenode.h:file-treenode-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File Treenode.h}}}})

\item {} 
\sphinxcode{boost/filesystem.hpp}

\item {} 
\sphinxcode{boost/lexical\_cast.hpp}

\item {} 
\sphinxcode{cmath}

\item {} 
\sphinxcode{cstring}

\item {} 
\sphinxcode{math.h}

\item {} 
\sphinxcode{sqlite3.h}

\item {} 
\sphinxcode{stdexcept}

\item {} 
\sphinxcode{string}

\end{itemize}


\subparagraph{Included By}
\label{\detokenize{Exhaled/exhale_file_Treelist.h:included-by}}\begin{itemize}
\item {} 
{\hyperref[\detokenize{Exhaled/exhale_file_Tree.h:file-tree-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File Tree.h}}}}

\item {} 
{\hyperref[\detokenize{Exhaled/exhale_file_SpeciationCounter.cpp:file-speciationcounter-cpp}]{\sphinxcrossref{\DUrole{std,std-ref}{File SpeciationCounter.cpp}}}}

\item {} 
{\hyperref[\detokenize{Exhaled/exhale_file_Treelist.cpp:file-treelist-cpp}]{\sphinxcrossref{\DUrole{std,std-ref}{File Treelist.cpp}}}}

\end{itemize}


\subparagraph{Classes}
\label{\detokenize{Exhaled/exhale_file_Treelist.h:classes}}\begin{itemize}
\item {} 
{\hyperref[\detokenize{Exhaled/exhale_struct_Fragment:struct-fragment}]{\sphinxcrossref{\DUrole{std,std-ref}{Struct Fragment}}}}

\item {} 
{\hyperref[\detokenize{Exhaled/exhale_class_Samplematrix:class-samplematrix}]{\sphinxcrossref{\DUrole{std,std-ref}{Class Samplematrix}}}}

\item {} 
{\hyperref[\detokenize{Exhaled/exhale_class_Treelist:class-treelist}]{\sphinxcrossref{\DUrole{std,std-ref}{Class Treelist}}}}

\end{itemize}


\subparagraph{Functions}
\label{\detokenize{Exhaled/exhale_file_Treelist.h:functions}}\begin{itemize}
\item {} 
{\hyperref[\detokenize{Exhaled/exhale_function_checkSpeciation:function-checkspeciation}]{\sphinxcrossref{\DUrole{std,std-ref}{Function checkSpeciation}}}}

\end{itemize}


\paragraph{File Treenode.h}
\label{\detokenize{Exhaled/exhale_file_Treenode.h:file-treenode-h}}\label{\detokenize{Exhaled/exhale_file_Treenode.h::doc}}\label{\detokenize{Exhaled/exhale_file_Treenode.h:id1}}

\subparagraph{Definition (\sphinxstyleliteralintitle{Treenode.h})}
\label{\detokenize{Exhaled/exhale_file_Treenode.h:definition-treenode-h}}

\subparagraph{Program Listing for File Treenode.h}
\label{\detokenize{Exhaled/exhale_program_listing_file_Treenode.h:program-listing-for-file-treenode-h}}\label{\detokenize{Exhaled/exhale_program_listing_file_Treenode.h:program-listing-file-treenode-h}}\label{\detokenize{Exhaled/exhale_program_listing_file_Treenode.h::doc}}\begin{itemize}
\item {} 
Return to documentation for {\hyperref[\detokenize{Exhaled/exhale_file_Treenode.h:file-treenode-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File Treenode.h}}}}

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{//This file is part of NECSim project which is released under BSD\PYGZhy{}3 license.}
\PYG{c+c1}{//See file **LICENSE.txt** or visit https://opensource.org/licenses/BSD\PYGZhy{}3\PYGZhy{}Clause) for full license details.}
\PYG{c+c1}{// Datapoint.cpp version 1.01}
\PYG{c+c1}{// Author \PYGZhy{} Samuel Thompson \PYGZhy{} Imperial College London}
\PYG{c+c1}{// with large use of code supplied by James Rosindell (Imperial College London)}
\PYG{c+c1}{// This file contains the datapoint class for usage in coalescence simulations.}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifndef TREENODE}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define TREENODE}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ define version1\PYGZus{}01}

\PYG{c+cm}{/************************************************************}
\PYG{c+cm}{                        TREENODE OBJECT}
\PYG{c+cm}{ ************************************************************/}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}stdio.h\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}iostream\PYGZgt{}}
\PYG{k}{using} \PYG{k}{namespace} \PYG{n}{std}\PYG{p}{;}
\PYG{k}{class} \PYG{n+nc}{Treenode}
\PYG{p}{\PYGZob{}}

\PYG{k}{private}\PYG{o}{:}
    \PYG{k+kt}{bool} \PYG{n}{tip}\PYG{p}{;}
    \PYG{c+c1}{// 0 means that this node is just here to mark a coalescense}
    \PYG{c+c1}{// and therefore this node of no real other relevance}
    \PYG{c+c1}{// 1 means that this node is a leaf node and counts towards diversity}
    \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{parent}\PYG{p}{;}
    \PYG{c+c1}{// this stores the parent of the individual}
    \PYG{c+c1}{// 0 means there is no parent \PYGZhy{} we are at the end of the tree}
    \PYG{c+c1}{// (as far as has been calculated)}
    \PYG{k+kt}{bool} \PYG{n}{speciated}\PYG{p}{;}
    \PYG{c+c1}{// true if this lineage has speciated in which case it should not have a parent}
    \PYG{c+c1}{// because under the present implementation lineages are not traced beyond speciation}

    \PYG{c+c1}{// boolean for checking whether the lineage actually exists at the end. If all children of the lineages have speciated, then the lineage no longer exists.}
    \PYG{k+kt}{bool} \PYG{n}{does\PYGZus{}exist}\PYG{p}{;}

    \PYG{c+c1}{// the species identity of the node}
    \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{species\PYGZus{}id}\PYG{p}{;}

    \PYG{c+c1}{// the following 4 variables describe the position of the lineage in the present day.}
    \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{xpos}\PYG{p}{;}
    \PYG{c+c1}{// x position}
    \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{ypos}\PYG{p}{;}
    \PYG{c+c1}{// y position}
    \PYG{k+kt}{long} \PYG{n}{xwrap}\PYG{p}{;}
    \PYG{c+c1}{// number of wraps of x around the torus}
    \PYG{k+kt}{long} \PYG{n}{ywrap}\PYG{p}{;}
    \PYG{c+c1}{// number of wraps of y around the torus}

    \PYG{k+kt}{long} \PYG{k+kt}{double} \PYG{n}{dSpec}\PYG{p}{;}
    \PYG{c+c1}{// the speciation probability. This needs to be multiplied by the number of generations in order to generate the actual probability.}
    \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{iGen}\PYG{p}{;}
    \PYG{k+kt}{long} \PYG{k+kt}{double} \PYG{n}{generation\PYGZus{}added}\PYG{p}{;}
\PYG{k}{public}\PYG{o}{:}
    \PYG{n}{Treenode}\PYG{p}{(}\PYG{p}{)} \PYG{o}{:} \PYG{n}{tip}\PYG{p}{(}\PYG{n+nb}{false}\PYG{p}{)}\PYG{p}{,}\PYG{n}{parent}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{,}\PYG{n}{speciated}\PYG{p}{(}\PYG{n+nb}{false}\PYG{p}{)}\PYG{p}{,}\PYG{n}{does\PYGZus{}exist}\PYG{p}{(}\PYG{n+nb}{false}\PYG{p}{)}\PYG{p}{,}\PYG{n}{species\PYGZus{}id}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{,}\PYG{n}{xpos}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{,}\PYG{n}{ypos}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{,}\PYG{n}{xwrap}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{,}\PYG{n}{ywrap}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{,} \PYG{n}{dSpec}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{,} \PYG{n}{iGen}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{,}\PYG{n}{generation\PYGZus{}added}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}

    \PYG{p}{\PYGZcb{}}

    \PYG{o}{\PYGZti{}}\PYG{n}{Treenode}\PYG{p}{(}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}

    \PYG{p}{\PYGZcb{}}

    \PYG{k+kt}{void} \PYG{n}{setup}\PYG{p}{(}\PYG{k+kt}{bool} \PYG{n}{z} \PYG{p}{,} \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{xp} \PYG{p}{,} \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{yp} \PYG{p}{,} \PYG{k+kt}{long} \PYG{n}{xi} \PYG{p}{,} \PYG{k+kt}{long} \PYG{n}{yi}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{tip} \PYG{o}{=} \PYG{n}{z}\PYG{p}{;}
        \PYG{n}{parent} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
        \PYG{n}{speciated} \PYG{o}{=} \PYG{n+nb}{false}\PYG{p}{;}

        \PYG{n}{species\PYGZus{}id} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}

        \PYG{n}{xpos} \PYG{o}{=} \PYG{n}{xp}\PYG{p}{;}
        \PYG{n}{ypos} \PYG{o}{=} \PYG{n}{yp}\PYG{p}{;}
        \PYG{n}{xwrap} \PYG{o}{=} \PYG{n}{xi}\PYG{p}{;}
        \PYG{n}{ywrap} \PYG{o}{=} \PYG{n}{yi}\PYG{p}{;}
        \PYG{n}{dSpec} \PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;}
        \PYG{n}{iGen} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
        \PYG{n}{generation\PYGZus{}added} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{k+kt}{void} \PYG{n}{setup}\PYG{p}{(}\PYG{k+kt}{bool} \PYG{n}{z} \PYG{p}{,} \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{xp} \PYG{p}{,} \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{yp} \PYG{p}{,} \PYG{k+kt}{long} \PYG{n}{xi} \PYG{p}{,} \PYG{k+kt}{long} \PYG{n}{yi}\PYG{p}{,} \PYG{k+kt}{long} \PYG{k+kt}{double} \PYG{n}{generation}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{tip} \PYG{o}{=} \PYG{n}{z}\PYG{p}{;}
        \PYG{n}{parent} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
        \PYG{n}{speciated} \PYG{o}{=} \PYG{n+nb}{false}\PYG{p}{;}

        \PYG{n}{species\PYGZus{}id} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}

        \PYG{n}{xpos} \PYG{o}{=} \PYG{n}{xp}\PYG{p}{;}
        \PYG{n}{ypos} \PYG{o}{=} \PYG{n}{yp}\PYG{p}{;}
        \PYG{n}{xwrap} \PYG{o}{=} \PYG{n}{xi}\PYG{p}{;}
        \PYG{n}{ywrap} \PYG{o}{=} \PYG{n}{yi}\PYG{p}{;}
        \PYG{n}{dSpec} \PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;}
        \PYG{n}{iGen} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
        \PYG{n}{generation\PYGZus{}added} \PYG{o}{=} \PYG{n}{generation}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{c+c1}{// standard setters}

    \PYG{k+kt}{void} \PYG{n}{setExistance}\PYG{p}{(}\PYG{k+kt}{bool} \PYG{n}{b}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{does\PYGZus{}exist} \PYG{o}{=} \PYG{n}{b}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{k+kt}{void} \PYG{n}{setParent}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{x}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{parent} \PYG{o}{=} \PYG{n}{x}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{k+kt}{void} \PYG{n}{qReset}\PYG{p}{(}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{species\PYGZus{}id} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
        \PYG{n}{does\PYGZus{}exist} \PYG{o}{=} \PYG{n+nb}{false}\PYG{p}{;}
        \PYG{n}{speciated} \PYG{o}{=} \PYG{n+nb}{false}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{k+kt}{void} \PYG{n}{setPosition}\PYG{p}{(}\PYG{k+kt}{long} \PYG{n}{x}\PYG{p}{,}\PYG{k+kt}{long} \PYG{n}{y}\PYG{p}{,} \PYG{k+kt}{long} \PYG{n}{xw}\PYG{p}{,} \PYG{k+kt}{long} \PYG{n}{yw}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{xpos} \PYG{o}{=} \PYG{n}{x}\PYG{p}{;}
        \PYG{n}{ypos} \PYG{o}{=} \PYG{n}{y}\PYG{p}{;}
        \PYG{n}{xwrap} \PYG{o}{=} \PYG{n}{xw}\PYG{p}{;}
        \PYG{n}{ywrap} \PYG{o}{=} \PYG{n}{yw}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{k+kt}{void} \PYG{n}{setSpec}\PYG{p}{(}\PYG{k+kt}{long} \PYG{k+kt}{double} \PYG{n}{d}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{dSpec} \PYG{o}{=} \PYG{n}{d}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{k+kt}{void} \PYG{n}{setIGen}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{g}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{iGen} \PYG{o}{=} \PYG{n}{g}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{k+kt}{void} \PYG{n}{setGeneration}\PYG{p}{(}\PYG{k+kt}{long} \PYG{k+kt}{double} \PYG{n}{d}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{generation\PYGZus{}added} \PYG{o}{=} \PYG{n}{d}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{k+kt}{void} \PYG{n}{setSpeciation}\PYG{p}{(}\PYG{k+kt}{bool} \PYG{n}{s}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{speciated} \PYG{o}{=} \PYG{n}{s}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{k+kt}{void} \PYG{n}{burnSpecies}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{idin}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{if} \PYG{p}{(}\PYG{n}{species\PYGZus{}id} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{species\PYGZus{}id} \PYG{o}{=} \PYG{n}{idin}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
    \PYG{p}{\PYGZcb{}}

    \PYG{k+kt}{void} \PYG{n}{setTip}\PYG{p}{(}\PYG{k+kt}{bool} \PYG{n}{b}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{tip} \PYG{o}{=} \PYG{n}{b}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{k+kt}{void} \PYG{n}{resetSpecies}\PYG{p}{(}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{species\PYGZus{}id} \PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{k+kt}{void} \PYG{n}{increaseGen}\PYG{p}{(}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{iGen}\PYG{o}{+}\PYG{o}{+}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{c+c1}{// we don\PYGZsq{}t allow the other variables to be changed}
    \PYG{c+c1}{// because they only need to be set once at the start of the coalescence}
    \PYG{c+c1}{// it\PYGZsq{}s actually safer to leave out setters.}
    \PYG{c+c1}{// similarly we don\PYGZsq{}t allow speciation to be changed once it has been set.}

    \PYG{c+c1}{// standard getters}

    \PYG{k+kt}{bool} \PYG{n}{getExistance}\PYG{p}{(}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{return} \PYG{n}{does\PYGZus{}exist}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{k+kt}{bool} \PYG{n}{isTip}\PYG{p}{(}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{return} \PYG{n}{tip}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{getParent}\PYG{p}{(}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{return} \PYG{n}{parent}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{getXpos}\PYG{p}{(}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{return} \PYG{n}{xpos}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{getYpos}\PYG{p}{(}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{return} \PYG{n}{ypos}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{k+kt}{long} \PYG{n}{getXwrap}\PYG{p}{(}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{return} \PYG{n}{xwrap}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{k+kt}{long} \PYG{n}{getYwrap}\PYG{p}{(}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{return} \PYG{n}{ywrap}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{k+kt}{bool} \PYG{n}{hasSpeciated}\PYG{p}{(}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{return} \PYG{p}{(}\PYG{n}{speciated}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{getSpeciesID}\PYG{p}{(}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{return} \PYG{p}{(}\PYG{n}{species\PYGZus{}id}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{k+kt}{long} \PYG{k+kt}{double} \PYG{n}{getSpecRate}\PYG{p}{(}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{return} \PYG{n}{dSpec}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{getGenRate}\PYG{p}{(}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{return} \PYG{n}{iGen}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{k+kt}{long} \PYG{k+kt}{double} \PYG{n}{getGeneration}\PYG{p}{(}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{return} \PYG{n}{generation\PYGZus{}added}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{c+c1}{// routines}

    \PYG{k+kt}{void} \PYG{n}{speciate}\PYG{p}{(}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{speciated} \PYG{o}{=} \PYG{n+nb}{true}\PYG{p}{;}
\PYG{c+c1}{//      parent = \PYGZhy{}1;}
    \PYG{p}{\PYGZcb{}}

    \PYG{k}{friend} \PYG{n}{ostream}\PYG{o}{\PYGZam{}} \PYG{k}{operator}\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{p}{(}\PYG{n}{ostream}\PYG{o}{\PYGZam{}} \PYG{n}{os}\PYG{p}{,}\PYG{k}{const} \PYG{n}{Treenode}\PYG{o}{\PYGZam{}} \PYG{n}{t}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{c+c1}{//os \PYGZlt{}\PYGZlt{} m.numRows\PYGZlt{}\PYGZlt{}\PYGZdq{} , \PYGZdq{}\PYGZlt{}\PYGZlt{}m.numCols\PYGZlt{}\PYGZlt{}\PYGZdq{} , \PYGZdq{}\PYGZlt{}\PYGZlt{}endl;}
        \PYG{c+c1}{//}
        \PYG{n}{os} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{n}{t}\PYG{p}{.}\PYG{n}{tip} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{,}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{t}\PYG{p}{.}\PYG{n}{parent} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{,}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{t}\PYG{p}{.}\PYG{n}{speciated} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{,}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{t}\PYG{p}{.}\PYG{n}{does\PYGZus{}exist} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{,}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{t}\PYG{p}{.}\PYG{n}{species\PYGZus{}id} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{,}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{t}\PYG{p}{.}\PYG{n}{xpos} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{,}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{t}\PYG{p}{.}\PYG{n}{ypos} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{,}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{t}\PYG{p}{.}\PYG{n}{xwrap} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{,}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
        \PYG{n}{os} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{t}\PYG{p}{.}\PYG{n}{ywrap} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{,}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{t}\PYG{p}{.}\PYG{n}{dSpec} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{,}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{t}\PYG{p}{.}\PYG{n}{iGen} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{,}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{t}\PYG{p}{.}\PYG{n}{generation\PYGZus{}added} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{,}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
        \PYG{k}{return} \PYG{n}{os}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{k}{friend} \PYG{n}{istream}\PYG{o}{\PYGZam{}} \PYG{k}{operator}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{n}{istream}\PYG{o}{\PYGZam{}} \PYG{n}{is}\PYG{p}{,}\PYG{n}{Treenode}\PYG{o}{\PYGZam{}} \PYG{n}{t}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{c+c1}{//is \PYGZlt{}\PYGZlt{} m.numRows\PYGZlt{}\PYGZlt{}\PYGZdq{} , \PYGZdq{}\PYGZlt{}\PYGZlt{}m.numCols\PYGZlt{}\PYGZlt{}\PYGZdq{} , \PYGZdq{}\PYGZlt{}\PYGZlt{}endl;}
        \PYG{k+kt}{char} \PYG{n}{delim}\PYG{p}{;}
        \PYG{n}{is} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}}\PYG{n}{t}\PYG{p}{.}\PYG{n}{tip} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{delim} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{t}\PYG{p}{.}\PYG{n}{parent} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{delim} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{t}\PYG{p}{.}\PYG{n}{speciated} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{delim} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{t}\PYG{p}{.}\PYG{n}{does\PYGZus{}exist} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{delim} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{t}\PYG{p}{.}\PYG{n}{species\PYGZus{}id} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{delim} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{t}\PYG{p}{.}\PYG{n}{xpos} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{delim}\PYG{p}{;}
        \PYG{n}{is} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{t}\PYG{p}{.}\PYG{n}{ypos} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{delim} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{t}\PYG{p}{.}\PYG{n}{xwrap} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{delim} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{t}\PYG{p}{.}\PYG{n}{ywrap} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{delim} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{t}\PYG{p}{.}\PYG{n}{dSpec} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{delim} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{t}\PYG{p}{.}\PYG{n}{iGen} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{delim} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{t}\PYG{p}{.}\PYG{n}{generation\PYGZus{}added} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{delim}\PYG{p}{;}
        \PYG{k}{return} \PYG{n}{is}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}

\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif}
\end{sphinxVerbatim}


\subparagraph{Includes}
\label{\detokenize{Exhaled/exhale_file_Treenode.h:includes}}\begin{itemize}
\item {} 
\sphinxcode{iostream}

\item {} 
\sphinxcode{stdio.h}

\end{itemize}


\subparagraph{Included By}
\label{\detokenize{Exhaled/exhale_file_Treenode.h:included-by}}\begin{itemize}
\item {} 
{\hyperref[\detokenize{Exhaled/exhale_file_Tree.h:file-tree-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File Tree.h}}}}

\item {} 
{\hyperref[\detokenize{Exhaled/exhale_file_Treelist.h:file-treelist-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File Treelist.h}}}}

\end{itemize}


\subparagraph{Classes}
\label{\detokenize{Exhaled/exhale_file_Treenode.h:classes}}\begin{itemize}
\item {} 
{\hyperref[\detokenize{Exhaled/exhale_class_Treenode:class-treenode}]{\sphinxcrossref{\DUrole{std,std-ref}{Class Treenode}}}}

\end{itemize}


\subparagraph{Defines}
\label{\detokenize{Exhaled/exhale_file_Treenode.h:defines}}\begin{itemize}
\item {} 
{\hyperref[\detokenize{Exhaled/exhale_define_version1_01:define-version1-01}]{\sphinxcrossref{\DUrole{std,std-ref}{Define version1\_01}}}}

\end{itemize}


\chapter{Indices and tables}
\label{\detokenize{index:indices-and-tables}}\begin{itemize}
\item {} 
\DUrole{xref,std,std-ref}{genindex}

\item {} 
\DUrole{xref,std,std-ref}{modindex}

\item {} 
\DUrole{xref,std,std-ref}{search}

\end{itemize}


\chapter{Citations}
\label{\detokenize{index:citations}}
\begin{sphinxthebibliography}{Hubbell2001}
\bibitem[Hubbell2001]{\detokenize{Hubbell2001}}{\phantomsection\label{\detokenize{index:hubbell2001}} 
Hubbell, S. P. (2001). The Unified Neutral Theory of Biodiversity and Biogeography. Monographs in Population Biology, 17(3), 375. \url{http://doi.org/10.1016/S0006-3207(02)00228-8}
}
\end{sphinxthebibliography}


\renewcommand{\indexname}{Python Module Index}
\begin{sphinxtheindex}
\def\bigletter#1{{\Large\sffamily#1}\nopagebreak\vspace{1mm}}
\bigletter{p}
\item {\sphinxstyleindexentry{PyCoalescence}}\sphinxstyleindexpageref{PyCoalescence:\detokenize{module-PyCoalescence}}
\item {\sphinxstyleindexentry{PyCoalescence.batch\_process}}\sphinxstyleindexpageref{PyCoalescence:\detokenize{module-PyCoalescence.batch_process}}
\item {\sphinxstyleindexentry{PyCoalescence.coal\_analyse}}\sphinxstyleindexpageref{PyCoalescence:\detokenize{module-PyCoalescence.coal_analyse}}
\item {\sphinxstyleindexentry{PyCoalescence.coalescence}}\sphinxstyleindexpageref{PyCoalescence:\detokenize{module-PyCoalescence.coalescence}}
\item {\sphinxstyleindexentry{PyCoalescence.hpc\_setup}}\sphinxstyleindexpageref{PyCoalescence:\detokenize{module-PyCoalescence.hpc_setup}}
\item {\sphinxstyleindexentry{PyCoalescence.setup}}\sphinxstyleindexpageref{PyCoalescence:\detokenize{module-PyCoalescence.setup}}
\end{sphinxtheindex}

\renewcommand{\indexname}{Index}
\printindex
\end{document}