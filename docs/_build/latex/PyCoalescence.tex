%% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,english]{sphinxmanual}
\ifdefined\pdfpxdimen
   \let\sphinxpxdimen\pdfpxdimen\else\newdimen\sphinxpxdimen
\fi \sphinxpxdimen=.75bp\relax

\usepackage[utf8]{inputenc}
\ifdefined\DeclareUnicodeCharacter
 \ifdefined\DeclareUnicodeCharacterAsOptional\else
  \DeclareUnicodeCharacter{00A0}{\nobreakspace}
\fi\fi
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb,amstext}
\usepackage{babel}
\usepackage{times}
\usepackage[Bjarne]{fncychap}
\usepackage{longtable}
\usepackage{sphinx}

\usepackage{geometry}
\usepackage{multirow}
\usepackage{eqparbox}

% Include hyperref last.
\usepackage{hyperref}
% Fix anchor placement for figures with captions.
\usepackage{hypcap}% it must be loaded after hyperref.
% Set up styles of URL: it should be placed after hyperref.
\urlstyle{same}

\addto\captionsenglish{\renewcommand{\figurename}{Fig.}}
\addto\captionsenglish{\renewcommand{\tablename}{Table}}
\addto\captionsenglish{\renewcommand{\literalblockname}{Listing}}

\addto\extrasenglish{\def\pageautorefname{page}}

\setcounter{tocdepth}{1}



\title{pycoalescence Documentation}
\date{Feb 16, 2018}
\release{1.2.5}
\author{Samuel Thompson}
\newcommand{\sphinxlogo}{\sphinxincludegraphics{PyCoal_logo.png}\par}
\renewcommand{\releasename}{Release}
\makeindex

\begin{document}

\maketitle
\sphinxtableofcontents
\phantomsection\label{\detokenize{index::doc}}


pycoalescence is a python package for running and analysing spatially-explicit neutral ecology simulations efficiently and easily.
Input your maps and output a simulated landscape of individuals.

There are two parts to this project. Models are run in {\hyperref[\detokenize{api/api_library:introduction-necsim}]{\sphinxcrossref{\DUrole{std,std-ref}{necsim}}}}, built in \sphinxcode{c++},
using coalescence methods. Most users will not need to use this tool directly.
{\hyperref[\detokenize{README_pycoalescence:introduction-pycoalescence}]{\sphinxcrossref{\DUrole{std,std-ref}{pycoalescence}}}} is an API for necsim that aids setting up, running and
analysing models.


\chapter{pycoalescence}
\label{\detokenize{README_pycoalescence:pycoalescence}}\label{\detokenize{README_pycoalescence:introduction-pycoalescence}}\label{\detokenize{README_pycoalescence::doc}}\label{\detokenize{README_pycoalescence:welcome-to-pycoalescence}}

\section{Introduction}
\label{\detokenize{README_pycoalescence:introduction}}
\sphinxstylestrong{pycoalescence} is a python module for the spatially-explicit coalescence neutral simulator, described
{\hyperref[\detokenize{api/api_library:introduction-necsim}]{\sphinxcrossref{\DUrole{std,std-ref}{here}}}}. \sphinxstylestrong{pycoalescence} provides a pythonic interface for setting up, running and analysing
spatially-explicit neutral simulations. It allows for a swift and clean creation management of simulations.


\section{Features}
\label{\detokenize{README_pycoalescence:features}}
A large number of performance-enhancing features have been implemented, as well as support for a wide number of
scenarios. These include:
\begin{itemize}
\item {} 
Coalescence methods for excellent performance.

\item {} 
Full output of community structure, with species IDs generated for every individual.

\item {} 
Full spatial modelling, using a dispersal kernel to simulate spatial dynamics.

\item {} 
Multiple sampling points, both spatially and temporally.

\item {} 
Simulate in a region much larger than the sample area.

\item {} 
Output of a variety of biodiversity metrics, including species richness, species abundances, beta-diversity and
locations of lineages.

\item {} 
Scalability - support for simulations of tens or hundreds of millions of individuals in a single simulation.

\end{itemize}


\section{Getting started}
\label{\detokenize{README_pycoalescence:getting-started}}
\begin{sphinxShadowBox}
\begin{itemize}
\item {} 
\phantomsection\label{\detokenize{README_pycoalescence:id2}}{\hyperref[\detokenize{README_pycoalescence:installation}]{\sphinxcrossref{Installation}}}

\item {} 
\phantomsection\label{\detokenize{README_pycoalescence:id3}}{\hyperref[\detokenize{README_pycoalescence:performing-simulations}]{\sphinxcrossref{Performing simulations}}}

\item {} 
\phantomsection\label{\detokenize{README_pycoalescence:id4}}{\hyperref[\detokenize{README_pycoalescence:post-simulation-analysis}]{\sphinxcrossref{Post-simulation analysis}}}

\item {} 
\phantomsection\label{\detokenize{README_pycoalescence:id5}}{\hyperref[\detokenize{README_pycoalescence:extended-analysis}]{\sphinxcrossref{Extended analysis}}}

\item {} 
\phantomsection\label{\detokenize{README_pycoalescence:id6}}{\hyperref[\detokenize{README_pycoalescence:testing-install}]{\sphinxcrossref{Testing install}}}

\end{itemize}
\end{sphinxShadowBox}


\subsection{Installation}
\label{\detokenize{README_pycoalescence:installation}}
Currently, only macOS and linux-based operating systems are supported. Windows compatibility will likely be added at a
later date.


\subsubsection{Method}
\label{\detokenize{README_pycoalescence:method}}
Before attempting installation, make sure the {\hyperref[\detokenize{README_pycoalescence:prerequisites}]{\sphinxcrossref{prerequisites are installed}}}. There are a few options for installation.
\phantomsection\label{\detokenize{README_pycoalescence:prerequisites}}\phantomsection\label{\detokenize{README_pycoalescence:prerequisites-are-installed}}\begin{itemize}
\item {} 
Use in-built installation \sphinxstylestrong{{[}recommended{]}}
\begin{itemize}
\item {} 
Simply run \sphinxcode{python setup.py} from the terminal.

\item {} 
You can also run \sphinxcode{python setup.py {[}opts{]}} where \sphinxcode{{[}opts{]}} are
your required compilation flags (see  {\hyperref[\detokenize{README_pycoalescence:compilation-options}]{\sphinxcrossref{Compilation Options}}}). On some systems this requires that \sphinxcode{autoconf} and
\sphinxcode{autotools} are installed on your computer.

\end{itemize}

\item {} 
Use {\hyperref[\detokenize{pycoalescence:module-pycoalescence.setup}]{\sphinxcrossref{\sphinxcode{setup.py}}}} to customise options and install locations. The procedure is the same
as exists in \sphinxcode{main()}.
\begin{quote}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{pycoalescence} \PYG{k+kn}{import} \PYG{n}{setup}
\PYG{c+c1}{\PYGZsh{} Replace with desired install options}
\PYG{n}{setup}\PYG{o}{.}\PYG{n}{run\PYGZus{}configure}\PYG{p}{(}\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZhy{}\PYGZhy{}with\PYGZhy{}hpc}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZhy{}\PYGZhy{}with\PYGZhy{}verbose}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}\PYG{p}{)}
\PYG{c+c1}{\PYGZsh{} This compiles the c++ code in the lib folder to lib/obj for .o files the package directory}
\PYG{c+c1}{\PYGZsh{} and build/sharedpy2 or build/sharedpy3 for .so files (depending on python version)}
\PYG{n}{setup}\PYG{o}{.}\PYG{n}{do\PYGZus{}compile}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}
\end{quote}

\item {} 
Run \sphinxcode{./configure} and \sphinxcode{make} yourself.
\begin{quote}

If you require additional compilation options, run \sphinxcode{./configure} with your options from the lib/ directory. Then
run \sphinxcode{make} and check that installation is complete. The shared object file should be moved into the \sphinxstyleemphasis{build/sharedpyx}
directory, where \sphinxstyleemphasis{x} is the major python version number (2 or 3).
\end{quote}

\item {} 
Custom compilation
\begin{quote}

Compile the c++ files yourself with the required defines and copy the executable to the required directory.
\end{quote}

\end{itemize}

For HPC use, running \sphinxcode{python hpc\_setup.py} (see {\hyperref[\detokenize{pycoalescence:module-pycoalescence.hpc_setup}]{\sphinxcrossref{\sphinxcode{hpc\_setup}}}}) will perform
compilation for an HPC using the intel compiler and copy the executable to \sphinxquotedblright{}../../Code\sphinxquotedblright{} relative to pycoalescence.

\begin{sphinxadmonition}{warning}{Warning:}
Additional steps may have to be taken to ensure availability of the correct packages on HPC systems. Check
with your HPC administrator for details.
\end{sphinxadmonition}

\begin{sphinxadmonition}{note}{Note:}
Separate compiles of the program are usually required for each python installation and virtual environment.
This can cause complications for certain IDEs. If you encounter problems, it is recommended that you run
\sphinxcode{setup.py} from within you IDE.
\end{sphinxadmonition}


\subsubsection{Compilation Options}
\label{\detokenize{README_pycoalescence:sec-compilation-options}}\label{\detokenize{README_pycoalescence:compilation-options}}
These are the possible flags which can be provided during installation as options in \sphinxcode{python setup.py {[}opts{]}}.

\noindent\begin{tabulary}{\linewidth}{|L|L|}
\hline
\sphinxstylethead{\relax 
Option
\unskip}\relax &\sphinxstylethead{\relax 
Description
\unskip}\relax \\
\hline
--with-debug
&
Adds additional debugging information, including writing all messages to a log file.
\\
\hline
--with-gdal=DIR
&
Define a gdal library at DIR
\\
\hline
--with-hpc
&
Compile ready for HPC, using intel's icpc compilation and a variety of optimisation flags.
\\
\hline
--with-boost=DIR
&
Define a boost library at DIR
\\
\hline\end{tabulary}



\subsection{Performing simulations}
\label{\detokenize{README_pycoalescence:performing-simulations}}\label{\detokenize{README_pycoalescence:id1}}

\subsubsection{Setting up simulations}
\label{\detokenize{README_pycoalescence:setting-up-simulations}}
There are two methods for providing configuration options in pycoalescence. Both require the same initial procedure.
The recommended method is:
\begin{enumerate}
\item {} 
Specify simulation parameters
\begin{itemize}
\item {} 
Set simulation parameters using {\hyperref[\detokenize{pycoalescence:pycoalescence.simulation.Simulation.set_simulation_params}]{\sphinxcrossref{\sphinxcode{set\_simulation\_params()}}}}
to set the job number, task number, output directory and other key simulation variables.

\item {} 
Set the map variables by one of the following:
\begin{enumerate}
\item {} 
{\hyperref[\detokenize{pycoalescence:pycoalescence.simulation.Simulation.set_map_parameters}]{\sphinxcrossref{\sphinxcode{set\_map\_parameters()}}}} to input file paths and dimensions

\item {} 
{\hyperref[\detokenize{pycoalescence:pycoalescence.simulation.Simulation.set_map_files}]{\sphinxcrossref{\sphinxcode{set\_map\_files()}}}} to set the map file paths. This
calls {\hyperref[\detokenize{pycoalescence:pycoalescence.simulation.Simulation.detect_map_dimensions}]{\sphinxcrossref{\sphinxcode{detect\_map\_dimensions()}}}} to automatically
detect file offsets and dimensions.

\end{enumerate}

\begin{sphinxadmonition}{tip}{Tip:}
Check {\hyperref[\detokenize{README_pycoalescence:limitations-of-simulation-variables}]{\sphinxcrossref{Limitations of simulation variables}}} for important information on restrictions on simulation
inputs.
\end{sphinxadmonition}

\begin{sphinxadmonition}{note}{Note:}
{\hyperref[\detokenize{pycoalescence:pycoalescence.simulation.Simulation.detect_map_dimensions}]{\sphinxcrossref{\sphinxcode{detect\_map\_dimensions()}}}} requires
that the files are in \sphinxstylestrong{.tif} formats so that file dimensions can be read. If input files are csv format,
method a) should be used.
\end{sphinxadmonition}

\begin{sphinxadmonition}{note}{Note:}
One can specify either \sphinxquotedblleft{}null\sphinxquotedblright{} or \sphinxquotedblleft{}none\sphinxquotedblright{} map types; \sphinxquotedblleft{}null\sphinxquotedblright{} creates a map at the specified
size, whereas \sphinxquotedblleft{}none\sphinxquotedblright{} creates hard boundaries without any in-memory map object created at all. However,
the dimensions of these files must be manually supplied.
\end{sphinxadmonition}

\item {} 
Optionally, also run {\hyperref[\detokenize{pycoalescence:pycoalescence.simulation.Simulation.set_speciation_rates}]{\sphinxcrossref{\sphinxcode{set\_speciation\_rates()}}}}
to set a list of speciation rates to apply at the end of the simulation.

\end{itemize}

\item {} 
Finalise setup
\begin{itemize}
\item {} 
Run {\hyperref[\detokenize{pycoalescence:pycoalescence.simulation.Simulation.finalise_setup}]{\sphinxcrossref{\sphinxcode{finalise\_setup()}}}} to check that simulations are
setup, generate the command to be passed to {\hyperref[\detokenize{api/api_library:introduction-necsim}]{\sphinxcrossref{\DUrole{std,std-ref}{necsim}}}} and create any required config files.

\end{itemize}

\item {} 
Run simulations
\begin{itemize}
\item {} 
Finally, start the simulation using {\hyperref[\detokenize{pycoalescence:pycoalescence.simulation.Simulation.run_coalescence}]{\sphinxcrossref{\sphinxcode{run\_coalescence()}}}}

\end{itemize}

\end{enumerate}


\subsubsection{Custom Configuration Files}
\label{\detokenize{README_pycoalescence:custom-configuration-files}}
Although not recommended for most use-cases, it is possible to manually create a configuration file, instead of relying on
{\hyperref[\detokenize{pycoalescence:pycoalescence.simulation.Simulation.finalise_setup}]{\sphinxcrossref{\sphinxcode{finalise\_setup()}}}} to do it for you. This may be useful if
you want to store the setup file in a particular place. The process is outlined below. There are two general configuration
files, which as default are mainconf\_*job\_num*\_*seed*.txt and the other as timeconf\_*job\_num*\_*seed*.txt.
\begin{enumerate}
\item {} 
Add a temporal sampling configuration file
If you require sampling at points other than the present day, these can be specified in another configuration file.
\begin{itemize}
\item {} 
Add temporal sampling points using {\hyperref[\detokenize{pycoalescence:pycoalescence.simulation.Simulation.add_sample_time}]{\sphinxcrossref{\sphinxcode{add\_sample\_time()}}}}
Multiple sample points can be added.

\item {} 
Create the temporal sampling config file ({\hyperref[\detokenize{pycoalescence:pycoalescence.simulation.Simulation.create_temporal_sampling_config}]{\sphinxcrossref{\sphinxcode{create\_temporal\_sampling\_config()}}}})

\end{itemize}

\item {} 
Generate the main config file
Run {\hyperref[\detokenize{pycoalescence:pycoalescence.simulation.Simulation.create_config}]{\sphinxcrossref{\sphinxcode{create\_config()}}}} to generate the main config file.

\begin{sphinxadmonition}{note}{Note:}
If you wish to use multiple map files or multiple temporal samples and wish to use a main config file as well,
you must call
{\hyperref[\detokenize{pycoalescence:pycoalescence.simulation.Simulation.create_config}]{\sphinxcrossref{\sphinxcode{create\_config()}}}} \sphinxstylestrong{after} both
{\hyperref[\detokenize{pycoalescence:pycoalescence.simulation.Simulation.create_map_config}]{\sphinxcrossref{\sphinxcode{create\_map\_config()}}}} and
{\hyperref[\detokenize{pycoalescence:pycoalescence.simulation.Simulation.create_temporal_sampling_config}]{\sphinxcrossref{\sphinxcode{create\_temporal\_sampling\_config()}}}}
\end{sphinxadmonition}

\begin{sphinxadmonition}{warning}{Warning:}
It is possible to use temporal config files without using a main config file. However,
if you want map or main options in config file, you \sphinxstylestrong{must} use all config options (main config and temporal config).
\end{sphinxadmonition}

\item {} 
Add map configuration options
If you require multiple map files at different points in time, you shall need to create a configuration (.txt or .cfg)
file to make these options accessible to the program.

These configuration options appear in the main configuration file under various headings.
\begin{itemize}
\item {} 
First add the pristine map options using {\hyperref[\detokenize{pycoalescence:pycoalescence.simulation.Simulation.add_pristine_map}]{\sphinxcrossref{\sphinxcode{add\_pristine\_map()}}}}
This can be performed multiple times to add several maps.

\item {} 
Add the options to the configuration file ({\hyperref[\detokenize{pycoalescence:pycoalescence.simulation.Simulation.create_map_config}]{\sphinxcrossref{\sphinxcode{create\_map\_config()}}}})

\end{itemize}

\end{enumerate}

\begin{sphinxadmonition}{note}{Note:}
See {\hyperref[\detokenize{README_pycoalescence:glossary}]{\sphinxcrossref{Glossary}}} for definitions of {\hyperref[\detokenize{README_pycoalescence:term-sample-map}]{\sphinxtermref{\DUrole{xref,std,std-term}{sample map}}}}, {\hyperref[\detokenize{README_pycoalescence:term-fine-map}]{\sphinxtermref{\DUrole{xref,std,std-term}{fine map}}}} and {\hyperref[\detokenize{README_pycoalescence:term-coarse-map}]{\sphinxtermref{\DUrole{xref,std,std-term}{coarse map}}}}.
\end{sphinxadmonition}


\subsubsection{Examples}
\label{\detokenize{README_pycoalescence:examples}}
A simple simulation

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{pycoalescence} \PYG{k+kn}{import} \PYG{n}{Simulation}
\PYG{c+c1}{\PYGZsh{} Set logging level to \PYGZdq{}info\PYGZdq{} (from logging module)}
\PYG{n}{c} \PYG{o}{=} \PYG{n}{Simulation}\PYG{p}{(}\PYG{n}{logging\PYGZus{}level}\PYG{o}{=}\PYG{l+m+mi}{20}\PYG{p}{)}
\PYG{c+c1}{\PYGZsh{} set the main simulation parameters \PYGZhy{} use default values for other keyword arguments}
\PYG{n}{c}\PYG{o}{.}\PYG{n}{set\PYGZus{}simulation\PYGZus{}params}\PYG{p}{(}\PYG{n}{seed}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{job\PYGZus{}type}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{output\PYGZus{}directory}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{output}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{min\PYGZus{}speciation\PYGZus{}rate}\PYG{o}{=}\PYG{l+m+mf}{0.1}\PYG{p}{,}
                        \PYG{n}{sigma}\PYG{o}{=}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{n}{tau}\PYG{o}{=}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{n}{deme}\PYG{o}{=}\PYG{l+m+mi}{10}\PYG{p}{,} \PYG{n}{sample\PYGZus{}size}\PYG{o}{=}\PYG{l+m+mf}{0.1}\PYG{p}{,} \PYG{n}{max\PYGZus{}time}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{c+c1}{\PYGZsh{} Optionally add a set of speciation rates to apply at the end of the simulation}
\PYG{n}{c}\PYG{o}{.}\PYG{n}{set\PYGZus{}speciation\PYGZus{}rates}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mf}{0.1}\PYG{p}{,} \PYG{l+m+mf}{0.2}\PYG{p}{,} \PYG{l+m+mf}{0.3}\PYG{p}{]}\PYG{p}{)}
\PYG{c+c1}{\PYGZsh{} set the map parameters \PYGZhy{} null means the map will be generated with 100\PYGZpc{} cover everywhere (no file input).}
\PYG{n}{c}\PYG{o}{.}\PYG{n}{set\PYGZus{}map\PYGZus{}parameters}\PYG{p}{(}\PYG{n}{sample\PYGZus{}file} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{null}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{sample\PYGZus{}x} \PYG{o}{=} \PYG{l+m+mi}{100}\PYG{p}{,} \PYG{n}{sample\PYGZus{}y}\PYG{o}{=}\PYG{l+m+mi}{100}\PYG{p}{,}
                     \PYG{n}{fine\PYGZus{}file} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{null}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{fine\PYGZus{}x} \PYG{o}{=} \PYG{l+m+mi}{200}\PYG{p}{,} \PYG{n}{fine\PYGZus{}y} \PYG{o}{=} \PYG{l+m+mi}{200}\PYG{p}{,} \PYG{n}{fine\PYGZus{}x\PYGZus{}offset} \PYG{o}{=} \PYG{l+m+mi}{50}\PYG{p}{,} \PYG{n}{fine\PYGZus{}y\PYGZus{}offset} \PYG{o}{=} \PYG{l+m+mi}{50}\PYG{p}{,}
                     \PYG{n}{coarse\PYGZus{}file} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{null}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{coarse\PYGZus{}x} \PYG{o}{=} \PYG{l+m+mi}{1000}\PYG{p}{,} \PYG{n}{coarse\PYGZus{}y} \PYG{o}{=} \PYG{l+m+mi}{1000}\PYG{p}{,}
                     \PYG{n}{coarse\PYGZus{}x\PYGZus{}offset} \PYG{o}{=} \PYG{l+m+mi}{100}\PYG{p}{,} \PYG{n}{coarse\PYGZus{}y\PYGZus{}offset} \PYG{o}{=} \PYG{l+m+mi}{100}\PYG{p}{,} \PYG{n}{coarse\PYGZus{}scale} \PYG{o}{=} \PYG{l+m+mi}{10}\PYG{p}{,}
                     \PYG{n}{pristine\PYGZus{}fine\PYGZus{}map} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{null}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{pristine\PYGZus{}coarse\PYGZus{}map} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{null}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{c+c1}{\PYGZsh{} complete setup and run simulation}
\PYG{n}{c}\PYG{o}{.}\PYG{n}{finalise\PYGZus{}setup}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{c}\PYG{o}{.}\PYG{n}{run\PYGZus{}coalescence}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

A more complex example using config files, multiple temporal sampling points and detection of map dimensions from the
inputted map files.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{pycoalescence} \PYG{k+kn}{import} \PYG{n}{Simulation}
\PYG{n}{c} \PYG{o}{=} \PYG{n}{Simulation}\PYG{p}{(}\PYG{p}{)}
\PYG{c+c1}{\PYGZsh{} set the main simulation parameters}
\PYG{n}{c}\PYG{o}{.}\PYG{n}{set\PYGZus{}simulation\PYGZus{}params}\PYG{p}{(}\PYG{n}{seed}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{job\PYGZus{}type}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{output\PYGZus{}directory}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{output}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{min\PYGZus{}speciation\PYGZus{}rate}\PYG{o}{=}\PYG{l+m+mf}{0.1}\PYG{p}{,}
                        \PYG{n}{sigma}\PYG{o}{=}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{n}{tau}\PYG{o}{=}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{n}{deme}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{sample\PYGZus{}size}\PYG{o}{=}\PYG{l+m+mf}{0.1}
                        \PYG{n}{max\PYGZus{}time}\PYG{o}{=}\PYG{l+m+mi}{100}\PYG{p}{,} \PYG{n}{dispersal\PYGZus{}method}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{normal}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{m\PYGZus{}prob}\PYG{o}{=}\PYG{l+m+mf}{0.0}\PYG{p}{,} \PYG{n}{cutoff}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{dispersal\PYGZus{}relative\PYGZus{}cost}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,}
                        \PYG{n}{min\PYGZus{}num\PYGZus{}species}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{forest\PYGZus{}change\PYGZus{}rate}\PYG{o}{=}\PYG{l+m+mf}{0.2}\PYG{p}{,}
                        \PYG{n}{pristine\PYGZus{}forest\PYGZus{}time}\PYG{o}{=}\PYG{l+m+mi}{200}\PYG{p}{,} \PYG{n}{time\PYGZus{}config\PYGZus{}file}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{null}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{restrict\PYGZus{}self}\PYG{o}{=}\PYG{n+nb+bp}{False}\PYG{p}{,}
                        \PYG{n}{infinite\PYGZus{}landscape}\PYG{o}{=}\PYG{n+nb+bp}{False}\PYG{p}{)}
\PYG{c+c1}{\PYGZsh{} Add a set of speciation rates to be applied at the end of the simulation}
\PYG{n}{c}\PYG{o}{.}\PYG{n}{set\PYGZus{}speciation\PYGZus{}rates}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mf}{0.2}\PYG{p}{,} \PYG{l+m+mf}{0.3}\PYG{p}{,} \PYG{l+m+mf}{0.4}\PYG{p}{]}\PYG{p}{)}
\PYG{c+c1}{\PYGZsh{} set the map files}
\PYG{n}{c}\PYG{o}{.}\PYG{n}{set\PYGZus{}map\PYGZus{}files}\PYG{p}{(}\PYG{n}{sample\PYGZus{}file}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{null}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{fine\PYGZus{}file}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{path/to/fine.tif}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{coarse\PYGZus{}file}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{path/to/coarse.tif}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{c+c1}{\PYGZsh{} add sample times}
\PYG{n}{c}\PYG{o}{.}\PYG{n}{add\PYGZus{}sample\PYGZus{}time}\PYG{p}{(}\PYG{l+m+mf}{0.0}\PYG{p}{)}
\PYG{n}{c}\PYG{o}{.}\PYG{n}{add\PYGZus{}sample\PYGZus{}time}\PYG{p}{(}\PYG{l+m+mf}{1.0}\PYG{p}{)}
\PYG{c+c1}{\PYGZsh{} add pristine maps}
\PYG{n}{c}\PYG{o}{.}\PYG{n}{add\PYGZus{}pristine\PYGZus{}map}\PYG{p}{(}\PYG{n}{fine\PYGZus{}map}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{path/to/pristinefine1.tif}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{coarse\PYGZus{}map}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{path/to/pristinecoarse1.tif}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{time}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{rate}\PYG{o}{=}\PYG{l+m+mf}{0.5}\PYG{p}{)}
\PYG{c+c1}{\PYGZsh{} create configuration files, run the checks and finalise the simulation}
\PYG{n}{c}\PYG{o}{.}\PYG{n}{finalise\PYGZus{}setup}\PYG{p}{(}\PYG{p}{)}
\PYG{c+c1}{\PYGZsh{} run the simulation}
\PYG{n}{c}\PYG{o}{.}\PYG{n}{run\PYGZus{}coalescence}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\begin{sphinxadmonition}{note}{Note:}
necsim can also be run directly using command line arguments (see
{\hyperref[\detokenize{api/api_library:introduction-necsim}]{\sphinxcrossref{\DUrole{std,std-ref}{Introduction to necsim}}}}).
\end{sphinxadmonition}

Example configuration file

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{[}\PYG{n}{sample\PYGZus{}grid}\PYG{p}{]}
\PYG{n}{path} \PYG{o}{=} \PYG{o}{/}\PYG{n}{Data}\PYG{o}{/}\PYG{n}{Maps}\PYG{o}{/}\PYG{n}{maskmap}\PYG{o}{.}\PYG{n}{tif}
\PYG{n}{x} \PYG{o}{=} \PYG{l+m+mi}{486}
\PYG{n}{y} \PYG{o}{=} \PYG{l+m+mi}{517}
\PYG{n}{mask} \PYG{o}{=} \PYG{o}{/}\PYG{n}{Data}\PYG{o}{/}\PYG{n}{Maps}\PYG{o}{/}\PYG{n}{maskmap}\PYG{o}{.}\PYG{n}{tif}

\PYG{p}{[}\PYG{n}{fine\PYGZus{}map}\PYG{p}{]}
\PYG{n}{path} \PYG{o}{=} \PYG{o}{/}\PYG{n}{Data}\PYG{o}{/}\PYG{n}{Maps}\PYG{o}{/}\PYG{n}{finemap}\PYG{o}{.}\PYG{n}{tif}
\PYG{n}{x} \PYG{o}{=} \PYG{l+m+mi}{34000}
\PYG{n}{y} \PYG{o}{=} \PYG{l+m+mi}{28000}
\PYG{n}{x\PYGZus{}off} \PYG{o}{=} \PYG{l+m+mi}{17155}
\PYG{n}{y\PYGZus{}off} \PYG{o}{=} \PYG{l+m+mi}{11178}

\PYG{p}{[}\PYG{n}{coarse\PYGZus{}map}\PYG{p}{]}
\PYG{n}{path} \PYG{o}{=} \PYG{o}{/}\PYG{n}{Data}\PYG{o}{/}\PYG{n}{Maps}\PYG{o}{/}\PYG{n}{coarsemap}\PYG{o}{.}\PYG{n}{tif}
\PYG{n}{x} \PYG{o}{=} \PYG{l+m+mi}{24000}
\PYG{n}{y} \PYG{o}{=} \PYG{l+m+mi}{20000}
\PYG{n}{x\PYGZus{}off} \PYG{o}{=} \PYG{l+m+mi}{10320}
\PYG{n}{y\PYGZus{}off} \PYG{o}{=} \PYG{l+m+mi}{7200}
\PYG{n}{scale} \PYG{o}{=} \PYG{l+m+mf}{10.0}

\PYG{p}{[}\PYG{n}{pristine\PYGZus{}fine0}\PYG{p}{]}
\PYG{n}{path} \PYG{o}{=} \PYG{n}{none}
\PYG{n}{number} \PYG{o}{=} \PYG{l+m+mi}{0}
\PYG{n}{time} \PYG{o}{=} \PYG{l+m+mi}{200}
\PYG{n}{rate} \PYG{o}{=} \PYG{l+m+mi}{0}

\PYG{p}{[}\PYG{n}{pristine\PYGZus{}coarse0}\PYG{p}{]}
\PYG{n}{path} \PYG{o}{=} \PYG{n}{none}
\PYG{n}{number} \PYG{o}{=} \PYG{l+m+mi}{0}
\PYG{n}{time} \PYG{o}{=} \PYG{l+m+mi}{200}
\PYG{n}{rate} \PYG{o}{=} \PYG{l+m+mi}{0}

\PYG{p}{[}\PYG{n}{pristine\PYGZus{}fine1}\PYG{p}{]}
\PYG{n}{path} \PYG{o}{=} \PYG{n}{none}
\PYG{n}{number} \PYG{o}{=} \PYG{l+m+mi}{1}
\PYG{n}{time} \PYG{o}{=} \PYG{l+m+mi}{200}
\PYG{n}{rate} \PYG{o}{=} \PYG{l+m+mi}{0}

\PYG{p}{[}\PYG{n}{pristine\PYGZus{}coarse1}\PYG{p}{]}
\PYG{n}{path} \PYG{o}{=} \PYG{n}{none}
\PYG{n}{number} \PYG{o}{=} \PYG{l+m+mi}{1}
\PYG{n}{time} \PYG{o}{=} \PYG{l+m+mi}{200}
\PYG{n}{rate} \PYG{o}{=} \PYG{l+m+mi}{0}

\PYG{p}{[}\PYG{n}{dispersal}\PYG{p}{]}
\PYG{n}{method} \PYG{o}{=} \PYG{n}{norm}\PYG{o}{\PYGZhy{}}\PYG{n}{uniform}
\PYG{n}{m\PYGZus{}probability} \PYG{o}{=} \PYG{l+m+mf}{1e\PYGZhy{}10}
\PYG{n}{cutoff} \PYG{o}{=} \PYG{l+m+mi}{0}
\PYG{n}{restrict\PYGZus{}self} \PYG{o}{=} \PYG{l+m+mi}{0}
\PYG{n}{infinite\PYGZus{}landscape} \PYG{o}{=} \PYG{l+m+mi}{0}

\PYG{p}{[}\PYG{n}{main}\PYG{p}{]}
\PYG{n}{seed} \PYG{o}{=} \PYG{l+m+mi}{1}
\PYG{n}{job\PYGZus{}type} \PYG{o}{=} \PYG{l+m+mi}{2}
\PYG{n}{map\PYGZus{}config} \PYG{o}{=} \PYG{n}{output}\PYG{o}{/}\PYG{n}{mainconf\PYGZus{}2\PYGZus{}1}\PYG{o}{.}\PYG{n}{txt}
\PYG{n}{output\PYGZus{}directory} \PYG{o}{=} \PYG{n}{output}\PYG{o}{/}
\PYG{n}{min\PYGZus{}spec\PYGZus{}rate} \PYG{o}{=} \PYG{l+m+mf}{1e\PYGZhy{}05}
\PYG{n}{sigma} \PYG{o}{=} \PYG{l+m+mf}{0.5}
\PYG{n}{tau} \PYG{o}{=} \PYG{l+m+mi}{2}
\PYG{n}{deme} \PYG{o}{=} \PYG{l+m+mi}{10}
\PYG{n}{sample\PYGZus{}size} \PYG{o}{=} \PYG{l+m+mf}{0.1}
\PYG{n}{max\PYGZus{}time} \PYG{o}{=} \PYG{l+m+mi}{2000}
\PYG{n}{dispersal\PYGZus{}relative\PYGZus{}cost} \PYG{o}{=} \PYG{l+m+mi}{1}
\PYG{n}{time\PYGZus{}config} \PYG{o}{=} \PYG{n}{null}
\PYG{n}{min\PYGZus{}species} \PYG{o}{=} \PYG{l+m+mi}{1}
\end{sphinxVerbatim}


\subsubsection{Dispersal Kernels}
\label{\detokenize{README_pycoalescence:dispersal-kernels}}
Three different dispersal functions are currently supported, which take some combination of the \sphinxstyleemphasis{sigma} (\(\sigma\))
, \sphinxstyleemphasis{tau} (\(\tau\) ), \sphinxstyleemphasis{m\_prob} (\(m\) ) and \sphinxstyleemphasis{cutoff} (\(c\) ) dispersal parameters. You only need to provide
the required parameters for each dispersal method; any additional parameters provided will be ignored.
\begin{itemize}
\item {} \begin{description}
\item[{Normal distribution (the default)}] \leavevmode
This requires \(\sigma\) only (the standard deviation). The outputted dispersal kernel in two dimensions
will follow a Rayleigh distribution for dispersal distance, \(N(r)\)

\end{description}

\item {} \begin{description}
\item[{Fat-tailed distribution}] \leavevmode
This requires both \(\sigma\) and \(\tau\). Importantly, for our fat-tailed dispersal kernel, \(F(r)\),
\(\lim{\tau \to \inf} = N(r)\). Within this dispersal kernel, there is an increased chance of long-distance
dispersal (but lower than the normal-uniform dispersal kernel).

\end{description}

\item {} \begin{description}
\item[{Normal-uniform distribution}] \leavevmode
This requires \(\sigma\), \(m\) and \(c\) . Here, we pick with probability \(1-m\) from a normal
distribution with standard deviation \(\sigma\), and probability \(m\) from a uniform distribution. This
uniform distribution picks a random distance equally between 0 and \(c\), the maximal dispersal distance. For
very large \(c\), extremely long distance dispersal is possible.

\end{description}

\end{itemize}

\sphinxstylestrong{pycoalescence} also has the ability to simulate a dispersal kernel on a landscape. For more information about that
process, see \DUrole{xref,std,std-ref}{here}


\subsubsection{Limitations of simulation variables}
\label{\detokenize{README_pycoalescence:limitations-of-simulation-variables}}
\begin{sphinxadmonition}{important}{Important:}
This section contains key information about the simulation inputs. Please read carefully to minimise any
unnecessary bugs.
\end{sphinxadmonition}

Certain simulation variables have limitations, depending on the method of setting up the simulation.
\begin{itemize}
\item {} 
Map variables set up using {\hyperref[\detokenize{pycoalescence:pycoalescence.simulation.Simulation.set_map_parameters}]{\sphinxcrossref{\sphinxcode{set\_map\_parameters()}}}}
\begin{itemize}
\item {} 
Sample map dimensions must be smaller than fine map dimensions.

\item {} 
Fine map dimensions must be smaller than coarse map dimensions (supplied at the resolution of the fine map files).

\item {} 
Dimensions of pristine fine and coarse maps must match their respective current map dimensions.

\item {} 
All offsets must maintain the smaller map within the larger map

\item {} 
If any files are supplied as `null', map sizes must still be provided. This is important for sample map size, but
should be corrected in a future update for coarse map files.

\end{itemize}

\item {} 
Map files (and variables) set using {\hyperref[\detokenize{pycoalescence:pycoalescence.simulation.Simulation.set_map_files}]{\sphinxcrossref{\sphinxcode{set\_map\_files()}}}}
\begin{quote}
\begin{itemize}
\item {} 
In addition to the above conditions being true, the files must all be georeferenced, so that coarse and fine map
dimensions will be read correctly.

\end{itemize}

\begin{sphinxadmonition}{hint}{Hint:}
Use a GIS program (such as ArcGIS or QGIS) for manipulation of map files to
ensure georeferencing is preserved.
\end{sphinxadmonition}
\begin{itemize}
\item {} 
If the samplemask map is \sphinxquotedblleft{}null\sphinxquotedblright{}, the program will read the dimensions from the fine map and choose that as the
area to sample entirely over. Supplying \sphinxquotedblleft{}null\sphinxquotedblright{} will therefore sample the entirety of the fine map.

\end{itemize}

\begin{sphinxadmonition}{hint}{Hint:}
Scalings and offsets between maps should also work correctly, but if problems are encountered, try manually
specifying offsets and dimensions to identify any problems.
\end{sphinxadmonition}
\end{quote}

\end{itemize}

An example of how the map files are related is shown below. Black arrows indicate the offsets for the fine map (in the x
and y dimensions) and purple arrows indicate the offsets for the coarse map.

\noindent\sphinxincludegraphics{{grid_sample}.png}


\subsubsection{Infinite Landscapes}
\label{\detokenize{README_pycoalescence:infinite-landscapes}}
Simulations can also be run on infinite landscapes. Set \sphinxcode{infinite\_landscapes=opt} in
{\hyperref[\detokenize{pycoalescence:pycoalescence.simulation.Simulation.set_simulation_params}]{\sphinxcrossref{\sphinxcode{set\_simulation\_params()}}}} where \sphinxstyleemphasis{opt} is one of the
following:
\begin{itemize}
\item {} \begin{description}
\item[{\sphinxquotedblleft{}closed\sphinxquotedblright{} (default)}] \leavevmode
Run without infinite landscapes, with closed boundaries to the coarse map.

\end{description}

\item {} \begin{description}
\item[{\sphinxquotedblleft{}infinite\sphinxquotedblright{}}] \leavevmode
Run with a pristine infinite landscape outside of the coares map boundaries.

\end{description}

\item {} \begin{description}
\item[{\sphinxquotedblleft{}tiled\_coarse\sphinxquotedblright{}}] \leavevmode
Tile the coarse map infinitely in all dimensions.

\end{description}

\item {} \begin{description}
\item[{\sphinxquotedblleft{}tiled\_fine\sphinxquotedblright{}}] \leavevmode
Tile the fine map infinitely in all dimensions.

\end{description}

\end{itemize}


\subsubsection{Optimising Simulations}
\label{\detokenize{README_pycoalescence:optimising-simulations}}
{\hyperref[\detokenize{pycoalescence:pycoalescence.simulation.Simulation.optimise_ram}]{\sphinxcrossref{\sphinxcode{optimise\_ram()}}}} exists for reducing the RAM requirements of
a simulation. Running the function with a specific RAM limit, in GB, should choose a sample map size and offsets to
minimise the in-memory object sizes. This may have a minor impact on simulation speed, but this is likely negligible.
After the function is run, the {\hyperref[\detokenize{pycoalescence:pycoalescence.simulation.Simulation}]{\sphinxcrossref{\sphinxcode{Simulation class}}}} should have re-defined
the grid x and y dimensions to be the largest size possible to simulate for the required memory. The sample map offsets
from the grid are then also stored, such that the grid encompasses the area with the highest number of individuals.

{\hyperref[\detokenize{pycoalescence:pycoalescence.simulation.Simulation.optimise_ram}]{\sphinxcrossref{\sphinxcode{optimise\_ram()}}}} may take some time to run. However, for a
single set of simulations with the same RAM limit, this function should only need to be completed once. Getting and
setting the optimised solution is therefore possible with
{\hyperref[\detokenize{pycoalescence:pycoalescence.simulation.Simulation.get_optimised_solution}]{\sphinxcrossref{\sphinxcode{get\_optimised\_solution()}}}} and
{\hyperref[\detokenize{pycoalescence:pycoalescence.simulation.Simulation.set_optimised_solution}]{\sphinxcrossref{\sphinxcode{set\_optimised\_solution()}}}}. The whole procedure is
outlined below.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} Detect the RAM\PYGZhy{}optimised solution}
\PYG{o}{\PYGZgt{}\PYGZgt{}} \PYG{n}{sim1}\PYG{o}{.}\PYG{n}{optimise\PYGZus{}ram}\PYG{p}{(}\PYG{p}{)}
\PYG{c+c1}{\PYGZsh{} Get the optimised solution for Simulation object sim1}
\PYG{o}{\PYGZgt{}\PYGZgt{}} \PYG{n}{sim1}\PYG{o}{.}\PYG{n}{get\PYGZus{}optimised\PYGZus{}solution}\PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{grid\PYGZus{}file\PYGZus{}name}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{set}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{grid\PYGZus{}x\PYGZus{}size}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+m+mi}{5134}\PYG{p}{,}
\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{grid\PYGZus{}y\PYGZus{}size}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+m+mi}{5134}\PYG{p}{,}
\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{sample\PYGZus{}x\PYGZus{}offset}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+m+mi}{8208}\PYG{p}{,}
\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{sample\PYGZus{}y\PYGZus{}offset}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+m+mi}{14877}\PYG{p}{\PYGZcb{}}
\PYG{c+c1}{\PYGZsh{} Now set the optimised solution for Simulation object sim2}
\PYG{o}{\PYGZgt{}\PYGZgt{}} \PYG{n}{sim2}\PYG{o}{.}\PYG{n}{set\PYGZus{}optimised\PYGZus{}solution}\PYG{p}{(}\PYG{p}{\PYGZob{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{grid\PYGZus{}file\PYGZus{}name}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{set}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
                              \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{grid\PYGZus{}x\PYGZus{}size}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+m+mi}{5134}\PYG{p}{,}
                              \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{grid\PYGZus{}y\PYGZus{}size}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+m+mi}{5134}\PYG{p}{,}
                              \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{sample\PYGZus{}x\PYGZus{}offset}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+m+mi}{8208}\PYG{p}{,}
                              \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{sample\PYGZus{}y\PYGZus{}offset}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+m+mi}{14877}\PYG{p}{\PYGZcb{}}\PYG{p}{)}
\end{sphinxVerbatim}


\subsection{Post-simulation analysis}
\label{\detokenize{README_pycoalescence:postsim-analysis}}\label{\detokenize{README_pycoalescence:post-simulation-analysis}}
Once simulations are complete, necsim's {\hyperref[\detokenize{api/api_library:introduction-speciationcounter}]{\sphinxcrossref{\DUrole{std,std-ref}{applying speciation rates functionality}}}}
can be used to apply additional speciation rates to the coalescence tree. A simple way of applying additional simulation
rates is provided within the {\hyperref[\detokenize{pycoalescence:pycoalescence.coalescence_tree.CoalescenceTree}]{\sphinxcrossref{\sphinxcode{CoalescenceTree class}}}}.

The two functions for this routine are
\begin{itemize}
\item {} 
{\hyperref[\detokenize{pycoalescence:pycoalescence.coalescence_tree.CoalescenceTree.set_speciation_params}]{\sphinxcrossref{\sphinxcode{set\_speciation\_params()}}}} which takes as

\end{itemize}
\begin{quote}

arguments
\begin{itemize}
\item {} 
the SQL database file containing a finished simulation

\item {} 
T/F of recording full spatial data

\item {} 
either a csv file containing fragment data, or T/F for whether
fragments should be calculated from squares of continuous habitat.
* list of speciation rates to apply

\item {} 
{[}optional{]} a sample file to specify certain cells to sample from

\item {} 
{[}optional{]} a config file containing the temporal sampling points
desired.

\end{itemize}
\end{quote}
\begin{itemize}
\item {} 
{\hyperref[\detokenize{pycoalescence:pycoalescence.coalescence_tree.CoalescenceTree.apply_speciation}]{\sphinxcrossref{\sphinxcode{apply\_speciation()}}}} performs the analysis. This can be extremely
RAM and time-intensive for simulations of a large number of individuals. The calculations will
be stored in extra tables within the same SQL file as originally
specified.

\end{itemize}

The procedure for applying additional speciation rates to an existing database is

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{pycoalescence} \PYG{k+kn}{import} \PYG{n}{CoalescenceTree}
\PYG{n}{t} \PYG{o}{=} \PYG{n}{CoalescenceTree}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{speciation\PYGZus{}rates} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mf}{0.1}\PYG{p}{,} \PYG{l+m+mf}{0.2} \PYG{p}{,}\PYG{l+m+mf}{0.3}\PYG{p}{]}
\PYG{n}{t}\PYG{o}{.}\PYG{n}{set\PYGZus{}database}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{output/SQL\PYGZus{}data/data\PYGZus{}1\PYGZus{}1.db}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{t}\PYG{o}{.}\PYG{n}{set\PYGZus{}speciation\PYGZus{}params}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{T}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{null}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{speciation\PYGZus{}rates}\PYG{p}{)}
\PYG{n}{t}\PYG{o}{.}\PYG{n}{apply\PYGZus{}speciation}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

The {\hyperref[\detokenize{pycoalescence:pycoalescence.coalescence_tree.CoalescenceTree}]{\sphinxcrossref{\sphinxcode{CoalescenceTree class}}}} object can also be set up from a
{\hyperref[\detokenize{pycoalescence:pycoalescence.simulation.Simulation}]{\sphinxcrossref{\sphinxcode{Simulation class}}}} object as:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{pycoalescence} \PYG{k+kn}{import} \PYG{n}{Simulation}\PYG{p}{,} \PYG{n}{CoalescenceTree}
\PYG{n}{sim} \PYG{o}{=} \PYG{n}{Simulation}\PYG{p}{(}\PYG{p}{)}
\PYG{c+c1}{\PYGZsh{} ... set up simulation here, then run}
\PYG{c+c1}{\PYGZsh{} Now import our completed simulation without needing to run t.set\PYGZus{}database(\PYGZdq{}filepath\PYGZdq{})}
\PYG{n}{t} \PYG{o}{=} \PYG{n}{CoalescenceTree}\PYG{p}{(}\PYG{n}{sim}\PYG{p}{)}
\end{sphinxVerbatim}

A few biodiversity metrics can then be obtained directly from the database using built-in functions, relieving the user
of having to generate these manually. These include
\begin{itemize}
\item {} 
species richness, using {\hyperref[\detokenize{pycoalescence:pycoalescence.coalescence_tree.CoalescenceTree.get_richness}]{\sphinxcrossref{\sphinxcode{get\_richness()}}}}

\item {} 
species abundances, using {\hyperref[\detokenize{pycoalescence:pycoalescence.coalescence_tree.CoalescenceTree.get_species_abundances}]{\sphinxcrossref{\sphinxcode{get\_species\_abundances()}}}}

\item {} 
species octave (2\textasciicircum{}n) classes for generating species abundance distributions,
using {\hyperref[\detokenize{pycoalescence:pycoalescence.coalescence_tree.CoalescenceTree.get_octaves}]{\sphinxcrossref{\sphinxcode{get\_octaves()}}}}

\end{itemize}

\begin{sphinxadmonition}{note}{Note:}
The above functions require supplying a speciation rate and time, otherwise will output data for all
speciation rates and times.
\end{sphinxadmonition}

\begin{sphinxadmonition}{tip}{Tip:}
Equivalent functions also exist for obtaining individual fragment biodiversity metrics.
\end{sphinxadmonition}

\begin{sphinxadmonition}{tip}{Tip:}
The entire list of species can be outputted using
{\hyperref[\detokenize{pycoalescence:pycoalescence.coalescence_tree.CoalescenceTree.get_species_list}]{\sphinxcrossref{\sphinxcode{get\_species\_list}}}}. This may be useful for scenarios
where it is desirable to calculate custom biodiversity metrics.
\end{sphinxadmonition}


\subsection{Extended analysis}
\label{\detokenize{README_pycoalescence:extended-analysis}}
The \sphinxcode{coal\_analyse} module can be used for more extensive simulation analysis, such
as comparing simulated landscapes to real data and calculating goodness of fits.

The general procedure for using this module involves a few functions, all contained in the
{\hyperref[\detokenize{pycoalescence:pycoalescence.coalescence_tree.CoalescenceTree}]{\sphinxcrossref{\sphinxcode{CoalescenceTree class}}}}.
\begin{itemize}
\item {} 
{\hyperref[\detokenize{pycoalescence:pycoalescence.coalescence_tree.CoalescenceTree.set_database}]{\sphinxcrossref{\sphinxcode{set\_database()}}}} generates the link to the SQL database, which
should be an output from a \sphinxstylestrong{necsim} simulation (probably run using the
{\hyperref[\detokenize{pycoalescence:pycoalescence.simulation.Simulation}]{\sphinxcrossref{\sphinxcode{Simulation class}}}}.

\item {} 
\sphinxcode{import\_comparison\_data()} reads an SQL database which
contains real data to compare to the simulation output. The comparison data should contain the following tables:
\begin{itemize}
\item {} 
BIODIVERSITY\_ METRICS, containing \sphinxstyleemphasis{only} \sphinxquotedblleft{}metric\sphinxquotedblright{}, \sphinxquotedblleft{}fragment\sphinxquotedblright{}, \sphinxquotedblleft{}value\sphinxquotedblright{} and \sphinxquotedblleft{}number\_of\_individuals\sphinxquotedblright{} columns.
The metric can be \sphinxquotedblleft{}fragment\_richness\sphinxquotedblright{} or any other metric created by your own functions which exists also in
the simulated data.

\item {} 
SPECIES\_ABUNDANCES containing \sphinxstyleemphasis{at least} \sphinxquotedblleft{}SpeciesID\sphinxquotedblright{}, \sphinxquotedblleft{}Abund\sphinxquotedblright{}.

\end{itemize}

\end{itemize}

Additionally, one can provide the following if comparisons between fragments are required:
\begin{itemize}
\item {} 
FRAGMENT\_ABUNDANCES containing \sphinxstyleemphasis{at least} \sphinxquotedblleft{}Plot\sphinxquotedblright{}, \sphinxquotedblleft{}Mnemonic\sphinxquotedblright{} and \sphinxquotedblleft{}Abund\sphinxquotedblright{}.

\item {} 
FRAGMENT\_OCTAVES containing \sphinxstyleemphasis{at least} \sphinxquotedblleft{}fragment\sphinxquotedblright{}, \sphinxquotedblleft{}octave\sphinxquotedblright{}, \sphinxquotedblleft{}num\_species\sphinxquotedblright{}. This can also be calculated from
FRAGMENT\_ABUNDANCES using {\hyperref[\detokenize{pycoalescence:pycoalescence.coalescence_tree.CoalescenceTree.calculate_comparison_octaves}]{\sphinxcrossref{\sphinxcode{calculate\_comparison\_octaves()}}}}

\end{itemize}


\subsection{Testing install}
\label{\detokenize{README_pycoalescence:testing-install}}
The system install can be tested by running \sphinxcode{test\_install.py} from the command line
(\sphinxcode{python test\_install.py}) which requires that \sphinxcode{python setup.py} has been successfully run previously.


\section{Prerequisites}
\label{\detokenize{README_pycoalescence:prerequisites}}

\subsection{Essential}
\label{\detokenize{README_pycoalescence:essential}}\begin{itemize}
\item {} 
Python version 2 \textgreater{}= 2.7.9 or 3 \textgreater{}= 3.4.1

\item {} 
C++ compiler (such as GNU g++) with C++11 support.

\item {} 
The SQLite library available \sphinxhref{https://www.sqlite.org/download.html}{here}. Require both \sphinxcode{c++} and \sphinxcode{python} installations.

\item {} 
The Boost library for C++ available \sphinxhref{http://www.boost.org}{here}.

\item {} 
Numerical python (\sphinxcode{numpy}) package.

\end{itemize}

\begin{sphinxadmonition}{tip}{Tip:}
Most packages, including their c++ libraries, can be installed using \sphinxtitleref{pip install package\_name} on most UNIX
systems.
\end{sphinxadmonition}


\subsection{Recommended}
\label{\detokenize{README_pycoalescence:recommended}}\begin{itemize}
\item {} 
The gdal library for both python and C++ (\sphinxhref{http://www.gdal.org/}{available here}). This is \sphinxstylestrong{ESSENTIAL} if you wish
to use .tif files for {\hyperref[\detokenize{api/api_library:introduction-necsim}]{\sphinxcrossref{\DUrole{std,std-ref}{necsim}}}}.  It allows reading parameter information from .tif files
(using {\hyperref[\detokenize{pycoalescence:pycoalescence.simulation.Simulation.detect_map_dimensions}]{\sphinxcrossref{\sphinxcode{detect\_map\_dimensions()}}}}). Both the python
package and \sphinxcode{c++} binaries are required; installation differs between systems, so view the gdal documentation for more
help installing gdal properly.

\item {} 
The fast-cpp-csv-parser by Ben Strasser, available
\sphinxhref{https://github.com/ben-strasser/fast-cpp-csv-parser}{here}. This provides much faster csv read and write capabilities
and is probably essential for larger-scale simulations, but not necessary if your simulations are small. The folder
\sphinxstyleemphasis{fast-cpp-csv-parser/} should be in the same directory as your \sphinxstylestrong{necsim} C++ header files (the lib/necsim directory).

\end{itemize}

\begin{sphinxadmonition}{note}{Note:}
Running \sphinxcode{configure} (or \sphinxcode{python setup.py}) will detect system components, including \sphinxcode{sqlite3}, \sphinxcode{boost},
\sphinxcode{gdal} and \sphinxcode{fast-cpp-csv-parser} and set the correct compilation flags.
\end{sphinxadmonition}


\section{Glossary}
\label{\detokenize{README_pycoalescence:glossary}}\begin{description}
\item[{grid\index{grid|textbf}}] \leavevmode\phantomsection\label{\detokenize{README_pycoalescence:term-grid}}
Used to refer to the simulation area that is stored in memory as a matrix, for quick referencing. If no RAM
optimisations have been performed, this will be the same as the sample map. If also no sample map is used, this
will be the same as the fine map.

\item[{sample map\index{sample map|textbf}}] \leavevmode\phantomsection\label{\detokenize{README_pycoalescence:term-sample-map}}
The map file containing the points to be sampled from. This is the most zoomed in level of the simulation, and
should encompass all starting locations of lineages.

\item[{fine map\index{fine map|textbf}}] \leavevmode\phantomsection\label{\detokenize{README_pycoalescence:term-fine-map}}
The map file at a higher resolution (the same as the sample grid) which covers the area lineages are most likely
to move to, or where a higher spatial resolution is considered important.

\item[{coarse map\index{coarse map|textbf}}] \leavevmode\phantomsection\label{\detokenize{README_pycoalescence:term-coarse-map}}
The map file at a lower resolution (specified by the scale) which covers a larger area than the fine map. This is
to allow lineages to move far from their starting positions if required.

\item[{pristine map\index{pristine map|textbf}}] \leavevmode\phantomsection\label{\detokenize{README_pycoalescence:term-pristine-map}}
A historic map containing population densities at those times. Both fine and coarse pristine maps can be declared
and multiple sets of pristine maps can be declared at unique times.

\end{description}


\section{Version}
\label{\detokenize{README_pycoalescence:version}}
Version 1.2.5


\section{Contacts}
\label{\detokenize{README_pycoalescence:contacts}}
Author: Samuel Thompson

Contact: \sphinxhref{mailto:samuelthompson14@imperial.ac.uk}{samuelthompson14@imperial.ac.uk} - \sphinxhref{mailto:thompsonsed@gmail.com}{thompsonsed@gmail.com}

Institution: Imperial College London and National University of
Singapore

This project is released under BSD-3 See file
\sphinxstylestrong{LICENSE.txt} or go to
\sphinxhref{https://opensource.org/licenses/BSD-3-Clause}{here} for full license
details.


\chapter{necim}
\label{\detokenize{api/api_library:necim}}\label{\detokenize{api/api_library::doc}}
\sphinxstylestrong{A Neutral Ecology Coalescence Simulator}


\section{Introduction}
\label{\detokenize{api/api_library:introduction}}\label{\detokenize{api/api_library:introduction-necsim}}
Provided here is a set of tools for running and analysing backwards-time (coalescent) neutral models in ecology. necsim
is a generic spatial coalescence simulator for neutral systems.
It applies the model to maps for the supplied parameters and outputs information for each
individual to a SQL database.

Functionality is also provided for applying varying speciation rates to
outputs of \sphinxcode{necsim} for analysis after simulations are complete. This
enables the main simulation to be run with the \sphinxstyleemphasis{minimum} speciation rate
required and afterwards analysis can be completed using different
speciation rates. The same functionality is also provided within \sphinxcode{necsim} for application of speciation rates immediately
after simulations are complete.

\begin{sphinxadmonition}{important}{Important:}
The recommended method of installing the program and running simulations is to use the
{\hyperref[\detokenize{README_pycoalescence:introduction-pycoalescence}]{\sphinxcrossref{\DUrole{std,std-ref}{pycoalescence module}}}}.
\end{sphinxadmonition}


\subsection{A Note on the Neutral Theory of Ecology}
\label{\detokenize{api/api_library:a-note-on-the-neutral-theory-of-ecology}}
Neutral theory in ecology refers to the idea that individuals can be modelled as ecologically identical entities,
undergoing dispersal, drift and speciation without niche effects or other competitive elements.

Whilst obviously not realistic, the patterns produced by such models can often give a surprisingly accurate portrayal of
real-world systems. For more information on the topic, please see \phantomsection\label{\detokenize{api/api_library:id1}}{\hyperref[\detokenize{api/api_library:hubbell2001}]{\sphinxcrossref{{[}Hubbell2001{]}}}}.


\section{Instructions}
\label{\detokenize{api/api_library:instructions}}

\subsection{Compiling the program}
\label{\detokenize{api/api_library:compiling-the-program}}
For compilation, there are several provided options:
\begin{itemize}
\item {} 
Compilation can be handled within pycoalescence by running \sphinxcode{python setup.py}. \sphinxstylestrong{This is the recommended option.}

\item {} 
Alternatively, compilation can be completed with additional options using make. The steps are outlined below
\begin{itemize}
\item {} 
You might need to first run \sphinxcode{autoconf} from within the \sphinxcode{necsim} directory to generate the configure executable.

\item {} 
Run \sphinxcode{./configure} (located within the \sphinxcode{necsim} directory). Provide additional compilation flags if necessary (detailed below).

\item {} 
Run \sphinxcode{make all} to create the executable.

\item {} 
{[}Optional{]} Move the executable (called necsim) to the \sphinxstyleemphasis{build/Default} directory in \sphinxstylestrong{pycoalescence}.

\end{itemize}

\item {} 
If you require compilation outside of the pycoalescence module, make use of the the file \sphinxstylestrong{Makefile} located in
\sphinxstylestrong{Makefiles/SimpleCompile}. This can be modified and run using \sphinxcode{make} to generate the executable.

\end{itemize}

\begin{sphinxadmonition}{note}{Note:}
If you want to also compile the module for integrating with python, provide the python library (PYTHON\_LIB) and
python include directories (PYTHON\_INCLUDE) as command line flags to \sphinxcode{./configure}. You must then run This is
not recommended, and it is advised you use the {\hyperref[\detokenize{README_pycoalescence:introduction-pycoalescence}]{\sphinxcrossref{\DUrole{std,std-ref}{install proceedure outlined here}}}}.
\end{sphinxadmonition}

\begin{sphinxadmonition}{warning}{Warning:}
Compilation on High-performance clusters will likely require an icc compiler and custom linking to the
required libraries.
\end{sphinxadmonition}

See the Requirements section for a full list of the necessary
prerequisites.


\subsubsection{Requirements}
\label{\detokenize{api/api_library:requirements}}\begin{itemize}
\item {} 
The SQLite library available \sphinxhref{https://www.sqlite.org/download.html}{here}.

\item {} 
The Boost library available \sphinxhref{http://www.boost.org}{here}.

\item {} 
C++ compiler (such as GNU g++) with C++11 support.

\item {} 
Access to the relevant folders for Default simulations (see FAQS).

\end{itemize}

Recommended, but not essential:
\begin{itemize}
\item {} 
gdal library available \sphinxhref{http://www.gdal.org}{here}: provides reading of tif files.

\item {} \begin{description}
\item[{The fast-cpp-csv-parser by Ben Strasser, available}] \leavevmode
\sphinxhref{https://github.com/ben-strasser/fast-cpp-csv-parser}{here}: provides much faster csv read and write capabilities.

\end{description}

\end{itemize}


\subsubsection{Compiler Options}
\label{\detokenize{api/api_library:compiler-options}}
Recognised compiler options include:

\noindent\begin{tabulary}{\linewidth}{|L|L|}
\hline
\sphinxstylethead{\relax 
Option
\unskip}\relax &\sphinxstylethead{\relax 
Description
\unskip}\relax \\
\hline
--with-debug
&
Adds additional debugging information to a log file in /logs
\\
\hline
--with-gdal=DIR
&
Define a gdal library at DIR
\\
\hline
--with-hpc
&
Compile ready for HPC, using intel's icpc compilation and a variety of optimisation flags.
\\
\hline
--with-boost=DIR
&
Define a boost library at DIR
\\
\hline\end{tabulary}


Additional c++ compilation flags can be specified by \sphinxcode{CPPFLAGS=opts} for additional library paths or compilation options as required.

Note that gdal and fast-cpp-csv-parser availability will be automatically detected and included in the compilation if possible.


\subsection{Running simulations}
\label{\detokenize{api/api_library:running-simulations}}
As of version 3.1 and above, the routine relies on
supplying command line arguments (see below) for all the major
simulation variables. Alternatively, supplying a config .txt file and
using the command line arguments \sphinxcode{./necsim -c /path/to/config.txt}
can be used for parsing command line arguments from the text file.


\subsubsection{Command Line Arguments}
\label{\detokenize{api/api_library:command-line-arguments}}
\DUrole{versionmodified}{Deprecated since version This: }method of supplying simulation parameters is not recommended and is provided for backwards-compatibility only.
Support will be dropped completely in a future release.

The following command line arguments are required. This list can be
accessed by running \sphinxcode{./necsim -h} or \sphinxcode{./necsim -help}

As of version 3.6 and above, the command line options to be specified are:
\begin{enumerate}
\item {} 
the seed for the simulation.

\item {} 
the simulation task (for file reference).

\item {} 
the map config file.

\item {} 
the output directory.

\item {} 
the minimum speciation rate.

\item {} 
the dispersal z\_fat value.

\item {} 
the dispersal L value.

\item {} 
the deme size.

\item {} 
the deme sample size.

\item {} 
the maximum simulation time (in seconds).

\item {} 
the lambda value for moving through non-habitat.

\item {} 
the temporal sampling file containing generation
values for sampling points in time (null for only sampling the
present)

\item {} 
the minimum number of species known to exist. (Currently has no
effect).

\item {} 
(and onwards) speciation rates to apply after simulation.

\end{enumerate}

In this format, the map config file and temporal sampling file are as described in {\hyperref[\detokenize{api/api_library:config-files}]{\sphinxcrossref{Config Files}}}.

Alternatively, by specifying the -f flag, (full mode) as the first
argument, the program can read in pre-3.6 command line arguments, which
are as followed.
\begin{enumerate}
\item {} 
the task\_iter used for setting the seed.

\item {} 
the sample grid x dimension

\item {} 
the sample grid y dimension

\item {} 
the fine map file relative path.

\item {} 
the fine map x dimension

\item {} 
the fine map y dimension

\item {} 
the fine map x offset

\item {} 
the fine map y offset

\item {} 
the coarse map file relative path.

\item {} 
the coarse map x dimension

\item {} 
the coarse map y dimension

\item {} 
the coarse map x offset

\item {} 
the coarse map y offset

\item {} 
the scale of the coarse map compared to the fine (10 means
resolution of coarse map = 10 x resolution of fine map)

\item {} 
the output directory

\item {} 
the speciation rate.

\item {} 
the dispersal sigma value.

\item {} 
the deme size

\item {} 
the deme sample size (as a proportion of deme size)

\item {} 
the time to run the simulation (in seconds).

\item {} 
lambda - the relative cost of moving through non-forest

\item {} 
the\_task - for referencing the specific task later on.

\item {} 
the minimum number of species the system is known to contain.

\item {} 
the pristine fine map file to use

\item {} 
the pristine coarse map file to use

\item {} 
the rate of forest change from pristine

\item {} 
the time (in generations) since the pristine forest was seen.

\item {} 
the dispersal tau value (the width of the fat-tailed kernel).

\item {} 
the sample mask, with binary 1:0 values for areas that we want to
sample from. If this is not provided then this will default to
mapping the whole area.

\item {} 
the link to the file containing every generation that the list
should be expanded. This should be in the format of a list.

\item {} 
(and onwards) - speciation rates to apply after the simulation is
complete.

\end{enumerate}

\begin{sphinxadmonition}{warning}{Warning:}
This method of running simulations is provided for legacy purposes only, and is no longer recommended. For
increase functionality, use the condensed command-line format, or switch to using config files.
\end{sphinxadmonition}


\subsubsection{Config Files}
\label{\detokenize{api/api_library:config-files}}
There are two separate config files which are used when setting up simulations.
\begin{itemize}
\item {} \begin{description}
\item[{{\hyperref[\detokenize{api/api_library:main-simulation-config-file}]{\sphinxcrossref{main simulation config file}}}}] \leavevmode
Contains the main simulation parameters, including dispersal parameters, speciation rates, sampling information and
file referencing information. It also includes the paths to the other config files, which must be specified if the
main simulation config is used.
Contains the map parameters, including paths to the relevant map files, map dimensions, offsets and scaling. This
option cannot be null (map dimensions at least must be specified).

\end{description}

\item {} \begin{description}
\item[{{\hyperref[\detokenize{api/api_library:time-config-file}]{\sphinxcrossref{time config file}}}}] \leavevmode
Contains the temporal sampling points, in generations. If this is `null', sampling will automatically occur only
at the present (generation time=0)

\end{description}

\end{itemize}

When running the simulation using config files, the path to the {\hyperref[\detokenize{api/api_library:main-simulation-config-file}]{\sphinxcrossref{main simulation config file}}} should be specified, e.g
\sphinxcode{./necsim -c /path/to/main/config.txt}.


\paragraph{Main Config File}
\label{\detokenize{api/api_library:main-simulation-config-file}}\label{\detokenize{api/api_library:main-config-file}}
The configuration containing the majority of the simulation set up, outside of map dimensions. An example file is shown
below. This file can be automatically generated by \sphinxcode{create\_config()}
in pycoalescence. An example of this configuration is given below:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{[}\PYG{n}{main}\PYG{p}{]}
\PYG{n}{seed} \PYG{o}{=} \PYG{l+m+mi}{6}
\PYG{n}{job\PYGZus{}type} \PYG{o}{=} \PYG{l+m+mi}{6}
\PYG{n}{map\PYGZus{}config} \PYG{o}{=} \PYG{n}{output}\PYG{o}{/}\PYG{n}{mapconf}\PYG{o}{.}\PYG{n}{txt}
\PYG{n}{output\PYGZus{}directory} \PYG{o}{=} \PYG{n}{output}
\PYG{n}{min\PYGZus{}spec\PYGZus{}rate} \PYG{o}{=} \PYG{l+m+mf}{0.5}
\PYG{n}{sigma} \PYG{o}{=} \PYG{l+m+mi}{4}
\PYG{n}{tau} \PYG{o}{=} \PYG{l+m+mi}{4}
\PYG{n}{deme} \PYG{o}{=} \PYG{l+m+mi}{1}
\PYG{n}{sample\PYGZus{}size} \PYG{o}{=} \PYG{l+m+mf}{0.1}
\PYG{n}{max\PYGZus{}time} \PYG{o}{=} \PYG{l+m+mi}{1}
\PYG{k}{lambda} \PYG{o}{=} \PYG{l+m+mi}{1}
\PYG{n}{time\PYGZus{}config} \PYG{o}{=} \PYG{n}{output}\PYG{o}{/}\PYG{n}{tempconf}\PYG{o}{.}\PYG{n}{txt}
\PYG{n}{min\PYGZus{}species} \PYG{o}{=} \PYG{l+m+mi}{1}

\PYG{p}{[}\PYG{n}{spec\PYGZus{}rates}\PYG{p}{]}
\PYG{n}{spec\PYGZus{}rate1}  \PYG{o}{=} \PYG{l+m+mf}{0.6}
\PYG{n}{spec\PYGZus{}rate2}  \PYG{o}{=} \PYG{l+m+mf}{0.8}
\end{sphinxVerbatim}


\paragraph{Map Config Options}
\label{\detokenize{api/api_library:map-config-file}}\label{\detokenize{api/api_library:map-config-options}}
The map options contain the information for setting up all maps required by the simulation. This involves maps at all
times and at all scales. An example is given below.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{[}\PYG{n}{sample\PYGZus{}grid}\PYG{p}{]}
\PYG{n}{path} \PYG{o}{=} \PYG{n}{null}
\PYG{n}{x} \PYG{o}{=} \PYG{l+m+mi}{13}
\PYG{n}{y} \PYG{o}{=} \PYG{l+m+mi}{13}
\PYG{n}{mask} \PYG{o}{=} \PYG{n}{null}

\PYG{p}{[}\PYG{n}{fine\PYGZus{}map}\PYG{p}{]}
\PYG{n}{path} \PYG{o}{=} \PYG{n}{sample}\PYG{o}{/}\PYG{n}{SA\PYGZus{}sample\PYGZus{}fine}\PYG{o}{.}\PYG{n}{tif}
\PYG{n}{x} \PYG{o}{=} \PYG{l+m+mi}{13}
\PYG{n}{y} \PYG{o}{=} \PYG{l+m+mi}{13}
\PYG{n}{x\PYGZus{}off} \PYG{o}{=} \PYG{l+m+mi}{0}
\PYG{n}{y\PYGZus{}off} \PYG{o}{=} \PYG{l+m+mi}{0}

\PYG{p}{[}\PYG{n}{coarse\PYGZus{}map}\PYG{p}{]}
\PYG{n}{path} \PYG{o}{=} \PYG{n}{sample}\PYG{o}{/}\PYG{n}{SA\PYGZus{}sample\PYGZus{}coarse}\PYG{o}{.}\PYG{n}{tif}
\PYG{n}{x} \PYG{o}{=} \PYG{l+m+mi}{35}
\PYG{n}{y} \PYG{o}{=} \PYG{l+m+mi}{41}
\PYG{n}{x\PYGZus{}off} \PYG{o}{=} \PYG{l+m+mi}{11}
\PYG{n}{y\PYGZus{}off} \PYG{o}{=} \PYG{l+m+mi}{14}
\PYG{n}{scale} \PYG{o}{=} \PYG{l+m+mf}{1.0}

\PYG{p}{[}\PYG{n}{pristine\PYGZus{}fine0}\PYG{p}{]}
\PYG{n}{path} \PYG{o}{=} \PYG{n}{sample}\PYG{o}{/}\PYG{n}{SA\PYGZus{}sample\PYGZus{}fine\PYGZus{}pristine1}\PYG{o}{.}\PYG{n}{tif}
\PYG{n}{number} \PYG{o}{=} \PYG{l+m+mi}{0}
\PYG{n}{time} \PYG{o}{=} \PYG{l+m+mi}{1}
\PYG{n}{rate} \PYG{o}{=} \PYG{l+m+mf}{0.5}

\PYG{p}{[}\PYG{n}{pristine\PYGZus{}coarse0}\PYG{p}{]}
\PYG{n}{path} \PYG{o}{=} \PYG{n}{sample}\PYG{o}{/}\PYG{n}{SA\PYGZus{}sample\PYGZus{}coarse\PYGZus{}pristine1}\PYG{o}{.}\PYG{n}{tif}
\PYG{n}{number} \PYG{o}{=} \PYG{l+m+mi}{0}
\PYG{n}{time} \PYG{o}{=} \PYG{l+m+mi}{1}
\PYG{n}{rate} \PYG{o}{=} \PYG{l+m+mf}{0.5}

\PYG{p}{[}\PYG{n}{pristine\PYGZus{}fine1}\PYG{p}{]}
\PYG{n}{path} \PYG{o}{=} \PYG{n}{sample}\PYG{o}{/}\PYG{n}{SA\PYGZus{}sample\PYGZus{}fine\PYGZus{}pristine2}\PYG{o}{.}\PYG{n}{tif}
\PYG{n}{number} \PYG{o}{=} \PYG{l+m+mi}{1}
\PYG{n}{time} \PYG{o}{=} \PYG{l+m+mi}{4}
\PYG{n}{rate} \PYG{o}{=} \PYG{l+m+mf}{0.7}

\PYG{p}{[}\PYG{n}{pristine\PYGZus{}coarse1}\PYG{p}{]}
\PYG{n}{path} \PYG{o}{=} \PYG{n}{sample}\PYG{o}{/}\PYG{n}{SA\PYGZus{}sample\PYGZus{}coarse\PYGZus{}pristine2}\PYG{o}{.}\PYG{n}{tif}
\PYG{n}{number} \PYG{o}{=} \PYG{l+m+mi}{1}
\PYG{n}{time} \PYG{o}{=} \PYG{l+m+mi}{4}
\PYG{n}{rate} \PYG{o}{=} \PYG{l+m+mf}{0.7}
\end{sphinxVerbatim}

\begin{sphinxadmonition}{note}{Note:}
The rates and times between the pairs of pristine fine maps and pristine coarse maps must match up. Without matching
values here, there could be undetermined errors, or coarse map values being ignored.
\end{sphinxadmonition}

\begin{sphinxadmonition}{note}{Note:}
Pristine maps assume the same dimensions as their respective present-day equivalents.
\end{sphinxadmonition}

\begin{sphinxadmonition}{note}{Note:}
In older versions of this program these options were contained in a separate file. However, as of 1.2.4 map and main
simulation options are contained in the same file.
\end{sphinxadmonition}


\paragraph{Time Config File}
\label{\detokenize{api/api_library:time-config-file}}\label{\detokenize{api/api_library:id2}}
The temporal sampling config file (referred to as \sphinxquotedblleft{}time config file\sphinxquotedblright{}) specifies times, in generations, when a full
sample according to the sample map should be taken again. An example of this file is given below.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{[}\PYG{n}{main}\PYG{p}{]}
\PYG{n}{time0} \PYG{o}{=} \PYG{l+m+mf}{0.0}
\PYG{n}{time1} \PYG{o}{=} \PYG{l+m+mf}{1.0}
\end{sphinxVerbatim}

\begin{sphinxadmonition}{note}{Note:}
For each speciation rate, all biodiversity measures (such as species' abundances and species' richness) will be
calculated for each time supplied separately.
\end{sphinxadmonition}


\subsubsection{Default parameters}
\label{\detokenize{api/api_library:default-parameters}}
To run the program with the default parameters for testing purposes, run
with the command line arguments -d or -dl (for the larger default run).
Note that this will require access to the following folders relative to
the path of the program for storing the outputs to the default runs:

\sphinxstylestrong{./Default}

\sphinxstylestrong{./Default/SQL\_data/}


\section{Outputs}
\label{\detokenize{api/api_library:outputs}}
Upon successful completion of a simulation, the two files are created.
\begin{itemize}
\item {} 
A csv file is created called \sphinxstyleemphasis{Data\_\{the\_task\}\_\{the\_seed\}.csv} where the\_seed and the\_task are the values provided
in simulation set-up. This contains basic simulation information for quick reference.

\item {} 
an SQLite database file in the output directory in a folder called \sphinxstyleemphasis{SQL\_data}.
This database contains all important simulation data over several tables, which can be accessed
using a program like \sphinxhref{http://sqlitebrowser.org/}{DB Browser for SQLite} or Microsoft Access.
Alternatively, most programming languages have an SQLite interface
(\sphinxhref{https://cran.r-project.org/web/packages/RSQLite/index.html}{RSQlite},
\sphinxhref{https://docs.python.org/2/library/sqlite3.html}{python sqlite3})

\end{itemize}

The tables in the SQLite database are
- SIMULATION\_PARAMETERS
\begin{quote}

contains the parameters the simulation was performed with for referencing later.
\end{quote}
\begin{itemize}
\item {} 
SPECIES\_LIST
\begin{quote}

contains the locations of every coalescence event. This is used by SpeciationCounter to reconstruct the coalescence
tree for application of speciation rates after simulations are complete.
\end{quote}

\item {} 
SPECIES\_ABUNDANCES
\begin{quote}

contains the species abundance distributions for each speciation rate and time point that has been specified.
\end{quote}

\item {} 
SPECIES\_LOCATIONS {[}optional{]}
\begin{quote}

contains the x, y coordinates of every individual at each time point and for every specified speciation rate,
along with species ID numbers.
\end{quote}

\item {} 
FRAGMENT\_ABUNDANCES {[}optional{]}
\begin{quote}

contains the species abundance distributions for each habitat fragment, either specified by the fragment csv file,
or detected from squares across the map.
\end{quote}

\end{itemize}

Additional information can be found in {\hyperref[\detokenize{api/api_library:speciationcounter}]{\sphinxcrossref{SpeciationCounter}}} regarding the optional database tables.


\section{SpeciationCounter}
\label{\detokenize{api/api_library:speciationcounter}}\label{\detokenize{api/api_library:introduction-speciationcounter}}
SpeciationCounter provides a method for applying additional speciation rates to outputs from necsim, without having to
re-run the entire simulation. SpeciationCounter works by reconstructing the coalescence tree, checking at each point if
an additional speciation rate has occured. As such, SpeciationCounter can only apply speciation rates higher than the
initial speciation rate the program was run with.


\subsection{Applying Speciation Rates}
\label{\detokenize{api/api_library:applying-speciation-rates}}
Run \sphinxcode{./SpeciationCounter} with the following command-line options:
\begin{enumerate}
\item {} 
path to the SQLite database file (this is the output of a \sphinxcode{necsim} simulation).

\item {} 
T/F for recording spatial data. If true, the SPECIES\_LOCATIONS table will be created (see {\hyperref[\detokenize{api/api_library:outputs}]{\sphinxcrossref{Outputs}}}.)

\item {} 
a sample mask to use for the data. Species' identities for the individuals will only be calculated from locations
specified by a 1 in the sample mask (0 otherwise). Use \sphinxquotedblleft{}null\sphinxquotedblright{} to record all locations.

\item {} 
a {\hyperref[\detokenize{api/api_library:time-config-file}]{\sphinxcrossref{time config file}}} specifying temporal sampling locations.

\item {} 
T/F for calculating fragment species abundances individually. If true, the FRAGMENT\_ABUNDANCES table will be created
containing the species abundances for each fragment calculated as a square of continuous habitat. Alternatively, can
specify a csv file that contains the fragment information in the following format. All x, y coordinates are given on
the sample grid size specified at simulation run-time.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{fragment\PYGZus{}name1}\PYG{p}{,} \PYG{n}{x\PYGZus{}min}\PYG{p}{,} \PYG{n}{y\PYGZus{}min}\PYG{p}{,} \PYG{n}{x\PYGZus{}max}\PYG{p}{,} \PYG{n}{y\PYGZus{}max}\PYG{p}{,} \PYG{n}{number\PYGZus{}of\PYGZus{}individuals}
\PYG{n}{fragment\PYGZus{}name2}\PYG{p}{,} \PYG{n}{x\PYGZus{}min}\PYG{p}{,} \PYG{n}{y\PYGZus{}min}\PYG{p}{,} \PYG{n}{x\PYGZus{}max}\PYG{p}{,} \PYG{n}{y\PYGZus{}max}\PYG{p}{,} \PYG{n}{number\PYGZus{}of\PYGZus{}individuals}
\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}
\end{sphinxVerbatim}

\item {} 
A speciation rate to apply. Can list multiple speciation rates by supplying arguments 7 onwards.

\end{enumerate}


\section{Debugging}
\label{\detokenize{api/api_library:debugging}}
Most errors will return an error code in the form ERROR\_NAME\_XXX:
Description a list of which can be found in ERROR\_REF.txt.


\section{Brief Class Descriptions}
\label{\detokenize{api/api_library:brief-class-descriptions}}
A brief description of the important classes is given below. Some
classes also contain customised exceptions for better tracing of error
handling.
\begin{itemize}
\item {} 
The {\hyperref[\detokenize{api/class_Tree:_CPPv24Tree}]{\sphinxcrossref{\sphinxcode{Tree}}}} class
\begin{itemize}
\item {} 
The most important class!

\item {} 
Contains the main setup, run and data output routines.

\item {} 
{\hyperref[\detokenize{api/class_Tree:_CPPv2N4Tree5setupEv}]{\sphinxcrossref{\sphinxcode{setup()}}}} imports the data files from csv (if necessary) and creates
the in-memory objects for the storing of the coalescence tree and
the spatial grid of active lineages. Setup time mostly depends on
the size of the csv file being imported.

\item {} 
Run continually loops over sucessive coalesence, move or
speciation events until all individuals have speciated or
coalesced. This is where the majority of the simulation time will
be, and is mostly dependent on the number of individuals,
speciation rate and size of the spatial grid.

\item {} 
At the end of the simulation, the sqlCreate() routine will
generate the in-memory SQLite database for storing the coalescent
tree. It can run multiple times if multiple speciation rates are
required. {\hyperref[\detokenize{api/class_Tree:_CPPv2N4Tree10outputDataEv}]{\sphinxcrossref{\sphinxcode{outputData()}}}} will then be called to create a small csv
file containing important information, and output the SQLite
database to file if required.

\end{itemize}

\item {} 
The {\hyperref[\detokenize{api/class_TreeNode:_CPPv28TreeNode}]{\sphinxcrossref{\sphinxcode{TreeNode}}}} class
\begin{itemize}
\item {} 
Contains a single record of a node on the phylogenetic tree, to be
used in reassembling the tree structure at the end of the
simulation.

\end{itemize}

\item {} 
The {\hyperref[\detokenize{api/class_DataPoint:_CPPv29DataPoint}]{\sphinxcrossref{\sphinxcode{DataPoint}}}} class
\begin{itemize}
\item {} 
Contains a single record of the location of a lineage.

\end{itemize}

\item {} 
The {\hyperref[\detokenize{api/class_NRrand:_CPPv26NRrand}]{\sphinxcrossref{\sphinxcode{NRrand}}}} class
\begin{itemize}
\item {} 
Contains the random number generator, as written by James
Rosindell (\sphinxhref{mailto:j.rosindell@imperial.ac.uk}{j.rosindell@imperial.ac.uk}).

\end{itemize}

\item {} 
The {\hyperref[\detokenize{api/class_Map:_CPPv23Map}]{\sphinxcrossref{\sphinxcode{Map}}}} class
\begin{itemize}
\item {} 
Contains the routines for importing and calling values from the
map objects.

\item {} 
The {\hyperref[\detokenize{api/class_Map:_CPPv2N3Map6getValERKdRKdRKlRKlRKd}]{\sphinxcrossref{\sphinxcode{getVal()}}}} and {\hyperref[\detokenize{api/class_Map:_CPPv2N3Map12runDispersalERKdRKdRlRlRlRlRbRKd}]{\sphinxcrossref{\sphinxcode{runDispersal()}}}} functions can be modified
to produce altered dispersal behaviour, or alterations to the
structure of the {\hyperref[\detokenize{api/class_Row:_CPPv23Row}]{\sphinxcrossref{\sphinxcode{Row}}}}

\end{itemize}

\item {} 
The {\hyperref[\detokenize{api/class_Matrix:_CPPv26Matrix}]{\sphinxcrossref{\sphinxcode{Matrix}}}} and {\hyperref[\detokenize{api/class_Row:_CPPv23Row}]{\sphinxcrossref{\sphinxcode{Row}}}} classes
\begin{itemize}
\item {} 
Based on code written by James Rosindell
(\sphinxhref{mailto:j.rosindell@imperial.ac.uk}{j.rosindell@imperial.ac.uk}).

\item {} 
Handles indexing of the 2D object plus importing values from a csv
file.

\end{itemize}

\item {} 
The {\hyperref[\detokenize{api/class_SpeciesList:_CPPv211SpeciesList}]{\sphinxcrossref{\sphinxcode{SpeciesList}}}} class
\begin{itemize}
\item {} 
Contains the list of individuals, for application in a matrix, to
essentially create a 3D array.

\item {} 
Handles the positioning of individuals in space within a grid
cell.

\end{itemize}

\item {} 
The {\hyperref[\detokenize{api/class_ConfigOption:_CPPv212ConfigOption}]{\sphinxcrossref{\sphinxcode{ConfigOption}}}} class
\begin{itemize}
\item {} 
Contains basic functions for importing command line arguments from
a config file, providing an alternative way of setting up
simulations.

\end{itemize}

\item {} 
The \sphinxcode{TreeList} class
\begin{itemize}
\item {} 
Provides the routines for applying different speciation rates to a
phylogenetic tree, to be used either immediately after simulation
within \sphinxcode{necsim}, or at a later time using {\hyperref[\detokenize{api/api_library:speciationcounter}]{\sphinxcrossref{SpeciationCounter}}}

\end{itemize}

\end{itemize}


\section{Known Bugs}
\label{\detokenize{api/api_library:known-bugs}}\begin{itemize}
\item {} 
Simulations run until completion, rather than aiming for a desired
number of species. This is an intentional change. Functions related
to this functionality remain but are deprecated.

\item {} 
In SpeciationCounter, only continuous rectangular fragments are
properly calculated. Other shapes must be calculated by
post-processing.

\item {} 
In SpeciationCounter, 3 fragments instead of 2 will be calculated for
certain adjacent rectangular patches.

\end{itemize}


\section{FAQS (WIP)}
\label{\detokenize{api/api_library:faqs-wip}}\begin{itemize}
\item {} 
\sphinxstylestrong{Why doesnt the default simulation output anything?}
\begin{itemize}
\item {} 
Check that the program has access to the folders relative to the
program at \sphinxtitleref{Default/}

\end{itemize}

\item {} 
\sphinxstylestrong{Why cant I compile the program?}
\begin{itemize}
\item {} 
This could be due to a number of reasons, most likely that you
havent compiled with access to the lsqlite3 or boost packages.
Installation and compilation differs across different systems; for
most UNIX systems, compiling with the linker arguments -lsqlite3
-lboost\_filesystem and -lboost\_system will solve problems with
the compiler not finding the sqlite or boost header file.

\item {} 
Another option could be the potential lack of access to the
fast-cpp-csv-parser by Ben Strasser, available
\sphinxhref{https://github.com/ben-strasser/fast-cpp-csv-parser}{here}. If
use\_csv has been defined at the head of the file, try without
use\_csv or download the csv parser and locate the folder within
your working directory at compilation.

\end{itemize}

\item {} 
\sphinxstylestrong{Every time the program runs I get error code XXX.}
\begin{itemize}
\item {} 
Check the ERROR\_REF.txt file for descriptions of the files. Try compiling with the \sphinxtitleref{DEBUG} precursor to gain
more information on the problem. It is most likely a problem with
the set up of the map data (error checking is not yet properly
implemented here).

\end{itemize}

\end{itemize}


\section{Version}
\label{\detokenize{api/api_library:version}}
Version 1.2.5


\section{Contacts}
\label{\detokenize{api/api_library:contacts}}
Author: \sphinxstylestrong{Samuel Thompson}

Contact: \sphinxhref{mailto:samuelthompson14@imperial.ac.uk}{samuelthompson14@imperial.ac.uk} - \sphinxhref{mailto:thompsonsed@gmail.com}{thompsonsed@gmail.com}

Institution: Imperial College London and National University of
Singapore

Based heavily on code by \sphinxstylestrong{James Rosindell}

Contact: \sphinxhref{mailto:j.rosindell@imperial.ac.uk}{j.rosindell@imperial.ac.uk}

Institution: Imperial College London


\section{Licence}
\label{\detokenize{api/api_library:licence}}
This project is released under BSD-3 See file
\sphinxstylestrong{LICENSE.txt} or go to
\sphinxhref{https://opensource.org/licenses/BSD-3-Clause}{here} for full license
details.

You are free to modify and distribute the code for any non-commercial purpose.


\section{Class Hierarchy}
\label{\detokenize{api/api_library:class-hierarchy}}

\section{File Hierarchy}
\label{\detokenize{api/api_library:file-hierarchy}}

\section{Full API}
\label{\detokenize{api/api_library:full-api}}

\subsection{Namespace std}
\label{\detokenize{api/namespace_std:namespace-std}}\label{\detokenize{api/namespace_std::doc}}\label{\detokenize{api/namespace_std:id1}}
STL namespace.


\subsection{Struct CommunityParameters}
\label{\detokenize{api/struct_CommunityParameters::doc}}\label{\detokenize{api/struct_CommunityParameters:struct-communityparameters}}\label{\detokenize{api/struct_CommunityParameters:id1}}\begin{itemize}
\item {} 
Defined in {\hyperref[\detokenize{api/file_necsim_Community.h:file-necsim-community-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File Community.h}}}}

\end{itemize}


\subsubsection{Struct Documentation}
\label{\detokenize{api/struct_CommunityParameters:struct-documentation}}\index{CommunityParameters (C++ class)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/struct_CommunityParameters:_CPPv219CommunityParameters}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/struct_CommunityParameters:necsimstruct_community_parameters}}\pysigline{\sphinxstrong{struct }\sphinxcode{}\sphinxbfcode{CommunityParameters}}%
\pysigstopmultiline
A struct for containing pairs of previous calculations to make sure that aren't repeated. 
\paragraph{Public Functions}
\index{CommunityParameters::CommunityParameters (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/struct_CommunityParameters:_CPPv2N19CommunityParameters19CommunityParametersEv}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/struct_CommunityParameters:necsimstruct_community_parameters_1a03e06c14d5b1aa3e04e075d614117868}}\pysiglinewithargsret{\sphinxbfcode{CommunityParameters}}{}{}%
\pysigstopmultiline
\end{fulllineitems}

\index{CommunityParameters::CommunityParameters (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/struct_CommunityParameters:_CPPv2N19CommunityParameters19CommunityParametersEmeebm}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/struct_CommunityParameters:necsimstruct_community_parameters_1a35ba4287722675bea972392eaecace5d}}\pysiglinewithargsret{\sphinxbfcode{CommunityParameters}}{unsigned long \sphinxstyleemphasis{reference\_in}, long double \sphinxstyleemphasis{speciation\_rate\_in}, long double \sphinxstyleemphasis{time\_in}, bool \sphinxstyleemphasis{fragment\_in}, unsigned long \sphinxstyleemphasis{metacommunity\_reference\_in}}{}%
\pysigstopmultiline
Constructor for {\hyperref[\detokenize{api/struct_CommunityParameters:necsimstruct_community_parameters}]{\sphinxcrossref{\DUrole{std,std-ref}{CommunityParameters}}}}, for storing a pairs of previous calculations, requiring a speciation rate and a time. Overloaded version with setup routines. 

\begin{description}
\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{reference\_in}: the reference to set for this {\hyperref[\detokenize{api/struct_CommunityParameters:necsimstruct_community_parameters}]{\sphinxcrossref{\DUrole{std,std-ref}{CommunityParameters}}}} set 

\item {} 
\sphinxcode{speciation\_rate\_in}: the speciation rate of the previous calculation 

\item {} 
\sphinxcode{time\_in}: the time of the previous calculation 

\item {} 
\sphinxcode{fragment\_in}: bool of whether fragments were used in the previous calculation 

\item {} 
\sphinxcode{metacommunity\_reference\_in}: the metacommunity reference, or 0 for no metacommunity 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{CommunityParameters::setup (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/struct_CommunityParameters:_CPPv2N19CommunityParameters5setupEmeebm}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/struct_CommunityParameters:necsimstruct_community_parameters_1a76bcfc1686e2719af641a6c1854665e7}}\pysiglinewithargsret{void \sphinxbfcode{setup}}{unsigned long \sphinxstyleemphasis{reference\_in}, long double \sphinxstyleemphasis{speciation\_rate\_in}, long double \sphinxstyleemphasis{time\_in}, bool \sphinxstyleemphasis{fragment\_in}, unsigned long \sphinxstyleemphasis{metacommunity\_reference\_in}}{}%
\pysigstopmultiline
Sets up the {\hyperref[\detokenize{api/struct_CommunityParameters:necsimstruct_community_parameters}]{\sphinxcrossref{\DUrole{std,std-ref}{CommunityParameters}}}} object. 

\begin{description}
\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{reference\_in}: the reference to set for this {\hyperref[\detokenize{api/struct_CommunityParameters:necsimstruct_community_parameters}]{\sphinxcrossref{\DUrole{std,std-ref}{CommunityParameters}}}} set 

\item {} 
\sphinxcode{speciation\_rate\_in}: the speciation rate of the previous calculation 

\item {} 
\sphinxcode{time\_in}: the time of the previous calculation 

\item {} 
\sphinxcode{fragment\_in}: bool of whether fragments were used in the previous calculation 

\item {} 
\sphinxcode{metacommunity\_reference\_in}: the metacommunity reference, or 0 for no metacommunity 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{CommunityParameters::compare (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/struct_CommunityParameters:_CPPv2N19CommunityParameters7compareEeebm}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/struct_CommunityParameters:necsimstruct_community_parameters_1ab7c20d61446281ce145a65342fdf9ebc}}\pysiglinewithargsret{bool \sphinxbfcode{compare}}{long double \sphinxstyleemphasis{speciation\_rate\_in}, long double \sphinxstyleemphasis{time\_in}, bool \sphinxstyleemphasis{fragment\_in}, unsigned long \sphinxstyleemphasis{metacommunity\_reference\_in}}{}%
\pysigstopmultiline
Compare these set of parameters with the input set. If they match, return true, otherwise return false. 

\begin{description}
\item[{\sphinxstylestrong{Return}}] \leavevmode


\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{speciation\_rate\_in}: speciation rate to compare with stored community parameter 

\item {} 
\sphinxcode{time\_in}: time to compare with stored community parameter 

\item {} 
\sphinxcode{fragment\_in}: if fragments are being used on this database 

\item {} 
\sphinxcode{metacommunity\_reference\_in}: metacommunity reference to compare with stored community parameter 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{CommunityParameters::compare (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/struct_CommunityParameters:_CPPv2N19CommunityParameters7compareEeem}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/struct_CommunityParameters:necsimstruct_community_parameters_1a74f0d737ac1d0249d86fede848650ae2}}\pysiglinewithargsret{bool \sphinxbfcode{compare}}{long double \sphinxstyleemphasis{speciation\_rate\_in}, long double \sphinxstyleemphasis{time\_in}, unsigned long \sphinxstyleemphasis{metacommunity\_reference\_in}}{}%
\pysigstopmultiline
Compare these set of parameters with the input set. If they match, return true, otherwise return false Overloaded version ignoring the fragments parameter. 

\begin{description}
\item[{\sphinxstylestrong{Return}}] \leavevmode


\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{speciation\_rate\_in}: speciation rate to compare with stored community parameter 

\item {} 
\sphinxcode{time\_in}: time to compare with stored community parameter 

\item {} 
\sphinxcode{metacommunity\_reference\_in}: metacommunity reference to compare with stored community parameter 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{CommunityParameters::compare (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/struct_CommunityParameters:_CPPv2N19CommunityParameters7compareEm}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/struct_CommunityParameters:necsimstruct_community_parameters_1a40a051953654d97d5d5674875d5692cc}}\pysiglinewithargsret{bool \sphinxbfcode{compare}}{unsigned long \sphinxstyleemphasis{reference\_in}}{}%
\pysigstopmultiline
Checks if the supplied reference is the same in the community parameter. 

\begin{description}
\item[{\sphinxstylestrong{Return}}] \leavevmode


\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{reference\_in}: 

\end{itemize}

\end{description}


\end{fulllineitems}

\paragraph{Public Members}
\index{CommunityParameters::reference (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/struct_CommunityParameters:_CPPv2N19CommunityParameters9referenceE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{api/struct_CommunityParameters:necsimstruct_community_parameters_1a557474bb5acbee2483cf8176aaf2c2d6}}unsigned long \sphinxbfcode{reference}}%
\pysigstopmultiline
\end{fulllineitems}

\index{CommunityParameters::speciation\_rate (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/struct_CommunityParameters:_CPPv2N19CommunityParameters15speciation_rateE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{api/struct_CommunityParameters:necsimstruct_community_parameters_1afafe9532c12b83693d04cf63d56f0133}}long double \sphinxbfcode{speciation\_rate}}%
\pysigstopmultiline
\end{fulllineitems}

\index{CommunityParameters::time (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/struct_CommunityParameters:_CPPv2N19CommunityParameters4timeE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{api/struct_CommunityParameters:necsimstruct_community_parameters_1adb03228a8993f9e2e52f3dda85a96ec8}}long double \sphinxbfcode{time}}%
\pysigstopmultiline
\end{fulllineitems}

\index{CommunityParameters::fragment (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/struct_CommunityParameters:_CPPv2N19CommunityParameters8fragmentE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{api/struct_CommunityParameters:necsimstruct_community_parameters_1a358d21a0a083749d05f0d01f08f2ca14}}bool \sphinxbfcode{fragment}}%
\pysigstopmultiline
\end{fulllineitems}

\index{CommunityParameters::metacommunity\_reference (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/struct_CommunityParameters:_CPPv2N19CommunityParameters23metacommunity_referenceE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{api/struct_CommunityParameters:necsimstruct_community_parameters_1a10584c438483add52d9d8790256f2cc0}}unsigned long \sphinxbfcode{metacommunity\_reference}}%
\pysigstopmultiline
\end{fulllineitems}

\index{CommunityParameters::updated (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/struct_CommunityParameters:_CPPv2N19CommunityParameters7updatedE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{api/struct_CommunityParameters:necsimstruct_community_parameters_1aada886c5f72515e6eca62efdcccf47b7}}bool \sphinxbfcode{updated}}%
\pysigstopmultiline
\end{fulllineitems}


\end{fulllineitems}



\subsection{Struct ConfigException}
\label{\detokenize{api/struct_ConfigException:id1}}\label{\detokenize{api/struct_ConfigException::doc}}\label{\detokenize{api/struct_ConfigException:struct-configexception}}\begin{itemize}
\item {} 
Defined in {\hyperref[\detokenize{api/file_necsim_CustomExceptions.h:file-necsim-customexceptions-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File CustomExceptions.h}}}}

\end{itemize}


\subsubsection{Inheritance Relationships}
\label{\detokenize{api/struct_ConfigException:inheritance-relationships}}

\paragraph{Base Type}
\label{\detokenize{api/struct_ConfigException:base-type}}\begin{itemize}
\item {} 
\sphinxcode{public FatalException} ({\hyperref[\detokenize{api/struct_FatalException:struct-fatalexception}]{\sphinxcrossref{\DUrole{std,std-ref}{Struct FatalException}}}})

\end{itemize}


\subsubsection{Struct Documentation}
\label{\detokenize{api/struct_ConfigException:struct-documentation}}\index{ConfigException (C++ class)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/struct_ConfigException:_CPPv215ConfigException}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/struct_ConfigException:necsimstruct_config_exception}}\pysigline{\sphinxstrong{struct }\sphinxcode{}\sphinxbfcode{ConfigException}}%
\pysigstopmultiline
A structure for all exceptions thrown within config processes. 

Inherits from {\hyperref[\detokenize{api/struct_FatalException:necsimstruct_fatal_exception}]{\sphinxcrossref{\DUrole{std,std-ref}{FatalException}}}}
\paragraph{Public Functions}
\index{ConfigException::ConfigException (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/struct_ConfigException:_CPPv2N15ConfigException15ConfigExceptionEv}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/struct_ConfigException:necsimstruct_config_exception_1afda232dab9843a3ea9e3cbf273e7cc88}}\pysiglinewithargsret{\sphinxbfcode{ConfigException}}{}{}%
\pysigstopmultiline
\end{fulllineitems}

\index{ConfigException::ConfigException (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/struct_ConfigException:_CPPv2N15ConfigException15ConfigExceptionE6string}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/struct_ConfigException:necsimstruct_config_exception_1ab480162a6c4fa7932b4d6906025172f1}}\pysiglinewithargsret{\sphinxbfcode{ConfigException}}{string \sphinxstyleemphasis{msg}}{}%
\pysigstopmultiline
\end{fulllineitems}


\end{fulllineitems}



\subsection{Struct FatalException}
\label{\detokenize{api/struct_FatalException:struct-fatalexception}}\label{\detokenize{api/struct_FatalException::doc}}\label{\detokenize{api/struct_FatalException:id1}}\begin{itemize}
\item {} 
Defined in {\hyperref[\detokenize{api/file_necsim_CustomExceptions.h:file-necsim-customexceptions-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File CustomExceptions.h}}}}

\end{itemize}


\subsubsection{Inheritance Relationships}
\label{\detokenize{api/struct_FatalException:inheritance-relationships}}

\paragraph{Base Type}
\label{\detokenize{api/struct_FatalException:base-type}}\begin{itemize}
\item {} 
\sphinxcode{public std::runtime\_error}

\end{itemize}


\paragraph{Derived Types}
\label{\detokenize{api/struct_FatalException:derived-types}}\begin{itemize}
\item {} 
\sphinxcode{public ConfigException} ({\hyperref[\detokenize{api/struct_ConfigException:struct-configexception}]{\sphinxcrossref{\DUrole{std,std-ref}{Struct ConfigException}}}})

\item {} 
\sphinxcode{public SpeciesException} ({\hyperref[\detokenize{api/struct_SpeciesException:struct-speciesexception}]{\sphinxcrossref{\DUrole{std,std-ref}{Struct SpeciesException}}}})

\end{itemize}


\subsubsection{Struct Documentation}
\label{\detokenize{api/struct_FatalException:struct-documentation}}\index{FatalException (C++ class)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/struct_FatalException:_CPPv214FatalException}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/struct_FatalException:necsimstruct_fatal_exception}}\pysigline{\sphinxstrong{struct }\sphinxcode{}\sphinxbfcode{FatalException}}%
\pysigstopmultiline
This is called any time a fatal exception is called and the program is unwound and ended. 

Inherits from std::runtime\_error

Subclassed by {\hyperref[\detokenize{api/struct_ConfigException:necsimstruct_config_exception}]{\sphinxcrossref{\DUrole{std,std-ref}{ConfigException}}}}, {\hyperref[\detokenize{api/struct_SpeciesException:necsimstruct_species_exception}]{\sphinxcrossref{\DUrole{std,std-ref}{SpeciesException}}}}
\paragraph{Public Functions}
\index{FatalException::FatalException (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/struct_FatalException:_CPPv2N14FatalException14FatalExceptionEv}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/struct_FatalException:necsimstruct_fatal_exception_1a942e75b5fae2803c69cbf794a974b43a}}\pysiglinewithargsret{\sphinxbfcode{FatalException}}{}{}%
\pysigstopmultiline
\end{fulllineitems}

\index{FatalException::FatalException (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/struct_FatalException:_CPPv2N14FatalException14FatalExceptionE6string}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/struct_FatalException:necsimstruct_fatal_exception_1a0a95484803080c915b5a728b9ab863c6}}\pysiglinewithargsret{\sphinxbfcode{FatalException}}{string \sphinxstyleemphasis{msg}}{}%
\pysigstopmultiline
\end{fulllineitems}


\end{fulllineitems}



\subsection{Struct Fragment}
\label{\detokenize{api/struct_Fragment:struct-fragment}}\label{\detokenize{api/struct_Fragment::doc}}\label{\detokenize{api/struct_Fragment:id1}}\begin{itemize}
\item {} 
Defined in {\hyperref[\detokenize{api/file_necsim_Community.h:file-necsim-community-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File Community.h}}}}

\end{itemize}


\subsubsection{Struct Documentation}
\label{\detokenize{api/struct_Fragment:struct-documentation}}\index{Fragment (C++ class)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/struct_Fragment:_CPPv28Fragment}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/struct_Fragment:necsimstruct_fragment}}\pysigline{\sphinxstrong{struct }\sphinxcode{}\sphinxbfcode{Fragment}}%
\pysigstopmultiline
Contains the information needed for defining a fragment. Fragments can be detected from the {\hyperref[\detokenize{api/class_Samplematrix:necsimclass_samplematrix}]{\sphinxcrossref{\DUrole{std,std-ref}{Samplematrix}}}} object (which only detects rectangular fragments), or (preferably) is read from an input file. Currently all fragments must be rectangular, although they can be larger than the intended shape if necesssary. 
\paragraph{Public Members}
\index{Fragment::name (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/struct_Fragment:_CPPv2N8Fragment4nameE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{api/struct_Fragment:necsimstruct_fragment_1acf92da0ecedecb7080adf56e35543636}}string \sphinxbfcode{name}}%
\pysigstopmultiline
\end{fulllineitems}

\index{Fragment::x\_east (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/struct_Fragment:_CPPv2N8Fragment6x_eastE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{api/struct_Fragment:necsimstruct_fragment_1a0257d6b1942656e4181eab82cc5392c4}}long \sphinxbfcode{x\_east}}%
\pysigstopmultiline
\end{fulllineitems}

\index{Fragment::x\_west (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/struct_Fragment:_CPPv2N8Fragment6x_westE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{api/struct_Fragment:necsimstruct_fragment_1aabfd09652d5abae4b6393fd40e6d3d9d}}long \sphinxbfcode{x\_west}}%
\pysigstopmultiline
\end{fulllineitems}

\index{Fragment::y\_north (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/struct_Fragment:_CPPv2N8Fragment7y_northE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{api/struct_Fragment:necsimstruct_fragment_1a1d792c8e975cbc9405ece3a90a283c4f}}long \sphinxbfcode{y\_north}}%
\pysigstopmultiline
\end{fulllineitems}

\index{Fragment::y\_south (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/struct_Fragment:_CPPv2N8Fragment7y_southE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{api/struct_Fragment:necsimstruct_fragment_1a71d7c613d71459b72158ef80ba705bfc}}long \sphinxbfcode{y\_south}}%
\pysigstopmultiline
\end{fulllineitems}

\index{Fragment::num (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/struct_Fragment:_CPPv2N8Fragment3numE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{api/struct_Fragment:necsimstruct_fragment_1ac966a3ac928cba2706ca9c87f159d1ee}}unsigned long \sphinxbfcode{num}}%
\pysigstopmultiline
\end{fulllineitems}

\index{Fragment::area (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/struct_Fragment:_CPPv2N8Fragment4areaE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{api/struct_Fragment:necsimstruct_fragment_1ad37e6d449d9b0b1273e712e5a4da2887}}double \sphinxbfcode{area}}%
\pysigstopmultiline
\end{fulllineitems}


\end{fulllineitems}



\subsection{Struct MetacommunitiesArray}
\label{\detokenize{api/struct_MetacommunitiesArray:struct-metacommunitiesarray}}\label{\detokenize{api/struct_MetacommunitiesArray::doc}}\label{\detokenize{api/struct_MetacommunitiesArray:id1}}\begin{itemize}
\item {} 
Defined in {\hyperref[\detokenize{api/file_necsim_Community.h:file-necsim-community-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File Community.h}}}}

\end{itemize}


\subsubsection{Struct Documentation}
\label{\detokenize{api/struct_MetacommunitiesArray:struct-documentation}}\index{MetacommunitiesArray (C++ class)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/struct_MetacommunitiesArray:_CPPv220MetacommunitiesArray}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/struct_MetacommunitiesArray:necsimstruct_metacommunities_array}}\pysigline{\sphinxstrong{struct }\sphinxcode{}\sphinxbfcode{MetacommunitiesArray}}%
\pysigstopmultiline
Contains an array of {\hyperref[\detokenize{api/struct_MetacommunityParameters:necsimstruct_metacommunity_parameters}]{\sphinxcrossref{\DUrole{std,std-ref}{MetacommunityParameters}}}} that have been applied to the coalescence tree. 
\paragraph{Public Functions}
\index{MetacommunitiesArray::pushBack (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/struct_MetacommunitiesArray:_CPPv2N20MetacommunitiesArray8pushBackEmem}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/struct_MetacommunitiesArray:necsimstruct_metacommunities_array_1a581a404fb39d14256419d9ae1118f58b}}\pysiglinewithargsret{void \sphinxbfcode{pushBack}}{unsigned long \sphinxstyleemphasis{reference}, long double \sphinxstyleemphasis{speciation\_rate}, unsigned long \sphinxstyleemphasis{metacommunity\_size}}{}%
\pysigstopmultiline
Adds an extra {\hyperref[\detokenize{api/struct_CommunityParameters:necsimstruct_community_parameters}]{\sphinxcrossref{\DUrole{std,std-ref}{CommunityParameters}}}} object to the calc\_array vector with the supplied variables. 

\begin{description}
\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{reference}: the reference for this set of metacommunity parameters 

\item {} 
\sphinxcode{speciation\_rate}: the speciation rate used in generation of the metacommunity 

\item {} 
\sphinxcode{metacommunity\_size}: the size of the metacommunity used 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{MetacommunitiesArray::pushBack (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/struct_MetacommunitiesArray:_CPPv2N20MetacommunitiesArray8pushBackE23MetacommunityParameters}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/struct_MetacommunitiesArray:necsimstruct_metacommunities_array_1aafc6f9ba63be4c85d32d86ebfd2137e3}}\pysiglinewithargsret{void \sphinxbfcode{pushBack}}{{\hyperref[\detokenize{api/struct_MetacommunityParameters:_CPPv223MetacommunityParameters}]{\sphinxcrossref{MetacommunityParameters}}} \sphinxstyleemphasis{tmp\_param}}{}%
\pysigstopmultiline
Adds the provided PastMetacommunityParameters object to the calc\_array vector. 

\begin{description}
\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{tmp\_param}: the set of metacommunity parameters to add 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{MetacommunitiesArray::addNew (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/struct_MetacommunitiesArray:_CPPv2N20MetacommunitiesArray6addNewEem}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/struct_MetacommunitiesArray:necsimstruct_metacommunities_array_1a2fef78ac6dea9d8297a7fd3b72f3026c}}\pysiglinewithargsret{unsigned long \sphinxbfcode{addNew}}{long double \sphinxstyleemphasis{speciation\_rate}, unsigned long \sphinxstyleemphasis{metacommunity\_size}}{}%
\pysigstopmultiline
Adds a new metacommunities calculation paremeters reference, with a new unique reference. 

\begin{description}
\item[{\sphinxstylestrong{Return}}] \leavevmode
the new reference number, which should be unique 

\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{speciation\_rate}: the speciation rate of the new calculation 

\item {} 
\sphinxcode{metacommunity\_size}: the size of the metacommunity in the new calculation 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{MetacommunitiesArray::hasPair (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/struct_MetacommunitiesArray:_CPPv2N20MetacommunitiesArray7hasPairEem}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/struct_MetacommunitiesArray:necsimstruct_metacommunities_array_1a8ef151569615b4091807aa8c50ebf1b2}}\pysiglinewithargsret{bool \sphinxbfcode{hasPair}}{long double \sphinxstyleemphasis{speciation\_rate}, unsigned long \sphinxstyleemphasis{metacommunity\_size}}{}%
\pysigstopmultiline
Checks whether the calculation with the supplied variables has already been performed. 

\begin{description}
\item[{\sphinxstylestrong{Return}}] \leavevmode
true if the reference exists in past metacommunity parameters 

\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{speciation\_rate}: the speciation rate to check for 

\item {} 
\sphinxcode{metacommunity\_size}: the size of metacommunity to check for 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{MetacommunitiesArray::hasPair (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/struct_MetacommunitiesArray:_CPPv2N20MetacommunitiesArray7hasPairEm}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/struct_MetacommunitiesArray:necsimstruct_metacommunities_array_1a98876103779bab91793f6daa513722d6}}\pysiglinewithargsret{bool \sphinxbfcode{hasPair}}{unsigned long \sphinxstyleemphasis{reference}}{}%
\pysigstopmultiline
Checks whether the calculation with the supplied reference has already been performed. Overloaded version for checking references. 

\begin{description}
\item[{\sphinxstylestrong{Return}}] \leavevmode
true if the reference exists in past metacommunity parameters 

\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{reference}: the reference to check for in past metacommunity parameters 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{MetacommunitiesArray::getReference (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/struct_MetacommunitiesArray:_CPPv2N20MetacommunitiesArray12getReferenceEem}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/struct_MetacommunitiesArray:necsimstruct_metacommunities_array_1a5c15d164bc32cd2731c9382fe3fbbfbe}}\pysiglinewithargsret{unsigned long \sphinxbfcode{getReference}}{long double \sphinxstyleemphasis{speciation\_rate}, unsigned long \sphinxstyleemphasis{metacommunity\_size}}{}%
\pysigstopmultiline
Gets the metacommunity reference for the provided parameters, or returns 0 if it doesn't exist. 

\begin{description}
\item[{\sphinxstylestrong{Return}}] \leavevmode
the metacommunity reference number, or 0 if it doesn't exist 

\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{speciation\_rate}: the metacommunity speciation rate to obtain for 

\item {} 
\sphinxcode{metacommunity\_size}: the metacommunity size to apply for 

\item {} 
\sphinxcode{fragment}: bool for checking if fragments were used 

\end{itemize}

\end{description}


\end{fulllineitems}

\paragraph{Public Members}
\index{MetacommunitiesArray::calc\_array (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/struct_MetacommunitiesArray:_CPPv2N20MetacommunitiesArray10calc_arrayE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{api/struct_MetacommunitiesArray:necsimstruct_metacommunities_array_1ae98cbbcca0be5883b0028f4c0a136261}}vector\textless{}{\hyperref[\detokenize{api/struct_MetacommunityParameters:_CPPv223MetacommunityParameters}]{\sphinxcrossref{MetacommunityParameters}}}\textgreater{} \sphinxbfcode{calc\_array}}%
\pysigstopmultiline
\end{fulllineitems}


\end{fulllineitems}



\subsection{Struct MetacommunityParameters}
\label{\detokenize{api/struct_MetacommunityParameters:struct-metacommunityparameters}}\label{\detokenize{api/struct_MetacommunityParameters::doc}}\label{\detokenize{api/struct_MetacommunityParameters:id1}}\begin{itemize}
\item {} 
Defined in {\hyperref[\detokenize{api/file_necsim_Community.h:file-necsim-community-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File Community.h}}}}

\end{itemize}


\subsubsection{Struct Documentation}
\label{\detokenize{api/struct_MetacommunityParameters:struct-documentation}}\index{MetacommunityParameters (C++ class)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/struct_MetacommunityParameters:_CPPv223MetacommunityParameters}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/struct_MetacommunityParameters:necsimstruct_metacommunity_parameters}}\pysigline{\sphinxstrong{struct }\sphinxcode{}\sphinxbfcode{MetacommunityParameters}}%
\pysigstopmultiline
Contains a set of metacommunity parameters that have been applied, or are to be applied, to the coalescence tree. 
\paragraph{Public Functions}
\index{MetacommunityParameters::MetacommunityParameters (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/struct_MetacommunityParameters:_CPPv2N23MetacommunityParameters23MetacommunityParametersEmem}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/struct_MetacommunityParameters:necsimstruct_metacommunity_parameters_1af6bab418342254503030c3fc6390420e}}\pysiglinewithargsret{\sphinxbfcode{MetacommunityParameters}}{unsigned long \sphinxstyleemphasis{reference\_in}, long double \sphinxstyleemphasis{speciation\_rate\_in}, unsigned long \sphinxstyleemphasis{metacommunity\_size\_in}}{}%
\pysigstopmultiline
Constructor for {\hyperref[\detokenize{api/struct_MetacommunityParameters:necsimstruct_metacommunity_parameters}]{\sphinxcrossref{\DUrole{std,std-ref}{MetacommunityParameters}}}}, storing a previously applied metacommunity. 

\begin{description}
\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{reference\_in}: the metacommunity reference number 

\item {} 
\sphinxcode{speciation\_rate\_in}: the speciation rate used for metacommunity generation 

\item {} 
\sphinxcode{metacommunity\_size\_in}: size of the tested metacommunity 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{MetacommunityParameters::compare (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/struct_MetacommunityParameters:_CPPv2N23MetacommunityParameters7compareEem}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/struct_MetacommunityParameters:necsimstruct_metacommunity_parameters_1a5f0c670813ba6a1e34d05e7eba782251}}\pysiglinewithargsret{bool \sphinxbfcode{compare}}{long double \sphinxstyleemphasis{speciation\_rate\_in}, unsigned long \sphinxstyleemphasis{metacommunity\_size\_in}}{}%
\pysigstopmultiline
Compare these set of parameters with the input set. If they match, return true, otherwise return false. 

\begin{description}
\item[{\sphinxstylestrong{Return}}] \leavevmode


\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{speciation\_rate\_in}: speciation rate to compare with stored community parameter 

\item {} 
\sphinxcode{metacommunity\_size\_in}: size of the tested metacommunity 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{MetacommunityParameters::compare (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/struct_MetacommunityParameters:_CPPv2N23MetacommunityParameters7compareEm}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/struct_MetacommunityParameters:necsimstruct_metacommunity_parameters_1a5b8597643984dd783a4275d93ce0b7cb}}\pysiglinewithargsret{bool \sphinxbfcode{compare}}{unsigned long \sphinxstyleemphasis{reference\_in}}{}%
\pysigstopmultiline
Checks if the supplied reference is the same in the metacommunity reference. 

\begin{description}
\item[{\sphinxstylestrong{Return}}] \leavevmode


\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{reference\_in}: the reference to check against 

\end{itemize}

\end{description}


\end{fulllineitems}

\paragraph{Public Members}
\index{MetacommunityParameters::reference (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/struct_MetacommunityParameters:_CPPv2N23MetacommunityParameters9referenceE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{api/struct_MetacommunityParameters:necsimstruct_metacommunity_parameters_1af6c04331c114ae95467ff2301789a67b}}unsigned long \sphinxbfcode{reference}}%
\pysigstopmultiline
\end{fulllineitems}

\index{MetacommunityParameters::metacommunity\_size (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/struct_MetacommunityParameters:_CPPv2N23MetacommunityParameters18metacommunity_sizeE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{api/struct_MetacommunityParameters:necsimstruct_metacommunity_parameters_1a92d44abb439daab624572ed7f9199ab4}}unsigned long \sphinxbfcode{metacommunity\_size}}%
\pysigstopmultiline
\end{fulllineitems}

\index{MetacommunityParameters::speciation\_rate (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/struct_MetacommunityParameters:_CPPv2N23MetacommunityParameters15speciation_rateE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{api/struct_MetacommunityParameters:necsimstruct_metacommunity_parameters_1a6ad494c076296c0eac963facca209430}}long double \sphinxbfcode{speciation\_rate}}%
\pysigstopmultiline
\end{fulllineitems}


\end{fulllineitems}



\subsection{Struct module\_state}
\label{\detokenize{api/struct_module_state:id1}}\label{\detokenize{api/struct_module_state::doc}}\label{\detokenize{api/struct_module_state:struct-module-state}}\begin{itemize}
\item {} 
Defined in {\hyperref[\detokenize{api/file_applyspecmodule.h:file-applyspecmodule-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File applyspecmodule.h}}}}

\end{itemize}


\subsubsection{Struct Documentation}
\label{\detokenize{api/struct_module_state:struct-documentation}}\index{module\_state (C++ class)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/struct_module_state:_CPPv212module_state}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/struct_module_state:necsimstructmodule__state}}\pysigline{\sphinxstrong{struct }\sphinxcode{}\sphinxbfcode{module\_state}}%
\pysigstopmultiline~\paragraph{Public Members}
\index{module\_state::error (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/struct_module_state:_CPPv2N12module_state5errorE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{api/struct_module_state:necsimstructmodule__state_1a6593da300121fe46fad3e7280053fab8}}PyObject *\sphinxbfcode{error}}%
\pysigstopmultiline
\end{fulllineitems}


\end{fulllineitems}



\subsection{Struct SectionOption}
\label{\detokenize{api/struct_SectionOption::doc}}\label{\detokenize{api/struct_SectionOption:struct-sectionoption}}\label{\detokenize{api/struct_SectionOption:id1}}\begin{itemize}
\item {} 
Defined in {\hyperref[\detokenize{api/file_necsim_ConfigFileParser.h:file-necsim-configfileparser-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File ConfigFileParser.h}}}}

\end{itemize}


\subsubsection{Struct Documentation}
\label{\detokenize{api/struct_SectionOption:struct-documentation}}\index{SectionOption (C++ class)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/struct_SectionOption:_CPPv213SectionOption}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/struct_SectionOption:necsimstruct_section_option}}\pysigline{\sphinxstrong{struct }\sphinxcode{}\sphinxbfcode{SectionOption}}%
\pysigstopmultiline
A simple container for importing options from a config file. 
\paragraph{Public Functions}
\index{SectionOption::SectionOption (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/struct_SectionOption:_CPPv2N13SectionOption13SectionOptionEv}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/struct_SectionOption:necsimstruct_section_option_1a0a6a33e41311ea0eef34b76379421362}}\pysiglinewithargsret{\sphinxbfcode{SectionOption}}{}{}%
\pysigstopmultiline
Default constructor for {\hyperref[\detokenize{api/struct_SectionOption:necsimstruct_section_option}]{\sphinxcrossref{\DUrole{std,std-ref}{SectionOption}}}}. 

\end{fulllineitems}

\index{SectionOption::getOption (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/struct_SectionOption:_CPPv2N13SectionOption9getOptionE6string}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/struct_SectionOption:necsimstruct_section_option_1a78d55aa842ba2056764236246492734f}}\pysiglinewithargsret{string \sphinxbfcode{getOption}}{string \sphinxstyleemphasis{refval}}{}%
\pysigstopmultiline
Returns the value for the provided reference from within the key. 

\begin{description}
\item[{\sphinxstylestrong{Return}}] \leavevmode
the requested value as a string. Returns string \sphinxquotedblleft{}null\sphinxquotedblright{} if no reference is found. 

\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{refval}: the reference to obtain the value of 

\end{itemize}

\end{description}


\end{fulllineitems}

\paragraph{Public Members}
\index{SectionOption::section (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/struct_SectionOption:_CPPv2N13SectionOption7sectionE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{api/struct_SectionOption:necsimstruct_section_option_1af6dd28af164466810fe9f36091b9d6d1}}string \sphinxbfcode{section}}%
\pysigstopmultiline
\end{fulllineitems}

\index{SectionOption::val (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/struct_SectionOption:_CPPv2N13SectionOption3valE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{api/struct_SectionOption:necsimstruct_section_option_1a789da4aa7aeef3887bcfc94f7cf2c254}}vector\textless{}string\textgreater{} \sphinxbfcode{val}}%
\pysigstopmultiline
\end{fulllineitems}

\index{SectionOption::refs (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/struct_SectionOption:_CPPv2N13SectionOption4refsE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{api/struct_SectionOption:necsimstruct_section_option_1a916b36005e0e1817a9dcf45bf02952e4}}vector\textless{}string\textgreater{} \sphinxbfcode{refs}}%
\pysigstopmultiline
\end{fulllineitems}

\paragraph{Friends}
\index{operator\textless{}\textless{} (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/struct_SectionOption:_CPPv2lsR7ostreamRK13SectionOption}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/struct_SectionOption:necsimstruct_section_option_1a8e9eafe82f001a7bf599bebb1f0bdb76}}\pysiglinewithargsret{ostream \&\sphinxbfcode{operator\textless{}\textless{}}}{ostream \&\sphinxstyleemphasis{os}, \sphinxstrong{const} {\hyperref[\detokenize{api/struct_SectionOption:_CPPv213SectionOption}]{\sphinxcrossref{SectionOption}}} \&\sphinxstyleemphasis{k}}{}%
\pysigstopmultiline
Overloading the \textless{}\textless{} operator for outputting to the output stream. 

\begin{description}
\item[{\sphinxstylestrong{Return}}] \leavevmode
os the output stream. 

\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{os}: the output stream. 

\item {} 
\sphinxcode{k}: the KeyOption object. 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{operator\textgreater{}\textgreater{} (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/struct_SectionOption:_CPPv2rsR7istreamR13SectionOption}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/struct_SectionOption:necsimstruct_section_option_1a6e317b3e4692b867e48205afcceff1a1}}\pysiglinewithargsret{istream \&\sphinxbfcode{operator\textgreater{}\textgreater{}}}{istream \&\sphinxstyleemphasis{is}, {\hyperref[\detokenize{api/struct_SectionOption:_CPPv213SectionOption}]{\sphinxcrossref{SectionOption}}} \&\sphinxstyleemphasis{k}}{}%
\pysigstopmultiline
Overloading the \textgreater{}\textgreater{} operator for inputting from an input stream. 

\begin{description}
\item[{\sphinxstylestrong{Return}}] \leavevmode
is the input stream 

\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{is}: the input stream 

\item {} 
\sphinxcode{k}: the KeyOption object 

\end{itemize}

\end{description}


\end{fulllineitems}


\end{fulllineitems}



\subsection{Struct SimParameters}
\label{\detokenize{api/struct_SimParameters::doc}}\label{\detokenize{api/struct_SimParameters:struct-simparameters}}\label{\detokenize{api/struct_SimParameters:id1}}\begin{itemize}
\item {} 
Defined in {\hyperref[\detokenize{api/file_necsim_SimParameters.h:file-necsim-simparameters-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File SimParameters.h}}}}

\end{itemize}


\subsubsection{Struct Documentation}
\label{\detokenize{api/struct_SimParameters:struct-documentation}}\index{SimParameters (C++ class)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/struct_SimParameters:_CPPv213SimParameters}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/struct_SimParameters:necsimstruct_sim_parameters}}\pysigline{\sphinxstrong{struct }\sphinxcode{}\sphinxbfcode{SimParameters}}%
\pysigstopmultiline
Stores and imports the variables required by the {\hyperref[\detokenize{api/class_Map:necsimclass_map}]{\sphinxcrossref{\DUrole{std,std-ref}{Map}}}} object. Used to setting the {\hyperref[\detokenize{api/class_Map:necsimclass_map}]{\sphinxcrossref{\DUrole{std,std-ref}{Map}}}} variables in a more elegant way. 
\paragraph{Public Functions}
\index{SimParameters::SimParameters (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/struct_SimParameters:_CPPv2N13SimParameters13SimParametersEv}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/struct_SimParameters:necsimstruct_sim_parameters_1aa91bc46ea6909abeeb7488c36da269ee}}\pysiglinewithargsret{\sphinxbfcode{SimParameters}}{}{}%
\pysigstopmultiline
Default constructor. 

\end{fulllineitems}

\index{SimParameters::importParameters (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/struct_SimParameters:_CPPv2N13SimParameters16importParametersEP12ConfigOption}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/struct_SimParameters:necsimstruct_sim_parameters_1affb4a6133434c61c720b648012ccbcea}}\pysiglinewithargsret{void \sphinxbfcode{importParameters}}{{\hyperref[\detokenize{api/class_ConfigOption:_CPPv212ConfigOption}]{\sphinxcrossref{ConfigOption}}} *\sphinxstyleemphasis{configOption}}{}%
\pysigstopmultiline
Links to the provided {\hyperref[\detokenize{api/class_ConfigOption:necsimclass_config_option}]{\sphinxcrossref{\DUrole{std,std-ref}{ConfigOption}}}}. Assumes that the parameters have already been parsed from the config file. 

\begin{description}
\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{configOption}: the pointer to the parsed {\hyperref[\detokenize{api/class_ConfigOption:necsimclass_config_option}]{\sphinxcrossref{\DUrole{std,std-ref}{ConfigOption}}}} object 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{SimParameters::importParameters (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/struct_SimParameters:_CPPv2N13SimParameters16importParametersERK6string}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/struct_SimParameters:necsimstruct_sim_parameters_1a2c587f1f41e13c51696ca24e5edadc96}}\pysiglinewithargsret{void \sphinxbfcode{importParameters}}{\sphinxstrong{const} string \&\sphinxstyleemphasis{conf\_in}}{}%
\pysigstopmultiline
Imports the spatial variables from a path to the config file.. 

\begin{description}
\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{config\_in}: string of the path to the config file 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{SimParameters::importParameters (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/struct_SimParameters:_CPPv2N13SimParameters16importParametersEv}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/struct_SimParameters:necsimstruct_sim_parameters_1a65833f22d1f30997727ed71e989af02e}}\pysiglinewithargsret{void \sphinxbfcode{importParameters}}{}{}%
\pysigstopmultiline
Main import of parameters from the config file option. 

\end{fulllineitems}

\index{SimParameters::setKeyParameters (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/struct_SimParameters:_CPPv2N13SimParameters16setKeyParametersERKxRKxRK6stringRKmmRK6string}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/struct_SimParameters:necsimstruct_sim_parameters_1aa6684caccd53613a5d08ff4071d0edc9}}\pysiglinewithargsret{void \sphinxbfcode{setKeyParameters}}{\sphinxstrong{const} long long \&\sphinxstyleemphasis{task\_in}, \sphinxstrong{const} long long \&\sphinxstyleemphasis{seed\_in}, \sphinxstrong{const} string \&\sphinxstyleemphasis{output\_directory\_in}, \sphinxstrong{const} unsigned long \&\sphinxstyleemphasis{max\_time\_in}, unsigned long \sphinxstyleemphasis{desired\_specnum\_in}, \sphinxstrong{const} string \&\sphinxstyleemphasis{times\_file\_in}}{}%
\pysigstopmultiline
Sets the main simulation parameters. 

\begin{description}
\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{task\_in}: the task reference number, used for file referencing 

\item {} 
\sphinxcode{seed\_in}: the seed to set random number generation 

\item {} 
\sphinxcode{output\_directory\_in}: the output directory 

\item {} 
\sphinxcode{max\_time\_in}: the maximum time to simulate for 

\item {} 
\sphinxcode{desired\_specnum\_in}: the desired number of species to aim towards (currently not functional) 

\item {} 
\sphinxcode{times\_file\_in}: the file containing a list of temporal sampling points 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{SimParameters::setSpeciationParameters (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/struct_SimParameters:_CPPv2N13SimParameters23setSpeciationParametersERKebRKdRKd}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/struct_SimParameters:necsimstruct_sim_parameters_1a6753a70e7b9183c97fb1b304b089968d}}\pysiglinewithargsret{void \sphinxbfcode{setSpeciationParameters}}{\sphinxstrong{const} long double \&\sphinxstyleemphasis{spec\_in}, bool \sphinxstyleemphasis{is\_protracted\_in}, \sphinxstrong{const} double \&\sphinxstyleemphasis{min\_speciation\_gen\_in}, \sphinxstrong{const} double \&\sphinxstyleemphasis{max\_speciation\_gen\_in}}{}%
\pysigstopmultiline
Sets the speciation parameters for the simulation. 

\begin{description}
\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{spec\_in}: the speciation rate to use 

\item {} 
\sphinxcode{is\_protracted\_in}: if true, simulates as a protracted simulation 

\item {} 
\sphinxcode{min\_speciation\_gen\_in}: the minimum speciation generation for protracted simulations 

\item {} 
\sphinxcode{max\_speciation\_gen\_in}: the maximum speciation generation for protracted simulations 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{SimParameters::setDispersalParameters (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/struct_SimParameters:_CPPv2N13SimParameters22setDispersalParametersERK6stringRKdRKdRKdRKdRKdbRK6stringRK6stringRK6string}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/struct_SimParameters:necsimstruct_sim_parameters_1a74782aab11b1e07a507cc60bdec3bf95}}\pysiglinewithargsret{void \sphinxbfcode{setDispersalParameters}}{\sphinxstrong{const} string \&\sphinxstyleemphasis{dispersal\_method\_in}, \sphinxstrong{const} double \&\sphinxstyleemphasis{sigma\_in}, \sphinxstrong{const} double \&\sphinxstyleemphasis{tau\_in}, \sphinxstrong{const} double \&\sphinxstyleemphasis{m\_prob\_in}, \sphinxstrong{const} double \&\sphinxstyleemphasis{cutoff\_in}, \sphinxstrong{const} double \&\sphinxstyleemphasis{dispersal\_relative\_cost\_in}, bool \sphinxstyleemphasis{restrict\_self\_in}, \sphinxstrong{const} string \&\sphinxstyleemphasis{landscape\_type\_in}, \sphinxstrong{const} string \&\sphinxstyleemphasis{dispersal\_file\_in}, \sphinxstrong{const} string \&\sphinxstyleemphasis{reproduction\_file\_in}}{}%
\pysigstopmultiline
Sets the dispersal parameters for the simulation. 

\begin{description}
\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{dispersal\_method\_in}: the method of individuals dispersing (normal, fat-tailed or norm-uniform) 

\item {} 
\sphinxcode{sigma\_in}: the sigma value for a normal distribution 

\item {} 
\sphinxcode{tau\_in}: the tau value for the fat-tailed distribution 

\item {} 
\sphinxcode{m\_prob\_in}: the probability of uniform dispersal for the norm-uniform distribution 

\item {} 
\sphinxcode{cutoff\_in}: the maximum dispersal distance for the uniform distribution 

\item {} 
\sphinxcode{dispersal\_relative\_cost\_in}: the relative cost of dispersing through non-forest 

\item {} 
\sphinxcode{restrict\_self\_in}: if true, prevents dispersal from the same cell 

\item {} 
\sphinxcode{landscape\_type\_in}: the landscape type (infinite, tiled or closed) 

\item {} 
\sphinxcode{dispersal\_file\_in}: a map of dispersal probabilities 

\item {} 
\sphinxcode{reproduction\_file\_in}: a map of reproduction probabilities 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{SimParameters::setPristineMapParameters (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/struct_SimParameters:_CPPv2N13SimParameters24setPristineMapParametersERK6stringRK6stringRKdRKd}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/struct_SimParameters:necsimstruct_sim_parameters_1a117bb284f7bd540e0301e7985d08614a}}\pysiglinewithargsret{void \sphinxbfcode{setPristineMapParameters}}{\sphinxstrong{const} string \&\sphinxstyleemphasis{pristine\_fine\_file\_map\_in}, \sphinxstrong{const} string \&\sphinxstyleemphasis{pristine\_coarse\_map\_file\_in}, \sphinxstrong{const} double \&\sphinxstyleemphasis{gen\_since\_pristine\_in}, \sphinxstrong{const} double \&\sphinxstyleemphasis{habitat\_change\_rate\_in}}{}%
\pysigstopmultiline
Sets the pristine map parameters for the simulation. 

\begin{description}
\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{pristine\_fine\_file\_map\_in}: the fine resolution pristine file 

\item {} 
\sphinxcode{pristine\_coarse\_map\_file\_in}: the coarse resolution pristine file 

\item {} 
\sphinxcode{gen\_since\_pristine\_in}: the number of generations since the pristine state was achieved 

\item {} 
\sphinxcode{habitat\_change\_rate\_in}: the rate of habitat change towards the pristine state 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{SimParameters::setMapParameters (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/struct_SimParameters:_CPPv2N13SimParameters16setMapParametersERK6stringRK6stringRK6stringRKmRKmRKmRKmRKmRKmRKmRKmRKmRKmRKmRKmRKmRKmRKmRKmRKdb}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/struct_SimParameters:necsimstruct_sim_parameters_1a4073ee2bf48a25eebdc0439e3b8625e7}}\pysiglinewithargsret{void \sphinxbfcode{setMapParameters}}{\sphinxstrong{const} string \&\sphinxstyleemphasis{fine\_map\_file\_in}, \sphinxstrong{const} string \&\sphinxstyleemphasis{coarse\_map\_file\_in}, \sphinxstrong{const} string \&\sphinxstyleemphasis{sample\_mask\_file\_in}, \sphinxstrong{const} unsigned long \&\sphinxstyleemphasis{grid\_x\_size\_in}, \sphinxstrong{const} unsigned long \&\sphinxstyleemphasis{grid\_y\_size\_in}, \sphinxstrong{const} unsigned long \&\sphinxstyleemphasis{sample\_x\_size\_in}, \sphinxstrong{const} unsigned long \&\sphinxstyleemphasis{sample\_y\_size\_in}, \sphinxstrong{const} unsigned long \&\sphinxstyleemphasis{sample\_x\_offset\_in}, \sphinxstrong{const} unsigned long \&\sphinxstyleemphasis{sample\_y\_offset\_in}, \sphinxstrong{const} unsigned long \&\sphinxstyleemphasis{fine\_map\_x\_size\_in}, \sphinxstrong{const} unsigned long \&\sphinxstyleemphasis{fine\_map\_y\_size\_in}, \sphinxstrong{const} unsigned long \&\sphinxstyleemphasis{fine\_map\_x\_offset\_in}, \sphinxstrong{const} unsigned long \&\sphinxstyleemphasis{fine\_map\_y\_offset\_in}, \sphinxstrong{const} unsigned long \&\sphinxstyleemphasis{coarse\_map\_x\_size\_in}, \sphinxstrong{const} unsigned long \&\sphinxstyleemphasis{coarse\_map\_y\_size\_in}, \sphinxstrong{const} unsigned long \&\sphinxstyleemphasis{coarse\_map\_x\_offset\_in}, \sphinxstrong{const} unsigned long \&\sphinxstyleemphasis{coarse\_map\_y\_offset\_in}, \sphinxstrong{const} unsigned long \&\sphinxstyleemphasis{coarse\_map\_scale\_in}, \sphinxstrong{const} unsigned long \&\sphinxstyleemphasis{deme\_in}, \sphinxstrong{const} double \&\sphinxstyleemphasis{deme\_sample\_in}, bool \sphinxstyleemphasis{uses\_spatial\_sampling\_in}}{}%
\pysigstopmultiline
Sets the map parameters for the simulation. 

\begin{description}
\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{fine\_map\_file\_in}: the fine resolution density map 

\item {} 
\sphinxcode{coarse\_map\_file\_in}: the coarse resolution density map 

\item {} 
\sphinxcode{sample\_mask\_file\_in}: the spatial sampling mask 

\item {} 
\sphinxcode{grid\_x\_size\_in}: the x dimension of the grid 

\item {} 
\sphinxcode{grid\_y\_size\_in}: the y dimension of the grid 

\item {} 
\sphinxcode{sample\_x\_size\_in}: the x dimension of the sample mask 

\item {} 
\sphinxcode{sample\_y\_size\_in}: the y dimension of the sample mask 

\item {} 
\sphinxcode{sample\_x\_offset\_in}: the x offset of the sample mask from the grid 

\item {} 
\sphinxcode{sample\_y\_offset\_in}: the y offset of the sample mask from the grid 

\item {} 
\sphinxcode{fine\_map\_x\_size\_in}: the x dimension of the fine map 

\item {} 
\sphinxcode{fine\_map\_y\_size\_in}: the y dimension of the fine map 

\item {} 
\sphinxcode{fine\_map\_x\_offset\_in}: the x offset of the fine map from the sample mask 

\item {} 
\sphinxcode{fine\_map\_y\_offset\_in}: the y offset of the fine map from the sample mask 

\item {} 
\sphinxcode{coarse\_map\_x\_size\_in}: the x dimension of the coarse map 

\item {} 
\sphinxcode{coarse\_map\_y\_size\_in}: the y dimension of the coarse map 

\item {} 
\sphinxcode{coarse\_map\_x\_offset\_in}: the x offset of the coarse map from the fine map 

\item {} 
\sphinxcode{coarse\_map\_y\_offset\_in}: the y offset of the coarse map from the fine map 

\item {} 
\sphinxcode{coarse\_map\_scale\_in}: the scale of the coarse map compared to the fine map 

\item {} 
\sphinxcode{deme\_in}: the number of individuals per cell 

\item {} 
\sphinxcode{deme\_sample\_in}: the proportion of individuals to sample from each cell 

\item {} 
\sphinxcode{uses\_spatial\_sampling\_in}: if the sample mask denotes differing spatial sampling proportions 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{SimParameters::setPristine (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/struct_SimParameters:_CPPv2N13SimParameters11setPristineEj}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/struct_SimParameters:necsimstruct_sim_parameters_1a35fef102ce86c4158d2ae0e19ad0a85e}}\pysiglinewithargsret{bool \sphinxbfcode{setPristine}}{unsigned int \sphinxstyleemphasis{n}}{}%
\pysigstopmultiline
Alters the pristine parameters to the configuration matching the input number. If no configuration option exists for this number, bPristine will be set to true. 

\begin{description}
\item[{\sphinxstylestrong{Return}}] \leavevmode
bool true if we need to re-import the maps (i.e. the pristine maps have changed between updates) 

\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{n}: the pristine map number to check. 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{SimParameters::printVars (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/struct_SimParameters:_CPPv2N13SimParameters9printVarsEv}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/struct_SimParameters:necsimstruct_sim_parameters_1ac7072f58a9dccc718341d25a84148ffc}}\pysiglinewithargsret{void \sphinxbfcode{printVars}}{}{}%
\pysigstopmultiline
Prints selected important variables to the terminal. 

\end{fulllineitems}

\index{SimParameters::setMetacommunityParameters (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/struct_SimParameters:_CPPv2N13SimParameters26setMetacommunityParametersERKmRKdRKmRKm}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/struct_SimParameters:necsimstruct_sim_parameters_1a8a245d9aef5595c7d3b4e29e3b1a2ef2}}\pysiglinewithargsret{void \sphinxbfcode{setMetacommunityParameters}}{\sphinxstrong{const} unsigned long \&\sphinxstyleemphasis{metacommunity\_size}, \sphinxstrong{const} double \&\sphinxstyleemphasis{speciation\_rate}, \sphinxstrong{const} unsigned long \&\sphinxstyleemphasis{seed}, \sphinxstrong{const} unsigned long \&\sphinxstyleemphasis{job}}{}%
\pysigstopmultiline
\end{fulllineitems}

\paragraph{Public Members}
\index{SimParameters::fine\_map\_file (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/struct_SimParameters:_CPPv2N13SimParameters13fine_map_fileE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{api/struct_SimParameters:necsimstruct_sim_parameters_1a24483485b1127d7c4a91f02bd56a130e}}string \sphinxbfcode{fine\_map\_file}}%
\pysigstopmultiline
\end{fulllineitems}

\index{SimParameters::coarse\_map\_file (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/struct_SimParameters:_CPPv2N13SimParameters15coarse_map_fileE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{api/struct_SimParameters:necsimstruct_sim_parameters_1a03831d4d7590072a153620fdedd7e2fd}}string \sphinxbfcode{coarse\_map\_file}}%
\pysigstopmultiline
\end{fulllineitems}

\index{SimParameters::output\_directory (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/struct_SimParameters:_CPPv2N13SimParameters16output_directoryE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{api/struct_SimParameters:necsimstruct_sim_parameters_1afc36bb2fbfc7ebf5e84149be5be87c1e}}string \sphinxbfcode{output\_directory}}%
\pysigstopmultiline
\end{fulllineitems}

\index{SimParameters::pristine\_fine\_map\_file (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/struct_SimParameters:_CPPv2N13SimParameters22pristine_fine_map_fileE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{api/struct_SimParameters:necsimstruct_sim_parameters_1a9977f435af14f8b9e8db4430151b3c04}}string \sphinxbfcode{pristine\_fine\_map\_file}}%
\pysigstopmultiline
\end{fulllineitems}

\index{SimParameters::pristine\_coarse\_map\_file (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/struct_SimParameters:_CPPv2N13SimParameters24pristine_coarse_map_fileE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{api/struct_SimParameters:necsimstruct_sim_parameters_1aad8b8c7b53f58ea05ef75fedafff4314}}string \sphinxbfcode{pristine\_coarse\_map\_file}}%
\pysigstopmultiline
\end{fulllineitems}

\index{SimParameters::sample\_mask\_file (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/struct_SimParameters:_CPPv2N13SimParameters16sample_mask_fileE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{api/struct_SimParameters:necsimstruct_sim_parameters_1ac5298525ed1d094d1668bc78491b0c69}}string \sphinxbfcode{sample\_mask\_file}}%
\pysigstopmultiline
\end{fulllineitems}

\index{SimParameters::the\_task (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/struct_SimParameters:_CPPv2N13SimParameters8the_taskE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{api/struct_SimParameters:necsimstruct_sim_parameters_1a219ea06b17e82f1512e0e8cdd9990ea7}}long long \sphinxbfcode{the\_task} = \{\}}%
\pysigstopmultiline
\end{fulllineitems}

\index{SimParameters::the\_seed (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/struct_SimParameters:_CPPv2N13SimParameters8the_seedE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{api/struct_SimParameters:necsimstruct_sim_parameters_1a689610f6fd7c87866ca950c8700b4943}}long long \sphinxbfcode{the\_seed} = \{\}}%
\pysigstopmultiline
\end{fulllineitems}

\index{SimParameters::grid\_x\_size (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/struct_SimParameters:_CPPv2N13SimParameters11grid_x_sizeE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{api/struct_SimParameters:necsimstruct_sim_parameters_1aba773a5ec7ad130d6009d319c7d2f591}}unsigned long \sphinxbfcode{grid\_x\_size} = \{\}}%
\pysigstopmultiline
\end{fulllineitems}

\index{SimParameters::grid\_y\_size (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/struct_SimParameters:_CPPv2N13SimParameters11grid_y_sizeE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{api/struct_SimParameters:necsimstruct_sim_parameters_1a3d52bbca2ec77eb584b2940fce8b018f}}unsigned long \sphinxbfcode{grid\_y\_size} = \{\}}%
\pysigstopmultiline
\end{fulllineitems}

\index{SimParameters::sample\_x\_size (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/struct_SimParameters:_CPPv2N13SimParameters13sample_x_sizeE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{api/struct_SimParameters:necsimstruct_sim_parameters_1ae5b4ec9858fdeb80231ad20a255402ee}}unsigned long \sphinxbfcode{sample\_x\_size} = \{\}}%
\pysigstopmultiline
\end{fulllineitems}

\index{SimParameters::sample\_y\_size (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/struct_SimParameters:_CPPv2N13SimParameters13sample_y_sizeE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{api/struct_SimParameters:necsimstruct_sim_parameters_1a81ffb850421d1e758c770fdbba39ed67}}unsigned long \sphinxbfcode{sample\_y\_size} = \{\}}%
\pysigstopmultiline
\end{fulllineitems}

\index{SimParameters::sample\_x\_offset (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/struct_SimParameters:_CPPv2N13SimParameters15sample_x_offsetE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{api/struct_SimParameters:necsimstruct_sim_parameters_1a8f303a960065679ea0d5fcb3c85f87f6}}unsigned long \sphinxbfcode{sample\_x\_offset} = \{\}}%
\pysigstopmultiline
\end{fulllineitems}

\index{SimParameters::sample\_y\_offset (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/struct_SimParameters:_CPPv2N13SimParameters15sample_y_offsetE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{api/struct_SimParameters:necsimstruct_sim_parameters_1ab6bc36c5ef40d86635116626964da79a}}unsigned long \sphinxbfcode{sample\_y\_offset} = \{\}}%
\pysigstopmultiline
\end{fulllineitems}

\index{SimParameters::fine\_map\_x\_size (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/struct_SimParameters:_CPPv2N13SimParameters15fine_map_x_sizeE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{api/struct_SimParameters:necsimstruct_sim_parameters_1aec1386c872750e502b69c3037afdba2f}}unsigned long \sphinxbfcode{fine\_map\_x\_size} = \{\}}%
\pysigstopmultiline
\end{fulllineitems}

\index{SimParameters::fine\_map\_y\_size (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/struct_SimParameters:_CPPv2N13SimParameters15fine_map_y_sizeE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{api/struct_SimParameters:necsimstruct_sim_parameters_1ad810612827e11f079e8a5c57bc4fabed}}unsigned long \sphinxbfcode{fine\_map\_y\_size} = \{\}}%
\pysigstopmultiline
\end{fulllineitems}

\index{SimParameters::fine\_map\_x\_offset (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/struct_SimParameters:_CPPv2N13SimParameters17fine_map_x_offsetE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{api/struct_SimParameters:necsimstruct_sim_parameters_1a8785eeb045175ada592cfcd929130bf5}}unsigned long \sphinxbfcode{fine\_map\_x\_offset} = \{\}}%
\pysigstopmultiline
\end{fulllineitems}

\index{SimParameters::fine\_map\_y\_offset (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/struct_SimParameters:_CPPv2N13SimParameters17fine_map_y_offsetE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{api/struct_SimParameters:necsimstruct_sim_parameters_1aa967eee87a44c6ff0f6b386bff1aacbe}}unsigned long \sphinxbfcode{fine\_map\_y\_offset} = \{\}}%
\pysigstopmultiline
\end{fulllineitems}

\index{SimParameters::coarse\_map\_x\_size (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/struct_SimParameters:_CPPv2N13SimParameters17coarse_map_x_sizeE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{api/struct_SimParameters:necsimstruct_sim_parameters_1a3381edb83995cd9885299c7df7a754e3}}unsigned long \sphinxbfcode{coarse\_map\_x\_size} = \{\}}%
\pysigstopmultiline
\end{fulllineitems}

\index{SimParameters::coarse\_map\_y\_size (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/struct_SimParameters:_CPPv2N13SimParameters17coarse_map_y_sizeE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{api/struct_SimParameters:necsimstruct_sim_parameters_1aeab1bf5577592c3bafb36b5b15a54919}}unsigned long \sphinxbfcode{coarse\_map\_y\_size} = \{\}}%
\pysigstopmultiline
\end{fulllineitems}

\index{SimParameters::coarse\_map\_x\_offset (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/struct_SimParameters:_CPPv2N13SimParameters19coarse_map_x_offsetE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{api/struct_SimParameters:necsimstruct_sim_parameters_1a3f95e2012d3708621cb0861b879b52b3}}unsigned long \sphinxbfcode{coarse\_map\_x\_offset} = \{\}}%
\pysigstopmultiline
\end{fulllineitems}

\index{SimParameters::coarse\_map\_y\_offset (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/struct_SimParameters:_CPPv2N13SimParameters19coarse_map_y_offsetE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{api/struct_SimParameters:necsimstruct_sim_parameters_1a8713a6b0664c61c70e7af783d84e373d}}unsigned long \sphinxbfcode{coarse\_map\_y\_offset} = \{\}}%
\pysigstopmultiline
\end{fulllineitems}

\index{SimParameters::coarse\_map\_scale (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/struct_SimParameters:_CPPv2N13SimParameters16coarse_map_scaleE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{api/struct_SimParameters:necsimstruct_sim_parameters_1a800d7f614c88ed8a6456e77d75456670}}unsigned long \sphinxbfcode{coarse\_map\_scale} = \{\}}%
\pysigstopmultiline
\end{fulllineitems}

\index{SimParameters::desired\_specnum (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/struct_SimParameters:_CPPv2N13SimParameters15desired_specnumE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{api/struct_SimParameters:necsimstruct_sim_parameters_1a9def538c1416f7318c4cc264cfcb3897}}unsigned long \sphinxbfcode{desired\_specnum} = \{\}}%
\pysigstopmultiline
\end{fulllineitems}

\index{SimParameters::dispersal\_relative\_cost (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/struct_SimParameters:_CPPv2N13SimParameters23dispersal_relative_costE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{api/struct_SimParameters:necsimstruct_sim_parameters_1a4d6187a8a4d767d5eb8bc4bf41f3b2fe}}double \sphinxbfcode{dispersal\_relative\_cost} = \{\}}%
\pysigstopmultiline
\end{fulllineitems}

\index{SimParameters::deme (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/struct_SimParameters:_CPPv2N13SimParameters4demeE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{api/struct_SimParameters:necsimstruct_sim_parameters_1a769999e2ea3ab2dff10ea085dda7582f}}unsigned long \sphinxbfcode{deme} = \{\}}%
\pysigstopmultiline
\end{fulllineitems}

\index{SimParameters::deme\_sample (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/struct_SimParameters:_CPPv2N13SimParameters11deme_sampleE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{api/struct_SimParameters:necsimstruct_sim_parameters_1a14db55cf335c4bf539d6ad8c029a3010}}double \sphinxbfcode{deme\_sample} = \{\}}%
\pysigstopmultiline
\end{fulllineitems}

\index{SimParameters::spec (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/struct_SimParameters:_CPPv2N13SimParameters4specE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{api/struct_SimParameters:necsimstruct_sim_parameters_1af0edb212b87212a38a68bf287316ccba}}long double \sphinxbfcode{spec} = \{\}}%
\pysigstopmultiline
\end{fulllineitems}

\index{SimParameters::sigma (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/struct_SimParameters:_CPPv2N13SimParameters5sigmaE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{api/struct_SimParameters:necsimstruct_sim_parameters_1a6292e5891ccbf9c188c45688d8d43b6b}}double \sphinxbfcode{sigma} = \{\}}%
\pysigstopmultiline
\end{fulllineitems}

\index{SimParameters::max\_time (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/struct_SimParameters:_CPPv2N13SimParameters8max_timeE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{api/struct_SimParameters:necsimstruct_sim_parameters_1a17f737b3df0bc13f924b0a9e71d062f8}}unsigned long \sphinxbfcode{max\_time} = \{\}}%
\pysigstopmultiline
\end{fulllineitems}

\index{SimParameters::gen\_since\_pristine (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/struct_SimParameters:_CPPv2N13SimParameters18gen_since_pristineE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{api/struct_SimParameters:necsimstruct_sim_parameters_1a00fc006df97967c8f80812d2d519e8f5}}double \sphinxbfcode{gen\_since\_pristine} = \{\}}%
\pysigstopmultiline
\end{fulllineitems}

\index{SimParameters::habitat\_change\_rate (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/struct_SimParameters:_CPPv2N13SimParameters19habitat_change_rateE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{api/struct_SimParameters:necsimstruct_sim_parameters_1a91166734e5a125ee5f07051bc5b3fdb2}}double \sphinxbfcode{habitat\_change\_rate} = \{\}}%
\pysigstopmultiline
\end{fulllineitems}

\index{SimParameters::tau (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/struct_SimParameters:_CPPv2N13SimParameters3tauE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{api/struct_SimParameters:necsimstruct_sim_parameters_1a2e1055f1888b9be5eef4e62a191e1cd8}}double \sphinxbfcode{tau} = \{\}}%
\pysigstopmultiline
\end{fulllineitems}

\index{SimParameters::dispersal\_method (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/struct_SimParameters:_CPPv2N13SimParameters16dispersal_methodE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{api/struct_SimParameters:necsimstruct_sim_parameters_1a6fe66a71f2ed472b63bd7c59900ce0e3}}string \sphinxbfcode{dispersal\_method}}%
\pysigstopmultiline
\end{fulllineitems}

\index{SimParameters::m\_prob (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/struct_SimParameters:_CPPv2N13SimParameters6m_probE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{api/struct_SimParameters:necsimstruct_sim_parameters_1a6352831b6cec12ebdcb06aad5fab50d6}}double \sphinxbfcode{m\_prob} = \{\}}%
\pysigstopmultiline
\end{fulllineitems}

\index{SimParameters::cutoff (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/struct_SimParameters:_CPPv2N13SimParameters6cutoffE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{api/struct_SimParameters:necsimstruct_sim_parameters_1a92d960aaf1e219077939fee652477c6f}}double \sphinxbfcode{cutoff} = \{\}}%
\pysigstopmultiline
\end{fulllineitems}

\index{SimParameters::restrict\_self (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/struct_SimParameters:_CPPv2N13SimParameters13restrict_selfE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{api/struct_SimParameters:necsimstruct_sim_parameters_1ae7a20347a2beb38b8bdfd200e1e1d11e}}bool \sphinxbfcode{restrict\_self} = \{\}}%
\pysigstopmultiline
\end{fulllineitems}

\index{SimParameters::times\_file (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/struct_SimParameters:_CPPv2N13SimParameters10times_fileE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{api/struct_SimParameters:necsimstruct_sim_parameters_1aefc1652e914bfee5e6649dc96c1409e8}}string \sphinxbfcode{times\_file}}%
\pysigstopmultiline
\end{fulllineitems}

\index{SimParameters::configs (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/struct_SimParameters:_CPPv2N13SimParameters7configsE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{api/struct_SimParameters:necsimstruct_sim_parameters_1a8fd9196201c4e49d844f8a028936926f}}{\hyperref[\detokenize{api/class_ConfigOption:_CPPv212ConfigOption}]{\sphinxcrossref{ConfigOption}}} \sphinxbfcode{configs}}%
\pysigstopmultiline
\end{fulllineitems}

\index{SimParameters::is\_pristine (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/struct_SimParameters:_CPPv2N13SimParameters11is_pristineE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{api/struct_SimParameters:necsimstruct_sim_parameters_1abbd71e2d44f7e7e6c70cba317c00b8dc}}bool \sphinxbfcode{is\_pristine} = \{\}}%
\pysigstopmultiline
\end{fulllineitems}

\index{SimParameters::uses\_spatial\_sampling (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/struct_SimParameters:_CPPv2N13SimParameters21uses_spatial_samplingE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{api/struct_SimParameters:necsimstruct_sim_parameters_1a5f05ff4f1197c72bf3151cf7f3dbfac8}}bool \sphinxbfcode{uses\_spatial\_sampling} = \{\}}%
\pysigstopmultiline
\end{fulllineitems}

\index{SimParameters::landscape\_type (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/struct_SimParameters:_CPPv2N13SimParameters14landscape_typeE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{api/struct_SimParameters:necsimstruct_sim_parameters_1a5c324616c8e08b4af3407d0a8f7b24bb}}string \sphinxbfcode{landscape\_type}}%
\pysigstopmultiline
\end{fulllineitems}

\index{SimParameters::is\_protracted (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/struct_SimParameters:_CPPv2N13SimParameters13is_protractedE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{api/struct_SimParameters:necsimstruct_sim_parameters_1a6472949dd3ecea1e089582ea8da3eac6}}bool \sphinxbfcode{is\_protracted} = \{\}}%
\pysigstopmultiline
\end{fulllineitems}

\index{SimParameters::min\_speciation\_gen (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/struct_SimParameters:_CPPv2N13SimParameters18min_speciation_genE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{api/struct_SimParameters:necsimstruct_sim_parameters_1a9356adf501b3ed9af2c30fcb525762fc}}double \sphinxbfcode{min\_speciation\_gen} = \{\}}%
\pysigstopmultiline
\end{fulllineitems}

\index{SimParameters::max\_speciation\_gen (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/struct_SimParameters:_CPPv2N13SimParameters18max_speciation_genE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{api/struct_SimParameters:necsimstruct_sim_parameters_1aa482e642b80dc339e44f79f9c0be8324}}double \sphinxbfcode{max\_speciation\_gen} = \{\}}%
\pysigstopmultiline
\end{fulllineitems}

\index{SimParameters::dispersal\_file (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/struct_SimParameters:_CPPv2N13SimParameters14dispersal_fileE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{api/struct_SimParameters:necsimstruct_sim_parameters_1aa7966dd17cfc1f04211e75f92de3bf25}}string \sphinxbfcode{dispersal\_file}}%
\pysigstopmultiline
\end{fulllineitems}

\index{SimParameters::reproduction\_file (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/struct_SimParameters:_CPPv2N13SimParameters17reproduction_fileE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{api/struct_SimParameters:necsimstruct_sim_parameters_1ade1188f6c86ee8b46091be3fb314d73d}}string \sphinxbfcode{reproduction\_file}}%
\pysigstopmultiline
\end{fulllineitems}

\paragraph{Friends}
\index{operator\textless{}\textless{} (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/struct_SimParameters:_CPPv2lsR7ostreamRK13SimParameters}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/struct_SimParameters:necsimstruct_sim_parameters_1a9a762d7dd8157c538a45194e17fed2e8}}\pysiglinewithargsret{ostream \&\sphinxbfcode{operator\textless{}\textless{}}}{ostream \&\sphinxstyleemphasis{os}, \sphinxstrong{const} {\hyperref[\detokenize{api/struct_SimParameters:_CPPv213SimParameters}]{\sphinxcrossref{SimParameters}}} \&\sphinxstyleemphasis{m}}{}%
\pysigstopmultiline
Overloading the \textless{}\textless{} operator for outputting to the output stream. 

\begin{description}
\item[{\sphinxstylestrong{Return}}] \leavevmode
os the output stream. 

\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{os}: the output stream. 

\item {} 
\sphinxcode{m}: the {\hyperref[\detokenize{api/struct_SimParameters:necsimstruct_sim_parameters}]{\sphinxcrossref{\DUrole{std,std-ref}{SimParameters}}}} object. 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{operator\textgreater{}\textgreater{} (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/struct_SimParameters:_CPPv2rsR7istreamR13SimParameters}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/struct_SimParameters:necsimstruct_sim_parameters_1a5265cab3c1560ae4133b04a3a434a892}}\pysiglinewithargsret{istream \&\sphinxbfcode{operator\textgreater{}\textgreater{}}}{istream \&\sphinxstyleemphasis{is}, {\hyperref[\detokenize{api/struct_SimParameters:_CPPv213SimParameters}]{\sphinxcrossref{SimParameters}}} \&\sphinxstyleemphasis{m}}{}%
\pysigstopmultiline
Overloading the \textgreater{}\textgreater{} operator for inputting from an input stream. 

\begin{description}
\item[{\sphinxstylestrong{Return}}] \leavevmode
is the input stream 

\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{is}: the input stream 

\item {} 
\sphinxcode{m}: the mapvars object 

\end{itemize}

\end{description}


\end{fulllineitems}


\end{fulllineitems}



\subsection{Struct SpeciesException}
\label{\detokenize{api/struct_SpeciesException::doc}}\label{\detokenize{api/struct_SpeciesException:struct-speciesexception}}\label{\detokenize{api/struct_SpeciesException:id1}}\begin{itemize}
\item {} 
Defined in {\hyperref[\detokenize{api/file_necsim_CustomExceptions.h:file-necsim-customexceptions-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File CustomExceptions.h}}}}

\end{itemize}


\subsubsection{Inheritance Relationships}
\label{\detokenize{api/struct_SpeciesException:inheritance-relationships}}

\paragraph{Base Type}
\label{\detokenize{api/struct_SpeciesException:base-type}}\begin{itemize}
\item {} 
\sphinxcode{public FatalException} ({\hyperref[\detokenize{api/struct_FatalException:struct-fatalexception}]{\sphinxcrossref{\DUrole{std,std-ref}{Struct FatalException}}}})

\end{itemize}


\subsubsection{Struct Documentation}
\label{\detokenize{api/struct_SpeciesException:struct-documentation}}\index{SpeciesException (C++ class)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/struct_SpeciesException:_CPPv216SpeciesException}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/struct_SpeciesException:necsimstruct_species_exception}}\pysigline{\sphinxstrong{struct }\sphinxcode{}\sphinxbfcode{SpeciesException}}%
\pysigstopmultiline
An exception thrown whenever a non-fatal Species exception is thrown. 

Inherits from {\hyperref[\detokenize{api/struct_FatalException:necsimstruct_fatal_exception}]{\sphinxcrossref{\DUrole{std,std-ref}{FatalException}}}}
\paragraph{Public Functions}
\index{SpeciesException::SpeciesException (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/struct_SpeciesException:_CPPv2N16SpeciesException16SpeciesExceptionEv}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/struct_SpeciesException:necsimstruct_species_exception_1aad9febae65922d3a68a3d70ddc8b6a16}}\pysiglinewithargsret{\sphinxbfcode{SpeciesException}}{}{}%
\pysigstopmultiline
Throws a runtime\_error with a custom message indicating source. 

\end{fulllineitems}

\index{SpeciesException::SpeciesException (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/struct_SpeciesException:_CPPv2N16SpeciesException16SpeciesExceptionE6string}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/struct_SpeciesException:necsimstruct_species_exception_1aee4c223dc1b702be3b937556f39b26a5}}\pysiglinewithargsret{\sphinxbfcode{SpeciesException}}{string \sphinxstyleemphasis{msg}}{}%
\pysigstopmultiline
Overloaded runtime\_error call which provides error message parsing. 

\begin{description}
\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{msg}: the message to be passed to the runtime\_error 

\end{itemize}

\end{description}


\end{fulllineitems}


\end{fulllineitems}



\subsection{Class Cell}
\label{\detokenize{api/class_Cell:class-cell}}\label{\detokenize{api/class_Cell::doc}}\label{\detokenize{api/class_Cell:id1}}\begin{itemize}
\item {} 
Defined in {\hyperref[\detokenize{api/file_necsim_SimulateDispersal.h:file-necsim-simulatedispersal-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File SimulateDispersal.h}}}}

\end{itemize}


\subsubsection{Class Documentation}
\label{\detokenize{api/class_Cell:class-documentation}}\index{Cell (C++ class)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Cell:_CPPv24Cell}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_Cell:necsimstruct_cell}}\pysigline{\sphinxstrong{class }\sphinxcode{}\sphinxbfcode{Cell}}%
\pysigstopmultiline
Simple structure containing the x and y positions of a cell. 
\paragraph{Public Functions}
\index{Cell::operator= (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Cell:_CPPv2N4CellaSER4Cell}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_Cell:necsimstruct_cell_1ac1f905d4cd626cc32963ab7a6f76634e}}\pysiglinewithargsret{{\hyperref[\detokenize{api/class_Cell:_CPPv24Cell}]{\sphinxcrossref{Cell}}} \&\sphinxbfcode{operator=}}{{\hyperref[\detokenize{api/class_Cell:_CPPv24Cell}]{\sphinxcrossref{Cell}}} \sphinxstrong{const} \&\sphinxstyleemphasis{c}}{}%
\pysigstopmultiline
Overloading equality operator. 

\begin{description}
\item[{\sphinxstylestrong{Return}}] \leavevmode
the cell with the new values 

\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{c}: the {\hyperref[\detokenize{api/class_Cell:necsimstruct_cell}]{\sphinxcrossref{\DUrole{std,std-ref}{Cell}}}} containing the values to overload 

\end{itemize}

\end{description}


\end{fulllineitems}

\paragraph{Public Members}
\index{Cell::x (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Cell:_CPPv2N4Cell1xE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{api/class_Cell:necsimstruct_cell_1a20ccaf4c7a18ce06930f961ed4fe3851}}long \sphinxbfcode{x}}%
\pysigstopmultiline
\end{fulllineitems}

\index{Cell::y (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Cell:_CPPv2N4Cell1yE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{api/class_Cell:necsimstruct_cell_1a05aaf17f035c254584190b8ada505efc}}long \sphinxbfcode{y}}%
\pysigstopmultiline
\end{fulllineitems}


\end{fulllineitems}



\subsection{Class CommunitiesArray}
\label{\detokenize{api/class_CommunitiesArray::doc}}\label{\detokenize{api/class_CommunitiesArray:class-communitiesarray}}\label{\detokenize{api/class_CommunitiesArray:id1}}\begin{itemize}
\item {} 
Defined in {\hyperref[\detokenize{api/file_necsim_Community.h:file-necsim-community-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File Community.h}}}}

\end{itemize}


\subsubsection{Class Documentation}
\label{\detokenize{api/class_CommunitiesArray:class-documentation}}\index{CommunitiesArray (C++ class)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_CommunitiesArray:_CPPv216CommunitiesArray}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_CommunitiesArray:necsimstruct_communities_array}}\pysigline{\sphinxstrong{class }\sphinxcode{}\sphinxbfcode{CommunitiesArray}}%
\pysigstopmultiline
A structure for containing an array of previous calculation information, including which fragments have been already calculated for. 
\paragraph{Public Functions}
\index{CommunitiesArray::pushBack (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_CommunitiesArray:_CPPv2N16CommunitiesArray8pushBackEmeebm}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_CommunitiesArray:necsimstruct_communities_array_1ab216cad89ebc4cf73859093060a4a20c}}\pysiglinewithargsret{void \sphinxbfcode{pushBack}}{unsigned long \sphinxstyleemphasis{reference}, long double \sphinxstyleemphasis{speciation\_rate}, long double \sphinxstyleemphasis{time}, bool \sphinxstyleemphasis{fragment}, unsigned long \sphinxstyleemphasis{metacommunity\_reference}}{}%
\pysigstopmultiline
Adds an extra {\hyperref[\detokenize{api/struct_CommunityParameters:necsimstruct_community_parameters}]{\sphinxcrossref{\DUrole{std,std-ref}{CommunityParameters}}}} object to the calc\_array vector with the supplied variables. 

\begin{description}
\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{reference}: the reference for this set of community parameters 

\item {} 
\sphinxcode{speciation\_rate}: the speciation rate of the past calculation 

\item {} 
\sphinxcode{time}: the time of the past calculation 

\item {} 
\sphinxcode{fragment}: bool of whether fragments were used in the past calculation 

\item {} 
\sphinxcode{metacommunity\_reference}: reference for the metacommunity parameters, or 0 if no metacommunity 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{CommunitiesArray::pushBack (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_CommunitiesArray:_CPPv2N16CommunitiesArray8pushBackE19CommunityParameters}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_CommunitiesArray:necsimstruct_communities_array_1a0abeec9457993dffd047a78db4e4b289}}\pysiglinewithargsret{void \sphinxbfcode{pushBack}}{{\hyperref[\detokenize{api/struct_CommunityParameters:_CPPv219CommunityParameters}]{\sphinxcrossref{CommunityParameters}}} \sphinxstyleemphasis{tmp\_param}}{}%
\pysigstopmultiline
Adds the provided {\hyperref[\detokenize{api/struct_CommunityParameters:necsimstruct_community_parameters}]{\sphinxcrossref{\DUrole{std,std-ref}{CommunityParameters}}}} object to the calc\_array vector. 

\begin{description}
\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{tmp\_param}: the set of community parameters to add 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{CommunitiesArray::addNew (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_CommunitiesArray:_CPPv2N16CommunitiesArray6addNewEeebm}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_CommunitiesArray:necsimstruct_communities_array_1adf488e4c1790eb8d850820d8014d89fa}}\pysiglinewithargsret{{\hyperref[\detokenize{api/struct_CommunityParameters:_CPPv219CommunityParameters}]{\sphinxcrossref{CommunityParameters}}} \&\sphinxbfcode{addNew}}{long double \sphinxstyleemphasis{speciation\_rate}, long double \sphinxstyleemphasis{time}, bool \sphinxstyleemphasis{fragment}, unsigned long \sphinxstyleemphasis{metacommunity\_reference}}{}%
\pysigstopmultiline
Adds a new communities calculation paremeters reference, with a new unique reference. 

\begin{description}
\item[{\sphinxstylestrong{Return}}] \leavevmode
reference to the new {\hyperref[\detokenize{api/struct_CommunityParameters:necsimstruct_community_parameters}]{\sphinxcrossref{\DUrole{std,std-ref}{CommunityParameters}}}} object added 

\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{speciation\_rate}: the speciation rate of the new calculation 

\item {} 
\sphinxcode{time}: the time used in the new calculation 

\item {} 
\sphinxcode{fragment}: true if fragments were used in the new calculation 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{CommunitiesArray::hasPair (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_CommunitiesArray:_CPPv2N16CommunitiesArray7hasPairEedbm}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_CommunitiesArray:necsimstruct_communities_array_1a53d5250849767365e4d50751c3583309}}\pysiglinewithargsret{bool \sphinxbfcode{hasPair}}{long double \sphinxstyleemphasis{speciation\_rate}, double \sphinxstyleemphasis{time}, bool \sphinxstyleemphasis{fragment}, unsigned long \sphinxstyleemphasis{metacommunity\_reference}}{}%
\pysigstopmultiline
Checks whether the calculation with the supplied variables has already been performed. 

\begin{description}
\item[{\sphinxstylestrong{Note}}] \leavevmode


\item[{\sphinxstylestrong{Return}}] \leavevmode
true if the reference exists in past community parameters 

\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{speciation\_rate}: the speciation rate to check for 

\item {} 
\sphinxcode{time}: the time to check for 

\item {} 
\sphinxcode{fragment}: bool for checking if fragments were used 

\end{itemize}

\end{description}


\end{fulllineitems}

\paragraph{Public Members}
\index{CommunitiesArray::calc\_array (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_CommunitiesArray:_CPPv2N16CommunitiesArray10calc_arrayE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{api/class_CommunitiesArray:necsimstruct_communities_array_1addd27a8197dd835e55c529294ecae398}}vector\textless{}{\hyperref[\detokenize{api/struct_CommunityParameters:_CPPv219CommunityParameters}]{\sphinxcrossref{CommunityParameters}}}\textgreater{} \sphinxbfcode{calc\_array}}%
\pysigstopmultiline
\end{fulllineitems}


\end{fulllineitems}



\subsection{Class Community}
\label{\detokenize{api/class_Community:id1}}\label{\detokenize{api/class_Community::doc}}\label{\detokenize{api/class_Community:class-community}}\begin{itemize}
\item {} 
Defined in {\hyperref[\detokenize{api/file_necsim_Community.h:file-necsim-community-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File Community.h}}}}

\end{itemize}


\subsubsection{Inheritance Relationships}
\label{\detokenize{api/class_Community:inheritance-relationships}}

\paragraph{Derived Type}
\label{\detokenize{api/class_Community:derived-type}}\begin{itemize}
\item {} 
\sphinxcode{public Metacommunity} ({\hyperref[\detokenize{api/class_Metacommunity:class-metacommunity}]{\sphinxcrossref{\DUrole{std,std-ref}{Class Metacommunity}}}})

\end{itemize}


\subsubsection{Class Documentation}
\label{\detokenize{api/class_Community:class-documentation}}\index{Community (C++ class)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Community:_CPPv29Community}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_Community:necsimclass_community}}\pysigline{\sphinxstrong{class }\sphinxcode{}\sphinxbfcode{Community}}%
\pysigstopmultiline
A class to contain the tree object lineages and reconstructing the coalescence tree. Contains functions for calculating the number of species for a given speciation rate, outputting spatial data and generating species abundance distributions. Requires a link to the SQLite database from simulation output, and produces results within the same database file. 

Subclassed by {\hyperref[\detokenize{api/class_Metacommunity:necsimclass_metacommunity}]{\sphinxcrossref{\DUrole{std,std-ref}{Metacommunity}}}}
\paragraph{Public Functions}
\index{Community::Community (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Community:_CPPv2N9Community9CommunityEP3RowI8TreeNodeE}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_Community:necsimclass_community_1a7697e887d12366a6953fe7439d978768}}\pysiglinewithargsret{\sphinxbfcode{Community}}{{\hyperref[\detokenize{api/class_Row:_CPPv23Row}]{\sphinxcrossref{Row}}}\textless{}{\hyperref[\detokenize{api/class_TreeNode:_CPPv28TreeNode}]{\sphinxcrossref{TreeNode}}}\textgreater{} *\sphinxstyleemphasis{r}}{}%
\pysigstopmultiline
Contructor for the community linking to Treenode list. 

\begin{description}
\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{r}: {\hyperref[\detokenize{api/class_Row:necsimclass_row}]{\sphinxcrossref{\DUrole{std,std-ref}{Row}}}} of {\hyperref[\detokenize{api/class_TreeNode:necsimclass_tree_node}]{\sphinxcrossref{\DUrole{std,std-ref}{TreeNode}}}} objects to link to. 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{Community::Community (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Community:_CPPv2N9Community9CommunityEv}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_Community:necsimclass_community_1a995bd6adbfb7a4aad1bc5fb74e2a8ef2}}\pysiglinewithargsret{\sphinxbfcode{Community}}{}{}%
\pysigstopmultiline
Default constructor. 

\end{fulllineitems}

\index{Community::\textasciitilde{}Community (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Community:_CPPv2N9CommunityD0Ev}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_Community:necsimclass_community_1a9ed3b94e90b38497805610de6d18df4e}}\pysiglinewithargsret{\sphinxbfcode{\textasciitilde{}Community}}{}{}%
\pysigstopmultiline
Default destructor. 

\end{fulllineitems}

\index{Community::setList (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Community:_CPPv2N9Community7setListEP3RowI8TreeNodeE}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_Community:necsimclass_community_1a710a402dffa1b85183dd7f4a5a44f988}}\pysiglinewithargsret{void \sphinxbfcode{setList}}{{\hyperref[\detokenize{api/class_Row:_CPPv23Row}]{\sphinxcrossref{Row}}}\textless{}{\hyperref[\detokenize{api/class_TreeNode:_CPPv28TreeNode}]{\sphinxcrossref{TreeNode}}}\textgreater{} *\sphinxstyleemphasis{l}}{}%
\pysigstopmultiline
Set the nodes object to the input {\hyperref[\detokenize{api/class_Row:necsimclass_row}]{\sphinxcrossref{\DUrole{std,std-ref}{Row}}}} of Treenode objects. 

\begin{description}
\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{l}: the {\hyperref[\detokenize{api/class_Row:necsimclass_row}]{\sphinxcrossref{\DUrole{std,std-ref}{Row}}}} of Treenode objects to link to. 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{Community::setDatabase (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Community:_CPPv2N9Community11setDatabaseEP7sqlite3}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_Community:necsimclass_community_1a6fe2fdb93911f403dd879ca2847e4933}}\pysiglinewithargsret{void \sphinxbfcode{setDatabase}}{sqlite3 *\sphinxstyleemphasis{dbin}}{}%
\pysigstopmultiline
Sets the database object for the sqlite functions. 

\begin{description}
\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{dbin}: the sqlite3 input database. 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{Community::hasImportedData (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Community:_CPPv2N9Community15hasImportedDataEv}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_Community:necsimclass_community_1a045f762ca30c3a20e8ef5911a4982160}}\pysiglinewithargsret{bool \sphinxbfcode{hasImportedData}}{}{}%
\pysigstopmultiline
Get the boolean of whether the data has been imported yet. 

\begin{description}
\item[{\sphinxstylestrong{Return}}] \leavevmode
true if database has been imported. 

\end{description}


\end{fulllineitems}

\index{Community::getMinimumSpeciation (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Community:_CPPv2N9Community20getMinimumSpeciationEv}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_Community:necsimclass_community_1a4e5dea65183810c3b27441736eca825a}}\pysiglinewithargsret{long double \sphinxbfcode{getMinimumSpeciation}}{}{}%
\pysigstopmultiline
Get the minimum speciation rate the simulation was originally run with. This value is read in from the SIMULATION\_PARAMETERS table in the database file. 

\begin{description}
\item[{\sphinxstylestrong{Return}}] \leavevmode
the minimum speciation rate. 

\end{description}


\end{fulllineitems}

\index{Community::importSamplemask (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Community:_CPPv2N9Community16importSamplemaskE6string}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_Community:necsimclass_community_1a01a137383e1e23f2191d63f16513a00a}}\pysiglinewithargsret{void \sphinxbfcode{importSamplemask}}{string \sphinxstyleemphasis{sSamplemask}}{}%
\pysigstopmultiline
Imports the samplemask if it hasn't already been imported. 

\begin{description}
\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{sSamplemask}: the path to the samplemask file. 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{Community::countSpecies (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Community:_CPPv2N9Community12countSpeciesEv}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_Community:necsimclass_community_1a07970398c04e7c31ceda695c2860e20f}}\pysiglinewithargsret{unsigned long \sphinxbfcode{countSpecies}}{}{}%
\pysigstopmultiline
Counts the number of species that have speciated currently on the tree. 

\begin{description}
\item[{\sphinxstylestrong{Return}}] \leavevmode
the number of species 

\end{description}


\end{fulllineitems}

\index{Community::calcSpecies (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Community:_CPPv2N9Community11calcSpeciesEv}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_Community:necsimclass_community_1a241f69d1f69e61fc53c112fd874bf3ba}}\pysiglinewithargsret{unsigned long \sphinxbfcode{calcSpecies}}{}{}%
\pysigstopmultiline
Calculate the number of species in the list for the parameters in the current\_community\_parameters object. This is the main function which reconstructs the coalescence tree. Each Treenode object will end having its existence value set correctly after a call to this function. 

\begin{description}
\item[{\sphinxstylestrong{Return}}] \leavevmode
the number of species present. 

\end{description}


\end{fulllineitems}

\index{Community::addSpecies (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Community:_CPPv2N9Community10addSpeciesERmP8TreeNodeR3setImE}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_Community:necsimclass_community_1a7a51d163ec40883125fde38e6e85e52e}}\pysiglinewithargsret{void \sphinxbfcode{addSpecies}}{unsigned long \&\sphinxstyleemphasis{species\_count}, {\hyperref[\detokenize{api/class_TreeNode:_CPPv28TreeNode}]{\sphinxcrossref{TreeNode}}} *\sphinxstyleemphasis{treenode}, set\textless{}unsigned long\textgreater{} \&\sphinxstyleemphasis{species\_list}}{}%
\pysigstopmultiline
Speciates {\hyperref[\detokenize{api/class_TreeNode:necsimclass_tree_node}]{\sphinxcrossref{\DUrole{std,std-ref}{TreeNode}}}} and updates the species count. 

For systems which are not using a metacommunity, this function will just perform basic speciation.

\begin{description}
\item[{\sphinxstylestrong{Note}}] \leavevmode
species\_list is not updated in unless the function is overridden for metacommunity application. 

\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{species\_count}: the total number of species currently in the community 

\item {} 
\sphinxcode{treenode}: pointer to the {\hyperref[\detokenize{api/class_TreeNode:necsimclass_tree_node}]{\sphinxcrossref{\DUrole{std,std-ref}{TreeNode}}}} object for this lineage 

\item {} 
\sphinxcode{species\_list}: the set of all species ids. 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{Community::calcSpeciesAbundance (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Community:_CPPv2N9Community20calcSpeciesAbundanceEv}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_Community:necsimclass_community_1a502a409a75567d78575625346b6a969f}}\pysiglinewithargsret{void \sphinxbfcode{calcSpeciesAbundance}}{}{}%
\pysigstopmultiline
Calculates the species abundance of the dataset. The species abundances will be with rOut after a call do this function. If a samplemask has been applied, only lineages which originally existed in the samplemask will be counted. 

\end{fulllineitems}

\index{Community::resetTree (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Community:_CPPv2N9Community9resetTreeEv}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_Community:necsimclass_community_1abd099aacb5332a9b89b3421e01269d24}}\pysiglinewithargsret{void \sphinxbfcode{resetTree}}{}{}%
\pysigstopmultiline
Resets the entire tree. Sets existance to false, speciation to false and removes any species ID. 

\end{fulllineitems}

\index{Community::detectDimensions (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Community:_CPPv2N9Community16detectDimensionsE6string}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_Community:necsimclass_community_1a579c5f423fc2461838a80baf6b396310}}\pysiglinewithargsret{void \sphinxbfcode{detectDimensions}}{string \sphinxstyleemphasis{db}}{}%
\pysigstopmultiline
This function detects the maximum x and y values of the sql database. This allows for the dimensions before opening the map file. 

\begin{description}
\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{db}: the path to the input database to read from. 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{Community::openSqlConnection (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Community:_CPPv2N9Community17openSqlConnectionE6string}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_Community:necsimclass_community_1a389c35f39ed73eb1e5dc1476c220c140}}\pysiglinewithargsret{void \sphinxbfcode{openSqlConnection}}{string \sphinxstyleemphasis{inputfile}}{}%
\pysigstopmultiline
Opens the connection to the sql database file Note that this imports the database to memory, so functionality should be changed for extremely large database files. 

\begin{description}
\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{inputfile}: the sql database output from a NECSim simulation. 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{Community::setInternalDatabase (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Community:_CPPv2N9Community19setInternalDatabaseEv}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_Community:necsimclass_community_1acba6b894e62ad4ecccbcf86f064ebc46}}\pysiglinewithargsret{void \sphinxbfcode{setInternalDatabase}}{}{}%
\pysigstopmultiline
Opens a connection to an in-memory database. This will eventually be written to the output file. 

\end{fulllineitems}

\index{Community::internalOption (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Community:_CPPv2N9Community14internalOptionEv}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_Community:necsimclass_community_1a527f03120e4cb211e466cab7e405ba9a}}\pysiglinewithargsret{void \sphinxbfcode{internalOption}}{}{}%
\pysigstopmultiline
Internally sets the file referencing, data import and sql connection flags to true, for allowing checks to pass from internal object creation (so no external files are needed) 

\end{fulllineitems}

\index{Community::importData (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Community:_CPPv2N9Community10importDataE6string}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_Community:necsimclass_community_1a85db7255d3a1d53509ed2800fc24de31}}\pysiglinewithargsret{void \sphinxbfcode{importData}}{string \sphinxstyleemphasis{inputfile}}{}%
\pysigstopmultiline
Imports the data from the desired SQL database object into the array. 

\begin{description}
\item[{\sphinxstylestrong{Note}}] \leavevmode
Opens the sql connection if it has not already been opened. 

\item[{\sphinxstylestrong{Note}}] \leavevmode
If nodes is not of length 0, this function does nothing. This is so that any in-memory data is not overwritten. 

\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{inputfile}: the path to the input SQLite database. 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{Community::importSimParameters (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Community:_CPPv2N9Community19importSimParametersE6string}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_Community:necsimclass_community_1a548d36e99e592f0bfc09c8315b27f8bb}}\pysiglinewithargsret{void \sphinxbfcode{importSimParameters}}{string \sphinxstyleemphasis{file}}{}%
\pysigstopmultiline
Imports the simulation parameters by reading the SIMULATION\_PARAMETERS table in the provided file. This imports the grid\_x\_size, grid\_y\_size (which should also be the sample map dimensions) and the minimum speciation rate. 

\begin{description}
\item[{\sphinxstylestrong{Note}}] \leavevmode
Opens the sql connection if it has not already been opened.

\item[{\sphinxstylestrong{Note}}] \leavevmode
If bDataImport has already been set, no operation is performed.

\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{file}: the sqlite database simulation output which will be used for coalescence tree generation. 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{Community::getMaxSpeciesAbundancesID (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Community:_CPPv2N9Community25getMaxSpeciesAbundancesIDEv}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_Community:necsimclass_community_1a8ac0ce642595283f342c2f1841f4c20f}}\pysiglinewithargsret{void \sphinxbfcode{getMaxSpeciesAbundancesID}}{}{}%
\pysigstopmultiline
Gets the maximum species abundance ID from the database and stores it in the max\_species\_id variable. 

\begin{description}
\item[{\sphinxstylestrong{Note}}] \leavevmode
Does not check for SPECIES\_ABUNDANCES existence and will throw an error if it cannot access it 

\end{description}


\end{fulllineitems}

\index{Community::getCumulativeAbundances (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Community:_CPPv2N9Community23getCumulativeAbundancesEv}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_Community:necsimclass_community_1a51d90183f6a26e7d192abfd748945f2b}}\pysiglinewithargsret{{\hyperref[\detokenize{api/class_Row:_CPPv23Row}]{\sphinxcrossref{Row}}}\textless{}unsigned long\textgreater{} *\sphinxbfcode{getCumulativeAbundances}}{}{}%
\pysigstopmultiline
Changes the rOut object so that values represent cummulative species abundances. 

Allows binary sort on rOut (much faster) and the previous rOut value can be obtained by value = rOut{[}i{]} - rOut{[}i-1{]} \begin{description}
\item[{\sphinxstylestrong{Return}}] \leavevmode
pointer to sorted {\hyperref[\detokenize{api/class_Row:necsimclass_row}]{\sphinxcrossref{\DUrole{std,std-ref}{Row}}}} of species abundances 

\end{description}


\end{fulllineitems}

\index{Community::getRowOut (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Community:_CPPv2N9Community9getRowOutEv}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_Community:necsimclass_community_1a63fd8d32af6d52d009d1fd54098e4594}}\pysiglinewithargsret{{\hyperref[\detokenize{api/class_Row:_CPPv23Row}]{\sphinxcrossref{Row}}}\textless{}unsigned long\textgreater{} \sphinxbfcode{getRowOut}}{}{}%
\pysigstopmultiline
Returns the row\_out object, which should contain species abundances or cumulative abundances. 

\begin{description}
\item[{\sphinxstylestrong{Note}}] \leavevmode
Does not recalculate species abundances, so if getCumulativeAbundances has been called, will return the cumulative species abundances instead. 

\item[{\sphinxstylestrong{Note}}] \leavevmode
Returns a copy, so could cause problems for extremely large simulations with immense numbers of species. 

\item[{\sphinxstylestrong{Return}}] \leavevmode
row\_out, the species abundances, or the cumulative abundances if getCumulativeAbundances has been called 

\end{description}


\end{fulllineitems}

\index{Community::getSpeciesNumber (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Community:_CPPv2N9Community16getSpeciesNumberEv}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_Community:necsimclass_community_1a8523432488d6586521c5994cad4215d8}}\pysiglinewithargsret{unsigned long \sphinxbfcode{getSpeciesNumber}}{}{}%
\pysigstopmultiline
Gets the number of species in the most recent calculation. 

\begin{description}
\item[{\sphinxstylestrong{Return}}] \leavevmode
the number of species in the most recent calculation 

\end{description}


\end{fulllineitems}

\index{Community::getMaxFragmentAbundancesID (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Community:_CPPv2N9Community26getMaxFragmentAbundancesIDEv}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_Community:necsimclass_community_1af6fe28e1047ed5b56fde833e4b2b30de}}\pysiglinewithargsret{void \sphinxbfcode{getMaxFragmentAbundancesID}}{}{}%
\pysigstopmultiline
Gets the maximum fragment abundance ID from the database and stores it in the max\_fragment\_id variable. 

\begin{description}
\item[{\sphinxstylestrong{Note}}] \leavevmode
Does not check for FRAGMENT\_ABUNDANCES existence and will throw an error if it cannot access it 

\end{description}


\end{fulllineitems}

\index{Community::getMaxSpeciesLocationsID (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Community:_CPPv2N9Community24getMaxSpeciesLocationsIDEv}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_Community:necsimclass_community_1a04d65ed53ea9e2cb6ce02dddccf3d33e}}\pysiglinewithargsret{void \sphinxbfcode{getMaxSpeciesLocationsID}}{}{}%
\pysigstopmultiline
Gets the maximum species locations ID from the database and stores it in the max\_locations\_id variable. 

\begin{description}
\item[{\sphinxstylestrong{Note}}] \leavevmode
Does not check for SPECIES\_LOCATIONS existence and will throw an error if it cannot access it 

\end{description}


\end{fulllineitems}

\index{Community::setProtractedParameters (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Community:_CPPv2N9Community23setProtractedParametersEd}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_Community:necsimclass_community_1aa5643c34557be54ea2674e78a1e0c53a}}\pysiglinewithargsret{void \sphinxbfcode{setProtractedParameters}}{double \sphinxstyleemphasis{max\_speciation\_gen\_in}}{}%
\pysigstopmultiline
Sets the protracted parameters for application of protracted speciation. 

\begin{description}
\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{max\_speciation\_gen}: the maximum number of generations a lineage can exist for before speciating 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{Community::setProtractedParameters (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Community:_CPPv2N9Community23setProtractedParametersERKdRKd}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_Community:necsimclass_community_1a3833e048848d21bc0292c05e86b7d5ce}}\pysiglinewithargsret{void \sphinxbfcode{setProtractedParameters}}{\sphinxstrong{const} double \&\sphinxstyleemphasis{max\_speciation\_gen\_in}, \sphinxstrong{const} double \&\sphinxstyleemphasis{mix\_speciation\_gen\_in}}{}%
\pysigstopmultiline
Sets the protracted parameters for application of protracted speciation. 

This overloaded version is for setting protracted parameters before a full simulation has been outputted (i.e. immediately after completion of the simulation).

\begin{description}
\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{max\_speciation\_gen\_in}: the maximum number of generations a lineage can exist for before speciating 

\item {} 
\sphinxcode{min\_speciation\_gen\_in}: the minimum number of generations a lineage must exist before speciating. 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{Community::overrideProtractedParameters (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Community:_CPPv2N9Community28overrideProtractedParametersERKdRKd}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_Community:necsimclass_community_1a132137f2a27a6fad21ada4c94726480a}}\pysiglinewithargsret{void \sphinxbfcode{overrideProtractedParameters}}{\sphinxstrong{const} double \&\sphinxstyleemphasis{min\_speciation\_gen\_in}, \sphinxstrong{const} double \&\sphinxstyleemphasis{max\_speciation\_gen\_in}}{}%
\pysigstopmultiline
\end{fulllineitems}

\index{Community::setProtracted (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Community:_CPPv2N9Community13setProtractedEb}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_Community:necsimclass_community_1a649afbf07398a1717ad49cb22bb744ff}}\pysiglinewithargsret{void \sphinxbfcode{setProtracted}}{bool \sphinxstyleemphasis{protracted\_in}}{}%
\pysigstopmultiline
Sets the protracted boolean to the input. 

\begin{description}
\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{protracted\_in}: the protracted boolean to set 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{Community::createDatabase (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Community:_CPPv2N9Community14createDatabaseEv}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_Community:necsimclass_community_1ad6e92dafaf00fd65cc29ca436dc61a2e}}\pysiglinewithargsret{void \sphinxbfcode{createDatabase}}{}{}%
\pysigstopmultiline
Creates a new table in the database file and outputs the database object to the same file as the input file. Calculates the community structure for the set of community parameters in current\_community\_parameters. 

The new SPECIES\_ABUNDANCES table contains the species abundance distribution for the whole samplemask. A similar tabe FRAGMENT\_ABUNDANCES is generated by {\hyperref[\detokenize{api/class_Community:necsimclass_community_1ad6515ff43ea8189a1acdcccfe893bbba}]{\sphinxcrossref{\DUrole{std,std-ref}{createFragmentDatabase()}}}} if specified via the command line parameters. 

\end{fulllineitems}

\index{Community::generateCoalescenceTree (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Community:_CPPv2N9Community23generateCoalescenceTreeEv}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_Community:necsimclass_community_1a078a9a1210d6b7e8f6f378891f7e8b86}}\pysiglinewithargsret{void \sphinxbfcode{generateCoalescenceTree}}{}{}%
\pysigstopmultiline
Calls calcSpecies and calcSpeciesAbundances to generate the coalescence tree and calculate species abundances. 

\end{fulllineitems}

\index{Community::outputSpeciesAbundances (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Community:_CPPv2N9Community23outputSpeciesAbundancesEv}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_Community:necsimclass_community_1a8cb8044c6b2e290e7933cbc78d7019be}}\pysiglinewithargsret{void \sphinxbfcode{outputSpeciesAbundances}}{}{}%
\pysigstopmultiline
Outputs the species abundances into the database. 

\end{fulllineitems}

\index{Community::checkCalculationsPerformed (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Community:_CPPv2N9Community26checkCalculationsPerformedEedbme}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_Community:necsimclass_community_1a7a1c541651f7b2326db2334233072d04}}\pysiglinewithargsret{bool \sphinxbfcode{checkCalculationsPerformed}}{long double \sphinxstyleemphasis{speciation\_rate}, double \sphinxstyleemphasis{time}, bool \sphinxstyleemphasis{fragments}, unsigned long \sphinxstyleemphasis{metacommunity\_size}, long double \sphinxstyleemphasis{metacommunity\_speciation\_rate}}{}%
\pysigstopmultiline
Checks if calculations with the given set of parameters has already been performed. 

\begin{description}
\item[{\sphinxstylestrong{Return}}] \leavevmode


\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{speciation\_rate}: the speciation rate to check for 

\item {} 
\sphinxcode{time}: the time to check for 

\item {} 
\sphinxcode{fragments}: if true, checks fragments have been used 

\item {} 
\sphinxcode{metacommunity\_size}: the metacommunity size to check for 

\item {} 
\sphinxcode{metacommunity\_speciation\_rate}: the metacommunity speciation rate to check for 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{Community::addCalculationPerformed (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Community:_CPPv2N9Community23addCalculationPerformedEedbme}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_Community:necsimclass_community_1a28f6996de89e7596da6777cc55e9861d}}\pysiglinewithargsret{void \sphinxbfcode{addCalculationPerformed}}{long double \sphinxstyleemphasis{speciation\_rate}, double \sphinxstyleemphasis{time}, bool \sphinxstyleemphasis{fragments}, unsigned long \sphinxstyleemphasis{metacommunity\_size}, long double \sphinxstyleemphasis{metacommunity\_speciation\_rate}}{}%
\pysigstopmultiline
Adds a performed calculation to the lists of calculations. Also sets the current\_community\_parameters pointer to the set of parameters to be applied. 

\begin{description}
\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{speciation\_rate}: the speciation rate of the performed calculation 

\item {} 
\sphinxcode{time}: the time of the performed calculation 

\item {} 
\sphinxcode{fragments}: if true, fragments were used 

\item {} 
\sphinxcode{metacommunity\_size}: the metacommunity size of the performed calculation 

\item {} 
\sphinxcode{metacommunity\_speciation\_rate}: the metacommunity speciation rate of the performed calculation 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{Community::createFragmentDatabase (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Community:_CPPv2N9Community22createFragmentDatabaseERK8Fragment}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_Community:necsimclass_community_1ad6515ff43ea8189a1acdcccfe893bbba}}\pysiglinewithargsret{void \sphinxbfcode{createFragmentDatabase}}{\sphinxstrong{const} {\hyperref[\detokenize{api/struct_Fragment:_CPPv28Fragment}]{\sphinxcrossref{Fragment}}} \&\sphinxstyleemphasis{f}}{}%
\pysigstopmultiline
Creates a new table in the database file and outputs the database object to the same file as the input file. Essentially creates a species abundance distribution (as in {\hyperref[\detokenize{api/class_Community:necsimclass_community_1ad6e92dafaf00fd65cc29ca436dc61a2e}]{\sphinxcrossref{\DUrole{std,std-ref}{createDatabase()}}}}), but for the specified fragment within the samplemask. 

\begin{description}
\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{f}: the {\hyperref[\detokenize{api/struct_Fragment:necsimstruct_fragment}]{\sphinxcrossref{\DUrole{std,std-ref}{Fragment}}}} to sample from. 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{Community::exportDatabase (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Community:_CPPv2N9Community14exportDatabaseEv}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_Community:necsimclass_community_1a280850bd6077692755cc419028aa5d67}}\pysiglinewithargsret{void \sphinxbfcode{exportDatabase}}{}{}%
\pysigstopmultiline
Output the database from memory to the database file. Most of the time, it is desirable for the outputfile to be the same path as the input file and will write to the same object. 

\begin{description}
\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{outputfile}: the path to the output file. 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{Community::checkSpeciesLocationsReference (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Community:_CPPv2N9Community30checkSpeciesLocationsReferenceEv}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_Community:necsimclass_community_1a23b9398df3a63c75d01e3ed3982432c2}}\pysiglinewithargsret{bool \sphinxbfcode{checkSpeciesLocationsReference}}{}{}%
\pysigstopmultiline
Checks for the current {\hyperref[\detokenize{api/struct_CommunityParameters:necsimstruct_community_parameters}]{\sphinxcrossref{\DUrole{std,std-ref}{CommunityParameters}}}} reference in the SPECIES\_LOCATIONS table. 

\begin{description}
\item[{\sphinxstylestrong{Return}}] \leavevmode
true if the reference exists in the SPECIES\_LOCATIONS table 

\end{description}


\end{fulllineitems}

\index{Community::checkSpeciesAbundancesReference (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Community:_CPPv2N9Community31checkSpeciesAbundancesReferenceEv}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_Community:necsimclass_community_1a5b2236c98b613c0ec96998bd932101f5}}\pysiglinewithargsret{bool \sphinxbfcode{checkSpeciesAbundancesReference}}{}{}%
\pysigstopmultiline
Checks for the current {\hyperref[\detokenize{api/struct_CommunityParameters:necsimstruct_community_parameters}]{\sphinxcrossref{\DUrole{std,std-ref}{CommunityParameters}}}} reference in the SPECIES\_ABUNDANCES table. 

\begin{description}
\item[{\sphinxstylestrong{Return}}] \leavevmode
return true if the reference exists in the SPECIES\_LOCATIONS table 

\end{description}


\end{fulllineitems}

\index{Community::recordSpatial (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Community:_CPPv2N9Community13recordSpatialEv}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_Community:necsimclass_community_1a08be240fddc6ea481014567276a84dd0}}\pysiglinewithargsret{void \sphinxbfcode{recordSpatial}}{}{}%
\pysigstopmultiline
Record the full spatial data. Creates a new table, SPECIES\_LOCATIONS containing every species and their parameters. This allows for more in-depth analysis to be performed if necessary. 

\end{fulllineitems}

\index{Community::calcFragments (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Community:_CPPv2N9Community13calcFragmentsE6string}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_Community:necsimclass_community_1ac9433a0c34911ec1128b5459f61488fc}}\pysiglinewithargsret{void \sphinxbfcode{calcFragments}}{string \sphinxstyleemphasis{fragment\_file}}{}%
\pysigstopmultiline
Calculates the limits of each fragment in the sample map and adds it to the vector of fragments. If the fragment\_file is null, then the program will attempt to calculate fragments from the map. 

\begin{description}
\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{fragment\_file}: the fragment file to read from. 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{Community::applyFragments (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Community:_CPPv2N9Community14applyFragmentsEv}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_Community:necsimclass_community_1a706aba5b07c98849cb2b4b0318488f99}}\pysiglinewithargsret{void \sphinxbfcode{applyFragments}}{}{}%
\pysigstopmultiline
Calculate species abundances for each fragment, and call {\hyperref[\detokenize{api/class_Community:necsimclass_community_1ad6515ff43ea8189a1acdcccfe893bbba}]{\sphinxcrossref{\DUrole{std,std-ref}{createFragmentDatabase()}}}} for each {\hyperref[\detokenize{api/struct_Fragment:necsimstruct_fragment}]{\sphinxcrossref{\DUrole{std,std-ref}{Fragment}}}}. 

\end{fulllineitems}

\index{Community::getPreviousCalcs (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Community:_CPPv2N9Community16getPreviousCalcsEv}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_Community:necsimclass_community_1a24c425f32b1e3b10227e2d04cbacfe31}}\pysiglinewithargsret{void \sphinxbfcode{getPreviousCalcs}}{}{}%
\pysigstopmultiline
Gets the previous calculations that have already been performed. 

\end{fulllineitems}

\index{Community::getUniqueCommunityRefs (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Community:_CPPv2N9Community22getUniqueCommunityRefsEv}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_Community:necsimclass_community_1aed61108d8c4fd42d39a9112c5062cad4}}\pysiglinewithargsret{vector\textless{}unsigned long\textgreater{} \sphinxbfcode{getUniqueCommunityRefs}}{}{}%
\pysigstopmultiline
Gets the unique community references from the SQL database. 

\begin{description}
\item[{\sphinxstylestrong{Return}}] \leavevmode
a vector containing the unique references 

\end{description}


\end{fulllineitems}

\index{Community::getUniqueMetacommunityRefs (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Community:_CPPv2N9Community26getUniqueMetacommunityRefsEv}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_Community:necsimclass_community_1a257e8e3dce33b235985ed9d167817a89}}\pysiglinewithargsret{vector\textless{}unsigned long\textgreater{} \sphinxbfcode{getUniqueMetacommunityRefs}}{}{}%
\pysigstopmultiline
Gets the unique metacommunity reference from the SQL database. 

\begin{description}
\item[{\sphinxstylestrong{Return}}] \leavevmode
a vector containing the unique references 

\end{description}


\end{fulllineitems}

\index{Community::writeNewCommunityParameters (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Community:_CPPv2N9Community27writeNewCommunityParametersEv}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_Community:necsimclass_community_1afbc8709084a00a7450e3a168cb016db9}}\pysiglinewithargsret{void \sphinxbfcode{writeNewCommunityParameters}}{}{}%
\pysigstopmultiline
Write all performed calculations to the output database. 

\end{fulllineitems}

\index{Community::writeNewMetacommuntyParameters (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Community:_CPPv2N9Community30writeNewMetacommuntyParametersEv}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_Community:necsimclass_community_1ac900c23ffe2572504fca11f20b7ba8cd}}\pysiglinewithargsret{void \sphinxbfcode{writeNewMetacommuntyParameters}}{}{}%
\pysigstopmultiline
Write all performed calculations to the output database. 

\end{fulllineitems}

\index{Community::updateCommunityParameters (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Community:_CPPv2N9Community25updateCommunityParametersEv}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_Community:necsimclass_community_1af3f5939bfb59fdf3b7d7b5f3699bd225}}\pysiglinewithargsret{void \sphinxbfcode{updateCommunityParameters}}{}{}%
\pysigstopmultiline
Updates the fragments tag on those simulations which now have had fragments added. 

\end{fulllineitems}

\index{Community::writeSpeciationRates (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Community:_CPPv2N9Community20writeSpeciationRatesEv}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_Community:necsimclass_community_1adcfc04e92cbb597682dcc1f2913d6668}}\pysiglinewithargsret{void \sphinxbfcode{writeSpeciationRates}}{}{}%
\pysigstopmultiline
Prints speciation rates to terminal. 

\end{fulllineitems}

\index{Community::calculateTree (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Community:_CPPv2N9Community13calculateTreeEv}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_Community:necsimclass_community_1adfa9a1c84bb326092805614ad195fcdd}}\pysiglinewithargsret{void \sphinxbfcode{calculateTree}}{}{}%
\pysigstopmultiline
Calculates the coalescence tree for each set of parameters in speciation\_parameters;. 

\end{fulllineitems}

\index{Community::output (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Community:_CPPv2N9Community6outputEv}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_Community:necsimclass_community_1ad2483623c7ad7a11564fc49305204585}}\pysiglinewithargsret{void \sphinxbfcode{output}}{}{}%
\pysigstopmultiline
Outputs the data to the SQL database. 

\begin{description}
\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{file\_name}: the path to the sql database to output to 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{Community::printEndTimes (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Community:_CPPv2N9Community13printEndTimesE6time_t6time_t}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_Community:necsimclass_community_1a36216913433e3e011ee2420e83e1fe4a}}\pysiglinewithargsret{void \sphinxbfcode{printEndTimes}}{time\_t \sphinxstyleemphasis{tStart}, time\_t \sphinxstyleemphasis{tEnd}}{}%
\pysigstopmultiline
Prints the application times. 

\begin{description}
\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{tStart}: the start time 

\item {} 
\sphinxcode{tEnd}: the end time 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{Community::apply (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Community:_CPPv2N9Community5applyEP17SpecSimParameters}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_Community:necsimclass_community_1ac1dee14af27a0add712e257e316cadbf}}\pysiglinewithargsret{void \sphinxbfcode{apply}}{{\hyperref[\detokenize{api/class_SpecSimParameters:_CPPv217SpecSimParameters}]{\sphinxcrossref{SpecSimParameters}}} *\sphinxstyleemphasis{sp}}{}%
\pysigstopmultiline
Apply the given speciation parameters to the coalescence tree. Overridden for metacommunity application. 

\begin{description}
\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{sp}: speciation parameters to apply, including speciation rate, times and spatial sampling procedure 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{Community::doApplication (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Community:_CPPv2N9Community13doApplicationEP17SpecSimParameters}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_Community:necsimclass_community_1a8ce443a30731d2249852d2b615f4a29a}}\pysiglinewithargsret{void \sphinxbfcode{doApplication}}{{\hyperref[\detokenize{api/class_SpecSimParameters:_CPPv217SpecSimParameters}]{\sphinxcrossref{SpecSimParameters}}} *\sphinxstyleemphasis{sp}}{}%
\pysigstopmultiline
Creates the coalescence tree for the given speciation parameters. 

\begin{description}
\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{sp}: speciation parameters to apply, including speciation rate, times and spatial sampling procedure 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{Community::doApplication (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Community:_CPPv2N9Community13doApplicationEP17SpecSimParametersP3RowI8TreeNodeE}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_Community:necsimclass_community_1a7289dd39ee9b69ca314e1752a7b45701}}\pysiglinewithargsret{void \sphinxbfcode{doApplication}}{{\hyperref[\detokenize{api/class_SpecSimParameters:_CPPv217SpecSimParameters}]{\sphinxcrossref{SpecSimParameters}}} *\sphinxstyleemphasis{sp}, {\hyperref[\detokenize{api/class_Row:_CPPv23Row}]{\sphinxcrossref{Row}}}\textless{}{\hyperref[\detokenize{api/class_TreeNode:_CPPv28TreeNode}]{\sphinxcrossref{TreeNode}}}\textgreater{} *\sphinxstyleemphasis{data}}{}%
\pysigstopmultiline
Creates the coalescence tree for the given speciation parameters. 

\begin{description}
\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{sp}: speciation parameters to apply, including speciation rate, times and spatial sampling procedure 

\item {} 
\sphinxcode{data}: the {\hyperref[\detokenize{api/class_Row:necsimclass_row}]{\sphinxcrossref{\DUrole{std,std-ref}{Row}}}} of TreeNodes that contains the coalescence tree. 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{Community::doApplicationInternal (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Community:_CPPv2N9Community21doApplicationInternalEP17SpecSimParametersP3RowI8TreeNodeE}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_Community:necsimclass_community_1aee7488d02cccb897ed1d561e242391df}}\pysiglinewithargsret{void \sphinxbfcode{doApplicationInternal}}{{\hyperref[\detokenize{api/class_SpecSimParameters:_CPPv217SpecSimParameters}]{\sphinxcrossref{SpecSimParameters}}} *\sphinxstyleemphasis{sp}, {\hyperref[\detokenize{api/class_Row:_CPPv23Row}]{\sphinxcrossref{Row}}}\textless{}{\hyperref[\detokenize{api/class_TreeNode:_CPPv28TreeNode}]{\sphinxcrossref{TreeNode}}}\textgreater{} *\sphinxstyleemphasis{data}}{}%
\pysigstopmultiline
Creates the coalescence tree for the given speciation parameters, using internal file referencing to avoid any actual file creation. 

\begin{description}
\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{sp}: speciation parameters to apply, including speciation rate, times and spatial sampling procedure 

\item {} 
\sphinxcode{data}: the {\hyperref[\detokenize{api/class_Row:necsimclass_row}]{\sphinxcrossref{\DUrole{std,std-ref}{Row}}}} of TreeNodes that contains the coalescence tree. 

\end{itemize}

\end{description}


\end{fulllineitems}

\paragraph{Protected Attributes}
\index{Community::bMem (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Community:_CPPv2N9Community4bMemE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{api/class_Community:necsimclass_community_1ad5344789223153c3756dbad28948410b}}bool \sphinxbfcode{bMem}}%
\pysigstopmultiline
\end{fulllineitems}

\index{Community::bFileSet (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Community:_CPPv2N9Community8bFileSetE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{api/class_Community:necsimclass_community_1a82d7b635a6d81a0036238d02c5833e6d}}bool \sphinxbfcode{bFileSet}}%
\pysigstopmultiline
\end{fulllineitems}

\index{Community::database (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Community:_CPPv2N9Community8databaseE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{api/class_Community:necsimclass_community_1a382c0e6e90ca8055d3192bfe2af4d741}}sqlite3 *\sphinxbfcode{database}}%
\pysigstopmultiline
\end{fulllineitems}

\index{Community::outdatabase (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Community:_CPPv2N9Community11outdatabaseE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{api/class_Community:necsimclass_community_1a884634e98e0aacb082968664acd5a32e}}sqlite3 *\sphinxbfcode{outdatabase}}%
\pysigstopmultiline
\end{fulllineitems}

\index{Community::bSqlConnection (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Community:_CPPv2N9Community14bSqlConnectionE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{api/class_Community:necsimclass_community_1aa9fe335ff9e94c626d1e0d41ff145524}}bool \sphinxbfcode{bSqlConnection}}%
\pysigstopmultiline
\end{fulllineitems}

\index{Community::nodes (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Community:_CPPv2N9Community5nodesE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{api/class_Community:necsimclass_community_1aa1309616989642b98c15e6e2ed25b379}}{\hyperref[\detokenize{api/class_Row:_CPPv23Row}]{\sphinxcrossref{Row}}}\textless{}{\hyperref[\detokenize{api/class_TreeNode:_CPPv28TreeNode}]{\sphinxcrossref{TreeNode}}}\textgreater{} *\sphinxbfcode{nodes}}%
\pysigstopmultiline
\end{fulllineitems}

\index{Community::row\_out (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Community:_CPPv2N9Community7row_outE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{api/class_Community:necsimclass_community_1a06e5a133792f29fa17a1b0664d650541}}{\hyperref[\detokenize{api/class_Row:_CPPv23Row}]{\sphinxcrossref{Row}}}\textless{}unsigned long\textgreater{} \sphinxbfcode{row\_out}}%
\pysigstopmultiline
\end{fulllineitems}

\index{Community::iSpecies (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Community:_CPPv2N9Community8iSpeciesE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{api/class_Community:necsimclass_community_1a094f10ce5bbbcab19bccda352f545aad}}unsigned long \sphinxbfcode{iSpecies}}%
\pysigstopmultiline
\end{fulllineitems}

\index{Community::bSample (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Community:_CPPv2N9Community7bSampleE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{api/class_Community:necsimclass_community_1a40b8a468ecba59b2cb2c04750208495f}}bool \sphinxbfcode{bSample}}%
\pysigstopmultiline
\end{fulllineitems}

\index{Community::bDataImport (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Community:_CPPv2N9Community11bDataImportE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{api/class_Community:necsimclass_community_1ab6496c803e44395f4490f6301fc15a13}}bool \sphinxbfcode{bDataImport}}%
\pysigstopmultiline
\end{fulllineitems}

\index{Community::samplemask (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Community:_CPPv2N9Community10samplemaskE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{api/class_Community:necsimclass_community_1ac7434119a77086e3b38a4a94c8fbff01}}{\hyperref[\detokenize{api/class_Samplematrix:_CPPv212Samplematrix}]{\sphinxcrossref{Samplematrix}}} \sphinxbfcode{samplemask}}%
\pysigstopmultiline
\end{fulllineitems}

\index{Community::fragments (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Community:_CPPv2N9Community9fragmentsE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{api/class_Community:necsimclass_community_1a8a17909b92a0cec3b63cec41e92796cb}}vector\textless{}{\hyperref[\detokenize{api/struct_Fragment:_CPPv28Fragment}]{\sphinxcrossref{Fragment}}}\textgreater{} \sphinxbfcode{fragments}}%
\pysigstopmultiline
\end{fulllineitems}

\index{Community::current\_community\_parameters (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Community:_CPPv2N9Community28current_community_parametersE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{api/class_Community:necsimclass_community_1a77e925f82bee5441d8ec45406066dcfb}}{\hyperref[\detokenize{api/struct_CommunityParameters:_CPPv219CommunityParameters}]{\sphinxcrossref{CommunityParameters}}} *\sphinxbfcode{current\_community\_parameters}}%
\pysigstopmultiline
\end{fulllineitems}

\index{Community::min\_spec\_rate (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Community:_CPPv2N9Community13min_spec_rateE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{api/class_Community:necsimclass_community_1a9dc6f7d4ab75b382be85c2b74edac6b7}}long double \sphinxbfcode{min\_spec\_rate}}%
\pysigstopmultiline
\end{fulllineitems}

\index{Community::grid\_x\_size (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Community:_CPPv2N9Community11grid_x_sizeE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{api/class_Community:necsimclass_community_1a383dba82c8c76bf5c130c2bf4ac057e5}}unsigned long \sphinxbfcode{grid\_x\_size}}%
\pysigstopmultiline
\end{fulllineitems}

\index{Community::grid\_y\_size (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Community:_CPPv2N9Community11grid_y_sizeE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{api/class_Community:necsimclass_community_1a308d12fa4ef95015860d4181b075c93f}}unsigned long \sphinxbfcode{grid\_y\_size}}%
\pysigstopmultiline
\end{fulllineitems}

\index{Community::samplemask\_x\_size (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Community:_CPPv2N9Community17samplemask_x_sizeE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{api/class_Community:necsimclass_community_1a960bb6bb58eaec017d36d16cb3a3bc8a}}unsigned long \sphinxbfcode{samplemask\_x\_size}}%
\pysigstopmultiline
\end{fulllineitems}

\index{Community::samplemask\_y\_size (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Community:_CPPv2N9Community17samplemask_y_sizeE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{api/class_Community:necsimclass_community_1a10722b2fe8855460946f04f0ae69fd74}}unsigned long \sphinxbfcode{samplemask\_y\_size}}%
\pysigstopmultiline
\end{fulllineitems}

\index{Community::samplemask\_x\_offset (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Community:_CPPv2N9Community19samplemask_x_offsetE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{api/class_Community:necsimclass_community_1ac4985481c86bd62a50fa946699867216}}unsigned long \sphinxbfcode{samplemask\_x\_offset}}%
\pysigstopmultiline
\end{fulllineitems}

\index{Community::samplemask\_y\_offset (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Community:_CPPv2N9Community19samplemask_y_offsetE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{api/class_Community:necsimclass_community_1aeaebe975a46d62b70380e50ff7ebd09a}}unsigned long \sphinxbfcode{samplemask\_y\_offset}}%
\pysigstopmultiline
\end{fulllineitems}

\index{Community::past\_communities (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Community:_CPPv2N9Community16past_communitiesE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{api/class_Community:necsimclass_community_1a0726a962287af565658aaa8f9d9ea6c1}}{\hyperref[\detokenize{api/class_CommunitiesArray:_CPPv216CommunitiesArray}]{\sphinxcrossref{CommunitiesArray}}} \sphinxbfcode{past\_communities}}%
\pysigstopmultiline
\end{fulllineitems}

\index{Community::past\_metacommunities (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Community:_CPPv2N9Community20past_metacommunitiesE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{api/class_Community:necsimclass_community_1ae00d8d9f52d163b040cc716955569ad3}}{\hyperref[\detokenize{api/struct_MetacommunitiesArray:_CPPv220MetacommunitiesArray}]{\sphinxcrossref{MetacommunitiesArray}}} \sphinxbfcode{past\_metacommunities}}%
\pysigstopmultiline
\end{fulllineitems}

\index{Community::protracted (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Community:_CPPv2N9Community10protractedE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{api/class_Community:necsimclass_community_1acab5a676e365934f9dfd2148ab9d5a60}}bool \sphinxbfcode{protracted}}%
\pysigstopmultiline
\end{fulllineitems}

\index{Community::min\_speciation\_gen (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Community:_CPPv2N9Community18min_speciation_genE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{api/class_Community:necsimclass_community_1a6b906ec2096b22631b60aa3511925fe0}}double \sphinxbfcode{min\_speciation\_gen}}%
\pysigstopmultiline
\end{fulllineitems}

\index{Community::max\_speciation\_gen (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Community:_CPPv2N9Community18max_speciation_genE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{api/class_Community:necsimclass_community_1aeff6623b51fdd177e87b6eebfba27080}}double \sphinxbfcode{max\_speciation\_gen}}%
\pysigstopmultiline
\end{fulllineitems}

\index{Community::applied\_min\_speciation\_gen (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Community:_CPPv2N9Community26applied_min_speciation_genE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{api/class_Community:necsimclass_community_1aa5e9946a354a46d675e015d803cc7fa1}}double \sphinxbfcode{applied\_min\_speciation\_gen}}%
\pysigstopmultiline
\end{fulllineitems}

\index{Community::applied\_max\_speciation\_gen (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Community:_CPPv2N9Community26applied_max_speciation_genE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{api/class_Community:necsimclass_community_1a77d20815b5638387ce186130657ec660}}double \sphinxbfcode{applied\_max\_speciation\_gen}}%
\pysigstopmultiline
\end{fulllineitems}

\index{Community::max\_species\_id (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Community:_CPPv2N9Community14max_species_idE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{api/class_Community:necsimclass_community_1a31f80e452a92aabdf2d9ba7bcc798f84}}unsigned long \sphinxbfcode{max\_species\_id}}%
\pysigstopmultiline
\end{fulllineitems}

\index{Community::max\_fragment\_id (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Community:_CPPv2N9Community15max_fragment_idE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{api/class_Community:necsimclass_community_1a5de3afc536570241b82489d1b9c87d03}}unsigned long \sphinxbfcode{max\_fragment\_id}}%
\pysigstopmultiline
\end{fulllineitems}

\index{Community::max\_locations\_id (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Community:_CPPv2N9Community16max_locations_idE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{api/class_Community:necsimclass_community_1ae503af91bc33ed302a363098a3b49a61}}unsigned long \sphinxbfcode{max\_locations\_id}}%
\pysigstopmultiline
\end{fulllineitems}

\index{Community::spec\_sim\_parameters (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Community:_CPPv2N9Community19spec_sim_parametersE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{api/class_Community:necsimclass_community_1a45df8aefb9914e7c8f3133143069ca35}}{\hyperref[\detokenize{api/class_SpecSimParameters:_CPPv217SpecSimParameters}]{\sphinxcrossref{SpecSimParameters}}} *\sphinxbfcode{spec\_sim\_parameters}}%
\pysigstopmultiline
\end{fulllineitems}


\end{fulllineitems}



\subsection{Class ConfigOption}
\label{\detokenize{api/class_ConfigOption::doc}}\label{\detokenize{api/class_ConfigOption:class-configoption}}\label{\detokenize{api/class_ConfigOption:id1}}\begin{itemize}
\item {} 
Defined in {\hyperref[\detokenize{api/file_necsim_ConfigFileParser.h:file-necsim-configfileparser-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File ConfigFileParser.h}}}}

\end{itemize}


\subsubsection{Class Documentation}
\label{\detokenize{api/class_ConfigOption:class-documentation}}\index{ConfigOption (C++ class)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_ConfigOption:_CPPv212ConfigOption}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_ConfigOption:necsimclass_config_option}}\pysigline{\sphinxstrong{class }\sphinxcode{}\sphinxbfcode{ConfigOption}}%
\pysigstopmultiline
Config option class to store and import options from a file. 
\paragraph{Public Functions}
\index{ConfigOption::ConfigOption (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_ConfigOption:_CPPv2N12ConfigOption12ConfigOptionEv}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_ConfigOption:necsimclass_config_option_1ac0639cf9fc6660b1436ebc9e7af52525}}\pysiglinewithargsret{\sphinxbfcode{ConfigOption}}{}{}%
\pysigstopmultiline
default construtor for {\hyperref[\detokenize{api/class_ConfigOption:necsimclass_config_option}]{\sphinxcrossref{\DUrole{std,std-ref}{ConfigOption}}}} 

\end{fulllineitems}

\index{ConfigOption::setConfig (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_ConfigOption:_CPPv2N12ConfigOption9setConfigERK6stringbb}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_ConfigOption:necsimclass_config_option_1ac1ae69813100e755359b25b11dfeb8c7}}\pysiglinewithargsret{void \sphinxbfcode{setConfig}}{\sphinxstrong{const} string \&\sphinxstyleemphasis{file}, bool \sphinxstyleemphasis{main}, bool \sphinxstyleemphasis{full\_parse} = false}{}%
\pysigstopmultiline
Sets the config file the specified string. A boolean is also provided, set equal to true if this is the main command line import. This causes the deletion of the first few command line options after import. 

\begin{description}
\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{file}: the target config file (in .txt format). 

\item {} 
\sphinxcode{main}: boolean of if this is the main command line import. 

\item {} 
\sphinxcode{full\_parse}: sets bFullParse to provided value 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{ConfigOption::parseConfig (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_ConfigOption:_CPPv2N12ConfigOption11parseConfigEv}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_ConfigOption:necsimclass_config_option_1a45cdefa1516c378e5a90803d594ccd34}}\pysiglinewithargsret{void \sphinxbfcode{parseConfig}}{}{}%
\pysigstopmultiline
Reads a config file of a specific configuration. Each line must be a set of values related to the object determined by ref='object'. Each key must have the form key=value, which will be read as a string into a KeyOption structure. 

\end{fulllineitems}

\index{ConfigOption::getSectionOptions (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_ConfigOption:_CPPv2N12ConfigOption17getSectionOptionsEv}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_ConfigOption:necsimclass_config_option_1a7d9570023d8c96962f90784283b68859}}\pysiglinewithargsret{vector\textless{}{\hyperref[\detokenize{api/struct_SectionOption:_CPPv213SectionOption}]{\sphinxcrossref{SectionOption}}}\textgreater{} \sphinxbfcode{getSectionOptions}}{}{}%
\pysigstopmultiline
Returns the vector of key options imported from the file. 

\begin{description}
\item[{\sphinxstylestrong{Return}}] \leavevmode
vector of key options 

\end{description}


\end{fulllineitems}

\index{ConfigOption::setSectionOption (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_ConfigOption:_CPPv2N12ConfigOption16setSectionOptionE6string6string6string}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_ConfigOption:necsimclass_config_option_1ac824f16f50a77fcc5c11d5ac3fb244cc}}\pysiglinewithargsret{void \sphinxbfcode{setSectionOption}}{string \sphinxstyleemphasis{section}, string \sphinxstyleemphasis{reference}, string \sphinxstyleemphasis{value}}{}%
\pysigstopmultiline
Sets the section option with the provided section, key and value. 

\begin{description}
\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{section}: the section name 

\item {} 
\sphinxcode{reference}: the reference key for the parameter 

\item {} 
\sphinxcode{value}: the value of the key 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{ConfigOption::operator{[}{]} (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_ConfigOption:_CPPv2N12ConfigOptionixEi}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_ConfigOption:necsimclass_config_option_1a66d2199cf3bd4fa015ef38e34fe02bd1}}\pysiglinewithargsret{{\hyperref[\detokenize{api/struct_SectionOption:_CPPv213SectionOption}]{\sphinxcrossref{SectionOption}}} \sphinxbfcode{operator{[}{]}}}{int \sphinxstyleemphasis{index}}{}%
\pysigstopmultiline
Gets the {\hyperref[\detokenize{api/struct_SectionOption:necsimstruct_section_option}]{\sphinxcrossref{\DUrole{std,std-ref}{SectionOption}}}} at the provided index. 

\begin{description}
\item[{\sphinxstylestrong{Return}}] \leavevmode
the section option at the index 

\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{index}: the index of the {\hyperref[\detokenize{api/struct_SectionOption:necsimstruct_section_option}]{\sphinxcrossref{\DUrole{std,std-ref}{SectionOption}}}} to obtain, must be less than configs.size() 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{ConfigOption::getSectionOptionsSize (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_ConfigOption:_CPPv2N12ConfigOption21getSectionOptionsSizeEv}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_ConfigOption:necsimclass_config_option_1acb7b9141efc8d0e50e21ff1adce8e9cb}}\pysiglinewithargsret{unsigned int \sphinxbfcode{getSectionOptionsSize}}{}{}%
\pysigstopmultiline
Gets the size of the key options vector. 

\begin{description}
\item[{\sphinxstylestrong{Return}}] \leavevmode
the size of the configuration vector. 

\end{description}


\end{fulllineitems}

\index{ConfigOption::getSections (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_ConfigOption:_CPPv2N12ConfigOption11getSectionsEv}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_ConfigOption:necsimclass_config_option_1a025402f31cd098e827dee09d08736398}}\pysiglinewithargsret{vector\textless{}string\textgreater{} \sphinxbfcode{getSections}}{}{}%
\pysigstopmultiline
Gets the sections contained in the SectionOptions object. 

\begin{description}
\item[{\sphinxstylestrong{Return}}] \leavevmode
A vector of the section names. 

\end{description}


\end{fulllineitems}

\index{ConfigOption::hasSection (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_ConfigOption:_CPPv2N12ConfigOption10hasSectionERK6string}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_ConfigOption:necsimclass_config_option_1a3a99578bbd121d5494340388f8a3498c}}\pysiglinewithargsret{bool \sphinxbfcode{hasSection}}{\sphinxstrong{const} string \&\sphinxstyleemphasis{sec}}{}%
\pysigstopmultiline
Checks whether the config option has the specified section. 

\begin{description}
\item[{\sphinxstylestrong{Return}}] \leavevmode
true if the section has been found 

\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{sec}: the section name to check for 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{ConfigOption::getSectionValues (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_ConfigOption:_CPPv2N12ConfigOption16getSectionValuesE6string}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_ConfigOption:necsimclass_config_option_1a1cd1b4a0e620ba32a4e8864346357dcd}}\pysiglinewithargsret{vector\textless{}string\textgreater{} \sphinxbfcode{getSectionValues}}{string \sphinxstyleemphasis{sec}}{}%
\pysigstopmultiline
Gets all values within a section. 

Throws a Config\_Exception if the section is not found. \begin{description}
\item[{\sphinxstylestrong{Return}}] \leavevmode
a vector of the section's values. 

\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{sec}: the section to find values for 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{ConfigOption::getSectionOptions (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_ConfigOption:_CPPv2N12ConfigOption17getSectionOptionsE6string6string}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_ConfigOption:necsimclass_config_option_1a36917196846e64db6634730fa9b2b3f3}}\pysiglinewithargsret{string \sphinxbfcode{getSectionOptions}}{string \sphinxstyleemphasis{section}, string \sphinxstyleemphasis{ref}}{}%
\pysigstopmultiline
Returns a specific value for a particular key options and reference. 

\begin{description}
\item[{\sphinxstylestrong{Return}}] \leavevmode
the string at the correct place in KeyOptions.val 

\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{section}: the section to match 

\item {} 
\sphinxcode{ref}: the reference to match 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{ConfigOption::getSectionOptions (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_ConfigOption:_CPPv2N12ConfigOption17getSectionOptionsE6string6string6string}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_ConfigOption:necsimclass_config_option_1a9f4884f12f74d865a3370c2f24ffcc67}}\pysiglinewithargsret{string \sphinxbfcode{getSectionOptions}}{string \sphinxstyleemphasis{section}, string \sphinxstyleemphasis{ref}, string \sphinxstyleemphasis{def}}{}%
\pysigstopmultiline
Returns a specific value for a particular key options and reference. This overloaded version of the function returns the default value def when no match is found. 

\begin{description}
\item[{\sphinxstylestrong{Return}}] \leavevmode
the string at the correct place in KeyOptions.val 

\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{section}: the section to match 

\item {} 
\sphinxcode{ref}: the reference to match 

\item {} 
\sphinxcode{def}: the default value to return if no match is found 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{ConfigOption::importConfig (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_ConfigOption:_CPPv2N12ConfigOption12importConfigER6vectorI6stringE}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_ConfigOption:necsimclass_config_option_1afbd1ed9d006c8ff48d90e63a57f55e2a}}\pysiglinewithargsret{int \sphinxbfcode{importConfig}}{vector\textless{}string\textgreater{} \&\sphinxstyleemphasis{comargs}}{}%
\pysigstopmultiline
Imports the parameters from the config file and returns an integer of the number of arguments. 

\begin{description}
\item[{\sphinxstylestrong{Return}}] \leavevmode
a count of the number of arguments (should also be the size of comargs). 

\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{comargs}: a vector of command line arguments to import to from file. 

\end{itemize}

\end{description}


\end{fulllineitems}

\paragraph{Friends}
\index{operator\textless{}\textless{} (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_ConfigOption:_CPPv2lsR7ostreamRK12ConfigOption}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_ConfigOption:necsimclass_config_option_1a9e0cbadb5ac652eb62eb6e046dad5126}}\pysiglinewithargsret{ostream \&\sphinxbfcode{operator\textless{}\textless{}}}{ostream \&\sphinxstyleemphasis{os}, \sphinxstrong{const} {\hyperref[\detokenize{api/class_ConfigOption:_CPPv212ConfigOption}]{\sphinxcrossref{ConfigOption}}} \&\sphinxstyleemphasis{c}}{}%
\pysigstopmultiline
Overloading the \textless{}\textless{} operator for outputting to the output stream. 

\begin{description}
\item[{\sphinxstylestrong{Return}}] \leavevmode
os the output stream. 

\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{os}: the output stream. 

\item {} 
\sphinxcode{c}: the {\hyperref[\detokenize{api/class_ConfigOption:necsimclass_config_option}]{\sphinxcrossref{\DUrole{std,std-ref}{ConfigOption}}}} object. 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{operator\textgreater{}\textgreater{} (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_ConfigOption:_CPPv2rsR7istreamR12ConfigOption}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_ConfigOption:necsimclass_config_option_1ad418094c35f378a7b92ca5922e45a206}}\pysiglinewithargsret{istream \&\sphinxbfcode{operator\textgreater{}\textgreater{}}}{istream \&\sphinxstyleemphasis{is}, {\hyperref[\detokenize{api/class_ConfigOption:_CPPv212ConfigOption}]{\sphinxcrossref{ConfigOption}}} \&\sphinxstyleemphasis{c}}{}%
\pysigstopmultiline
Overloading the \textgreater{}\textgreater{} operator for inputting from an input stream. Note that the config file must still exist for re-inport and parsing. 

\begin{description}
\item[{\sphinxstylestrong{Return}}] \leavevmode
is the input stream 

\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{is}: the input stream 

\item {} 
\sphinxcode{c}: the {\hyperref[\detokenize{api/class_ConfigOption:necsimclass_config_option}]{\sphinxcrossref{\DUrole{std,std-ref}{ConfigOption}}}} object 

\end{itemize}

\end{description}


\end{fulllineitems}


\end{fulllineitems}



\subsection{Class DataMask}
\label{\detokenize{api/class_DataMask:id1}}\label{\detokenize{api/class_DataMask::doc}}\label{\detokenize{api/class_DataMask:class-datamask}}\begin{itemize}
\item {} 
Defined in {\hyperref[\detokenize{api/file_necsim_DataMask.h:file-necsim-datamask-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File DataMask.h}}}}

\end{itemize}


\subsubsection{Inheritance Relationships}
\label{\detokenize{api/class_DataMask:inheritance-relationships}}

\paragraph{Derived Type}
\label{\detokenize{api/class_DataMask:derived-type}}\begin{itemize}
\item {} 
\sphinxcode{public Samplematrix} ({\hyperref[\detokenize{api/class_Samplematrix:class-samplematrix}]{\sphinxcrossref{\DUrole{std,std-ref}{Class Samplematrix}}}})

\end{itemize}


\subsubsection{Class Documentation}
\label{\detokenize{api/class_DataMask:class-documentation}}\index{DataMask (C++ class)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_DataMask:_CPPv28DataMask}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_DataMask:necsimclass_data_mask}}\pysigline{\sphinxstrong{class }\sphinxcode{}\sphinxbfcode{DataMask}}%
\pysigstopmultiline
Contains the {\hyperref[\detokenize{api/class_DataMask:necsimclass_data_mask}]{\sphinxcrossref{\DUrole{std,std-ref}{DataMask}}}} object, a {\hyperref[\detokenize{api/class_Matrix:necsimclass_matrix}]{\sphinxcrossref{\DUrole{std,std-ref}{Matrix}}}} of booleans describing the spatial sampling pattern. 

Subclassed by {\hyperref[\detokenize{api/class_Samplematrix:necsimclass_samplematrix}]{\sphinxcrossref{\DUrole{std,std-ref}{Samplematrix}}}}
\paragraph{Public Functions}
\index{DataMask::DataMask (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_DataMask:_CPPv2N8DataMask8DataMaskEv}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_DataMask:necsimclass_data_mask_1ae89a953b8200f027d44dc74fa748852b}}\pysiglinewithargsret{\sphinxbfcode{DataMask}}{}{}%
\pysigstopmultiline
The {\hyperref[\detokenize{api/class_DataMask:necsimclass_data_mask}]{\sphinxcrossref{\DUrole{std,std-ref}{DataMask}}}} constructor. 

Exact grid for determining sampling proportion. 

\end{fulllineitems}

\index{DataMask::\textasciitilde{}DataMask (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_DataMask:_CPPv2N8DataMaskD0Ev}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_DataMask:necsimclass_data_mask_1aa45741c95c5ab3881d6606c0ad5b6560}}\pysiglinewithargsret{\sphinxbfcode{\textasciitilde{}DataMask}}{}{}%
\pysigstopmultiline
\end{fulllineitems}

\index{DataMask::getDefault (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_DataMask:_CPPv2N8DataMask10getDefaultEv}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_DataMask:necsimclass_data_mask_1a093364b6da9442f7c4945b5a06cfe3af}}\pysiglinewithargsret{bool \sphinxbfcode{getDefault}}{}{}%
\pysigstopmultiline
Returns if the simulation is using the a null samplemask, and therefore does not need to store the full sample grid in memory. 

\begin{description}
\item[{\sphinxstylestrong{Return}}] \leavevmode
true if using a null samplemask 

\end{description}


\end{fulllineitems}

\index{DataMask::setup (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_DataMask:_CPPv2N8DataMask5setupERK6stringRKmRKmRKmRKmRKmRKm}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_DataMask:necsimclass_data_mask_1a73922a90e7f491ec3dcf90fdd400fdf8}}\pysiglinewithargsret{bool \sphinxbfcode{setup}}{\sphinxstrong{const} string \&\sphinxstyleemphasis{sample\_mask\_file}, \sphinxstrong{const} unsigned long \&\sphinxstyleemphasis{x\_in}, \sphinxstrong{const} unsigned long \&\sphinxstyleemphasis{y\_in}, \sphinxstrong{const} unsigned long \&\sphinxstyleemphasis{mask\_x\_in}, \sphinxstrong{const} unsigned long \&\sphinxstyleemphasis{mask\_y\_in}, \sphinxstrong{const} unsigned long \&\sphinxstyleemphasis{x\_offset\_in}, \sphinxstrong{const} unsigned long \&\sphinxstyleemphasis{y\_offset\_in}}{}%
\pysigstopmultiline
Sets the parameters for the datamask, including the dimensions of the map, the offsets from the grid and the dimensions of the grid itself for recalculating coordinates. 

\begin{description}
\item[{\sphinxstylestrong{Return}}] \leavevmode
true if using a \sphinxquotedblleft{}null\sphinxquotedblright{} samplemask 

\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{sample\_mask\_file}: the file to import the samplemask from (or \sphinxquotedblleft{}null\sphinxquotedblright{}) 

\item {} 
\sphinxcode{x\_in}: x dimension of the grid 

\item {} 
\sphinxcode{y\_in}: y dimension of the grid 

\item {} 
\sphinxcode{mask\_x\_in}: x dimension of the sample mask 

\item {} 
\sphinxcode{mask\_y\_in}: y dimension of the sample mask 

\item {} 
\sphinxcode{x\_offset\_in}: x offset of the sample mask from the grid 

\item {} 
\sphinxcode{y\_offset\_in}: y offset of the sample mask from the grid 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{DataMask::importBooleanMask (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_DataMask:_CPPv2N8DataMask17importBooleanMaskEmmmmmm6string}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_DataMask:necsimclass_data_mask_1a819eacf6968b0384a0221599dac09122}}\pysiglinewithargsret{void \sphinxbfcode{importBooleanMask}}{unsigned long \sphinxstyleemphasis{xdim}, unsigned long \sphinxstyleemphasis{ydim}, unsigned long \sphinxstyleemphasis{mask\_xdim}, unsigned long \sphinxstyleemphasis{mask\_ydim}, unsigned long \sphinxstyleemphasis{xoffset}, unsigned long \sphinxstyleemphasis{yoffset}, string \sphinxstyleemphasis{inputfile}}{}%
\pysigstopmultiline
Imports the sample mask as a boolean mask and sets the relevant sample mask dimensions. 

\begin{description}
\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{xdim}: the x dimension of the grid area 

\item {} 
\sphinxcode{ydim}: the y dimension of the grid area 

\item {} 
\sphinxcode{mask\_xdim}: the x dimension of the sample map file 

\item {} 
\sphinxcode{mask\_ydim}: the y dimension of the sample map file 

\item {} 
\sphinxcode{xoffset}: the x offset of the grid area from the sample map file 

\item {} 
\sphinxcode{yoffset}: the y offset of the grid area from the sample map file 

\item {} 
\sphinxcode{inputfile}: the path to the sample map file 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{DataMask::doImport (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_DataMask:_CPPv2N8DataMask8doImportEv}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_DataMask:necsimclass_data_mask_1a85f7b85bb4ac54aa884a8a06f1d35d1b}}\pysiglinewithargsret{void \sphinxbfcode{doImport}}{}{}%
\pysigstopmultiline
Imports the boolean map object. 

\end{fulllineitems}

\index{DataMask::importSampleMask (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_DataMask:_CPPv2N8DataMask16importSampleMaskER13SimParameters}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_DataMask:necsimclass_data_mask_1ac756e21b1c8d9412d565fb020eec9a06}}\pysiglinewithargsret{void \sphinxbfcode{importSampleMask}}{{\hyperref[\detokenize{api/struct_SimParameters:_CPPv213SimParameters}]{\sphinxcrossref{SimParameters}}} \&\sphinxstyleemphasis{mapvarin}}{}%
\pysigstopmultiline
Imports the specified file for the sampling percentage within each cell. 

The map should consist of floating points representing the relative sampling rates in each cell. Note that the actual sampling proportion is equal to the cell value multiplied by global deme sampling proportion. \begin{description}
\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{mapvarin}: the {\hyperref[\detokenize{api/struct_SimParameters:necsimstruct_sim_parameters}]{\sphinxcrossref{\DUrole{std,std-ref}{SimParameters}}}} object containing the samplemask file location and dimensions 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{DataMask::getVal (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_DataMask:_CPPv2N8DataMask6getValERKlRKlRKlRKl}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_DataMask:necsimclass_data_mask_1ace6578db5b096b0c24112cc438cfa90d}}\pysiglinewithargsret{bool \sphinxbfcode{getVal}}{\sphinxstrong{const} long \&\sphinxstyleemphasis{x}, \sphinxstrong{const} long \&\sphinxstyleemphasis{y}, \sphinxstrong{const} long \&\sphinxstyleemphasis{xwrap}, \sphinxstrong{const} long \&\sphinxstyleemphasis{ywrap}}{}%
\pysigstopmultiline
Calculates the matrix value at the provided x, y location. If everywhere is sampled, simply returns true, as no sample\_mask will be stored in memory. This is to save RAM where possible. 

\begin{description}
\item[{\sphinxstylestrong{Return}}] \leavevmode
the sample\_mask value at x,y (or true if the file was \sphinxquotedblleft{}null\sphinxquotedblright{}) 

\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{x}: the x position on the grid 

\item {} 
\sphinxcode{y}: the y position on the grid 

\item {} 
\sphinxcode{xval}: the number of x wraps 

\item {} 
\sphinxcode{yval}: the number of y wraps 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{DataMask::getNullProportion (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_DataMask:_CPPv2N8DataMask17getNullProportionERKlRKlRKlRKl}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_DataMask:necsimclass_data_mask_1af7a7cb35d309d37f42c7a3720a02b400}}\pysiglinewithargsret{double \sphinxbfcode{getNullProportion}}{\sphinxstrong{const} long \&\sphinxstyleemphasis{x}, \sphinxstrong{const} long \&\sphinxstyleemphasis{y}, \sphinxstrong{const} long \&\sphinxstyleemphasis{xwrap}, \sphinxstrong{const} long \&\sphinxstyleemphasis{ywrap}}{}%
\pysigstopmultiline
Separate return function for always returning 1.0 as density value. 

\begin{description}
\item[{\sphinxstylestrong{Return}}] \leavevmode
the sample\_mask\_exact value at (x, y) 

\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{x}: the x position on the grid 

\item {} 
\sphinxcode{y}: the y position on the grid 

\item {} 
\sphinxcode{xwrap}: the number of x wraps around the map 

\item {} 
\sphinxcode{ywrap}: the number of y wraps around the map 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{DataMask::getBoolProportion (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_DataMask:_CPPv2N8DataMask17getBoolProportionERKlRKlRKlRKl}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_DataMask:necsimclass_data_mask_1a31cb42c363219967a7867340a7110e9f}}\pysiglinewithargsret{double \sphinxbfcode{getBoolProportion}}{\sphinxstrong{const} long \&\sphinxstyleemphasis{x}, \sphinxstrong{const} long \&\sphinxstyleemphasis{y}, \sphinxstrong{const} long \&\sphinxstyleemphasis{xwrap}, \sphinxstrong{const} long \&\sphinxstyleemphasis{ywrap}}{}%
\pysigstopmultiline
Returns the exact value from the spatial sampling map, for calculating the proportion of individuals to be sampled in each cell. 

\begin{description}
\item[{\sphinxstylestrong{Note}}] \leavevmode
this function assumes that the file is not \sphinxquotedblleft{}null\sphinxquotedblright{} and the exact sampling mask has been imported. No error checks on these conditions are performed except in debugging mode. 

\item[{\sphinxstylestrong{Return}}] \leavevmode
the sample\_mask\_exact value at (x, y) 

\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{x}: the x position on the grid 

\item {} 
\sphinxcode{y}: the y position on the grid 

\item {} 
\sphinxcode{xwrap}: the number of x wraps around the map 

\item {} 
\sphinxcode{ywrap}: the number of y wraps around the map 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{DataMask::getSampleProportion (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_DataMask:_CPPv2N8DataMask19getSampleProportionERKlRKlRKlRKl}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_DataMask:necsimclass_data_mask_1a682324892b67910b1dd2fa86a98c0873}}\pysiglinewithargsret{double \sphinxbfcode{getSampleProportion}}{\sphinxstrong{const} long \&\sphinxstyleemphasis{x}, \sphinxstrong{const} long \&\sphinxstyleemphasis{y}, \sphinxstrong{const} long \&\sphinxstyleemphasis{xwrap}, \sphinxstrong{const} long \&\sphinxstyleemphasis{ywrap}}{}%
\pysigstopmultiline
Returns the exact value from the spatial sampling map, for calculating the proportion of individuals to be sampled in each cell. 

\begin{description}
\item[{\sphinxstylestrong{Note}}] \leavevmode
this function assumes that the file is not \sphinxquotedblleft{}null\sphinxquotedblright{} and the exact sampling mask has been imported. No error checks on these conditions are performed except in debugging mode. 

\item[{\sphinxstylestrong{Return}}] \leavevmode
the sample\_mask\_exact value at (x, y) 

\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{x}: the x position on the grid 

\item {} 
\sphinxcode{y}: the y position on the grid 

\item {} 
\sphinxcode{xwrap}: the number of x wraps around the map 

\item {} 
\sphinxcode{ywrap}: the number of y wraps around the map 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{DataMask::getExactValue (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_DataMask:_CPPv2N8DataMask13getExactValueERKlRKlRKlRKl}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_DataMask:necsimclass_data_mask_1a2738d996bf7ee99d44a2833b2bed15ef}}\pysiglinewithargsret{double \sphinxbfcode{getExactValue}}{\sphinxstrong{const} long \&\sphinxstyleemphasis{x}, \sphinxstrong{const} long \&\sphinxstyleemphasis{y}, \sphinxstrong{const} long \&\sphinxstyleemphasis{xwrap}, \sphinxstrong{const} long \&\sphinxstyleemphasis{ywrap}}{}%
\pysigstopmultiline
Returns the exact value from the spatial sampling map, as returned by the pointer function. 

\begin{description}
\item[{\sphinxstylestrong{Return}}] \leavevmode
the sample\_mask\_exact value at (x, y) 

\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{x}: the x position on the grid 

\item {} 
\sphinxcode{y}: the y position on the grid 

\item {} 
\sphinxcode{xwrap}: the number of x wraps around the map 

\item {} 
\sphinxcode{ywrap}: the number of y wraps around the map 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{DataMask::convertBoolean (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_DataMask:_CPPv2N8DataMask14convertBooleanER3MapRKdRKd}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_DataMask:necsimclass_data_mask_1a9de1eec774b8307f63357d2eff514b93}}\pysiglinewithargsret{void \sphinxbfcode{convertBoolean}}{{\hyperref[\detokenize{api/class_Map:_CPPv23Map}]{\sphinxcrossref{Map}}} \&\sphinxstyleemphasis{map1}, \sphinxstrong{const} double \&\sphinxstyleemphasis{deme\_sampling}, \sphinxstrong{const} double \&\sphinxstyleemphasis{generation}}{}%
\pysigstopmultiline
Converts the spatial map into the boolean grid required for continued simulation. This is done so that the faster boolean accesses are possible. 

\begin{description}
\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{map1}: the map object to obtain density values from 

\item {} 
\sphinxcode{deme\_sampling}: the proportion of individuals to sample 

\item {} 
\sphinxcode{generation}: the generation individuals are added at 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{DataMask::clearSpatialMask (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_DataMask:_CPPv2N8DataMask16clearSpatialMaskEv}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_DataMask:necsimclass_data_mask_1a2d152bcb13820a9061ea85c984e042a7}}\pysiglinewithargsret{void \sphinxbfcode{clearSpatialMask}}{}{}%
\pysigstopmultiline
Removes the spatial mask from memory. This should be performed if no more map expansions are required. 

\end{fulllineitems}

\index{DataMask::recalculate\_coordinates (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_DataMask:_CPPv2N8DataMask23recalculate_coordinatesERlRlRlRl}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_DataMask:necsimclass_data_mask_1ab96af629241f61a4d7122c6b7a91a3ef}}\pysiglinewithargsret{void \sphinxbfcode{recalculate\_coordinates}}{long \&\sphinxstyleemphasis{x}, long \&\sphinxstyleemphasis{y}, long \&\sphinxstyleemphasis{x\_wrap}, long \&\sphinxstyleemphasis{y\_wrap}}{}%
\pysigstopmultiline
Converts the coordinates back into the grid format. Changes the values in the provided variables to be correct. 

\begin{description}
\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{x}: the x value to convert 

\item {} 
\sphinxcode{y}: the y value to convert 

\item {} 
\sphinxcode{x\_wrap}: the xwrap variable to place the value into 

\item {} 
\sphinxcode{y\_wrap}: the ywrap variable to place the value into 

\end{itemize}

\end{description}


\end{fulllineitems}

\paragraph{Public Members}
\index{DataMask::sample\_mask (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_DataMask:_CPPv2N8DataMask11sample_maskE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{api/class_DataMask:necsimclass_data_mask_1ac4852ba45532f4ec91751df868b11303}}{\hyperref[\detokenize{api/class_Matrix:_CPPv26Matrix}]{\sphinxcrossref{Matrix}}}\textless{}bool\textgreater{} \sphinxbfcode{sample\_mask}}%
\pysigstopmultiline
\end{fulllineitems}

\index{DataMask::sample\_mask\_exact (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_DataMask:_CPPv2N8DataMask17sample_mask_exactE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{api/class_DataMask:necsimclass_data_mask_1a28b2136c9666ec5188dd3301e1db602a}}{\hyperref[\detokenize{api/class_Matrix:_CPPv26Matrix}]{\sphinxcrossref{Matrix}}}\textless{}double\textgreater{} \sphinxbfcode{sample\_mask\_exact}}%
\pysigstopmultiline
A binary grid telling whether or not the cell should be sampled. 

\end{fulllineitems}

\paragraph{Protected Types}
\index{DataMask::fptr (C++ type)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_DataMask:_CPPv2N8DataMask4fptrE}}%
\pysigstartmultiline
\pysiglinewithargsret{\phantomsection\label{\detokenize{api/class_DataMask:necsimclass_data_mask_1a0ed51de5661fc3046d085e044a7efd4a}}\sphinxstrong{typedef }double (\sphinxbfcode{DataMask}::*\sphinxbfcode{fptr})}{\sphinxstrong{const} long \&x, \sphinxstrong{const} long \&y, \sphinxstrong{const} long \&xwrap, \sphinxstrong{const} long \&ywrap}{}%
\pysigstopmultiline
\end{fulllineitems}

\paragraph{Protected Attributes}
\index{DataMask::inputfile (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_DataMask:_CPPv2N8DataMask9inputfileE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{api/class_DataMask:necsimclass_data_mask_1acde16cc845a6102a8b2ee0aa9b8917cb}}string \sphinxbfcode{inputfile}}%
\pysigstopmultiline
\end{fulllineitems}

\index{DataMask::bDefault (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_DataMask:_CPPv2N8DataMask8bDefaultE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{api/class_DataMask:necsimclass_data_mask_1af5d895b50f04eceac1e473dee6f36703}}bool \sphinxbfcode{bDefault}}%
\pysigstopmultiline
\end{fulllineitems}

\index{DataMask::x\_offset (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_DataMask:_CPPv2N8DataMask8x_offsetE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{api/class_DataMask:necsimclass_data_mask_1a70178c907b2dc072b62f4bfb8f690823}}unsigned long \sphinxbfcode{x\_offset}}%
\pysigstopmultiline
\end{fulllineitems}

\index{DataMask::y\_offset (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_DataMask:_CPPv2N8DataMask8y_offsetE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{api/class_DataMask:necsimclass_data_mask_1ab4508058d8563d90bfc606a648cedb2f}}unsigned long \sphinxbfcode{y\_offset}}%
\pysigstopmultiline
\end{fulllineitems}

\index{DataMask::x\_dim (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_DataMask:_CPPv2N8DataMask5x_dimE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{api/class_DataMask:necsimclass_data_mask_1aba77e907211dea06a4a52ad3036716b0}}unsigned long \sphinxbfcode{x\_dim}}%
\pysigstopmultiline
\end{fulllineitems}

\index{DataMask::y\_dim (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_DataMask:_CPPv2N8DataMask5y_dimE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{api/class_DataMask:necsimclass_data_mask_1aa2c689edd7b8bd84bb60e836aac4e378}}unsigned long \sphinxbfcode{y\_dim}}%
\pysigstopmultiline
\end{fulllineitems}

\index{DataMask::mask\_x\_dim (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_DataMask:_CPPv2N8DataMask10mask_x_dimE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{api/class_DataMask:necsimclass_data_mask_1ab971fd5a14a17e850cd92c79c3a1543e}}unsigned long \sphinxbfcode{mask\_x\_dim}}%
\pysigstopmultiline
\end{fulllineitems}

\index{DataMask::mask\_y\_dim (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_DataMask:_CPPv2N8DataMask10mask_y_dimE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{api/class_DataMask:necsimclass_data_mask_1a5ab1bf33e9b9fac964c8c2576fc5edca}}unsigned long \sphinxbfcode{mask\_y\_dim}}%
\pysigstopmultiline
\end{fulllineitems}

\index{DataMask::getProportionfptr (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_DataMask:_CPPv2N8DataMask17getProportionfptrE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{api/class_DataMask:necsimclass_data_mask_1a67c92c63f3397de5312c573281515c1c}}{\hyperref[\detokenize{api/class_DataMask:_CPPv2N8DataMask4fptrE}]{\sphinxcrossref{fptr}}} \sphinxbfcode{getProportionfptr}}%
\pysigstopmultiline
\end{fulllineitems}


\end{fulllineitems}



\subsection{Class DataPoint}
\label{\detokenize{api/class_DataPoint:class-datapoint}}\label{\detokenize{api/class_DataPoint::doc}}\label{\detokenize{api/class_DataPoint:id1}}\begin{itemize}
\item {} 
Defined in {\hyperref[\detokenize{api/file_necsim_DataPoint.h:file-necsim-datapoint-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File DataPoint.h}}}}

\end{itemize}


\subsubsection{Class Documentation}
\label{\detokenize{api/class_DataPoint:class-documentation}}\index{DataPoint (C++ class)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_DataPoint:_CPPv29DataPoint}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_DataPoint:necsimclass_data_point}}\pysigline{\sphinxstrong{class }\sphinxcode{}\sphinxbfcode{DataPoint}}%
\pysigstopmultiline
A data object used in coalescence simulations for calculating the output. Data from this object is outputted to an SQLite database after simulations are complete. 
\paragraph{Public Functions}
\index{DataPoint::DataPoint (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_DataPoint:_CPPv2N9DataPoint9DataPointEv}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_DataPoint:necsimclass_data_point_1a1e1b3678b2d1522b7956148a57e1602f}}\pysiglinewithargsret{\sphinxbfcode{DataPoint}}{}{}%
\pysigstopmultiline
Standard constructor. 

\end{fulllineitems}

\index{DataPoint::\textasciitilde{}DataPoint (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_DataPoint:_CPPv2N9DataPointD0Ev}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_DataPoint:necsimclass_data_point_1aecfe4a3c98e1f29f9e7f8267a26eadd9}}\pysiglinewithargsret{\sphinxbfcode{\textasciitilde{}DataPoint}}{}{}%
\pysigstopmultiline
Standard destructor. 

\end{fulllineitems}

\index{DataPoint::setup (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_DataPoint:_CPPv2N9DataPoint5setupEmmllmmd}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_DataPoint:necsimclass_data_point_1a426e22fa33be467e3cddf71990d3ca8a}}\pysiglinewithargsret{void \sphinxbfcode{setup}}{unsigned long \sphinxstyleemphasis{x}, unsigned long \sphinxstyleemphasis{y}, long \sphinxstyleemphasis{xwrap\_in}, long \sphinxstyleemphasis{ywrap\_in}, unsigned long \sphinxstyleemphasis{reference\_in}, unsigned long \sphinxstyleemphasis{list\_position\_in}, double \sphinxstyleemphasis{min\_max\_in}}{}%
\pysigstopmultiline
Setup of lineage data with any information that's wanted. Note that nwrap is set to 0 in this routine. 

\begin{description}
\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{x}: the x position on the grid 

\item {} 
\sphinxcode{y}: the y position on the grid 

\item {} 
\sphinxcode{xwrap\_in}: the number of wraps of the location on the grid in the x direction 

\item {} 
\sphinxcode{ywrap\_in}: the number of wraps of the location on the grid in the y direction 

\item {} 
\sphinxcode{reference\_in}: the position in the {\hyperref[\detokenize{api/class_TreeNode:necsimclass_tree_node}]{\sphinxcrossref{\DUrole{std,std-ref}{TreeNode}}}} reference object 

\item {} 
\sphinxcode{list\_position\_in}: the position within the {\hyperref[\detokenize{api/class_SpeciesList:necsimclass_species_list}]{\sphinxcrossref{\DUrole{std,std-ref}{SpeciesList}}}} object at the relevant x,y position 

\item {} 
\sphinxcode{min\_max\_in}: the input maximum minimum speciation rate required for speciation to have occured 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{DataPoint::setup (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_DataPoint:_CPPv2N9DataPoint5setupEmmd}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_DataPoint:necsimclass_data_point_1abddc939aebb23f387a23ca5f9ce0eda0}}\pysiglinewithargsret{void \sphinxbfcode{setup}}{unsigned long \sphinxstyleemphasis{reference\_in}, unsigned long \sphinxstyleemphasis{list\_position\_in}, double \sphinxstyleemphasis{min\_max\_in}}{}%
\pysigstopmultiline
Setup of lineage data with any information that's wanted. 

\begin{description}
\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{reference\_in}: the reference point for the {\hyperref[\detokenize{api/class_TreeNode:necsimclass_tree_node}]{\sphinxcrossref{\DUrole{std,std-ref}{TreeNode}}}} reference object 

\item {} 
\sphinxcode{list\_position\_in}: the list position of this lineage in {\hyperref[\detokenize{api/class_SpeciesList:necsimclass_species_list}]{\sphinxcrossref{\DUrole{std,std-ref}{SpeciesList}}}} object 

\item {} 
\sphinxcode{min\_max\_in}: the input maximum minimum speciation rate required for speciation to have occured 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{DataPoint::setup (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_DataPoint:_CPPv2N9DataPoint5setupE9DataPoint}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_DataPoint:necsimclass_data_point_1a1e8c41e56eb1d69a52f5246d9f7ee3f1}}\pysiglinewithargsret{void \sphinxbfcode{setup}}{{\hyperref[\detokenize{api/class_DataPoint:_CPPv29DataPoint}]{\sphinxcrossref{DataPoint}}} \sphinxstyleemphasis{datin}}{}%
\pysigstopmultiline
Copy constructor from another Datapoint object. 

\begin{description}
\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{datin}: a Datapoint object to copy the data from. 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{DataPoint::setReference (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_DataPoint:_CPPv2N9DataPoint12setReferenceEm}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_DataPoint:necsimclass_data_point_1a2433657bfd215678d40904310b926033}}\pysiglinewithargsret{void \sphinxbfcode{setReference}}{unsigned long \sphinxstyleemphasis{z}}{}%
\pysigstopmultiline
Sets the mpos (the position within the {\hyperref[\detokenize{api/class_Row:necsimclass_row}]{\sphinxcrossref{\DUrole{std,std-ref}{Row}}}} of {\hyperref[\detokenize{api/class_TreeNode:necsimclass_tree_node}]{\sphinxcrossref{\DUrole{std,std-ref}{TreeNode}}}} objects.). 

\begin{description}
\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{z}: the desired mpos. 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{DataPoint::setNext (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_DataPoint:_CPPv2N9DataPoint7setNextEm}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_DataPoint:necsimclass_data_point_1aa8279493a06f7c9f810e27673d38f5d4}}\pysiglinewithargsret{void \sphinxbfcode{setNext}}{unsigned long \sphinxstyleemphasis{x}}{}%
\pysigstopmultiline
Set the next link in the linked list. 

\begin{description}
\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{x}: the next Datapoint object. 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{DataPoint::setListPosition (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_DataPoint:_CPPv2N9DataPoint15setListPositionEm}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_DataPoint:necsimclass_data_point_1a8cbeb60a0cb7e46a2bf37973dc72c3b2}}\pysiglinewithargsret{void \sphinxbfcode{setListPosition}}{unsigned long \sphinxstyleemphasis{l}}{}%
\pysigstopmultiline
Sets the list position within the {\hyperref[\detokenize{api/class_SpeciesList:necsimclass_species_list}]{\sphinxcrossref{\DUrole{std,std-ref}{SpeciesList}}}} object. 

\begin{description}
\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{l}: the input list position. 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{DataPoint::setNwrap (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_DataPoint:_CPPv2N9DataPoint8setNwrapEm}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_DataPoint:necsimclass_data_point_1ae73f807fa45356311a58953fb39b4e46}}\pysiglinewithargsret{void \sphinxbfcode{setNwrap}}{unsigned long \sphinxstyleemphasis{n}}{}%
\pysigstopmultiline
Sets the number of wraps from the first {\hyperref[\detokenize{api/class_SpeciesList:necsimclass_species_list}]{\sphinxcrossref{\DUrole{std,std-ref}{SpeciesList}}}} wrapped lineage. If and only if this is 0, the lineage is within the main grid (i.e xwrap and ywrap should be 0). 

\begin{description}
\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{n}: the desired nwrap. 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{DataPoint::setMinmax (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_DataPoint:_CPPv2N9DataPoint9setMinmaxEd}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_DataPoint:necsimclass_data_point_1a45a301225a2d39b98d19ed88264b5d31}}\pysiglinewithargsret{void \sphinxbfcode{setMinmax}}{double \sphinxstyleemphasis{d}}{}%
\pysigstopmultiline
Sets the minmax variable. This is the minimum maximum speciation rate required for speciation to have occured on this branch. 

\begin{description}
\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{d}: the minmax to set. 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{DataPoint::getXpos (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_DataPoint:_CPPv2N9DataPoint7getXposEv}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_DataPoint:necsimclass_data_point_1a4b97b62d0d3438e0317e39084c9b95cb}}\pysiglinewithargsret{unsigned long \sphinxbfcode{getXpos}}{}{}%
\pysigstopmultiline
Get the x position. 

\begin{description}
\item[{\sphinxstylestrong{Return}}] \leavevmode
the xpos. 

\end{description}


\end{fulllineitems}

\index{DataPoint::getYpos (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_DataPoint:_CPPv2N9DataPoint7getYposEv}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_DataPoint:necsimclass_data_point_1a185dbf2dc87c0cb9aaaa75e7ec65e79a}}\pysiglinewithargsret{unsigned long \sphinxbfcode{getYpos}}{}{}%
\pysigstopmultiline
Get the y position. 

\begin{description}
\item[{\sphinxstylestrong{Return}}] \leavevmode
the ypos. 

\end{description}


\end{fulllineitems}

\index{DataPoint::getXwrap (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_DataPoint:_CPPv2N9DataPoint8getXwrapEv}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_DataPoint:necsimclass_data_point_1a94c95a87b33ce5d986ff74f6a5c96fcd}}\pysiglinewithargsret{long \sphinxbfcode{getXwrap}}{}{}%
\pysigstopmultiline
Get the x wrapping. 

\begin{description}
\item[{\sphinxstylestrong{Return}}] \leavevmode
the xwrap. 

\end{description}


\end{fulllineitems}

\index{DataPoint::getYwrap (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_DataPoint:_CPPv2N9DataPoint8getYwrapEv}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_DataPoint:necsimclass_data_point_1ab9d7976595edc06922c997767afc9424}}\pysiglinewithargsret{long \sphinxbfcode{getYwrap}}{}{}%
\pysigstopmultiline
Get the y wrapping. 

\begin{description}
\item[{\sphinxstylestrong{Return}}] \leavevmode
the ywrap. 

\end{description}


\end{fulllineitems}

\index{DataPoint::getReference (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_DataPoint:_CPPv2N9DataPoint12getReferenceEv}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_DataPoint:necsimclass_data_point_1aa8b811037d67e2c74c16e9d85939969e}}\pysiglinewithargsret{unsigned long \sphinxbfcode{getReference}}{}{}%
\pysigstopmultiline
Get the reference position variable. 

\begin{description}
\item[{\sphinxstylestrong{Return}}] \leavevmode
the mpos. 

\end{description}


\end{fulllineitems}

\index{DataPoint::getNext (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_DataPoint:_CPPv2N9DataPoint7getNextEv}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_DataPoint:necsimclass_data_point_1a77bfe024c349550b8f0812cca41c8649}}\pysiglinewithargsret{unsigned long \sphinxbfcode{getNext}}{}{}%
\pysigstopmultiline
Gets the next element linked to this {\hyperref[\detokenize{api/class_DataPoint:necsimclass_data_point}]{\sphinxcrossref{\DUrole{std,std-ref}{DataPoint}}}}. 

\begin{description}
\item[{\sphinxstylestrong{Return}}] \leavevmode
the reference of the next individual in the linked list 

\end{description}


\end{fulllineitems}

\index{DataPoint::getListpos (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_DataPoint:_CPPv2N9DataPoint10getListposEv}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_DataPoint:necsimclass_data_point_1a8c60a34fba35ffb915a57f0968043798}}\pysiglinewithargsret{unsigned long \sphinxbfcode{getListpos}}{}{}%
\pysigstopmultiline
Gets the list position with the {\hyperref[\detokenize{api/class_SpeciesList:necsimclass_species_list}]{\sphinxcrossref{\DUrole{std,std-ref}{SpeciesList}}}} object at the relevant x,y position. 

\begin{description}
\item[{\sphinxstylestrong{Return}}] \leavevmode
the listpos. 

\end{description}


\end{fulllineitems}

\index{DataPoint::getNwrap (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_DataPoint:_CPPv2N9DataPoint8getNwrapEv}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_DataPoint:necsimclass_data_point_1a874d55e25ca0809ba5b8d5d5256731e5}}\pysiglinewithargsret{unsigned long \sphinxbfcode{getNwrap}}{}{}%
\pysigstopmultiline
Get the position in the linked list from the {\hyperref[\detokenize{api/class_SpeciesList:necsimclass_species_list}]{\sphinxcrossref{\DUrole{std,std-ref}{SpeciesList}}}} object. If this is 0, indicates the lineage lies on the original grid, and xwrap and ywrap should be 0. 

\begin{description}
\item[{\sphinxstylestrong{Return}}] \leavevmode
the nwrap. 

\end{description}


\end{fulllineitems}

\index{DataPoint::getMinmax (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_DataPoint:_CPPv2N9DataPoint9getMinmaxEv}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_DataPoint:necsimclass_data_point_1a190823c53c821336c7a40d1aee6a5995}}\pysiglinewithargsret{double \sphinxbfcode{getMinmax}}{}{}%
\pysigstopmultiline
Get the maximum minimum speciation rate required for speciation to have occured on this branch. 

\begin{description}
\item[{\sphinxstylestrong{Return}}] \leavevmode
the minmax. 

\end{description}


\end{fulllineitems}

\index{DataPoint::decreaseNwrap (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_DataPoint:_CPPv2N9DataPoint13decreaseNwrapEv}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_DataPoint:necsimclass_data_point_1a2d939bcbc5abae0d80fdd42a1b26725f}}\pysiglinewithargsret{void \sphinxbfcode{decreaseNwrap}}{}{}%
\pysigstopmultiline
Decreases the nwrap by 1 (to a minimum of 0). 

\end{fulllineitems}

\index{DataPoint::setEndpoint (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_DataPoint:_CPPv2N9DataPoint11setEndpointEllll}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_DataPoint:necsimclass_data_point_1a1d80702ad55b2c64f386b71052adc4d8}}\pysiglinewithargsret{void \sphinxbfcode{setEndpoint}}{long \sphinxstyleemphasis{x}, long \sphinxstyleemphasis{y}, long \sphinxstyleemphasis{xwrapin}, long \sphinxstyleemphasis{ywrapin}}{}%
\pysigstopmultiline
Sets the position in space. 

\begin{description}
\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{x}: the x position. 

\item {} 
\sphinxcode{y}: the y position. 

\item {} 
\sphinxcode{xwrapin}: the number of wraps in the x direction. 

\item {} 
\sphinxcode{ywrapin}: the number of wraps in the y direction. 

\end{itemize}

\end{description}


\end{fulllineitems}

\paragraph{Friends}
\index{operator\textless{}\textless{} (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_DataPoint:_CPPv2lsR7ostreamRK9DataPoint}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_DataPoint:necsimclass_data_point_1adfa94e754617c0b58a39bf86925beeac}}\pysiglinewithargsret{ostream \&\sphinxbfcode{operator\textless{}\textless{}}}{ostream \&\sphinxstyleemphasis{os}, \sphinxstrong{const} {\hyperref[\detokenize{api/class_DataPoint:_CPPv29DataPoint}]{\sphinxcrossref{DataPoint}}} \&\sphinxstyleemphasis{d}}{}%
\pysigstopmultiline
An operator for piping the variables of the Datapoint object to the output stream. 

\begin{description}
\item[{\sphinxstylestrong{Return}}] \leavevmode
returns the output stream at the end. 

\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{os}: the output stream. 

\item {} 
\sphinxcode{d}: the Datapoint object to output. 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{operator\textgreater{}\textgreater{} (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_DataPoint:_CPPv2rsR7istreamR9DataPoint}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_DataPoint:necsimclass_data_point_1a5ea22488fc99136335b4c8474623ccc3}}\pysiglinewithargsret{istream \&\sphinxbfcode{operator\textgreater{}\textgreater{}}}{istream \&\sphinxstyleemphasis{is}, {\hyperref[\detokenize{api/class_DataPoint:_CPPv29DataPoint}]{\sphinxcrossref{DataPoint}}} \&\sphinxstyleemphasis{d}}{}%
\pysigstopmultiline
An operator for piping the variables in to the Datapoint object from the input stream. 

\begin{description}
\item[{\sphinxstylestrong{Return}}] \leavevmode
returns the input stream at the end. 

\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{is}: the input stream 

\item {} 
\sphinxcode{d}: the Datapoint object to input to. 

\end{itemize}

\end{description}


\end{fulllineitems}


\end{fulllineitems}



\subsection{Class DispersalCoordinator}
\label{\detokenize{api/class_DispersalCoordinator:class-dispersalcoordinator}}\label{\detokenize{api/class_DispersalCoordinator::doc}}\label{\detokenize{api/class_DispersalCoordinator:id1}}\begin{itemize}
\item {} 
Defined in {\hyperref[\detokenize{api/file_necsim_DispersalCoordinator.h:file-necsim-dispersalcoordinator-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File DispersalCoordinator.h}}}}

\end{itemize}


\subsubsection{Class Documentation}
\label{\detokenize{api/class_DispersalCoordinator:class-documentation}}\index{DispersalCoordinator (C++ class)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_DispersalCoordinator:_CPPv220DispersalCoordinator}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_DispersalCoordinator:necsimclass_dispersal_coordinator}}\pysigline{\sphinxstrong{class }\sphinxcode{}\sphinxbfcode{DispersalCoordinator}}%
\pysigstopmultiline
Class for generating dispersal distances and provide routines for reading dispersal distance maps as a unwound map-of-maps. This class also handles reading density maps for rejection sampling. 

It requires linking to a density map, random number generator and a generation counter from the {\hyperref[\detokenize{api/class_Tree:necsimclass_tree}]{\sphinxcrossref{\DUrole{std,std-ref}{Tree}}}} class.

Note that no element of this object is recorded during a paused simulation, as all objects pointed to are stored elsewhere and behaviours are recalculated upon simulation resume. 
\paragraph{Public Functions}
\index{DispersalCoordinator::DispersalCoordinator (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_DispersalCoordinator:_CPPv2N20DispersalCoordinator20DispersalCoordinatorEv}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_DispersalCoordinator:necsimclass_dispersal_coordinator_1a164f6a8e881c3786bf2d3f70b68b9431}}\pysiglinewithargsret{\sphinxbfcode{DispersalCoordinator}}{}{}%
\pysigstopmultiline
\end{fulllineitems}

\index{DispersalCoordinator::\textasciitilde{}DispersalCoordinator (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_DispersalCoordinator:_CPPv2N20DispersalCoordinatorD0Ev}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_DispersalCoordinator:necsimclass_dispersal_coordinator_1a34be74448be124dcc46fc041e585cef5}}\pysiglinewithargsret{\sphinxbfcode{\textasciitilde{}DispersalCoordinator}}{}{}%
\pysigstopmultiline
\end{fulllineitems}

\index{DispersalCoordinator::setRandomNumber (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_DispersalCoordinator:_CPPv2N20DispersalCoordinator15setRandomNumberEP6NRrand}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_DispersalCoordinator:necsimclass_dispersal_coordinator_1a3cfdb18edbf4dd1c45d0cf6af47f91fe}}\pysiglinewithargsret{void \sphinxbfcode{setRandomNumber}}{{\hyperref[\detokenize{api/class_NRrand:_CPPv26NRrand}]{\sphinxcrossref{NRrand}}} *\sphinxstyleemphasis{NR\_ptr}}{}%
\pysigstopmultiline
Sets the random number pointer to an {\hyperref[\detokenize{api/class_NRrand:necsimclass_n_rrand}]{\sphinxcrossref{\DUrole{std,std-ref}{NRrand}}}} instance. 

\begin{description}
\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{NR\_ptr}: the random number object to set to 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{DispersalCoordinator::setHabitatMap (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_DispersalCoordinator:_CPPv2N20DispersalCoordinator13setHabitatMapEP3Map}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_DispersalCoordinator:necsimclass_dispersal_coordinator_1a03bc78c6b218366d6165ca49b7e9b35c}}\pysiglinewithargsret{void \sphinxbfcode{setHabitatMap}}{{\hyperref[\detokenize{api/class_Map:_CPPv23Map}]{\sphinxcrossref{Map}}} *\sphinxstyleemphasis{map\_ptr}}{}%
\pysigstopmultiline
Sets the pointer to the {\hyperref[\detokenize{api/class_Map:necsimclass_map}]{\sphinxcrossref{\DUrole{std,std-ref}{Map}}}} object. 

\begin{description}
\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{map\_ptr}: pointer to a {\hyperref[\detokenize{api/class_Map:necsimclass_map}]{\sphinxcrossref{\DUrole{std,std-ref}{Map}}}} object 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{DispersalCoordinator::setGenerationPtr (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_DispersalCoordinator:_CPPv2N20DispersalCoordinator16setGenerationPtrEPd}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_DispersalCoordinator:necsimclass_dispersal_coordinator_1aad9a57afe4629674c958e4d0de4d2451}}\pysiglinewithargsret{void \sphinxbfcode{setGenerationPtr}}{double *\sphinxstyleemphasis{generation\_ptr}}{}%
\pysigstopmultiline
Sets the generation pointer to the provided double. 

\begin{description}
\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{generation\_ptr}: pointer to the generation double 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{DispersalCoordinator::setDispersal (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_DispersalCoordinator:_CPPv2N20DispersalCoordinator12setDispersalERK6stringRK6stringKmKmRKdRKdRKdRKdRKb}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_DispersalCoordinator:necsimclass_dispersal_coordinator_1ab0face98d80793e7f4a8ad1bf4dfe3f1}}\pysiglinewithargsret{void \sphinxbfcode{setDispersal}}{\sphinxstrong{const} string \&\sphinxstyleemphasis{dispersal\_method}, \sphinxstrong{const} string \&\sphinxstyleemphasis{dispersal\_file}, \sphinxstrong{const} unsigned long \sphinxstyleemphasis{dispersal\_x}, \sphinxstrong{const} unsigned long \sphinxstyleemphasis{dispersal\_y}, \sphinxstrong{const} double \&\sphinxstyleemphasis{m\_probin}, \sphinxstrong{const} double \&\sphinxstyleemphasis{cutoffin}, \sphinxstrong{const} double \&\sphinxstyleemphasis{sigmain}, \sphinxstrong{const} double \&\sphinxstyleemphasis{tauin}, \sphinxstrong{const} bool \&\sphinxstyleemphasis{restrict\_self}}{}%
\pysigstopmultiline
Sets the dispersal method and parameters. 

\begin{description}
\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{dispersal\_method}: string containing the dispersal type. Can be one of {[}normal, fat-tail, norm-uniform{]} 

\item {} 
\sphinxcode{dispersal\_file}: string containing the dispersal file, or \sphinxquotedblleft{}none\sphinxquotedblright{} if using dispersal kernel 

\item {} 
\sphinxcode{m\_probin}: the probability of drawing from the uniform distribution. Only relevant for uniform dispersals 

\item {} 
\sphinxcode{cutoffin}: the maximum value to be drawn from the uniform dispersal. Only relevant for uniform dispersals 

\item {} 
\sphinxcode{sigmain}: the fatness of the fat-tailed dispersal kernel 

\item {} 
\sphinxcode{tauin}: the width of the fat-tailed dispersal kernel 

\item {} 
\sphinxcode{restrict\_self}: if true, denies possibility that dispersal comes from the same cell as the parent 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{DispersalCoordinator::disperseNullDispersalMap (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_DispersalCoordinator:_CPPv2N20DispersalCoordinator24disperseNullDispersalMapER4Step}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_DispersalCoordinator:necsimclass_dispersal_coordinator_1a4bac3aeedb3ceb40601c3db951032d0e}}\pysiglinewithargsret{void \sphinxbfcode{disperseNullDispersalMap}}{{\hyperref[\detokenize{api/class_Step:_CPPv24Step}]{\sphinxcrossref{Step}}} \&\sphinxstyleemphasis{this\_step}}{}%
\pysigstopmultiline
Picks a random cell from the whole map and stores the value in the step object. 

\begin{description}
\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{this\_step}: the step object to store end points in 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{DispersalCoordinator::disperseDispersalMap (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_DispersalCoordinator:_CPPv2N20DispersalCoordinator20disperseDispersalMapER4Step}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_DispersalCoordinator:necsimclass_dispersal_coordinator_1a6605069356e02d1c130b6d68e5d08483}}\pysiglinewithargsret{void \sphinxbfcode{disperseDispersalMap}}{{\hyperref[\detokenize{api/class_Step:_CPPv24Step}]{\sphinxcrossref{Step}}} \&\sphinxstyleemphasis{this\_step}}{}%
\pysigstopmultiline
Picks a random dispersal distance from the dispersal map. 

\begin{description}
\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{this\_step}: the step object to store end points in 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{DispersalCoordinator::calculateCellCoordinates (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_DispersalCoordinator:_CPPv2N20DispersalCoordinator24calculateCellCoordinatesER4StepRKm}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_DispersalCoordinator:necsimclass_dispersal_coordinator_1af2a3792c5e0bea86fa044c4cd3e5146c}}\pysiglinewithargsret{void \sphinxbfcode{calculateCellCoordinates}}{{\hyperref[\detokenize{api/class_Step:_CPPv24Step}]{\sphinxcrossref{Step}}} \&\sphinxstyleemphasis{this\_step}, \sphinxstrong{const} unsigned long \&\sphinxstyleemphasis{col\_ref}}{}%
\pysigstopmultiline
Calculates the new coordinates for a column reference. This includes converting between the fine map and sample map. New coordinates are saved in this\_step. 

\begin{description}
\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{this\_step}: the step to save new coordinates in. 

\item {} 
\sphinxcode{col\_ref}: the column reference for 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{DispersalCoordinator::calculateCellReference (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_DispersalCoordinator:_CPPv2N20DispersalCoordinator22calculateCellReferenceER4Step}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_DispersalCoordinator:necsimclass_dispersal_coordinator_1a737c7f1a06650b467d06a91c0474fb79}}\pysiglinewithargsret{unsigned long \sphinxbfcode{calculateCellReference}}{{\hyperref[\detokenize{api/class_Step:_CPPv24Step}]{\sphinxcrossref{Step}}} \&\sphinxstyleemphasis{this\_step}}{}%
\pysigstopmultiline
Calculates the cell reference for a particular coordinate. 

The formula for this calculation is x + (y * xdim) where xdim is the dimensions of the fine map, and x and y are the coordinates for the fine map

\begin{description}
\item[{\sphinxstylestrong{Return}}] \leavevmode
the cell reference from the dispersal\_prob\_map which corresponds to the required cell 

\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{this\_step}: the step object containing the x, y location, and x,y wrapping 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{DispersalCoordinator::disperseDensityMap (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_DispersalCoordinator:_CPPv2N20DispersalCoordinator18disperseDensityMapER4Step}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_DispersalCoordinator:necsimclass_dispersal_coordinator_1a79b6018cda012a59f7b80de40b394a6a}}\pysiglinewithargsret{void \sphinxbfcode{disperseDensityMap}}{{\hyperref[\detokenize{api/class_Step:_CPPv24Step}]{\sphinxcrossref{Step}}} \&\sphinxstyleemphasis{this\_step}}{}%
\pysigstopmultiline
Calls the dispersal kernel from the supplied dispersal distribution. 

\begin{description}
\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{this\_step}: the step object to store end points in 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{DispersalCoordinator::setEndPointFptr (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_DispersalCoordinator:_CPPv2N20DispersalCoordinator15setEndPointFptrERKb}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_DispersalCoordinator:necsimclass_dispersal_coordinator_1ae72980ec66825c641545675037885248}}\pysiglinewithargsret{void \sphinxbfcode{setEndPointFptr}}{\sphinxstrong{const} bool \&\sphinxstyleemphasis{restrict\_self}}{}%
\pysigstopmultiline
Sets the end point function pointer correctly, based on whether it is restricted or not. 

\begin{description}
\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{restrict\_self}: if true, denies possibility that dispersal comes from the same cell as the parent 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{DispersalCoordinator::checkEndPoint (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_DispersalCoordinator:_CPPv2N20DispersalCoordinator13checkEndPointERKmRlRlRlRlRKlRKlRKlRKl}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_DispersalCoordinator:necsimclass_dispersal_coordinator_1a46fe28ad569bda217e168b33216a888b}}\pysiglinewithargsret{bool \sphinxbfcode{checkEndPoint}}{\sphinxstrong{const} unsigned long \&\sphinxstyleemphasis{density}, long \&\sphinxstyleemphasis{oldx}, long \&\sphinxstyleemphasis{oldy}, long \&\sphinxstyleemphasis{oldxwrap}, long \&\sphinxstyleemphasis{oldywrap}, \sphinxstrong{const} long \&\sphinxstyleemphasis{startx}, \sphinxstrong{const} long \&\sphinxstyleemphasis{starty}, \sphinxstrong{const} long \&\sphinxstyleemphasis{startxwrap}, \sphinxstrong{const} long \&\sphinxstyleemphasis{startywrap}}{}%
\pysigstopmultiline
Check the end point for the given coordinates and density. 

\begin{description}
\item[{\sphinxstylestrong{Return}}] \leavevmode
true if the end point passes the density and restricted checks 

\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{density}: the density at the end point - avoids an extra call to {\hyperref[\detokenize{api/class_Map:necsimclass_map_1ab96b3097832c620a024184ed54d5e2d1}]{\sphinxcrossref{\DUrole{std,std-ref}{Map::getVal()}}}} 

\item {} 
\sphinxcode{oldx}: the old x position 

\item {} 
\sphinxcode{oldy}: the old y position 

\item {} 
\sphinxcode{oldxwrap}: the old x wrap 

\item {} 
\sphinxcode{oldywrap}: the old y wrap 

\item {} 
\sphinxcode{startx}: the starting x position 

\item {} 
\sphinxcode{starty}: the starting y position 

\item {} 
\sphinxcode{startxwrap}: the starting x wrap 

\item {} 
\sphinxcode{startywrap}: the ending y wrap 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{DispersalCoordinator::checkEndPointDensity (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_DispersalCoordinator:_CPPv2N20DispersalCoordinator20checkEndPointDensityERKmRlRlRlRlRKlRKlRKlRKl}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_DispersalCoordinator:necsimclass_dispersal_coordinator_1a72d8a718590c6dde6f0e8d1ac991d99d}}\pysiglinewithargsret{bool \sphinxbfcode{checkEndPointDensity}}{\sphinxstrong{const} unsigned long \&\sphinxstyleemphasis{density}, long \&\sphinxstyleemphasis{oldx}, long \&\sphinxstyleemphasis{oldy}, long \&\sphinxstyleemphasis{oldxwrap}, long \&\sphinxstyleemphasis{oldywrap}, \sphinxstrong{const} long \&\sphinxstyleemphasis{startx}, \sphinxstrong{const} long \&\sphinxstyleemphasis{starty}, \sphinxstrong{const} long \&\sphinxstyleemphasis{startxwrap}, \sphinxstrong{const} long \&\sphinxstyleemphasis{startywrap}}{}%
\pysigstopmultiline
Check the end point for the given coordinates and density. 

\begin{description}
\item[{\sphinxstylestrong{Return}}] \leavevmode
true if the end point passes the density and restricted checks 

\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{density}: the density at the end point - avoids an extra call to {\hyperref[\detokenize{api/class_Map:necsimclass_map_1ab96b3097832c620a024184ed54d5e2d1}]{\sphinxcrossref{\DUrole{std,std-ref}{Map::getVal()}}}} 

\item {} 
\sphinxcode{oldx}: the old x position 

\item {} 
\sphinxcode{oldy}: the old y position 

\item {} 
\sphinxcode{oldxwrap}: the old x wrap 

\item {} 
\sphinxcode{oldywrap}: the old y wrap 

\item {} 
\sphinxcode{startx}: the starting x position 

\item {} 
\sphinxcode{starty}: the starting y position 

\item {} 
\sphinxcode{startxwrap}: the starting x wrap 

\item {} 
\sphinxcode{startywrap}: the ending y wrap 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{DispersalCoordinator::checkEndPointRestricted (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_DispersalCoordinator:_CPPv2N20DispersalCoordinator23checkEndPointRestrictedERKmRlRlRlRlRKlRKlRKlRKl}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_DispersalCoordinator:necsimclass_dispersal_coordinator_1a055c62c70087ab163bede5c4c4a8be33}}\pysiglinewithargsret{bool \sphinxbfcode{checkEndPointRestricted}}{\sphinxstrong{const} unsigned long \&\sphinxstyleemphasis{density}, long \&\sphinxstyleemphasis{oldx}, long \&\sphinxstyleemphasis{oldy}, long \&\sphinxstyleemphasis{oldxwrap}, long \&\sphinxstyleemphasis{oldywrap}, \sphinxstrong{const} long \&\sphinxstyleemphasis{startx}, \sphinxstrong{const} long \&\sphinxstyleemphasis{starty}, \sphinxstrong{const} long \&\sphinxstyleemphasis{startxwrap}, \sphinxstrong{const} long \&\sphinxstyleemphasis{startywrap}}{}%
\pysigstopmultiline
Check the end point for the given coordinates and density. 

\begin{description}
\item[{\sphinxstylestrong{Return}}] \leavevmode
true if the end point passes the density and restricted checks 

\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{density}: the density at the end point - avoids an extra call to {\hyperref[\detokenize{api/class_Map:necsimclass_map_1ab96b3097832c620a024184ed54d5e2d1}]{\sphinxcrossref{\DUrole{std,std-ref}{Map::getVal()}}}} 

\item {} 
\sphinxcode{oldx}: the old x position 

\item {} 
\sphinxcode{oldy}: the old y position 

\item {} 
\sphinxcode{oldxwrap}: the old x wrap 

\item {} 
\sphinxcode{oldywrap}: the old y wrap 

\item {} 
\sphinxcode{startx}: the starting x position 

\item {} 
\sphinxcode{starty}: the starting y position 

\item {} 
\sphinxcode{startxwrap}: the starting x wrap 

\item {} 
\sphinxcode{startywrap}: the ending y wrap 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{DispersalCoordinator::disperse (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_DispersalCoordinator:_CPPv2N20DispersalCoordinator8disperseER4Step}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_DispersalCoordinator:necsimclass_dispersal_coordinator_1a08e7c2e1882bd2f83ffd33eed2491fa0}}\pysiglinewithargsret{void \sphinxbfcode{disperse}}{{\hyperref[\detokenize{api/class_Step:_CPPv24Step}]{\sphinxcrossref{Step}}} \&\sphinxstyleemphasis{this\_step}}{}%
\pysigstopmultiline
Performs the dispersal routine using the {\hyperref[\detokenize{api/class_Step:necsimstruct_step}]{\sphinxcrossref{\DUrole{std,std-ref}{Step}}}} object to read starting positions and record the end positions. 

\begin{description}
\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{this\_step}: the {\hyperref[\detokenize{api/class_Step:necsimstruct_step}]{\sphinxcrossref{\DUrole{std,std-ref}{Step}}}} object for reading starting position and storing output distances and angles 

\end{itemize}

\end{description}


\end{fulllineitems}

\paragraph{Protected Types}
\index{DispersalCoordinator::dispersal\_fptr (C++ type)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_DispersalCoordinator:_CPPv2N20DispersalCoordinator14dispersal_fptrE}}%
\pysigstartmultiline
\pysiglinewithargsret{\phantomsection\label{\detokenize{api/class_DispersalCoordinator:necsimclass_dispersal_coordinator_1a95a865c016904f23990926af1e7534da}}\sphinxstrong{typedef }void (\sphinxbfcode{DispersalCoordinator}::*\sphinxbfcode{dispersal\_fptr})}{{\hyperref[\detokenize{api/class_Step:_CPPv24Step}]{\sphinxcrossref{Step}}} \&this\_step}{}%
\pysigstopmultiline
\end{fulllineitems}

\index{DispersalCoordinator::end\_fptr (C++ type)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_DispersalCoordinator:_CPPv2N20DispersalCoordinator8end_fptrE}}%
\pysigstartmultiline
\pysiglinewithargsret{\phantomsection\label{\detokenize{api/class_DispersalCoordinator:necsimclass_dispersal_coordinator_1a6f3d41e77253cb394c63253431decd36}}\sphinxstrong{typedef }bool (\sphinxbfcode{DispersalCoordinator}::*\sphinxbfcode{end\_fptr})}{\sphinxstrong{const} unsigned long \&density, long \&oldx, long \&oldy, long \&oldxwrap, long \&oldywrap, \sphinxstrong{const} long \&startx, \sphinxstrong{const} long \&starty, \sphinxstrong{const} long \&startxwrap, \sphinxstrong{const} long \&startywrap}{}%
\pysigstopmultiline
\end{fulllineitems}

\paragraph{Protected Attributes}
\index{DispersalCoordinator::dispersal\_prob\_map (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_DispersalCoordinator:_CPPv2N20DispersalCoordinator18dispersal_prob_mapE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{api/class_DispersalCoordinator:necsimclass_dispersal_coordinator_1a3d780624030ef3d6b3e2b5ae642854fe}}{\hyperref[\detokenize{api/class_Matrix:_CPPv26Matrix}]{\sphinxcrossref{Matrix}}}\textless{}double\textgreater{} \sphinxbfcode{dispersal\_prob\_map}}%
\pysigstopmultiline
\end{fulllineitems}

\index{DispersalCoordinator::NR (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_DispersalCoordinator:_CPPv2N20DispersalCoordinator2NRE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{api/class_DispersalCoordinator:necsimclass_dispersal_coordinator_1ac4c17447257ed00e1b5610e0e35a5443}}{\hyperref[\detokenize{api/class_NRrand:_CPPv26NRrand}]{\sphinxcrossref{NRrand}}} *\sphinxbfcode{NR}}%
\pysigstopmultiline
\end{fulllineitems}

\index{DispersalCoordinator::habitat\_map (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_DispersalCoordinator:_CPPv2N20DispersalCoordinator11habitat_mapE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{api/class_DispersalCoordinator:necsimclass_dispersal_coordinator_1abcd97d006f49882c6f5c4c24df6cb52a}}{\hyperref[\detokenize{api/class_Map:_CPPv23Map}]{\sphinxcrossref{Map}}} *\sphinxbfcode{habitat\_map}}%
\pysigstopmultiline
\end{fulllineitems}

\index{DispersalCoordinator::generation (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_DispersalCoordinator:_CPPv2N20DispersalCoordinator10generationE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{api/class_DispersalCoordinator:necsimclass_dispersal_coordinator_1ae3f83d100dad7c60137edf42b3c199c1}}double *\sphinxbfcode{generation}}%
\pysigstopmultiline
\end{fulllineitems}

\index{DispersalCoordinator::doDispersal (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_DispersalCoordinator:_CPPv2N20DispersalCoordinator11doDispersalE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{api/class_DispersalCoordinator:necsimclass_dispersal_coordinator_1a93262d2bb612108bfcdc56c1ba11bad1}}{\hyperref[\detokenize{api/class_DispersalCoordinator:_CPPv2N20DispersalCoordinator14dispersal_fptrE}]{\sphinxcrossref{dispersal\_fptr}}} \sphinxbfcode{doDispersal}}%
\pysigstopmultiline
\end{fulllineitems}

\index{DispersalCoordinator::checkEndPointFptr (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_DispersalCoordinator:_CPPv2N20DispersalCoordinator17checkEndPointFptrE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{api/class_DispersalCoordinator:necsimclass_dispersal_coordinator_1a1612005c176cd769797a4d4e459e2dec}}{\hyperref[\detokenize{api/class_DispersalCoordinator:_CPPv2N20DispersalCoordinator8end_fptrE}]{\sphinxcrossref{end\_fptr}}} \sphinxbfcode{checkEndPointFptr}}%
\pysigstopmultiline
\end{fulllineitems}

\index{DispersalCoordinator::xdim (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_DispersalCoordinator:_CPPv2N20DispersalCoordinator4xdimE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{api/class_DispersalCoordinator:necsimclass_dispersal_coordinator_1a66668e6ceec55afa61c1e99719bc6146}}unsigned long \sphinxbfcode{xdim}}%
\pysigstopmultiline
\end{fulllineitems}


\end{fulllineitems}



\subsection{Class LogFile}
\label{\detokenize{api/class_LogFile::doc}}\label{\detokenize{api/class_LogFile:class-logfile}}\label{\detokenize{api/class_LogFile:id1}}\begin{itemize}
\item {} 
Defined in {\hyperref[\detokenize{api/file_necsim_LogFile.h:file-necsim-logfile-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File LogFile.h}}}}

\end{itemize}


\subsubsection{Class Documentation}
\label{\detokenize{api/class_LogFile:class-documentation}}\index{LogFile (C++ class)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_LogFile:_CPPv27LogFile}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_LogFile:necsimclass_log_file}}\pysigline{\sphinxstrong{class }\sphinxcode{}\sphinxbfcode{LogFile}}%
\pysigstopmultiline
Contains routines for writing to log files. 
\paragraph{Public Functions}
\index{LogFile::LogFile (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_LogFile:_CPPv2N7LogFile7LogFileEv}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_LogFile:necsimclass_log_file_1ad11b3baf5602575c1396f726d3598188}}\pysiglinewithargsret{\sphinxbfcode{LogFile}}{}{}%
\pysigstopmultiline
Default constructor. 

\end{fulllineitems}

\index{LogFile::LogFile (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_LogFile:_CPPv2N7LogFile7LogFileERK6string}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_LogFile:necsimclass_log_file_1a0b1339474eda3eb8bed23dce67fa55b0}}\pysiglinewithargsret{\sphinxbfcode{LogFile}}{\sphinxstrong{const} string \&\sphinxstyleemphasis{file\_name\_in}}{}%
\pysigstopmultiline
Constructor taking location of a log file. 

\begin{description}
\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{file\_name\_in}: the path to the log file to open 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{LogFile::\textasciitilde{}LogFile (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_LogFile:_CPPv2N7LogFileD0Ev}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_LogFile:necsimclass_log_file_1a440a7de2dcbb9facb68e56dc47cb9dea}}\pysiglinewithargsret{\sphinxbfcode{\textasciitilde{}LogFile}}{}{}%
\pysigstopmultiline
Default destructor, including writing closure out to log file. 

\end{fulllineitems}

\index{LogFile::init (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_LogFile:_CPPv2N7LogFile4initERK6string}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_LogFile:necsimclass_log_file_1a8f245a5659dba714deb45c8e93ce9681}}\pysiglinewithargsret{void \sphinxbfcode{init}}{\sphinxstrong{const} string \&\sphinxstyleemphasis{file\_name\_in}}{}%
\pysigstopmultiline
\end{fulllineitems}

\index{LogFile::write (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_LogFile:_CPPv2N7LogFile5writeERKi6string}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_LogFile:necsimclass_log_file_1ad8acf8bc3a616ad47f43307781ea3c63}}\pysiglinewithargsret{void \sphinxbfcode{write}}{\sphinxstrong{const} int \&\sphinxstyleemphasis{level}, string \sphinxstyleemphasis{message}}{}%
\pysigstopmultiline
Writes the message out to the logfile at the specified logging level. 

\begin{description}
\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{level}: the level of logging severity 

\item {} 
\sphinxcode{message}: the message to write out 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{LogFile::write (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_LogFile:_CPPv2N7LogFile5writeERKiR12stringstream}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_LogFile:necsimclass_log_file_1a08c10809b0095438671be7603e1a53ae}}\pysiglinewithargsret{void \sphinxbfcode{write}}{\sphinxstrong{const} int \&\sphinxstyleemphasis{level}, stringstream \&\sphinxstyleemphasis{message}}{}%
\pysigstopmultiline
Writes the message out to the logfile at the specified logging level. 

\begin{description}
\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{level}: the level of logging severity 

\item {} 
\sphinxcode{message}: the message to write out 

\end{itemize}

\end{description}


\end{fulllineitems}

\paragraph{Protected Functions}
\index{LogFile::LogFile (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_LogFile:_CPPv2N7LogFile7LogFileERK7LogFile}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_LogFile:necsimclass_log_file_1ad18ff4b82ec0b081cbfd9556a48194fe}}\pysiglinewithargsret{\sphinxbfcode{LogFile}}{\sphinxstrong{const} {\hyperref[\detokenize{api/class_LogFile:_CPPv2N7LogFile7LogFileERK7LogFile}]{\sphinxcrossref{LogFile}}}\&}{}%
\pysigstopmultiline
\end{fulllineitems}

\index{LogFile::operator= (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_LogFile:_CPPv2N7LogFileaSERK7LogFile}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_LogFile:necsimclass_log_file_1a3556b56361a4f9f1cc83e9c3967096ab}}\pysiglinewithargsret{{\hyperref[\detokenize{api/class_LogFile:_CPPv27LogFile}]{\sphinxcrossref{LogFile}}} \&\sphinxbfcode{operator=}}{\sphinxstrong{const} {\hyperref[\detokenize{api/class_LogFile:_CPPv27LogFile}]{\sphinxcrossref{LogFile}}}\&}{}%
\pysigstopmultiline
\end{fulllineitems}

\paragraph{Protected Attributes}
\index{LogFile::output\_stream (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_LogFile:_CPPv2N7LogFile13output_streamE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{api/class_LogFile:necsimclass_log_file_1aae3e784ed5a2414b57d46940a2995c82}}ofstream \sphinxbfcode{output\_stream}}%
\pysigstopmultiline
\end{fulllineitems}

\index{LogFile::file\_name (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_LogFile:_CPPv2N7LogFile9file_nameE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{api/class_LogFile:necsimclass_log_file_1a0fcd1e0a15e6c08f147b39dbea2b253c}}string \sphinxbfcode{file\_name}}%
\pysigstopmultiline
\end{fulllineitems}

\index{LogFile::levels\_map (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_LogFile:_CPPv2N7LogFile10levels_mapE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{api/class_LogFile:necsimclass_log_file_1a75e3b5022358adcff29923c0e9116ff4}}map\textless{}int, string\textgreater{} \sphinxbfcode{levels\_map}}%
\pysigstopmultiline
\end{fulllineitems}


\end{fulllineitems}



\subsection{Class Map}
\label{\detokenize{api/class_Map:class-map}}\label{\detokenize{api/class_Map::doc}}\label{\detokenize{api/class_Map:id1}}\begin{itemize}
\item {} 
Defined in {\hyperref[\detokenize{api/file_necsim_Map.h:file-necsim-map-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File Map.h}}}}

\end{itemize}


\subsubsection{Class Documentation}
\label{\detokenize{api/class_Map:class-documentation}}\index{Map (C++ class)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Map:_CPPv23Map}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_Map:necsimclass_map}}\pysigline{\sphinxstrong{class }\sphinxcode{}\sphinxbfcode{Map}}%
\pysigstopmultiline
Contains all maps and provides the functions for accessing a grid cell in the correct temporal and spacial location. 

The function {\hyperref[\detokenize{api/class_Map:necsimclass_map_1a7c5b0623134a33511d7c17626c967176}]{\sphinxcrossref{\DUrole{std,std-ref}{runDispersal()}}}} also provides the move routine, provided two alternative methods for moving individuals. Contains routines for easy setting up and switching between the different coordinate systems required. Set the map parameters with {\hyperref[\detokenize{api/class_Map:necsimclass_map_1a4265717341e63a4662bf7ada49cc0c3d}]{\sphinxcrossref{\DUrole{std,std-ref}{setDims()}}}}, import the map files with {\hyperref[\detokenize{api/class_Map:necsimclass_map_1ab3c9e77675ad9ca1d34e9ff8e861901d}]{\sphinxcrossref{\DUrole{std,std-ref}{calcFineMap()}}}}, {\hyperref[\detokenize{api/class_Map:necsimclass_map_1ac0b46ec7e4792d6ad3d7bdcf358ecabf}]{\sphinxcrossref{\DUrole{std,std-ref}{calcCoarseMap()}}}} etc, then set up the landscape type using {\hyperref[\detokenize{api/class_Map:necsimclass_map_1acaff6d6881f7547b824cb1a9086f8094}]{\sphinxcrossref{\DUrole{std,std-ref}{setLandscape()}}}} and {\hyperref[\detokenize{api/class_Map:necsimclass_map_1aff6628e343532689d5bdcee2433ac041}]{\sphinxcrossref{\DUrole{std,std-ref}{setPristine()}}}}. Usage is then by {\hyperref[\detokenize{api/class_Map:necsimclass_map_1a7c5b0623134a33511d7c17626c967176}]{\sphinxcrossref{\DUrole{std,std-ref}{runDispersal()}}}} for running a dispersal kernel on the landscape, and then {\hyperref[\detokenize{api/class_Map:necsimclass_map_1ab96b3097832c620a024184ed54d5e2d1}]{\sphinxcrossref{\DUrole{std,std-ref}{getVal()}}}} to obtain the density at the desired coordinates. All coordinates should be given in reference to the simulation grid, and offsets for the fine and coarse map are calculated automatically. 
\paragraph{Public Functions}
\index{Map::Map (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Map:_CPPv2N3Map3MapEv}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_Map:necsimclass_map_1a0f5ad0fd4563497b4214038cbca8b582}}\pysiglinewithargsret{\sphinxbfcode{Map}}{}{}%
\pysigstopmultiline
The default constructor. 

\end{fulllineitems}

\index{Map::getHabitatMax (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Map:_CPPv2N3Map13getHabitatMaxEv}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_Map:necsimclass_map_1a28f72a430bee372e855139adff0bc597}}\pysiglinewithargsret{unsigned long \sphinxbfcode{getHabitatMax}}{}{}%
\pysigstopmultiline
Gets the maximum habitat value from any map. 

\begin{description}
\item[{\sphinxstylestrong{Return}}] \leavevmode
the maximum habitat value 

\end{description}


\end{fulllineitems}

\index{Map::setDims (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Map:_CPPv2N3Map7setDimsE13SimParameters}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_Map:necsimclass_map_1a4265717341e63a4662bf7ada49cc0c3d}}\pysiglinewithargsret{void \sphinxbfcode{setDims}}{{\hyperref[\detokenize{api/struct_SimParameters:_CPPv213SimParameters}]{\sphinxcrossref{SimParameters}}} \sphinxstyleemphasis{mapvarsin}}{}%
\pysigstopmultiline
Sets the dimensions of the grid, the area where the species are initially sampled from. This function must be run before any of the calc map functions to allow for the correct deme allocation. 

\begin{description}
\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{mapvarsin}: the {\hyperref[\detokenize{api/struct_SimParameters:necsimstruct_sim_parameters}]{\sphinxcrossref{\DUrole{std,std-ref}{SimParameters}}}} object containing the map variables to import 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{Map::checkMapExists (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Map:_CPPv2N3Map14checkMapExistsEv}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_Map:necsimclass_map_1ab74d57e0de40b6e16c7bb62489ecff5c}}\pysiglinewithargsret{bool \sphinxbfcode{checkMapExists}}{}{}%
\pysigstopmultiline
\end{fulllineitems}

\index{Map::calcFineMap (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Map:_CPPv2N3Map11calcFineMapEv}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_Map:necsimclass_map_1ab3c9e77675ad9ca1d34e9ff8e861901d}}\pysiglinewithargsret{void \sphinxbfcode{calcFineMap}}{}{}%
\pysigstopmultiline
Imports the fine map object from file and calculates the correct values at each point. Without a map to input, the fine map will simply be a matrix of 1s. 

\end{fulllineitems}

\index{Map::calcPristineFineMap (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Map:_CPPv2N3Map19calcPristineFineMapEv}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_Map:necsimclass_map_1ab1d1bac59d3e1518deaa2ebc561a7f82}}\pysiglinewithargsret{void \sphinxbfcode{calcPristineFineMap}}{}{}%
\pysigstopmultiline
Imports the pristine fine map object from file and calculates the correct values at each point. Without a map to input, the pristine fine map will simply be a matrix of 1s. This has the potential to be changed easily in future versions. 

\end{fulllineitems}

\index{Map::calcCoarseMap (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Map:_CPPv2N3Map13calcCoarseMapEv}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_Map:necsimclass_map_1ac0b46ec7e4792d6ad3d7bdcf358ecabf}}\pysiglinewithargsret{void \sphinxbfcode{calcCoarseMap}}{}{}%
\pysigstopmultiline
Imports the coarse map object from file and calculates the correct values at each point. Without a map to input, the coarse map will simply be a matrix of 1s. This has the potential to be changed easily in future versions. 

\end{fulllineitems}

\index{Map::calcPristineCoarseMap (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Map:_CPPv2N3Map21calcPristineCoarseMapEv}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_Map:necsimclass_map_1a4efc51f5d4e2bb562cf4126a7f291f33}}\pysiglinewithargsret{void \sphinxbfcode{calcPristineCoarseMap}}{}{}%
\pysigstopmultiline
Imports the pristine coarse map object from file and calculates the correct values at each point. Without a map to input, the pristine coarse map will simply be a matrix of 1s. This has the potential to be changed easily in future versions. 

\end{fulllineitems}

\index{Map::setTimeVars (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Map:_CPPv2N3Map11setTimeVarsEdd}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_Map:necsimclass_map_1a1b3b545f5435170d29820b061a924378}}\pysiglinewithargsret{void \sphinxbfcode{setTimeVars}}{double \sphinxstyleemphasis{gen\_since\_pristine\_in}, double \sphinxstyleemphasis{habitat\_change\_rate\_in}}{}%
\pysigstopmultiline
Sets the time variables. 

\begin{description}
\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{gen\_since\_pristine\_in}: the time (in generations) since a pristine habitat state was achieved. 

\item {} 
\sphinxcode{habitat\_change\_rate\_in}: the rate of transform of the habitat up until the pristine time. A value of 0.2 would mean 20\% of the change occurs linearlly up until the pristine time and the remaining 80\% occurs in a jump to the pristine state. 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{Map::calcOffset (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Map:_CPPv2N3Map10calcOffsetEv}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_Map:necsimclass_map_1a7615f4c20da51b3a96d60f9fa89ec73e}}\pysiglinewithargsret{void \sphinxbfcode{calcOffset}}{}{}%
\pysigstopmultiline
Calculates the offset and extremeties of the fine map. 

Note that setting dispersal\_relative\_cost to a value other than 1 can massively increase simulation time. 

\end{fulllineitems}

\index{Map::validateMaps (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Map:_CPPv2N3Map12validateMapsEv}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_Map:necsimclass_map_1a123d710095a549030f2c801ccf9645f1}}\pysiglinewithargsret{void \sphinxbfcode{validateMaps}}{}{}%
\pysigstopmultiline
Checks that the map file sizes are correct and that each value on the fragmented maps is less than the pristine maps. This should be disabled in simulations where habitat sizes are expected to shrink as well as grow. 

\end{fulllineitems}

\index{Map::updateMap (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Map:_CPPv2N3Map9updateMapEd}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_Map:necsimclass_map_1a0c71277515f9f2fc5e2ae586ae9d07f8}}\pysiglinewithargsret{void \sphinxbfcode{updateMap}}{double \sphinxstyleemphasis{generation}}{}%
\pysigstopmultiline
Updates the maps to the newer map. 

\end{fulllineitems}

\index{Map::isPristine (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Map:_CPPv2N3Map10isPristineEv}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_Map:necsimclass_map_1a7c4ca1306850126bf6c040f1c0cc0754}}\pysiglinewithargsret{bool \sphinxbfcode{isPristine}}{}{}%
\pysigstopmultiline
Gets the pristine boolean. 

\begin{description}
\item[{\sphinxstylestrong{Return}}] \leavevmode
the pristine map state. 

\end{description}


\end{fulllineitems}

\index{Map::setPristine (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Map:_CPPv2N3Map11setPristineERKb}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_Map:necsimclass_map_1aff6628e343532689d5bdcee2433ac041}}\pysiglinewithargsret{void \sphinxbfcode{setPristine}}{\sphinxstrong{const} bool \&\sphinxstyleemphasis{bPristinein}}{}%
\pysigstopmultiline
Sets the pristine state of the system. 

\begin{description}
\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{bPristinein}: the pristine state. 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{Map::getPristine (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Map:_CPPv2N3Map11getPristineEv}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_Map:necsimclass_map_1a56f158adbe67d3eea95e2537493851f1}}\pysiglinewithargsret{double \sphinxbfcode{getPristine}}{}{}%
\pysigstopmultiline
Get the pristine map time. 

\begin{description}
\item[{\sphinxstylestrong{Return}}] \leavevmode
double the pristine map time 

\end{description}


\end{fulllineitems}

\index{Map::getLandscapeType (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Map:_CPPv2N3Map16getLandscapeTypeEv}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_Map:necsimclass_map_1a89f96e39e9111c0c6a05a1ee59e7a5d5}}\pysiglinewithargsret{string \sphinxbfcode{getLandscapeType}}{}{}%
\pysigstopmultiline
\end{fulllineitems}

\index{Map::checkPristine (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Map:_CPPv2N3Map13checkPristineEd}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_Map:necsimclass_map_1af7067d6d076eb10b735dc08750dbf924}}\pysiglinewithargsret{void \sphinxbfcode{checkPristine}}{double \sphinxstyleemphasis{generation}}{}%
\pysigstopmultiline
Checks if the pristine state has been reached. 

If there are no pristine maps, this function will do nothing. \begin{description}
\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{generation}: the time to check at. 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{Map::setLandscape (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Map:_CPPv2N3Map12setLandscapeE6string}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_Map:necsimclass_map_1acaff6d6881f7547b824cb1a9086f8094}}\pysiglinewithargsret{void \sphinxbfcode{setLandscape}}{string \sphinxstyleemphasis{is\_infinite}}{}%
\pysigstopmultiline
Sets the landscape functions to either infinite or finite. 

\begin{description}
\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{is\_infinite}: a string of either closed, infinite, tiled\_fine or tiled\_coarse, corresponding to the relevant landscape type. 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{Map::getVal (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Map:_CPPv2N3Map6getValERKdRKdRKlRKlRKd}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_Map:necsimclass_map_1ab96b3097832c620a024184ed54d5e2d1}}\pysiglinewithargsret{unsigned long \sphinxbfcode{getVal}}{\sphinxstrong{const} double \&\sphinxstyleemphasis{x}, \sphinxstrong{const} double \&\sphinxstyleemphasis{y}, \sphinxstrong{const} long \&\sphinxstyleemphasis{xwrap}, \sphinxstrong{const} long \&\sphinxstyleemphasis{ywrap}, \sphinxstrong{const} double \&\sphinxstyleemphasis{current\_generation}}{}%
\pysigstopmultiline
Gets the value at a particular coordinate from the correct map. Takes in to account temporal and spatial referencing. This version involves a call to the function pointer, *getValFunc, so that the correct call to either {\hyperref[\detokenize{api/class_Map:necsimclass_map_1a2c01cd7869a9500204381cdc231df27f}]{\sphinxcrossref{\DUrole{std,std-ref}{getValFinite()}}}} or getValInfinite is made. 

\begin{description}
\item[{\sphinxstylestrong{Return}}] \leavevmode
the value on the correct map at the correct space. 

\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{x}: the x position on the grid. 

\item {} 
\sphinxcode{y}: the y position on the grid. 

\item {} 
\sphinxcode{xwrap}: the number of wraps in the x dimension.. 

\item {} 
\sphinxcode{ywrap}: the number of wraps in the y dimension.. 

\item {} 
\sphinxcode{current\_generation}: the current generation time. 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{Map::getValCoarse (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Map:_CPPv2N3Map12getValCoarseERKdRKdRKd}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_Map:necsimclass_map_1a901ae65dbd0c471acde50a5425ae6a69}}\pysiglinewithargsret{unsigned long \sphinxbfcode{getValCoarse}}{\sphinxstrong{const} double \&\sphinxstyleemphasis{xval}, \sphinxstrong{const} double \&\sphinxstyleemphasis{yval}, \sphinxstrong{const} double \&\sphinxstyleemphasis{current\_generation}}{}%
\pysigstopmultiline
Gets the value from the coarse maps, including linear interpolating between the pristine and present maps. 

\begin{description}
\item[{\sphinxstylestrong{Return}}] \leavevmode
the value of the map at the given coordinates and time 

\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{xval}: the x coordinate 

\item {} 
\sphinxcode{yval}: the y coordinate 

\item {} 
\sphinxcode{current\_generation}: the current generation timer 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{Map::getValFine (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Map:_CPPv2N3Map10getValFineERKdRKdRKd}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_Map:necsimclass_map_1adb6f68f81f080b0ff798a2b375e1563b}}\pysiglinewithargsret{unsigned long \sphinxbfcode{getValFine}}{\sphinxstrong{const} double \&\sphinxstyleemphasis{xval}, \sphinxstrong{const} double \&\sphinxstyleemphasis{yval}, \sphinxstrong{const} double \&\sphinxstyleemphasis{current\_generation}}{}%
\pysigstopmultiline
Gets the value from the fine maps, including linear interpolating between the pristine and present maps. 

\begin{description}
\item[{\sphinxstylestrong{Return}}] \leavevmode
the value of the map at the given coordinates and time 

\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{xval}: the x coordinate 

\item {} 
\sphinxcode{yval}: the y coordinate 

\item {} 
\sphinxcode{current\_generation}: the current generation timer 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{Map::getValFinite (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Map:_CPPv2N3Map12getValFiniteERKdRKdRKlRKlRKd}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_Map:necsimclass_map_1a2c01cd7869a9500204381cdc231df27f}}\pysiglinewithargsret{unsigned long \sphinxbfcode{getValFinite}}{\sphinxstrong{const} double \&\sphinxstyleemphasis{x}, \sphinxstrong{const} double \&\sphinxstyleemphasis{y}, \sphinxstrong{const} long \&\sphinxstyleemphasis{xwrap}, \sphinxstrong{const} long \&\sphinxstyleemphasis{ywrap}, \sphinxstrong{const} double \&\sphinxstyleemphasis{current\_generation}}{}%
\pysigstopmultiline
Gets the value at a particular coordinate from the correct map. Takes in to account temporal and spatial referencing. This version assumes finite landscape. 

\begin{description}
\item[{\sphinxstylestrong{Return}}] \leavevmode
the value on the correct map at the correct space. 

\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{x}: the x position on the grid. 

\item {} 
\sphinxcode{y}: the y position on the grid. 

\item {} 
\sphinxcode{xwrap}: the number of wraps in the x dimension.. 

\item {} 
\sphinxcode{ywrap}: the number of wraps in the y dimension.. 

\item {} 
\sphinxcode{current\_generation}: the current generation time. 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{Map::getValInfinite (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Map:_CPPv2N3Map14getValInfiniteERKdRKdRKlRKlRKd}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_Map:necsimclass_map_1a89d1a01f4e88146dd6860f7d3c71a43b}}\pysiglinewithargsret{unsigned long \sphinxbfcode{getValInfinite}}{\sphinxstrong{const} double \&\sphinxstyleemphasis{x}, \sphinxstrong{const} double \&\sphinxstyleemphasis{y}, \sphinxstrong{const} long \&\sphinxstyleemphasis{xwrap}, \sphinxstrong{const} long \&\sphinxstyleemphasis{ywrap}, \sphinxstrong{const} double \&\sphinxstyleemphasis{current\_generation}}{}%
\pysigstopmultiline
Gets the value at a particular coordinate from the correct map. Takes in to account temporal and spatial referencing. This version assumes an infinite landscape. 

\begin{description}
\item[{\sphinxstylestrong{Return}}] \leavevmode
the value on the correct map at the correct space. 

\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{x}: the x position on the grid. 

\item {} 
\sphinxcode{y}: the y position on the grid. 

\item {} 
\sphinxcode{xwrap}: the number of wraps in the x dimension.. 

\item {} 
\sphinxcode{ywrap}: the number of wraps in the y dimension.. 

\item {} 
\sphinxcode{current\_generation}: the current generation time. 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{Map::getValCoarseTiled (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Map:_CPPv2N3Map17getValCoarseTiledERKdRKdRKlRKlRKd}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_Map:necsimclass_map_1a40ddaa602e7b0e65995638025234de64}}\pysiglinewithargsret{unsigned long \sphinxbfcode{getValCoarseTiled}}{\sphinxstrong{const} double \&\sphinxstyleemphasis{x}, \sphinxstrong{const} double \&\sphinxstyleemphasis{y}, \sphinxstrong{const} long \&\sphinxstyleemphasis{xwrap}, \sphinxstrong{const} long \&\sphinxstyleemphasis{ywrap}, \sphinxstrong{const} double \&\sphinxstyleemphasis{current\_generation}}{}%
\pysigstopmultiline
Gets the value at a particular coordinate from the correct map. Takes in to account temporal and spatial referencing. This version assumes an infinite landscape of tiled coarse maps. 

\begin{description}
\item[{\sphinxstylestrong{Return}}] \leavevmode
the value on the correct map at the correct space. 

\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{x}: the x position on the grid. 

\item {} 
\sphinxcode{y}: the y position on the grid. 

\item {} 
\sphinxcode{xwrap}: the number of wraps in the x dimension.. 

\item {} 
\sphinxcode{ywrap}: the number of wraps in the y dimension.. 

\item {} 
\sphinxcode{current\_generation}: the current generation time. 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{Map::getValFineTiled (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Map:_CPPv2N3Map15getValFineTiledERKdRKdRKlRKlRKd}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_Map:necsimclass_map_1ac9af706dce7adc8d8db17a6189abd1bd}}\pysiglinewithargsret{unsigned long \sphinxbfcode{getValFineTiled}}{\sphinxstrong{const} double \&\sphinxstyleemphasis{x}, \sphinxstrong{const} double \&\sphinxstyleemphasis{y}, \sphinxstrong{const} long \&\sphinxstyleemphasis{xwrap}, \sphinxstrong{const} long \&\sphinxstyleemphasis{ywrap}, \sphinxstrong{const} double \&\sphinxstyleemphasis{current\_generation}}{}%
\pysigstopmultiline
Gets the value at a particular coordinate from the correct map. Takes in to account temporal and spatial referencing. This version assumes an infinite landscape of tiled fine maps. 

\begin{description}
\item[{\sphinxstylestrong{Return}}] \leavevmode
the value on the correct map at the correct space. 

\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{x}: the x position on the grid. 

\item {} 
\sphinxcode{y}: the y position on the grid. 

\item {} 
\sphinxcode{xwrap}: the number of wraps in the x dimension.. 

\item {} 
\sphinxcode{ywrap}: the number of wraps in the y dimension.. 

\item {} 
\sphinxcode{current\_generation}: the current generation time. 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{Map::convertSampleXToFineX (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Map:_CPPv2N3Map21convertSampleXToFineXERKmRKl}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_Map:necsimclass_map_1a12d17532ea880afc77b729f1005b6e4f}}\pysiglinewithargsret{unsigned long \sphinxbfcode{convertSampleXToFineX}}{\sphinxstrong{const} unsigned long \&\sphinxstyleemphasis{x}, \sphinxstrong{const} long \&\sphinxstyleemphasis{xwrap}}{}%
\pysigstopmultiline
Gets the x position on the fine map, given an x and x wrapping. 

Note that this function will not check if the value is actually within bounds of the fine map, and an error will likely be thrown by the matrix referencing if this is the case. \begin{description}
\item[{\sphinxstylestrong{Return}}] \leavevmode
the x location on the fine map 

\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{x}: the x coordinate on the sample mask 

\item {} 
\sphinxcode{xwrap}: the x wrapping of the sample mask. 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{Map::convertSampleYToFineY (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Map:_CPPv2N3Map21convertSampleYToFineYERKmRKl}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_Map:necsimclass_map_1a69ba72442bd3cbf7ee892ea0d2b6e4a1}}\pysiglinewithargsret{unsigned long \sphinxbfcode{convertSampleYToFineY}}{\sphinxstrong{const} unsigned long \&\sphinxstyleemphasis{y}, \sphinxstrong{const} long \&\sphinxstyleemphasis{ywrap}}{}%
\pysigstopmultiline
Gets the y position on the fine map, given a y and y wrapping. 

Note that this function will not check if the value is actually within bounds of the fine map, and an error will likely be thrown by the matrix referencing if this is the case. \begin{description}
\item[{\sphinxstylestrong{Return}}] \leavevmode
the y location on the fine map 

\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{y}: the y coordinate on the sample mask 

\item {} 
\sphinxcode{ywrap}: the y wrapping of the sample mask. 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{Map::convertFineToSample (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Map:_CPPv2N3Map19convertFineToSampleERlRlRlRl}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_Map:necsimclass_map_1abd472c52b8aa58027621187de4a65683}}\pysiglinewithargsret{void \sphinxbfcode{convertFineToSample}}{long \&\sphinxstyleemphasis{x}, long \&\sphinxstyleemphasis{xwrap}, long \&\sphinxstyleemphasis{y}, long \&\sphinxstyleemphasis{ywrap}}{}%
\pysigstopmultiline
Converts the fine map coordinates to the sample grid coordinates. Main conversion is in a call to convertCoordinates, but also makes sure the returned types are long integers. 

\begin{description}
\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{x}: the x coordinate to modify 

\item {} 
\sphinxcode{xwrap}: the x wrapping to modify 

\item {} 
\sphinxcode{y}: the y coordinate to modify 

\item {} 
\sphinxcode{ywrap}: the y wrapping to modify 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{Map::getInitialCount (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Map:_CPPv2N3Map15getInitialCountEdR8DataMask}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_Map:necsimclass_map_1a5f31e18dd51244f51625b28e5314c68e}}\pysiglinewithargsret{unsigned long \sphinxbfcode{getInitialCount}}{double \sphinxstyleemphasis{dSample}, {\hyperref[\detokenize{api/class_DataMask:_CPPv28DataMask}]{\sphinxcrossref{DataMask}}} \&\sphinxstyleemphasis{samplemask}}{}%
\pysigstopmultiline
Counts the number of spaces available in the initial species space. Requires the samplemask to check the sampling area. 

\begin{description}
\item[{\sphinxstylestrong{Return}}] \leavevmode
the total number of individuals predicted to initially exist on the map. 

\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{dSample}: the sample proportion (from 0 to 1). 

\item {} 
\sphinxcode{samplemask}: the {\hyperref[\detokenize{api/class_DataMask:necsimclass_data_mask}]{\sphinxcrossref{\DUrole{std,std-ref}{DataMask}}}} object to sample from. 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{Map::getSimParameters (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Map:_CPPv2N3Map16getSimParametersEv}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_Map:necsimclass_map_1ac560f241eb5a392d2599e11b00328964}}\pysiglinewithargsret{{\hyperref[\detokenize{api/struct_SimParameters:_CPPv213SimParameters}]{\sphinxcrossref{SimParameters}}} \sphinxbfcode{getSimParameters}}{}{}%
\pysigstopmultiline
Gets the mapvars object for referencing simulation parameters. 

\begin{description}
\item[{\sphinxstylestrong{Return}}] \leavevmode


\end{description}


\end{fulllineitems}

\index{Map::checkMap (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Map:_CPPv2N3Map8checkMapERKdRKdRKlRKlKd}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_Map:necsimclass_map_1ac5e842ad3f8d76f2293a6b1be44071ca}}\pysiglinewithargsret{bool \sphinxbfcode{checkMap}}{\sphinxstrong{const} double \&\sphinxstyleemphasis{x}, \sphinxstrong{const} double \&\sphinxstyleemphasis{y}, \sphinxstrong{const} long \&\sphinxstyleemphasis{xwrap}, \sphinxstrong{const} long \&\sphinxstyleemphasis{ywrap}, \sphinxstrong{const} double \sphinxstyleemphasis{generation}}{}%
\pysigstopmultiline
Checks whether the point is habitat or non-habitat. 

\begin{description}
\item[{\sphinxstylestrong{Return}}] \leavevmode
a boolean of whether the map is habitat or non-habitat. 

\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{x}: the x position on the grid. 

\item {} 
\sphinxcode{y}: the y position on the grid. 

\item {} 
\sphinxcode{xwrap}: the number of wraps in the x dimension. 

\item {} 
\sphinxcode{ywrap}: the number of wraps in the y dimension. 

\item {} 
\sphinxcode{generation}: the current generation time. 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{Map::checkFine (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Map:_CPPv2N3Map9checkFineERKdRKdRKlRKl}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_Map:necsimclass_map_1aae9663c2b5bb78e89e2c476d1d1a409b}}\pysiglinewithargsret{bool \sphinxbfcode{checkFine}}{\sphinxstrong{const} double \&\sphinxstyleemphasis{x}, \sphinxstrong{const} double \&\sphinxstyleemphasis{y}, \sphinxstrong{const} long \&\sphinxstyleemphasis{xwrap}, \sphinxstrong{const} long \&\sphinxstyleemphasis{ywrap}}{}%
\pysigstopmultiline
Checks whether the point comes from the fine grid. 

\begin{description}
\item[{\sphinxstylestrong{Return}}] \leavevmode
a boolean of whether the location is on the fine map. 

\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{x}: the x position. 

\item {} 
\sphinxcode{y}: the y position. 

\item {} 
\sphinxcode{xwrap}: the number of wraps in the x dimension. 

\item {} 
\sphinxcode{ywrap}: the number of wraps in the y dimension. 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{Map::convertCoordinates (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Map:_CPPv2N3Map18convertCoordinatesERdRdRlRl}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_Map:necsimclass_map_1af0f4a6a41c91e915614b56b2422d6d5a}}\pysiglinewithargsret{void \sphinxbfcode{convertCoordinates}}{double \&\sphinxstyleemphasis{x}, double \&\sphinxstyleemphasis{y}, long \&\sphinxstyleemphasis{xwrap}, long \&\sphinxstyleemphasis{ywrap}}{}%
\pysigstopmultiline
Converts the coordinates to within the original grid, altering the xwrap and ywrap consequently. 

\begin{description}
\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{x}: the x position. 

\item {} 
\sphinxcode{y}: the y position. 

\item {} 
\sphinxcode{xwrap}: the number of wraps in the x dimension. 

\item {} 
\sphinxcode{ywrap}: the number of wraps in the y dimension. 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{Map::runDispersal (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Map:_CPPv2N3Map12runDispersalERKdRKdRlRlRlRlRbRKd}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_Map:necsimclass_map_1a7c5b0623134a33511d7c17626c967176}}\pysiglinewithargsret{unsigned long \sphinxbfcode{runDispersal}}{\sphinxstrong{const} double \&\sphinxstyleemphasis{dist}, \sphinxstrong{const} double \&\sphinxstyleemphasis{angle}, long \&\sphinxstyleemphasis{startx}, long \&\sphinxstyleemphasis{starty}, long \&\sphinxstyleemphasis{startxwrap}, long \&\sphinxstyleemphasis{startywrap}, bool \&\sphinxstyleemphasis{disp\_comp}, \sphinxstrong{const} double \&\sphinxstyleemphasis{generation}}{}%
\pysigstopmultiline
The function that actually performs the dispersal. It is included here for easier programming and efficiency as the function doesn't need to perform all the checks until the edge of the fine grid. 

\begin{description}
\item[{\sphinxstylestrong{Return}}] \leavevmode
the density value at the end dispersal point 

\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{dist}: the distance travelled (or \sphinxquotedblleft{}distance energy\sphinxquotedblright{} if dispersal\_relative\_cost is not 1). 

\item {} 
\sphinxcode{angle}: the angle of movement. 

\item {} 
\sphinxcode{startx}: the start x position. 

\item {} 
\sphinxcode{starty}: the start y position. 

\item {} 
\sphinxcode{startxwrap}: the start number of wraps in the x dimension. 

\item {} 
\sphinxcode{startywrap}: the start number of wraps in the y dimension. 

\item {} 
\sphinxcode{disp\_comp}: a boolean of whether the dispersal was complete or not. This value is returned true if dispersal is to habitat, false otherwise. 

\item {} 
\sphinxcode{generation}: the time in generations since the start of the simulation. 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{Map::printVars (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Map:_CPPv2N3Map9printVarsEv}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_Map:necsimclass_map_1af25b0713e794dfa189f0445ffcd511b8}}\pysiglinewithargsret{string \sphinxbfcode{printVars}}{}{}%
\pysigstopmultiline
Prints some selected {\hyperref[\detokenize{api/class_Map:necsimclass_map}]{\sphinxcrossref{\DUrole{std,std-ref}{Map}}}} variables to the terminal. 

\begin{description}
\item[{\sphinxstylestrong{Return}}] \leavevmode
the string containing the map variables to print 

\end{description}


\end{fulllineitems}

\index{Map::clearMap (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Map:_CPPv2N3Map8clearMapEv}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_Map:necsimclass_map_1a7ded655c7db0e9d72816430b4f2c83a5}}\pysiglinewithargsret{void \sphinxbfcode{clearMap}}{}{}%
\pysigstopmultiline
Wipes the map of all variables. Only really useful for testing purposes. 

\end{fulllineitems}

\index{Map::recalculateHabitatMax (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Map:_CPPv2N3Map21recalculateHabitatMaxEv}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_Map:necsimclass_map_1a9610a8ee9c5baa8624074fc1ef6ba3e4}}\pysiglinewithargsret{void \sphinxbfcode{recalculateHabitatMax}}{}{}%
\pysigstopmultiline
Recalculates the habitat map maximum by checking the maximums for each of the relevant map files (fine, coarse and pristines). 

\end{fulllineitems}

\paragraph{Protected Types}
\index{Map::fptr (C++ type)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Map:_CPPv2N3Map4fptrE}}%
\pysigstartmultiline
\pysiglinewithargsret{\phantomsection\label{\detokenize{api/class_Map:necsimclass_map_1a0080b09c39d18cad51d83d5ec2bc2ce7}}\sphinxstrong{typedef }unsigned long (\sphinxbfcode{Map}::*\sphinxbfcode{fptr})}{\sphinxstrong{const} double \&x, \sphinxstrong{const} double \&y, \sphinxstrong{const} long \&xwrap, \sphinxstrong{const} long \&ywrap, \sphinxstrong{const} double \&dCurrentGen}{}%
\pysigstopmultiline
\end{fulllineitems}

\paragraph{Protected Attributes}
\index{Map::fine\_map (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Map:_CPPv2N3Map8fine_mapE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{api/class_Map:necsimclass_map_1a4579c0a75f27777739b8f13ec620fa21}}{\hyperref[\detokenize{api/class_Matrix:_CPPv26Matrix}]{\sphinxcrossref{Matrix}}}\textless{}uint32\_t\textgreater{} \sphinxbfcode{fine\_map}}%
\pysigstopmultiline
\end{fulllineitems}

\index{Map::pristine\_fine\_map (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Map:_CPPv2N3Map17pristine_fine_mapE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{api/class_Map:necsimclass_map_1a807b35e2a3822cb98f92cf545cb85cf6}}{\hyperref[\detokenize{api/class_Matrix:_CPPv26Matrix}]{\sphinxcrossref{Matrix}}}\textless{}uint32\_t\textgreater{} \sphinxbfcode{pristine\_fine\_map}}%
\pysigstopmultiline
\end{fulllineitems}

\index{Map::coarse\_map (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Map:_CPPv2N3Map10coarse_mapE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{api/class_Map:necsimclass_map_1a67045641f66beb1d3689726cb23fbc29}}{\hyperref[\detokenize{api/class_Matrix:_CPPv26Matrix}]{\sphinxcrossref{Matrix}}}\textless{}uint32\_t\textgreater{} \sphinxbfcode{coarse\_map}}%
\pysigstopmultiline
\end{fulllineitems}

\index{Map::pristine\_coarse\_map (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Map:_CPPv2N3Map19pristine_coarse_mapE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{api/class_Map:necsimclass_map_1a6d2258eb1652f5d411d88a02efaf4862}}{\hyperref[\detokenize{api/class_Matrix:_CPPv26Matrix}]{\sphinxcrossref{Matrix}}}\textless{}uint32\_t\textgreater{} \sphinxbfcode{pristine\_coarse\_map}}%
\pysigstopmultiline
\end{fulllineitems}

\index{Map::mapvars (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Map:_CPPv2N3Map7mapvarsE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{api/class_Map:necsimclass_map_1afc7243e4b89be2a6e7340e8fa84c6679}}{\hyperref[\detokenize{api/struct_SimParameters:_CPPv213SimParameters}]{\sphinxcrossref{SimParameters}}} \sphinxbfcode{mapvars}}%
\pysigstopmultiline
\end{fulllineitems}

\index{Map::fine\_x\_min (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Map:_CPPv2N3Map10fine_x_minE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{api/class_Map:necsimclass_map_1ad1a45a6a48740e4ea0f0e02f7370318e}}long \sphinxbfcode{fine\_x\_min}}%
\pysigstopmultiline
\end{fulllineitems}

\index{Map::fine\_y\_min (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Map:_CPPv2N3Map10fine_y_minE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{api/class_Map:necsimclass_map_1adb389e9c031b9f5d2eea869792ed4860}}long \sphinxbfcode{fine\_y\_min}}%
\pysigstopmultiline
\end{fulllineitems}

\index{Map::coarse\_x\_min (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Map:_CPPv2N3Map12coarse_x_minE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{api/class_Map:necsimclass_map_1ad7df363b8838c3ba53c1271b6567f446}}long \sphinxbfcode{coarse\_x\_min}}%
\pysigstopmultiline
\end{fulllineitems}

\index{Map::coarse\_y\_min (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Map:_CPPv2N3Map12coarse_y_minE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{api/class_Map:necsimclass_map_1a5156c05799e2281562e1903fdb256069}}long \sphinxbfcode{coarse\_y\_min}}%
\pysigstopmultiline
\end{fulllineitems}

\index{Map::fine\_x\_max (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Map:_CPPv2N3Map10fine_x_maxE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{api/class_Map:necsimclass_map_1a9113839ec16bbea73081ed9f8f45bb69}}long \sphinxbfcode{fine\_x\_max}}%
\pysigstopmultiline
\end{fulllineitems}

\index{Map::fine\_y\_max (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Map:_CPPv2N3Map10fine_y_maxE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{api/class_Map:necsimclass_map_1a39fea920dc4900cfad9eb866926b52ee}}long \sphinxbfcode{fine\_y\_max}}%
\pysigstopmultiline
\end{fulllineitems}

\index{Map::coarse\_x\_max (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Map:_CPPv2N3Map12coarse_x_maxE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{api/class_Map:necsimclass_map_1aa0482e6238755990a0cbfae535c28145}}long \sphinxbfcode{coarse\_x\_max}}%
\pysigstopmultiline
\end{fulllineitems}

\index{Map::coarse\_y\_max (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Map:_CPPv2N3Map12coarse_y_maxE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{api/class_Map:necsimclass_map_1a4d4031effac0eef4bc40e97e6bd0d4a1}}long \sphinxbfcode{coarse\_y\_max}}%
\pysigstopmultiline
\end{fulllineitems}

\index{Map::fine\_x\_offset (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Map:_CPPv2N3Map13fine_x_offsetE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{api/class_Map:necsimclass_map_1ac28dd97be2767f531282ab16f1082201}}long \sphinxbfcode{fine\_x\_offset}}%
\pysigstopmultiline
\end{fulllineitems}

\index{Map::fine\_y\_offset (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Map:_CPPv2N3Map13fine_y_offsetE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{api/class_Map:necsimclass_map_1a119d4f97bdfac4971a06e59f4f213e4c}}long \sphinxbfcode{fine\_y\_offset}}%
\pysigstopmultiline
\end{fulllineitems}

\index{Map::coarse\_x\_offset (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Map:_CPPv2N3Map15coarse_x_offsetE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{api/class_Map:necsimclass_map_1a4632cd90a5268e09e56dfb6b598b5cbd}}long \sphinxbfcode{coarse\_x\_offset}}%
\pysigstopmultiline
\end{fulllineitems}

\index{Map::coarse\_y\_offset (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Map:_CPPv2N3Map15coarse_y_offsetE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{api/class_Map:necsimclass_map_1ad08ca9fa985b9f04655bd72f33b4ff0f}}long \sphinxbfcode{coarse\_y\_offset}}%
\pysigstopmultiline
\end{fulllineitems}

\index{Map::scale (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Map:_CPPv2N3Map5scaleE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{api/class_Map:necsimclass_map_1ab02a8112322ed5d3ca32212708542118}}unsigned long \sphinxbfcode{scale} = \{\}}%
\pysigstopmultiline
\end{fulllineitems}

\index{Map::x\_dim (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Map:_CPPv2N3Map5x_dimE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{api/class_Map:necsimclass_map_1a1cb67128cea447224d2bcd7bf776e27d}}long \sphinxbfcode{x\_dim}}%
\pysigstopmultiline
\end{fulllineitems}

\index{Map::y\_dim (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Map:_CPPv2N3Map5y_dimE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{api/class_Map:necsimclass_map_1a77bfceb8443f3c5765d4925032346899}}long \sphinxbfcode{y\_dim}}%
\pysigstopmultiline
\end{fulllineitems}

\index{Map::deme (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Map:_CPPv2N3Map4demeE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{api/class_Map:necsimclass_map_1a6e4e471035966189b5085bb6b82c2227}}unsigned long \sphinxbfcode{deme} = \{\}}%
\pysigstopmultiline
\end{fulllineitems}

\index{Map::check\_set\_dim (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Map:_CPPv2N3Map13check_set_dimE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{api/class_Map:necsimclass_map_1ae1dfe0677a730f4389c299da9dd56598}}bool \sphinxbfcode{check\_set\_dim}}%
\pysigstopmultiline
\end{fulllineitems}

\index{Map::dispersal\_relative\_cost (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Map:_CPPv2N3Map23dispersal_relative_costE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{api/class_Map:necsimclass_map_1aeb8e8114c1bfa253379098978b50f603}}double \sphinxbfcode{dispersal\_relative\_cost} = \{\}}%
\pysigstopmultiline
\end{fulllineitems}

\index{Map::update\_time (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Map:_CPPv2N3Map11update_timeE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{api/class_Map:necsimclass_map_1aa61ad7fb290102bc5aa085b2b2a0db9e}}double \sphinxbfcode{update\_time}}%
\pysigstopmultiline
\end{fulllineitems}

\index{Map::habitat\_change\_rate (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Map:_CPPv2N3Map19habitat_change_rateE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{api/class_Map:necsimclass_map_1a7b408911660e9bdea9bd600f0149808d}}double \sphinxbfcode{habitat\_change\_rate}}%
\pysigstopmultiline
\end{fulllineitems}

\index{Map::gen\_since\_pristine (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Map:_CPPv2N3Map18gen_since_pristineE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{api/class_Map:necsimclass_map_1aecea7aa734ff27cd11d362f3d6cf1f5b}}double \sphinxbfcode{gen\_since\_pristine}}%
\pysigstopmultiline
\end{fulllineitems}

\index{Map::current\_map\_time (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Map:_CPPv2N3Map16current_map_timeE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{api/class_Map:necsimclass_map_1a398f4c492eaceb4478745fb80f622d2b}}double \sphinxbfcode{current\_map\_time}}%
\pysigstopmultiline
\end{fulllineitems}

\index{Map::is\_pristine (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Map:_CPPv2N3Map11is_pristineE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{api/class_Map:necsimclass_map_1a2310b482b9986a6a8e04e99c1b622bed}}bool \sphinxbfcode{is\_pristine}}%
\pysigstopmultiline
\end{fulllineitems}

\index{Map::has\_pristine (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Map:_CPPv2N3Map12has_pristineE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{api/class_Map:necsimclass_map_1a121203a1e2f05d718dbefcc086d3d7c0}}bool \sphinxbfcode{has\_pristine}}%
\pysigstopmultiline
\end{fulllineitems}

\index{Map::habitat\_max (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Map:_CPPv2N3Map11habitat_maxE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{api/class_Map:necsimclass_map_1a023ee2f1943e4951c90b6432c4727b6e}}unsigned long \sphinxbfcode{habitat\_max}}%
\pysigstopmultiline
\end{fulllineitems}

\index{Map::fine\_max (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Map:_CPPv2N3Map8fine_maxE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{api/class_Map:necsimclass_map_1a22c982a0ab401a604f1b3f70084236aa}}unsigned long \sphinxbfcode{fine\_max}}%
\pysigstopmultiline
\end{fulllineitems}

\index{Map::coarse\_max (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Map:_CPPv2N3Map10coarse_maxE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{api/class_Map:necsimclass_map_1a63bc1bd83bf9d720c1e73ac8d05f2ea0}}unsigned long \sphinxbfcode{coarse\_max}}%
\pysigstopmultiline
\end{fulllineitems}

\index{Map::pristine\_fine\_max (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Map:_CPPv2N3Map17pristine_fine_maxE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{api/class_Map:necsimclass_map_1a53f737ddc03cf354a0e4d4fb676b2073}}unsigned long \sphinxbfcode{pristine\_fine\_max}}%
\pysigstopmultiline
\end{fulllineitems}

\index{Map::pristine\_coarse\_max (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Map:_CPPv2N3Map19pristine_coarse_maxE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{api/class_Map:necsimclass_map_1af92e8eded3e1d8113ea733d4ef24b5c0}}unsigned long \sphinxbfcode{pristine\_coarse\_max}}%
\pysigstopmultiline
\end{fulllineitems}

\index{Map::landscape\_type (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Map:_CPPv2N3Map14landscape_typeE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{api/class_Map:necsimclass_map_1a81e886ea2c2168c3d8b33a3e9502901a}}string \sphinxbfcode{landscape\_type}}%
\pysigstopmultiline
\end{fulllineitems}

\index{Map::NextMap (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Map:_CPPv2N3Map7NextMapE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{api/class_Map:necsimclass_map_1a8346e76eb734528fc6cffc2170517c3d}}string \sphinxbfcode{NextMap}}%
\pysigstopmultiline
\end{fulllineitems}

\index{Map::bCoarse (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Map:_CPPv2N3Map7bCoarseE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{api/class_Map:necsimclass_map_1aa2478803a3e80e91042d054de88e9ee1}}bool \sphinxbfcode{bCoarse}}%
\pysigstopmultiline
\end{fulllineitems}

\index{Map::nUpdate (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Map:_CPPv2N3Map7nUpdateE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{api/class_Map:necsimclass_map_1ae91de9d71b1aa841d73adcacaf1777d8}}unsigned int \sphinxbfcode{nUpdate} = \{\}}%
\pysigstopmultiline
\end{fulllineitems}

\index{Map::getValFunc (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Map:_CPPv2N3Map10getValFuncE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{api/class_Map:necsimclass_map_1af2ed0369327fb4dbe0e7f7fc5088920d}}{\hyperref[\detokenize{api/class_Map:_CPPv2N3Map4fptrE}]{\sphinxcrossref{fptr}}} \sphinxbfcode{getValFunc}}%
\pysigstopmultiline
\end{fulllineitems}

\paragraph{Friends}
\index{operator\textless{}\textless{} (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Map:_CPPv2lsR7ostreamRK3Map}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_Map:necsimclass_map_1a0da37af2cd547fa045e06a2da3c1039f}}\pysiglinewithargsret{ostream \&\sphinxbfcode{operator\textless{}\textless{}}}{ostream \&\sphinxstyleemphasis{os}, \sphinxstrong{const} {\hyperref[\detokenize{api/class_Map:_CPPv23Map}]{\sphinxcrossref{Map}}} \&\sphinxstyleemphasis{r}}{}%
\pysigstopmultiline
Operator for outputting the {\hyperref[\detokenize{api/class_Map:necsimclass_map}]{\sphinxcrossref{\DUrole{std,std-ref}{Map}}}} object variables to an output stream. This is used for storing the {\hyperref[\detokenize{api/class_Map:necsimclass_map}]{\sphinxcrossref{\DUrole{std,std-ref}{Map}}}} object to file. 

\begin{description}
\item[{\sphinxstylestrong{Return}}] \leavevmode
the output stream. 

\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{os}: the output stream. 

\item {} 
\sphinxcode{r}: the {\hyperref[\detokenize{api/class_Map:necsimclass_map}]{\sphinxcrossref{\DUrole{std,std-ref}{Map}}}} object to output. 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{operator\textgreater{}\textgreater{} (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Map:_CPPv2rsR7istreamR3Map}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_Map:necsimclass_map_1a480da4c3f474c0af7eacdde650546dc1}}\pysiglinewithargsret{istream \&\sphinxbfcode{operator\textgreater{}\textgreater{}}}{istream \&\sphinxstyleemphasis{is}, {\hyperref[\detokenize{api/class_Map:_CPPv23Map}]{\sphinxcrossref{Map}}} \&\sphinxstyleemphasis{r}}{}%
\pysigstopmultiline
Operator for inputting the {\hyperref[\detokenize{api/class_Map:necsimclass_map}]{\sphinxcrossref{\DUrole{std,std-ref}{Map}}}} object variables from an input stream. This is used for reading the {\hyperref[\detokenize{api/class_Map:necsimclass_map}]{\sphinxcrossref{\DUrole{std,std-ref}{Map}}}} object from file. 

\begin{description}
\item[{\sphinxstylestrong{Return}}] \leavevmode
the input stream. 

\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{is}: the input stream. 

\item {} 
\sphinxcode{r}: the {\hyperref[\detokenize{api/class_Map:necsimclass_map}]{\sphinxcrossref{\DUrole{std,std-ref}{Map}}}} object to input to. 

\end{itemize}

\end{description}


\end{fulllineitems}


\end{fulllineitems}



\subsection{Template Class Matrix}
\label{\detokenize{api/class_Matrix:template-class-matrix}}\label{\detokenize{api/class_Matrix::doc}}\label{\detokenize{api/class_Matrix:id1}}\begin{itemize}
\item {} 
Defined in {\hyperref[\detokenize{api/file_necsim_Matrix.h:file-necsim-matrix-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File Matrix.h}}}}

\end{itemize}


\subsubsection{Class Documentation}
\label{\detokenize{api/class_Matrix:class-documentation}}\index{Matrix (C++ class)}

\begin{fulllineitems}
\pysigline{\phantomsection\label{\detokenize{api/class_Matrix:necsimclass_matrix}}\sphinxstrong{template }\textless{}class \sphinxstyleemphasis{T}\textgreater{}}\phantomsection\label{\detokenize{api/class_Matrix:_CPPv26Matrix}}%
\pysigstartmultiline
\pysigline{\sphinxstrong{class }\sphinxcode{}\sphinxbfcode{Matrix}}%
\pysigstopmultiline
A class containing the {\hyperref[\detokenize{api/class_Matrix:necsimclass_matrix}]{\sphinxcrossref{\DUrole{std,std-ref}{Matrix}}}} object, set up as an array of {\hyperref[\detokenize{api/class_Row:necsimclass_row}]{\sphinxcrossref{\DUrole{std,std-ref}{Row}}}} objects. Includes basic operations, as well as the {\hyperref[\detokenize{api/class_Matrix:necsimclass_matrix_1aab2f77cfbdbeffcfe67d63d876581b2e}]{\sphinxcrossref{\DUrole{std,std-ref}{importCsv()}}}} function for more advanced reading from file. 
\paragraph{Public Functions}
\index{Matrix::Matrix (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Matrix:_CPPv2N6Matrix6MatrixEmm}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_Matrix:necsimclass_matrix_1a53f60218c002f2bb454695a1fc35c5d3}}\pysiglinewithargsret{\sphinxbfcode{Matrix}}{unsigned long \sphinxstyleemphasis{rows} = 0, unsigned long \sphinxstyleemphasis{cols} = 0}{}%
\pysigstopmultiline
The standard constructor. 

\begin{description}
\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{rows}: optionally provide the number of rows. 

\item {} 
\sphinxcode{cols}: optionally provide the number of columns. 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{Matrix::Matrix (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Matrix:_CPPv2N6Matrix6MatrixERK6Matrix}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_Matrix:necsimclass_matrix_1a3796b4f32dc8e11f908a90fd3dd39c45}}\pysiglinewithargsret{\sphinxbfcode{Matrix}}{\sphinxstrong{const} {\hyperref[\detokenize{api/class_Matrix:_CPPv2N6Matrix6MatrixEmm}]{\sphinxcrossref{Matrix}}} \&\sphinxstyleemphasis{m}}{}%
\pysigstopmultiline
The copy constructor. 

\begin{description}
\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{m}: a {\hyperref[\detokenize{api/class_Matrix:necsimclass_matrix}]{\sphinxcrossref{\DUrole{std,std-ref}{Matrix}}}} object to copy from. 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{Matrix::\textasciitilde{}Matrix (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Matrix:_CPPv2N6MatrixD0Ev}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_Matrix:necsimclass_matrix_1a91aa704de674203e96aece9e1955ccd3}}\pysiglinewithargsret{\sphinxbfcode{\textasciitilde{}Matrix}}{}{}%
\pysigstopmultiline
The destructor. 

\end{fulllineitems}

\index{Matrix::SetSize (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Matrix:_CPPv2N6Matrix7SetSizeEmm}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_Matrix:necsimclass_matrix_1afec0d39d2d97ec573024552983694a66}}\pysiglinewithargsret{void \sphinxbfcode{SetSize}}{unsigned long \sphinxstyleemphasis{rows}, unsigned long \sphinxstyleemphasis{cols}}{}%
\pysigstopmultiline
Sets the matrix size. Similar concept to that for Rows. 

\begin{description}
\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{rows}: the number of rows. 

\item {} 
\sphinxcode{cols}: the number of columns. 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{Matrix::GetCols (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Matrix:_CPPv2NK6Matrix7GetColsEv}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_Matrix:necsimclass_matrix_1a0467ce3fc5d310bd78e2c48ae4e80b45}}\pysiglinewithargsret{unsigned long \sphinxbfcode{GetCols}}{}{ \sphinxstrong{const}}%
\pysigstopmultiline
Getter for the number of columns. 

\begin{description}
\item[{\sphinxstylestrong{Return}}] \leavevmode
the number of columns. 

\end{description}


\end{fulllineitems}

\index{Matrix::GetRows (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Matrix:_CPPv2NK6Matrix7GetRowsEv}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_Matrix:necsimclass_matrix_1a7c3e1fb8bf860913a03d874c02655ac2}}\pysiglinewithargsret{unsigned long \sphinxbfcode{GetRows}}{}{ \sphinxstrong{const}}%
\pysigstopmultiline
Getter for the number of rows. 

\begin{description}
\item[{\sphinxstylestrong{Return}}] \leavevmode
the number of rows. 

\end{description}


\end{fulllineitems}

\index{Matrix::operator{[}{]} (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Matrix:_CPPv2N6MatrixixEm}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_Matrix:necsimclass_matrix_1ae7e14b4bd8bb570260a4e578e4a601b7}}\pysiglinewithargsret{{\hyperref[\detokenize{api/class_Row:_CPPv23Row}]{\sphinxcrossref{Row}}}\textless{}T\textgreater{} \&\sphinxbfcode{operator{[}{]}}}{unsigned long \sphinxstyleemphasis{index}}{}%
\pysigstopmultiline
Overoads the {[}{]} operator for {\hyperref[\detokenize{api/class_Matrix:necsimclass_matrix}]{\sphinxcrossref{\DUrole{std,std-ref}{Matrix}}}}. Allows referencing of a value i,j using {\hyperref[\detokenize{api/class_Matrix:necsimclass_matrix}]{\sphinxcrossref{\DUrole{std,std-ref}{Matrix}}}}{[}i{]}{[}j{]}. Includes error checking for if the indices are out of range of the matrix. Note that this functionality has been altered since the original file generation. 

\begin{description}
\item[{\sphinxstylestrong{Return}}] \leavevmode
the matrix row object. 

\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{index}: the row number to get the value from. 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{Matrix::operator= (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Matrix:_CPPv2N6MatrixaSERK6Matrix}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_Matrix:necsimclass_matrix_1a94508f84ba0d62e81aa8d508aa43f1ec}}\pysiglinewithargsret{{\hyperref[\detokenize{api/class_Matrix:_CPPv26Matrix}]{\sphinxcrossref{Matrix}}} \&\sphinxbfcode{operator=}}{\sphinxstrong{const} {\hyperref[\detokenize{api/class_Matrix:_CPPv26Matrix}]{\sphinxcrossref{Matrix}}} \&\sphinxstyleemphasis{m}}{}%
\pysigstopmultiline
Overloading the = operator. 

\begin{description}
\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{m}: the matrix to copy from. 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{Matrix::operator+ (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Matrix:_CPPv2N6MatrixplERK6Matrix}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_Matrix:necsimclass_matrix_1a311f3649e41cb4a3155f3f71a65829cb}}\pysiglinewithargsret{\sphinxstrong{const} {\hyperref[\detokenize{api/class_Matrix:_CPPv26Matrix}]{\sphinxcrossref{Matrix}}} \sphinxbfcode{operator+}}{\sphinxstrong{const} {\hyperref[\detokenize{api/class_Matrix:_CPPv26Matrix}]{\sphinxcrossref{Matrix}}} \&\sphinxstyleemphasis{m}}{}%
\pysigstopmultiline
Overloading the + operator. 

\begin{description}
\item[{\sphinxstylestrong{Return}}] \leavevmode
the matrix object which is the sum of the two matrices. 

\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{m}: the matrix to add to this matrix. 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{Matrix::operator- (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Matrix:_CPPv2N6MatrixmiERK6Matrix}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_Matrix:necsimclass_matrix_1a08e75978ea8288083ef36f53b4ac115d}}\pysiglinewithargsret{\sphinxstrong{const} {\hyperref[\detokenize{api/class_Matrix:_CPPv26Matrix}]{\sphinxcrossref{Matrix}}} \sphinxbfcode{operator-}}{\sphinxstrong{const} {\hyperref[\detokenize{api/class_Matrix:_CPPv26Matrix}]{\sphinxcrossref{Matrix}}} \&\sphinxstyleemphasis{m}}{}%
\pysigstopmultiline
Overloading the - operator. 

\begin{description}
\item[{\sphinxstylestrong{Return}}] \leavevmode
the matrix object which is the subtraction of the two matrices. 

\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{m}: the matrix to subtract from this matrix. 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{Matrix::operator+= (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Matrix:_CPPv2N6MatrixpLERK6Matrix}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_Matrix:necsimclass_matrix_1a480a72298ae1fc8443b0edfaa66d7c46}}\pysiglinewithargsret{{\hyperref[\detokenize{api/class_Matrix:_CPPv26Matrix}]{\sphinxcrossref{Matrix}}} \&\sphinxbfcode{operator+=}}{\sphinxstrong{const} {\hyperref[\detokenize{api/class_Matrix:_CPPv26Matrix}]{\sphinxcrossref{Matrix}}} \&\sphinxstyleemphasis{m}}{}%
\pysigstopmultiline
Overloading the += operator so that the new object is written to the current object. 

\begin{description}
\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{m}: the {\hyperref[\detokenize{api/class_Matrix:necsimclass_matrix}]{\sphinxcrossref{\DUrole{std,std-ref}{Matrix}}}} object to add to this matrix. 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{Matrix::operator-= (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Matrix:_CPPv2N6MatrixmIERK6Matrix}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_Matrix:necsimclass_matrix_1a0e459fd035b2435ea016dc93c55ccac0}}\pysiglinewithargsret{{\hyperref[\detokenize{api/class_Matrix:_CPPv26Matrix}]{\sphinxcrossref{Matrix}}} \&\sphinxbfcode{operator-=}}{\sphinxstrong{const} {\hyperref[\detokenize{api/class_Matrix:_CPPv26Matrix}]{\sphinxcrossref{Matrix}}} \&\sphinxstyleemphasis{m}}{}%
\pysigstopmultiline
Overloading the -= operator so that the new object is written to the current object. 

\begin{description}
\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{m}: the {\hyperref[\detokenize{api/class_Matrix:necsimclass_matrix}]{\sphinxcrossref{\DUrole{std,std-ref}{Matrix}}}} object to subtract from this matrix. 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{Matrix::operator* (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Matrix:_CPPv2N6MatrixmlEKd}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_Matrix:necsimclass_matrix_1ac4e94b307c56a15fb47a9255855f94a9}}\pysiglinewithargsret{\sphinxstrong{const} {\hyperref[\detokenize{api/class_Matrix:_CPPv26Matrix}]{\sphinxcrossref{Matrix}}} \sphinxbfcode{operator*}}{\sphinxstrong{const} double \sphinxstyleemphasis{s}}{}%
\pysigstopmultiline
Overloading the * operator for scaling. 

\begin{description}
\item[{\sphinxstylestrong{Return}}] \leavevmode
the scaled matrix. 

\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{s}: the constant to scale the matrix by. 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{Matrix::operator* (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Matrix:_CPPv2N6MatrixmlER6Matrix}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_Matrix:necsimclass_matrix_1ac396cdd2d98e1b4d99f7e17c1c26b1ec}}\pysiglinewithargsret{\sphinxstrong{const} {\hyperref[\detokenize{api/class_Matrix:_CPPv26Matrix}]{\sphinxcrossref{Matrix}}} \sphinxbfcode{operator*}}{{\hyperref[\detokenize{api/class_Matrix:_CPPv26Matrix}]{\sphinxcrossref{Matrix}}} \&\sphinxstyleemphasis{m}}{}%
\pysigstopmultiline
Overloading the * operator for matrix multiplication. Multiplies each value in the matrix with its corresponding value in the other matrix. 

\begin{description}
\item[{\sphinxstylestrong{Return}}] \leavevmode
the product of each ith,jth value of the matrix. 

\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{m}: the matrix to multiply with 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{Matrix::setValue (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Matrix:_CPPv2N6Matrix8setValueERKmRKmPKc}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_Matrix:necsimclass_matrix_1ae511e2f5874e7602fc968541efeefca1}}\pysiglinewithargsret{void \sphinxbfcode{setValue}}{\sphinxstrong{const} unsigned long \&\sphinxstyleemphasis{x}, \sphinxstrong{const} unsigned long \&\sphinxstyleemphasis{y}, \sphinxstrong{const} char *\sphinxstyleemphasis{value}}{}%
\pysigstopmultiline
Sets the value at the specified indices, including handling type conversion from char to the template class. 

\begin{description}
\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{x}: the x index. 

\item {} 
\sphinxcode{y}: the y index. 

\item {} 
\sphinxcode{value}: the value to set 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{Matrix::import (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Matrix:_CPPv2N6Matrix6importERK6string}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_Matrix:necsimclass_matrix_1aeff54b3b98211bde4c0cae25af7aaa0c}}\pysiglinewithargsret{void \sphinxbfcode{import}}{\sphinxstrong{const} string \&\sphinxstyleemphasis{filename}}{}%
\pysigstopmultiline
Imports the matrix from either a csv or tif file. Calls either {\hyperref[\detokenize{api/class_Matrix:necsimclass_matrix_1aab2f77cfbdbeffcfe67d63d876581b2e}]{\sphinxcrossref{\DUrole{std,std-ref}{importCsv()}}}} or importTif() dependent on the provided file type. 

\begin{description}
\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{filename}: the file to import. 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{Matrix::importCsv (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Matrix:_CPPv2N6Matrix9importCsvERK6string}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_Matrix:necsimclass_matrix_1aab2f77cfbdbeffcfe67d63d876581b2e}}\pysiglinewithargsret{void \sphinxbfcode{importCsv}}{\sphinxstrong{const} string \&\sphinxstyleemphasis{filename}}{}%
\pysigstopmultiline
Imports the matrix from a tif file using the gdal library functions. Currently supports importing from. 

\begin{description}
\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{filename}: the path to the file to import. Imports the matrix from a csv file using the fast-csv-parser method. 

\item {} 
\sphinxcode{filename}: the path to the file to import. Imports the matrix from a csv file using the standard, slower method. 

\end{itemize}

\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{filename}: the path to the file to import. 

\end{itemize}

\end{description}


\end{fulllineitems}

\paragraph{Protected Attributes}
\index{Matrix::numCols (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Matrix:_CPPv2N6Matrix7numColsE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{api/class_Matrix:necsimclass_matrix_1a341aaedcfaac978957087bd0467dc527}}unsigned long \sphinxbfcode{numCols} = \{\}}%
\pysigstopmultiline
\end{fulllineitems}

\index{Matrix::numRows (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Matrix:_CPPv2N6Matrix7numRowsE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{api/class_Matrix:necsimclass_matrix_1ac1e96667d48c7845708f978ddd17475d}}unsigned long \sphinxbfcode{numRows} = \{\}}%
\pysigstopmultiline
\end{fulllineitems}

\index{Matrix::matrix (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Matrix:_CPPv2N6Matrix6matrixE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{api/class_Matrix:necsimclass_matrix_1a7a143ae112112155c9622ba17dc434c7}}{\hyperref[\detokenize{api/class_Row:_CPPv23Row}]{\sphinxcrossref{Row}}}\textless{}T\textgreater{} *\sphinxbfcode{matrix}}%
\pysigstopmultiline
\end{fulllineitems}

\paragraph{Friends}
\index{operator\textless{}\textless{} (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Matrix:_CPPv2lsR7ostreamRK6Matrix}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_Matrix:necsimclass_matrix_1a5ed9a90fd6f010e7e9840a17d92d5361}}\pysiglinewithargsret{ostream \&\sphinxbfcode{operator\textless{}\textless{}}}{ostream \&\sphinxstyleemphasis{os}, \sphinxstrong{const} {\hyperref[\detokenize{api/class_Matrix:_CPPv26Matrix}]{\sphinxcrossref{Matrix}}} \&\sphinxstyleemphasis{m}}{}%
\pysigstopmultiline
Overloading the \textless{}\textless{} operator for outputting to an output stream. This can be used for writing to console or storing to file. 

\begin{description}
\item[{\sphinxstylestrong{Return}}] \leavevmode
the output stream. 

\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{os}: the output stream. 

\item {} 
\sphinxcode{m}: the matrix to output. 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{operator\textgreater{}\textgreater{} (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Matrix:_CPPv2rsR7istreamR6Matrix}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_Matrix:necsimclass_matrix_1afcea9fa7d9a5052070fe1fda963ef237}}\pysiglinewithargsret{istream \&\sphinxbfcode{operator\textgreater{}\textgreater{}}}{istream \&\sphinxstyleemphasis{is}, {\hyperref[\detokenize{api/class_Matrix:_CPPv26Matrix}]{\sphinxcrossref{Matrix}}} \&\sphinxstyleemphasis{m}}{}%
\pysigstopmultiline
Overloading the \textgreater{}\textgreater{} operator for inputting from an input stream. This can be used for writing to console or storing to file. 

\begin{description}
\item[{\sphinxstylestrong{Return}}] \leavevmode
the input stream. 

\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{is}: the input stream. 

\item {} 
\sphinxcode{m}: the matrix to input to. 

\end{itemize}

\end{description}


\end{fulllineitems}


\end{fulllineitems}



\subsection{Class Metacommunity}
\label{\detokenize{api/class_Metacommunity::doc}}\label{\detokenize{api/class_Metacommunity:class-metacommunity}}\label{\detokenize{api/class_Metacommunity:id1}}\begin{itemize}
\item {} 
Defined in {\hyperref[\detokenize{api/file_necsim_Metacommunity.h:file-necsim-metacommunity-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File Metacommunity.h}}}}

\end{itemize}


\subsubsection{Inheritance Relationships}
\label{\detokenize{api/class_Metacommunity:inheritance-relationships}}

\paragraph{Base Type}
\label{\detokenize{api/class_Metacommunity:base-type}}\begin{itemize}
\item {} 
\sphinxcode{public Community} ({\hyperref[\detokenize{api/class_Community:class-community}]{\sphinxcrossref{\DUrole{std,std-ref}{Class Community}}}})

\end{itemize}


\subsubsection{Class Documentation}
\label{\detokenize{api/class_Metacommunity:class-documentation}}\index{Metacommunity (C++ class)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Metacommunity:_CPPv213Metacommunity}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_Metacommunity:necsimclass_metacommunity}}\pysigline{\sphinxstrong{class }\sphinxcode{}\sphinxbfcode{Metacommunity}}%
\pysigstopmultiline
Generates a metacommunity using spatially-implicit neutral simulations, which is used to draw individuals from a community. 

Inherits from {\hyperref[\detokenize{api/class_Community:necsimclass_community}]{\sphinxcrossref{\DUrole{std,std-ref}{Community}}}}
\paragraph{Public Functions}
\index{Metacommunity::Metacommunity (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Metacommunity:_CPPv2N13Metacommunity13MetacommunityEv}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_Metacommunity:necsimclass_metacommunity_1ae9f7d7ea2b20471a330b10db37a15342}}\pysiglinewithargsret{\sphinxbfcode{Metacommunity}}{}{}%
\pysigstopmultiline
\end{fulllineitems}

\index{Metacommunity::\textasciitilde{}Metacommunity (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Metacommunity:_CPPv2N13MetacommunityD0Ev}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_Metacommunity:necsimclass_metacommunity_1a41711a34f23904297adc63f6abf3a8e4}}\pysiglinewithargsret{\sphinxbfcode{\textasciitilde{}Metacommunity}}{}{}%
\pysigstopmultiline
\end{fulllineitems}

\index{Metacommunity::setCommunityParameters (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Metacommunity:_CPPv2N13Metacommunity22setCommunityParametersEme6string}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_Metacommunity:necsimclass_metacommunity_1af9407da2a2e99848ac11ce3a426d4c8a}}\pysiglinewithargsret{void \sphinxbfcode{setCommunityParameters}}{unsigned long \sphinxstyleemphasis{community\_size\_in}, long double \sphinxstyleemphasis{speciation\_rate\_in}, string \sphinxstyleemphasis{database\_name\_in}}{}%
\pysigstopmultiline
Sets the parameters for the metacommunity. 

\begin{description}
\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{community\_size\_in}: the number of individuals in the metacommunity 

\item {} 
\sphinxcode{speciation\_rate\_in}: the speciation rate to use for metacommunity creation 

\item {} 
\sphinxcode{database\_name\_in}: the path to the database to store the metacommunity in 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{Metacommunity::checkSimulationParameters (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Metacommunity:_CPPv2N13Metacommunity25checkSimulationParametersEv}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_Metacommunity:necsimclass_metacommunity_1ad3775b6cecab860b008d15cc9c7650ea}}\pysiglinewithargsret{void \sphinxbfcode{checkSimulationParameters}}{}{}%
\pysigstopmultiline
Gets the seed and the task from the SIMULATION\_PARAMETERS database and stores them in the relevant variables. 

\begin{description}
\item[{\sphinxstylestrong{Note}}] \leavevmode
Should only be called once, and will have no effect if called multiple times. 

\end{description}


\end{fulllineitems}

\index{Metacommunity::addSpecies (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Metacommunity:_CPPv2N13Metacommunity10addSpeciesERmP8TreeNodeR3setImE}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_Metacommunity:necsimclass_metacommunity_1a8cad1a5648ff5b6b51f2441898fdad48}}\pysiglinewithargsret{void \sphinxbfcode{addSpecies}}{unsigned long \&\sphinxstyleemphasis{species\_count}, {\hyperref[\detokenize{api/class_TreeNode:_CPPv28TreeNode}]{\sphinxcrossref{TreeNode}}} *\sphinxstyleemphasis{tree\_node}, set\textless{}unsigned long\textgreater{} \&\sphinxstyleemphasis{species\_list}}{}%
\pysigstopmultiline
Speciates {\hyperref[\detokenize{api/class_TreeNode:necsimclass_tree_node}]{\sphinxcrossref{\DUrole{std,std-ref}{TreeNode}}}} and updates the species count, including adding to the set of species ids, if a new species has been selected from the metacommunity. 

\begin{description}
\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{species\_count}: the total number of species currently in the community 

\item {} 
\sphinxcode{tree\_node}: pointer to the {\hyperref[\detokenize{api/class_TreeNode:necsimclass_tree_node}]{\sphinxcrossref{\DUrole{std,std-ref}{TreeNode}}}} object for this lineage 

\item {} 
\sphinxcode{species\_list}: the set of all species ids. 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{Metacommunity::createMetacommunityNSENeutralModel (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Metacommunity:_CPPv2N13Metacommunity34createMetacommunityNSENeutralModelEv}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_Metacommunity:necsimclass_metacommunity_1a2557f1dc48f4a7aba97431ac8a8c7dbd}}\pysiglinewithargsret{void \sphinxbfcode{createMetacommunityNSENeutralModel}}{}{}%
\pysigstopmultiline
Creates the metacommunity in memory using a non-spatially\_explicit neutral model, which is run using the {\hyperref[\detokenize{api/class_Tree:necsimclass_tree}]{\sphinxcrossref{\DUrole{std,std-ref}{Tree}}}} class. 

\end{fulllineitems}

\index{Metacommunity::selectLineageFromMetacommunity (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Metacommunity:_CPPv2N13Metacommunity30selectLineageFromMetacommunityEv}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_Metacommunity:necsimclass_metacommunity_1ac1884bfd79b272d8dcb470f34f579cf1}}\pysiglinewithargsret{unsigned long \sphinxbfcode{selectLineageFromMetacommunity}}{}{}%
\pysigstopmultiline
Selects a random lineage from the metacommunity (rOut), which should be a cumulative sum of species abundances. Performs a binary search on rOut. 

\begin{description}
\item[{\sphinxstylestrong{Return}}] \leavevmode
the species id for the lineage 

\end{description}


\end{fulllineitems}

\index{Metacommunity::apply (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Metacommunity:_CPPv2N13Metacommunity5applyEP17SpecSimParameters}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_Metacommunity:necsimclass_metacommunity_1adf30667aa617bc969706eab2facd5482}}\pysiglinewithargsret{void \sphinxbfcode{apply}}{{\hyperref[\detokenize{api/class_SpecSimParameters:_CPPv217SpecSimParameters}]{\sphinxcrossref{SpecSimParameters}}} *\sphinxstyleemphasis{sp}}{}%
\pysigstopmultiline
Applies the speciation parameters to the completed simulation, including running the spatially-implicit for the metacommunity structure. 

\begin{description}
\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{sp}: the speciation parameters to apply 

\end{itemize}

\end{description}


\end{fulllineitems}

\paragraph{Protected Attributes}
\index{Metacommunity::community\_size (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Metacommunity:_CPPv2N13Metacommunity14community_sizeE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{api/class_Metacommunity:necsimclass_metacommunity_1a3b392090e764ffb2ada3881e4eddd0b1}}unsigned long \sphinxbfcode{community\_size}}%
\pysigstopmultiline
\end{fulllineitems}

\index{Metacommunity::speciation\_rate (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Metacommunity:_CPPv2N13Metacommunity15speciation_rateE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{api/class_Metacommunity:necsimclass_metacommunity_1aad4378b40264345fc6f5116aedc58c26}}long double \sphinxbfcode{speciation\_rate}}%
\pysigstopmultiline
\end{fulllineitems}

\index{Metacommunity::seed (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Metacommunity:_CPPv2N13Metacommunity4seedE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{api/class_Metacommunity:necsimclass_metacommunity_1afd81750697ac8540b71de001ee53fc61}}unsigned long \sphinxbfcode{seed}}%
\pysigstopmultiline
\end{fulllineitems}

\index{Metacommunity::task (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Metacommunity:_CPPv2N13Metacommunity4taskE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{api/class_Metacommunity:necsimclass_metacommunity_1a094dfd2d0bb737a1f5bd06ceb3c6da1f}}unsigned long \sphinxbfcode{task}}%
\pysigstopmultiline
\end{fulllineitems}

\index{Metacommunity::parameters\_checked (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Metacommunity:_CPPv2N13Metacommunity18parameters_checkedE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{api/class_Metacommunity:necsimclass_metacommunity_1a8b0ca689c1c638e49424d59fadb2e28d}}bool \sphinxbfcode{parameters\_checked}}%
\pysigstopmultiline
\end{fulllineitems}

\index{Metacommunity::metacommunity\_cumulative\_abundances (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Metacommunity:_CPPv2N13Metacommunity35metacommunity_cumulative_abundancesE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{api/class_Metacommunity:necsimclass_metacommunity_1ae9ef6b36732d3269baef697b5341c0b9}}{\hyperref[\detokenize{api/class_Row:_CPPv23Row}]{\sphinxcrossref{Row}}}\textless{}unsigned long\textgreater{} *\sphinxbfcode{metacommunity\_cumulative\_abundances}}%
\pysigstopmultiline
\end{fulllineitems}

\index{Metacommunity::random (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Metacommunity:_CPPv2N13Metacommunity6randomE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{api/class_Metacommunity:necsimclass_metacommunity_1aa47b2ff3f6944143f8e734d0988d2ff3}}{\hyperref[\detokenize{api/class_NRrand:_CPPv26NRrand}]{\sphinxcrossref{NRrand}}} \sphinxbfcode{random}}%
\pysigstopmultiline
\end{fulllineitems}

\index{Metacommunity::metacommunity\_tree (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Metacommunity:_CPPv2N13Metacommunity18metacommunity_treeE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{api/class_Metacommunity:necsimclass_metacommunity_1a85e91103025feb641bf0df9d02152b99}}{\hyperref[\detokenize{api/class_Tree:_CPPv24Tree}]{\sphinxcrossref{Tree}}} \sphinxbfcode{metacommunity\_tree}}%
\pysigstopmultiline
\end{fulllineitems}


\end{fulllineitems}



\subsection{Class NRrand}
\label{\detokenize{api/class_NRrand:class-nrrand}}\label{\detokenize{api/class_NRrand::doc}}\label{\detokenize{api/class_NRrand:id1}}\begin{itemize}
\item {} 
Defined in {\hyperref[\detokenize{api/file_necsim_NRrand.h:file-necsim-nrrand-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File NRrand.h}}}}

\end{itemize}


\subsubsection{Class Documentation}
\label{\detokenize{api/class_NRrand:class-documentation}}\index{NRrand (C++ class)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_NRrand:_CPPv26NRrand}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_NRrand:necsimclass_n_rrand}}\pysigline{\sphinxstrong{class }\sphinxcode{}\sphinxbfcode{NRrand}}%
\pysigstopmultiline
Contains the functions for random number generation. 
\paragraph{Public Functions}
\index{NRrand::NRrand (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_NRrand:_CPPv2N6NRrand6NRrandEv}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_NRrand:necsimclass_n_rrand_1a674521c4c29a6cb692f343ea9cf6a40c}}\pysiglinewithargsret{\sphinxbfcode{NRrand}}{}{}%
\pysigstopmultiline
Standard constructor. 

\end{fulllineitems}

\index{NRrand::setSeed (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_NRrand:_CPPv2N6NRrand7setSeedEl}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_NRrand:necsimclass_n_rrand_1a23325b4d35ee0b5b580726db05e2b8a3}}\pysiglinewithargsret{void \sphinxbfcode{setSeed}}{long \sphinxstyleemphasis{seed}}{}%
\pysigstopmultiline
Sets the seed to the given input. Is only seeded if the seed hasn't already been provided. 

\begin{description}
\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{seed}: the input seed. 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{NRrand::d01 (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_NRrand:_CPPv2N6NRrand3d01Ev}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_NRrand:necsimclass_n_rrand_1a0043ba1c33b3dcb3b98210fb432f9f6c}}\pysiglinewithargsret{double \sphinxbfcode{d01}}{}{}%
\pysigstopmultiline
The random number generator. Uses Schrage's method and a shuffle table to generate the output. 

\begin{description}
\item[{\sphinxstylestrong{Return}}] \leavevmode
the random number (a double between 0 and 1). 

\end{description}


\end{fulllineitems}

\index{NRrand::i0 (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_NRrand:_CPPv2N6NRrand2i0Em}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_NRrand:necsimclass_n_rrand_1abb6db53dd1fdd9388b39e5dcd26c13ac}}\pysiglinewithargsret{unsigned long \sphinxbfcode{i0}}{unsigned long \sphinxstyleemphasis{max}}{}%
\pysigstopmultiline
Generates a random number uniformly from 0 to the maximum value provided. 

\begin{description}
\item[{\sphinxstylestrong{Return}}] \leavevmode
an integer of the produced random number. 

\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{max}: the maximum number. 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{NRrand::norm (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_NRrand:_CPPv2N6NRrand4normEv}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_NRrand:necsimclass_n_rrand_1aa57a6e9bae94c2df5a00473ba6fa900d}}\pysiglinewithargsret{double \sphinxbfcode{norm}}{}{}%
\pysigstopmultiline
Generates a normally distributed number Uses the standard normal distribution from a Box-Muller transform. 

\begin{description}
\item[{\sphinxstylestrong{Return}}] \leavevmode
the random number from a normal distribution. 

\end{description}


\end{fulllineitems}

\index{NRrand::norm2D (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_NRrand:_CPPv2N6NRrand6norm2DEv}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_NRrand:necsimclass_n_rrand_1a754e5083299d12c1b33e8c66519d057e}}\pysiglinewithargsret{double \sphinxbfcode{norm2D}}{}{}%
\pysigstopmultiline
Returns a 2 dimensional call from a normal distribution, giving a distance in cartesian space This way is slightly inefficient for normal distributions, but it's kept this way to make the {\hyperref[\detokenize{api/class_Map:necsimclass_map_1a7c5b0623134a33511d7c17626c967176}]{\sphinxcrossref{\DUrole{std,std-ref}{Map::runDispersal()}}}} function applicable with any dispersal type. 

\begin{description}
\item[{\sphinxstylestrong{Return}}] \leavevmode
dispersal distance of a normal distribution 

\end{description}


\end{fulllineitems}

\index{NRrand::setDispersalParams (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_NRrand:_CPPv2N6NRrand18setDispersalParamsEKdKd}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_NRrand:necsimclass_n_rrand_1a5679f458940de730f527772ca27db5ad}}\pysiglinewithargsret{void \sphinxbfcode{setDispersalParams}}{\sphinxstrong{const} double \sphinxstyleemphasis{sigmain}, \sphinxstrong{const} double \sphinxstyleemphasis{tauin}}{}%
\pysigstopmultiline
Sets the dispersal parameters, avoiding requirement to provide these numbers each function call. This is only relevant for fat-tailed dispersal calls. 

\begin{description}
\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{sigmain}: the fatness of the fat-tailed dispersal kernel. 

\item {} 
\sphinxcode{tauin}: the width of the fat-tailed dispersal kernel. 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{NRrand::fattail (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_NRrand:_CPPv2N6NRrand7fattailEd}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_NRrand:necsimclass_n_rrand_1a464101f3def678477f9156d0bd1aab54}}\pysiglinewithargsret{double \sphinxbfcode{fattail}}{double \sphinxstyleemphasis{z}}{}%
\pysigstopmultiline
Call from the fat-tailed dispersal kernel with the provided sigma. 

\begin{description}
\item[{\sphinxstylestrong{Return}}] \leavevmode
a random number drawn from the fat-tailed dispersal kernel. 

\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{z}: the desired sigma. 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{NRrand::fattail (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_NRrand:_CPPv2N6NRrand7fattailEv}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_NRrand:necsimclass_n_rrand_1a3ec8aae87ae486ddfb5ad481a7972c27}}\pysiglinewithargsret{double \sphinxbfcode{fattail}}{}{}%
\pysigstopmultiline
Call from fat-tailed dispersal kernel. This function requires {\hyperref[\detokenize{api/class_NRrand:necsimclass_n_rrand_1a5679f458940de730f527772ca27db5ad}]{\sphinxcrossref{\DUrole{std,std-ref}{setDispersalParams()}}}} has already been called. 

\begin{description}
\item[{\sphinxstylestrong{Return}}] \leavevmode
a random number drawn from the fat-tailed dispersal kernel. 

\end{description}


\end{fulllineitems}

\index{NRrand::fattail\_old (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_NRrand:_CPPv2N6NRrand11fattail_oldEv}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_NRrand:necsimclass_n_rrand_1aab0ec97e2c0f74cf38cc7047356cae5c}}\pysiglinewithargsret{double \sphinxbfcode{fattail\_old}}{}{}%
\pysigstopmultiline
Old version of the function call reparameterised for different nu and sigma. 

\begin{description}
\item[{\sphinxstylestrong{Return}}] \leavevmode
a random number drawn from the fat-tailed dispersal kernel. 

\end{description}


\end{fulllineitems}

\index{NRrand::direction (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_NRrand:_CPPv2N6NRrand9directionEv}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_NRrand:necsimclass_n_rrand_1aef021289f62893215204589af450bf65}}\pysiglinewithargsret{double \sphinxbfcode{direction}}{}{}%
\pysigstopmultiline
Generates a direction in radians. 

\begin{description}
\item[{\sphinxstylestrong{Return}}] \leavevmode
the direction in radians 

\end{description}


\end{fulllineitems}

\index{NRrand::event (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_NRrand:_CPPv2N6NRrand5eventEd}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_NRrand:necsimclass_n_rrand_1a7c7a2dc1b3f14ebaaa0e6edd6c1d517a}}\pysiglinewithargsret{bool \sphinxbfcode{event}}{double \sphinxstyleemphasis{event\_probability}}{}%
\pysigstopmultiline
For a given event probability, returns the probability that the event has occured. 

\begin{description}
\item[{\sphinxstylestrong{Return}}] \leavevmode
whether or not the event has occured. 

\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{event\_probability}: the event probability. 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{NRrand::normUniform (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_NRrand:_CPPv2N6NRrand11normUniformEv}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_NRrand:necsimclass_n_rrand_1ab18277b2f873878602e82672b272c9be}}\pysiglinewithargsret{double \sphinxbfcode{normUniform}}{}{}%
\pysigstopmultiline
Normal distribution, with percentage chance to choose a uniform distribution instead. 

\begin{description}
\item[{\sphinxstylestrong{Note}}] \leavevmode
This function will not produce the same output as {\hyperref[\detokenize{api/class_NRrand:necsimclass_n_rrand_1aa57a6e9bae94c2df5a00473ba6fa900d}]{\sphinxcrossref{\DUrole{std,std-ref}{norm()}}}} for the same parameters, even with a zero chance of picking from the uniform distribution (due to random number draws). 

\item[{\sphinxstylestrong{Return}}] \leavevmode
normally (or uniformly) distributed number 

\end{description}


\end{fulllineitems}

\index{NRrand::uniformUniform (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_NRrand:_CPPv2N6NRrand14uniformUniformEv}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_NRrand:necsimclass_n_rrand_1a799f55c57dc238f094a20e882e3abb51}}\pysiglinewithargsret{double \sphinxbfcode{uniformUniform}}{}{}%
\pysigstopmultiline
Two uniform distributions, the first between 0 and 0.1*cutoff, and the second between 0.9*cutoff and cutoff. Selects from both distributions equally. 

\begin{description}
\item[{\sphinxstylestrong{Note}}] \leavevmode
The mean for this function should be identical to a uniform distribution between 0 and cutoff. 

\item[{\sphinxstylestrong{Return}}] \leavevmode
uniformly distributed number 

\end{description}


\end{fulllineitems}

\index{NRrand::setDispersalMethod (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_NRrand:_CPPv2N6NRrand18setDispersalMethodERK6stringRKdRKd}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_NRrand:necsimclass_n_rrand_1a432b648073ccd3cb7f8215bb5c299619}}\pysiglinewithargsret{void \sphinxbfcode{setDispersalMethod}}{\sphinxstrong{const} string \&\sphinxstyleemphasis{dispersal\_method}, \sphinxstrong{const} double \&\sphinxstyleemphasis{m\_probin}, \sphinxstrong{const} double \&\sphinxstyleemphasis{cutoffin}}{}%
\pysigstopmultiline
Sets the dispersal method by creating the link between dispersalFunction() and the correct dispersal character. 

\begin{description}
\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{dispersal\_method}: string containing the dispersal type. Can be one of {[}normal, fat-tail, norm-uniform{]} 

\item {} 
\sphinxcode{m\_probin}: the probability of drawing from the uniform distribution. Only relevant for uniform dispersals. 

\item {} 
\sphinxcode{cutoffin}: the maximum value to be drawn from the uniform dispersal. Only relevant for uniform dispersals. 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{NRrand::dispersal (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_NRrand:_CPPv2N6NRrand9dispersalEv}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_NRrand:necsimclass_n_rrand_1a1e15746ff8398488245b750325f37b08}}\pysiglinewithargsret{double \sphinxbfcode{dispersal}}{}{}%
\pysigstopmultiline
Runs the dispersal with the allocated dispersal function. 

\begin{description}
\item[{\sphinxstylestrong{Note}}] \leavevmode
This function will never return a value larger than the size of LONG\_MAX to avoid issues of converting doubles to integers. For dispersal distance within coalescence simulations, this is seemed a reasonable assumption, but may cause issues if code is re-used in later projects.

\item[{\sphinxstylestrong{Return}}] \leavevmode
distance the dispersal distance 

\end{description}


\end{fulllineitems}

\paragraph{Friends}
\index{operator\textless{}\textless{} (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_NRrand:_CPPv2lsR7ostreamRK6NRrand}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_NRrand:necsimclass_n_rrand_1a604ebc1c878ab63df21e123dbd34185f}}\pysiglinewithargsret{ostream \&\sphinxbfcode{operator\textless{}\textless{}}}{ostream \&\sphinxstyleemphasis{os}, \sphinxstrong{const} {\hyperref[\detokenize{api/class_NRrand:_CPPv26NRrand}]{\sphinxcrossref{NRrand}}} \&\sphinxstyleemphasis{r}}{}%
\pysigstopmultiline
Outputs the {\hyperref[\detokenize{api/class_NRrand:necsimclass_n_rrand}]{\sphinxcrossref{\DUrole{std,std-ref}{NRrand}}}} object to the output stream. Used for saving the object to file. 

\begin{description}
\item[{\sphinxstylestrong{Return}}] \leavevmode
the output stream. 

\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{os}: the output stream. 

\item {} 
\sphinxcode{r}: the {\hyperref[\detokenize{api/class_NRrand:necsimclass_n_rrand}]{\sphinxcrossref{\DUrole{std,std-ref}{NRrand}}}} object to output. 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{operator\textgreater{}\textgreater{} (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_NRrand:_CPPv2rsR7istreamR6NRrand}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_NRrand:necsimclass_n_rrand_1a0b8544414e90bb92ba90afa881b1f06e}}\pysiglinewithargsret{istream \&\sphinxbfcode{operator\textgreater{}\textgreater{}}}{istream \&\sphinxstyleemphasis{is}, {\hyperref[\detokenize{api/class_NRrand:_CPPv26NRrand}]{\sphinxcrossref{NRrand}}} \&\sphinxstyleemphasis{r}}{}%
\pysigstopmultiline
Inputs the {\hyperref[\detokenize{api/class_NRrand:necsimclass_n_rrand}]{\sphinxcrossref{\DUrole{std,std-ref}{NRrand}}}} object from the input stream. Used for reading the {\hyperref[\detokenize{api/class_NRrand:necsimclass_n_rrand}]{\sphinxcrossref{\DUrole{std,std-ref}{NRrand}}}} object from a file. 

\begin{description}
\item[{\sphinxstylestrong{Return}}] \leavevmode
the input stream. 

\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{is}: the input stream. 

\item {} 
\sphinxcode{r}: the {\hyperref[\detokenize{api/class_NRrand:necsimclass_n_rrand}]{\sphinxcrossref{\DUrole{std,std-ref}{NRrand}}}} object to input to. 

\end{itemize}

\end{description}


\end{fulllineitems}


\end{fulllineitems}



\subsection{Class ProtractedSpatialTree}
\label{\detokenize{api/class_ProtractedSpatialTree:class-protractedspatialtree}}\label{\detokenize{api/class_ProtractedSpatialTree::doc}}\label{\detokenize{api/class_ProtractedSpatialTree:id1}}\begin{itemize}
\item {} 
Defined in {\hyperref[\detokenize{api/file_necsim_ProtractedSpatialTree.h:file-necsim-protractedspatialtree-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File ProtractedSpatialTree.h}}}}

\end{itemize}


\subsubsection{Inheritance Relationships}
\label{\detokenize{api/class_ProtractedSpatialTree:inheritance-relationships}}

\paragraph{Base Types}
\label{\detokenize{api/class_ProtractedSpatialTree:base-types}}\begin{itemize}
\item {} 
\sphinxcode{public SpatialTree} ({\hyperref[\detokenize{api/class_SpatialTree:class-spatialtree}]{\sphinxcrossref{\DUrole{std,std-ref}{Class SpatialTree}}}})

\item {} 
\sphinxcode{public ProtractedTree} ({\hyperref[\detokenize{api/class_ProtractedTree:class-protractedtree}]{\sphinxcrossref{\DUrole{std,std-ref}{Class ProtractedTree}}}})

\end{itemize}


\subsubsection{Class Documentation}
\label{\detokenize{api/class_ProtractedSpatialTree:class-documentation}}\index{ProtractedSpatialTree (C++ class)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_ProtractedSpatialTree:_CPPv221ProtractedSpatialTree}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_ProtractedSpatialTree:necsimclass_protracted_spatial_tree}}\pysigline{\sphinxstrong{class }\sphinxcode{}\sphinxbfcode{ProtractedSpatialTree}}%
\pysigstopmultiline
Inherits from {\hyperref[\detokenize{api/class_SpatialTree:necsimclass_spatial_tree}]{\sphinxcrossref{\DUrole{std,std-ref}{SpatialTree}}}}, {\hyperref[\detokenize{api/class_ProtractedTree:necsimclass_protracted_tree}]{\sphinxcrossref{\DUrole{std,std-ref}{ProtractedTree}}}}

\end{fulllineitems}



\subsection{Class ProtractedTree}
\label{\detokenize{api/class_ProtractedTree:id1}}\label{\detokenize{api/class_ProtractedTree::doc}}\label{\detokenize{api/class_ProtractedTree:class-protractedtree}}\begin{itemize}
\item {} 
Defined in {\hyperref[\detokenize{api/file_necsim_ProtractedTree.h:file-necsim-protractedtree-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File ProtractedTree.h}}}}

\end{itemize}


\subsubsection{Inheritance Relationships}
\label{\detokenize{api/class_ProtractedTree:inheritance-relationships}}

\paragraph{Base Type}
\label{\detokenize{api/class_ProtractedTree:base-type}}\begin{itemize}
\item {} 
\sphinxcode{public Tree} ({\hyperref[\detokenize{api/class_Tree:class-tree}]{\sphinxcrossref{\DUrole{std,std-ref}{Class Tree}}}})

\end{itemize}


\paragraph{Derived Type}
\label{\detokenize{api/class_ProtractedTree:derived-type}}\begin{itemize}
\item {} 
\sphinxcode{public ProtractedSpatialTree} ({\hyperref[\detokenize{api/class_ProtractedSpatialTree:class-protractedspatialtree}]{\sphinxcrossref{\DUrole{std,std-ref}{Class ProtractedSpatialTree}}}})

\end{itemize}


\subsubsection{Class Documentation}
\label{\detokenize{api/class_ProtractedTree:class-documentation}}\index{ProtractedTree (C++ class)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_ProtractedTree:_CPPv214ProtractedTree}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_ProtractedTree:necsimclass_protracted_tree}}\pysigline{\sphinxstrong{class }\sphinxcode{}\sphinxbfcode{ProtractedTree}}%
\pysigstopmultiline
\begin{description}
\item[{\sphinxstylestrong{Author}}] \leavevmode
Sam Thompson 

\item[{\sphinxstylestrong{Date}}] \leavevmode
10/07/2017 

\end{description}


Inherits from {\hyperref[\detokenize{api/class_Tree:necsimclass_tree}]{\sphinxcrossref{\DUrole{std,std-ref}{Tree}}}}

Subclassed by {\hyperref[\detokenize{api/class_ProtractedSpatialTree:necsimclass_protracted_spatial_tree}]{\sphinxcrossref{\DUrole{std,std-ref}{ProtractedSpatialTree}}}}
\paragraph{Public Functions}
\index{ProtractedTree::ProtractedTree (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_ProtractedTree:_CPPv2N14ProtractedTree14ProtractedTreeEv}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_ProtractedTree:necsimclass_protracted_tree_1a43bd50d3c1092727160413dffd11df41}}\pysiglinewithargsret{\sphinxbfcode{ProtractedTree}}{}{}%
\pysigstopmultiline
\end{fulllineitems}

\index{ProtractedTree::calcSpeciation (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_ProtractedTree:_CPPv2N14ProtractedTree14calcSpeciationERKeRKeRKm}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_ProtractedTree:necsimclass_protracted_tree_1af9690f122e77c0a60d363af3e818c9a2}}\pysiglinewithargsret{bool \sphinxbfcode{calcSpeciation}}{\sphinxstrong{const} long double \&\sphinxstyleemphasis{random\_number}, \sphinxstrong{const} long double \&\sphinxstyleemphasis{speciation\_rate}, \sphinxstrong{const} unsigned long \&\sphinxstyleemphasis{no\_generations}}{}%
\pysigstopmultiline
Calculates the speciation probability from the random number, speciation rate and number of generations a lineage has existed for. 

\begin{description}
\item[{\sphinxstylestrong{Return}}] \leavevmode
if true, speciation has occured 

\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{random\_number}: the generated random number from 0-1 

\item {} 
\sphinxcode{speciation\_rate}: the speciation rate to be applied 

\item {} 
\sphinxcode{no\_generations}: the number of generations a lineage has existed for 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{ProtractedTree::speciateLineage (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_ProtractedTree:_CPPv2N14ProtractedTree15speciateLineageERKm}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_ProtractedTree:necsimclass_protracted_tree_1aaa2f1db86b0fd49a69d0809bd1c1fb81}}\pysiglinewithargsret{void \sphinxbfcode{speciateLineage}}{\sphinxstrong{const} unsigned long \&\sphinxstyleemphasis{data\_position}}{}%
\pysigstopmultiline
Performs the actual speciation. Includes handling of speciated lineages under protracted conditions. 

\begin{description}
\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{data\_position}: the position in the array of TreeNodes for this lineage 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{ProtractedTree::getProtracted (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_ProtractedTree:_CPPv2N14ProtractedTree13getProtractedEv}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_ProtractedTree:necsimclass_protracted_tree_1ab0bb05fbdeb2aa75a3d3128ded3d655b}}\pysiglinewithargsret{bool \sphinxbfcode{getProtracted}}{}{}%
\pysigstopmultiline
Gets the protractedness of the simulation. Overridden by protracted child classes. 

\begin{description}
\item[{\sphinxstylestrong{Return}}] \leavevmode


\end{description}


\end{fulllineitems}

\index{ProtractedTree::setProtractedVariables (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_ProtractedTree:_CPPv2N14ProtractedTree22setProtractedVariablesEdd}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_ProtractedTree:necsimclass_protracted_tree_1a6e04aa92dd30e889a468d9b9fc6fd58d}}\pysiglinewithargsret{void \sphinxbfcode{setProtractedVariables}}{double \sphinxstyleemphasis{speciation\_gen\_min}, double \sphinxstyleemphasis{speciation\_gen\_max}}{}%
\pysigstopmultiline
Sets the protracted variables. 

\begin{description}
\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{speciation\_gen\_min}: the minimum number of generations to have passed before speciation is allowed 

\item {} 
\sphinxcode{speciation\_gen\_max}: the maximum number of generations a lineage can exist for before it is speciated. 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{ProtractedTree::getProtractedVariables (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_ProtractedTree:_CPPv2N14ProtractedTree22getProtractedVariablesEv}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_ProtractedTree:necsimclass_protracted_tree_1af0eca5eb2a790fcee9a0854e30088753}}\pysiglinewithargsret{string \sphinxbfcode{getProtractedVariables}}{}{}%
\pysigstopmultiline
Gets the protracted variables and returns them as a single, newline separated string. 

\begin{description}
\item[{\sphinxstylestrong{Return}}] \leavevmode
string containing the protracted variables, separated by newlines. 

\end{description}


\end{fulllineitems}

\index{ProtractedTree::getProtractedGenerationMin (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_ProtractedTree:_CPPv2N14ProtractedTree26getProtractedGenerationMinEv}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_ProtractedTree:necsimclass_protracted_tree_1a331561815abc7d595e88d98e9268e7a1}}\pysiglinewithargsret{double \sphinxbfcode{getProtractedGenerationMin}}{}{}%
\pysigstopmultiline
Gets the minimum number of generations a lineage must exist. 

\begin{description}
\item[{\sphinxstylestrong{Return}}] \leavevmode
double the number of generations a lineage must exist 

\end{description}


\end{fulllineitems}

\index{ProtractedTree::getProtractedGenerationMax (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_ProtractedTree:_CPPv2N14ProtractedTree26getProtractedGenerationMaxEv}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_ProtractedTree:necsimclass_protracted_tree_1a2093dd13cdbfc66e6c1de1406023bad6}}\pysiglinewithargsret{double \sphinxbfcode{getProtractedGenerationMax}}{}{}%
\pysigstopmultiline
Gets the maximum number of generations a lineage can exist. 

\begin{description}
\item[{\sphinxstylestrong{Return}}] \leavevmode
double the number of generations a lineage must exist 

\end{description}


\end{fulllineitems}

\index{ProtractedTree::protractedVarsToString (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_ProtractedTree:_CPPv2N14ProtractedTree22protractedVarsToStringEv}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_ProtractedTree:necsimclass_protracted_tree_1a505a464578e6a7028e66f26b3e6b4a92}}\pysiglinewithargsret{string \sphinxbfcode{protractedVarsToString}}{}{}%
\pysigstopmultiline
Outputs the protracted variables to a string. 

This function is intended to be overridden by derived classes. It is intended the output is used for writing to SQL databases.

\begin{description}
\item[{\sphinxstylestrong{Return}}] \leavevmode
string containing a list of the protracted speciation variables. 

\end{description}


\end{fulllineitems}

\index{ProtractedTree::applySpecRate (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_ProtractedTree:_CPPv2N14ProtractedTree13applySpecRateEdd}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_ProtractedTree:necsimclass_protracted_tree_1a56a3631e65bb91d04ba4626c4c1ea79a}}\pysiglinewithargsret{void \sphinxbfcode{applySpecRate}}{double \sphinxstyleemphasis{sr}, double \sphinxstyleemphasis{t}}{}%
\pysigstopmultiline
Applies the given speciation rate to the tree. 

\begin{description}
\item[{\sphinxstylestrong{Note}}] \leavevmode
Currently this just copies code from the version in tree, which is not ideal, but this avoids creating an extra function.

\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{sr}: the required speciation rate 

\end{itemize}

\end{description}


\end{fulllineitems}


\end{fulllineitems}



\subsection{Class ReproductionMap}
\label{\detokenize{api/class_ReproductionMap::doc}}\label{\detokenize{api/class_ReproductionMap:class-reproductionmap}}\label{\detokenize{api/class_ReproductionMap:id1}}\begin{itemize}
\item {} 
Defined in {\hyperref[\detokenize{api/file_necsim_ReproductionMap.h:file-necsim-reproductionmap-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File ReproductionMap.h}}}}

\end{itemize}


\subsubsection{Class Documentation}
\label{\detokenize{api/class_ReproductionMap:class-documentation}}\index{ReproductionMap (C++ class)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_ReproductionMap:_CPPv215ReproductionMap}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_ReproductionMap:necsimclass_reproduction_map}}\pysigline{\sphinxstrong{class }\sphinxcode{}\sphinxbfcode{ReproductionMap}}%
\pysigstopmultiline
Contains the routines for importing the reproduction map and getting a cell value from the map. 
\paragraph{Public Functions}
\index{ReproductionMap::ReproductionMap (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_ReproductionMap:_CPPv2N15ReproductionMap15ReproductionMapEv}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_ReproductionMap:necsimclass_reproduction_map_1ad516d66b4de5eaacb076f96f911f3797}}\pysiglinewithargsret{\sphinxbfcode{ReproductionMap}}{}{}%
\pysigstopmultiline
\end{fulllineitems}

\index{ReproductionMap::import (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_ReproductionMap:_CPPv2N15ReproductionMap6importE6stringmm}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_ReproductionMap:necsimclass_reproduction_map_1a144d2f39ff2e978acd9d2ebcb6f8dc97}}\pysiglinewithargsret{void \sphinxbfcode{import}}{string \sphinxstyleemphasis{file\_name}, unsigned long \sphinxstyleemphasis{size\_x}, unsigned long \sphinxstyleemphasis{size\_y}}{}%
\pysigstopmultiline
Imports the map file from the given path Requires the dimensions to be identical as the fine map file dimensions. 

\begin{description}
\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{file\_name}: the path to the reproduction map to import 

\item {} 
\sphinxcode{size\_x}: the x dimensions of the map file 

\item {} 
\sphinxcode{size\_y}: the y dimensions of the map file 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{ReproductionMap::setReproductionFunction (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_ReproductionMap:_CPPv2N15ReproductionMap23setReproductionFunctionEv}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_ReproductionMap:necsimclass_reproduction_map_1afc0419bc78ce9a4813212360c67b49a2}}\pysiglinewithargsret{void \sphinxbfcode{setReproductionFunction}}{}{}%
\pysigstopmultiline
Correctly sets the reproduction function to either rejectionSampleNull or rejectionSample depending on if a reproduction map is used or not. 

\end{fulllineitems}

\index{ReproductionMap::setOffsets (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_ReproductionMap:_CPPv2N15ReproductionMap10setOffsetsERKmRKmRKmRKm}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_ReproductionMap:necsimclass_reproduction_map_1aba75d30a9d2c7cd8aa06db17af286f7d}}\pysiglinewithargsret{void \sphinxbfcode{setOffsets}}{\sphinxstrong{const} unsigned long \&\sphinxstyleemphasis{x\_offset}, \sphinxstrong{const} unsigned long \&\sphinxstyleemphasis{y\_offset}, \sphinxstrong{const} unsigned long \&\sphinxstyleemphasis{xdim}, \sphinxstrong{const} unsigned long \&\sphinxstyleemphasis{ydim}}{}%
\pysigstopmultiline
Sets the offsets for the reproduction map from the sample grid. 

\begin{description}
\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{x\_offset}: the x offset from the sample grid 

\item {} 
\sphinxcode{y\_offset}: the y offset from the sample grid 

\item {} 
\sphinxcode{xdim}: the x dimension of the sample grid 

\item {} 
\sphinxcode{ydim}: the y dimension of the sample grid 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{ReproductionMap::rejectionSampleNull (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_ReproductionMap:_CPPv2N15ReproductionMap19rejectionSampleNullER6NRrandRKmRKmRKlRKl}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_ReproductionMap:necsimclass_reproduction_map_1a80dfa3194b7acabd813d9ae6b4ae3671}}\pysiglinewithargsret{bool \sphinxbfcode{rejectionSampleNull}}{{\hyperref[\detokenize{api/class_NRrand:_CPPv26NRrand}]{\sphinxcrossref{NRrand}}} \&\sphinxstyleemphasis{random\_number}, \sphinxstrong{const} unsigned long \&\sphinxstyleemphasis{x}, \sphinxstrong{const} unsigned long \&\sphinxstyleemphasis{y}, \sphinxstrong{const} long \&\sphinxstyleemphasis{xwrap}, \sphinxstrong{const} long \&\sphinxstyleemphasis{ywrap}}{}%
\pysigstopmultiline
Returns true for all cell values Function to be pointed to in cases where there is no reproduction map. 

\begin{description}
\item[{\sphinxstylestrong{Return}}] \leavevmode
true always 

\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{random\_number}: random number object to pass forward 

\item {} 
\sphinxcode{x}: x coordinate of the lineage on the sample grid 

\item {} 
\sphinxcode{y}: y coordinate of the lineage on the sample grid 

\item {} 
\sphinxcode{xwrap}: x wrapping of the lineage 

\item {} 
\sphinxcode{ywrap}: y wrapping of the lineage 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{ReproductionMap::rejectionSample (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_ReproductionMap:_CPPv2N15ReproductionMap15rejectionSampleER6NRrandRKmRKmRKlRKl}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_ReproductionMap:necsimclass_reproduction_map_1a2dccd14c9d4cdc1b14a63e7d95eba0ae}}\pysiglinewithargsret{bool \sphinxbfcode{rejectionSample}}{{\hyperref[\detokenize{api/class_NRrand:_CPPv26NRrand}]{\sphinxcrossref{NRrand}}} \&\sphinxstyleemphasis{random\_number}, \sphinxstrong{const} unsigned long \&\sphinxstyleemphasis{x}, \sphinxstrong{const} unsigned long \&\sphinxstyleemphasis{y}, \sphinxstrong{const} long \&\sphinxstyleemphasis{xwrap}, \sphinxstrong{const} long \&\sphinxstyleemphasis{ywrap}}{}%
\pysigstopmultiline
Returns true for all cell values Function to be pointed to in cases where there is no reproduction map. 

\begin{description}
\item[{\sphinxstylestrong{Return}}] \leavevmode
true always 

\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{random\_number}: random number object to pass forward 

\item {} 
\sphinxcode{x}: x coordinate of the lineage on the sample grid 

\item {} 
\sphinxcode{y}: y coordinate of the lineage on the sample grid 

\item {} 
\sphinxcode{xwrap}: x wrapping of the lineage 

\item {} 
\sphinxcode{ywrap}: y wrapping of the lineage 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{ReproductionMap::getVal (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_ReproductionMap:_CPPv2N15ReproductionMap6getValERKmRKmRKlRKl}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_ReproductionMap:necsimclass_reproduction_map_1a36cb74792a8e935eec6f7fcb6af3aeb8}}\pysiglinewithargsret{double \sphinxbfcode{getVal}}{\sphinxstrong{const} unsigned long \&\sphinxstyleemphasis{x}, \sphinxstrong{const} unsigned long \&\sphinxstyleemphasis{y}, \sphinxstrong{const} long \&\sphinxstyleemphasis{xwrap}, \sphinxstrong{const} long \&\sphinxstyleemphasis{ywrap}}{}%
\pysigstopmultiline
Gets the value of the reproduction map at that location. 

\begin{description}
\item[{\sphinxstylestrong{Return}}] \leavevmode
value of the reproduction map at the required location 

\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{x}: x coordinate of the lineage on the sample grid 

\item {} 
\sphinxcode{y}: y coordinate of the lineage on the sample grid 

\item {} 
\sphinxcode{xwrap}: x wrapping of the lineage 

\item {} 
\sphinxcode{ywrap}: y wrapping of the lineage 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{ReproductionMap::hasReproduced (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_ReproductionMap:_CPPv2N15ReproductionMap13hasReproducedER6NRrandRKmRKmRKlRKl}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_ReproductionMap:necsimclass_reproduction_map_1aa8afbdf28197532a65c17035a075fe9b}}\pysiglinewithargsret{bool \sphinxbfcode{hasReproduced}}{{\hyperref[\detokenize{api/class_NRrand:_CPPv26NRrand}]{\sphinxcrossref{NRrand}}} \&\sphinxstyleemphasis{random\_number}, \sphinxstrong{const} unsigned long \&\sphinxstyleemphasis{x}, \sphinxstrong{const} unsigned long \&\sphinxstyleemphasis{y}, \sphinxstrong{const} long \&\sphinxstyleemphasis{xwrap}, \sphinxstrong{const} long \&\sphinxstyleemphasis{ywrap}}{}%
\pysigstopmultiline
\begin{description}
\item[{\sphinxstylestrong{Return}}] \leavevmode
value of the reproduction map at the required location 

\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{random\_number}: random number object to draw from 

\item {} 
\sphinxcode{x}: x coordinate of the lineage on the sample grid 

\item {} 
\sphinxcode{y}: y coordinate of the lineage on the sample grid 

\item {} 
\sphinxcode{xwrap}: x wrapping of the lineage 

\item {} 
\sphinxcode{ywrap}: y wrapping of the lineage 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{ReproductionMap::operator{[}{]} (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_ReproductionMap:_CPPv2N15ReproductionMapixEl}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_ReproductionMap:necsimclass_reproduction_map_1ad9489c17cf27be65c21f54ff20e6ccc8}}\pysiglinewithargsret{{\hyperref[\detokenize{api/class_Row:_CPPv23Row}]{\sphinxcrossref{Row}}}\textless{}double\textgreater{} \sphinxbfcode{operator{[}{]}}}{long \sphinxstyleemphasis{index}}{}%
\pysigstopmultiline
Operator {[}{]} for getting values directly from the reproduction map. 

\begin{description}
\item[{\sphinxstylestrong{Return}}] \leavevmode
the row present at that index 

\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{index}: the index to get the row of 

\end{itemize}

\end{description}


\end{fulllineitems}

\paragraph{Protected Types}
\index{ReproductionMap::rep\_ptr (C++ type)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_ReproductionMap:_CPPv2N15ReproductionMap7rep_ptrE}}%
\pysigstartmultiline
\pysiglinewithargsret{\phantomsection\label{\detokenize{api/class_ReproductionMap:necsimclass_reproduction_map_1a5edd07fa5fe2f2ecbd778f2fa20d2a88}}\sphinxstrong{typedef }bool (\sphinxbfcode{ReproductionMap}::*\sphinxbfcode{rep\_ptr})}{{\hyperref[\detokenize{api/class_NRrand:_CPPv26NRrand}]{\sphinxcrossref{NRrand}}} \&random\_no, \sphinxstrong{const} unsigned long \&x, \sphinxstrong{const} unsigned long \&y, \sphinxstrong{const} long \&xwrap, \sphinxstrong{const} long \&ywrap}{}%
\pysigstopmultiline
\end{fulllineitems}

\paragraph{Protected Attributes}
\index{ReproductionMap::reproduction\_map (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_ReproductionMap:_CPPv2N15ReproductionMap16reproduction_mapE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{api/class_ReproductionMap:necsimclass_reproduction_map_1a4092819111e3b20c8c6bbd189a81def7}}{\hyperref[\detokenize{api/class_Matrix:_CPPv26Matrix}]{\sphinxcrossref{Matrix}}}\textless{}double\textgreater{} \sphinxbfcode{reproduction\_map}}%
\pysigstopmultiline
\end{fulllineitems}

\index{ReproductionMap::map\_file (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_ReproductionMap:_CPPv2N15ReproductionMap8map_fileE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{api/class_ReproductionMap:necsimclass_reproduction_map_1a4fdefab63d92f1244422b602ef11b2ee}}string \sphinxbfcode{map\_file}}%
\pysigstopmultiline
\end{fulllineitems}

\index{ReproductionMap::max\_val (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_ReproductionMap:_CPPv2N15ReproductionMap7max_valE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{api/class_ReproductionMap:necsimclass_reproduction_map_1a093ebaad740e4d8b0873bb6e96e5e1c1}}double \sphinxbfcode{max\_val}}%
\pysigstopmultiline
\end{fulllineitems}

\index{ReproductionMap::null\_map (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_ReproductionMap:_CPPv2N15ReproductionMap8null_mapE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{api/class_ReproductionMap:necsimclass_reproduction_map_1a3ae593187d7087cb543f40fe59218257}}bool \sphinxbfcode{null\_map}}%
\pysigstopmultiline
\end{fulllineitems}

\index{ReproductionMap::offset\_x (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_ReproductionMap:_CPPv2N15ReproductionMap8offset_xE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{api/class_ReproductionMap:necsimclass_reproduction_map_1acaa2a99d3667440a1e610fd1d0ecda7e}}unsigned long \sphinxbfcode{offset\_x}}%
\pysigstopmultiline
\end{fulllineitems}

\index{ReproductionMap::offset\_y (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_ReproductionMap:_CPPv2N15ReproductionMap8offset_yE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{api/class_ReproductionMap:necsimclass_reproduction_map_1ae70ca7adb1272ed2a15287108526351b}}unsigned long \sphinxbfcode{offset\_y}}%
\pysigstopmultiline
\end{fulllineitems}

\index{ReproductionMap::x\_dim (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_ReproductionMap:_CPPv2N15ReproductionMap5x_dimE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{api/class_ReproductionMap:necsimclass_reproduction_map_1aea934c598f314851c50a9d5aa12f8035}}unsigned long \sphinxbfcode{x\_dim}}%
\pysigstopmultiline
\end{fulllineitems}

\index{ReproductionMap::y\_dim (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_ReproductionMap:_CPPv2N15ReproductionMap5y_dimE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{api/class_ReproductionMap:necsimclass_reproduction_map_1a48dcb8efff54b3734d2a560f6660dc18}}unsigned long \sphinxbfcode{y\_dim}}%
\pysigstopmultiline
\end{fulllineitems}

\index{ReproductionMap::reproductionMapChecker\_fptr (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_ReproductionMap:_CPPv2N15ReproductionMap27reproductionMapChecker_fptrE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{api/class_ReproductionMap:necsimclass_reproduction_map_1a927b35c48a2c3c32a994a95ebfb9aa87}}{\hyperref[\detokenize{api/class_ReproductionMap:_CPPv2N15ReproductionMap7rep_ptrE}]{\sphinxcrossref{rep\_ptr}}} \sphinxbfcode{reproductionMapChecker\_fptr}}%
\pysigstopmultiline
\end{fulllineitems}

\paragraph{Friends}
\index{operator\textless{}\textless{} (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_ReproductionMap:_CPPv2lsR7ostreamR15ReproductionMap}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_ReproductionMap:necsimclass_reproduction_map_1a98af33155ec460fb9b9c55fa53458262}}\pysiglinewithargsret{ostream \&\sphinxbfcode{operator\textless{}\textless{}}}{ostream \&\sphinxstyleemphasis{os}, {\hyperref[\detokenize{api/class_ReproductionMap:_CPPv215ReproductionMap}]{\sphinxcrossref{ReproductionMap}}} \&\sphinxstyleemphasis{r}}{}%
\pysigstopmultiline
Operator for outputting to an ostream. 

\begin{description}
\item[{\sphinxstylestrong{Return}}] \leavevmode
the os object 

\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{os}: the ostream to output to 

\item {} 
\sphinxcode{r}: the {\hyperref[\detokenize{api/class_ReproductionMap:necsimclass_reproduction_map}]{\sphinxcrossref{\DUrole{std,std-ref}{ReproductionMap}}}} to read from 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{operator\textgreater{}\textgreater{} (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_ReproductionMap:_CPPv2rsR7istreamR15ReproductionMap}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_ReproductionMap:necsimclass_reproduction_map_1a7cffbc069ece5bfb93d296580e22892a}}\pysiglinewithargsret{istream \&\sphinxbfcode{operator\textgreater{}\textgreater{}}}{istream \&\sphinxstyleemphasis{is}, {\hyperref[\detokenize{api/class_ReproductionMap:_CPPv215ReproductionMap}]{\sphinxcrossref{ReproductionMap}}} \&\sphinxstyleemphasis{r}}{}%
\pysigstopmultiline
Operator for inputting from an istream. 

\begin{description}
\item[{\sphinxstylestrong{Return}}] \leavevmode
the is object 

\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{is}: the istream to input from 

\item {} 
\sphinxcode{r}: the {\hyperref[\detokenize{api/class_ReproductionMap:necsimclass_reproduction_map}]{\sphinxcrossref{\DUrole{std,std-ref}{ReproductionMap}}}} to input to 

\end{itemize}

\end{description}


\end{fulllineitems}


\end{fulllineitems}



\subsection{Template Class Row}
\label{\detokenize{api/class_Row:template-class-row}}\label{\detokenize{api/class_Row::doc}}\label{\detokenize{api/class_Row:id1}}\begin{itemize}
\item {} 
Defined in {\hyperref[\detokenize{api/file_necsim_Matrix.h:file-necsim-matrix-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File Matrix.h}}}}

\end{itemize}


\subsubsection{Class Documentation}
\label{\detokenize{api/class_Row:class-documentation}}\index{Row (C++ class)}

\begin{fulllineitems}
\pysigline{\phantomsection\label{\detokenize{api/class_Row:necsimclass_row}}\sphinxstrong{template }\textless{}class \sphinxstyleemphasis{T}\textgreater{}}\phantomsection\label{\detokenize{api/class_Row:_CPPv23Row}}%
\pysigstartmultiline
\pysigline{\sphinxstrong{class }\sphinxcode{}\sphinxbfcode{Row}}%
\pysigstopmultiline
Contains a template {\hyperref[\detokenize{api/class_Row:necsimclass_row}]{\sphinxcrossref{\DUrole{std,std-ref}{Row}}}} class and basic operations. Uses an array to store the row. 
\paragraph{Public Functions}
\index{Row::Row (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Row:_CPPv2N3Row3RowEm}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_Row:necsimclass_row_1a32774cba0d7cdb6f0d7100c395ece9e5}}\pysiglinewithargsret{\sphinxbfcode{Row}}{unsigned long \sphinxstyleemphasis{cols} = 0}{}%
\pysigstopmultiline
Standard constructor. 

\begin{description}
\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{cols}: optionally provide the number of rows to initiate with. 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{Row::\textasciitilde{}Row (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Row:_CPPv2N3RowD0Ev}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_Row:necsimclass_row_1a8e888a33060156cd2e3757a95e9feee1}}\pysiglinewithargsret{\sphinxbfcode{\textasciitilde{}Row}}{}{}%
\pysigstopmultiline
Standard destructor. 

\end{fulllineitems}

\index{Row::Row (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Row:_CPPv2N3Row3RowERK3Row}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_Row:necsimclass_row_1a3c76905ddd4522c92da0d8a9e24a22a1}}\pysiglinewithargsret{\sphinxbfcode{Row}}{\sphinxstrong{const} {\hyperref[\detokenize{api/class_Row:_CPPv2N3Row3RowEm}]{\sphinxcrossref{Row}}} \&\sphinxstyleemphasis{r}}{}%
\pysigstopmultiline
Copy constructor. 

\begin{description}
\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{r}: the {\hyperref[\detokenize{api/class_Row:necsimclass_row}]{\sphinxcrossref{\DUrole{std,std-ref}{Row}}}} object to copy from. 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{Row::setSize (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Row:_CPPv2N3Row7setSizeEm}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_Row:necsimclass_row_1a4015d3cc7a22a4a4ad31ae410ab8fce4}}\pysiglinewithargsret{void \sphinxbfcode{setSize}}{unsigned long \sphinxstyleemphasis{n}}{}%
\pysigstopmultiline
Setter for the row size. 

\begin{description}
\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{n}: the number of rows to initiate with. SetRowSize() deletes any old data, and allocates space for new data, unless we set the number of columns to 0, in which case it merely deletes the data. This lets us use this function for construction, destruction, and dynamic modification in one method. 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{Row::resize (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Row:_CPPv2N3Row6resizeEm}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_Row:necsimclass_row_1aac3e65388e6ce2a003be1a1b460fab53}}\pysiglinewithargsret{void \sphinxbfcode{resize}}{unsigned long \sphinxstyleemphasis{n}}{}%
\pysigstopmultiline
Changes the size of the array. 

\begin{description}
\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{n}: the new size to change to. Note that no checks are performed that the new row size is larger than the old row size. Thus is this function is used to shrink the row size, a bad\_alloc error will likely be thrown. 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{Row::size (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Row:_CPPv2N3Row4sizeEv}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_Row:necsimclass_row_1a5fdbcb2478b0ff00d12b8b109b0eb89a}}\pysiglinewithargsret{unsigned long \sphinxbfcode{size}}{}{}%
\pysigstopmultiline
Getter for the size of the array. 

\begin{description}
\item[{\sphinxstylestrong{Return}}] \leavevmode
the number of columns. 

\end{description}


\end{fulllineitems}

\index{Row::operator{[}{]} (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Row:_CPPv2N3RowixEm}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_Row:necsimclass_row_1aecb642c8ceffbb7d6c69bc13d9de4bb0}}\pysiglinewithargsret{T \&\sphinxbfcode{operator{[}{]}}}{unsigned long \sphinxstyleemphasis{column}}{}%
\pysigstopmultiline
Overloading the {[}{]} operator to allow for simple referencing. 

\begin{description}
\item[{\sphinxstylestrong{Return}}] \leavevmode
the value in the specified column. Note that different versions deal with values outside of (0,numCols) in different ways. 

\item[{\sphinxstylestrong{Note}}] \leavevmode
updated to throw an out\_of\_range exception if the column is out of the row range. 

\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{column}: the column to get the value from. 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{Row::operator= (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Row:_CPPv2N3RowaSERK3Row}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_Row:necsimclass_row_1a877484e061eef2a179cc28d30b3ec542}}\pysiglinewithargsret{{\hyperref[\detokenize{api/class_Row:_CPPv23Row}]{\sphinxcrossref{Row}}} \&\sphinxbfcode{operator=}}{\sphinxstrong{const} {\hyperref[\detokenize{api/class_Row:_CPPv23Row}]{\sphinxcrossref{Row}}} \&\sphinxstyleemphasis{r}}{}%
\pysigstopmultiline
Overloading the = operator to allow for copying data across. 

\begin{description}
\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{r}: the {\hyperref[\detokenize{api/class_Row:necsimclass_row}]{\sphinxcrossref{\DUrole{std,std-ref}{Row}}}} object to copy data from. 

\end{itemize}

\end{description}


\end{fulllineitems}

\paragraph{Friends}
\index{operator\textless{}\textless{} (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Row:_CPPv2lsR7ostreamRK3Row}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_Row:necsimclass_row_1a8aaaee73ace04bfd4dda937bc311a16e}}\pysiglinewithargsret{ostream \&\sphinxbfcode{operator\textless{}\textless{}}}{ostream \&\sphinxstyleemphasis{os}, \sphinxstrong{const} {\hyperref[\detokenize{api/class_Row:_CPPv23Row}]{\sphinxcrossref{Row}}} \&\sphinxstyleemphasis{r}}{}%
\pysigstopmultiline
Overloading the \textless{}\textless{} operator for outputting to the output stream. 

\begin{description}
\item[{\sphinxstylestrong{Return}}] \leavevmode
os the output stream. 

\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{os}: the output stream. 

\item {} 
\sphinxcode{r}: the {\hyperref[\detokenize{api/class_Row:necsimclass_row}]{\sphinxcrossref{\DUrole{std,std-ref}{Row}}}} object to output from. 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{operator\textgreater{}\textgreater{} (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Row:_CPPv2rsR7istreamR3Row}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_Row:necsimclass_row_1adaa9bd295e9b13a99d9205911763468c}}\pysiglinewithargsret{istream \&\sphinxbfcode{operator\textgreater{}\textgreater{}}}{istream \&\sphinxstyleemphasis{is}, {\hyperref[\detokenize{api/class_Row:_CPPv23Row}]{\sphinxcrossref{Row}}} \&\sphinxstyleemphasis{r}}{}%
\pysigstopmultiline
Overloading the \textless{}\textless{} operator for inputting from an input stream. 

\begin{description}
\item[{\sphinxstylestrong{Return}}] \leavevmode
the input stream. 

\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{is}: the input stream. 

\item {} 
\sphinxcode{r}: the {\hyperref[\detokenize{api/class_Row:necsimclass_row}]{\sphinxcrossref{\DUrole{std,std-ref}{Row}}}} object to input to. 

\end{itemize}

\end{description}


\end{fulllineitems}


\end{fulllineitems}



\subsection{Class Samplematrix}
\label{\detokenize{api/class_Samplematrix::doc}}\label{\detokenize{api/class_Samplematrix:class-samplematrix}}\label{\detokenize{api/class_Samplematrix:id1}}\begin{itemize}
\item {} 
Defined in {\hyperref[\detokenize{api/file_necsim_Community.h:file-necsim-community-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File Community.h}}}}

\end{itemize}


\subsubsection{Inheritance Relationships}
\label{\detokenize{api/class_Samplematrix:inheritance-relationships}}

\paragraph{Base Type}
\label{\detokenize{api/class_Samplematrix:base-type}}\begin{itemize}
\item {} 
\sphinxcode{public DataMask} ({\hyperref[\detokenize{api/class_DataMask:class-datamask}]{\sphinxcrossref{\DUrole{std,std-ref}{Class DataMask}}}})

\end{itemize}


\subsubsection{Class Documentation}
\label{\detokenize{api/class_Samplematrix:class-documentation}}\index{Samplematrix (C++ class)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Samplematrix:_CPPv212Samplematrix}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_Samplematrix:necsimclass_samplematrix}}\pysigline{\sphinxstrong{class }\sphinxcode{}\sphinxbfcode{Samplematrix}}%
\pysigstopmultiline
A child of the {\hyperref[\detokenize{api/class_Matrix:necsimclass_matrix}]{\sphinxcrossref{\DUrole{std,std-ref}{Matrix}}}} class as booleans. Used for determining where to sample species from. 

Inherits from {\hyperref[\detokenize{api/class_DataMask:necsimclass_data_mask}]{\sphinxcrossref{\DUrole{std,std-ref}{DataMask}}}}
\paragraph{Public Functions}
\index{Samplematrix::Samplematrix (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Samplematrix:_CPPv2N12Samplematrix12SamplematrixEv}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_Samplematrix:necsimclass_samplematrix_1abe3fb4ca1e24678f2720f451cee80492}}\pysiglinewithargsret{\sphinxbfcode{Samplematrix}}{}{}%
\pysigstopmultiline
Inherit construction from the {\hyperref[\detokenize{api/class_Matrix:necsimclass_matrix}]{\sphinxcrossref{\DUrole{std,std-ref}{Matrix}}}} class, but also set the booleans. 

\end{fulllineitems}

\index{Samplematrix::getTestVal (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Samplematrix:_CPPv2N12Samplematrix10getTestValEmmll}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_Samplematrix:necsimclass_samplematrix_1a834c750ab142d1ed2241fb9ab559b704}}\pysiglinewithargsret{bool \sphinxbfcode{getTestVal}}{unsigned long \sphinxstyleemphasis{xval}, unsigned long \sphinxstyleemphasis{yval}, long \sphinxstyleemphasis{xwrap}, long \sphinxstyleemphasis{ywrap}}{}%
\pysigstopmultiline
Returns the value at the x,y position. This is used for testing purposes only. 

\begin{description}
\item[{\sphinxstylestrong{Return}}] \leavevmode
the value at x,y. 

\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{xval}: the x coordinate. 

\item {} 
\sphinxcode{yval}: the y coordinate 

\item {} 
\sphinxcode{xwrap}: the x wrapping 

\item {} 
\sphinxcode{ywrap}: the y wrapping 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{Samplematrix::getMaskVal (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Samplematrix:_CPPv2N12Samplematrix10getMaskValEmmll}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_Samplematrix:necsimclass_samplematrix_1a8b494886260857ffdc9f52f47661a628}}\pysiglinewithargsret{bool \sphinxbfcode{getMaskVal}}{unsigned long \sphinxstyleemphasis{x1}, unsigned long \sphinxstyleemphasis{y1}, long \sphinxstyleemphasis{x\_wrap}, long \sphinxstyleemphasis{y\_wrap}}{}%
\pysigstopmultiline
Returns the value at the x,y position, with the given x and y wrap. Also checks whether or not the map is set to null, or whether the value comes from within a fragment. 

\begin{description}
\item[{\sphinxstylestrong{Return}}] \leavevmode
the value at x,y. 

\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{x1}: the x coordinate. 

\item {} 
\sphinxcode{y1}: the y coordinate 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{Samplematrix::setFragment (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Samplematrix:_CPPv2N12Samplematrix11setFragmentER8Fragment}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_Samplematrix:necsimclass_samplematrix_1adbc1732a726c387965f63d4484bd4c25}}\pysiglinewithargsret{void \sphinxbfcode{setFragment}}{{\hyperref[\detokenize{api/struct_Fragment:_CPPv28Fragment}]{\sphinxcrossref{Fragment}}} \&\sphinxstyleemphasis{fragment\_in}}{}%
\pysigstopmultiline
Set the fragment for the samplemask to some calculated fragment. This can be set multiple times. 

\begin{description}
\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{fragment\_in}: the {\hyperref[\detokenize{api/struct_Fragment:necsimstruct_fragment}]{\sphinxcrossref{\DUrole{std,std-ref}{Fragment}}}} to set the samplemask to. 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{Samplematrix::removeFragment (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Samplematrix:_CPPv2N12Samplematrix14removeFragmentEv}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_Samplematrix:necsimclass_samplematrix_1a9b796f2279f1716c2a555ff3d641ea0b}}\pysiglinewithargsret{void \sphinxbfcode{removeFragment}}{}{}%
\pysigstopmultiline
Removes the fragment. 

\end{fulllineitems}


\end{fulllineitems}



\subsection{Class SimulateDispersal}
\label{\detokenize{api/class_SimulateDispersal:class-simulatedispersal}}\label{\detokenize{api/class_SimulateDispersal::doc}}\label{\detokenize{api/class_SimulateDispersal:id1}}\begin{itemize}
\item {} 
Defined in {\hyperref[\detokenize{api/file_necsim_SimulateDispersal.h:file-necsim-simulatedispersal-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File SimulateDispersal.h}}}}

\end{itemize}


\subsubsection{Class Documentation}
\label{\detokenize{api/class_SimulateDispersal:class-documentation}}\index{SimulateDispersal (C++ class)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_SimulateDispersal:_CPPv217SimulateDispersal}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_SimulateDispersal:necsimclass_simulate_dispersal}}\pysigline{\sphinxstrong{class }\sphinxcode{}\sphinxbfcode{SimulateDispersal}}%
\pysigstopmultiline
Contains routines for importing a density map file, running a dispersal kernel n times on a landscape and record the dispersal distances. 
\paragraph{Public Functions}
\index{SimulateDispersal::SimulateDispersal (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_SimulateDispersal:_CPPv2N17SimulateDispersal17SimulateDispersalEv}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_SimulateDispersal:necsimclass_simulate_dispersal_1ad05135d21e5bf28a5b905455a764829c}}\pysiglinewithargsret{\sphinxbfcode{SimulateDispersal}}{}{}%
\pysigstopmultiline
\end{fulllineitems}

\index{SimulateDispersal::\textasciitilde{}SimulateDispersal (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_SimulateDispersal:_CPPv2N17SimulateDispersalD0Ev}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_SimulateDispersal:necsimclass_simulate_dispersal_1a99a7ef1d8e1e917512848f0123f4b834}}\pysiglinewithargsret{\sphinxbfcode{\textasciitilde{}SimulateDispersal}}{}{}%
\pysigstopmultiline
\end{fulllineitems}

\index{SimulateDispersal::setSequential (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_SimulateDispersal:_CPPv2N17SimulateDispersal13setSequentialEb}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_SimulateDispersal:necsimclass_simulate_dispersal_1a3da09319132db8c7ad035290be6590ef}}\pysiglinewithargsret{void \sphinxbfcode{setSequential}}{bool \sphinxstyleemphasis{bSequential}}{}%
\pysigstopmultiline
Sets the is\_sequential flag. 

\begin{description}
\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{bSequential}: if true, dispersal events are selected using the end point of the last dispersal distance for the start of the next move event 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{SimulateDispersal::setSizes (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_SimulateDispersal:_CPPv2N17SimulateDispersal8setSizesEmm}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_SimulateDispersal:necsimclass_simulate_dispersal_1ade30de5c9c7daebb6ccc4168fec3e813}}\pysiglinewithargsret{void \sphinxbfcode{setSizes}}{unsigned long \sphinxstyleemphasis{x}, unsigned long \sphinxstyleemphasis{y}}{}%
\pysigstopmultiline
Sets the sizes of the density map. 

\begin{description}
\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{x}: the x dimension (number of columns) in the density map 

\item {} 
\sphinxcode{y}: the y dimension (number of rows) in the density map 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{SimulateDispersal::importMaps (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_SimulateDispersal:_CPPv2N17SimulateDispersal10importMapsE6string}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_SimulateDispersal:necsimclass_simulate_dispersal_1a8c7c65b4788010f02213fba5c985f49a}}\pysiglinewithargsret{void \sphinxbfcode{importMaps}}{string \sphinxstyleemphasis{map\_file}}{}%
\pysigstopmultiline
Import the map from the prescribed file. 

\begin{description}
\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{map\_file}: the map file to import from 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{SimulateDispersal::setSeed (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_SimulateDispersal:_CPPv2N17SimulateDispersal7setSeedEm}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_SimulateDispersal:necsimclass_simulate_dispersal_1a46f2cd557ac9b21c107eac75e7c916af}}\pysiglinewithargsret{void \sphinxbfcode{setSeed}}{unsigned long \sphinxstyleemphasis{s}}{}%
\pysigstopmultiline
Sets the seed for the random number generator. 

\begin{description}
\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{s}: the seed 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{SimulateDispersal::setDispersalParameters (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_SimulateDispersal:_CPPv2N17SimulateDispersal22setDispersalParametersE6stringdddd6string}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_SimulateDispersal:necsimclass_simulate_dispersal_1a93b3d450679b00c015f5e18d91f3a426}}\pysiglinewithargsret{void \sphinxbfcode{setDispersalParameters}}{string \sphinxstyleemphasis{dispersal\_method\_in}, double \sphinxstyleemphasis{sigma\_in}, double \sphinxstyleemphasis{tau\_in}, double \sphinxstyleemphasis{m\_prob\_in}, double \sphinxstyleemphasis{cutoff\_in}, string \sphinxstyleemphasis{landscape\_type}}{}%
\pysigstopmultiline
Sets the dispersal parameters. 

\begin{description}
\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{dispersal\_method\_in}: the dispersal method (e.g. \sphinxquotedblleft{}normal\sphinxquotedblright{}) 

\item {} 
\sphinxcode{sigma\_in}: the sigma value for normal and fat-tailed dispersals 

\item {} 
\sphinxcode{tau\_in}: the nu value for fat-tailed dispersals 

\item {} 
\sphinxcode{m\_prob\_in}: the m\_prob for norm-uniform dispersals 

\item {} 
\sphinxcode{cutoff\_in}: the maximum dispersal distance for norm-uniform dispersal 

\item {} 
\sphinxcode{landscape\_type}: string containing the landscape type (one of \sphinxquotedblleft{}closed\sphinxquotedblright{}, \sphinxquotedblleft{}tiled\sphinxquotedblright{} or \sphinxquotedblleft{}infinite\sphinxquotedblright{}). 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{SimulateDispersal::setLandscapeType (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_SimulateDispersal:_CPPv2N17SimulateDispersal16setLandscapeTypeE6string}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_SimulateDispersal:necsimclass_simulate_dispersal_1a627bcb0be7e7d6b0ef1dbd44b32a1909}}\pysiglinewithargsret{void \sphinxbfcode{setLandscapeType}}{string \sphinxstyleemphasis{landscape\_type}}{}%
\pysigstopmultiline
\end{fulllineitems}

\index{SimulateDispersal::setOutputDatabase (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_SimulateDispersal:_CPPv2N17SimulateDispersal17setOutputDatabaseE6string}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_SimulateDispersal:necsimclass_simulate_dispersal_1acae5067045d5989df6d7dce80bcfe276}}\pysiglinewithargsret{void \sphinxbfcode{setOutputDatabase}}{string \sphinxstyleemphasis{out\_database}}{}%
\pysigstopmultiline
Sets the output database for writing results to. 

\begin{description}
\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{out\_database}: path to the output database 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{SimulateDispersal::setNumberRepeats (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_SimulateDispersal:_CPPv2N17SimulateDispersal16setNumberRepeatsEm}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_SimulateDispersal:necsimclass_simulate_dispersal_1a29c7cf41d8b5610109d61f302fb32e73}}\pysiglinewithargsret{void \sphinxbfcode{setNumberRepeats}}{unsigned long \sphinxstyleemphasis{n}}{}%
\pysigstopmultiline
Sets the number of repeats to run the dispersal kernel for. 

\begin{description}
\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{n}: the number of repeats 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{SimulateDispersal::setNumberSteps (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_SimulateDispersal:_CPPv2N17SimulateDispersal14setNumberStepsEm}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_SimulateDispersal:necsimclass_simulate_dispersal_1a4a38f61284426daa4d968bbab91d3608}}\pysiglinewithargsret{void \sphinxbfcode{setNumberSteps}}{unsigned long \sphinxstyleemphasis{s}}{}%
\pysigstopmultiline
Sets the number of steps to run each repeat of the dispersal kernel for when recording mean distance travelled. 

\begin{description}
\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{s}: the number of steps 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{SimulateDispersal::storeCellList (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_SimulateDispersal:_CPPv2N17SimulateDispersal13storeCellListEv}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_SimulateDispersal:necsimclass_simulate_dispersal_1a85d8ee68e5f4962429571c835aa028b4}}\pysiglinewithargsret{void \sphinxbfcode{storeCellList}}{}{}%
\pysigstopmultiline
Calculates the list of cells to choose randomly from. 

\end{fulllineitems}

\index{SimulateDispersal::getRandomCell (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_SimulateDispersal:_CPPv2N17SimulateDispersal13getRandomCellEv}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_SimulateDispersal:necsimclass_simulate_dispersal_1a7d0a2b28dd8d45f1b8a74dbcd82290e7}}\pysiglinewithargsret{\sphinxstrong{const} {\hyperref[\detokenize{api/class_Cell:_CPPv24Cell}]{\sphinxcrossref{Cell}}} \&\sphinxbfcode{getRandomCell}}{}{}%
\pysigstopmultiline
Gets a random cell from the list of cells. 

\begin{description}
\item[{\sphinxstylestrong{Return}}] \leavevmode
a {\hyperref[\detokenize{api/class_Cell:necsimstruct_cell}]{\sphinxcrossref{\DUrole{std,std-ref}{Cell}}}} object reference containing the x and y positions to choose from 

\end{description}


\end{fulllineitems}

\index{SimulateDispersal::calculateNewPosition (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_SimulateDispersal:_CPPv2N17SimulateDispersal20calculateNewPositionERKdRKdRK4CellR4Cell}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_SimulateDispersal:necsimclass_simulate_dispersal_1a75eeedf1627eb25945a2d8f5dd0a2379}}\pysiglinewithargsret{void \sphinxbfcode{calculateNewPosition}}{\sphinxstrong{const} double \&\sphinxstyleemphasis{dist}, \sphinxstrong{const} double \&\sphinxstyleemphasis{angle}, \sphinxstrong{const} {\hyperref[\detokenize{api/class_Cell:_CPPv24Cell}]{\sphinxcrossref{Cell}}} \&\sphinxstyleemphasis{start\_cell}, {\hyperref[\detokenize{api/class_Cell:_CPPv24Cell}]{\sphinxcrossref{Cell}}} \&\sphinxstyleemphasis{end\_cell}}{}%
\pysigstopmultiline
Calculates the new position from the start cell based on the distance and angle moved. Stores the new x and y location in the end cell. 

\begin{description}
\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{dist}: the distance to move 

\item {} 
\sphinxcode{angle}: the direction from the start cell to move 

\item {} 
\sphinxcode{start\_cell}: the cell containing the start x and y position 

\item {} 
\sphinxcode{end\_cell}: the cell to contain the end x and y position 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{SimulateDispersal::getEndPointInfinite (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_SimulateDispersal:_CPPv2N17SimulateDispersal19getEndPointInfiniteERKdRKdRK4CellR4Cell}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_SimulateDispersal:necsimclass_simulate_dispersal_1acb12b6b2f113e58c62636b2b4456f4da}}\pysiglinewithargsret{bool \sphinxbfcode{getEndPointInfinite}}{\sphinxstrong{const} double \&\sphinxstyleemphasis{dist}, \sphinxstrong{const} double \&\sphinxstyleemphasis{angle}, \sphinxstrong{const} {\hyperref[\detokenize{api/class_Cell:_CPPv24Cell}]{\sphinxcrossref{Cell}}} \&\sphinxstyleemphasis{this\_cell}, {\hyperref[\detokenize{api/class_Cell:_CPPv24Cell}]{\sphinxcrossref{Cell}}} \&\sphinxstyleemphasis{end\_cell}}{}%
\pysigstopmultiline
Checks the density is greater than 0 a given distance from the start point on an infinite null landscape. 

This also takes into account the rejection sampling of density based on the maximal density value from the map.

\begin{description}
\item[{\sphinxstylestrong{Return}}] \leavevmode
true if the point has a density \textgreater{} 0, otherwise generates a random number between 0 and the max size and if it is \textgreater{} the density, return true, false otherwise. 

\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{dist}: the distance of dispersal 

\item {} 
\sphinxcode{angle}: the angle of dispersal 

\item {} 
\sphinxcode{this\_cell}: {\hyperref[\detokenize{api/class_Cell:necsimstruct_cell}]{\sphinxcrossref{\DUrole{std,std-ref}{Cell}}}} containing the x and y coordinates of the starting position 

\item {} 
\sphinxcode{end\_cell}: {\hyperref[\detokenize{api/class_Cell:necsimstruct_cell}]{\sphinxcrossref{\DUrole{std,std-ref}{Cell}}}} to store the end point in 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{SimulateDispersal::getEndPointTiled (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_SimulateDispersal:_CPPv2N17SimulateDispersal16getEndPointTiledERKdRKdRK4CellR4Cell}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_SimulateDispersal:necsimclass_simulate_dispersal_1a9694673493b261697020f42aa2fdf9e7}}\pysiglinewithargsret{bool \sphinxbfcode{getEndPointTiled}}{\sphinxstrong{const} double \&\sphinxstyleemphasis{dist}, \sphinxstrong{const} double \&\sphinxstyleemphasis{angle}, \sphinxstrong{const} {\hyperref[\detokenize{api/class_Cell:_CPPv24Cell}]{\sphinxcrossref{Cell}}} \&\sphinxstyleemphasis{this\_cell}, {\hyperref[\detokenize{api/class_Cell:_CPPv24Cell}]{\sphinxcrossref{Cell}}} \&\sphinxstyleemphasis{end\_cell}}{}%
\pysigstopmultiline
Checks the density is greater than 0 a given distance from the start point on an infinite tiled landscape. 

This also takes into account the rejection sampling of density based on the maximal density value from the map.

\begin{description}
\item[{\sphinxstylestrong{Return}}] \leavevmode
true if the point has a density \textgreater{} 0, otherwise generates a random number between 0 and the max size and if it is \textgreater{} the density, return true, false otherwise. 

\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{dist}: the distance of dispersal 

\item {} 
\sphinxcode{angle}: the angle of dispersal 

\item {} 
\sphinxcode{this\_cell}: {\hyperref[\detokenize{api/class_Cell:necsimstruct_cell}]{\sphinxcrossref{\DUrole{std,std-ref}{Cell}}}} containing the x and y coordinates of the starting position 

\item {} 
\sphinxcode{end\_cell}: {\hyperref[\detokenize{api/class_Cell:necsimstruct_cell}]{\sphinxcrossref{\DUrole{std,std-ref}{Cell}}}} to store the end point in

\end{itemize}

\end{description}


\end{fulllineitems}

\index{SimulateDispersal::getEndPointClosed (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_SimulateDispersal:_CPPv2N17SimulateDispersal17getEndPointClosedERKdRKdRK4CellR4Cell}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_SimulateDispersal:necsimclass_simulate_dispersal_1ab7fa3b37534cdd35871b30c7bb511351}}\pysiglinewithargsret{bool \sphinxbfcode{getEndPointClosed}}{\sphinxstrong{const} double \&\sphinxstyleemphasis{dist}, \sphinxstrong{const} double \&\sphinxstyleemphasis{angle}, \sphinxstrong{const} {\hyperref[\detokenize{api/class_Cell:_CPPv24Cell}]{\sphinxcrossref{Cell}}} \&\sphinxstyleemphasis{this\_cell}, {\hyperref[\detokenize{api/class_Cell:_CPPv24Cell}]{\sphinxcrossref{Cell}}} \&\sphinxstyleemphasis{end\_cell}}{}%
\pysigstopmultiline
Checks the density a given distance from the start point on an closed landscape. 

This also takes into account the rejection sampling of density based on the maximal density value from the map.

\begin{description}
\item[{\sphinxstylestrong{Return}}] \leavevmode
true if the point has a density \textgreater{} 0, otherwise generates a random number between 0 and the max size and if it is \textgreater{} the density, return true, false otherwise. 

\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{dist}: the distance of dispersal 

\item {} 
\sphinxcode{angle}: the angle of dispersal 

\item {} 
\sphinxcode{this\_cell}: {\hyperref[\detokenize{api/class_Cell:necsimstruct_cell}]{\sphinxcrossref{\DUrole{std,std-ref}{Cell}}}} containing the x and y coordinates of the starting position 

\item {} 
\sphinxcode{end\_cell}: {\hyperref[\detokenize{api/class_Cell:necsimstruct_cell}]{\sphinxcrossref{\DUrole{std,std-ref}{Cell}}}} to store the end point in

\end{itemize}

\end{description}


\end{fulllineitems}

\index{SimulateDispersal::getEndPoint (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_SimulateDispersal:_CPPv2N17SimulateDispersal11getEndPointERKdRKdRK4CellR4Cell}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_SimulateDispersal:necsimclass_simulate_dispersal_1a10a1dd769e993d018e7c7ae9208240ab}}\pysiglinewithargsret{bool \sphinxbfcode{getEndPoint}}{\sphinxstrong{const} double \&\sphinxstyleemphasis{dist}, \sphinxstrong{const} double \&\sphinxstyleemphasis{angle}, \sphinxstrong{const} {\hyperref[\detokenize{api/class_Cell:_CPPv24Cell}]{\sphinxcrossref{Cell}}} \&\sphinxstyleemphasis{this\_cell}, {\hyperref[\detokenize{api/class_Cell:_CPPv24Cell}]{\sphinxcrossref{Cell}}} \&\sphinxstyleemphasis{end\_cell}}{}%
\pysigstopmultiline
Checks the density a given distance from the start point, calling the relevant landscape function. 

This also takes into account the rejection sampling of density based on the maximal density value from the map.

\begin{description}
\item[{\sphinxstylestrong{Return}}] \leavevmode
true if the point has a density \textgreater{} 0, otherwise generates a random number between 0 and the max size and if it is \textgreater{} the density, return true, false otherwise. 

\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{dist}: the distance of dispersal 

\item {} 
\sphinxcode{angle}: the angle of dispersal 

\item {} 
\sphinxcode{this\_cell}: {\hyperref[\detokenize{api/class_Cell:necsimstruct_cell}]{\sphinxcrossref{\DUrole{std,std-ref}{Cell}}}} containing the x and y coordinates of the starting position 

\item {} 
\sphinxcode{end\_cell}: {\hyperref[\detokenize{api/class_Cell:necsimstruct_cell}]{\sphinxcrossref{\DUrole{std,std-ref}{Cell}}}} to store the end point in

\end{itemize}

\end{description}


\end{fulllineitems}

\index{SimulateDispersal::runMeanDispersalDistance (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_SimulateDispersal:_CPPv2N17SimulateDispersal24runMeanDispersalDistanceEv}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_SimulateDispersal:necsimclass_simulate_dispersal_1a4a759f6bb3b8288345eaf7c0d66ad29e}}\pysiglinewithargsret{void \sphinxbfcode{runMeanDispersalDistance}}{}{}%
\pysigstopmultiline
Simulates the dispersal kernel for the set parameters, storing the mean dispersal distance. 

\end{fulllineitems}

\index{SimulateDispersal::runMeanDistanceTravelled (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_SimulateDispersal:_CPPv2N17SimulateDispersal24runMeanDistanceTravelledEv}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_SimulateDispersal:necsimclass_simulate_dispersal_1a406514e917874907cfb7a8d6c7889098}}\pysiglinewithargsret{void \sphinxbfcode{runMeanDistanceTravelled}}{}{}%
\pysigstopmultiline
Simulates the dispersal kernel for the set parameters, storing the mean distance travelled. 

\end{fulllineitems}

\index{SimulateDispersal::writeDatabase (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_SimulateDispersal:_CPPv2N17SimulateDispersal13writeDatabaseE6string}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_SimulateDispersal:necsimclass_simulate_dispersal_1af7d0a726cb3724c159ca46f4586a8bd3}}\pysiglinewithargsret{void \sphinxbfcode{writeDatabase}}{string \sphinxstyleemphasis{table\_name}}{}%
\pysigstopmultiline
Writes out the distances to the SQL database. 

\begin{description}
\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{table\_name}: the name of the table to output to, either `DISPERSAL\_DISTANCE' or `DISTANCES\_TRAVELLED' 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{SimulateDispersal::writeParameters (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_SimulateDispersal:_CPPv2N17SimulateDispersal15writeParametersE6string}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_SimulateDispersal:necsimclass_simulate_dispersal_1ae0afed6eeb06f5bae4ee13a24850c8c5}}\pysiglinewithargsret{void \sphinxbfcode{writeParameters}}{string \sphinxstyleemphasis{table\_name}}{}%
\pysigstopmultiline
Writes the simulation parameters to the output SQL database. 

\begin{description}
\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{table\_name}: the name of the table to output to, either `DISPERSAL\_DISTANCE' or `DISTANCES\_TRAVELLED' 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{SimulateDispersal::checkMaxParameterReference (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_SimulateDispersal:_CPPv2N17SimulateDispersal26checkMaxParameterReferenceEv}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_SimulateDispersal:necsimclass_simulate_dispersal_1a0dee5d1529bd7ee6f382f7cd1b5393e5}}\pysiglinewithargsret{void \sphinxbfcode{checkMaxParameterReference}}{}{}%
\pysigstopmultiline
Gets the maximum parameter reference from the output SQL database and saves val + 1 to parameter\_reference Assumes that the database exists. 

\end{fulllineitems}

\index{SimulateDispersal::checkMaxIdNumber (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_SimulateDispersal:_CPPv2N17SimulateDispersal16checkMaxIdNumberE6string}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_SimulateDispersal:necsimclass_simulate_dispersal_1abafd3fc30df157d12e462c4b1907d8fa}}\pysiglinewithargsret{unsigned long \sphinxbfcode{checkMaxIdNumber}}{string \sphinxstyleemphasis{table\_name}}{}%
\pysigstopmultiline
Gets the maximum id number from the output SQL database and returns val + 1 Assumes that the database exists. 

\begin{description}
\item[{\sphinxstylestrong{Note}}] \leavevmode
this function does not check for SQL injection attacks and should not be used with variable function names. 

\item[{\sphinxstylestrong{Return}}] \leavevmode
the maximum id + 1 from the given table 

\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{table\_name}: the name of the table to check for max(id) in 

\end{itemize}

\end{description}


\end{fulllineitems}

\paragraph{Protected Types}
\index{SimulateDispersal::landscape\_fptr (C++ type)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_SimulateDispersal:_CPPv2N17SimulateDispersal14landscape_fptrE}}%
\pysigstartmultiline
\pysiglinewithargsret{\phantomsection\label{\detokenize{api/class_SimulateDispersal:necsimclass_simulate_dispersal_1a33cf29f05f05fbf3cd70f759e62f57f0}}\sphinxstrong{typedef }bool (\sphinxbfcode{SimulateDispersal}::*\sphinxbfcode{landscape\_fptr})}{\sphinxstrong{const} double \&dist, \sphinxstrong{const} double \&angle, \sphinxstrong{const} {\hyperref[\detokenize{api/class_Cell:_CPPv24Cell}]{\sphinxcrossref{Cell}}} \&this\_cell, {\hyperref[\detokenize{api/class_Cell:_CPPv24Cell}]{\sphinxcrossref{Cell}}} \&end\_cell}{}%
\pysigstopmultiline
\end{fulllineitems}

\paragraph{Protected Attributes}
\index{SimulateDispersal::density\_map (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_SimulateDispersal:_CPPv2N17SimulateDispersal11density_mapE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{api/class_SimulateDispersal:necsimclass_simulate_dispersal_1aa699133749e7a30f225cb355f95f51e6}}{\hyperref[\detokenize{api/class_Matrix:_CPPv26Matrix}]{\sphinxcrossref{Matrix}}}\textless{}uint32\_t\textgreater{} \sphinxbfcode{density\_map}}%
\pysigstopmultiline
\end{fulllineitems}

\index{SimulateDispersal::has\_set\_size (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_SimulateDispersal:_CPPv2N17SimulateDispersal12has_set_sizeE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{api/class_SimulateDispersal:necsimclass_simulate_dispersal_1aff72c923e8454470b2d4c8935061fb21}}bool \sphinxbfcode{has\_set\_size}}%
\pysigstopmultiline
\end{fulllineitems}

\index{SimulateDispersal::random (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_SimulateDispersal:_CPPv2N17SimulateDispersal6randomE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{api/class_SimulateDispersal:necsimclass_simulate_dispersal_1a5f6389fc4116b52622a900c55532f86b}}{\hyperref[\detokenize{api/class_NRrand:_CPPv26NRrand}]{\sphinxcrossref{NRrand}}} \sphinxbfcode{random}}%
\pysigstopmultiline
\end{fulllineitems}

\index{SimulateDispersal::map\_name (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_SimulateDispersal:_CPPv2N17SimulateDispersal8map_nameE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{api/class_SimulateDispersal:necsimclass_simulate_dispersal_1af1dc4cf60a69aafc2be4c80b0e9228c2}}string \sphinxbfcode{map\_name}}%
\pysigstopmultiline
\end{fulllineitems}

\index{SimulateDispersal::seed (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_SimulateDispersal:_CPPv2N17SimulateDispersal4seedE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{api/class_SimulateDispersal:necsimclass_simulate_dispersal_1af9ab2fa8b2c3e1bb1ba49b31679ae0d7}}unsigned long \sphinxbfcode{seed}}%
\pysigstopmultiline
\end{fulllineitems}

\index{SimulateDispersal::dispersal\_method (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_SimulateDispersal:_CPPv2N17SimulateDispersal16dispersal_methodE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{api/class_SimulateDispersal:necsimclass_simulate_dispersal_1aedabf3440f475bc15d4b95f9e8500d94}}string \sphinxbfcode{dispersal\_method}}%
\pysigstopmultiline
\end{fulllineitems}

\index{SimulateDispersal::sigma (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_SimulateDispersal:_CPPv2N17SimulateDispersal5sigmaE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{api/class_SimulateDispersal:necsimclass_simulate_dispersal_1ad6d6ae35911ed2bd045bf8e5bb30b628}}double \sphinxbfcode{sigma}}%
\pysigstopmultiline
\end{fulllineitems}

\index{SimulateDispersal::tau (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_SimulateDispersal:_CPPv2N17SimulateDispersal3tauE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{api/class_SimulateDispersal:necsimclass_simulate_dispersal_1aa195b7e1b697c93e85a923eea5fabccc}}double \sphinxbfcode{tau}}%
\pysigstopmultiline
\end{fulllineitems}

\index{SimulateDispersal::m\_prob (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_SimulateDispersal:_CPPv2N17SimulateDispersal6m_probE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{api/class_SimulateDispersal:necsimclass_simulate_dispersal_1ae4b679b39467170abf45845d4591e6db}}double \sphinxbfcode{m\_prob}}%
\pysigstopmultiline
\end{fulllineitems}

\index{SimulateDispersal::cutoff (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_SimulateDispersal:_CPPv2N17SimulateDispersal6cutoffE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{api/class_SimulateDispersal:necsimclass_simulate_dispersal_1a532f1c5ba22d681c5761dcce4fc8555d}}double \sphinxbfcode{cutoff}}%
\pysigstopmultiline
\end{fulllineitems}

\index{SimulateDispersal::database (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_SimulateDispersal:_CPPv2N17SimulateDispersal8databaseE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{api/class_SimulateDispersal:necsimclass_simulate_dispersal_1afd3f96f169715aacbcc2939614a6a910}}sqlite3 *\sphinxbfcode{database}}%
\pysigstopmultiline
\end{fulllineitems}

\index{SimulateDispersal::distances (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_SimulateDispersal:_CPPv2N17SimulateDispersal9distancesE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{api/class_SimulateDispersal:necsimclass_simulate_dispersal_1a616354e9527a71396a428bb63f444a15}}vector\textless{}double\textgreater{} \sphinxbfcode{distances}}%
\pysigstopmultiline
\end{fulllineitems}

\index{SimulateDispersal::cells (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_SimulateDispersal:_CPPv2N17SimulateDispersal5cellsE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{api/class_SimulateDispersal:necsimclass_simulate_dispersal_1abcb3ce61b835cbd007d09726302d692a}}vector\textless{}{\hyperref[\detokenize{api/class_Cell:_CPPv24Cell}]{\sphinxcrossref{Cell}}}\textgreater{} \sphinxbfcode{cells}}%
\pysigstopmultiline
\end{fulllineitems}

\index{SimulateDispersal::num\_repeats (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_SimulateDispersal:_CPPv2N17SimulateDispersal11num_repeatsE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{api/class_SimulateDispersal:necsimclass_simulate_dispersal_1a36ca3df92a79e284cdeb84ea0dfb3c9a}}unsigned long \sphinxbfcode{num\_repeats}}%
\pysigstopmultiline
\end{fulllineitems}

\index{SimulateDispersal::num\_steps (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_SimulateDispersal:_CPPv2N17SimulateDispersal9num_stepsE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{api/class_SimulateDispersal:necsimclass_simulate_dispersal_1a7f3401f3a7f1ec48635973d94e3470e8}}unsigned long \sphinxbfcode{num\_steps}}%
\pysigstopmultiline
\end{fulllineitems}

\index{SimulateDispersal::max\_density (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_SimulateDispersal:_CPPv2N17SimulateDispersal11max_densityE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{api/class_SimulateDispersal:necsimclass_simulate_dispersal_1a0edc9ca52d14b3ea78c99c33b200447e}}unsigned long \sphinxbfcode{max\_density}}%
\pysigstopmultiline
\end{fulllineitems}

\index{SimulateDispersal::is\_sequential (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_SimulateDispersal:_CPPv2N17SimulateDispersal13is_sequentialE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{api/class_SimulateDispersal:necsimclass_simulate_dispersal_1a72f4b5ec8d52f080f2c9df991fb546ef}}bool \sphinxbfcode{is\_sequential}}%
\pysigstopmultiline
\end{fulllineitems}

\index{SimulateDispersal::parameter\_reference (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_SimulateDispersal:_CPPv2N17SimulateDispersal19parameter_referenceE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{api/class_SimulateDispersal:necsimclass_simulate_dispersal_1a2d15ba06c50a249328f867a105848f72}}unsigned long \sphinxbfcode{parameter\_reference}}%
\pysigstopmultiline
\end{fulllineitems}

\index{SimulateDispersal::getValFptr (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_SimulateDispersal:_CPPv2N17SimulateDispersal10getValFptrE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{api/class_SimulateDispersal:necsimclass_simulate_dispersal_1ae1f3a40b1805f024e41ec8df9c38c01e}}{\hyperref[\detokenize{api/class_SimulateDispersal:_CPPv2N17SimulateDispersal14landscape_fptrE}]{\sphinxcrossref{landscape\_fptr}}} \sphinxbfcode{getValFptr}}%
\pysigstopmultiline
\end{fulllineitems}


\end{fulllineitems}



\subsection{Class SpatialTree}
\label{\detokenize{api/class_SpatialTree::doc}}\label{\detokenize{api/class_SpatialTree:class-spatialtree}}\label{\detokenize{api/class_SpatialTree:id1}}\begin{itemize}
\item {} 
Defined in {\hyperref[\detokenize{api/file_necsim_SpatialTree.h:file-necsim-spatialtree-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File SpatialTree.h}}}}

\end{itemize}


\subsubsection{Inheritance Relationships}
\label{\detokenize{api/class_SpatialTree:inheritance-relationships}}

\paragraph{Base Type}
\label{\detokenize{api/class_SpatialTree:base-type}}\begin{itemize}
\item {} 
\sphinxcode{public Tree} ({\hyperref[\detokenize{api/class_Tree:class-tree}]{\sphinxcrossref{\DUrole{std,std-ref}{Class Tree}}}})

\end{itemize}


\paragraph{Derived Type}
\label{\detokenize{api/class_SpatialTree:derived-type}}\begin{itemize}
\item {} 
\sphinxcode{public ProtractedSpatialTree} ({\hyperref[\detokenize{api/class_ProtractedSpatialTree:class-protractedspatialtree}]{\sphinxcrossref{\DUrole{std,std-ref}{Class ProtractedSpatialTree}}}})

\end{itemize}


\subsubsection{Class Documentation}
\label{\detokenize{api/class_SpatialTree:class-documentation}}\index{SpatialTree (C++ class)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_SpatialTree:_CPPv211SpatialTree}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_SpatialTree:necsimclass_spatial_tree}}\pysigline{\sphinxstrong{class }\sphinxcode{}\sphinxbfcode{SpatialTree}}%
\pysigstopmultiline
Represents the output phylogenetic tree, when run on a spatially-explicit landscape. 

Contains all functions for running simulations, outputting data and calculating coalescence tree structure. 

Inherits from {\hyperref[\detokenize{api/class_Tree:necsimclass_tree}]{\sphinxcrossref{\DUrole{std,std-ref}{Tree}}}}

Subclassed by {\hyperref[\detokenize{api/class_ProtractedSpatialTree:necsimclass_protracted_spatial_tree}]{\sphinxcrossref{\DUrole{std,std-ref}{ProtractedSpatialTree}}}}
\paragraph{Public Functions}
\index{SpatialTree::SpatialTree (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_SpatialTree:_CPPv2N11SpatialTree11SpatialTreeEv}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_SpatialTree:necsimclass_spatial_tree_1a051cc56f4f1284c419616ca6b582d52f}}\pysiglinewithargsret{\sphinxbfcode{SpatialTree}}{}{}%
\pysigstopmultiline
The constructor for the tree object. 

Sets all uninitiated variables to false, except log\_all. log\_all should be changed to false if minimal text output during simulations is desired. 

\end{fulllineitems}

\index{SpatialTree::\textasciitilde{}SpatialTree (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_SpatialTree:_CPPv2N11SpatialTreeD0Ev}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_SpatialTree:necsimclass_spatial_tree_1ad2b7d5f103ed5d7c3b9219b55c176219}}\pysiglinewithargsret{\sphinxbfcode{\textasciitilde{}SpatialTree}}{}{}%
\pysigstopmultiline
\end{fulllineitems}

\index{SpatialTree::importSimulationVariables (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_SpatialTree:_CPPv2N11SpatialTree25importSimulationVariablesERK6string}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_SpatialTree:necsimclass_spatial_tree_1ac5fc862af2ca6f2b4c471c450093fcae}}\pysiglinewithargsret{void \sphinxbfcode{importSimulationVariables}}{\sphinxstrong{const} string \&\sphinxstyleemphasis{configfile}}{}%
\pysigstopmultiline
Imports the simulation variables from the config file. 

Also checks for paused simulations and file existence. \begin{description}
\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{configfile}: a vector containing the configfile to import from 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{SpatialTree::parseArgs (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_SpatialTree:_CPPv2N11SpatialTree9parseArgsER6vectorI6stringE}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_SpatialTree:necsimclass_spatial_tree_1ad6a5412bccbccc92a302b2fb05bbced2}}\pysiglinewithargsret{void \sphinxbfcode{parseArgs}}{vector\textless{}string\textgreater{} \&\sphinxstyleemphasis{comargs}}{}%
\pysigstopmultiline
Parses the command line arguments and saves the flags in {\hyperref[\detokenize{api/class_Tree:necsimclass_tree}]{\sphinxcrossref{\DUrole{std,std-ref}{Tree}}}} for fullmode, resuming and other important variables. 

\begin{description}
\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{comargs}: 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{SpatialTree::checkFolders (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_SpatialTree:_CPPv2N11SpatialTree12checkFoldersEv}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_SpatialTree:necsimclass_spatial_tree_1aef0097abc7c616ed656e26b4055834c3}}\pysiglinewithargsret{void \sphinxbfcode{checkFolders}}{}{}%
\pysigstopmultiline
Checks that the folders exist and the files required for the simulation also exist. 

\end{fulllineitems}

\index{SpatialTree::setParameters (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_SpatialTree:_CPPv2N11SpatialTree13setParametersEv}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_SpatialTree:necsimclass_spatial_tree_1a0c83bcd9a84f4fa98c78b75a78a9a012}}\pysiglinewithargsret{void \sphinxbfcode{setParameters}}{}{}%
\pysigstopmultiline
Sets the map object with the correct variables, taking the {\hyperref[\detokenize{api/struct_SimParameters:necsimstruct_sim_parameters}]{\sphinxcrossref{\DUrole{std,std-ref}{SimParameters}}}} structure defined elsewhere for the parameters. 

Requires that parameters have already been imported into the {\hyperref[\detokenize{api/struct_SimParameters:necsimstruct_sim_parameters}]{\sphinxcrossref{\DUrole{std,std-ref}{SimParameters}}}}

This function can only be run once, otherwise a Main\_Exception will be thrown 

\end{fulllineitems}

\index{SpatialTree::importMaps (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_SpatialTree:_CPPv2N11SpatialTree10importMapsEv}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_SpatialTree:necsimclass_spatial_tree_1ab9603c25cd1c8466d1e4bfa3f73f191f}}\pysiglinewithargsret{void \sphinxbfcode{importMaps}}{}{}%
\pysigstopmultiline
Imports the maps into the forestmap object. 

The simulation variables should have already been imported by {\hyperref[\detokenize{api/class_SpatialTree:necsimclass_spatial_tree_1a0c83bcd9a84f4fa98c78b75a78a9a012}]{\sphinxcrossref{\DUrole{std,std-ref}{setParameters()}}}}, otherwise a Fatal\_Exception will be thrown. 

\end{fulllineitems}

\index{SpatialTree::importReproductionMap (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_SpatialTree:_CPPv2N11SpatialTree21importReproductionMapEv}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_SpatialTree:necsimclass_spatial_tree_1a5d9f29a12f8b66798139c89f153130db}}\pysiglinewithargsret{void \sphinxbfcode{importReproductionMap}}{}{}%
\pysigstopmultiline
Imports the reproduction map from file. 

\end{fulllineitems}

\index{SpatialTree::getInitialCount (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_SpatialTree:_CPPv2N11SpatialTree15getInitialCountEv}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_SpatialTree:necsimclass_spatial_tree_1a05ac9205ab49dbe6056522722372063b}}\pysiglinewithargsret{unsigned long \sphinxbfcode{getInitialCount}}{}{}%
\pysigstopmultiline
Counts the number of individuals that exist on the spatial grid. 

\begin{description}
\item[{\sphinxstylestrong{Return}}] \leavevmode
the number of individuals that will be initially simulated 

\end{description}


\end{fulllineitems}

\index{SpatialTree::setupDispersalCoordinator (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_SpatialTree:_CPPv2N11SpatialTree25setupDispersalCoordinatorEv}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_SpatialTree:necsimclass_spatial_tree_1a3ce93c4d62367f17dd523cab4cc35ae8}}\pysiglinewithargsret{void \sphinxbfcode{setupDispersalCoordinator}}{}{}%
\pysigstopmultiline
Sets up the dispersal coordinator by linking to the correct functions and choosing the appropriate dispersal method. 

\end{fulllineitems}

\index{SpatialTree::setup (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_SpatialTree:_CPPv2N11SpatialTree5setupEv}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_SpatialTree:necsimclass_spatial_tree_1ae97336318c81e182e9f445f7efdbff8d}}\pysiglinewithargsret{void \sphinxbfcode{setup}}{}{}%
\pysigstopmultiline
Contains the setup routines for a spatial landscape. It also checks for paused simulations and imports data if necessary from paused files. {\hyperref[\detokenize{api/class_SpatialTree:necsimclass_spatial_tree_1ab9603c25cd1c8466d1e4bfa3f73f191f}]{\sphinxcrossref{\DUrole{std,std-ref}{importMaps()}}}} is called for importing the map files. 



\end{fulllineitems}

\index{SpatialTree::fillObjects (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_SpatialTree:_CPPv2N11SpatialTree11fillObjectsERKm}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_SpatialTree:necsimclass_spatial_tree_1a030ece1d0756057e56f4272510d3e567}}\pysiglinewithargsret{unsigned long \sphinxbfcode{fillObjects}}{\sphinxstrong{const} unsigned long \&\sphinxstyleemphasis{initial\_count}}{}%
\pysigstopmultiline
Fill the active, data and grid objects with the starting lineages. 

\begin{description}
\item[{\sphinxstylestrong{Return}}] \leavevmode
the number of lineages added (for validation purposes) 

\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{initial\_count}: the number of individuals expected to exist 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{SpatialTree::getIndividualsSampled (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_SpatialTree:_CPPv2N11SpatialTree21getIndividualsSampledERKlRKlRKlRKlRKd}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_SpatialTree:necsimclass_spatial_tree_1a46d31dc58b01f2666e90078e95b2a25d}}\pysiglinewithargsret{unsigned long \sphinxbfcode{getIndividualsSampled}}{\sphinxstrong{const} long \&\sphinxstyleemphasis{x}, \sphinxstrong{const} long \&\sphinxstyleemphasis{y}, \sphinxstrong{const} long \&\sphinxstyleemphasis{x\_wrap}, \sphinxstrong{const} long \&\sphinxstyleemphasis{y\_wrap}, \sphinxstrong{const} double \&\sphinxstyleemphasis{current\_gen}}{}%
\pysigstopmultiline
Gets the number of individuals to be sampled at the particular point and time. Round the number down to the nearest whole number for numbers of individuals. 

\begin{description}
\item[{\sphinxstylestrong{Return}}] \leavevmode
the number of individuals to sample at this location. 

\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{x}: the x location for individuals to be sampled 

\item {} 
\sphinxcode{y}: the y location for individuals to be sampled 

\item {} 
\sphinxcode{x\_wrap}: the number of x wraps for the cell 

\item {} 
\sphinxcode{y\_wrap}: the number of y wraps for the cell 

\item {} 
\sphinxcode{current\_gen}: the current generation timer 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{SpatialTree::removeOldPosition (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_SpatialTree:_CPPv2N11SpatialTree17removeOldPositionERKm}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_SpatialTree:necsimclass_spatial_tree_1ae694bde4ab31b51c13c4a96f9a86a8ba}}\pysiglinewithargsret{void \sphinxbfcode{removeOldPosition}}{\sphinxstrong{const} unsigned long \&\sphinxstyleemphasis{chosen}}{}%
\pysigstopmultiline
Removes the old position within active by checking any wrapping and removing connections. 

The function also corrects the linked list to identify the correct nwrap for every wrapped lineage in that space.

\begin{description}
\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{chosen}: the desired active reference to remove from the grid. 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{SpatialTree::calcMove (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_SpatialTree:_CPPv2N11SpatialTree8calcMoveEv}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_SpatialTree:necsimclass_spatial_tree_1ac7202eff84dfe8931374cc236efb9133}}\pysiglinewithargsret{void \sphinxbfcode{calcMove}}{}{}%
\pysigstopmultiline
Calculate the move, given a start x,y coordinates and wrapping. 

The provided parameters will be altered to contain the new values so no record of the old variables remains after function running. Current dispersal methods use a fattailed dispersal. 

\end{fulllineitems}

\index{SpatialTree::calcMinMax (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_SpatialTree:_CPPv2N11SpatialTree10calcMinMaxERKm}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_SpatialTree:necsimclass_spatial_tree_1ae6b453b80ea8ffedbbba799ac6142352}}\pysiglinewithargsret{long double \sphinxbfcode{calcMinMax}}{\sphinxstrong{const} unsigned long \&\sphinxstyleemphasis{current}}{}%
\pysigstopmultiline
Calculates the minmax for a given branch. 

Calculates the speciation rate required for speciation to have occured on this branch.

\begin{description}
\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{current}: the current active reference to perform calculations over. 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{SpatialTree::calcNewPos (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_SpatialTree:_CPPv2N11SpatialTree10calcNewPosERbRKmRmRKlRKlRKlRKl}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_SpatialTree:necsimclass_spatial_tree_1ac2b2ab269b36896cb41c47f750b8c032}}\pysiglinewithargsret{void \sphinxbfcode{calcNewPos}}{bool \&\sphinxstyleemphasis{coal}, \sphinxstrong{const} unsigned long \&\sphinxstyleemphasis{chosen}, unsigned long \&\sphinxstyleemphasis{coalchosen}, \sphinxstrong{const} long \&\sphinxstyleemphasis{oldx}, \sphinxstrong{const} long \&\sphinxstyleemphasis{oldy}, \sphinxstrong{const} long \&\sphinxstyleemphasis{oldxwrap}, \sphinxstrong{const} long \&\sphinxstyleemphasis{oldywrap}}{}%
\pysigstopmultiline
Calculates the new position, checking whether coalescence has occured and with which lineage. 

This involves correct handling of checking wrapped lineages (outside the original grid). The probability of coalescence is also calculated.

\begin{description}
\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{coal}: boolean for whether coalescence occured or not 

\item {} 
\sphinxcode{chosen}: the chosen lineage 

\item {} 
\sphinxcode{coalchosen}: the lineaged that is coalescing (if required) 

\item {} 
\sphinxcode{oldx}: the old x position 

\item {} 
\sphinxcode{oldy}: the old y position 

\item {} 
\sphinxcode{oldxwrap}: the old x wrapping 

\item {} 
\sphinxcode{oldywrap}: the old y wrapping 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{SpatialTree::switchPositions (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_SpatialTree:_CPPv2N11SpatialTree15switchPositionsERKm}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_SpatialTree:necsimclass_spatial_tree_1a71c99204503ec59815a5338ab934331d}}\pysiglinewithargsret{void \sphinxbfcode{switchPositions}}{\sphinxstrong{const} unsigned long \&\sphinxstyleemphasis{chosen}}{}%
\pysigstopmultiline
Switches the chosen position with the endactive position. 

\begin{description}
\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{chosen}: the chosen lineage to switch with endactive. 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{SpatialTree::calcNextStep (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_SpatialTree:_CPPv2N11SpatialTree12calcNextStepEv}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_SpatialTree:necsimclass_spatial_tree_1a577196761885888dcb9366ab377f98cb}}\pysiglinewithargsret{void \sphinxbfcode{calcNextStep}}{}{}%
\pysigstopmultiline
Calculates the next step for the simulation. 

\end{fulllineitems}

\index{SpatialTree::estSpecnum (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_SpatialTree:_CPPv2N11SpatialTree10estSpecnumEv}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_SpatialTree:necsimclass_spatial_tree_1a96919ff86b2a4d1de5ba14c2598a9346}}\pysiglinewithargsret{unsigned long \sphinxbfcode{estSpecnum}}{}{}%
\pysigstopmultiline
Estimates the species number from the second largest minimum speciation rate remaining in active. 

This allows for halting of the simulation once this threshold has been reached. However, the function is not currently in use as calculating the coalescence tree is very computionally intensive. 

\end{fulllineitems}

\index{SpatialTree::incrementGeneration (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_SpatialTree:_CPPv2N11SpatialTree19incrementGenerationEv}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_SpatialTree:necsimclass_spatial_tree_1aa5db72e986bed4b0aa81217f5be30cf4}}\pysiglinewithargsret{void \sphinxbfcode{incrementGeneration}}{}{}%
\pysigstopmultiline
Increments the generation counter and step references, then updates the map for any changes to habitat cover. 

\end{fulllineitems}

\index{SpatialTree::updateStepCoalescenceVariables (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_SpatialTree:_CPPv2N11SpatialTree30updateStepCoalescenceVariablesEv}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_SpatialTree:necsimclass_spatial_tree_1ad14491fc87b0a9b28f5b8b316ee8a89d}}\pysiglinewithargsret{void \sphinxbfcode{updateStepCoalescenceVariables}}{}{}%
\pysigstopmultiline
Updates the coalescence variables in the step object. 

\end{fulllineitems}

\index{SpatialTree::addLineages (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_SpatialTree:_CPPv2N11SpatialTree11addLineagesEd}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_SpatialTree:necsimclass_spatial_tree_1a6e802a5034648cc26b24923f27f85727}}\pysiglinewithargsret{void \sphinxbfcode{addLineages}}{double \sphinxstyleemphasis{generation\_in}}{}%
\pysigstopmultiline
Expands the map, generating the new lineages where necessary. 

The samplemask provided is used for expansion. Any empty spaces are filled with a new lineage. Lineages which have not moved are changed to tips, with a new data entry so that original and new generations are recorded.

\begin{description}
\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{generation\_in}: the generation that the expansion is occuring at. This is used in recording the new tips 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{SpatialTree::simulationParametersSqlInsertion (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_SpatialTree:_CPPv2N11SpatialTree32simulationParametersSqlInsertionEv}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_SpatialTree:necsimclass_spatial_tree_1acc54786661c182b6df23e57a61716e0f}}\pysiglinewithargsret{string \sphinxbfcode{simulationParametersSqlInsertion}}{}{}%
\pysigstopmultiline
Creates a string containing the SQL insertion statement for the simulation parameters. 

\begin{description}
\item[{\sphinxstylestrong{Return}}] \leavevmode
string containing the SQL insertion statement 

\end{description}


\end{fulllineitems}

\index{SpatialTree::simPause (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_SpatialTree:_CPPv2N11SpatialTree8simPauseEv}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_SpatialTree:necsimclass_spatial_tree_1af89289a1dc549102c0137763a7d26065}}\pysiglinewithargsret{void \sphinxbfcode{simPause}}{}{}%
\pysigstopmultiline
Pause the simulation and dump data from memory. 

\end{fulllineitems}

\index{SpatialTree::dumpMap (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_SpatialTree:_CPPv2N11SpatialTree7dumpMapE6string}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_SpatialTree:necsimclass_spatial_tree_1a51b4c8703d179cc4a4c861f8b36b4a9b}}\pysiglinewithargsret{void \sphinxbfcode{dumpMap}}{string \sphinxstyleemphasis{pause\_folder}}{}%
\pysigstopmultiline
Saves the map object to file. 

\begin{description}
\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{pause\_folder}: the folder to save files into 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{SpatialTree::simResume (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_SpatialTree:_CPPv2N11SpatialTree9simResumeEv}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_SpatialTree:necsimclass_spatial_tree_1ad578ceeaf0ab3f4a2e39eb907881c11f}}\pysiglinewithargsret{void \sphinxbfcode{simResume}}{}{}%
\pysigstopmultiline
Resumes the simulation from a previous state. 

Reads in the parameters and objects from file and re-starts the simulation. 

\end{fulllineitems}

\index{SpatialTree::loadGridSave (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_SpatialTree:_CPPv2N11SpatialTree12loadGridSaveEv}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_SpatialTree:necsimclass_spatial_tree_1a6e3cfc1c0371d90ceaa7a463470de798}}\pysiglinewithargsret{void \sphinxbfcode{loadGridSave}}{}{}%
\pysigstopmultiline
Loads the grid from the save file into memory. 

\end{fulllineitems}

\index{SpatialTree::loadMapSave (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_SpatialTree:_CPPv2N11SpatialTree11loadMapSaveEv}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_SpatialTree:necsimclass_spatial_tree_1a585861bbad04528d2cabf7b1604a40dc}}\pysiglinewithargsret{void \sphinxbfcode{loadMapSave}}{}{}%
\pysigstopmultiline
Loads the map from the save file into memory. 

\end{fulllineitems}

\index{SpatialTree::verifyReproductionMap (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_SpatialTree:_CPPv2N11SpatialTree21verifyReproductionMapEv}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_SpatialTree:necsimclass_spatial_tree_1a0eb6f50f218289c79770b203d3eeaada}}\pysiglinewithargsret{void \sphinxbfcode{verifyReproductionMap}}{}{}%
\pysigstopmultiline
Checks that the reproduction map makes sense with the fine density map. 

\end{fulllineitems}

\index{SpatialTree::addWrappedLineage (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_SpatialTree:_CPPv2N11SpatialTree17addWrappedLineageEmll}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_SpatialTree:necsimclass_spatial_tree_1a5b26973b7f2dd3ca842a2eb8d2957896}}\pysiglinewithargsret{void \sphinxbfcode{addWrappedLineage}}{unsigned long \sphinxstyleemphasis{numstart}, long \sphinxstyleemphasis{x}, long \sphinxstyleemphasis{y}}{}%
\pysigstopmultiline
Adds the lineage to the correct point in the linked list of active lineages. 

\begin{description}
\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{numstart}: the active position to add 

\item {} 
\sphinxcode{x}: the x position of the lineage 

\item {} 
\sphinxcode{y}: the y position of the lineage 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{SpatialTree::countCellExpansion (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_SpatialTree:_CPPv2N11SpatialTree18countCellExpansionERKlRKlRKlRKlRKdRKb}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_SpatialTree:necsimclass_spatial_tree_1a706ec7831f8c68e9245c00ebab76414f}}\pysiglinewithargsret{unsigned long \sphinxbfcode{countCellExpansion}}{\sphinxstrong{const} long \&\sphinxstyleemphasis{x}, \sphinxstrong{const} long \&\sphinxstyleemphasis{y}, \sphinxstrong{const} long \&\sphinxstyleemphasis{xwrap}, \sphinxstrong{const} long \&\sphinxstyleemphasis{ywrap}, \sphinxstrong{const} double \&\sphinxstyleemphasis{generationin}, \sphinxstrong{const} bool \&\sphinxstyleemphasis{make\_tips}}{}%
\pysigstopmultiline
Counts the number of lineages at a particular location that need to be added, after making the correct number of those that already exist into tips. 

\begin{description}
\item[{\sphinxstylestrong{Return}}] \leavevmode
the number of new lineages that need to be added. 

\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{x}: the x coordinate of the location of interest 

\item {} 
\sphinxcode{y}: the y coordinate of the location of interest 

\item {} 
\sphinxcode{xwrap}: the x wrapping of the location 

\item {} 
\sphinxcode{ywrap}: the y wrapping of the location 

\item {} 
\sphinxcode{generationin}: the generation to assign to new tips 

\item {} 
\sphinxcode{make\_tips}: if true, stores the tips as well as counting them 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{SpatialTree::expandCell (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_SpatialTree:_CPPv2N11SpatialTree10expandCellElllldm}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_SpatialTree:necsimclass_spatial_tree_1ac986898035a4c5c159cc6db19092c159}}\pysiglinewithargsret{void \sphinxbfcode{expandCell}}{long \sphinxstyleemphasis{x}, long \sphinxstyleemphasis{y}, long \sphinxstyleemphasis{x\_wrap}, long \sphinxstyleemphasis{y\_wrap}, double \sphinxstyleemphasis{generation\_in}, unsigned long \sphinxstyleemphasis{add}}{}%
\pysigstopmultiline
Expands the cell at the desired location by adding the supplied number of lineages. 

This takes into account wrapping to correctly add the right number

\begin{description}
\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{x}: the x coordinate to add at 

\item {} 
\sphinxcode{y}: the y coordinate to add at 

\item {} 
\sphinxcode{x\_wrap}: the x wrapping to add at 

\item {} 
\sphinxcode{y\_wrap}: the y wrapping to add at 

\item {} 
\sphinxcode{generation\_in}: the generation to set the new lineages to 

\item {} 
\sphinxcode{add}: the total number of lineages to add at this location 

\end{itemize}

\end{description}


\end{fulllineitems}

\paragraph{Protected Attributes}
\index{SpatialTree::dispersal\_coordinator (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_SpatialTree:_CPPv2N11SpatialTree21dispersal_coordinatorE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{api/class_SpatialTree:necsimclass_spatial_tree_1ad238e987bbf1cf2110bd6c3b980de3e4}}{\hyperref[\detokenize{api/class_DispersalCoordinator:_CPPv220DispersalCoordinator}]{\sphinxcrossref{DispersalCoordinator}}} \sphinxbfcode{dispersal\_coordinator}}%
\pysigstopmultiline
\end{fulllineitems}

\index{SpatialTree::rep\_map (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_SpatialTree:_CPPv2N11SpatialTree7rep_mapE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{api/class_SpatialTree:necsimclass_spatial_tree_1aee26e469bc42c208feb98f6320bd9d0c}}{\hyperref[\detokenize{api/class_ReproductionMap:_CPPv215ReproductionMap}]{\sphinxcrossref{ReproductionMap}}} \sphinxbfcode{rep\_map}}%
\pysigstopmultiline
\end{fulllineitems}

\index{SpatialTree::fine\_map\_input (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_SpatialTree:_CPPv2N11SpatialTree14fine_map_inputE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{api/class_SpatialTree:necsimclass_spatial_tree_1a44fdea35be7d4496248ee27c1457ad6a}}string \sphinxbfcode{fine\_map\_input}}%
\pysigstopmultiline
\end{fulllineitems}

\index{SpatialTree::coarse\_map\_input (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_SpatialTree:_CPPv2N11SpatialTree16coarse_map_inputE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{api/class_SpatialTree:necsimclass_spatial_tree_1a464b674dbf6f2968497f698ad9a16433}}string \sphinxbfcode{coarse\_map\_input}}%
\pysigstopmultiline
\end{fulllineitems}

\index{SpatialTree::pristine\_fine\_map\_input (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_SpatialTree:_CPPv2N11SpatialTree23pristine_fine_map_inputE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{api/class_SpatialTree:necsimclass_spatial_tree_1a0b6a624a8d0a434131f3ec5e2581d8b6}}string \sphinxbfcode{pristine\_fine\_map\_input}}%
\pysigstopmultiline
\end{fulllineitems}

\index{SpatialTree::pristine\_coarse\_map\_input (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_SpatialTree:_CPPv2N11SpatialTree25pristine_coarse_map_inputE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{api/class_SpatialTree:necsimclass_spatial_tree_1abf4a4019079d23e4489420fc14f0e461}}string \sphinxbfcode{pristine\_coarse\_map\_input}}%
\pysigstopmultiline
\end{fulllineitems}

\index{SpatialTree::gen\_since\_pristine (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_SpatialTree:_CPPv2N11SpatialTree18gen_since_pristineE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{api/class_SpatialTree:necsimclass_spatial_tree_1a0ddea193979944b5df0e317cf1fe5be3}}double \sphinxbfcode{gen\_since\_pristine}}%
\pysigstopmultiline
\end{fulllineitems}

\index{SpatialTree::habitat\_change\_rate (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_SpatialTree:_CPPv2N11SpatialTree19habitat_change_rateE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{api/class_SpatialTree:necsimclass_spatial_tree_1abdb9b4692e583b7db0e292cd0e26da56}}double \sphinxbfcode{habitat\_change\_rate}}%
\pysigstopmultiline
\end{fulllineitems}

\index{SpatialTree::grid\_x\_size (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_SpatialTree:_CPPv2N11SpatialTree11grid_x_sizeE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{api/class_SpatialTree:necsimclass_spatial_tree_1aa4c60d73794de44877b9ed66b73b4ed8}}unsigned long \sphinxbfcode{grid\_x\_size}}%
\pysigstopmultiline
\end{fulllineitems}

\index{SpatialTree::grid\_y\_size (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_SpatialTree:_CPPv2N11SpatialTree11grid_y_sizeE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{api/class_SpatialTree:necsimclass_spatial_tree_1a03c67ea3848796e91a3b45afc9e99365}}unsigned long \sphinxbfcode{grid\_y\_size}}%
\pysigstopmultiline
\end{fulllineitems}

\index{SpatialTree::fine\_map\_x\_size (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_SpatialTree:_CPPv2N11SpatialTree15fine_map_x_sizeE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{api/class_SpatialTree:necsimclass_spatial_tree_1aa43ad30213722e213a5e727fa4df7d26}}long \sphinxbfcode{fine\_map\_x\_size}}%
\pysigstopmultiline
\end{fulllineitems}

\index{SpatialTree::fine\_map\_y\_size (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_SpatialTree:_CPPv2N11SpatialTree15fine_map_y_sizeE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{api/class_SpatialTree:necsimclass_spatial_tree_1ac0ed1ed58adc2099735bbee0a1ef47d9}}long \sphinxbfcode{fine\_map\_y\_size}}%
\pysigstopmultiline
\end{fulllineitems}

\index{SpatialTree::fine\_map\_x\_offset (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_SpatialTree:_CPPv2N11SpatialTree17fine_map_x_offsetE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{api/class_SpatialTree:necsimclass_spatial_tree_1ac049de6119b9a9666f3328da1c28e285}}long \sphinxbfcode{fine\_map\_x\_offset}}%
\pysigstopmultiline
\end{fulllineitems}

\index{SpatialTree::fine\_map\_y\_offset (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_SpatialTree:_CPPv2N11SpatialTree17fine_map_y_offsetE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{api/class_SpatialTree:necsimclass_spatial_tree_1ad0074b25db2a7de1bbe3a62b0e5e4e1e}}long \sphinxbfcode{fine\_map\_y\_offset}}%
\pysigstopmultiline
\end{fulllineitems}

\index{SpatialTree::coarse\_map\_x\_size (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_SpatialTree:_CPPv2N11SpatialTree17coarse_map_x_sizeE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{api/class_SpatialTree:necsimclass_spatial_tree_1a8fa4275acbf42f0fd95d8edd4ae425a9}}long \sphinxbfcode{coarse\_map\_x\_size}}%
\pysigstopmultiline
\end{fulllineitems}

\index{SpatialTree::coarse\_map\_y\_size (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_SpatialTree:_CPPv2N11SpatialTree17coarse_map_y_sizeE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{api/class_SpatialTree:necsimclass_spatial_tree_1a402d3c750b01e5fd4661d1adc4cd8659}}long \sphinxbfcode{coarse\_map\_y\_size}}%
\pysigstopmultiline
\end{fulllineitems}

\index{SpatialTree::coarse\_map\_x\_offset (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_SpatialTree:_CPPv2N11SpatialTree19coarse_map_x_offsetE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{api/class_SpatialTree:necsimclass_spatial_tree_1a37e3608962bb1af677f9cf53b5d5a4c1}}long \sphinxbfcode{coarse\_map\_x\_offset}}%
\pysigstopmultiline
\end{fulllineitems}

\index{SpatialTree::coarse\_map\_y\_offset (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_SpatialTree:_CPPv2N11SpatialTree19coarse_map_y_offsetE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{api/class_SpatialTree:necsimclass_spatial_tree_1a37988dc296cb7e58de13630a58685b0d}}long \sphinxbfcode{coarse\_map\_y\_offset}}%
\pysigstopmultiline
\end{fulllineitems}

\index{SpatialTree::coarse\_map\_scale (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_SpatialTree:_CPPv2N11SpatialTree16coarse_map_scaleE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{api/class_SpatialTree:necsimclass_spatial_tree_1ae4659e7c636e1796e1f3acef1724a38c}}long \sphinxbfcode{coarse\_map\_scale}}%
\pysigstopmultiline
\end{fulllineitems}

\index{SpatialTree::habitat\_map (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_SpatialTree:_CPPv2N11SpatialTree11habitat_mapE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{api/class_SpatialTree:necsimclass_spatial_tree_1a3849ee88827d7278afe73cce56408d83}}{\hyperref[\detokenize{api/class_Map:_CPPv23Map}]{\sphinxcrossref{Map}}} \sphinxbfcode{habitat\_map}}%
\pysigstopmultiline
\end{fulllineitems}

\index{SpatialTree::grid (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_SpatialTree:_CPPv2N11SpatialTree4gridE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{api/class_SpatialTree:necsimclass_spatial_tree_1a199167b149b25c506fdaeb660d595658}}{\hyperref[\detokenize{api/class_Matrix:_CPPv26Matrix}]{\sphinxcrossref{Matrix}}}\textless{}{\hyperref[\detokenize{api/class_SpeciesList:_CPPv211SpeciesList}]{\sphinxcrossref{SpeciesList}}}\textgreater{} \sphinxbfcode{grid}}%
\pysigstopmultiline
\end{fulllineitems}

\index{SpatialTree::sigma (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_SpatialTree:_CPPv2N11SpatialTree5sigmaE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{api/class_SpatialTree:necsimclass_spatial_tree_1a26bf90b6b6e5f18d53b4d96f11dcce36}}double \sphinxbfcode{sigma}}%
\pysigstopmultiline
\end{fulllineitems}

\index{SpatialTree::tau (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_SpatialTree:_CPPv2N11SpatialTree3tauE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{api/class_SpatialTree:necsimclass_spatial_tree_1acf53651097bb38ef7aae42445e73ccb4}}double \sphinxbfcode{tau}}%
\pysigstopmultiline
\end{fulllineitems}

\index{SpatialTree::dispersal\_relative\_cost (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_SpatialTree:_CPPv2N11SpatialTree23dispersal_relative_costE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{api/class_SpatialTree:necsimclass_spatial_tree_1a92a159ead42d431773a52989254a1379}}double \sphinxbfcode{dispersal\_relative\_cost}}%
\pysigstopmultiline
\end{fulllineitems}

\index{SpatialTree::desired\_specnum (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_SpatialTree:_CPPv2N11SpatialTree15desired_specnumE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{api/class_SpatialTree:necsimclass_spatial_tree_1a694c7eb6c70687ea87e49066a8957877}}unsigned long \sphinxbfcode{desired\_specnum}}%
\pysigstopmultiline
\end{fulllineitems}

\index{SpatialTree::samplegrid (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_SpatialTree:_CPPv2N11SpatialTree10samplegridE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{api/class_SpatialTree:necsimclass_spatial_tree_1ad902e850c9573b5c26ef6d77a203f72d}}{\hyperref[\detokenize{api/class_DataMask:_CPPv28DataMask}]{\sphinxcrossref{DataMask}}} \sphinxbfcode{samplegrid}}%
\pysigstopmultiline
\end{fulllineitems}


\end{fulllineitems}



\subsection{Class SpeciationCommands}
\label{\detokenize{api/class_SpeciationCommands:class-speciationcommands}}\label{\detokenize{api/class_SpeciationCommands::doc}}\label{\detokenize{api/class_SpeciationCommands:id1}}\begin{itemize}
\item {} 
Defined in {\hyperref[\detokenize{api/file_necsim_SpeciationCommands.h:file-necsim-speciationcommands-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File SpeciationCommands.h}}}}

\end{itemize}


\subsubsection{Class Documentation}
\label{\detokenize{api/class_SpeciationCommands:class-documentation}}\index{SpeciationCommands (C++ class)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_SpeciationCommands:_CPPv218SpeciationCommands}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_SpeciationCommands:necsimclass_speciation_commands}}\pysigline{\sphinxstrong{class }\sphinxcode{}\sphinxbfcode{SpeciationCommands}}%
\pysigstopmultiline
Routines for parsing command-line arguments to apply speciation rates to a necsim output post-simulation. 
\paragraph{Public Functions}
\index{SpeciationCommands::SpeciationCommands (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_SpeciationCommands:_CPPv2N18SpeciationCommands18SpeciationCommandsEv}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_SpeciationCommands:necsimclass_speciation_commands_1a6e693fcd81d61fd8d4c04af39f851e49}}\pysiglinewithargsret{\sphinxbfcode{SpeciationCommands}}{}{}%
\pysigstopmultiline
Default constructor for {\hyperref[\detokenize{api/class_SpeciationCommands:necsimclass_speciation_commands}]{\sphinxcrossref{\DUrole{std,std-ref}{SpeciationCommands}}}} class. 

\end{fulllineitems}

\index{SpeciationCommands::parseArgs (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_SpeciationCommands:_CPPv2N18SpeciationCommands9parseArgsEv}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_SpeciationCommands:necsimclass_speciation_commands_1a691dfe450b005f1fa50e1e6fc0027db7}}\pysiglinewithargsret{void \sphinxbfcode{parseArgs}}{}{}%
\pysigstopmultiline
Run the command line arguments check. Writes arguments to the {\hyperref[\detokenize{api/class_SpecSimParameters:necsimstruct_spec_sim_parameters}]{\sphinxcrossref{\DUrole{std,std-ref}{SpecSimParameters}}}} object. 

\begin{description}
\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{argc}: the number of arguments. 

\item {} 
\sphinxcode{comargs}: a vector filled with the command line arguments 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{SpeciationCommands::applyFromComargs (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_SpeciationCommands:_CPPv2N18SpeciationCommands16applyFromComargsEiPPc}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_SpeciationCommands:necsimclass_speciation_commands_1a2ac0cf0a39c9c88b76d88c1d5d65f01a}}\pysiglinewithargsret{int \sphinxbfcode{applyFromComargs}}{int \sphinxstyleemphasis{argc\_in}, char **\sphinxstyleemphasis{argv}}{}%
\pysigstopmultiline
Runs the main program including parsing command line arguments and running the main analyses. 

\begin{description}
\item[{\sphinxstylestrong{Return}}] \leavevmode


\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{argc}: the number of command line arguments 

\item {} 
\sphinxcode{argv}: the array of command line arguments 

\end{itemize}

\end{description}


\end{fulllineitems}


\end{fulllineitems}



\subsection{Class SpeciesList}
\label{\detokenize{api/class_SpeciesList:class-specieslist}}\label{\detokenize{api/class_SpeciesList::doc}}\label{\detokenize{api/class_SpeciesList:id1}}\begin{itemize}
\item {} 
Defined in {\hyperref[\detokenize{api/file_necsim_SpeciesList.h:file-necsim-specieslist-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File SpeciesList.h}}}}

\end{itemize}


\subsubsection{Class Documentation}
\label{\detokenize{api/class_SpeciesList:class-documentation}}\index{SpeciesList (C++ class)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_SpeciesList:_CPPv211SpeciesList}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_SpeciesList:necsimclass_species_list}}\pysigline{\sphinxstrong{class }\sphinxcode{}\sphinxbfcode{SpeciesList}}%
\pysigstopmultiline
Contains a list of the species that exist at one location. The {\hyperref[\detokenize{api/class_Row:necsimclass_row}]{\sphinxcrossref{\DUrole{std,std-ref}{Row}}}} object, list, contains the active reference number, for looking up the lineage in a {\hyperref[\detokenize{api/class_Row:necsimclass_row}]{\sphinxcrossref{\DUrole{std,std-ref}{Row}}}} of Datapoint objects. Also contains the functions for correctly generating coalescence probabilities and list management. 

Note that the maximum size of the list is constrained by the maximum size of unsigned long. Any simulation requiring more individuals per cell than this will unlikely finish in any reasonable time anyway. 
\paragraph{Public Functions}
\index{SpeciesList::SpeciesList (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_SpeciesList:_CPPv2N11SpeciesList11SpeciesListEv}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_SpeciesList:necsimclass_species_list_1a5ebcb2cf12fc4e7a3d8bbd650814a5fb}}\pysiglinewithargsret{\sphinxbfcode{SpeciesList}}{}{}%
\pysigstopmultiline
Default constructor. 

\end{fulllineitems}

\index{SpeciesList::\textasciitilde{}SpeciesList (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_SpeciesList:_CPPv2N11SpeciesListD0Ev}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_SpeciesList:necsimclass_species_list_1a16e2d58a8643fa58eb25e8258682965c}}\pysiglinewithargsret{\sphinxbfcode{\textasciitilde{}SpeciesList}}{}{}%
\pysigstopmultiline
Default destructor. 

\end{fulllineitems}

\index{SpeciesList::fillList (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_SpeciesList:_CPPv2N11SpeciesList8fillListEv}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_SpeciesList:necsimclass_species_list_1ad617317047f221e64066dd851b9e8d2d}}\pysiglinewithargsret{void \sphinxbfcode{fillList}}{}{}%
\pysigstopmultiline
Fills the list with 0, up to the specified maximum size. 

\end{fulllineitems}

\index{SpeciesList::initialise (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_SpeciesList:_CPPv2N11SpeciesList10initialiseEm}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_SpeciesList:necsimclass_species_list_1ab36fdc058217514e66e6152479dfab8d}}\pysiglinewithargsret{void \sphinxbfcode{initialise}}{unsigned long \sphinxstyleemphasis{maxsizein}}{}%
\pysigstopmultiline
Initialises the list to the specified size. 

\begin{description}
\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{maxsizein}: the maximum list size. 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{SpeciesList::setMaxsize (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_SpeciesList:_CPPv2N11SpeciesList10setMaxsizeEm}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_SpeciesList:necsimclass_species_list_1a8532bddc8397cf50531639c50cccbef3}}\pysiglinewithargsret{void \sphinxbfcode{setMaxsize}}{unsigned long \sphinxstyleemphasis{maxsizein}}{}%
\pysigstopmultiline
Sets the maxsize without altering the actual size of list. 

\begin{description}
\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{maxsizein}: The new maximum size to set. 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{SpeciesList::setSpecies (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_SpeciesList:_CPPv2N11SpeciesList10setSpeciesEmm}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_SpeciesList:necsimclass_species_list_1a98f19fa65ed7cbe4536342ce2dff2b7b}}\pysiglinewithargsret{void \sphinxbfcode{setSpecies}}{unsigned long \sphinxstyleemphasis{index}, unsigned long \sphinxstyleemphasis{new\_val}}{}%
\pysigstopmultiline
Set specific entry to a particular species reference number. 


This version throws an error if the space is empty. \begin{description}
\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{index}: the location in list of the species. 

\item {} 
\sphinxcode{new\_val}: the new species reference to set list{[}index{]} to.

\end{itemize}

\end{description}


\end{fulllineitems}

\index{SpeciesList::setSpeciesEmpty (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_SpeciesList:_CPPv2N11SpeciesList15setSpeciesEmptyEim}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_SpeciesList:necsimclass_species_list_1ae4b1baaacea721479c8585d36b475c96}}\pysiglinewithargsret{void \sphinxbfcode{setSpeciesEmpty}}{int \sphinxstyleemphasis{index}, unsigned long \sphinxstyleemphasis{new\_val}}{}%
\pysigstopmultiline
Set specific entry to a particular species reference number. 


Note this version will throw a runtime\_error if the space is not empty \begin{description}
\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{index}: the location in list of the species 

\item {} 
\sphinxcode{new\_val}: the new species reference to set list{[}index{]} to

\end{itemize}

\end{description}


\end{fulllineitems}

\index{SpeciesList::setNext (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_SpeciesList:_CPPv2N11SpeciesList7setNextEm}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_SpeciesList:necsimclass_species_list_1a627f9d95948f4a2cb6cfb3d8b8f9f2ea}}\pysiglinewithargsret{void \sphinxbfcode{setNext}}{unsigned long \sphinxstyleemphasis{n}}{}%
\pysigstopmultiline
Set the next active lineage (for wrapping purposes). 

\begin{description}
\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{n}: the lineage to set as the first wrapped lineage. 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{SpeciesList::setNwrap (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_SpeciesList:_CPPv2N11SpeciesList8setNwrapEm}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_SpeciesList:necsimclass_species_list_1ad3f8f91e3983b8829c0b405013b2709e}}\pysiglinewithargsret{void \sphinxbfcode{setNwrap}}{unsigned long \sphinxstyleemphasis{nr}}{}%
\pysigstopmultiline
Set the number of wrapping lineages. 

\begin{description}
\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{nr}: the number of wrapped lineages. 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{SpeciesList::addSpecies (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_SpeciesList:_CPPv2N11SpeciesList10addSpeciesEm}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_SpeciesList:necsimclass_species_list_1a4a54fa9e6c07f8d75d9cddbf9a04da19}}\pysiglinewithargsret{unsigned long \sphinxbfcode{addSpecies}}{unsigned long \sphinxstyleemphasis{new\_spec}}{}%
\pysigstopmultiline
Add a new species to the first empty place and return the position of the lineage. 

\begin{description}
\item[{\sphinxstylestrong{Return}}] \leavevmode
the location the species has been added to. 

\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{new\_spec}: the new species reference to place in the first empty space. 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{SpeciesList::addSpeciesSilent (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_SpeciesList:_CPPv2N11SpeciesList16addSpeciesSilentEm}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_SpeciesList:necsimclass_species_list_1af84a5aa6584f16dfb8e8f2ce379cf947}}\pysiglinewithargsret{void \sphinxbfcode{addSpeciesSilent}}{unsigned long \sphinxstyleemphasis{new\_spec}}{}%
\pysigstopmultiline
Add a new species to the first empty place. Essentially a version of {\hyperref[\detokenize{api/class_SpeciesList:necsimclass_species_list_1a4a54fa9e6c07f8d75d9cddbf9a04da19}]{\sphinxcrossref{\DUrole{std,std-ref}{addSpecies()}}}} without returning the species location. 

\begin{description}
\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{new\_spec}: the new species reference to place in the first empty space. 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{SpeciesList::deleteSpecies (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_SpeciesList:_CPPv2N11SpeciesList13deleteSpeciesEm}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_SpeciesList:necsimclass_species_list_1af7464b3a3ea20220634ab38476a195e4}}\pysiglinewithargsret{void \sphinxbfcode{deleteSpecies}}{unsigned long \sphinxstyleemphasis{index}}{}%
\pysigstopmultiline
Removes the species at the specified index. The species number will be replaced with 0, indicating no species present. 

Older versions of this function re-shuffled the list so that all species came at the top. \begin{description}
\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{index}: the index of the species to remove from the list. 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{SpeciesList::decreaseNwrap (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_SpeciesList:_CPPv2N11SpeciesList13decreaseNwrapEv}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_SpeciesList:necsimclass_species_list_1a15420717ab0ba00bba0ff55f971ee3d2}}\pysiglinewithargsret{void \sphinxbfcode{decreaseNwrap}}{}{}%
\pysigstopmultiline
Decreases the nwrap by one. 

Indicates the number of species wrapped at the location of this {\hyperref[\detokenize{api/class_SpeciesList:necsimclass_species_list}]{\sphinxcrossref{\DUrole{std,std-ref}{SpeciesList}}}} object has decreased by one. 

\end{fulllineitems}

\index{SpeciesList::increaseListSize (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_SpeciesList:_CPPv2N11SpeciesList16increaseListSizeEv}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_SpeciesList:necsimclass_species_list_1ac15ecbcddcce068f75162dac03eafcfc}}\pysiglinewithargsret{void \sphinxbfcode{increaseListSize}}{}{}%
\pysigstopmultiline
Increases the list size by one. 

\end{fulllineitems}

\index{SpeciesList::increaseNwrap (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_SpeciesList:_CPPv2N11SpeciesList13increaseNwrapEv}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_SpeciesList:necsimclass_species_list_1aa9e64b4e922b43c17e188ca2038cb18a}}\pysiglinewithargsret{void \sphinxbfcode{increaseNwrap}}{}{}%
\pysigstopmultiline
Increases the nwrap by one. 

Indicates the number of species wrapped at the location of this {\hyperref[\detokenize{api/class_SpeciesList:necsimclass_species_list}]{\sphinxcrossref{\DUrole{std,std-ref}{SpeciesList}}}} object has increased by one. 

\end{fulllineitems}

\index{SpeciesList::changePercentCover (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_SpeciesList:_CPPv2N11SpeciesList18changePercentCoverEm}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_SpeciesList:necsimclass_species_list_1a40206bc9836f394653997a61c1c8617a}}\pysiglinewithargsret{void \sphinxbfcode{changePercentCover}}{unsigned long \sphinxstyleemphasis{newmaxsize}}{}%
\pysigstopmultiline
Changes the maximum size of the {\hyperref[\detokenize{api/class_SpeciesList:necsimclass_species_list}]{\sphinxcrossref{\DUrole{std,std-ref}{SpeciesList}}}}. Creates a new list object with all the species in the correct place from the old list object and zeros everywhere else. 

\begin{description}
\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{newmaxsize}: the new maximum size to be applied. 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{SpeciesList::getRandLineage (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_SpeciesList:_CPPv2N11SpeciesList14getRandLineageER6NRrand}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_SpeciesList:necsimclass_species_list_1a8e57aa257510bf61680e53c548fd4610}}\pysiglinewithargsret{unsigned long \sphinxbfcode{getRandLineage}}{{\hyperref[\detokenize{api/class_NRrand:_CPPv26NRrand}]{\sphinxcrossref{NRrand}}} \&\sphinxstyleemphasis{rand\_no}}{}%
\pysigstopmultiline
Get a random species reference number from all the potential entries. Updated alternative version returns any entry, including empty cells, giving the probability of coalescence as well. 

\begin{description}
\item[{\sphinxstylestrong{Return}}] \leavevmode
the reference of the random lineage. 0 indicates an empty space. 

\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{rand\_no}: the random number object to pass (for maintaining the same seed throughout simulations). 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{SpeciesList::getSpecies (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_SpeciesList:_CPPv2N11SpeciesList10getSpeciesEm}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_SpeciesList:necsimclass_species_list_1ab215c2790feb1a721c759bbb1c434f85}}\pysiglinewithargsret{unsigned long \sphinxbfcode{getSpecies}}{unsigned long \sphinxstyleemphasis{index}}{}%
\pysigstopmultiline
Get the species reference number from a particular entry. 

\begin{description}
\item[{\sphinxstylestrong{Return}}] \leavevmode
the species reference at the specified location. 

\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{index}: the location of the species to reference. 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{SpeciesList::getNext (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_SpeciesList:_CPPv2N11SpeciesList7getNextEv}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_SpeciesList:necsimclass_species_list_1ac3fffc2d47557af6964cb25336d0e5cc}}\pysiglinewithargsret{unsigned long \sphinxbfcode{getNext}}{}{}%
\pysigstopmultiline
Get the next\_active variable. 

\begin{description}
\item[{\sphinxstylestrong{Return}}] \leavevmode
the next linked species reference. 

\end{description}


\end{fulllineitems}

\index{SpeciesList::getNwrap (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_SpeciesList:_CPPv2N11SpeciesList8getNwrapEv}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_SpeciesList:necsimclass_species_list_1a9cd0acb0d22d6b14c4d58668cdb36af3}}\pysiglinewithargsret{unsigned long \sphinxbfcode{getNwrap}}{}{}%
\pysigstopmultiline
Getter for the nwrap. 

\begin{description}
\item[{\sphinxstylestrong{Return}}] \leavevmode
the number of wrapped lineages currently at this grid cell. 

\end{description}


\end{fulllineitems}

\index{SpeciesList::getListsize (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_SpeciesList:_CPPv2N11SpeciesList11getListsizeEv}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_SpeciesList:necsimclass_species_list_1a9c6206262b57a450eb92c95f94bd59f7}}\pysiglinewithargsret{unsigned long \sphinxbfcode{getListsize}}{}{}%
\pysigstopmultiline
Getter for the list size. 

\begin{description}
\item[{\sphinxstylestrong{Return}}] \leavevmode
the number of lineages currently directly within the {\hyperref[\detokenize{api/class_SpeciesList:necsimclass_species_list}]{\sphinxcrossref{\DUrole{std,std-ref}{SpeciesList}}}}. 

\end{description}


\end{fulllineitems}

\index{SpeciesList::getMaxsize (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_SpeciesList:_CPPv2N11SpeciesList10getMaxsizeEv}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_SpeciesList:necsimclass_species_list_1ad7d1f16709df32455743995ecb61ed9e}}\pysiglinewithargsret{unsigned long \sphinxbfcode{getMaxsize}}{}{}%
\pysigstopmultiline
Getter for the maximum size of the {\hyperref[\detokenize{api/class_SpeciesList:necsimclass_species_list}]{\sphinxcrossref{\DUrole{std,std-ref}{SpeciesList}}}} object. 

\begin{description}
\item[{\sphinxstylestrong{Return}}] \leavevmode
the maximum number of lineages that can exist currently. 

\end{description}


\end{fulllineitems}

\index{SpeciesList::wipeList (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_SpeciesList:_CPPv2N11SpeciesList8wipeListEv}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_SpeciesList:necsimclass_species_list_1acd0fd4ab7517523f04d8c37bb918d390}}\pysiglinewithargsret{void \sphinxbfcode{wipeList}}{}{}%
\pysigstopmultiline
Empties the list of any data and fills the list with zeros. 

\end{fulllineitems}

\paragraph{Friends}
\index{operator\textless{}\textless{} (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_SpeciesList:_CPPv2lsR7ostreamRK11SpeciesList}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_SpeciesList:necsimclass_species_list_1a307fffef634cd0a4615794ef7498cd4a}}\pysiglinewithargsret{ostream \&\sphinxbfcode{operator\textless{}\textless{}}}{ostream \&\sphinxstyleemphasis{os}, \sphinxstrong{const} {\hyperref[\detokenize{api/class_SpeciesList:_CPPv211SpeciesList}]{\sphinxcrossref{SpeciesList}}} \&\sphinxstyleemphasis{r}}{}%
\pysigstopmultiline
Outputs the {\hyperref[\detokenize{api/class_SpeciesList:necsimclass_species_list}]{\sphinxcrossref{\DUrole{std,std-ref}{SpeciesList}}}} object to an output stream. Allows for piping to the terminal or writing the object to a file. 

\begin{description}
\item[{\sphinxstylestrong{Return}}] \leavevmode
the output stream. 

\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{os}: the output stream. 

\item {} 
\sphinxcode{r}: the {\hyperref[\detokenize{api/class_SpeciesList:necsimclass_species_list}]{\sphinxcrossref{\DUrole{std,std-ref}{SpeciesList}}}} object to output. 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{operator\textgreater{}\textgreater{} (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_SpeciesList:_CPPv2rsR7istreamR11SpeciesList}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_SpeciesList:necsimclass_species_list_1a2d74faa6012ce148a9f437249390c294}}\pysiglinewithargsret{istream \&\sphinxbfcode{operator\textgreater{}\textgreater{}}}{istream \&\sphinxstyleemphasis{is}, {\hyperref[\detokenize{api/class_SpeciesList:_CPPv211SpeciesList}]{\sphinxcrossref{SpeciesList}}} \&\sphinxstyleemphasis{r}}{}%
\pysigstopmultiline
Inputs the {\hyperref[\detokenize{api/class_SpeciesList:necsimclass_species_list}]{\sphinxcrossref{\DUrole{std,std-ref}{SpeciesList}}}} object from an input stream. Allows for reading data from a file or string stream. 

\begin{description}
\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{is}: the input stream. 

\item {} 
\sphinxcode{r}: the {\hyperref[\detokenize{api/class_SpeciesList:necsimclass_species_list}]{\sphinxcrossref{\DUrole{std,std-ref}{SpeciesList}}}} object to input to. 

\end{itemize}

\end{description}


\end{fulllineitems}


\end{fulllineitems}



\subsection{Class SpecSimParameters}
\label{\detokenize{api/class_SpecSimParameters:class-specsimparameters}}\label{\detokenize{api/class_SpecSimParameters::doc}}\label{\detokenize{api/class_SpecSimParameters:id1}}\begin{itemize}
\item {} 
Defined in {\hyperref[\detokenize{api/file_necsim_SpecSimParameters.h:file-necsim-specsimparameters-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File SpecSimParameters.h}}}}

\end{itemize}


\subsubsection{Class Documentation}
\label{\detokenize{api/class_SpecSimParameters:class-documentation}}\index{SpecSimParameters (C++ class)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_SpecSimParameters:_CPPv217SpecSimParameters}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_SpecSimParameters:necsimstruct_spec_sim_parameters}}\pysigline{\sphinxstrong{class }\sphinxcode{}\sphinxbfcode{SpecSimParameters}}%
\pysigstopmultiline
Contains the simulation parameters that are read from the command line. 
\paragraph{Public Functions}
\index{SpecSimParameters::setup (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_SpecSimParameters:_CPPv2N17SpecSimParameters5setupE6stringb6string6string6string6vectorIdEdd}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_SpecSimParameters:necsimstruct_spec_sim_parameters_1ad2b6362214ce80114e602ee04413fc56}}\pysiglinewithargsret{void \sphinxbfcode{setup}}{string \sphinxstyleemphasis{file\_in}, bool \sphinxstyleemphasis{use\_spatial\_in}, string \sphinxstyleemphasis{sample\_file}, string \sphinxstyleemphasis{time\_config}, string \sphinxstyleemphasis{use\_fragments\_in}, vector\textless{}double\textgreater{} \sphinxstyleemphasis{speciation\_rates}, double \sphinxstyleemphasis{min\_speciation\_gen\_in}, double \sphinxstyleemphasis{max\_speciation\_gen\_in}}{}%
\pysigstopmultiline
Sets the application arguments for the inputs. Intended for use with the applyspecmodule for integration with python. 

\begin{description}
\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{file\_in}: the database to apply speciation rates to 

\item {} 
\sphinxcode{use\_spatial\_in}: if true, record full spatial data 

\item {} 
\sphinxcode{sample\_file}: the sample file to select lineages from the map 

\item {} 
\sphinxcode{time\_config}: the time config file to use 

\item {} 
\sphinxcode{use\_fragments\_in}: fragment file, or \sphinxquotedblleft{}T\sphinxquotedblright{}/\sphinxquotedblright{}F\sphinxquotedblright{} for automatic detection/no detection 

\item {} 
\sphinxcode{speciation\_rates}: the speciation rates to apply 

\item {} 
\sphinxcode{min\_speciation\_gen\_in}: the minimum generation rate for speciation in protracted simulations 

\item {} 
\sphinxcode{max\_speciation\_gen\_in}: the maximum generation rate for speciation in protracted simulations 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{SpecSimParameters::setup (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_SpecSimParameters:_CPPv2N17SpecSimParameters5setupE6stringb6string6string6string6vectorIdEddmd}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_SpecSimParameters:necsimstruct_spec_sim_parameters_1affff445e6b2dc27c00dcdb6f0779fba2}}\pysiglinewithargsret{void \sphinxbfcode{setup}}{string \sphinxstyleemphasis{file\_in}, bool \sphinxstyleemphasis{use\_spatial\_in}, string \sphinxstyleemphasis{sample\_file}, string \sphinxstyleemphasis{time\_config}, string \sphinxstyleemphasis{use\_fragments\_in}, vector\textless{}double\textgreater{} \sphinxstyleemphasis{speciation\_rates}, double \sphinxstyleemphasis{min\_speciation\_gen\_in}, double \sphinxstyleemphasis{max\_speciation\_gen\_in}, unsigned long \sphinxstyleemphasis{metacommunity\_size\_in}, double \sphinxstyleemphasis{metacommunity\_speciation\_rate\_in}}{}%
\pysigstopmultiline
Sets the application arguments for the inputs. Intended for use with the applyspecmodule for integration with python. 

\begin{description}
\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{file\_in}: the database to apply speciation rates to 

\item {} 
\sphinxcode{use\_spatial\_in}: if true, record full spatial data 

\item {} 
\sphinxcode{sample\_file}: the sample file to select lineages from the map 

\item {} 
\sphinxcode{time\_config}: the time config file to use 

\item {} 
\sphinxcode{use\_fragments\_in}: fragment file, or \sphinxquotedblleft{}T\sphinxquotedblright{}/\sphinxquotedblright{}F\sphinxquotedblright{} for automatic detection/no detection 

\item {} 
\sphinxcode{speciation\_rates}: the speciation rates to apply 

\item {} 
\sphinxcode{min\_speciation\_gen\_in}: the minimum generation rate for speciation in protracted simulations 

\item {} 
\sphinxcode{max\_speciation\_gen\_in}: the maximum generation rate for speciation in protracted simulations 

\item {} 
\sphinxcode{metacommunity\_size\_in}: 

\item {} 
\sphinxcode{metacommunity\_speciation\_rate\_in}: 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{SpecSimParameters::importTimeConfig (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_SpecSimParameters:_CPPv2N17SpecSimParameters16importTimeConfigEv}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_SpecSimParameters:necsimstruct_spec_sim_parameters_1ae0196a50a551a821b75b6e92a35534a7}}\pysiglinewithargsret{void \sphinxbfcode{importTimeConfig}}{}{}%
\pysigstopmultiline
Import the time config file, if there is one. 

\end{fulllineitems}

\paragraph{Public Members}
\index{SpecSimParameters::use\_spatial (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_SpecSimParameters:_CPPv2N17SpecSimParameters11use_spatialE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{api/class_SpecSimParameters:necsimstruct_spec_sim_parameters_1a7baa6db5f411b4fdb9dd5fae0fd25a26}}bool \sphinxbfcode{use\_spatial}}%
\pysigstopmultiline
\end{fulllineitems}

\index{SpecSimParameters::bMultiRun (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_SpecSimParameters:_CPPv2N17SpecSimParameters9bMultiRunE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{api/class_SpecSimParameters:necsimstruct_spec_sim_parameters_1a7ca69d2db2aaf8cdcc62b1ec854f72bf}}bool \sphinxbfcode{bMultiRun}}%
\pysigstopmultiline
\end{fulllineitems}

\index{SpecSimParameters::use\_fragments (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_SpecSimParameters:_CPPv2N17SpecSimParameters13use_fragmentsE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{api/class_SpecSimParameters:necsimstruct_spec_sim_parameters_1ae2a8648d57c4b7df097bd450ab868e64}}bool \sphinxbfcode{use\_fragments}}%
\pysigstopmultiline
\end{fulllineitems}

\index{SpecSimParameters::filename (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_SpecSimParameters:_CPPv2N17SpecSimParameters8filenameE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{api/class_SpecSimParameters:necsimstruct_spec_sim_parameters_1a39beb88bb0ce36265bb0b8c8468cbe48}}string \sphinxbfcode{filename}}%
\pysigstopmultiline
\end{fulllineitems}

\index{SpecSimParameters::all\_speciation\_rates (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_SpecSimParameters:_CPPv2N17SpecSimParameters20all_speciation_ratesE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{api/class_SpecSimParameters:necsimstruct_spec_sim_parameters_1af70bb0689f934fd5ec5ea1878a3e4011}}vector\textless{}double\textgreater{} \sphinxbfcode{all\_speciation\_rates}}%
\pysigstopmultiline
\end{fulllineitems}

\index{SpecSimParameters::samplemask (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_SpecSimParameters:_CPPv2N17SpecSimParameters10samplemaskE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{api/class_SpecSimParameters:necsimstruct_spec_sim_parameters_1add68fe2a48b1d80173c5066bf9cd0f6c}}string \sphinxbfcode{samplemask}}%
\pysigstopmultiline
\end{fulllineitems}

\index{SpecSimParameters::times\_file (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_SpecSimParameters:_CPPv2N17SpecSimParameters10times_fileE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{api/class_SpecSimParameters:necsimstruct_spec_sim_parameters_1a83a3ce34449db0152e0012838c0ac3a6}}string \sphinxbfcode{times\_file}}%
\pysigstopmultiline
\end{fulllineitems}

\index{SpecSimParameters::all\_times (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_SpecSimParameters:_CPPv2N17SpecSimParameters9all_timesE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{api/class_SpecSimParameters:necsimstruct_spec_sim_parameters_1a2a61028935128b94785b6faca0a5788f}}vector\textless{}double\textgreater{} \sphinxbfcode{all\_times}}%
\pysigstopmultiline
\end{fulllineitems}

\index{SpecSimParameters::fragment\_config\_file (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_SpecSimParameters:_CPPv2N17SpecSimParameters20fragment_config_fileE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{api/class_SpecSimParameters:necsimstruct_spec_sim_parameters_1adef81f827b1402d19f318c66f295c62a}}string \sphinxbfcode{fragment\_config\_file}}%
\pysigstopmultiline
\end{fulllineitems}

\index{SpecSimParameters::min\_speciation\_gen (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_SpecSimParameters:_CPPv2N17SpecSimParameters18min_speciation_genE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{api/class_SpecSimParameters:necsimstruct_spec_sim_parameters_1a386648731706431c9972b76faa2ba7ec}}double \sphinxbfcode{min\_speciation\_gen}}%
\pysigstopmultiline
\end{fulllineitems}

\index{SpecSimParameters::max\_speciation\_gen (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_SpecSimParameters:_CPPv2N17SpecSimParameters18max_speciation_genE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{api/class_SpecSimParameters:necsimstruct_spec_sim_parameters_1a1930497f64e7f914b8f93aa1fb2d8bff}}double \sphinxbfcode{max\_speciation\_gen}}%
\pysigstopmultiline
\end{fulllineitems}

\index{SpecSimParameters::metacommunity\_size (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_SpecSimParameters:_CPPv2N17SpecSimParameters18metacommunity_sizeE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{api/class_SpecSimParameters:necsimstruct_spec_sim_parameters_1a5afee22112d2be5b0dc730553e01d2cd}}unsigned long \sphinxbfcode{metacommunity\_size}}%
\pysigstopmultiline
\end{fulllineitems}

\index{SpecSimParameters::metacommunity\_speciation\_rate (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_SpecSimParameters:_CPPv2N17SpecSimParameters29metacommunity_speciation_rateE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{api/class_SpecSimParameters:necsimstruct_spec_sim_parameters_1a4aa21c1b3e61729fb6f25d1b5cf38bd2}}double \sphinxbfcode{metacommunity\_speciation\_rate}}%
\pysigstopmultiline
\end{fulllineitems}


\end{fulllineitems}



\subsection{Class Step}
\label{\detokenize{api/class_Step::doc}}\label{\detokenize{api/class_Step:class-step}}\label{\detokenize{api/class_Step:id1}}\begin{itemize}
\item {} 
Defined in {\hyperref[\detokenize{api/file_necsim_Step.h:file-necsim-step-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File Step.h}}}}

\end{itemize}


\subsubsection{Class Documentation}
\label{\detokenize{api/class_Step:class-documentation}}\index{Step (C++ class)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Step:_CPPv24Step}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_Step:necsimstruct_step}}\pysigline{\sphinxstrong{class }\sphinxcode{}\sphinxbfcode{Step}}%
\pysigstopmultiline
Stores the elements associated with a single step in a coalescence simulation. 

This object should only contain transient variables that are used within a single simulation step and therefore should not be important for pausing/resuming simulations. 
\paragraph{Public Functions}
\index{Step::Step (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Step:_CPPv2N4Step4StepEv}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_Step:necsimstruct_step_1a3f66a321aa9c417352a75c85cff5aca5}}\pysiglinewithargsret{\sphinxbfcode{Step}}{}{}%
\pysigstopmultiline
{\hyperref[\detokenize{api/class_Step:necsimstruct_step}]{\sphinxcrossref{\DUrole{std,std-ref}{Step}}}} constructor. 

\begin{description}
\item[{\sphinxstylestrong{Return}}] \leavevmode


\end{description}


\end{fulllineitems}

\index{Step::wipeData (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Step:_CPPv2N4Step8wipeDataEv}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_Step:necsimstruct_step_1ac70e891f944dbeba29bfd1d168b9593c}}\pysiglinewithargsret{void \sphinxbfcode{wipeData}}{}{}%
\pysigstopmultiline
Removes all stored data from the step. This should be run at the start of a single coalescence step. 

\end{fulllineitems}

\paragraph{Public Members}
\index{Step::chosen (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Step:_CPPv2N4Step6chosenE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{api/class_Step:necsimstruct_step_1a03a0984250a050752ff20129ff457510}}unsigned long \sphinxbfcode{chosen}}%
\pysigstopmultiline
\end{fulllineitems}

\index{Step::coalchosen (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Step:_CPPv2N4Step10coalchosenE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{api/class_Step:necsimstruct_step_1a5824c6f227fbe3aa249f6067bae0aab2}}unsigned long \sphinxbfcode{coalchosen}}%
\pysigstopmultiline
\end{fulllineitems}

\index{Step::oldx (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Step:_CPPv2N4Step4oldxE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{api/class_Step:necsimstruct_step_1a79f782f87fe4df1f7df10bc6b102530a}}long \sphinxbfcode{oldx}}%
\pysigstopmultiline
\end{fulllineitems}

\index{Step::oldy (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Step:_CPPv2N4Step4oldyE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{api/class_Step:necsimstruct_step_1afde730c847c774e13f96c36a2a87a818}}long \sphinxbfcode{oldy}}%
\pysigstopmultiline
\end{fulllineitems}

\index{Step::oldxwrap (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Step:_CPPv2N4Step8oldxwrapE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{api/class_Step:necsimstruct_step_1ad627fdb344ea1b6e143bf81794955f9a}}long \sphinxbfcode{oldxwrap}}%
\pysigstopmultiline
\end{fulllineitems}

\index{Step::oldywrap (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Step:_CPPv2N4Step8oldywrapE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{api/class_Step:necsimstruct_step_1ae18da2822c5603f935b02454c1c8f9f3}}long \sphinxbfcode{oldywrap}}%
\pysigstopmultiline
\end{fulllineitems}

\index{Step::coal (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Step:_CPPv2N4Step4coalE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{api/class_Step:necsimstruct_step_1a20362fa305c240b197cab6934b4b5087}}bool \sphinxbfcode{coal}}%
\pysigstopmultiline
\end{fulllineitems}

\index{Step::bContinueSim (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Step:_CPPv2N4Step12bContinueSimE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{api/class_Step:necsimstruct_step_1a38035eb27c4eb998e5303905356a2cab}}bool \sphinxbfcode{bContinueSim}}%
\pysigstopmultiline
\end{fulllineitems}

\index{Step::time\_reference (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Step:_CPPv2N4Step14time_referenceE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{api/class_Step:necsimstruct_step_1a2ad070594a57205ace161c8e910e06b4}}unsigned int \sphinxbfcode{time\_reference}}%
\pysigstopmultiline
\end{fulllineitems}

\index{Step::distance (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Step:_CPPv2N4Step8distanceE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{api/class_Step:necsimstruct_step_1adcded9ae31a77edc5b91457e38008a7a}}double \sphinxbfcode{distance}}%
\pysigstopmultiline
\end{fulllineitems}

\index{Step::angle (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Step:_CPPv2N4Step5angleE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{api/class_Step:necsimstruct_step_1a92772e673d8c49b468df8710e49cffcb}}double \sphinxbfcode{angle}}%
\pysigstopmultiline
\end{fulllineitems}


\end{fulllineitems}



\subsection{Class Tree}
\label{\detokenize{api/class_Tree:class-tree}}\label{\detokenize{api/class_Tree::doc}}\label{\detokenize{api/class_Tree:id1}}\begin{itemize}
\item {} 
Defined in {\hyperref[\detokenize{api/file_necsim_Tree.h:file-necsim-tree-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File Tree.h}}}}

\end{itemize}


\subsubsection{Inheritance Relationships}
\label{\detokenize{api/class_Tree:inheritance-relationships}}

\paragraph{Derived Types}
\label{\detokenize{api/class_Tree:derived-types}}\begin{itemize}
\item {} 
\sphinxcode{public ProtractedTree} ({\hyperref[\detokenize{api/class_ProtractedTree:class-protractedtree}]{\sphinxcrossref{\DUrole{std,std-ref}{Class ProtractedTree}}}})

\item {} 
\sphinxcode{public SpatialTree} ({\hyperref[\detokenize{api/class_SpatialTree:class-spatialtree}]{\sphinxcrossref{\DUrole{std,std-ref}{Class SpatialTree}}}})

\end{itemize}


\subsubsection{Class Documentation}
\label{\detokenize{api/class_Tree:class-documentation}}\index{Tree (C++ class)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Tree:_CPPv24Tree}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_Tree:necsimclass_tree}}\pysigline{\sphinxstrong{class }\sphinxcode{}\sphinxbfcode{Tree}}%
\pysigstopmultiline
Main simulation class for performing a non-spatial neutral simulation and generating the phylogenetic tree of the individuals. 

Subclassed by {\hyperref[\detokenize{api/class_ProtractedTree:necsimclass_protracted_tree}]{\sphinxcrossref{\DUrole{std,std-ref}{ProtractedTree}}}}, {\hyperref[\detokenize{api/class_SpatialTree:necsimclass_spatial_tree}]{\sphinxcrossref{\DUrole{std,std-ref}{SpatialTree}}}}
\paragraph{Public Functions}
\index{Tree::Tree (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Tree:_CPPv2N4Tree4TreeEv}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_Tree:necsimclass_tree_1ad376a7c639d857312f5de2ef47482f68}}\pysiglinewithargsret{\sphinxbfcode{Tree}}{}{}%
\pysigstopmultiline
\end{fulllineitems}

\index{Tree::\textasciitilde{}Tree (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Tree:_CPPv2N4TreeD0Ev}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_Tree:necsimclass_tree_1a2348b20e31754ce28b00f6b6e9536644}}\pysiglinewithargsret{\sphinxstrong{virtual} \sphinxbfcode{\textasciitilde{}Tree}}{}{}%
\pysigstopmultiline
\end{fulllineitems}

\index{Tree::importSimulationVariables (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Tree:_CPPv2N4Tree25importSimulationVariablesERK6string}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_Tree:necsimclass_tree_1a455d87022772b309a5974ea5f0295139}}\pysiglinewithargsret{void \sphinxbfcode{importSimulationVariables}}{\sphinxstrong{const} string \&\sphinxstyleemphasis{configfile}}{}%
\pysigstopmultiline
Import the simulation variables from the command line structure. 

This function parses the simulation variables, imports them (from either the command line or a config file), checks that the input files exist and checks for any paused simulations. The flags are then set correctly, meaning that {\hyperref[\detokenize{api/class_Tree:necsimclass_tree_1aec10ea2b720edc13a38310afdfe2b6e4}]{\sphinxcrossref{\DUrole{std,std-ref}{setup()}}}} and runSim() can be run immediately afterwards.

\begin{description}
\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{comargs}: a vector of strings, containing the command-line arguments 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{Tree::internalSetup (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Tree:_CPPv2N4Tree13internalSetupERK13SimParameters}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_Tree:necsimclass_tree_1a62db83e47e5850c6a83793829b22b68b}}\pysiglinewithargsret{void \sphinxbfcode{internalSetup}}{\sphinxstrong{const} {\hyperref[\detokenize{api/struct_SimParameters:_CPPv213SimParameters}]{\sphinxcrossref{SimParameters}}} \&\sphinxstyleemphasis{sim\_parameters\_in}}{}%
\pysigstopmultiline
Sets up the simulation parameters from the one provided. 

Intended for usage with metacommunity application. No output directory is expected. \begin{description}
\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{sim\_parameters\_in}: the simulation parameters to set up the simulation with 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{Tree::checkOutputDirectory (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Tree:_CPPv2N4Tree20checkOutputDirectoryEv}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_Tree:necsimclass_tree_1a5c6065ede9862e9fb6561eb8beaf5d78}}\pysiglinewithargsret{bool \sphinxbfcode{checkOutputDirectory}}{}{}%
\pysigstopmultiline
Asserts that the output directory is not null and exists. If it doesn't exist, it attempts to create it. 

\begin{description}
\item[{\sphinxstylestrong{Return}}] \leavevmode
true if output creates successfully 

\item[{\sphinxstylestrong{Exceptions}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{Fatal\_Exception}: if the output directory creation fails 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{Tree::checkSims (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Tree:_CPPv2N4Tree9checkSimsEv}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_Tree:necsimclass_tree_1ad0bcc474a9ab1d4e3e2458c4de7304ad}}\pysiglinewithargsret{void \sphinxbfcode{checkSims}}{}{}%
\pysigstopmultiline
Checks for existing paused simulations to resume from Sets bPaused if there are. 

This version uses the default values read from the config file. 

\end{fulllineitems}

\index{Tree::checkSims (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Tree:_CPPv2N4Tree9checkSimsE6stringll}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_Tree:necsimclass_tree_1aafaede1da6c79583bf2e28b7a1881a5c}}\pysiglinewithargsret{void \sphinxbfcode{checkSims}}{string \sphinxstyleemphasis{output\_dir}, long \sphinxstyleemphasis{seed}, long \sphinxstyleemphasis{task}}{}%
\pysigstopmultiline
Checks for existing paused simulations to resume from. 

Sets bPaused if there are.

This version uses the values supplied to the function directly

\begin{description}
\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{output\_dir}: the output directory to check for 

\item {} 
\sphinxcode{seed}: the seed for paused sims 

\item {} 
\sphinxcode{task}: the task for paused sims 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{Tree::setParameters (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Tree:_CPPv2N4Tree13setParametersEv}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_Tree:necsimclass_tree_1ac374d237b7e2e7e11f6a0ff395003635}}\pysiglinewithargsret{void \sphinxbfcode{setParameters}}{}{}%
\pysigstopmultiline
Move the parameters from the sim\_parameters object to their relevant parameters. 

\end{fulllineitems}

\index{Tree::setProtractedVariables (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Tree:_CPPv2N4Tree22setProtractedVariablesEdd}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_Tree:necsimclass_tree_1a891764ffc1e29d3edbe0fd08e67a184b}}\pysiglinewithargsret{void \sphinxbfcode{setProtractedVariables}}{double \sphinxstyleemphasis{speciation\_gen\_min}, double \sphinxstyleemphasis{speciation\_gen\_max}}{}%
\pysigstopmultiline
Sets the protracted variables. 

\begin{description}
\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{speciation\_gen\_min}: the minimum number of generations to have passed before speciation is allowed 

\item {} 
\sphinxcode{speciation\_gen\_max}: the maximum number of generations a lineage can exist for before it is speciated. 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{Tree::hasPaused (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Tree:_CPPv2N4Tree9hasPausedEv}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_Tree:necsimclass_tree_1ae07761c0a91a44ebe459904b1b8ffb43}}\pysiglinewithargsret{bool \sphinxbfcode{hasPaused}}{}{}%
\pysigstopmultiline
Gets the has\_paused variable for resuming sims. 

\begin{description}
\item[{\sphinxstylestrong{Return}}] \leavevmode
if the simulation has paused 

\end{description}


\end{fulllineitems}

\index{Tree::getTemporalSampling (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Tree:_CPPv2N4Tree19getTemporalSamplingEv}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_Tree:necsimclass_tree_1ac03c034a5730ee4f4d8727aace776412}}\pysiglinewithargsret{vector\textless{}double\textgreater{} \sphinxbfcode{getTemporalSampling}}{}{}%
\pysigstopmultiline
Gets the map autocorrel times. 

\end{fulllineitems}

\index{Tree::getSeed (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Tree:_CPPv2N4Tree7getSeedEv}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_Tree:necsimclass_tree_1a857521315ca6bd9b3300d099488d74f1}}\pysiglinewithargsret{long long \sphinxbfcode{getSeed}}{}{}%
\pysigstopmultiline
Getter for the simulation seed. 

\begin{description}
\item[{\sphinxstylestrong{Return}}] \leavevmode
Returns the seeds 

\end{description}


\end{fulllineitems}

\index{Tree::setSeed (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Tree:_CPPv2N4Tree7setSeedEx}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_Tree:necsimclass_tree_1ab240ab1988cbde281a6811b3fdc1dd5d}}\pysiglinewithargsret{void \sphinxbfcode{setSeed}}{long long \sphinxstyleemphasis{seed\_in}}{}%
\pysigstopmultiline
Sets the simulation seed for the random number generator. 

This function should only be called once.

The seed is set within the NR object. This will be fixed for the simulation and is only performed once.

\begin{description}
\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{seed\_in}: the desired seed to set for the simulation 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{Tree::getInitialCount (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Tree:_CPPv2N4Tree15getInitialCountEv}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_Tree:necsimclass_tree_1a1e0685310a5a9bca4d6069e8d4ce1f1b}}\pysiglinewithargsret{unsigned long \sphinxbfcode{getInitialCount}}{}{}%
\pysigstopmultiline
Gets the initial number of individuals. 

\begin{description}
\item[{\sphinxstylestrong{Return}}] \leavevmode
the number of initial individuals to simulate 

\end{description}


\end{fulllineitems}

\index{Tree::setObjectSizes (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Tree:_CPPv2N4Tree14setObjectSizesEv}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_Tree:necsimclass_tree_1a869ab0aba75336f737cbb137c74b8abc}}\pysiglinewithargsret{unsigned long \sphinxbfcode{setObjectSizes}}{}{}%
\pysigstopmultiline
Sets the sizes of grid, active and data, based on the number of individuals counted from the samplemask. 

\begin{description}
\item[{\sphinxstylestrong{Return}}] \leavevmode
a count of the number of individuals that exist in the simulation 

\end{description}


\end{fulllineitems}

\index{Tree::setup (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Tree:_CPPv2N4Tree5setupEv}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_Tree:necsimclass_tree_1aec10ea2b720edc13a38310afdfe2b6e4}}\pysiglinewithargsret{void \sphinxbfcode{setup}}{}{}%
\pysigstopmultiline
The setup function for generating the simulation objects. 

The simulation parameters are set from comargs using {\hyperref[\detokenize{api/class_Tree:necsimclass_tree_1ac374d237b7e2e7e11f6a0ff395003635}]{\sphinxcrossref{\DUrole{std,std-ref}{setParameters()}}}}. Generates and fills the active and grid objects as well as importing all the maps from the supplied files. 

\end{fulllineitems}

\index{Tree::setInitialValues (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Tree:_CPPv2N4Tree16setInitialValuesEv}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_Tree:necsimclass_tree_1aec2640897132a1b667e852bbafc14c78}}\pysiglinewithargsret{void \sphinxbfcode{setInitialValues}}{}{}%
\pysigstopmultiline
Sets the starting values for required parameters. 

\end{fulllineitems}

\index{Tree::setSimStartVariables (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Tree:_CPPv2N4Tree20setSimStartVariablesEv}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_Tree:necsimclass_tree_1a1ba0f5d27c6ef6e9e17f988aff2dfe65}}\pysiglinewithargsret{void \sphinxbfcode{setSimStartVariables}}{}{}%
\pysigstopmultiline
Sets the variables at the start of a simulation for temporary data. 

This is not the main set-up routine, which creates the permanent data structures including maps, the coalescence tree and active lineage listings. 

\end{fulllineitems}

\index{Tree::printSetup (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Tree:_CPPv2N4Tree10printSetupEv}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_Tree:necsimclass_tree_1ab71da7797a6586ddd948661c34ce4788}}\pysiglinewithargsret{void \sphinxbfcode{printSetup}}{}{}%
\pysigstopmultiline
Prints the statement for the setup initiation. 

This is stored in a separate function so that it can be called in isolation by child classes. 

\end{fulllineitems}

\index{Tree::setTimes (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Tree:_CPPv2N4Tree8setTimesEv}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_Tree:necsimclass_tree_1ae3fb33c46cf7e3af44604a9875b375a3}}\pysiglinewithargsret{void \sphinxbfcode{setTimes}}{}{}%
\pysigstopmultiline
Sets the temporal sampling points from the time config file. 

\end{fulllineitems}

\index{Tree::determineSpeciationRates (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Tree:_CPPv2N4Tree24determineSpeciationRatesEv}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_Tree:necsimclass_tree_1a25f082da13789dfa3fefcbcfd08b4dfe}}\pysiglinewithargsret{void \sphinxbfcode{determineSpeciationRates}}{}{}%
\pysigstopmultiline
Determines the speciation rates to apply and then applies them to the coalescence tree post-simulation. 

Detects speciation rates from the config files supplied. 

\end{fulllineitems}

\index{Tree::generateObjects (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Tree:_CPPv2N4Tree15generateObjectsEv}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_Tree:necsimclass_tree_1a50b3d13d4032e0d7a69890b9bd7f84fa}}\pysiglinewithargsret{void \sphinxbfcode{generateObjects}}{}{}%
\pysigstopmultiline
Assigns the objects sizes in memory and fills with the starting lineages. 

\end{fulllineitems}

\index{Tree::fillObjects (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Tree:_CPPv2N4Tree11fillObjectsERKm}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_Tree:necsimclass_tree_1a4af845777294c9116c60115e651620b4}}\pysiglinewithargsret{unsigned long \sphinxbfcode{fillObjects}}{\sphinxstrong{const} unsigned long \&\sphinxstyleemphasis{initial\_count}}{}%
\pysigstopmultiline
Fills the active and data objects with the starting lineages. 

\begin{description}
\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{initial\_count}: the number of individuals expected to exist 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{Tree::runSimulation (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Tree:_CPPv2N4Tree13runSimulationEv}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_Tree:necsimclass_tree_1afe75245862a1c40030c1c8607518cf8d}}\pysiglinewithargsret{bool \sphinxbfcode{runSimulation}}{}{}%
\pysigstopmultiline
Run the entire simulation given the start conditions already defined by {\hyperref[\detokenize{api/class_Tree:necsimclass_tree_1aec10ea2b720edc13a38310afdfe2b6e4}]{\sphinxcrossref{\DUrole{std,std-ref}{setup()}}}} 

Setup is assumed to have been run already. This function is the main function containing the main loop of the simulation. At the end of the simulation, returns true if the simulation is complete, false otherwise. 

\end{fulllineitems}

\index{Tree::writeSimStartToConsole (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Tree:_CPPv2N4Tree22writeSimStartToConsoleEv}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_Tree:necsimclass_tree_1a95360a2f62ef0eb436d586552b299e1f}}\pysiglinewithargsret{void \sphinxbfcode{writeSimStartToConsole}}{}{}%
\pysigstopmultiline
Writes to the console that the simulation is beginning. 

\end{fulllineitems}

\index{Tree::writeStepToConsole (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Tree:_CPPv2N4Tree18writeStepToConsoleEv}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_Tree:necsimclass_tree_1a37de93174eece50a2fc082b683d97047}}\pysiglinewithargsret{void \sphinxbfcode{writeStepToConsole}}{}{}%
\pysigstopmultiline
Write the step counter to console. This function should only be called in debugging mode. 

\end{fulllineitems}

\index{Tree::incrementGeneration (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Tree:_CPPv2N4Tree19incrementGenerationEv}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_Tree:necsimclass_tree_1a3f0c8928b4b72fb6f03cabd4d0e04457}}\pysiglinewithargsret{void \sphinxbfcode{incrementGeneration}}{}{}%
\pysigstopmultiline
Increments the generation counter and step references. 

\end{fulllineitems}

\index{Tree::chooseRandomLineage (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Tree:_CPPv2N4Tree19chooseRandomLineageEv}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_Tree:necsimclass_tree_1a23803bddf46ad28a1bdd46bf05693b1f}}\pysiglinewithargsret{void \sphinxbfcode{chooseRandomLineage}}{}{}%
\pysigstopmultiline
Chooses a random lineage from active. 

The index of the random lineage is stored in this\_step, as chosen. Also records the required variables for the step process, like x, y position. 

\end{fulllineitems}

\index{Tree::updateStepCoalescenceVariables (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Tree:_CPPv2N4Tree30updateStepCoalescenceVariablesEv}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_Tree:necsimclass_tree_1ad65e94936001675b8bc908cf77e0cb53}}\pysiglinewithargsret{void \sphinxbfcode{updateStepCoalescenceVariables}}{}{}%
\pysigstopmultiline
Updates the coalescence variables in the step object. 

\end{fulllineitems}

\index{Tree::speciation (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Tree:_CPPv2N4Tree10speciationERKm}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_Tree:necsimclass_tree_1a05c9e44f1a4d7af83e65b6c4565b1b28}}\pysiglinewithargsret{void \sphinxbfcode{speciation}}{\sphinxstrong{const} unsigned long \&\sphinxstyleemphasis{chosen}}{}%
\pysigstopmultiline
Speciation to supplied lineage. 

Also calls the removeOldPos() and {\hyperref[\detokenize{api/class_Tree:necsimclass_tree_1ab1be13d2e99a4445a7cc84f907e0c90e}]{\sphinxcrossref{\DUrole{std,std-ref}{switchPositions()}}}} functions for removing the lineage out of active reference. \begin{description}
\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{chosen}: 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{Tree::speciateLineage (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Tree:_CPPv2N4Tree15speciateLineageERKm}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_Tree:necsimclass_tree_1a32e12cc62ce2d9ae893214b1f4cfad1f}}\pysiglinewithargsret{void \sphinxbfcode{speciateLineage}}{\sphinxstrong{const} unsigned long \&\sphinxstyleemphasis{data\_position}}{}%
\pysigstopmultiline
Performs the actual speciation. 

\begin{description}
\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{data\_position}: the position in the array of TreeNodes for this lineage 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{Tree::removeOldPosition (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Tree:_CPPv2N4Tree17removeOldPositionERKm}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_Tree:necsimclass_tree_1ad74c05729c9e5235ab0fa6e34260093a}}\pysiglinewithargsret{void \sphinxbfcode{removeOldPosition}}{\sphinxstrong{const} unsigned long \&\sphinxstyleemphasis{chosen}}{}%
\pysigstopmultiline
Removes the old position within active. 

\begin{description}
\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{chosen}: the desired active reference to remove from the grid. 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{Tree::switchPositions (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Tree:_CPPv2N4Tree15switchPositionsERKm}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_Tree:necsimclass_tree_1ab1be13d2e99a4445a7cc84f907e0c90e}}\pysiglinewithargsret{void \sphinxbfcode{switchPositions}}{\sphinxstrong{const} unsigned long \&\sphinxstyleemphasis{chosen}}{}%
\pysigstopmultiline
Switches the chosen position with the endactive position. 

\begin{description}
\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{chosen}: the chosen lineage to switch with endactive. 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{Tree::calcNextStep (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Tree:_CPPv2N4Tree12calcNextStepEv}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_Tree:necsimclass_tree_1a0dc015aa5a45d2a75d80456d680172ac}}\pysiglinewithargsret{void \sphinxbfcode{calcNextStep}}{}{}%
\pysigstopmultiline
Calculates the next step for the simulation. 

\end{fulllineitems}

\index{Tree::calcSpeciation (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Tree:_CPPv2N4Tree14calcSpeciationERKeRKeRKm}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_Tree:necsimclass_tree_1abc9389511e1aecf5e573315fc8f4d77c}}\pysiglinewithargsret{bool \sphinxbfcode{calcSpeciation}}{\sphinxstrong{const} long double \&\sphinxstyleemphasis{random\_number}, \sphinxstrong{const} long double \&\sphinxstyleemphasis{speciation\_rate}, \sphinxstrong{const} unsigned long \&\sphinxstyleemphasis{no\_generations}}{}%
\pysigstopmultiline
Calculates the speciation probability from the random number, speciation rate and number of generations a lineage has existed for. 

\begin{description}
\item[{\sphinxstylestrong{Return}}] \leavevmode
if true, speciation has occured 

\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{random\_number}: the generated random number from 0-1 

\item {} 
\sphinxcode{speciation\_rate}: the speciation rate to be applied 

\item {} 
\sphinxcode{no\_generations}: the number of generations a lineage has existed for 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{Tree::coalescenceEvent (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Tree:_CPPv2N4Tree16coalescenceEventERKmRm}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_Tree:necsimclass_tree_1a16eedb70009e7570d933f88e8ce44117}}\pysiglinewithargsret{void \sphinxbfcode{coalescenceEvent}}{\sphinxstrong{const} unsigned long \&\sphinxstyleemphasis{chosen}, unsigned long \&\sphinxstyleemphasis{coalchosen}}{}%
\pysigstopmultiline
Perform the coalescence between lineages. Once coalesced, lineages are removed from the active scope. 

\begin{description}
\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{chosen}: the chosen lineage for coalescence 

\item {} 
\sphinxcode{coalchosen}: the target lineage for coalscence 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{Tree::checkTimeUpdate (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Tree:_CPPv2N4Tree15checkTimeUpdateEv}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_Tree:necsimclass_tree_1afcbe72c55b38c94ae17de9c2e1dd3a7f}}\pysiglinewithargsret{void \sphinxbfcode{checkTimeUpdate}}{}{}%
\pysigstopmultiline
Checks if the number of lineages should be expanded at another sample point. 

\end{fulllineitems}

\index{Tree::addLineages (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Tree:_CPPv2N4Tree11addLineagesEd}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_Tree:necsimclass_tree_1a8bfa9a86f122b21900ec33ab4b1e323f}}\pysiglinewithargsret{void \sphinxbfcode{addLineages}}{double \sphinxstyleemphasis{generation\_in}}{}%
\pysigstopmultiline
Adds the required lineages at the generation time. 

\begin{description}
\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{generation\_in}: the generation to add lineages at 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{Tree::checkSimSize (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Tree:_CPPv2N4Tree12checkSimSizeEmm}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_Tree:necsimclass_tree_1ab8a62d0ca2b1746676073e3f33e2a949}}\pysiglinewithargsret{void \sphinxbfcode{checkSimSize}}{unsigned long \sphinxstyleemphasis{req\_data}, unsigned long \sphinxstyleemphasis{req\_active}}{}%
\pysigstopmultiline
Checks the size of the main active and data objects is large enough. 

\begin{description}
\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{req\_data}: the required data object size 

\item {} 
\sphinxcode{req\_active}: the required active object size 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{Tree::makeTip (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Tree:_CPPv2N4Tree7makeTipERKmRKd}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_Tree:necsimclass_tree_1a0973cc37d9b95144db76d36cb363caca}}\pysiglinewithargsret{void \sphinxbfcode{makeTip}}{\sphinxstrong{const} unsigned long \&\sphinxstyleemphasis{tmp\_active}, \sphinxstrong{const} double \&\sphinxstyleemphasis{generation\_in}}{}%
\pysigstopmultiline
Sets the active reference to a tip, if it isn't one already. Otherwise, creates a new tip for the new generation time. 

\begin{description}
\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{tmp\_active}: the reference in active 

\item {} 
\sphinxcode{generation\_in}: the generation to set for the new lineage 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{Tree::convertTip (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Tree:_CPPv2N4Tree10convertTipEmd}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_Tree:necsimclass_tree_1a6af2aaa691ffbb9899e3f070a715e371}}\pysiglinewithargsret{void \sphinxbfcode{convertTip}}{unsigned long \sphinxstyleemphasis{i}, double \sphinxstyleemphasis{generationin}}{}%
\pysigstopmultiline
Creates a new reference in data containing the tip with a new generation counter. 

\begin{description}
\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{i}: the reference in active of the lineage to make a tip 

\item {} 
\sphinxcode{generationin}: the generation to make the lineage a tip at 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{Tree::stopSimulation (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Tree:_CPPv2N4Tree14stopSimulationEv}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_Tree:necsimclass_tree_1afd6bd75c301d2f57c4997fcfc92f192e}}\pysiglinewithargsret{bool \sphinxbfcode{stopSimulation}}{}{}%
\pysigstopmultiline
Finalises the simulation, and performs the correct tasks depending if the sim has been paused or finished. 

\begin{description}
\item[{\sphinxstylestrong{Return}}] \leavevmode


\end{description}


\end{fulllineitems}

\index{Tree::applySpecRate (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Tree:_CPPv2N4Tree13applySpecRateEed}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_Tree:necsimclass_tree_1aa6349a32b3fcfb82a5f8311b11db3982}}\pysiglinewithargsret{void \sphinxbfcode{applySpecRate}}{long double \sphinxstyleemphasis{sr}, double \sphinxstyleemphasis{t}}{}%
\pysigstopmultiline
Applies the given speciation rate to the tree. 

\begin{description}
\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{sr}: the required speciation rate 

\item {} 
\sphinxcode{t}: the required time of speciation 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{Tree::applySpecRateInternal (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Tree:_CPPv2N4Tree21applySpecRateInternalEed}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_Tree:necsimclass_tree_1ac89abe0404d05d0363258b72cb80700b}}\pysiglinewithargsret{void \sphinxbfcode{applySpecRateInternal}}{long double \sphinxstyleemphasis{sr}, double \sphinxstyleemphasis{t}}{}%
\pysigstopmultiline
Applies the given speciation rate to the tree, but does not output to a file. Instead returns a pointer to the nodes object. 

\begin{description}
\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{sr}: the required speciation rate 

\item {} 
\sphinxcode{t}: the required time of speciation 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{Tree::getCumulativeAbundances (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Tree:_CPPv2N4Tree23getCumulativeAbundancesEv}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_Tree:necsimclass_tree_1a49a94b2218f7ae127a53af4a58d02b06}}\pysiglinewithargsret{{\hyperref[\detokenize{api/class_Row:_CPPv23Row}]{\sphinxcrossref{Row}}}\textless{}unsigned long\textgreater{} *\sphinxbfcode{getCumulativeAbundances}}{}{}%
\pysigstopmultiline
Gets the sorted cumulative species abundances from the contained TreeList. 

For use with metacommunity applications \begin{description}
\item[{\sphinxstylestrong{Return}}] \leavevmode
row of cumulative species abundances 

\end{description}


\end{fulllineitems}

\index{Tree::setupTreeGeneration (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Tree:_CPPv2N4Tree19setupTreeGenerationEed}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_Tree:necsimclass_tree_1a9997b98824a786d9843a3df40de1226a}}\pysiglinewithargsret{void \sphinxbfcode{setupTreeGeneration}}{long double \sphinxstyleemphasis{sr}, double \sphinxstyleemphasis{t}}{}%
\pysigstopmultiline
Sets up the generation of the tree object. 

\begin{description}
\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{sr}: the required speciation rate 

\item {} 
\sphinxcode{t}: the required time of speciation 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{Tree::applySpecRate (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Tree:_CPPv2N4Tree13applySpecRateEe}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_Tree:necsimclass_tree_1ab699328f13b22f48faa63a5638e907db}}\pysiglinewithargsret{void \sphinxbfcode{applySpecRate}}{long double \sphinxstyleemphasis{sr}}{}%
\pysigstopmultiline
Overloaded version of applySpecRates for the default generation (0.0). 

\begin{description}
\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{sr}: the speciation rate to apply to the tree 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{Tree::applyMultipleRates (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Tree:_CPPv2N4Tree18applyMultipleRatesEv}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_Tree:necsimclass_tree_1acfc7efdec999f6dbf2ac089514d22091}}\pysiglinewithargsret{void \sphinxbfcode{applyMultipleRates}}{}{}%
\pysigstopmultiline
Applies multiple speciation rates to the coalescence tree, ignoring repeated speciation rates. 

Speciation rates are read from the speciation\_rates object, which should have already been calculated. 

\end{fulllineitems}

\index{Tree::getProtracted (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Tree:_CPPv2N4Tree13getProtractedEv}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_Tree:necsimclass_tree_1aa23a57f7863d58384f61d464d998ab3c}}\pysiglinewithargsret{bool \sphinxbfcode{getProtracted}}{}{}%
\pysigstopmultiline
Gets the protractedness of the simulation. Overridden by protracted child classes. 

\begin{description}
\item[{\sphinxstylestrong{Return}}] \leavevmode


\end{description}


\end{fulllineitems}

\index{Tree::getProtractedVariables (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Tree:_CPPv2N4Tree22getProtractedVariablesEv}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_Tree:necsimclass_tree_1a34c0808026bf00546c8f9786376be730}}\pysiglinewithargsret{string \sphinxbfcode{getProtractedVariables}}{}{}%
\pysigstopmultiline
Gets the protracted variables and returns them as a single, newline separated string. This method is intended to be overridden in derived classes. 

\begin{description}
\item[{\sphinxstylestrong{Return}}] \leavevmode
string containing the protracted variables, separated by newlines. 

\end{description}


\end{fulllineitems}

\index{Tree::getProtractedGenerationMin (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Tree:_CPPv2N4Tree26getProtractedGenerationMinEv}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_Tree:necsimclass_tree_1a6ffc42e941f352cd74f01f6f7011f00b}}\pysiglinewithargsret{double \sphinxbfcode{getProtractedGenerationMin}}{}{}%
\pysigstopmultiline
Gets the minimum number of generations a lineage must exist. 

Without overriding this function, should always return 0.0. \begin{description}
\item[{\sphinxstylestrong{Return}}] \leavevmode
double the number of generations a lineage must exist 

\end{description}


\end{fulllineitems}

\index{Tree::getProtractedGenerationMax (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Tree:_CPPv2N4Tree26getProtractedGenerationMaxEv}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_Tree:necsimclass_tree_1a0c5e746982a87f24c083f4534bf92b45}}\pysiglinewithargsret{double \sphinxbfcode{getProtractedGenerationMax}}{}{}%
\pysigstopmultiline
Gets the maximum number of generations a lineage can exist. 

Without overriding this function, should always return 0.0 (no maximum).

\begin{description}
\item[{\sphinxstylestrong{Return}}] \leavevmode
double the number of generations a lineage must exist 

\end{description}


\end{fulllineitems}

\index{Tree::sqlOutput (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Tree:_CPPv2N4Tree9sqlOutputEv}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_Tree:necsimclass_tree_1a8cd3db7add1884ea53b0d98002d39cd3}}\pysiglinewithargsret{void \sphinxbfcode{sqlOutput}}{}{}%
\pysigstopmultiline
Copy the in-memory database to file. 

This function should not be called if the database is already opened on disc, and won't do anything if it is. 

\end{fulllineitems}

\index{Tree::outputData (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Tree:_CPPv2N4Tree10outputDataEv}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_Tree:necsimclass_tree_1afdf680e187c25ed39d1e66542ce44cc3}}\pysiglinewithargsret{void \sphinxbfcode{outputData}}{}{}%
\pysigstopmultiline
Outputs important simulation data to a csv file. Overloaded version which automatically calls {\hyperref[\detokenize{api/class_Tree:necsimclass_tree_1a2d2065bbebee8b55270d2691d40cd974}]{\sphinxcrossref{\DUrole{std,std-ref}{sortData()}}}} if no species richness is provided. 

\end{fulllineitems}

\index{Tree::outputData (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Tree:_CPPv2N4Tree10outputDataEm}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_Tree:necsimclass_tree_1a5acf7d0eea9ea2ef4928bb6691b87724}}\pysiglinewithargsret{void \sphinxbfcode{outputData}}{unsigned long \sphinxstyleemphasis{species\_richness}}{}%
\pysigstopmultiline
Outputs important simulation data to a csv file. This function will likely be remove in future versions as all simulation output is now contained in an SQLite database. 

\begin{description}
\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{species\_richness}: the species richness of the tree with the minimum speciation rate. Outputted into the csv file 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{Tree::sortData (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Tree:_CPPv2N4Tree8sortDataEv}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_Tree:necsimclass_tree_1a2d2065bbebee8b55270d2691d40cd974}}\pysiglinewithargsret{unsigned long \sphinxbfcode{sortData}}{}{}%
\pysigstopmultiline
Sort and process the species list so that the useful information can be extracted from it. 

\end{fulllineitems}

\index{Tree::writeTimes (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Tree:_CPPv2N4Tree10writeTimesEv}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_Tree:necsimclass_tree_1ab8785fc9e27868a56335048321c13290}}\pysiglinewithargsret{void \sphinxbfcode{writeTimes}}{}{}%
\pysigstopmultiline
Writes the times to the terminal for simulation information. 

\end{fulllineitems}

\index{Tree::sqlCreate (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Tree:_CPPv2N4Tree9sqlCreateEv}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_Tree:necsimclass_tree_1ae784a6ed362f6c5263ee797759f715b6}}\pysiglinewithargsret{void \sphinxbfcode{sqlCreate}}{}{}%
\pysigstopmultiline
Generates the SQL database file from the full simulation data. This allows for greater analysis of the data after completion of the simulation. 

\end{fulllineitems}

\index{Tree::sqlCreateSimulationParameters (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Tree:_CPPv2N4Tree29sqlCreateSimulationParametersEv}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_Tree:necsimclass_tree_1a199f47b62b9b10917ff8b89d20c543a7}}\pysiglinewithargsret{void \sphinxbfcode{sqlCreateSimulationParameters}}{}{}%
\pysigstopmultiline
Creates the SIMULATION\_PARAMETERS table in the SQL database. 

\end{fulllineitems}

\index{Tree::simulationParametersSqlInsertion (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Tree:_CPPv2N4Tree32simulationParametersSqlInsertionEv}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_Tree:necsimclass_tree_1aed6504b4f759fb31fdeb61cd03b2b3f9}}\pysiglinewithargsret{string \sphinxbfcode{simulationParametersSqlInsertion}}{}{}%
\pysigstopmultiline
Creates a string containing the SQL insertion statement for the simulation parameters. 

\begin{description}
\item[{\sphinxstylestrong{Return}}] \leavevmode
string containing the SQL insertion statement 

\end{description}


\end{fulllineitems}

\index{Tree::protractedVarsToString (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Tree:_CPPv2N4Tree22protractedVarsToStringEv}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_Tree:necsimclass_tree_1aa8bb5d93c7992404ede0a49bb69ccd1f}}\pysiglinewithargsret{string \sphinxbfcode{protractedVarsToString}}{}{}%
\pysigstopmultiline
Outputs the protracted variables to a string. 

This function is intended to be overridden by derived classes. It is intended the output is used for writing to SQL databases.

\begin{description}
\item[{\sphinxstylestrong{Return}}] \leavevmode
string containing a list of the protracted speciation variables. 

\end{description}


\end{fulllineitems}

\index{Tree::simPause (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Tree:_CPPv2N4Tree8simPauseEv}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_Tree:necsimclass_tree_1ae5308f74e982485ac444aa394b952152}}\pysiglinewithargsret{void \sphinxbfcode{simPause}}{}{}%
\pysigstopmultiline
Pause the simulation and dump data from memory. 

\end{fulllineitems}

\index{Tree::initiatePause (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Tree:_CPPv2N4Tree13initiatePauseEv}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_Tree:necsimclass_tree_1a9b2df7fd1b61d3d70ac630f7fbfd683d}}\pysiglinewithargsret{string \sphinxbfcode{initiatePause}}{}{}%
\pysigstopmultiline
Checks the output folder exists and initiates the pause. 

\end{fulllineitems}

\index{Tree::dumpMain (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Tree:_CPPv2N4Tree8dumpMainE6string}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_Tree:necsimclass_tree_1a4c2988184328a5236ca61f16744cfac2}}\pysiglinewithargsret{void \sphinxbfcode{dumpMain}}{string \sphinxstyleemphasis{pause\_folder}}{}%
\pysigstopmultiline
Saves the main simulation variables to file. 

\begin{description}
\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{pause\_folder}: the folder to save files into 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{Tree::dumpActive (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Tree:_CPPv2N4Tree10dumpActiveE6string}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_Tree:necsimclass_tree_1aca99503f49b91baae7401423fe547daf}}\pysiglinewithargsret{void \sphinxbfcode{dumpActive}}{string \sphinxstyleemphasis{pause\_folder}}{}%
\pysigstopmultiline
Saves the active object to file. 

\begin{description}
\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{pause\_folder}: the folder to save files into 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{Tree::dumpData (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Tree:_CPPv2N4Tree8dumpDataE6string}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_Tree:necsimclass_tree_1acd23fa139c7d097315c9479187b1a674}}\pysiglinewithargsret{void \sphinxbfcode{dumpData}}{string \sphinxstyleemphasis{pause\_folder}}{}%
\pysigstopmultiline
Saves the data object to file. 

\begin{description}
\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{pause\_folder}: the folder to save files into 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{Tree::completePause (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Tree:_CPPv2N4Tree13completePauseEv}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_Tree:necsimclass_tree_1a3fddb18a5d19b64dec378dca3d3fea31}}\pysiglinewithargsret{void \sphinxbfcode{completePause}}{}{}%
\pysigstopmultiline
Completes the pause routine and outputs the sql dump. 

\end{fulllineitems}

\index{Tree::setResumeParameters (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Tree:_CPPv2N4Tree19setResumeParametersE6string6stringmmm}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_Tree:necsimclass_tree_1ac545d844141db977920fc9fd76ce9dbb}}\pysiglinewithargsret{void \sphinxbfcode{setResumeParameters}}{string \sphinxstyleemphasis{pausedir}, string \sphinxstyleemphasis{outdir}, unsigned long \sphinxstyleemphasis{seed}, unsigned long \sphinxstyleemphasis{task}, unsigned long \sphinxstyleemphasis{new\_max\_time}}{}%
\pysigstopmultiline
Sets the resume variables so that the simulation can be resumed. 

The pause directory can be the same as the output directory if it is desirable to save to the same location.

\begin{description}
\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{pausedir}: the directory containing the pause folder for resuming the simulation 

\item {} 
\sphinxcode{outdir}: the directory to write simulation output to 

\item {} 
\sphinxcode{seed}: the simulation seed 

\item {} 
\sphinxcode{task}: the simulation task 

\item {} 
\sphinxcode{new\_max\_time}: the maximum simulation time to run for in seconds (0 keeps old simulation max time) 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{Tree::setResumeParameters (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Tree:_CPPv2N4Tree19setResumeParametersEv}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_Tree:necsimclass_tree_1aeade4bccb8394937a53bc4fbcf2b4300}}\pysiglinewithargsret{void \sphinxbfcode{setResumeParameters}}{}{}%
\pysigstopmultiline
Sets the resume variables to the defaults. 

\end{fulllineitems}

\index{Tree::loadMainSave (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Tree:_CPPv2N4Tree12loadMainSaveEv}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_Tree:necsimclass_tree_1af57075728924141c7b6d311822a22dc0}}\pysiglinewithargsret{void \sphinxbfcode{loadMainSave}}{}{}%
\pysigstopmultiline
Loads the main simulation parameters from the save file into memory. 

\end{fulllineitems}

\index{Tree::loadDataSave (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Tree:_CPPv2N4Tree12loadDataSaveEv}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_Tree:necsimclass_tree_1af7db53d4870d845741d3159f57b73b30}}\pysiglinewithargsret{void \sphinxbfcode{loadDataSave}}{}{}%
\pysigstopmultiline
Loads the data object from the save file into memory. 

\end{fulllineitems}

\index{Tree::loadActiveSave (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Tree:_CPPv2N4Tree14loadActiveSaveEv}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_Tree:necsimclass_tree_1af145148202f11654d6d6a15a6c021924}}\pysiglinewithargsret{void \sphinxbfcode{loadActiveSave}}{}{}%
\pysigstopmultiline
Loads the active object from the save file into memory. 

\end{fulllineitems}

\index{Tree::initiateResume (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Tree:_CPPv2N4Tree14initiateResumeEv}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_Tree:necsimclass_tree_1a8cfe5d30d53d702f18cd67981e2c9acb}}\pysiglinewithargsret{void \sphinxbfcode{initiateResume}}{}{}%
\pysigstopmultiline
Checks for resuming and prints to the terminal. 

\end{fulllineitems}

\index{Tree::simResume (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Tree:_CPPv2N4Tree9simResumeEv}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_Tree:necsimclass_tree_1a3d614f3848dc7acab168642efe345569}}\pysiglinewithargsret{void \sphinxbfcode{simResume}}{}{}%
\pysigstopmultiline
Resumes the simulation from a previous state. 

Reads in the parameters and objects from file and re-starts the simulation. 

\end{fulllineitems}

\paragraph{Protected Attributes}
\index{Tree::data (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Tree:_CPPv2N4Tree4dataE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{api/class_Tree:necsimclass_tree_1a5983af6c56e41be51be0766941093b4b}}{\hyperref[\detokenize{api/class_Row:_CPPv23Row}]{\sphinxcrossref{Row}}}\textless{}{\hyperref[\detokenize{api/class_TreeNode:_CPPv28TreeNode}]{\sphinxcrossref{TreeNode}}}\textgreater{} \sphinxbfcode{data}}%
\pysigstopmultiline
\end{fulllineitems}

\index{Tree::enddata (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Tree:_CPPv2N4Tree7enddataE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{api/class_Tree:necsimclass_tree_1a50344999e6b64d15eef935b1f6023471}}unsigned long \sphinxbfcode{enddata}}%
\pysigstopmultiline
\end{fulllineitems}

\index{Tree::sim\_parameters (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Tree:_CPPv2N4Tree14sim_parametersE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{api/class_Tree:necsimclass_tree_1a63c399793a209332ad0f5da7fc830d56}}{\hyperref[\detokenize{api/struct_SimParameters:_CPPv213SimParameters}]{\sphinxcrossref{SimParameters}}} \sphinxbfcode{sim\_parameters}}%
\pysigstopmultiline
\end{fulllineitems}

\index{Tree::NR (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Tree:_CPPv2N4Tree2NRE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{api/class_Tree:necsimclass_tree_1aa7df162306777b040a9a2aac543e6801}}{\hyperref[\detokenize{api/class_NRrand:_CPPv26NRrand}]{\sphinxcrossref{NRrand}}} \sphinxbfcode{NR}}%
\pysigstopmultiline
\end{fulllineitems}

\index{Tree::speciation\_rates (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Tree:_CPPv2N4Tree16speciation_ratesE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{api/class_Tree:necsimclass_tree_1a61b4349fe78d09ac06eff4b7d6833105}}vector\textless{}long double\textgreater{} \sphinxbfcode{speciation\_rates}}%
\pysigstopmultiline
\end{fulllineitems}

\index{Tree::seeded (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Tree:_CPPv2N4Tree6seededE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{api/class_Tree:necsimclass_tree_1a78935befd45946b8e69023bffca59c1d}}bool \sphinxbfcode{seeded}}%
\pysigstopmultiline
\end{fulllineitems}

\index{Tree::the\_seed (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Tree:_CPPv2N4Tree8the_seedE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{api/class_Tree:necsimclass_tree_1acf483ed0a44629c9aa4690a08017ee35}}long long \sphinxbfcode{the\_seed}}%
\pysigstopmultiline
\end{fulllineitems}

\index{Tree::the\_task (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Tree:_CPPv2N4Tree8the_taskE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{api/class_Tree:necsimclass_tree_1a9f74137d5c9c5529ec9a06f88dfa6960}}long long \sphinxbfcode{the\_task}}%
\pysigstopmultiline
\end{fulllineitems}

\index{Tree::times\_file (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Tree:_CPPv2N4Tree10times_fileE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{api/class_Tree:necsimclass_tree_1a5e031ea8d94f48288547116a9e7d7add}}string \sphinxbfcode{times\_file}}%
\pysigstopmultiline
\end{fulllineitems}

\index{Tree::reference\_times (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Tree:_CPPv2N4Tree15reference_timesE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{api/class_Tree:necsimclass_tree_1a56bb1ea64368f5b705360a435350f9d5}}vector\textless{}double\textgreater{} \sphinxbfcode{reference\_times}}%
\pysigstopmultiline
\end{fulllineitems}

\index{Tree::has\_times\_file (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Tree:_CPPv2N4Tree14has_times_fileE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{api/class_Tree:necsimclass_tree_1adf239a9aa029c9c6eda4b10c5ce20780}}bool \sphinxbfcode{has\_times\_file}}%
\pysigstopmultiline
\end{fulllineitems}

\index{Tree::start (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Tree:_CPPv2N4Tree5startE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{api/class_Tree:necsimclass_tree_1ac077d686ee96b123aa779e8a8a5de3ce}}time\_t \sphinxbfcode{start}}%
\pysigstopmultiline
\end{fulllineitems}

\index{Tree::sim\_start (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Tree:_CPPv2N4Tree9sim_startE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{api/class_Tree:necsimclass_tree_1a01cc9b30f2b10b9f51b218df25b13b09}}time\_t \sphinxbfcode{sim\_start}}%
\pysigstopmultiline
\end{fulllineitems}

\index{Tree::sim\_end (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Tree:_CPPv2N4Tree7sim_endE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{api/class_Tree:necsimclass_tree_1a26100477c7e58a9e0a90cdee1379ed69}}time\_t \sphinxbfcode{sim\_end}}%
\pysigstopmultiline
\end{fulllineitems}

\index{Tree::now (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Tree:_CPPv2N4Tree3nowE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{api/class_Tree:necsimclass_tree_1a5510d0fb5deb23fd39a2619d104f85fa}}time\_t \sphinxbfcode{now}}%
\pysigstopmultiline
\end{fulllineitems}

\index{Tree::sim\_finish (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Tree:_CPPv2N4Tree10sim_finishE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{api/class_Tree:necsimclass_tree_1ac399ba59be9dc33a04223d10a82ee5ee}}time\_t \sphinxbfcode{sim\_finish}}%
\pysigstopmultiline
\end{fulllineitems}

\index{Tree::out\_finish (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Tree:_CPPv2N4Tree10out_finishE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{api/class_Tree:necsimclass_tree_1a5ee1fa5adf72bb599badc041fbee7d09}}time\_t \sphinxbfcode{out\_finish}}%
\pysigstopmultiline
\end{fulllineitems}

\index{Tree::time\_taken (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Tree:_CPPv2N4Tree10time_takenE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{api/class_Tree:necsimclass_tree_1abd18bb487c0192588b6bed6f00bcfd07}}time\_t \sphinxbfcode{time\_taken}}%
\pysigstopmultiline
\end{fulllineitems}

\index{Tree::active (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Tree:_CPPv2N4Tree6activeE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{api/class_Tree:necsimclass_tree_1a047b331de4979aa4713c69f09237ac35}}{\hyperref[\detokenize{api/class_Row:_CPPv23Row}]{\sphinxcrossref{Row}}}\textless{}{\hyperref[\detokenize{api/class_DataPoint:_CPPv29DataPoint}]{\sphinxcrossref{DataPoint}}}\textgreater{} \sphinxbfcode{active}}%
\pysigstopmultiline
\end{fulllineitems}

\index{Tree::endactive (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Tree:_CPPv2N4Tree9endactiveE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{api/class_Tree:necsimclass_tree_1ab478831f09c135bc9a4bc991c9fd5076}}unsigned long \sphinxbfcode{endactive}}%
\pysigstopmultiline
\end{fulllineitems}

\index{Tree::startendactive (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Tree:_CPPv2N4Tree14startendactiveE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{api/class_Tree:necsimclass_tree_1a3f1a90ab7ef917a996790e5ddfcebf85}}unsigned long \sphinxbfcode{startendactive}}%
\pysigstopmultiline
\end{fulllineitems}

\index{Tree::maxsimsize (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Tree:_CPPv2N4Tree10maxsimsizeE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{api/class_Tree:necsimclass_tree_1a0244ee15452c38393246147d93836b4d}}unsigned long \sphinxbfcode{maxsimsize}}%
\pysigstopmultiline
\end{fulllineitems}

\index{Tree::community (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Tree:_CPPv2N4Tree9communityE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{api/class_Tree:necsimclass_tree_1adbb8b625d03dbcdca00f3d8d4b4a50df}}{\hyperref[\detokenize{api/class_Community:_CPPv29Community}]{\sphinxcrossref{Community}}} \sphinxbfcode{community}}%
\pysigstopmultiline
\end{fulllineitems}

\index{Tree::steps (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Tree:_CPPv2N4Tree5stepsE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{api/class_Tree:necsimclass_tree_1ae7d33b8c16eeb8cb0c7f96dbfbc61b4e}}long \sphinxbfcode{steps}}%
\pysigstopmultiline
\end{fulllineitems}

\index{Tree::maxtime (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Tree:_CPPv2N4Tree7maxtimeE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{api/class_Tree:necsimclass_tree_1a1868cf626a0b12f21a038989d4eca210}}unsigned long \sphinxbfcode{maxtime}}%
\pysigstopmultiline
\end{fulllineitems}

\index{Tree::generation (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Tree:_CPPv2N4Tree10generationE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{api/class_Tree:necsimclass_tree_1a84cc46d51045ff3b161ee8788950e0c2}}double \sphinxbfcode{generation}}%
\pysigstopmultiline
\end{fulllineitems}

\index{Tree::deme (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Tree:_CPPv2N4Tree4demeE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{api/class_Tree:necsimclass_tree_1a9fe104115b4593c772c03b57b82ff0de}}long \sphinxbfcode{deme}}%
\pysigstopmultiline
\end{fulllineitems}

\index{Tree::deme\_sample (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Tree:_CPPv2N4Tree11deme_sampleE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{api/class_Tree:necsimclass_tree_1ac7a1d0583d3dcb55c50fec0e1fd57985}}double \sphinxbfcode{deme\_sample}}%
\pysigstopmultiline
\end{fulllineitems}

\index{Tree::spec (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Tree:_CPPv2N4Tree4specE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{api/class_Tree:necsimclass_tree_1a586678f7084086add3a4136476abd375}}long double \sphinxbfcode{spec}}%
\pysigstopmultiline
\end{fulllineitems}

\index{Tree::out\_directory (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Tree:_CPPv2N4Tree13out_directoryE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{api/class_Tree:necsimclass_tree_1a85615771af7b568adca1b801995cfdc7}}string \sphinxbfcode{out\_directory}}%
\pysigstopmultiline
\end{fulllineitems}

\index{Tree::database (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Tree:_CPPv2N4Tree8databaseE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{api/class_Tree:necsimclass_tree_1aae24ce11e30fbd74fe078b23b46c14cd}}sqlite3 *\sphinxbfcode{database}}%
\pysigstopmultiline
\end{fulllineitems}

\index{Tree::sim\_complete (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Tree:_CPPv2N4Tree12sim_completeE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{api/class_Tree:necsimclass_tree_1a07f9982fd6f6243c78ef42371603bbe4}}bool \sphinxbfcode{sim\_complete}}%
\pysigstopmultiline
\end{fulllineitems}

\index{Tree::has\_imported\_vars (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Tree:_CPPv2N4Tree17has_imported_varsE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{api/class_Tree:necsimclass_tree_1a97bde28466a098bb9e58c1bd5610fd68}}bool \sphinxbfcode{has\_imported\_vars}}%
\pysigstopmultiline
\end{fulllineitems}

\index{Tree::outdatabase (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Tree:_CPPv2N4Tree11outdatabaseE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{api/class_Tree:necsimclass_tree_1afd585c8a4bdb86461780418f7b886abd}}sqlite3 *\sphinxbfcode{outdatabase}}%
\pysigstopmultiline
\end{fulllineitems}

\index{Tree::this\_step (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Tree:_CPPv2N4Tree9this_stepE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{api/class_Tree:necsimclass_tree_1af7de4d4f04360edcbe2a20db882b1f87}}{\hyperref[\detokenize{api/class_Step:_CPPv24Step}]{\sphinxcrossref{Step}}} \sphinxbfcode{this\_step}}%
\pysigstopmultiline
\end{fulllineitems}

\index{Tree::sqloutname (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Tree:_CPPv2N4Tree10sqloutnameE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{api/class_Tree:necsimclass_tree_1ade2744c2510a6e8ae791ca7189f483bb}}string \sphinxbfcode{sqloutname}}%
\pysigstopmultiline
\end{fulllineitems}

\index{Tree::bFullmode (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Tree:_CPPv2N4Tree9bFullmodeE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{api/class_Tree:necsimclass_tree_1a9379466b9fc0f25bd28543743000e700}}bool \sphinxbfcode{bFullmode}}%
\pysigstopmultiline
\end{fulllineitems}

\index{Tree::bResume (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Tree:_CPPv2N4Tree7bResumeE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{api/class_Tree:necsimclass_tree_1ac9cbd7d17fb511c1fcc70c765f6440b0}}bool \sphinxbfcode{bResume}}%
\pysigstopmultiline
\end{fulllineitems}

\index{Tree::bConfig (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Tree:_CPPv2N4Tree7bConfigE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{api/class_Tree:necsimclass_tree_1a6c8c76aec6a9faef9c38f4f275b0793d}}bool \sphinxbfcode{bConfig}}%
\pysigstopmultiline
\end{fulllineitems}

\index{Tree::has\_paused (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Tree:_CPPv2N4Tree10has_pausedE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{api/class_Tree:necsimclass_tree_1aaa64e29ab7bc3c6f48d454063f0c39e1}}bool \sphinxbfcode{has\_paused}}%
\pysigstopmultiline
\end{fulllineitems}

\index{Tree::has\_imported\_pause (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Tree:_CPPv2N4Tree18has_imported_pauseE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{api/class_Tree:necsimclass_tree_1ad8d1d7e4fa673b28542ba31c5b637856}}bool \sphinxbfcode{has\_imported\_pause}}%
\pysigstopmultiline
\end{fulllineitems}

\index{Tree::bIsProtracted (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Tree:_CPPv2N4Tree13bIsProtractedE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{api/class_Tree:necsimclass_tree_1a1f7515f16d99a9748ab2c4c667f1ffc4}}bool \sphinxbfcode{bIsProtracted}}%
\pysigstopmultiline
\end{fulllineitems}

\index{Tree::pause\_sim\_directory (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_Tree:_CPPv2N4Tree19pause_sim_directoryE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{api/class_Tree:necsimclass_tree_1a504a4d7ae23146fd6236baa59da51a6e}}string \sphinxbfcode{pause\_sim\_directory}}%
\pysigstopmultiline
\end{fulllineitems}


\end{fulllineitems}



\subsection{Class TreeNode}
\label{\detokenize{api/class_TreeNode:id1}}\label{\detokenize{api/class_TreeNode::doc}}\label{\detokenize{api/class_TreeNode:class-treenode}}\begin{itemize}
\item {} 
Defined in {\hyperref[\detokenize{api/file_necsim_TreeNode.h:file-necsim-treenode-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File TreeNode.h}}}}

\end{itemize}


\subsubsection{Class Documentation}
\label{\detokenize{api/class_TreeNode:class-documentation}}\index{TreeNode (C++ class)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_TreeNode:_CPPv28TreeNode}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_TreeNode:necsimclass_tree_node}}\pysigline{\sphinxstrong{class }\sphinxcode{}\sphinxbfcode{TreeNode}}%
\pysigstopmultiline
The {\hyperref[\detokenize{api/class_TreeNode:necsimclass_tree_node}]{\sphinxcrossref{\DUrole{std,std-ref}{TreeNode}}}} class that acts as a data storage object for the phylogenetic tree. 

Also contains all the necessary routines for changes to a lineage's attributes, called by TreeList objects when generating new coalescence trees. 
\paragraph{Public Functions}
\index{TreeNode::TreeNode (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_TreeNode:_CPPv2N8TreeNode8TreeNodeEv}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_TreeNode:necsimclass_tree_node_1a984a98d5ccf7ef1f5a18094c6821f35d}}\pysiglinewithargsret{\sphinxbfcode{TreeNode}}{}{}%
\pysigstopmultiline
The default constructor. 

\end{fulllineitems}

\index{TreeNode::\textasciitilde{}TreeNode (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_TreeNode:_CPPv2N8TreeNodeD0Ev}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_TreeNode:necsimclass_tree_node_1a89eb1eb0e25fccaa83c780b85f95b570}}\pysiglinewithargsret{\sphinxbfcode{\textasciitilde{}TreeNode}}{}{}%
\pysigstopmultiline
The default destructor. 

\end{fulllineitems}

\index{TreeNode::setup (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_TreeNode:_CPPv2N8TreeNode5setupEbmmll}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_TreeNode:necsimclass_tree_node_1aac058ef4e26cc498e54ac5d0208e96e1}}\pysiglinewithargsret{void \sphinxbfcode{setup}}{bool \sphinxstyleemphasis{z}, unsigned long \sphinxstyleemphasis{xp}, unsigned long \sphinxstyleemphasis{yp}, long \sphinxstyleemphasis{xi}, long \sphinxstyleemphasis{yi}}{}%
\pysigstopmultiline
Sets up variables with initial conditions. 

\begin{description}
\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{z}: whether this lineage is a tip or not (represents the end of a tree). 

\item {} 
\sphinxcode{xp}: the x position on the grid. 

\item {} 
\sphinxcode{yp}: the y position on the grid. 

\item {} 
\sphinxcode{xi}: the number of wraps in the x dimension. 

\item {} 
\sphinxcode{yi}: the number of wraps in the y dimension. 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{TreeNode::setup (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_TreeNode:_CPPv2N8TreeNode5setupEb}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_TreeNode:necsimclass_tree_node_1ab8300978f2020de993f8ead2e08b8377}}\pysiglinewithargsret{void \sphinxbfcode{setup}}{bool \sphinxstyleemphasis{z}}{}%
\pysigstopmultiline
Sets up variables with initial conditions. 

\begin{description}
\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{z}: whether this lineage is a tip or not (represents the end of a tree) 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{TreeNode::setup (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_TreeNode:_CPPv2N8TreeNode5setupERKbRKlRKlRKlRKlRKe}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_TreeNode:necsimclass_tree_node_1a5d27405bfc2cf6be90895de24b40e076}}\pysiglinewithargsret{void \sphinxbfcode{setup}}{\sphinxstrong{const} bool \&\sphinxstyleemphasis{is\_tip}, \sphinxstrong{const} long \&\sphinxstyleemphasis{xp}, \sphinxstrong{const} long \&\sphinxstyleemphasis{yp}, \sphinxstrong{const} long \&\sphinxstyleemphasis{xi}, \sphinxstrong{const} long \&\sphinxstyleemphasis{yi}, \sphinxstrong{const} long double \&\sphinxstyleemphasis{generation}}{}%
\pysigstopmultiline
Overloaded {\hyperref[\detokenize{api/class_TreeNode:necsimclass_tree_node_1aac058ef4e26cc498e54ac5d0208e96e1}]{\sphinxcrossref{\DUrole{std,std-ref}{setup()}}}} function, additionally taking a generation time point. 

Used when creating lineages after the start of the simulation, when the generation is not 0. \begin{description}
\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{is\_tip}: whether this lineage is a tip or not (represents the end of a tree). 

\item {} 
\sphinxcode{xp}: the x position on the grid. 

\item {} 
\sphinxcode{yp}: the y position on the grid. 

\item {} 
\sphinxcode{xi}: the number of wraps in the x dimension. 

\item {} 
\sphinxcode{yi}: the number of wraps in the y dimension. 

\item {} 
\sphinxcode{generation}: the current generation at creation time. 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{TreeNode::setExistence (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_TreeNode:_CPPv2N8TreeNode12setExistenceEb}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_TreeNode:necsimclass_tree_node_1ad9f8d4d7d790cd0cd89a950cc0909519}}\pysiglinewithargsret{void \sphinxbfcode{setExistence}}{bool \sphinxstyleemphasis{b}}{}%
\pysigstopmultiline
Setter for the existence of the lineage. 

\begin{description}
\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{b}: existence boolean. 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{TreeNode::setParent (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_TreeNode:_CPPv2N8TreeNode9setParentEm}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_TreeNode:necsimclass_tree_node_1abd2840804b1d9b8caed25de5ae9b3ee6}}\pysiglinewithargsret{void \sphinxbfcode{setParent}}{unsigned long \sphinxstyleemphasis{x}}{}%
\pysigstopmultiline
Setter for the parent reference. 

\begin{description}
\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{x}: a reference for the parent location. 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{TreeNode::qReset (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_TreeNode:_CPPv2N8TreeNode6qResetEv}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_TreeNode:necsimclass_tree_node_1a78b82146ccdd88a405c701c1389c67e2}}\pysiglinewithargsret{void \sphinxbfcode{qReset}}{}{}%
\pysigstopmultiline
Resets the lineage. Remove any species ID, existence and speciation record. 

\end{fulllineitems}

\index{TreeNode::setPosition (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_TreeNode:_CPPv2N8TreeNode11setPositionEllll}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_TreeNode:necsimclass_tree_node_1a123ebe5ac7a4aa9c911aed404b22f166}}\pysiglinewithargsret{void \sphinxbfcode{setPosition}}{long \sphinxstyleemphasis{x}, long \sphinxstyleemphasis{y}, long \sphinxstyleemphasis{xw}, long \sphinxstyleemphasis{yw}}{}%
\pysigstopmultiline
Set a new position for the lineage. 

\begin{description}
\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{x}: the x position on the grid. 

\item {} 
\sphinxcode{y}: the y position on the grid. 

\item {} 
\sphinxcode{xw}: the number of wraps in the x dimension. 

\item {} 
\sphinxcode{yw}: the number of wraps in the y dimension. 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{TreeNode::setSpec (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_TreeNode:_CPPv2N8TreeNode7setSpecEe}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_TreeNode:necsimclass_tree_node_1ac5b41ed58cd5270504d4891af28a3a52}}\pysiglinewithargsret{void \sphinxbfcode{setSpec}}{long double \sphinxstyleemphasis{d}}{}%
\pysigstopmultiline
Setter for the randomly generated number (from NRrand.d0()) for the speciation probability for this lineage. 

\begin{description}
\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{d}: the speciation probability. 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{TreeNode::setGenerationRate (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_TreeNode:_CPPv2N8TreeNode17setGenerationRateEm}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_TreeNode:necsimclass_tree_node_1a114820b41e7d84a5761573784acc1d5e}}\pysiglinewithargsret{void \sphinxbfcode{setGenerationRate}}{unsigned long \sphinxstyleemphasis{g}}{}%
\pysigstopmultiline
Setter for the number of generations this lineage has existed for. 

\begin{description}
\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{g}: the number of generations that the lineage has existed. 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{TreeNode::setGeneration (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_TreeNode:_CPPv2N8TreeNode13setGenerationEe}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_TreeNode:necsimclass_tree_node_1ab51e108eac10b3f9e3fdd1e42882a94c}}\pysiglinewithargsret{void \sphinxbfcode{setGeneration}}{long double \sphinxstyleemphasis{d}}{}%
\pysigstopmultiline
Setter for the birth generation timer for the lineage. 

Note that moves that don't involve coalescence do not create a new Treenode object, and therefore the generation\_added does not get updated. However, coalescence events will cause a new Treenode object creation. The lineage birth generation is generally only important for calculating the age of tips. \begin{description}
\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{d}: 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{TreeNode::setSpeciation (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_TreeNode:_CPPv2N8TreeNode13setSpeciationEb}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_TreeNode:necsimclass_tree_node_1a7b0ead212f130b9754be7f1cb6eda13e}}\pysiglinewithargsret{void \sphinxbfcode{setSpeciation}}{bool \sphinxstyleemphasis{s}}{}%
\pysigstopmultiline
Setter for the speciation boolean. 

\begin{description}
\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{s}: the speciation boolean. 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{TreeNode::burnSpecies (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_TreeNode:_CPPv2N8TreeNode11burnSpeciesEm}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_TreeNode:necsimclass_tree_node_1a99516661c1321a1b4948be29ed247936}}\pysiglinewithargsret{void \sphinxbfcode{burnSpecies}}{unsigned long \sphinxstyleemphasis{idin}}{}%
\pysigstopmultiline
Setter for the species ID. Once set to something other than 0, this cannot be changed with a call to {\hyperref[\detokenize{api/class_TreeNode:necsimclass_tree_node_1a78b82146ccdd88a405c701c1389c67e2}]{\sphinxcrossref{\DUrole{std,std-ref}{qReset()}}}} or {\hyperref[\detokenize{api/class_TreeNode:necsimclass_tree_node_1a715869c786bb0442d56994de11571605}]{\sphinxcrossref{\DUrole{std,std-ref}{resetSpecies()}}}}. 

\begin{description}
\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{idin}: the species ID. 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{TreeNode::setTip (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_TreeNode:_CPPv2N8TreeNode6setTipEb}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_TreeNode:necsimclass_tree_node_1acb1926edf4d646f81a60e3b76a6475e0}}\pysiglinewithargsret{void \sphinxbfcode{setTip}}{bool \sphinxstyleemphasis{b}}{}%
\pysigstopmultiline
Setter for the tip boolean. 

\begin{description}
\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{b}: the tip boolean. 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{TreeNode::resetSpecies (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_TreeNode:_CPPv2N8TreeNode12resetSpeciesEv}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_TreeNode:necsimclass_tree_node_1a715869c786bb0442d56994de11571605}}\pysiglinewithargsret{void \sphinxbfcode{resetSpecies}}{}{}%
\pysigstopmultiline
Reset the species ID to 0. 

\end{fulllineitems}

\index{TreeNode::increaseGen (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_TreeNode:_CPPv2N8TreeNode11increaseGenEv}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_TreeNode:necsimclass_tree_node_1a9601d828d9ff808dd3081410a105a069}}\pysiglinewithargsret{void \sphinxbfcode{increaseGen}}{}{}%
\pysigstopmultiline
Increases the generation counter by one. 

\end{fulllineitems}

\index{TreeNode::getExistence (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_TreeNode:_CPPv2N8TreeNode12getExistenceEv}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_TreeNode:necsimclass_tree_node_1a9d9336ac6e4157c8618c40eb43ddb948}}\pysiglinewithargsret{bool \sphinxbfcode{getExistence}}{}{}%
\pysigstopmultiline
Getter for the existence boolean. 

\begin{description}
\item[{\sphinxstylestrong{Return}}] \leavevmode
the existence boolean. 

\end{description}


\end{fulllineitems}

\index{TreeNode::isTip (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_TreeNode:_CPPv2N8TreeNode5isTipEv}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_TreeNode:necsimclass_tree_node_1a469a21919177bd1161f9bfa3c13bd148}}\pysiglinewithargsret{bool \sphinxbfcode{isTip}}{}{}%
\pysigstopmultiline
Getter for the tip boolean. 

\begin{description}
\item[{\sphinxstylestrong{Return}}] \leavevmode
the tip boolean. 

\end{description}


\end{fulllineitems}

\index{TreeNode::getParent (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_TreeNode:_CPPv2N8TreeNode9getParentEv}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_TreeNode:necsimclass_tree_node_1a8115342188f03eeaace4573531fdbfc2}}\pysiglinewithargsret{unsigned long \sphinxbfcode{getParent}}{}{}%
\pysigstopmultiline
Getter for the parent location. 

\begin{description}
\item[{\sphinxstylestrong{Return}}] \leavevmode
the parent reference. 

\end{description}


\end{fulllineitems}

\index{TreeNode::getXpos (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_TreeNode:_CPPv2N8TreeNode7getXposEv}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_TreeNode:necsimclass_tree_node_1a64333707f61650c168e4fb56bde1f95c}}\pysiglinewithargsret{unsigned long \sphinxbfcode{getXpos}}{}{}%
\pysigstopmultiline
Getter for the x position. 

\begin{description}
\item[{\sphinxstylestrong{Return}}] \leavevmode
the x position. 

\end{description}


\end{fulllineitems}

\index{TreeNode::getYpos (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_TreeNode:_CPPv2N8TreeNode7getYposEv}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_TreeNode:necsimclass_tree_node_1a37a2d729519175d8a509e616256d8d1a}}\pysiglinewithargsret{unsigned long \sphinxbfcode{getYpos}}{}{}%
\pysigstopmultiline
Getter for the y position. 

\begin{description}
\item[{\sphinxstylestrong{Return}}] \leavevmode
the y position. 

\end{description}


\end{fulllineitems}

\index{TreeNode::getXwrap (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_TreeNode:_CPPv2N8TreeNode8getXwrapEv}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_TreeNode:necsimclass_tree_node_1a97967c939c284e38c2471a16063d6f58}}\pysiglinewithargsret{long \sphinxbfcode{getXwrap}}{}{}%
\pysigstopmultiline
Getter for the number of times the lineage is wrapped in the x dimension. 

\begin{description}
\item[{\sphinxstylestrong{Return}}] \leavevmode
the number of times the lineage is wrapped in the x dimension. 

\end{description}


\end{fulllineitems}

\index{TreeNode::getYwrap (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_TreeNode:_CPPv2N8TreeNode8getYwrapEv}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_TreeNode:necsimclass_tree_node_1a9111da13a5d750d2a38c0e3f4a7d7a5a}}\pysiglinewithargsret{long \sphinxbfcode{getYwrap}}{}{}%
\pysigstopmultiline
Getter for the number of times the lineage is wrapped in the y dimension. 

\begin{description}
\item[{\sphinxstylestrong{Return}}] \leavevmode
the number of times the lineage is wrapped in the y dimension. 

\end{description}


\end{fulllineitems}

\index{TreeNode::hasSpeciated (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_TreeNode:_CPPv2N8TreeNode12hasSpeciatedEv}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_TreeNode:necsimclass_tree_node_1a1c6376914155dee34c708a9daa664f81}}\pysiglinewithargsret{bool \sphinxbfcode{hasSpeciated}}{}{}%
\pysigstopmultiline
Getter for the speciation boolean. 

\begin{description}
\item[{\sphinxstylestrong{Return}}] \leavevmode
the speciation boolean. 

\end{description}


\end{fulllineitems}

\index{TreeNode::getSpeciesID (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_TreeNode:_CPPv2N8TreeNode12getSpeciesIDEv}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_TreeNode:necsimclass_tree_node_1a923a5ffbd66e3823a816fb9d76555eaf}}\pysiglinewithargsret{unsigned long \sphinxbfcode{getSpeciesID}}{}{}%
\pysigstopmultiline
Getter for the species ID. 

\begin{description}
\item[{\sphinxstylestrong{Return}}] \leavevmode
the species ID. 

\end{description}


\end{fulllineitems}

\index{TreeNode::getSpecRate (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_TreeNode:_CPPv2N8TreeNode11getSpecRateEv}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_TreeNode:necsimclass_tree_node_1af43059aa1fd45e75c9e48ef8f67fa3b1}}\pysiglinewithargsret{long double \sphinxbfcode{getSpecRate}}{}{}%
\pysigstopmultiline
Getter for the randomly generated speciation probability. 

\begin{description}
\item[{\sphinxstylestrong{Return}}] \leavevmode
the speciation probability. 

\end{description}


\end{fulllineitems}

\index{TreeNode::getGenRate (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_TreeNode:_CPPv2N8TreeNode10getGenRateEv}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_TreeNode:necsimclass_tree_node_1ac4e7efffacf32905d73c83b9092232b0}}\pysiglinewithargsret{unsigned long \sphinxbfcode{getGenRate}}{}{}%
\pysigstopmultiline
Getter for the number of generations the lineage has existed. 

\begin{description}
\item[{\sphinxstylestrong{Return}}] \leavevmode
the number of generations of existence. 

\end{description}


\end{fulllineitems}

\index{TreeNode::getGeneration (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_TreeNode:_CPPv2N8TreeNode13getGenerationEv}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_TreeNode:necsimclass_tree_node_1a55ff42f83d75a9a1fae09605b3e2027f}}\pysiglinewithargsret{long double \sphinxbfcode{getGeneration}}{}{}%
\pysigstopmultiline
Getter for the generation the lineage was created. 

\begin{description}
\item[{\sphinxstylestrong{Return}}] \leavevmode
the generation counter the lineage was created. 

\end{description}


\end{fulllineitems}

\index{TreeNode::speciate (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_TreeNode:_CPPv2N8TreeNode8speciateEv}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_TreeNode:necsimclass_tree_node_1a65a021122e06071f6f127be3a0171518}}\pysiglinewithargsret{void \sphinxbfcode{speciate}}{}{}%
\pysigstopmultiline
Sets the speciation boolean to true. 

\end{fulllineitems}

\index{TreeNode::operator= (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_TreeNode:_CPPv2N8TreeNodeaSERK8TreeNode}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_TreeNode:necsimclass_tree_node_1af362bf557fa6af455f6bac31c4f0356a}}\pysiglinewithargsret{{\hyperref[\detokenize{api/class_TreeNode:_CPPv28TreeNode}]{\sphinxcrossref{TreeNode}}} \&\sphinxbfcode{operator=}}{\sphinxstrong{const} {\hyperref[\detokenize{api/class_TreeNode:_CPPv28TreeNode}]{\sphinxcrossref{TreeNode}}} \&\sphinxstyleemphasis{t}}{}%
\pysigstopmultiline
Overloading the equality operator for TreeNodes \begin{description}
\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{t}: the input {\hyperref[\detokenize{api/class_TreeNode:necsimclass_tree_node}]{\sphinxcrossref{\DUrole{std,std-ref}{TreeNode}}}} 

\end{itemize}

\end{description}


\end{fulllineitems}

\paragraph{Friends}
\index{operator\textless{}\textless{} (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_TreeNode:_CPPv2lsR7ostreamRK8TreeNode}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_TreeNode:necsimclass_tree_node_1a2d73715892a5f20100609978a53dea81}}\pysiglinewithargsret{ostream \&\sphinxbfcode{operator\textless{}\textless{}}}{ostream \&\sphinxstyleemphasis{os}, \sphinxstrong{const} {\hyperref[\detokenize{api/class_TreeNode:_CPPv28TreeNode}]{\sphinxcrossref{TreeNode}}} \&\sphinxstyleemphasis{t}}{}%
\pysigstopmultiline
Overloading the \textless{}\textless{} operator for outputting a Treenode object to an output stream. 

\begin{description}
\item[{\sphinxstylestrong{Return}}] \leavevmode
the output stream. 

\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{os}: the output stream. 

\item {} 
\sphinxcode{t}: a Treenode object to output. 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{operator\textgreater{}\textgreater{} (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/class_TreeNode:_CPPv2rsR7istreamR8TreeNode}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/class_TreeNode:necsimclass_tree_node_1afc6e1f55282105fd812724a8bb09a918}}\pysiglinewithargsret{istream \&\sphinxbfcode{operator\textgreater{}\textgreater{}}}{istream \&\sphinxstyleemphasis{is}, {\hyperref[\detokenize{api/class_TreeNode:_CPPv28TreeNode}]{\sphinxcrossref{TreeNode}}} \&\sphinxstyleemphasis{t}}{}%
\pysigstopmultiline
Overloading the \textgreater{}\textgreater{} operator for inputting the Treenode object from an input stream. 

\begin{description}
\item[{\sphinxstylestrong{Return}}] \leavevmode
the input stream. 

\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{is}: the input stream. 

\item {} 
\sphinxcode{t}: a Treenode object to input to. 

\end{itemize}

\end{description}


\end{fulllineitems}


\end{fulllineitems}



\subsection{Function apply}
\label{\detokenize{api/function_apply::doc}}\label{\detokenize{api/function_apply:function-apply}}\label{\detokenize{api/function_apply:id1}}\begin{itemize}
\item {} 
Defined in {\hyperref[\detokenize{api/file_applyspecmodule.cpp:file-applyspecmodule-cpp}]{\sphinxcrossref{\DUrole{std,std-ref}{File applyspecmodule.cpp}}}}

\end{itemize}


\subsubsection{Function Documentation}
\label{\detokenize{api/function_apply:function-documentation}}
\begin{sphinxadmonition}{warning}{Warning:}
doxygenfunction: Unable to resolve multiple matches for function \sphinxquotedblleft{}apply\sphinxquotedblright{} with arguments () in doxygen xml output for project \sphinxquotedblleft{}necsim\sphinxquotedblright{} from directory: ../docs/necsim\_doc/xml/.
Potential matches:


\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZhy{}} \PYG{n}{void} \PYG{n}{Community}\PYG{p}{:}\PYG{p}{:}\PYG{n+nb}{apply}\PYG{p}{(}\PYG{n}{SpecSimParameters} \PYG{o}{*}\PYG{p}{)}
\PYG{o}{\PYGZhy{}} \PYG{n}{void} \PYG{n}{Metacommunity}\PYG{p}{:}\PYG{p}{:}\PYG{n+nb}{apply}\PYG{p}{(}\PYG{n}{SpecSimParameters} \PYG{o}{*}\PYG{p}{)}
\end{sphinxVerbatim}
\end{sphinxadmonition}


\subsection{Function cantorPairing}
\label{\detokenize{api/function_cantorPairing::doc}}\label{\detokenize{api/function_cantorPairing:function-cantorpairing}}\label{\detokenize{api/function_cantorPairing:id1}}\begin{itemize}
\item {} 
Defined in {\hyperref[\detokenize{api/file_necsim_Filesystem.h:file-necsim-filesystem-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File Filesystem.h}}}}

\end{itemize}


\subsubsection{Function Documentation}
\label{\detokenize{api/function_cantorPairing:function-documentation}}\index{cantorPairing (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/function_cantorPairing:_CPPv213cantorPairingmm}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/function_cantorPairing:necsim_filesystem_8h_1a494775fbade46418f7584db133d85762}}\pysiglinewithargsret{unsigned long \sphinxcode{}\sphinxbfcode{cantorPairing}}{unsigned long \sphinxstyleemphasis{x1}, unsigned long \sphinxstyleemphasis{x2}}{}%
\pysigstopmultiline
Generates a unique ID for the pair of provided parameters. 

Maps ZxZ -\textgreater{} N, so only relevant for positive numbers. For any A and B, generates C such that no D and E produce C unless D=A and B=E.



\begin{description}
\item[{\sphinxstylestrong{Return}}] \leavevmode
a unique reference for the two provided integers 

\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{x1}: the first integer reference 

\item {} 
\sphinxcode{x2}: the second integer reference 

\end{itemize}

\end{description}


\end{fulllineitems}



\subsection{Function checkSpeciation}
\label{\detokenize{api/function_checkSpeciation::doc}}\label{\detokenize{api/function_checkSpeciation:function-checkspeciation}}\label{\detokenize{api/function_checkSpeciation:id1}}\begin{itemize}
\item {} 
Defined in {\hyperref[\detokenize{api/file_necsim_Community.h:file-necsim-community-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File Community.h}}}}

\end{itemize}


\subsubsection{Function Documentation}
\label{\detokenize{api/function_checkSpeciation:function-documentation}}\index{checkSpeciation (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/function_checkSpeciation:_CPPv215checkSpeciationRKeRKeRKm}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/function_checkSpeciation:necsim_community_8h_1ac0d535bc74d14e6a7c851f1242548dc0}}\pysiglinewithargsret{bool \sphinxcode{}\sphinxbfcode{checkSpeciation}}{\sphinxstrong{const} long double \&\sphinxstyleemphasis{random\_number}, \sphinxstrong{const} long double \&\sphinxstyleemphasis{speciation\_rate}, \sphinxstrong{const} unsigned long \&\sphinxstyleemphasis{no\_generations}}{}%
\pysigstopmultiline
Checks whether speciation has occured for the provided parameters. Provided here for ease of use when bug-fixing. 

\begin{description}
\item[{\sphinxstylestrong{Return}}] \leavevmode
bool the speciation state of the lineage 

\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{random\_number}: the random number associated with a lineage 

\item {} 
\sphinxcode{speciation\_rate}: the global speciation rate 

\item {} 
\sphinxcode{number\_of\_generations}: the number of generations the lineage has existed 

\end{itemize}

\end{description}


\end{fulllineitems}



\subsection{Function createCommunity}
\label{\detokenize{api/function_createCommunity:function-createcommunity}}\label{\detokenize{api/function_createCommunity::doc}}\label{\detokenize{api/function_createCommunity:id1}}\begin{itemize}
\item {} 
Defined in {\hyperref[\detokenize{api/file_applyspecmodule.cpp:file-applyspecmodule-cpp}]{\sphinxcrossref{\DUrole{std,std-ref}{File applyspecmodule.cpp}}}}

\end{itemize}


\subsubsection{Function Documentation}
\label{\detokenize{api/function_createCommunity:function-documentation}}
\begin{sphinxadmonition}{warning}{Warning:}
doxygenfunction: Cannot find function \sphinxquotedblleft{}createCommunity\sphinxquotedblright{} in doxygen xml output for project \sphinxquotedblleft{}necsim\sphinxquotedblright{} from directory: ../docs/necsim\_doc/xml/
\end{sphinxadmonition}


\subsection{Function createParent}
\label{\detokenize{api/function_createParent:function-createparent}}\label{\detokenize{api/function_createParent::doc}}\label{\detokenize{api/function_createParent:id1}}\begin{itemize}
\item {} 
Defined in {\hyperref[\detokenize{api/file_necsim_Filesystem.h:file-necsim-filesystem-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File Filesystem.h}}}}

\end{itemize}


\subsubsection{Function Documentation}
\label{\detokenize{api/function_createParent:function-documentation}}\index{createParent (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/function_createParent:_CPPv212createParentRK6string}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/function_createParent:necsim_filesystem_8h_1adc3ac635764997d6023cbb00f7664196}}\pysiglinewithargsret{void \sphinxcode{}\sphinxbfcode{createParent}}{\sphinxstrong{const} string \&\sphinxstyleemphasis{file}}{}%
\pysigstopmultiline
Checks that parent folder to the supplied file exists, and if it doesn't creates it. 

\begin{description}
\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{file}: the file path to check for 

\end{itemize}

\end{description}


\end{fulllineitems}



\subsection{Function distanceBetween}
\label{\detokenize{api/function_distanceBetween:function-distancebetween}}\label{\detokenize{api/function_distanceBetween::doc}}\label{\detokenize{api/function_distanceBetween:id1}}\begin{itemize}
\item {} 
Defined in {\hyperref[\detokenize{api/file_necsim_SimulateDispersal.h:file-necsim-simulatedispersal-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File SimulateDispersal.h}}}}

\end{itemize}


\subsubsection{Function Documentation}
\label{\detokenize{api/function_distanceBetween:function-documentation}}\index{distanceBetween (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/function_distanceBetween:_CPPv215distanceBetweenR4CellR4Cell}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/function_distanceBetween:necsim_simulate_dispersal_8h_1a4ab7d822feb75c3391bf0213a8677c53}}\pysiglinewithargsret{double \sphinxcode{}\sphinxbfcode{distanceBetween}}{{\hyperref[\detokenize{api/class_Cell:_CPPv24Cell}]{\sphinxcrossref{Cell}}} \&\sphinxstyleemphasis{c1}, {\hyperref[\detokenize{api/class_Cell:_CPPv24Cell}]{\sphinxcrossref{Cell}}} \&\sphinxstyleemphasis{c2}}{}%
\pysigstopmultiline
Calculates the distance between two cells. 

\begin{description}
\item[{\sphinxstylestrong{Return}}] \leavevmode
the distance between the two points 

\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{c1}: {\hyperref[\detokenize{api/class_Cell:necsimstruct_cell}]{\sphinxcrossref{\DUrole{std,std-ref}{Cell}}}} containing one point 

\item {} 
\sphinxcode{c2}: {\hyperref[\detokenize{api/class_Cell:necsimstruct_cell}]{\sphinxcrossref{\DUrole{std,std-ref}{Cell}}}} containing second point 

\end{itemize}

\end{description}


\end{fulllineitems}



\subsection{Function doesExist}
\label{\detokenize{api/function_doesExist::doc}}\label{\detokenize{api/function_doesExist:function-doesexist}}\label{\detokenize{api/function_doesExist:id1}}\begin{itemize}
\item {} 
Defined in {\hyperref[\detokenize{api/file_necsim_Filesystem.h:file-necsim-filesystem-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File Filesystem.h}}}}

\end{itemize}


\subsubsection{Function Documentation}
\label{\detokenize{api/function_doesExist:function-documentation}}\index{doesExist (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/function_doesExist:_CPPv29doesExist6string}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/function_doesExist:necsim_filesystem_8h_1af836e59d723600545dfdfe76b0c14b94}}\pysiglinewithargsret{bool \sphinxcode{}\sphinxbfcode{doesExist}}{string \sphinxstyleemphasis{testfile}}{}%
\pysigstopmultiline
Checks the existance of a file on the hard drive. 

\begin{description}
\item[{\sphinxstylestrong{Return}}] \leavevmode
if true, file exists 

\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{testfile}: the file to examine 

\end{itemize}

\end{description}


\end{fulllineitems}



\subsection{Function doesExistNull}
\label{\detokenize{api/function_doesExistNull:function-doesexistnull}}\label{\detokenize{api/function_doesExistNull::doc}}\label{\detokenize{api/function_doesExistNull:id1}}\begin{itemize}
\item {} 
Defined in {\hyperref[\detokenize{api/file_necsim_Filesystem.h:file-necsim-filesystem-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File Filesystem.h}}}}

\end{itemize}


\subsubsection{Function Documentation}
\label{\detokenize{api/function_doesExistNull:function-documentation}}\index{doesExistNull (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/function_doesExistNull:_CPPv213doesExistNull6string}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/function_doesExistNull:necsim_filesystem_8h_1a0b70d536db024e2f65c377c02fa596ba}}\pysiglinewithargsret{bool \sphinxcode{}\sphinxbfcode{doesExistNull}}{string \sphinxstyleemphasis{testfile}}{}%
\pysigstopmultiline
Checks for the existance of a file, but returns true if the file name is `null'. Note: this function just calls {\hyperref[\detokenize{api/function_doesExist:necsim_filesystem_8h_1af836e59d723600545dfdfe76b0c14b94}]{\sphinxcrossref{\DUrole{std,std-ref}{doesExist()}}}}. 

\begin{description}
\item[{\sphinxstylestrong{Return}}] \leavevmode
if true, file exists (or is null). 

\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{testfile}: the file to examine 

\end{itemize}

\end{description}


\end{fulllineitems}



\subsection{Function doubleCompare}
\label{\detokenize{api/function_doubleCompare::doc}}\label{\detokenize{api/function_doubleCompare:function-doublecompare}}\label{\detokenize{api/function_doubleCompare:id1}}\begin{itemize}
\item {} 
Defined in {\hyperref[\detokenize{api/file_necsim_Community.h:file-necsim-community-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File Community.h}}}}

\end{itemize}


\subsubsection{Function Documentation}
\label{\detokenize{api/function_doubleCompare:function-documentation}}
\begin{sphinxadmonition}{warning}{Warning:}
doxygenfunction: Unable to resolve multiple matches for function \sphinxquotedblleft{}doubleCompare\sphinxquotedblright{} with arguments () in doxygen xml output for project \sphinxquotedblleft{}necsim\sphinxquotedblright{} from directory: ../docs/necsim\_doc/xml/.
Potential matches:


\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZhy{}} \PYG{n+nb}{bool} \PYG{n}{doubleCompare}\PYG{p}{(}\PYG{n}{double}\PYG{p}{,} \PYG{n}{double}\PYG{p}{,} \PYG{n}{double}\PYG{p}{)}
\PYG{o}{\PYGZhy{}} \PYG{n+nb}{bool} \PYG{n}{doubleCompare}\PYG{p}{(}\PYG{n+nb}{long} \PYG{n}{double}\PYG{p}{,} \PYG{n+nb}{long} \PYG{n}{double}\PYG{p}{,} \PYG{n}{double}\PYG{p}{)}
\PYG{o}{\PYGZhy{}} \PYG{n+nb}{bool} \PYG{n}{doubleCompare}\PYG{p}{(}\PYG{n+nb}{long} \PYG{n}{double}\PYG{p}{,} \PYG{n+nb}{long} \PYG{n}{double}\PYG{p}{,} \PYG{n+nb}{long} \PYG{n}{double}\PYG{p}{)}
\end{sphinxVerbatim}
\end{sphinxadmonition}


\subsection{Function getConfigFileFromCmdArgs}
\label{\detokenize{api/function_getConfigFileFromCmdArgs:function-getconfigfilefromcmdargs}}\label{\detokenize{api/function_getConfigFileFromCmdArgs::doc}}\label{\detokenize{api/function_getConfigFileFromCmdArgs:id1}}\begin{itemize}
\item {} 
Defined in {\hyperref[\detokenize{api/file_necsim_SimulationTemplates.h:file-necsim-simulationtemplates-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File SimulationTemplates.h}}}}

\end{itemize}


\subsubsection{Function Documentation}
\label{\detokenize{api/function_getConfigFileFromCmdArgs:function-documentation}}\index{getConfigFileFromCmdArgs (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/function_getConfigFileFromCmdArgs:_CPPv224getConfigFileFromCmdArgsRK6vectorI6stringE}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/function_getConfigFileFromCmdArgs:necsim_simulation_templates_8h_1a5a0913fcc8a0d06bb3543bae060e94d2}}\pysiglinewithargsret{\sphinxstrong{const} string \&\sphinxcode{}\sphinxbfcode{getConfigFileFromCmdArgs}}{\sphinxstrong{const} vector\textless{}string\textgreater{} \&\sphinxstyleemphasis{com\_args}}{}%
\pysigstopmultiline
Gets the {[}2{]} element from the vector (which should contain the config file from command-line arguments. 

\begin{description}
\item[{\sphinxstylestrong{Return}}] \leavevmode
the string at the {[}2{]} position containing the path to the config file 

\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{com\_args}: the vector of command-line arguments 

\end{itemize}

\end{description}


\end{fulllineitems}



\subsection{Function getDefaultLogFile}
\label{\detokenize{api/function_getDefaultLogFile:function-getdefaultlogfile}}\label{\detokenize{api/function_getDefaultLogFile::doc}}\label{\detokenize{api/function_getDefaultLogFile:id1}}\begin{itemize}
\item {} 
Defined in {\hyperref[\detokenize{api/file_necsim_LogFile.h:file-necsim-logfile-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File LogFile.h}}}}

\end{itemize}


\subsubsection{Function Documentation}
\label{\detokenize{api/function_getDefaultLogFile:function-documentation}}\index{getDefaultLogFile (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/function_getDefaultLogFile:_CPPv217getDefaultLogFilev}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/function_getDefaultLogFile:necsim_log_file_8h_1a0f519c044006aac9a55a4098570843bb}}\pysiglinewithargsret{string \sphinxcode{}\sphinxbfcode{getDefaultLogFile}}{}{}%
\pysigstopmultiline
Gets the default log file path. Stored at log/DDMMYYYY\_HHMMSS.log where DDMMYYYY\_HHMMSS are replaced by the current date and time. 

\begin{description}
\item[{\sphinxstylestrong{Return}}] \leavevmode
location of the default logging position. 

\end{description}


\end{fulllineitems}



\subsection{Function getTime}
\label{\detokenize{api/function_getTime:function-gettime}}\label{\detokenize{api/function_getTime::doc}}\label{\detokenize{api/function_getTime:id1}}\begin{itemize}
\item {} 
Defined in {\hyperref[\detokenize{api/file_necsim_LogFile.cpp:file-necsim-logfile-cpp}]{\sphinxcrossref{\DUrole{std,std-ref}{File LogFile.cpp}}}}

\end{itemize}


\subsubsection{Function Documentation}
\label{\detokenize{api/function_getTime:function-documentation}}
\begin{sphinxadmonition}{warning}{Warning:}
doxygenfunction: Cannot find function \sphinxquotedblleft{}getTime\sphinxquotedblright{} in doxygen xml output for project \sphinxquotedblleft{}necsim\sphinxquotedblright{} from directory: ../docs/necsim\_doc/xml/
\end{sphinxadmonition}


\subsection{Function getUniqueFileName}
\label{\detokenize{api/function_getUniqueFileName:id1}}\label{\detokenize{api/function_getUniqueFileName::doc}}\label{\detokenize{api/function_getUniqueFileName:function-getuniquefilename}}\begin{itemize}
\item {} 
Defined in {\hyperref[\detokenize{api/file_necsim_LogFile.h:file-necsim-logfile-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File LogFile.h}}}}

\end{itemize}


\subsubsection{Function Documentation}
\label{\detokenize{api/function_getUniqueFileName:function-documentation}}\index{getUniqueFileName (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/function_getUniqueFileName:_CPPv217getUniqueFileNameR6string}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/function_getUniqueFileName:necsim_log_file_8h_1a96ac11c89504dd77c09235bbea7c1f67}}\pysiglinewithargsret{void \sphinxcode{}\sphinxbfcode{getUniqueFileName}}{string \&\sphinxstyleemphasis{basic\_string}}{}%
\pysigstopmultiline
Modifies the file name so that it doesn't point to an existing file. 

\begin{description}
\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{basic\_string}: the file name to modify 

\end{itemize}

\end{description}


\end{fulllineitems}



\subsection{Function importArgs}
\label{\detokenize{api/function_importArgs::doc}}\label{\detokenize{api/function_importArgs:function-importargs}}\label{\detokenize{api/function_importArgs:id1}}\begin{itemize}
\item {} 
Defined in {\hyperref[\detokenize{api/file_necsim_ConfigFileParser.h:file-necsim-configfileparser-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File ConfigFileParser.h}}}}

\end{itemize}


\subsubsection{Function Documentation}
\label{\detokenize{api/function_importArgs:function-documentation}}\index{importArgs (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/function_importArgs:_CPPv210importArgsRKjA_PcR6vectorI6stringE}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/function_importArgs:necsim_config_file_parser_8h_1ab14ba2a8e5a50a5a24b48c45294ef483}}\pysiglinewithargsret{void \sphinxcode{}\sphinxbfcode{importArgs}}{\sphinxstrong{const} unsigned int \&\sphinxstyleemphasis{argc}, char *\sphinxstyleemphasis{argv}{[}{]}, vector\textless{}string\textgreater{} \&\sphinxstyleemphasis{comargs}}{}%
\pysigstopmultiline
Import the command line arguments in to the vector for future processing. Arguments will be placed in the vector comargs. 

\begin{description}
\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{argc}: the number of arguments. 

\item {} 
\sphinxcode{argv}: a point to the array of arguments in raw character form. 

\item {} 
\sphinxcode{comargs}: a vector of the command-line arguments to be filled. 

\end{itemize}

\end{description}


\end{fulllineitems}



\subsection{Function initapplyspecmodule}
\label{\detokenize{api/function_initapplyspecmodule:function-initapplyspecmodule}}\label{\detokenize{api/function_initapplyspecmodule::doc}}\label{\detokenize{api/function_initapplyspecmodule:id1}}\begin{itemize}
\item {} 
Defined in {\hyperref[\detokenize{api/file_applyspecmodule.h:file-applyspecmodule-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File applyspecmodule.h}}}}

\end{itemize}


\subsubsection{Function Documentation}
\label{\detokenize{api/function_initapplyspecmodule:function-documentation}}\index{initapplyspecmodule (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/function_initapplyspecmodule:_CPPv219initapplyspecmodulev}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/function_initapplyspecmodule:necsimapplyspecmodule_8h_1a1d49241e65981fb4ceca59a7e420decf}}\pysiglinewithargsret{PyMODINIT\_FUNC \sphinxcode{}\sphinxbfcode{initapplyspecmodule}}{void}{}%
\pysigstopmultiline
\end{fulllineitems}



\subsection{Function initdispersalmodule}
\label{\detokenize{api/function_initdispersalmodule:function-initdispersalmodule}}\label{\detokenize{api/function_initdispersalmodule::doc}}\label{\detokenize{api/function_initdispersalmodule:id1}}\begin{itemize}
\item {} 
Defined in {\hyperref[\detokenize{api/file_dispersalmodule.h:file-dispersalmodule-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File dispersalmodule.h}}}}

\end{itemize}


\subsubsection{Function Documentation}
\label{\detokenize{api/function_initdispersalmodule:function-documentation}}\index{initdispersalmodule (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/function_initdispersalmodule:_CPPv219initdispersalmodulev}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/function_initdispersalmodule:necsimdispersalmodule_8h_1a6bb4c0faf0e3fd0b77bbad879dfec993}}\pysiglinewithargsret{PyMODINIT\_FUNC \sphinxcode{}\sphinxbfcode{initdispersalmodule}}{void}{}%
\pysigstopmultiline
\end{fulllineitems}



\subsection{Function initnecsimmodule}
\label{\detokenize{api/function_initnecsimmodule:function-initnecsimmodule}}\label{\detokenize{api/function_initnecsimmodule::doc}}\label{\detokenize{api/function_initnecsimmodule:id1}}\begin{itemize}
\item {} 
Defined in {\hyperref[\detokenize{api/file_necsimmodule.h:file-necsimmodule-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File necsimmodule.h}}}}

\end{itemize}


\subsubsection{Function Documentation}
\label{\detokenize{api/function_initnecsimmodule:function-documentation}}\index{initnecsimmodule (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/function_initnecsimmodule:_CPPv216initnecsimmodulev}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/function_initnecsimmodule:necsimnecsimmodule_8h_1af5f34a40faeb40208ed217296d73dc1e}}\pysiglinewithargsret{PyMODINIT\_FUNC \sphinxcode{}\sphinxbfcode{initnecsimmodule}}{void}{}%
\pysigstopmultiline
\end{fulllineitems}



\subsection{Function main}
\label{\detokenize{api/function_main:id1}}\label{\detokenize{api/function_main::doc}}\label{\detokenize{api/function_main:function-main}}\begin{itemize}
\item {} 
Defined in {\hyperref[\detokenize{api/file_SpeciationCounter.cpp:file-speciationcounter-cpp}]{\sphinxcrossref{\DUrole{std,std-ref}{File SpeciationCounter.cpp}}}}

\end{itemize}


\subsubsection{Function Documentation}
\label{\detokenize{api/function_main:function-documentation}}
\begin{sphinxadmonition}{warning}{Warning:}
doxygenfunction: Cannot find function \sphinxquotedblleft{}main\sphinxquotedblright{} in doxygen xml output for project \sphinxquotedblleft{}necsim\sphinxquotedblright{} from directory: ../docs/necsim\_doc/xml/
\end{sphinxadmonition}


\subsection{Function openLogFile}
\label{\detokenize{api/function_openLogFile:function-openlogfile}}\label{\detokenize{api/function_openLogFile::doc}}\label{\detokenize{api/function_openLogFile:id1}}\begin{itemize}
\item {} 
Defined in {\hyperref[\detokenize{api/file_necsim_Setup.cpp:file-necsim-setup-cpp}]{\sphinxcrossref{\DUrole{std,std-ref}{File Setup.cpp}}}}

\end{itemize}


\subsubsection{Function Documentation}
\label{\detokenize{api/function_openLogFile:function-documentation}}
\begin{sphinxadmonition}{warning}{Warning:}
doxygenfunction: Cannot find function \sphinxquotedblleft{}openLogFile\sphinxquotedblright{} in doxygen xml output for project \sphinxquotedblleft{}necsim\sphinxquotedblright{} from directory: ../docs/necsim\_doc/xml/
\end{sphinxadmonition}


\subsection{Function openSQLiteDatabase}
\label{\detokenize{api/function_openSQLiteDatabase::doc}}\label{\detokenize{api/function_openSQLiteDatabase:function-opensqlitedatabase}}\label{\detokenize{api/function_openSQLiteDatabase:id1}}\begin{itemize}
\item {} 
Defined in {\hyperref[\detokenize{api/file_necsim_Filesystem.h:file-necsim-filesystem-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File Filesystem.h}}}}

\end{itemize}


\subsubsection{Function Documentation}
\label{\detokenize{api/function_openSQLiteDatabase:function-documentation}}\index{openSQLiteDatabase (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/function_openSQLiteDatabase:_CPPv218openSQLiteDatabaseRK6stringRP7sqlite3}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/function_openSQLiteDatabase:necsim_filesystem_8h_1a2dd35a078ed71b998730c8af8f4788f0}}\pysiglinewithargsret{void \sphinxcode{}\sphinxbfcode{openSQLiteDatabase}}{\sphinxstrong{const} string \&\sphinxstyleemphasis{database\_name}, sqlite3 *\&\sphinxstyleemphasis{database}}{}%
\pysigstopmultiline
Safely opens a connection to the provided SQLite database. 

Adds type safety for usage on different filesystems. \begin{description}
\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{database\_name}: 

\item {} 
\sphinxcode{database}: 

\end{itemize}

\end{description}


\end{fulllineitems}



\subsection{Function operator\textless{}\textless{}}
\label{\detokenize{api/function_operator_LT__LT:function-operator}}\label{\detokenize{api/function_operator_LT__LT:function-operator-lt-lt}}\label{\detokenize{api/function_operator_LT__LT::doc}}\begin{itemize}
\item {} 
Defined in {\hyperref[\detokenize{api/file_necsim_TreeNode.cpp:file-necsim-treenode-cpp}]{\sphinxcrossref{\DUrole{std,std-ref}{File TreeNode.cpp}}}}

\end{itemize}


\subsubsection{Function Documentation}
\label{\detokenize{api/function_operator_LT__LT:function-documentation}}
\begin{sphinxadmonition}{warning}{Warning:}
doxygenfunction: Cannot find function \sphinxquotedblleft{}operator\textless{}\textless{}\sphinxquotedblright{} in doxygen xml output for project \sphinxquotedblleft{}necsim\sphinxquotedblright{} from directory: ../docs/necsim\_doc/xml/
\end{sphinxadmonition}


\subsection{Function operator\textgreater{}\textgreater{}}
\label{\detokenize{api/function_operator_GT__GT:function-operator}}\label{\detokenize{api/function_operator_GT__GT::doc}}\label{\detokenize{api/function_operator_GT__GT:function-operator-gt-gt}}\begin{itemize}
\item {} 
Defined in {\hyperref[\detokenize{api/file_necsim_TreeNode.cpp:file-necsim-treenode-cpp}]{\sphinxcrossref{\DUrole{std,std-ref}{File TreeNode.cpp}}}}

\end{itemize}


\subsubsection{Function Documentation}
\label{\detokenize{api/function_operator_GT__GT:function-documentation}}
\begin{sphinxadmonition}{warning}{Warning:}
doxygenfunction: Cannot find function \sphinxquotedblleft{}operator\textgreater{}\textgreater{}\sphinxquotedblright{} in doxygen xml output for project \sphinxquotedblleft{}necsim\sphinxquotedblright{} from directory: ../docs/necsim\_doc/xml/
\end{sphinxadmonition}


\subsection{Function removeComOption}
\label{\detokenize{api/function_removeComOption:function-removecomoption}}\label{\detokenize{api/function_removeComOption::doc}}\label{\detokenize{api/function_removeComOption:id1}}\begin{itemize}
\item {} 
Defined in {\hyperref[\detokenize{api/file_necsim_Setup.h:file-necsim-setup-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File Setup.h}}}}

\end{itemize}


\subsubsection{Function Documentation}
\label{\detokenize{api/function_removeComOption:function-documentation}}\index{removeComOption (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/function_removeComOption:_CPPv215removeComOptionRmR6vectorI6stringE}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/function_removeComOption:necsim_setup_8h_1a297d1a4ce3dd8aa2c7c06c578bd5d80a}}\pysiglinewithargsret{void \sphinxcode{}\sphinxbfcode{removeComOption}}{unsigned long \&\sphinxstyleemphasis{argc}, vector\textless{}string\textgreater{} \&\sphinxstyleemphasis{comargs}}{}%
\pysigstopmultiline
Removes the command line options supplied, leaving just a clean vector with the correct data in. 

\end{fulllineitems}



\subsection{Function resume\_simulation}
\label{\detokenize{api/function_resume_simulation:function-resume-simulation}}\label{\detokenize{api/function_resume_simulation::doc}}\label{\detokenize{api/function_resume_simulation:id1}}\begin{itemize}
\item {} 
Defined in {\hyperref[\detokenize{api/file_necsimmodule.cpp:file-necsimmodule-cpp}]{\sphinxcrossref{\DUrole{std,std-ref}{File necsimmodule.cpp}}}}

\end{itemize}


\subsubsection{Function Documentation}
\label{\detokenize{api/function_resume_simulation:function-documentation}}
\begin{sphinxadmonition}{warning}{Warning:}
doxygenfunction: Cannot find function \sphinxquotedblleft{}resume\_simulation\sphinxquotedblright{} in doxygen xml output for project \sphinxquotedblleft{}necsim\sphinxquotedblright{} from directory: ../docs/necsim\_doc/xml/
\end{sphinxadmonition}


\subsection{Function run\_simulation}
\label{\detokenize{api/function_run_simulation:function-run-simulation}}\label{\detokenize{api/function_run_simulation::doc}}\label{\detokenize{api/function_run_simulation:id1}}\begin{itemize}
\item {} 
Defined in {\hyperref[\detokenize{api/file_necsimmodule.cpp:file-necsimmodule-cpp}]{\sphinxcrossref{\DUrole{std,std-ref}{File necsimmodule.cpp}}}}

\end{itemize}


\subsubsection{Function Documentation}
\label{\detokenize{api/function_run_simulation:function-documentation}}
\begin{sphinxadmonition}{warning}{Warning:}
doxygenfunction: Cannot find function \sphinxquotedblleft{}run\_simulation\sphinxquotedblright{} in doxygen xml output for project \sphinxquotedblleft{}necsim\sphinxquotedblright{} from directory: ../docs/necsim\_doc/xml/
\end{sphinxadmonition}


\subsection{Function runAsDefault}
\label{\detokenize{api/function_runAsDefault:function-runasdefault}}\label{\detokenize{api/function_runAsDefault::doc}}\label{\detokenize{api/function_runAsDefault:id1}}\begin{itemize}
\item {} 
Defined in {\hyperref[\detokenize{api/file_necsim_Setup.h:file-necsim-setup-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File Setup.h}}}}

\end{itemize}


\subsubsection{Function Documentation}
\label{\detokenize{api/function_runAsDefault:function-documentation}}\index{runAsDefault (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/function_runAsDefault:_CPPv212runAsDefaultR6vectorI6stringE}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/function_runAsDefault:necsim_setup_8h_1ae5f0fe9d930f0bf31869e95f1d284e73}}\pysiglinewithargsret{void \sphinxcode{}\sphinxbfcode{runAsDefault}}{vector\textless{}string\textgreater{} \&\sphinxstyleemphasis{comargs}}{}%
\pysigstopmultiline
Sets up the command-line arguments for default parameters. 

This is intended for testing purposes only. \begin{description}
\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{comargs}: a vector of command-line arguments for putting the parameters into. 

\end{itemize}

\end{description}


\end{fulllineitems}



\subsection{Function runLarge}
\label{\detokenize{api/function_runLarge:function-runlarge}}\label{\detokenize{api/function_runLarge::doc}}\label{\detokenize{api/function_runLarge:id1}}\begin{itemize}
\item {} 
Defined in {\hyperref[\detokenize{api/file_necsim_Setup.h:file-necsim-setup-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File Setup.h}}}}

\end{itemize}


\subsubsection{Function Documentation}
\label{\detokenize{api/function_runLarge:function-documentation}}\index{runLarge (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/function_runLarge:_CPPv28runLargeR6vectorI6stringE}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/function_runLarge:necsim_setup_8h_1ae630bc537fa43724bcb8e13905640d4f}}\pysiglinewithargsret{void \sphinxcode{}\sphinxbfcode{runLarge}}{vector\textless{}string\textgreater{} \&\sphinxstyleemphasis{comargs}}{}%
\pysigstopmultiline
Sets up the command-line arguments for larger-scale default parameters. 

This is intended for testing purposes only. \begin{description}
\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{comargs}: a vector of command-line arguments for putting the parameters into. 

\end{itemize}

\end{description}


\end{fulllineitems}



\subsection{Function runMain}
\label{\detokenize{api/function_runMain:id1}}\label{\detokenize{api/function_runMain::doc}}\label{\detokenize{api/function_runMain:function-runmain}}\begin{itemize}
\item {} 
Defined in {\hyperref[\detokenize{api/file_necsim_SimulationTemplates.h:file-necsim-simulationtemplates-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File SimulationTemplates.h}}}}

\end{itemize}


\subsubsection{Function Documentation}
\label{\detokenize{api/function_runMain:function-documentation}}\index{runMain (C++ function)}

\begin{fulllineitems}
\pysigline{\sphinxstrong{template }\textless{}\sphinxstrong{class} T\textgreater{}}\phantomsection\label{\detokenize{api/function_runMain:_CPPv27runMainRK6string}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/function_runMain:necsim_simulation_templates_8h_1a7769b3dcc06a33c0f97a9053ae6d4046}}\pysiglinewithargsret{void \sphinxcode{}\sphinxbfcode{runMain}}{\sphinxstrong{const} string \&\sphinxstyleemphasis{config\_file}}{}%
\pysigstopmultiline
Template class for running simulations from all {\hyperref[\detokenize{api/class_Tree:necsimclass_tree}]{\sphinxcrossref{\DUrole{std,std-ref}{Tree}}}} types. 

\begin{description}
\item[{\sphinxstylestrong{Template Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{T}: the class (either {\hyperref[\detokenize{api/class_Tree:necsimclass_tree}]{\sphinxcrossref{\DUrole{std,std-ref}{Tree}}}}, or a child of {\hyperref[\detokenize{api/class_Tree:necsimclass_tree}]{\sphinxcrossref{\DUrole{std,std-ref}{Tree}}}}) of the simulation 

\end{itemize}

\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{config\_file}: the config file to read simulation parameters from 

\end{itemize}

\end{description}


\end{fulllineitems}



\subsection{Function runXL}
\label{\detokenize{api/function_runXL:function-runxl}}\label{\detokenize{api/function_runXL::doc}}\label{\detokenize{api/function_runXL:id1}}\begin{itemize}
\item {} 
Defined in {\hyperref[\detokenize{api/file_necsim_Setup.h:file-necsim-setup-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File Setup.h}}}}

\end{itemize}


\subsubsection{Function Documentation}
\label{\detokenize{api/function_runXL:function-documentation}}\index{runXL (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/function_runXL:_CPPv25runXLR6vectorI6stringE}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/function_runXL:necsim_setup_8h_1ac712ff5a067a5d07f3b4c3dc6e5bfad1}}\pysiglinewithargsret{void \sphinxcode{}\sphinxbfcode{runXL}}{vector\textless{}string\textgreater{} \&\sphinxstyleemphasis{comargs}}{}%
\pysigstopmultiline
Sets up the command-line arguments for default very large scale parameters. 

This is intended for testing purposes only. \begin{description}
\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{comargs}: a vector of command-line arguments for putting the parameters into. 

\end{itemize}

\end{description}


\end{fulllineitems}



\subsection{Function set\_log\_function}
\label{\detokenize{api/function_set_log_function:function-set-log-function}}\label{\detokenize{api/function_set_log_function::doc}}\label{\detokenize{api/function_set_log_function:id1}}\begin{itemize}
\item {} 
Defined in {\hyperref[\detokenize{api/file_PyLogging.h:file-pylogging-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File PyLogging.h}}}}

\end{itemize}


\subsubsection{Function Documentation}
\label{\detokenize{api/function_set_log_function:function-documentation}}\index{set\_log\_function (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/function_set_log_function:_CPPv216set_log_functionP8PyObjectP8PyObject}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/function_set_log_function:necsim_py_logging_8h_1a097ab5db9e7a680d4bbb69d4208d26b2}}\pysiglinewithargsret{PyObject *\sphinxcode{}\sphinxbfcode{set\_log\_function}}{PyObject *\sphinxstyleemphasis{dummy}, PyObject *\sphinxstyleemphasis{args}}{}%
\pysigstopmultiline
Sets the logging function to the provided specification. 

\begin{description}
\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{dummy}: the dummy object 

\item {} 
\sphinxcode{args}: the args provided (should be one callable logging function) 

\end{itemize}

\end{description}


\end{fulllineitems}



\subsection{Function set\_logger}
\label{\detokenize{api/function_set_logger:id1}}\label{\detokenize{api/function_set_logger::doc}}\label{\detokenize{api/function_set_logger:function-set-logger}}\begin{itemize}
\item {} 
Defined in {\hyperref[\detokenize{api/file_PyLogging.h:file-pylogging-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File PyLogging.h}}}}

\end{itemize}


\subsubsection{Function Documentation}
\label{\detokenize{api/function_set_logger:function-documentation}}\index{set\_logger (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/function_set_logger:_CPPv210set_loggerP8PyObjectP8PyObject}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{api/function_set_logger:necsim_py_logging_8h_1aacf1c4b75e0c736bc8947f45ef904694}}\pysiglinewithargsret{PyObject *\sphinxcode{}\sphinxbfcode{set\_logger}}{PyObject *\sphinxstyleemphasis{self}, PyObject *\sphinxstyleemphasis{args}}{}%
\pysigstopmultiline
Sets the logger to the inputted object Saves the logger in loggingmodule. 

\begin{description}
\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{self}: required for python objects 

\item {} 
\sphinxcode{args}: the logger to link for error outputting 

\end{itemize}

\end{description}


\end{fulllineitems}



\subsection{Function test\_mean\_dispersal}
\label{\detokenize{api/function_test_mean_dispersal::doc}}\label{\detokenize{api/function_test_mean_dispersal:function-test-mean-dispersal}}\label{\detokenize{api/function_test_mean_dispersal:id1}}\begin{itemize}
\item {} 
Defined in {\hyperref[\detokenize{api/file_dispersalmodule.cpp:file-dispersalmodule-cpp}]{\sphinxcrossref{\DUrole{std,std-ref}{File dispersalmodule.cpp}}}}

\end{itemize}


\subsubsection{Function Documentation}
\label{\detokenize{api/function_test_mean_dispersal:function-documentation}}
\begin{sphinxadmonition}{warning}{Warning:}
doxygenfunction: Cannot find function \sphinxquotedblleft{}test\_mean\_dispersal\sphinxquotedblright{} in doxygen xml output for project \sphinxquotedblleft{}necsim\sphinxquotedblright{} from directory: ../docs/necsim\_doc/xml/
\end{sphinxadmonition}


\subsection{Function test\_mean\_distance\_travelled}
\label{\detokenize{api/function_test_mean_distance_travelled::doc}}\label{\detokenize{api/function_test_mean_distance_travelled:function-test-mean-distance-travelled}}\label{\detokenize{api/function_test_mean_distance_travelled:id1}}\begin{itemize}
\item {} 
Defined in {\hyperref[\detokenize{api/file_dispersalmodule.cpp:file-dispersalmodule-cpp}]{\sphinxcrossref{\DUrole{std,std-ref}{File dispersalmodule.cpp}}}}

\end{itemize}


\subsubsection{Function Documentation}
\label{\detokenize{api/function_test_mean_distance_travelled:function-documentation}}
\begin{sphinxadmonition}{warning}{Warning:}
doxygenfunction: Cannot find function \sphinxquotedblleft{}test\_mean\_distance\_travelled\sphinxquotedblright{} in doxygen xml output for project \sphinxquotedblleft{}necsim\sphinxquotedblright{} from directory: ../docs/necsim\_doc/xml/
\end{sphinxadmonition}


\subsection{Function write\_log}
\label{\detokenize{api/function_write_log:function-write-log}}\label{\detokenize{api/function_write_log::doc}}\label{\detokenize{api/function_write_log:id1}}\begin{itemize}
\item {} 
Defined in {\hyperref[\detokenize{api/file_PyLogging.h:file-pylogging-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File PyLogging.h}}}}

\end{itemize}


\subsubsection{Function Documentation}
\label{\detokenize{api/function_write_log:function-documentation}}
\begin{sphinxadmonition}{warning}{Warning:}
doxygenfunction: Unable to resolve multiple matches for function \sphinxquotedblleft{}write\_log\sphinxquotedblright{} with arguments () in doxygen xml output for project \sphinxquotedblleft{}necsim\sphinxquotedblright{} from directory: ../docs/necsim\_doc/xml/.
Potential matches:


\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZhy{}} \PYG{n}{void} \PYG{n}{write\PYGZus{}log}\PYG{p}{(}\PYG{n+nb}{int}\PYG{p}{,} \PYG{n}{char} \PYG{o}{*}\PYG{p}{)}
\PYG{o}{\PYGZhy{}} \PYG{n}{void} \PYG{n}{write\PYGZus{}log}\PYG{p}{(}\PYG{n+nb}{int}\PYG{p}{,} \PYG{n}{string}\PYG{p}{)}
\end{sphinxVerbatim}
\end{sphinxadmonition}


\subsection{Function writeCritical}
\label{\detokenize{api/function_writeCritical:function-writecritical}}\label{\detokenize{api/function_writeCritical::doc}}\label{\detokenize{api/function_writeCritical:id1}}\begin{itemize}
\item {} 
Defined in {\hyperref[\detokenize{api/file_PyLogging.cpp:file-pylogging-cpp}]{\sphinxcrossref{\DUrole{std,std-ref}{File PyLogging.cpp}}}}

\end{itemize}


\subsubsection{Function Documentation}
\label{\detokenize{api/function_writeCritical:function-documentation}}
\begin{sphinxadmonition}{warning}{Warning:}
doxygenfunction: Cannot find function \sphinxquotedblleft{}writeCritical\sphinxquotedblright{} in doxygen xml output for project \sphinxquotedblleft{}necsim\sphinxquotedblright{} from directory: ../docs/necsim\_doc/xml/
\end{sphinxadmonition}


\subsection{Function writeError}
\label{\detokenize{api/function_writeError:id1}}\label{\detokenize{api/function_writeError::doc}}\label{\detokenize{api/function_writeError:function-writeerror}}\begin{itemize}
\item {} 
Defined in {\hyperref[\detokenize{api/file_PyLogging.cpp:file-pylogging-cpp}]{\sphinxcrossref{\DUrole{std,std-ref}{File PyLogging.cpp}}}}

\end{itemize}


\subsubsection{Function Documentation}
\label{\detokenize{api/function_writeError:function-documentation}}
\begin{sphinxadmonition}{warning}{Warning:}
doxygenfunction: Cannot find function \sphinxquotedblleft{}writeError\sphinxquotedblright{} in doxygen xml output for project \sphinxquotedblleft{}necsim\sphinxquotedblright{} from directory: ../docs/necsim\_doc/xml/
\end{sphinxadmonition}


\subsection{Function writeInfo}
\label{\detokenize{api/function_writeInfo:function-writeinfo}}\label{\detokenize{api/function_writeInfo::doc}}\label{\detokenize{api/function_writeInfo:id1}}\begin{itemize}
\item {} 
Defined in {\hyperref[\detokenize{api/file_PyLogging.cpp:file-pylogging-cpp}]{\sphinxcrossref{\DUrole{std,std-ref}{File PyLogging.cpp}}}}

\end{itemize}


\subsubsection{Function Documentation}
\label{\detokenize{api/function_writeInfo:function-documentation}}
\begin{sphinxadmonition}{warning}{Warning:}
doxygenfunction: Cannot find function \sphinxquotedblleft{}writeInfo\sphinxquotedblright{} in doxygen xml output for project \sphinxquotedblleft{}necsim\sphinxquotedblright{} from directory: ../docs/necsim\_doc/xml/
\end{sphinxadmonition}


\subsection{Function writeWarning}
\label{\detokenize{api/function_writeWarning:id1}}\label{\detokenize{api/function_writeWarning::doc}}\label{\detokenize{api/function_writeWarning:function-writewarning}}\begin{itemize}
\item {} 
Defined in {\hyperref[\detokenize{api/file_PyLogging.cpp:file-pylogging-cpp}]{\sphinxcrossref{\DUrole{std,std-ref}{File PyLogging.cpp}}}}

\end{itemize}


\subsubsection{Function Documentation}
\label{\detokenize{api/function_writeWarning:function-documentation}}
\begin{sphinxadmonition}{warning}{Warning:}
doxygenfunction: Cannot find function \sphinxquotedblleft{}writeWarning\sphinxquotedblright{} in doxygen xml output for project \sphinxquotedblleft{}necsim\sphinxquotedblright{} from directory: ../docs/necsim\_doc/xml/
\end{sphinxadmonition}


\subsection{Variable \_state}
\label{\detokenize{api/variable__state::doc}}\label{\detokenize{api/variable__state:variable-state}}\label{\detokenize{api/variable__state:id1}}\begin{itemize}
\item {} 
Defined in {\hyperref[\detokenize{api/file_necsimmodule.h:file-necsimmodule-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File necsimmodule.h}}}}

\end{itemize}


\subsubsection{Variable Documentation}
\label{\detokenize{api/variable__state:variable-documentation}}\index{\_state (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/variable__state:_CPPv26_state}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{api/variable__state:necsimapplyspecmodule_8h_1adb5f4e26ed08b1f5e57d51f452404533}}\sphinxstrong{struct} {\hyperref[\detokenize{api/struct_module_state:_CPPv212module_state}]{\sphinxcrossref{module\_state}}} \sphinxcode{}\sphinxbfcode{\_state}}%
\pysigstopmultiline
\end{fulllineitems}



\subsection{Variable ApplySpeciationError}
\label{\detokenize{api/variable_ApplySpeciationError:variable-applyspeciationerror}}\label{\detokenize{api/variable_ApplySpeciationError::doc}}\label{\detokenize{api/variable_ApplySpeciationError:id1}}\begin{itemize}
\item {} 
Defined in {\hyperref[\detokenize{api/file_applyspecmodule.h:file-applyspecmodule-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File applyspecmodule.h}}}}

\end{itemize}


\subsubsection{Variable Documentation}
\label{\detokenize{api/variable_ApplySpeciationError:variable-documentation}}\index{ApplySpeciationError (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/variable_ApplySpeciationError:_CPPv220ApplySpeciationError}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{api/variable_ApplySpeciationError:necsimapplyspecmodule_8h_1aa956653a8596099ba0b2477d665986af}}PyObject *\sphinxcode{}\sphinxbfcode{ApplySpeciationError}}%
\pysigstopmultiline
A python error container for all dispersal run-time errors. 

\end{fulllineitems}



\subsection{Variable ApplySpecMethods}
\label{\detokenize{api/variable_ApplySpecMethods::doc}}\label{\detokenize{api/variable_ApplySpecMethods:variable-applyspecmethods}}\label{\detokenize{api/variable_ApplySpecMethods:id1}}\begin{itemize}
\item {} 
Defined in {\hyperref[\detokenize{api/file_applyspecmodule.cpp:file-applyspecmodule-cpp}]{\sphinxcrossref{\DUrole{std,std-ref}{File applyspecmodule.cpp}}}}

\end{itemize}


\subsubsection{Variable Documentation}
\label{\detokenize{api/variable_ApplySpecMethods:variable-documentation}}
\begin{sphinxadmonition}{warning}{Warning:}
doxygenvariable: Cannot find variable \sphinxquotedblleft{}ApplySpecMethods\sphinxquotedblright{} in doxygen xml output for project \sphinxquotedblleft{}necsim\sphinxquotedblright{} from directory: ../docs/necsim\_doc/xml/
\end{sphinxadmonition}


\subsection{Variable call\_logging}
\label{\detokenize{api/variable_call_logging:variable-call-logging}}\label{\detokenize{api/variable_call_logging::doc}}\label{\detokenize{api/variable_call_logging:id1}}\begin{itemize}
\item {} 
Defined in {\hyperref[\detokenize{api/file_PyLogging.h:file-pylogging-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File PyLogging.h}}}}

\end{itemize}


\subsubsection{Variable Documentation}
\label{\detokenize{api/variable_call_logging:variable-documentation}}\index{call\_logging (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/variable_call_logging:_CPPv212call_logging}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{api/variable_call_logging:necsim_py_logging_8h_1ae0822a71c8f520b72eee4e308ca8f3d5}}PyObject *\sphinxcode{}\sphinxbfcode{call\_logging} = nullptr}%
\pysigstopmultiline
\end{fulllineitems}



\subsection{Variable DispersalError}
\label{\detokenize{api/variable_DispersalError:variable-dispersalerror}}\label{\detokenize{api/variable_DispersalError::doc}}\label{\detokenize{api/variable_DispersalError:id1}}\begin{itemize}
\item {} 
Defined in {\hyperref[\detokenize{api/file_dispersalmodule.h:file-dispersalmodule-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File dispersalmodule.h}}}}

\end{itemize}


\subsubsection{Variable Documentation}
\label{\detokenize{api/variable_DispersalError:variable-documentation}}\index{DispersalError (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/variable_DispersalError:_CPPv214DispersalError}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{api/variable_DispersalError:necsimdispersalmodule_8h_1a7e2e32e4fb16f13333729815a5194f89}}PyObject *\sphinxcode{}\sphinxbfcode{DispersalError}}%
\pysigstopmultiline
A python error container for all dispersal run-time errors. 

\end{fulllineitems}



\subsection{Variable DispersalMethods}
\label{\detokenize{api/variable_DispersalMethods:id1}}\label{\detokenize{api/variable_DispersalMethods::doc}}\label{\detokenize{api/variable_DispersalMethods:variable-dispersalmethods}}\begin{itemize}
\item {} 
Defined in {\hyperref[\detokenize{api/file_dispersalmodule.cpp:file-dispersalmodule-cpp}]{\sphinxcrossref{\DUrole{std,std-ref}{File dispersalmodule.cpp}}}}

\end{itemize}


\subsubsection{Variable Documentation}
\label{\detokenize{api/variable_DispersalMethods:variable-documentation}}
\begin{sphinxadmonition}{warning}{Warning:}
doxygenvariable: Cannot find variable \sphinxquotedblleft{}DispersalMethods\sphinxquotedblright{} in doxygen xml output for project \sphinxquotedblleft{}necsim\sphinxquotedblright{} from directory: ../docs/necsim\_doc/xml/
\end{sphinxadmonition}


\subsection{Variable gdal\_data\_sizes}
\label{\detokenize{api/variable_gdal_data_sizes:variable-gdal-data-sizes}}\label{\detokenize{api/variable_gdal_data_sizes::doc}}\label{\detokenize{api/variable_gdal_data_sizes:id1}}\begin{itemize}
\item {} 
Defined in {\hyperref[\detokenize{api/file_necsim_Matrix.h:file-necsim-matrix-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File Matrix.h}}}}

\end{itemize}


\subsubsection{Variable Documentation}
\label{\detokenize{api/variable_gdal_data_sizes:variable-documentation}}\index{gdal\_data\_sizes (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/variable_gdal_data_sizes:_CPPv215gdal_data_sizes}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{api/variable_gdal_data_sizes:necsim_matrix_8h_1a02aa962cfe49d9cc0a492fd0aaf74bd9}}\sphinxstrong{const} int \sphinxcode{}\sphinxbfcode{gdal\_data\_sizes}{[}{]} = \{0, 8, 16, 16, 32, 32, 32, 64\}}%
\pysigstopmultiline
\end{fulllineitems}



\subsection{Variable gstate}
\label{\detokenize{api/variable_gstate:variable-gstate}}\label{\detokenize{api/variable_gstate::doc}}\label{\detokenize{api/variable_gstate:id1}}\begin{itemize}
\item {} 
Defined in {\hyperref[\detokenize{api/file_PyLogging.h:file-pylogging-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File PyLogging.h}}}}

\end{itemize}


\subsubsection{Variable Documentation}
\label{\detokenize{api/variable_gstate:variable-documentation}}\index{gstate (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/variable_gstate:_CPPv26gstate}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{api/variable_gstate:necsim_py_logging_8h_1ae2ea2c066f7e65f192b08f50adb4ad1d}}PyGILState\_STATE \sphinxcode{}\sphinxbfcode{gstate}}%
\pysigstopmultiline
\end{fulllineitems}



\subsection{Variable log\_name}
\label{\detokenize{api/variable_log_name::doc}}\label{\detokenize{api/variable_log_name:variable-log-name}}\label{\detokenize{api/variable_log_name:id1}}\begin{itemize}
\item {} 
Defined in {\hyperref[\detokenize{api/file_necsim_Setup.h:file-necsim-setup-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File Setup.h}}}}

\end{itemize}


\subsubsection{Variable Documentation}
\label{\detokenize{api/variable_log_name:variable-documentation}}\index{log\_name (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/variable_log_name:_CPPv28log_name}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{api/variable_log_name:necsim_setup_8h_1a2b3e7c0f4a5a17a01a5157ab01e59a60}}string \sphinxcode{}\sphinxbfcode{log\_name}}%
\pysigstopmultiline
\end{fulllineitems}



\subsection{Variable log\_set}
\label{\detokenize{api/variable_log_set:variable-log-set}}\label{\detokenize{api/variable_log_set::doc}}\label{\detokenize{api/variable_log_set:id1}}\begin{itemize}
\item {} 
Defined in {\hyperref[\detokenize{api/file_PyLogging.h:file-pylogging-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File PyLogging.h}}}}

\end{itemize}


\subsubsection{Variable Documentation}
\label{\detokenize{api/variable_log_set:variable-documentation}}\index{log\_set (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/variable_log_set:_CPPv27log_set}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{api/variable_log_set:necsim_py_logging_8h_1a304b2017ec52852821aced29cb2fe2ed}}bool \sphinxcode{}\sphinxbfcode{log\_set}}%
\pysigstopmultiline
\end{fulllineitems}



\subsection{Variable logger}
\label{\detokenize{api/variable_logger:variable-logger}}\label{\detokenize{api/variable_logger::doc}}\label{\detokenize{api/variable_logger:id1}}\begin{itemize}
\item {} 
Defined in {\hyperref[\detokenize{api/file_PyLogging.h:file-pylogging-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File PyLogging.h}}}}

\end{itemize}


\subsubsection{Variable Documentation}
\label{\detokenize{api/variable_logger:variable-documentation}}\index{logger (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/variable_logger:_CPPv26logger}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{api/variable_logger:necsim_py_logging_8h_1ac5c8cc1b55a6d2753d51817bd568aada}}PyObject *\sphinxcode{}\sphinxbfcode{logger}}%
\pysigstopmultiline
A python object container for the logger object for outputting using python's logging module. 

\end{fulllineitems}



\subsection{Variable logger\_set}
\label{\detokenize{api/variable_logger_set:variable-logger-set}}\label{\detokenize{api/variable_logger_set::doc}}\label{\detokenize{api/variable_logger_set:id1}}\begin{itemize}
\item {} 
Defined in {\hyperref[\detokenize{api/file_PyLogging.h:file-pylogging-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File PyLogging.h}}}}

\end{itemize}


\subsubsection{Variable Documentation}
\label{\detokenize{api/variable_logger_set:variable-documentation}}\index{logger\_set (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/variable_logger_set:_CPPv210logger_set}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{api/variable_logger_set:necsim_py_logging_8h_1a08d9fbb3de64e2e37d485a6fb7c413c9}}bool \sphinxcode{}\sphinxbfcode{logger\_set}}%
\pysigstopmultiline
\end{fulllineitems}



\subsection{Variable loggingmodule}
\label{\detokenize{api/variable_loggingmodule::doc}}\label{\detokenize{api/variable_loggingmodule:variable-loggingmodule}}\label{\detokenize{api/variable_loggingmodule:id1}}\begin{itemize}
\item {} 
Defined in {\hyperref[\detokenize{api/file_PyLogging.h:file-pylogging-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File PyLogging.h}}}}

\end{itemize}


\subsubsection{Variable Documentation}
\label{\detokenize{api/variable_loggingmodule:variable-documentation}}\index{loggingmodule (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/variable_loggingmodule:_CPPv213loggingmodule}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{api/variable_loggingmodule:necsim_py_logging_8h_1ae269920327ad06583db48e0bb122605e}}PyObject *\sphinxcode{}\sphinxbfcode{loggingmodule}}%
\pysigstopmultiline
\end{fulllineitems}



\subsection{Variable NECSimError}
\label{\detokenize{api/variable_NECSimError:variable-necsimerror}}\label{\detokenize{api/variable_NECSimError::doc}}\label{\detokenize{api/variable_NECSimError:id1}}\begin{itemize}
\item {} 
Defined in {\hyperref[\detokenize{api/file_necsimmodule.h:file-necsimmodule-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File necsimmodule.h}}}}

\end{itemize}


\subsubsection{Variable Documentation}
\label{\detokenize{api/variable_NECSimError:variable-documentation}}\index{NECSimError (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/variable_NECSimError:_CPPv211NECSimError}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{api/variable_NECSimError:necsimnecsimmodule_8h_1a4375f2eae9ebb387616fb1d8a5f83f77}}PyObject *\sphinxcode{}\sphinxbfcode{NECSimError}}%
\pysigstopmultiline
A python error container for all run-time errors. 

\end{fulllineitems}



\subsection{Variable NECSimMethods}
\label{\detokenize{api/variable_NECSimMethods:variable-necsimmethods}}\label{\detokenize{api/variable_NECSimMethods::doc}}\label{\detokenize{api/variable_NECSimMethods:id1}}\begin{itemize}
\item {} 
Defined in {\hyperref[\detokenize{api/file_necsimmodule.cpp:file-necsimmodule-cpp}]{\sphinxcrossref{\DUrole{std,std-ref}{File necsimmodule.cpp}}}}

\end{itemize}


\subsubsection{Variable Documentation}
\label{\detokenize{api/variable_NECSimMethods:variable-documentation}}
\begin{sphinxadmonition}{warning}{Warning:}
doxygenvariable: Cannot find variable \sphinxquotedblleft{}NECSimMethods\sphinxquotedblright{} in doxygen xml output for project \sphinxquotedblleft{}necsim\sphinxquotedblright{} from directory: ../docs/necsim\_doc/xml/
\end{sphinxadmonition}


\subsection{Variable saved\_stdout}
\label{\detokenize{api/variable_saved_stdout:id1}}\label{\detokenize{api/variable_saved_stdout::doc}}\label{\detokenize{api/variable_saved_stdout:variable-saved-stdout}}\begin{itemize}
\item {} 
Defined in {\hyperref[\detokenize{api/file_necsim_Setup.h:file-necsim-setup-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File Setup.h}}}}

\end{itemize}


\subsubsection{Variable Documentation}
\label{\detokenize{api/variable_saved_stdout:variable-documentation}}\index{saved\_stdout (C++ member)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/variable_saved_stdout:_CPPv212saved_stdout}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{api/variable_saved_stdout:necsim_setup_8h_1abc860612bcc3ce0f446f60f8314195d0}}int \sphinxcode{}\sphinxbfcode{saved\_stdout}}%
\pysigstopmultiline
\end{fulllineitems}



\subsection{Define AM}
\label{\detokenize{api/define_AM::doc}}\label{\detokenize{api/define_AM:define-am}}\label{\detokenize{api/define_AM:id1}}\begin{itemize}
\item {} 
Defined in {\hyperref[\detokenize{api/file_necsim_NRrand.h:file-necsim-nrrand-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File NRrand.h}}}}

\end{itemize}


\subsubsection{Define Documentation}
\label{\detokenize{api/define_AM:define-documentation}}\index{AM (C macro)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/define_AM:c.AM}}\pysigline{\phantomsection\label{\detokenize{api/define_AM:necsim_n_rrand_8h_1ad301e6a88b1c01108f4867f2ea6f683c}}\sphinxbfcode{AM}}
\end{fulllineitems}



\subsection{Define APPLY\_SPEC\_IMPORT}
\label{\detokenize{api/define_APPLY_SPEC_IMPORT:define-apply-spec-import}}\label{\detokenize{api/define_APPLY_SPEC_IMPORT::doc}}\label{\detokenize{api/define_APPLY_SPEC_IMPORT:id1}}\begin{itemize}
\item {} 
Defined in {\hyperref[\detokenize{api/file_applyspecmodule.h:file-applyspecmodule-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File applyspecmodule.h}}}}

\end{itemize}


\subsubsection{Define Documentation}
\label{\detokenize{api/define_APPLY_SPEC_IMPORT:define-documentation}}\index{APPLY\_SPEC\_IMPORT (C macro)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/define_APPLY_SPEC_IMPORT:c.APPLY_SPEC_IMPORT}}\pysigline{\phantomsection\label{\detokenize{api/define_APPLY_SPEC_IMPORT:necsimapplyspecmodule_8h_1acb552735854a92b373d5c9c832ca1219}}\sphinxbfcode{APPLY\_SPEC\_IMPORT}}
\end{fulllineitems}



\subsection{Define DISPERSAL\_IMPORT}
\label{\detokenize{api/define_DISPERSAL_IMPORT::doc}}\label{\detokenize{api/define_DISPERSAL_IMPORT:define-dispersal-import}}\label{\detokenize{api/define_DISPERSAL_IMPORT:id1}}\begin{itemize}
\item {} 
Defined in {\hyperref[\detokenize{api/file_dispersalmodule.h:file-dispersalmodule-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File dispersalmodule.h}}}}

\end{itemize}


\subsubsection{Define Documentation}
\label{\detokenize{api/define_DISPERSAL_IMPORT:define-documentation}}\index{DISPERSAL\_IMPORT (C macro)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/define_DISPERSAL_IMPORT:c.DISPERSAL_IMPORT}}\pysigline{\phantomsection\label{\detokenize{api/define_DISPERSAL_IMPORT:necsimdispersalmodule_8h_1a11c30aa5aed370a0aa25f1f735501459}}\sphinxbfcode{DISPERSAL\_IMPORT}}
\end{fulllineitems}



\subsection{Define EPS}
\label{\detokenize{api/define_EPS::doc}}\label{\detokenize{api/define_EPS:define-eps}}\label{\detokenize{api/define_EPS:id1}}\begin{itemize}
\item {} 
Defined in {\hyperref[\detokenize{api/file_necsim_NRrand.h:file-necsim-nrrand-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File NRrand.h}}}}

\end{itemize}


\subsubsection{Define Documentation}
\label{\detokenize{api/define_EPS:define-documentation}}\index{EPS (C macro)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/define_EPS:c.EPS}}\pysigline{\phantomsection\label{\detokenize{api/define_EPS:necsim_n_rrand_8h_1a6ebf6899d6c1c8b7b9d09be872c05aae}}\sphinxbfcode{EPS}}
\end{fulllineitems}



\subsection{Define GETSTATE}
\label{\detokenize{api/define_GETSTATE::doc}}\label{\detokenize{api/define_GETSTATE:define-getstate}}\label{\detokenize{api/define_GETSTATE:id1}}\begin{itemize}
\item {} 
Defined in {\hyperref[\detokenize{api/file_necsimmodule.h:file-necsimmodule-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File necsimmodule.h}}}}

\end{itemize}


\subsubsection{Define Documentation}
\label{\detokenize{api/define_GETSTATE:define-documentation}}\index{GETSTATE (C macro)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/define_GETSTATE:c.GETSTATE}}\pysiglinewithargsret{\phantomsection\label{\detokenize{api/define_GETSTATE:necsimapplyspecmodule_8h_1a6d1f389576656b98c42c69f7cf1d55c0}}\sphinxbfcode{GETSTATE}}{m}{}
\end{fulllineitems}



\subsection{Define IA1}
\label{\detokenize{api/define_IA1:define-ia1}}\label{\detokenize{api/define_IA1::doc}}\label{\detokenize{api/define_IA1:id1}}\begin{itemize}
\item {} 
Defined in {\hyperref[\detokenize{api/file_necsim_NRrand.h:file-necsim-nrrand-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File NRrand.h}}}}

\end{itemize}


\subsubsection{Define Documentation}
\label{\detokenize{api/define_IA1:define-documentation}}\index{IA1 (C macro)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/define_IA1:c.IA1}}\pysigline{\phantomsection\label{\detokenize{api/define_IA1:necsim_n_rrand_8h_1a6ef2749dca39c605c3d033f788afe6e3}}\sphinxbfcode{IA1}}
\end{fulllineitems}



\subsection{Define IA2}
\label{\detokenize{api/define_IA2:define-ia2}}\label{\detokenize{api/define_IA2::doc}}\label{\detokenize{api/define_IA2:id1}}\begin{itemize}
\item {} 
Defined in {\hyperref[\detokenize{api/file_necsim_NRrand.h:file-necsim-nrrand-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File NRrand.h}}}}

\end{itemize}


\subsubsection{Define Documentation}
\label{\detokenize{api/define_IA2:define-documentation}}\index{IA2 (C macro)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/define_IA2:c.IA2}}\pysigline{\phantomsection\label{\detokenize{api/define_IA2:necsim_n_rrand_8h_1a372a58d7e9e25912fd79e7afaa06cc7a}}\sphinxbfcode{IA2}}
\end{fulllineitems}



\subsection{Define IM1}
\label{\detokenize{api/define_IM1:id1}}\label{\detokenize{api/define_IM1::doc}}\label{\detokenize{api/define_IM1:define-im1}}\begin{itemize}
\item {} 
Defined in {\hyperref[\detokenize{api/file_necsim_NRrand.h:file-necsim-nrrand-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File NRrand.h}}}}

\end{itemize}


\subsubsection{Define Documentation}
\label{\detokenize{api/define_IM1:define-documentation}}\index{IM1 (C macro)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/define_IM1:c.IM1}}\pysigline{\phantomsection\label{\detokenize{api/define_IM1:necsim_n_rrand_8h_1a78325bdf48423acef7c012567628b391}}\sphinxbfcode{IM1}}
\end{fulllineitems}



\subsection{Define IM2}
\label{\detokenize{api/define_IM2:define-im2}}\label{\detokenize{api/define_IM2::doc}}\label{\detokenize{api/define_IM2:id1}}\begin{itemize}
\item {} 
Defined in {\hyperref[\detokenize{api/file_necsim_NRrand.h:file-necsim-nrrand-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File NRrand.h}}}}

\end{itemize}


\subsubsection{Define Documentation}
\label{\detokenize{api/define_IM2:define-documentation}}\index{IM2 (C macro)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/define_IM2:c.IM2}}\pysigline{\phantomsection\label{\detokenize{api/define_IM2:necsim_n_rrand_8h_1ad8c519de7e5de4ae35344ddcf21fd062}}\sphinxbfcode{IM2}}
\end{fulllineitems}



\subsection{Define IMM1}
\label{\detokenize{api/define_IMM1:define-imm1}}\label{\detokenize{api/define_IMM1::doc}}\label{\detokenize{api/define_IMM1:id1}}\begin{itemize}
\item {} 
Defined in {\hyperref[\detokenize{api/file_necsim_NRrand.h:file-necsim-nrrand-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File NRrand.h}}}}

\end{itemize}


\subsubsection{Define Documentation}
\label{\detokenize{api/define_IMM1:define-documentation}}\index{IMM1 (C macro)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/define_IMM1:c.IMM1}}\pysigline{\phantomsection\label{\detokenize{api/define_IMM1:necsim_n_rrand_8h_1a87a6e0054f9d827c979c43aa0d5e621a}}\sphinxbfcode{IMM1}}
\end{fulllineitems}



\subsection{Define INITERROR}
\label{\detokenize{api/define_INITERROR:define-initerror}}\label{\detokenize{api/define_INITERROR::doc}}\label{\detokenize{api/define_INITERROR:id1}}\begin{itemize}
\item {} 
Defined in {\hyperref[\detokenize{api/file_necsimmodule.h:file-necsimmodule-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File necsimmodule.h}}}}

\end{itemize}


\subsubsection{Define Documentation}
\label{\detokenize{api/define_INITERROR:define-documentation}}\index{INITERROR (C macro)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/define_INITERROR:c.INITERROR}}\pysigline{\phantomsection\label{\detokenize{api/define_INITERROR:necsimapplyspecmodule_8h_1a3d94077229c2876134769daeeb28fa8a}}\sphinxbfcode{INITERROR}}
\end{fulllineitems}



\subsection{Define IQ1}
\label{\detokenize{api/define_IQ1:define-iq1}}\label{\detokenize{api/define_IQ1::doc}}\label{\detokenize{api/define_IQ1:id1}}\begin{itemize}
\item {} 
Defined in {\hyperref[\detokenize{api/file_necsim_NRrand.h:file-necsim-nrrand-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File NRrand.h}}}}

\end{itemize}


\subsubsection{Define Documentation}
\label{\detokenize{api/define_IQ1:define-documentation}}\index{IQ1 (C macro)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/define_IQ1:c.IQ1}}\pysigline{\phantomsection\label{\detokenize{api/define_IQ1:necsim_n_rrand_8h_1a9afa86ff22da69bda72fe271ae71ad46}}\sphinxbfcode{IQ1}}
\end{fulllineitems}



\subsection{Define IQ2}
\label{\detokenize{api/define_IQ2:define-iq2}}\label{\detokenize{api/define_IQ2::doc}}\label{\detokenize{api/define_IQ2:id1}}\begin{itemize}
\item {} 
Defined in {\hyperref[\detokenize{api/file_necsim_NRrand.h:file-necsim-nrrand-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File NRrand.h}}}}

\end{itemize}


\subsubsection{Define Documentation}
\label{\detokenize{api/define_IQ2:define-documentation}}\index{IQ2 (C macro)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/define_IQ2:c.IQ2}}\pysigline{\phantomsection\label{\detokenize{api/define_IQ2:necsim_n_rrand_8h_1abae040385946a6acdf5e10d2efd86f3d}}\sphinxbfcode{IQ2}}
\end{fulllineitems}



\subsection{Define IR1}
\label{\detokenize{api/define_IR1:define-ir1}}\label{\detokenize{api/define_IR1::doc}}\label{\detokenize{api/define_IR1:id1}}\begin{itemize}
\item {} 
Defined in {\hyperref[\detokenize{api/file_necsim_NRrand.h:file-necsim-nrrand-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File NRrand.h}}}}

\end{itemize}


\subsubsection{Define Documentation}
\label{\detokenize{api/define_IR1:define-documentation}}\index{IR1 (C macro)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/define_IR1:c.IR1}}\pysigline{\phantomsection\label{\detokenize{api/define_IR1:necsim_n_rrand_8h_1a7b2b32709f9770a283701ffcf3723497}}\sphinxbfcode{IR1}}
\end{fulllineitems}



\subsection{Define IR2}
\label{\detokenize{api/define_IR2:define-ir2}}\label{\detokenize{api/define_IR2::doc}}\label{\detokenize{api/define_IR2:id1}}\begin{itemize}
\item {} 
Defined in {\hyperref[\detokenize{api/file_necsim_NRrand.h:file-necsim-nrrand-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File NRrand.h}}}}

\end{itemize}


\subsubsection{Define Documentation}
\label{\detokenize{api/define_IR2:define-documentation}}\index{IR2 (C macro)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/define_IR2:c.IR2}}\pysigline{\phantomsection\label{\detokenize{api/define_IR2:necsim_n_rrand_8h_1a5a08e4f5cb3582e623cc14a6c92d48de}}\sphinxbfcode{IR2}}
\end{fulllineitems}



\subsection{Define LOGNAME\_FORMAT}
\label{\detokenize{api/define_LOGNAME_FORMAT::doc}}\label{\detokenize{api/define_LOGNAME_FORMAT:define-logname-format}}\label{\detokenize{api/define_LOGNAME_FORMAT:id1}}\begin{itemize}
\item {} 
Defined in {\hyperref[\detokenize{api/file_necsim_LogFile.h:file-necsim-logfile-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File LogFile.h}}}}

\end{itemize}


\subsubsection{Define Documentation}
\label{\detokenize{api/define_LOGNAME_FORMAT:define-documentation}}\index{LOGNAME\_FORMAT (C macro)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/define_LOGNAME_FORMAT:c.LOGNAME_FORMAT}}\pysigline{\phantomsection\label{\detokenize{api/define_LOGNAME_FORMAT:necsim_log_file_8h_1a4406b927e99aa582e1a919e579f88dcd}}\sphinxbfcode{LOGNAME\_FORMAT}}
\end{fulllineitems}



\subsection{Define NDIV}
\label{\detokenize{api/define_NDIV::doc}}\label{\detokenize{api/define_NDIV:define-ndiv}}\label{\detokenize{api/define_NDIV:id1}}\begin{itemize}
\item {} 
Defined in {\hyperref[\detokenize{api/file_necsim_NRrand.h:file-necsim-nrrand-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File NRrand.h}}}}

\end{itemize}


\subsubsection{Define Documentation}
\label{\detokenize{api/define_NDIV:define-documentation}}\index{NDIV (C macro)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/define_NDIV:c.NDIV}}\pysigline{\phantomsection\label{\detokenize{api/define_NDIV:necsim_n_rrand_8h_1a62339d74dd5d9d00480e1a288cf88fe8}}\sphinxbfcode{NDIV}}
\end{fulllineitems}



\subsection{Define NTAB}
\label{\detokenize{api/define_NTAB:define-ntab}}\label{\detokenize{api/define_NTAB::doc}}\label{\detokenize{api/define_NTAB:id1}}\begin{itemize}
\item {} 
Defined in {\hyperref[\detokenize{api/file_necsim_NRrand.h:file-necsim-nrrand-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File NRrand.h}}}}

\end{itemize}


\subsubsection{Define Documentation}
\label{\detokenize{api/define_NTAB:define-documentation}}\index{NTAB (C macro)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/define_NTAB:c.NTAB}}\pysigline{\phantomsection\label{\detokenize{api/define_NTAB:necsim_n_rrand_8h_1a0e93cfb2d62849853fd34957ba6e6fdc}}\sphinxbfcode{NTAB}}
\end{fulllineitems}



\subsection{Define null}
\label{\detokenize{api/define_null:define-null}}\label{\detokenize{api/define_null::doc}}\label{\detokenize{api/define_null:id1}}\begin{itemize}
\item {} 
Defined in {\hyperref[\detokenize{api/file_necsim_Matrix.h:file-necsim-matrix-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File Matrix.h}}}}

\end{itemize}


\subsubsection{Define Documentation}
\label{\detokenize{api/define_null:define-documentation}}\index{null (C macro)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/define_null:c.null}}\pysigline{\phantomsection\label{\detokenize{api/define_null:necsim_matrix_8h_1ac97b8ee753e4405397a42ad5799b0f9e}}\sphinxbfcode{null}}
\end{fulllineitems}



\subsection{Define PYTHON\_COMPILE}
\label{\detokenize{api/define_PYTHON_COMPILE::doc}}\label{\detokenize{api/define_PYTHON_COMPILE:define-python-compile}}\label{\detokenize{api/define_PYTHON_COMPILE:id1}}\begin{itemize}
\item {} 
Defined in {\hyperref[\detokenize{api/file_PyLogging.cpp:file-pylogging-cpp}]{\sphinxcrossref{\DUrole{std,std-ref}{File PyLogging.cpp}}}}

\end{itemize}


\subsubsection{Define Documentation}
\label{\detokenize{api/define_PYTHON_COMPILE:define-documentation}}\index{PYTHON\_COMPILE (C macro)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/define_PYTHON_COMPILE:c.PYTHON_COMPILE}}\pysigline{\phantomsection\label{\detokenize{api/define_PYTHON_COMPILE:necsim_simulate_dispersal_8h_1a9302692bd9a9cf56478cbae301f04d53}}\sphinxbfcode{PYTHON\_COMPILE}}
\end{fulllineitems}



\subsection{Define RNMX}
\label{\detokenize{api/define_RNMX::doc}}\label{\detokenize{api/define_RNMX:define-rnmx}}\label{\detokenize{api/define_RNMX:id1}}\begin{itemize}
\item {} 
Defined in {\hyperref[\detokenize{api/file_necsim_NRrand.h:file-necsim-nrrand-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File NRrand.h}}}}

\end{itemize}


\subsubsection{Define Documentation}
\label{\detokenize{api/define_RNMX:define-documentation}}\index{RNMX (C macro)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/define_RNMX:c.RNMX}}\pysigline{\phantomsection\label{\detokenize{api/define_RNMX:necsim_n_rrand_8h_1aa7436c9270ffb06f8c1eae8d2e605cec}}\sphinxbfcode{RNMX}}
\end{fulllineitems}



\subsection{Define SPECIATIONCOUNTER\_PROTRACTEDSPATIALTREE\_H}
\label{\detokenize{api/define_SPECIATIONCOUNTER_PROTRACTEDSPATIALTREE_H:id1}}\label{\detokenize{api/define_SPECIATIONCOUNTER_PROTRACTEDSPATIALTREE_H::doc}}\label{\detokenize{api/define_SPECIATIONCOUNTER_PROTRACTEDSPATIALTREE_H:define-speciationcounter-protractedspatialtree-h}}\begin{itemize}
\item {} 
Defined in {\hyperref[\detokenize{api/file_necsim_ProtractedSpatialTree.h:file-necsim-protractedspatialtree-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File ProtractedSpatialTree.h}}}}

\end{itemize}


\subsubsection{Define Documentation}
\label{\detokenize{api/define_SPECIATIONCOUNTER_PROTRACTEDSPATIALTREE_H:define-documentation}}\index{SPECIATIONCOUNTER\_PROTRACTEDSPATIALTREE\_H (C macro)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/define_SPECIATIONCOUNTER_PROTRACTEDSPATIALTREE_H:c.SPECIATIONCOUNTER_PROTRACTEDSPATIALTREE_H}}\pysigline{\phantomsection\label{\detokenize{api/define_SPECIATIONCOUNTER_PROTRACTEDSPATIALTREE_H:necsim_protracted_spatial_tree_8h_1ad9838a1c6978b0ac757bae17a32a4d0d}}\sphinxbfcode{SPECIATIONCOUNTER\_PROTRACTEDSPATIALTREE\_H}}
\end{fulllineitems}



\subsection{Define sql\_ram}
\label{\detokenize{api/define_sql_ram:define-sql-ram}}\label{\detokenize{api/define_sql_ram::doc}}\label{\detokenize{api/define_sql_ram:id1}}\begin{itemize}
\item {} 
Defined in {\hyperref[\detokenize{api/file_necsim_Tree.h:file-necsim-tree-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File Tree.h}}}}

\end{itemize}


\subsubsection{Define Documentation}
\label{\detokenize{api/define_sql_ram:define-documentation}}\index{sql\_ram (C macro)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/define_sql_ram:c.sql_ram}}\pysigline{\phantomsection\label{\detokenize{api/define_sql_ram:necsimgroup___d_e_f_i_n_e_s_1ga063c2e626b5c0dcf65522d05574349a6}}\sphinxbfcode{sql\_ram}}
Macro for using the fast-cpp-csv-parser from Ben Strasser (available from \sphinxurl{https://github.com/ben-strasser/fast-cpp-csv-parser}). This enables much faster csv reading, but can cause problems on systems where this module is not fully tested.

Macro to compile using RAM for storage of the active SQL database. Without this, the database will be written directly to disc (which is slower, but an option if RAM requirements get too huge). For HPC systems, it is recommended to use this option as write speeds are generally fast and large simulations don't have a linear increase in the SQL database size (at least in RAM). 

\end{fulllineitems}



\subsection{Directory necsim}
\label{\detokenize{api/dir_necsim::doc}}\label{\detokenize{api/dir_necsim:directory-necsim}}\label{\detokenize{api/dir_necsim:id1}}

\subsubsection{Files}
\label{\detokenize{api/dir_necsim:files}}\begin{itemize}
\item {} 
{\hyperref[\detokenize{api/file_necsim_Community.cpp:file-necsim-community-cpp}]{\sphinxcrossref{\DUrole{std,std-ref}{File Community.cpp}}}}

\item {} 
{\hyperref[\detokenize{api/file_necsim_Community.h:file-necsim-community-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File Community.h}}}}

\item {} 
{\hyperref[\detokenize{api/file_necsim_ConfigFileParser.cpp:file-necsim-configfileparser-cpp}]{\sphinxcrossref{\DUrole{std,std-ref}{File ConfigFileParser.cpp}}}}

\item {} 
{\hyperref[\detokenize{api/file_necsim_ConfigFileParser.h:file-necsim-configfileparser-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File ConfigFileParser.h}}}}

\item {} 
{\hyperref[\detokenize{api/file_necsim_CustomExceptions.h:file-necsim-customexceptions-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File CustomExceptions.h}}}}

\item {} 
{\hyperref[\detokenize{api/file_necsim_DataMask.cpp:file-necsim-datamask-cpp}]{\sphinxcrossref{\DUrole{std,std-ref}{File DataMask.cpp}}}}

\item {} 
{\hyperref[\detokenize{api/file_necsim_DataMask.h:file-necsim-datamask-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File DataMask.h}}}}

\item {} 
{\hyperref[\detokenize{api/file_necsim_DataPoint.cpp:file-necsim-datapoint-cpp}]{\sphinxcrossref{\DUrole{std,std-ref}{File DataPoint.cpp}}}}

\item {} 
{\hyperref[\detokenize{api/file_necsim_DataPoint.h:file-necsim-datapoint-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File DataPoint.h}}}}

\item {} 
{\hyperref[\detokenize{api/file_necsim_DispersalCoordinator.cpp:file-necsim-dispersalcoordinator-cpp}]{\sphinxcrossref{\DUrole{std,std-ref}{File DispersalCoordinator.cpp}}}}

\item {} 
{\hyperref[\detokenize{api/file_necsim_DispersalCoordinator.h:file-necsim-dispersalcoordinator-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File DispersalCoordinator.h}}}}

\item {} 
{\hyperref[\detokenize{api/file_necsim_Filesystem.cpp:file-necsim-filesystem-cpp}]{\sphinxcrossref{\DUrole{std,std-ref}{File Filesystem.cpp}}}}

\item {} 
{\hyperref[\detokenize{api/file_necsim_Filesystem.h:file-necsim-filesystem-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File Filesystem.h}}}}

\item {} 
{\hyperref[\detokenize{api/file_necsim_LicenseHeader.h:file-necsim-licenseheader-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File LicenseHeader.h}}}}

\item {} 
{\hyperref[\detokenize{api/file_necsim_LogFile.cpp:file-necsim-logfile-cpp}]{\sphinxcrossref{\DUrole{std,std-ref}{File LogFile.cpp}}}}

\item {} 
{\hyperref[\detokenize{api/file_necsim_LogFile.h:file-necsim-logfile-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File LogFile.h}}}}

\item {} 
{\hyperref[\detokenize{api/file_necsim_Logging.cpp:file-necsim-logging-cpp}]{\sphinxcrossref{\DUrole{std,std-ref}{File Logging.cpp}}}}

\item {} 
{\hyperref[\detokenize{api/file_necsim_Logging.h:file-necsim-logging-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File Logging.h}}}}

\item {} 
{\hyperref[\detokenize{api/file_necsim_main.cpp:file-necsim-main-cpp}]{\sphinxcrossref{\DUrole{std,std-ref}{File main.cpp}}}}

\item {} 
{\hyperref[\detokenize{api/file_necsim_Map.cpp:file-necsim-map-cpp}]{\sphinxcrossref{\DUrole{std,std-ref}{File Map.cpp}}}}

\item {} 
{\hyperref[\detokenize{api/file_necsim_Map.h:file-necsim-map-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File Map.h}}}}

\item {} 
{\hyperref[\detokenize{api/file_necsim_Matrix.h:file-necsim-matrix-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File Matrix.h}}}}

\item {} 
{\hyperref[\detokenize{api/file_necsim_Metacommunity.cpp:file-necsim-metacommunity-cpp}]{\sphinxcrossref{\DUrole{std,std-ref}{File Metacommunity.cpp}}}}

\item {} 
{\hyperref[\detokenize{api/file_necsim_Metacommunity.h:file-necsim-metacommunity-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File Metacommunity.h}}}}

\item {} 
{\hyperref[\detokenize{api/file_necsim_NRrand.h:file-necsim-nrrand-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File NRrand.h}}}}

\item {} 
{\hyperref[\detokenize{api/file_necsim_ProtractedSpatialTree.h:file-necsim-protractedspatialtree-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File ProtractedSpatialTree.h}}}}

\item {} 
{\hyperref[\detokenize{api/file_necsim_ProtractedTree.cpp:file-necsim-protractedtree-cpp}]{\sphinxcrossref{\DUrole{std,std-ref}{File ProtractedTree.cpp}}}}

\item {} 
{\hyperref[\detokenize{api/file_necsim_ProtractedTree.h:file-necsim-protractedtree-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File ProtractedTree.h}}}}

\item {} 
{\hyperref[\detokenize{api/file_necsim_README.md:file-necsim-readme-md}]{\sphinxcrossref{\DUrole{std,std-ref}{File README.md}}}}

\item {} 
{\hyperref[\detokenize{api/file_necsim_ReproductionMap.cpp:file-necsim-reproductionmap-cpp}]{\sphinxcrossref{\DUrole{std,std-ref}{File ReproductionMap.cpp}}}}

\item {} 
{\hyperref[\detokenize{api/file_necsim_ReproductionMap.h:file-necsim-reproductionmap-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File ReproductionMap.h}}}}

\item {} 
{\hyperref[\detokenize{api/file_necsim_Setup.cpp:file-necsim-setup-cpp}]{\sphinxcrossref{\DUrole{std,std-ref}{File Setup.cpp}}}}

\item {} 
{\hyperref[\detokenize{api/file_necsim_Setup.h:file-necsim-setup-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File Setup.h}}}}

\item {} 
{\hyperref[\detokenize{api/file_necsim_SimParameters.h:file-necsim-simparameters-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File SimParameters.h}}}}

\item {} 
{\hyperref[\detokenize{api/file_necsim_SimulateDispersal.cpp:file-necsim-simulatedispersal-cpp}]{\sphinxcrossref{\DUrole{std,std-ref}{File SimulateDispersal.cpp}}}}

\item {} 
{\hyperref[\detokenize{api/file_necsim_SimulateDispersal.h:file-necsim-simulatedispersal-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File SimulateDispersal.h}}}}

\item {} 
{\hyperref[\detokenize{api/file_necsim_SimulationTemplates.h:file-necsim-simulationtemplates-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File SimulationTemplates.h}}}}

\item {} 
{\hyperref[\detokenize{api/file_necsim_SpatialTree.cpp:file-necsim-spatialtree-cpp}]{\sphinxcrossref{\DUrole{std,std-ref}{File SpatialTree.cpp}}}}

\item {} 
{\hyperref[\detokenize{api/file_necsim_SpatialTree.h:file-necsim-spatialtree-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File SpatialTree.h}}}}

\item {} 
{\hyperref[\detokenize{api/file_necsim_SpeciationCommands.cpp:file-necsim-speciationcommands-cpp}]{\sphinxcrossref{\DUrole{std,std-ref}{File SpeciationCommands.cpp}}}}

\item {} 
{\hyperref[\detokenize{api/file_necsim_SpeciationCommands.h:file-necsim-speciationcommands-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File SpeciationCommands.h}}}}

\item {} 
{\hyperref[\detokenize{api/file_necsim_SpeciesList.cpp:file-necsim-specieslist-cpp}]{\sphinxcrossref{\DUrole{std,std-ref}{File SpeciesList.cpp}}}}

\item {} 
{\hyperref[\detokenize{api/file_necsim_SpeciesList.h:file-necsim-specieslist-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File SpeciesList.h}}}}

\item {} 
{\hyperref[\detokenize{api/file_necsim_SpecSimParameters.h:file-necsim-specsimparameters-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File SpecSimParameters.h}}}}

\item {} 
{\hyperref[\detokenize{api/file_necsim_Step.h:file-necsim-step-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File Step.h}}}}

\item {} 
{\hyperref[\detokenize{api/file_necsim_Tree.cpp:file-necsim-tree-cpp}]{\sphinxcrossref{\DUrole{std,std-ref}{File Tree.cpp}}}}

\item {} 
{\hyperref[\detokenize{api/file_necsim_Tree.h:file-necsim-tree-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File Tree.h}}}}

\item {} 
{\hyperref[\detokenize{api/file_necsim_TreeNode.cpp:file-necsim-treenode-cpp}]{\sphinxcrossref{\DUrole{std,std-ref}{File TreeNode.cpp}}}}

\item {} 
{\hyperref[\detokenize{api/file_necsim_TreeNode.h:file-necsim-treenode-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File TreeNode.h}}}}

\end{itemize}


\subsection{File applyspecmodule.cpp}
\label{\detokenize{api/file_applyspecmodule.cpp:file-applyspecmodule-cpp}}\label{\detokenize{api/file_applyspecmodule.cpp::doc}}\label{\detokenize{api/file_applyspecmodule.cpp:id1}}
Contains the module for python integration for additional applying speciation rates after a simulation is completed.

\begin{sphinxShadowBox}
\sphinxstyletopictitle{Contents}
\begin{itemize}
\item {} 
\phantomsection\label{\detokenize{api/file_applyspecmodule.cpp:id2}}{\hyperref[\detokenize{api/file_applyspecmodule.cpp:definition-applyspecmodule-cpp}]{\sphinxcrossref{Definition (\sphinxcode{applyspecmodule.cpp})}}}

\item {} 
\phantomsection\label{\detokenize{api/file_applyspecmodule.cpp:id3}}{\hyperref[\detokenize{api/file_applyspecmodule.cpp:detailed-description}]{\sphinxcrossref{Detailed Description}}}

\item {} 
\phantomsection\label{\detokenize{api/file_applyspecmodule.cpp:id4}}{\hyperref[\detokenize{api/file_applyspecmodule.cpp:includes}]{\sphinxcrossref{Includes}}}

\item {} 
\phantomsection\label{\detokenize{api/file_applyspecmodule.cpp:id5}}{\hyperref[\detokenize{api/file_applyspecmodule.cpp:functions}]{\sphinxcrossref{Functions}}}

\item {} 
\phantomsection\label{\detokenize{api/file_applyspecmodule.cpp:id6}}{\hyperref[\detokenize{api/file_applyspecmodule.cpp:defines}]{\sphinxcrossref{Defines}}}

\item {} 
\phantomsection\label{\detokenize{api/file_applyspecmodule.cpp:id7}}{\hyperref[\detokenize{api/file_applyspecmodule.cpp:variables}]{\sphinxcrossref{Variables}}}

\end{itemize}
\end{sphinxShadowBox}


\subsubsection{Definition (\sphinxstyleliteralintitle{applyspecmodule.cpp})}
\label{\detokenize{api/file_applyspecmodule.cpp:definition-applyspecmodule-cpp}}

\paragraph{Program Listing for File applyspecmodule.cpp}
\label{\detokenize{api/program_listing_file_applyspecmodule.cpp:program-listing-file-applyspecmodule-cpp}}\label{\detokenize{api/program_listing_file_applyspecmodule.cpp::doc}}\label{\detokenize{api/program_listing_file_applyspecmodule.cpp:program-listing-for-file-applyspecmodule-cpp}}\begin{itemize}
\item {} 
Return to documentation for {\hyperref[\detokenize{api/file_applyspecmodule.cpp:file-applyspecmodule-cpp}]{\sphinxcrossref{\DUrole{std,std-ref}{File applyspecmodule.cpp}}}}

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{// This file is part of NECSim project which is released under BSD\PYGZhy{}3 license.}
\PYG{c+c1}{// See file **LICENSE.txt** or visit https://opensource.org/licenses/BSD\PYGZhy{}3\PYGZhy{}Clause) for full license details.}

\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifndef PYTHON\PYGZus{}COMPILE}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define PYTHON\PYGZus{}COMPILE}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}Python.h\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}vector\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}string\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}cstring\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}unistd.h\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}signal.h\PYGZgt{}}

\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZdq{}applyspecmodule.h\PYGZdq{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZdq{}PyLogging.h\PYGZdq{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZdq{}necsim/Community.h\PYGZdq{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZdq{}necsim/Metacommunity.h\PYGZdq{}}

\PYG{n}{PyObject} \PYG{o}{*} \PYG{n}{loggingmodule}\PYG{p}{;}
\PYG{n}{PyGILState\PYGZus{}STATE} \PYG{n}{gstate}\PYG{p}{;}
\PYG{k+kt}{bool} \PYG{n}{log\PYGZus{}set} \PYG{o}{=} \PYG{n+nb}{false}\PYG{p}{;}
\PYG{k+kt}{bool} \PYG{n}{logger\PYGZus{}set} \PYG{o}{=} \PYG{n+nb}{false}\PYG{p}{;}
\PYG{n}{PyObject} \PYG{o}{*} \PYG{n}{logger}\PYG{p}{;}

\PYG{k}{template}\PYG{o}{\PYGZlt{}}\PYG{k}{class} \PYG{n+nc}{T}\PYG{o}{\PYGZgt{}} \PYG{k+kt}{void} \PYG{n}{createCommunity}\PYG{p}{(}\PYG{n}{string} \PYG{n}{database\PYGZus{}str}\PYG{p}{,} \PYG{k+kt}{bool} \PYG{n}{use\PYGZus{}spatial}\PYG{p}{,} \PYG{n}{string} \PYG{n}{sample\PYGZus{}file}\PYG{p}{,}
                                       \PYG{n}{string} \PYG{n}{time\PYGZus{}config\PYGZus{}file}\PYG{p}{,} \PYG{n}{string} \PYG{n}{fragment\PYGZus{}file}\PYG{p}{,} \PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{double}\PYG{o}{\PYGZgt{}} \PYG{o}{\PYGZam{}} \PYG{n}{speciation\PYGZus{}rates}\PYG{p}{,}
                                       \PYG{k+kt}{double} \PYG{n}{min\PYGZus{}speciation\PYGZus{}gen}\PYG{p}{,} \PYG{k+kt}{double} \PYG{n}{max\PYGZus{}speciation\PYGZus{}gen}\PYG{p}{,}
                                       \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{metacommunity\PYGZus{}size}\PYG{p}{,} \PYG{k+kt}{double} \PYG{n}{metacommunity\PYGZus{}speciation\PYGZus{}rate}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{n}{T} \PYG{n}{community}\PYG{p}{;}
    \PYG{n}{SpecSimParameters} \PYG{n}{speciation\PYGZus{}parameters}\PYG{p}{;}
    \PYG{n}{speciation\PYGZus{}parameters}\PYG{p}{.}\PYG{n}{setup}\PYG{p}{(}\PYG{n}{database\PYGZus{}str}\PYG{p}{,} \PYG{n}{use\PYGZus{}spatial}\PYG{p}{,} \PYG{n}{sample\PYGZus{}file}\PYG{p}{,} \PYG{n}{time\PYGZus{}config\PYGZus{}file}\PYG{p}{,}
                                \PYG{n}{fragment\PYGZus{}file}\PYG{p}{,} \PYG{n}{speciation\PYGZus{}rates}\PYG{p}{,} \PYG{n}{min\PYGZus{}speciation\PYGZus{}gen}\PYG{p}{,} \PYG{n}{max\PYGZus{}speciation\PYGZus{}gen}\PYG{p}{,}
                                \PYG{n}{metacommunity\PYGZus{}size}\PYG{p}{,} \PYG{n}{metacommunity\PYGZus{}speciation\PYGZus{}rate}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{community}\PYG{p}{.}\PYG{n}{apply}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{speciation\PYGZus{}parameters}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k}{static} \PYG{n}{PyObject} \PYG{o}{*} \PYG{n}{apply}\PYG{p}{(}\PYG{n}{PyObject} \PYG{o}{*} \PYG{n}{self}\PYG{p}{,} \PYG{n}{PyObject} \PYG{o}{*} \PYG{n}{args}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k+kt}{char} \PYG{o}{*} \PYG{n}{database}\PYG{p}{;}
    \PYG{k+kt}{int} \PYG{n}{record\PYGZus{}spatial}\PYG{p}{;}
    \PYG{k+kt}{char} \PYG{o}{*} \PYG{n}{sample\PYGZus{}file}\PYG{p}{;}
    \PYG{k+kt}{char} \PYG{o}{*} \PYG{n}{time\PYGZus{}config\PYGZus{}file}\PYG{p}{;}
    \PYG{k+kt}{char} \PYG{o}{*} \PYG{n}{fragment\PYGZus{}file}\PYG{p}{;}
    \PYG{k+kt}{double} \PYG{n}{min\PYGZus{}spec\PYGZus{}gen} \PYG{o}{=} \PYG{l+m+mf}{0.0}\PYG{p}{;}
    \PYG{k+kt}{double} \PYG{n}{max\PYGZus{}spec\PYGZus{}gen} \PYG{o}{=} \PYG{l+m+mf}{0.0}\PYG{p}{;}
    \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{metacommunity\PYGZus{}size} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
    \PYG{k+kt}{double} \PYG{n}{metacommunity\PYGZus{}speciation\PYGZus{}rate} \PYG{o}{=} \PYG{l+m+mf}{0.0}\PYG{p}{;}
    \PYG{n}{PyObject} \PYG{o}{*}\PYG{n}{pList}\PYG{p}{;}
    \PYG{n}{PyObject} \PYG{o}{*}\PYG{n}{pItem}\PYG{p}{;}
    \PYG{n}{Py\PYGZus{}ssize\PYGZus{}t} \PYG{n}{n}\PYG{p}{;}
    \PYG{k}{if} \PYG{p}{(}\PYG{o}{!}\PYG{n}{PyArg\PYGZus{}ParseTuple}\PYG{p}{(}\PYG{n}{args}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{sisssO!\textbar{}ddkd}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{database}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{record\PYGZus{}spatial}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{sample\PYGZus{}file}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{time\PYGZus{}config\PYGZus{}file}\PYG{p}{,}
                          \PYG{o}{\PYGZam{}}\PYG{n}{fragment\PYGZus{}file}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{PyList\PYGZus{}Type}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{pList}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{min\PYGZus{}spec\PYGZus{}gen}\PYG{p}{,}
                          \PYG{o}{\PYGZam{}}\PYG{n}{max\PYGZus{}spec\PYGZus{}gen}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{metacommunity\PYGZus{}size}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{metacommunity\PYGZus{}speciation\PYGZus{}rate}\PYG{p}{)}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{return} \PYG{n+nb}{NULL}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifdef DEBUG}
    \PYG{k}{if}\PYG{p}{(}\PYG{n}{metacommunity\PYGZus{}size} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{writeLog}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Metacommunity size not set.}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{else}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{writeLog}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Metacommunity size: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{+} \PYG{n}{to\PYGZus{}string}\PYG{p}{(}\PYG{n}{metacommunity\PYGZus{}size}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif }\PYG{c+c1}{// DEBUG}
    \PYG{k}{if}\PYG{p}{(}\PYG{n}{max\PYGZus{}spec\PYGZus{}gen} \PYG{o}{\PYGZgt{}} \PYG{l+m+mf}{0.0} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{n}{min\PYGZus{}spec\PYGZus{}gen} \PYG{o}{\PYGZgt{}}\PYG{o}{=} \PYG{n}{max\PYGZus{}spec\PYGZus{}gen}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{PyErr\PYGZus{}SetString}\PYG{p}{(}\PYG{n}{PyExc\PYGZus{}TypeError}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Minimum protracted speciation generation must be less than maximum.}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{else}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{min\PYGZus{}spec\PYGZus{}gen}\PYG{o}{=}\PYG{l+m+mf}{0.0}\PYG{p}{;}
        \PYG{n}{max\PYGZus{}spec\PYGZus{}gen}\PYG{o}{=}\PYG{l+m+mf}{0.0}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{c+c1}{// Convert all our variables to the relevant form}
    \PYG{n}{string} \PYG{n}{database\PYGZus{}str} \PYG{o}{=} \PYG{n}{database}\PYG{p}{;}
    \PYG{k+kt}{bool} \PYG{n}{use\PYGZus{}spatial} \PYG{o}{=} \PYG{n}{record\PYGZus{}spatial}\PYG{p}{;}
    \PYG{n}{string} \PYG{n}{sample\PYGZus{}file\PYGZus{}str} \PYG{o}{=} \PYG{n}{sample\PYGZus{}file}\PYG{p}{;}
    \PYG{n}{string} \PYG{n}{time\PYGZus{}config\PYGZus{}file\PYGZus{}str} \PYG{o}{=} \PYG{n}{time\PYGZus{}config\PYGZus{}file}\PYG{p}{;}
    \PYG{n}{string} \PYG{n}{fragment\PYGZus{}file\PYGZus{}str} \PYG{o}{=} \PYG{n}{fragment\PYGZus{}file}\PYG{p}{;}

    \PYG{n}{n} \PYG{o}{=} \PYG{n}{PyList\PYGZus{}Size}\PYG{p}{(}\PYG{n}{pList}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{double}\PYG{o}{\PYGZgt{}} \PYG{n}{spec\PYGZus{}rates}\PYG{p}{;}
    \PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i}\PYG{o}{\PYGZlt{}}\PYG{n}{n}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{pItem} \PYG{o}{=} \PYG{n}{PyList\PYGZus{}GetItem}\PYG{p}{(}\PYG{n}{pList}\PYG{p}{,} \PYG{n}{i}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{if}\PYG{p}{(}\PYG{o}{!}\PYG{n}{PyFloat\PYGZus{}Check}\PYG{p}{(}\PYG{n}{pItem}\PYG{p}{)}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{PyErr\PYGZus{}SetString}\PYG{p}{(}\PYG{n}{PyExc\PYGZus{}TypeError}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Speciation rates must be floats.}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
            \PYG{k}{return} \PYG{n+nb}{NULL}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{k+kt}{double} \PYG{n}{tmpspec} \PYG{o}{=} \PYG{n}{PyFloat\PYGZus{}AS\PYGZus{}DOUBLE}\PYG{p}{(}\PYG{n}{pItem}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{spec\PYGZus{}rates}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{n}{tmpspec}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{c+c1}{// Now run the actual simulation}
    \PYG{k}{try}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{metacommunity\PYGZus{}size} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{Py\PYGZus{}INCREF}\PYG{p}{(}\PYG{n}{logger}\PYG{p}{)}\PYG{p}{;}
            \PYG{n}{createCommunity}\PYG{o}{\PYGZlt{}}\PYG{n}{Community}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{n}{database\PYGZus{}str}\PYG{p}{,} \PYG{n}{use\PYGZus{}spatial}\PYG{p}{,} \PYG{n}{sample\PYGZus{}file\PYGZus{}str}\PYG{p}{,} \PYG{n}{time\PYGZus{}config\PYGZus{}file\PYGZus{}str}\PYG{p}{,}
                                       \PYG{n}{fragment\PYGZus{}file\PYGZus{}str}\PYG{p}{,} \PYG{n}{spec\PYGZus{}rates}\PYG{p}{,} \PYG{n}{min\PYGZus{}spec\PYGZus{}gen}\PYG{p}{,} \PYG{n}{max\PYGZus{}spec\PYGZus{}gen}\PYG{p}{,}
                                       \PYG{n}{metacommunity\PYGZus{}size}\PYG{p}{,} \PYG{n}{metacommunity\PYGZus{}speciation\PYGZus{}rate}\PYG{p}{)}\PYG{p}{;}
            \PYG{n}{Py\PYGZus{}DECREF}\PYG{p}{(}\PYG{n}{logger}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{else}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{Py\PYGZus{}INCREF}\PYG{p}{(}\PYG{n}{logger}\PYG{p}{)}\PYG{p}{;}
            \PYG{n}{createCommunity}\PYG{o}{\PYGZlt{}}\PYG{n}{Metacommunity}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{n}{database\PYGZus{}str}\PYG{p}{,} \PYG{n}{use\PYGZus{}spatial}\PYG{p}{,} \PYG{n}{sample\PYGZus{}file\PYGZus{}str}\PYG{p}{,} \PYG{n}{time\PYGZus{}config\PYGZus{}file\PYGZus{}str}\PYG{p}{,}
                                       \PYG{n}{fragment\PYGZus{}file\PYGZus{}str}\PYG{p}{,} \PYG{n}{spec\PYGZus{}rates}\PYG{p}{,} \PYG{n}{min\PYGZus{}spec\PYGZus{}gen}\PYG{p}{,} \PYG{n}{max\PYGZus{}spec\PYGZus{}gen}\PYG{p}{,}
                                       \PYG{n}{metacommunity\PYGZus{}size}\PYG{p}{,} \PYG{n}{metacommunity\PYGZus{}speciation\PYGZus{}rate}\PYG{p}{)}\PYG{p}{;}
            \PYG{n}{Py\PYGZus{}DECREF}\PYG{p}{(}\PYG{n}{logger}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{catch}\PYG{p}{(}\PYG{n}{exception} \PYG{o}{\PYGZam{}}\PYG{n}{e}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{Py\PYGZus{}DECREF}\PYG{p}{(}\PYG{n}{logger}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{PyErr\PYGZus{}SetString}\PYG{p}{(}\PYG{n}{ApplySpeciationError}\PYG{p}{,} \PYG{n}{e}\PYG{p}{.}\PYG{n}{what}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{return} \PYG{n+nb}{NULL}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{n}{Py\PYGZus{}RETURN\PYGZus{}NONE}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k}{static} \PYG{n}{PyMethodDef} \PYG{n}{ApplySpecMethods}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=}
\PYG{p}{\PYGZob{}}
    \PYG{p}{\PYGZob{}}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{apply}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{apply}\PYG{p}{,} \PYG{n}{METH\PYGZus{}VARARGS}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Applies the new speciation rate(s) to the coalescence tree.}\PYG{l+s}{\PYGZdq{}}\PYG{p}{\PYGZcb{}}\PYG{p}{,}
    \PYG{p}{\PYGZob{}}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{set\PYGZus{}log\PYGZus{}function}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{set\PYGZus{}log\PYGZus{}function}\PYG{p}{,} \PYG{n}{METH\PYGZus{}VARARGS}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{calls logging}\PYG{l+s}{\PYGZdq{}}\PYG{p}{\PYGZcb{}}\PYG{p}{,}
    \PYG{p}{\PYGZob{}}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{set\PYGZus{}logger}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{set\PYGZus{}logger}\PYG{p}{,} \PYG{n}{METH\PYGZus{}VARARGS}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Sets the logger to use}\PYG{l+s}{\PYGZdq{}}\PYG{p}{\PYGZcb{}}\PYG{p}{,}
    \PYG{p}{\PYGZob{}}\PYG{n+nb}{NULL}\PYG{p}{,} \PYG{n+nb}{NULL}\PYG{p}{,} \PYG{l+m+mi}{0} \PYG{p}{,} \PYG{n+nb}{NULL}\PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}

\PYG{c+c1}{// Conditional compilation for python \PYGZgt{}= 3.0 (changed how python integration worked)}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{if PY\PYGZus{}MAJOR\PYGZus{}VERSION \PYGZgt{}= 3}
\PYG{k}{static} \PYG{k+kt}{int} \PYG{n+nf}{applyspec\PYGZus{}traverse}\PYG{p}{(}\PYG{n}{PyObject} \PYG{o}{*}\PYG{n}{m}\PYG{p}{,} \PYG{n}{visitproc} \PYG{n}{visit}\PYG{p}{,} \PYG{k+kt}{void} \PYG{o}{*}\PYG{n}{arg}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{n}{Py\PYGZus{}VISIT}\PYG{p}{(}\PYG{n}{GETSTATE}\PYG{p}{(}\PYG{n}{m}\PYG{p}{)}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{error}\PYG{p}{)}\PYG{p}{;}
    \PYG{k}{return} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k}{static} \PYG{k+kt}{int} \PYG{n+nf}{applyspec\PYGZus{}clear}\PYG{p}{(}\PYG{n}{PyObject} \PYG{o}{*}\PYG{n}{m}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{n}{Py\PYGZus{}CLEAR}\PYG{p}{(}\PYG{n}{GETSTATE}\PYG{p}{(}\PYG{n}{m}\PYG{p}{)}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{error}\PYG{p}{)}\PYG{p}{;}
    \PYG{k}{return} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif}


\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{if PY\PYGZus{}MAJOR\PYGZus{}VERSION \PYGZgt{}= 3}
\PYG{k}{static} \PYG{k}{struct} \PYG{n}{PyModuleDef} \PYG{n}{moduledef} \PYG{o}{=}
\PYG{p}{\PYGZob{}}
    \PYG{n}{PyModuleDef\PYGZus{}HEAD\PYGZus{}INIT}\PYG{p}{,}
    \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{applyspecmodule}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}
    \PYG{n+nb}{NULL}\PYG{p}{,}
    \PYG{k}{sizeof}\PYG{p}{(}\PYG{k}{struct} \PYG{n}{module\PYGZus{}state}\PYG{p}{)}\PYG{p}{,}
    \PYG{n}{ApplySpecMethods}\PYG{p}{,}
    \PYG{n+nb}{NULL}\PYG{p}{,}
    \PYG{n}{applyspec\PYGZus{}traverse}\PYG{p}{,}
    \PYG{n}{applyspec\PYGZus{}clear}\PYG{p}{,}
    \PYG{n+nb}{NULL}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}


\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define INITERROR return NULL}

\PYG{n}{PyMODINIT\PYGZus{}FUNC}
\PYG{n+nf}{PyInit\PYGZus{}applyspecmodule}\PYG{p}{(}\PYG{k+kt}{void}\PYG{p}{)}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{else}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define INITERROR return}

\PYG{n}{PyMODINIT\PYGZus{}FUNC}
\PYG{n}{initapplyspecmodule}\PYG{p}{(}\PYG{k+kt}{void}\PYG{p}{)}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif}
\PYG{p}{\PYGZob{}}
    \PYG{n}{PyObject} \PYG{o}{*}\PYG{n}{module}\PYG{p}{;}
    \PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{if PY\PYGZus{}MAJOR\PYGZus{}VERSION\PYGZgt{}=3}
    \PYG{n}{module} \PYG{o}{=} \PYG{n}{PyModule\PYGZus{}Create}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{moduledef}\PYG{p}{)}\PYG{p}{;}
    \PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{else}
    \PYG{n}{module} \PYG{o}{=} \PYG{n}{Py\PYGZus{}InitModule}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{applyspecmodule}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{ApplySpecMethods}\PYG{p}{)}\PYG{p}{;}
    \PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif}
    \PYG{k}{if}\PYG{p}{(}\PYG{n}{module} \PYG{o}{=}\PYG{o}{=} \PYG{n+nb}{NULL}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{INITERROR}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{c+c1}{// Threading support}
    \PYG{k}{if}\PYG{p}{(}\PYG{o}{!}\PYG{n}{PyEval\PYGZus{}ThreadsInitialized}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{PyEval\PYGZus{}InitThreads}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

    \PYG{p}{\PYGZcb{}}
    \PYG{n}{ApplySpeciationError} \PYG{o}{=} \PYG{n}{PyErr\PYGZus{}NewException}\PYG{p}{(}\PYG{p}{(}\PYG{k+kt}{char}\PYG{o}{*}\PYG{p}{)}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{applyspec.Error}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n+nb}{NULL}\PYG{p}{,} \PYG{n+nb}{NULL}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{Py\PYGZus{}INCREF}\PYG{p}{(}\PYG{n}{ApplySpeciationError}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{PyModule\PYGZus{}AddObject}\PYG{p}{(}\PYG{n}{module}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ApplySpecError}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{ApplySpeciationError}\PYG{p}{)}\PYG{p}{;}
    \PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{if PY\PYGZus{}MAJOR\PYGZus{}VERSION \PYGZgt{}= 3}
    \PYG{k}{return} \PYG{n}{module}\PYG{p}{;}
    \PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}


\subsubsection{Detailed Description}
\label{\detokenize{api/file_applyspecmodule.cpp:detailed-description}}
Samuel Thompson
01/08/2017
BSD-3 Licence. Requires command line parameters and generates a data object from them. Contact: \sphinxhref{mailto:samuel.thompson14@imperial.ac.uk}{samuel.thompson14@imperial.ac.uk} or \sphinxhref{mailto:thompsonsed@gmail.com}{thompsonsed@gmail.com}


\subsubsection{Includes}
\label{\detokenize{api/file_applyspecmodule.cpp:includes}}\begin{itemize}
\item {} 
\sphinxcode{/Users/samthompson/Documents/PhD/Code/pycoalescence/pycoalescence/lib/necsim/Community.h}

\item {} 
\sphinxcode{/Users/samthompson/Documents/PhD/Code/pycoalescence/pycoalescence/lib/necsim/ConfigFileParser.h}

\item {} 
\sphinxcode{/Users/samthompson/Documents/PhD/Code/pycoalescence/pycoalescence/lib/necsim/CustomExceptions.h}

\item {} 
\sphinxcode{/Users/samthompson/Documents/PhD/Code/pycoalescence/pycoalescence/lib/necsim/DataMask.h}

\item {} 
\sphinxcode{/Users/samthompson/Documents/PhD/Code/pycoalescence/pycoalescence/lib/necsim/DataPoint.h}

\item {} 
\sphinxcode{/Users/samthompson/Documents/PhD/Code/pycoalescence/pycoalescence/lib/necsim/Filesystem.h}

\item {} 
\sphinxcode{/Users/samthompson/Documents/PhD/Code/pycoalescence/pycoalescence/lib/necsim/LogFile.h}

\item {} 
\sphinxcode{/Users/samthompson/Documents/PhD/Code/pycoalescence/pycoalescence/lib/necsim/Logging.h}

\item {} 
\sphinxcode{/Users/samthompson/Documents/PhD/Code/pycoalescence/pycoalescence/lib/necsim/Matrix.h}

\item {} 
\sphinxcode{/Users/samthompson/Documents/PhD/Code/pycoalescence/pycoalescence/lib/necsim/NRrand.h}

\item {} 
\sphinxcode{/Users/samthompson/Documents/PhD/Code/pycoalescence/pycoalescence/lib/necsim/SimParameters.h}

\item {} 
\sphinxcode{/Users/samthompson/Documents/PhD/Code/pycoalescence/pycoalescence/lib/necsim/SpecSimParameters.h}

\item {} 
\sphinxcode{/Users/samthompson/Documents/PhD/Code/pycoalescence/pycoalescence/lib/necsim/Step.h}

\item {} 
\sphinxcode{/Users/samthompson/Documents/PhD/Code/pycoalescence/pycoalescence/lib/necsim/Tree.h}

\item {} 
\sphinxcode{/Users/samthompson/Documents/PhD/Code/pycoalescence/pycoalescence/lib/necsim/TreeNode.h}

\item {} 
\sphinxcode{PyLogging.h} ({\hyperref[\detokenize{api/file_PyLogging.h:file-pylogging-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File PyLogging.h}}}})

\item {} 
\sphinxcode{Python.h}

\item {} 
\sphinxcode{algorithm}

\item {} 
\sphinxcode{applyspecmodule.h} ({\hyperref[\detokenize{api/file_applyspecmodule.h:file-applyspecmodule-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File applyspecmodule.h}}}})

\item {} 
\sphinxcode{boost/filesystem.hpp}

\item {} 
\sphinxcode{boost/lexical\_cast.hpp}

\item {} 
\sphinxcode{cctype}

\item {} 
\sphinxcode{climits}

\item {} 
\sphinxcode{cmath}

\item {} 
\sphinxcode{cstdint}

\item {} 
\sphinxcode{cstdio}

\item {} 
\sphinxcode{cstdlib}

\item {} 
\sphinxcode{cstring}

\item {} 
\sphinxcode{ctime}

\item {} 
\sphinxcode{fstream}

\item {} 
\sphinxcode{iomanip}

\item {} 
\sphinxcode{iostream}

\item {} 
\sphinxcode{map}

\item {} 
\sphinxcode{necsim/Community.h} ({\hyperref[\detokenize{api/file_necsim_Community.h:file-necsim-community-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File Community.h}}}})

\item {} 
\sphinxcode{necsim/Metacommunity.h} ({\hyperref[\detokenize{api/file_necsim_Metacommunity.h:file-necsim-metacommunity-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File Metacommunity.h}}}})

\item {} 
\sphinxcode{set}

\item {} 
\sphinxcode{signal.h}

\item {} 
\sphinxcode{sqlite3.h}

\item {} 
\sphinxcode{sstream}

\item {} 
\sphinxcode{stdexcept}

\item {} 
\sphinxcode{string}

\item {} 
\sphinxcode{unistd.h}

\item {} 
\sphinxcode{vector}

\end{itemize}


\subsubsection{Functions}
\label{\detokenize{api/file_applyspecmodule.cpp:functions}}\begin{itemize}
\item {} 
{\hyperref[\detokenize{api/function_apply:function-apply}]{\sphinxcrossref{\DUrole{std,std-ref}{Function apply}}}}

\item {} 
{\hyperref[\detokenize{api/function_createCommunity:function-createcommunity}]{\sphinxcrossref{\DUrole{std,std-ref}{Function createCommunity}}}}

\item {} 
{\hyperref[\detokenize{api/function_initapplyspecmodule:function-initapplyspecmodule}]{\sphinxcrossref{\DUrole{std,std-ref}{Function initapplyspecmodule}}}}

\end{itemize}


\subsubsection{Defines}
\label{\detokenize{api/file_applyspecmodule.cpp:defines}}\begin{itemize}
\item {} 
{\hyperref[\detokenize{api/define_INITERROR:define-initerror}]{\sphinxcrossref{\DUrole{std,std-ref}{Define INITERROR}}}}

\item {} 
{\hyperref[\detokenize{api/define_PYTHON_COMPILE:define-python-compile}]{\sphinxcrossref{\DUrole{std,std-ref}{Define PYTHON\_COMPILE}}}}

\end{itemize}


\subsubsection{Variables}
\label{\detokenize{api/file_applyspecmodule.cpp:variables}}\begin{itemize}
\item {} 
{\hyperref[\detokenize{api/variable_ApplySpecMethods:variable-applyspecmethods}]{\sphinxcrossref{\DUrole{std,std-ref}{Variable ApplySpecMethods}}}}

\item {} 
{\hyperref[\detokenize{api/variable_gstate:variable-gstate}]{\sphinxcrossref{\DUrole{std,std-ref}{Variable gstate}}}}

\item {} 
{\hyperref[\detokenize{api/variable_log_set:variable-log-set}]{\sphinxcrossref{\DUrole{std,std-ref}{Variable log\_set}}}}

\item {} 
{\hyperref[\detokenize{api/variable_logger:variable-logger}]{\sphinxcrossref{\DUrole{std,std-ref}{Variable logger}}}}

\item {} 
{\hyperref[\detokenize{api/variable_logger_set:variable-logger-set}]{\sphinxcrossref{\DUrole{std,std-ref}{Variable logger\_set}}}}

\item {} 
{\hyperref[\detokenize{api/variable_loggingmodule:variable-loggingmodule}]{\sphinxcrossref{\DUrole{std,std-ref}{Variable loggingmodule}}}}

\end{itemize}


\subsection{File applyspecmodule.h}
\label{\detokenize{api/file_applyspecmodule.h:file-applyspecmodule-h}}\label{\detokenize{api/file_applyspecmodule.h::doc}}\label{\detokenize{api/file_applyspecmodule.h:id1}}
Contains the module for python integration for additional applying speciation rates after a simulation is completed.

\begin{sphinxShadowBox}
\sphinxstyletopictitle{Contents}
\begin{itemize}
\item {} 
\phantomsection\label{\detokenize{api/file_applyspecmodule.h:id2}}{\hyperref[\detokenize{api/file_applyspecmodule.h:definition-applyspecmodule-h}]{\sphinxcrossref{Definition (\sphinxcode{applyspecmodule.h})}}}

\item {} 
\phantomsection\label{\detokenize{api/file_applyspecmodule.h:id3}}{\hyperref[\detokenize{api/file_applyspecmodule.h:detailed-description}]{\sphinxcrossref{Detailed Description}}}

\item {} 
\phantomsection\label{\detokenize{api/file_applyspecmodule.h:id4}}{\hyperref[\detokenize{api/file_applyspecmodule.h:includes}]{\sphinxcrossref{Includes}}}

\item {} 
\phantomsection\label{\detokenize{api/file_applyspecmodule.h:id5}}{\hyperref[\detokenize{api/file_applyspecmodule.h:included-by}]{\sphinxcrossref{Included By}}}

\item {} 
\phantomsection\label{\detokenize{api/file_applyspecmodule.h:id6}}{\hyperref[\detokenize{api/file_applyspecmodule.h:classes}]{\sphinxcrossref{Classes}}}

\item {} 
\phantomsection\label{\detokenize{api/file_applyspecmodule.h:id7}}{\hyperref[\detokenize{api/file_applyspecmodule.h:functions}]{\sphinxcrossref{Functions}}}

\item {} 
\phantomsection\label{\detokenize{api/file_applyspecmodule.h:id8}}{\hyperref[\detokenize{api/file_applyspecmodule.h:defines}]{\sphinxcrossref{Defines}}}

\item {} 
\phantomsection\label{\detokenize{api/file_applyspecmodule.h:id9}}{\hyperref[\detokenize{api/file_applyspecmodule.h:variables}]{\sphinxcrossref{Variables}}}

\end{itemize}
\end{sphinxShadowBox}


\subsubsection{Definition (\sphinxstyleliteralintitle{applyspecmodule.h})}
\label{\detokenize{api/file_applyspecmodule.h:definition-applyspecmodule-h}}

\paragraph{Program Listing for File applyspecmodule.h}
\label{\detokenize{api/program_listing_file_applyspecmodule.h:program-listing-file-applyspecmodule-h}}\label{\detokenize{api/program_listing_file_applyspecmodule.h:program-listing-for-file-applyspecmodule-h}}\label{\detokenize{api/program_listing_file_applyspecmodule.h::doc}}\begin{itemize}
\item {} 
Return to documentation for {\hyperref[\detokenize{api/file_applyspecmodule.h:file-applyspecmodule-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File applyspecmodule.h}}}}

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{// This file is part of NECSim project which is released under BSD\PYGZhy{}3 license.}
\PYG{c+c1}{// See file **LICENSE.txt** or visit https://opensource.org/licenses/BSD\PYGZhy{}3\PYGZhy{}Clause) for full license details.}

\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}Python.h\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifndef PYTHON\PYGZus{}COMPILE}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define PYTHON\PYGZus{}COMPILE}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}vector\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}string\PYGZgt{}}


\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifndef APPLY\PYGZus{}SPEC\PYGZus{}IMPORT}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define APPLY\PYGZus{}SPEC\PYGZus{}IMPORT}
\PYG{k}{using} \PYG{k}{namespace} \PYG{n}{std}\PYG{p}{;}
\PYG{k}{struct} \PYG{n}{module\PYGZus{}state}
\PYG{p}{\PYGZob{}}
    \PYG{n}{PyObject} \PYG{o}{*}\PYG{n}{error}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}

\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{if PY\PYGZus{}MAJOR\PYGZus{}VERSION \PYGZgt{}= 3}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define GETSTATE(m) ((struct module\PYGZus{}state*)PyModule\PYGZus{}GetState(m))}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{else}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define GETSTATE(m) (\PYGZam{}\PYGZus{}state)}
\PYG{k}{static} \PYG{k}{struct} \PYG{n}{module\PYGZus{}state} \PYG{n}{\PYGZus{}state}\PYG{p}{;}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif}

\PYG{k}{static} \PYG{n}{PyObject} \PYG{o}{*}\PYG{n}{ApplySpeciationError}\PYG{p}{;}

\PYG{c+c1}{// Conditional compilation for python \PYGZgt{}= 3.0 (changed how python integration worked)}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{if PY\PYGZus{}MAJOR\PYGZus{}VERSION \PYGZgt{}= 3}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define INITERROR return NULL}

\PYG{n}{PyMODINIT\PYGZus{}FUNC}
\PYG{n+nf}{PyInit\PYGZus{}applyspecmodule}\PYG{p}{(}\PYG{k+kt}{void}\PYG{p}{)}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{else}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define INITERROR return}

\PYG{n}{PyMODINIT\PYGZus{}FUNC}
\PYG{n}{initapplyspecmodule}\PYG{p}{(}\PYG{k+kt}{void}\PYG{p}{)}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif}
\PYG{p}{;}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif}
\end{sphinxVerbatim}


\subsubsection{Detailed Description}
\label{\detokenize{api/file_applyspecmodule.h:detailed-description}}
Samuel Thompson
01/08/2017
BSD-3 Licence. Requires command line parameters and generates a data object from them. Contact: \sphinxhref{mailto:samuel.thompson14@imperial.ac.uk}{samuel.thompson14@imperial.ac.uk} or \sphinxhref{mailto:thompsonsed@gmail.com}{thompsonsed@gmail.com}


\subsubsection{Includes}
\label{\detokenize{api/file_applyspecmodule.h:includes}}\begin{itemize}
\item {} 
\sphinxcode{Python.h}

\item {} 
\sphinxcode{string}

\item {} 
\sphinxcode{vector}

\end{itemize}


\subsubsection{Included By}
\label{\detokenize{api/file_applyspecmodule.h:included-by}}\begin{itemize}
\item {} 
{\hyperref[\detokenize{api/file_applyspecmodule.cpp:file-applyspecmodule-cpp}]{\sphinxcrossref{\DUrole{std,std-ref}{File applyspecmodule.cpp}}}}

\end{itemize}


\subsubsection{Classes}
\label{\detokenize{api/file_applyspecmodule.h:classes}}\begin{itemize}
\item {} 
{\hyperref[\detokenize{api/struct_module_state:struct-module-state}]{\sphinxcrossref{\DUrole{std,std-ref}{Struct module\_state}}}}

\end{itemize}


\subsubsection{Functions}
\label{\detokenize{api/file_applyspecmodule.h:functions}}\begin{itemize}
\item {} 
{\hyperref[\detokenize{api/function_initapplyspecmodule:function-initapplyspecmodule}]{\sphinxcrossref{\DUrole{std,std-ref}{Function initapplyspecmodule}}}}

\end{itemize}


\subsubsection{Defines}
\label{\detokenize{api/file_applyspecmodule.h:defines}}\begin{itemize}
\item {} 
{\hyperref[\detokenize{api/define_APPLY_SPEC_IMPORT:define-apply-spec-import}]{\sphinxcrossref{\DUrole{std,std-ref}{Define APPLY\_SPEC\_IMPORT}}}}

\item {} 
{\hyperref[\detokenize{api/define_GETSTATE:define-getstate}]{\sphinxcrossref{\DUrole{std,std-ref}{Define GETSTATE}}}}

\item {} 
{\hyperref[\detokenize{api/define_INITERROR:define-initerror}]{\sphinxcrossref{\DUrole{std,std-ref}{Define INITERROR}}}}

\end{itemize}


\subsubsection{Variables}
\label{\detokenize{api/file_applyspecmodule.h:variables}}\begin{itemize}
\item {} 
{\hyperref[\detokenize{api/variable__state:variable-state}]{\sphinxcrossref{\DUrole{std,std-ref}{Variable \_state}}}}

\item {} 
{\hyperref[\detokenize{api/variable_ApplySpeciationError:variable-applyspeciationerror}]{\sphinxcrossref{\DUrole{std,std-ref}{Variable ApplySpeciationError}}}}

\end{itemize}


\subsection{File Community.cpp}
\label{\detokenize{api/file_necsim_Community.cpp:file-community-cpp}}\label{\detokenize{api/file_necsim_Community.cpp::doc}}\label{\detokenize{api/file_necsim_Community.cpp:file-necsim-community-cpp}}
Contains the {\hyperref[\detokenize{api/class_Community:class-community}]{\sphinxcrossref{\DUrole{std,std-ref}{Class Community}}}} class implementation, which is used for reconstructing the coalescence tree after simulations are complete.

\begin{sphinxShadowBox}
\sphinxstyletopictitle{Contents}
\begin{itemize}
\item {} 
\phantomsection\label{\detokenize{api/file_necsim_Community.cpp:id1}}{\hyperref[\detokenize{api/file_necsim_Community.cpp:definition-necsim-community-cpp}]{\sphinxcrossref{Definition (\sphinxcode{necsim/Community.cpp})}}}

\item {} 
\phantomsection\label{\detokenize{api/file_necsim_Community.cpp:id2}}{\hyperref[\detokenize{api/file_necsim_Community.cpp:detailed-description}]{\sphinxcrossref{Detailed Description}}}

\item {} 
\phantomsection\label{\detokenize{api/file_necsim_Community.cpp:id3}}{\hyperref[\detokenize{api/file_necsim_Community.cpp:includes}]{\sphinxcrossref{Includes}}}

\item {} 
\phantomsection\label{\detokenize{api/file_necsim_Community.cpp:id4}}{\hyperref[\detokenize{api/file_necsim_Community.cpp:functions}]{\sphinxcrossref{Functions}}}

\end{itemize}
\end{sphinxShadowBox}


\subsubsection{Definition (\sphinxstyleliteralintitle{necsim/Community.cpp})}
\label{\detokenize{api/file_necsim_Community.cpp:definition-necsim-community-cpp}}

\paragraph{Program Listing for File Community.cpp}
\label{\detokenize{api/program_listing_file_necsim_Community.cpp:program-listing-for-file-community-cpp}}\label{\detokenize{api/program_listing_file_necsim_Community.cpp::doc}}\label{\detokenize{api/program_listing_file_necsim_Community.cpp:program-listing-file-necsim-community-cpp}}\begin{itemize}
\item {} 
Return to documentation for {\hyperref[\detokenize{api/file_necsim_Community.cpp:file-necsim-community-cpp}]{\sphinxcrossref{\DUrole{std,std-ref}{File Community.cpp}}}}

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{// This file is part of NECSim project which is released under BSD\PYGZhy{}3 license.}
\PYG{c+c1}{// See file **LICENSE.txt** or visit https://opensource.org/licenses/BSD\PYGZhy{}3\PYGZhy{}Clause) for full license details.}

\PYG{c+c1}{//\PYGZsh{}define use\PYGZus{}csv}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}algorithm\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}set\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}unordered\PYGZus{}map\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZdq{}Community.h\PYGZdq{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZdq{}Filesystem.h\PYGZdq{}}

\PYG{k+kt}{bool} \PYG{n+nf}{checkSpeciation}\PYG{p}{(}\PYG{k}{const} \PYG{k+kt}{long} \PYG{k+kt}{double} \PYG{o}{\PYGZam{}}\PYG{n}{random\PYGZus{}number}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{long} \PYG{k+kt}{double} \PYG{o}{\PYGZam{}}\PYG{n}{speciation\PYGZus{}rate}\PYG{p}{,}
                     \PYG{k}{const} \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{no\PYGZus{}generations}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{c+c1}{// bool result1, result2, result3, result4;}
    \PYG{k+kt}{long} \PYG{k+kt}{double} \PYG{n}{res} \PYG{o}{=} \PYG{l+m+mf}{1.0} \PYG{o}{\PYGZhy{}} \PYG{n}{pow}\PYG{p}{(}\PYG{k+kt}{double}\PYG{p}{(}\PYG{l+m+mf}{1.0} \PYG{o}{\PYGZhy{}} \PYG{n}{speciation\PYGZus{}rate}\PYG{p}{)}\PYG{p}{,} \PYG{k+kt}{double}\PYG{p}{(}\PYG{n}{no\PYGZus{}generations}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
    \PYG{k}{if}\PYG{p}{(}\PYG{n}{random\PYGZus{}number} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{n}{res}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{return} \PYG{p}{(}\PYG{n+nb}{true}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{return} \PYG{p}{(}\PYG{n+nb}{false}\PYG{p}{)}\PYG{p}{;}

\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{bool} \PYG{n+nf}{doubleCompare}\PYG{p}{(}\PYG{k+kt}{double} \PYG{n}{d1}\PYG{p}{,} \PYG{k+kt}{double} \PYG{n}{d2}\PYG{p}{,} \PYG{k+kt}{double} \PYG{n}{epsilon}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k}{return} \PYG{p}{(}\PYG{n}{abs}\PYG{p}{(}\PYG{k+kt}{float}\PYG{p}{(}\PYG{n}{d1} \PYG{o}{\PYGZhy{}} \PYG{n}{d2}\PYG{p}{)}\PYG{p}{)} \PYG{o}{\PYGZlt{}} \PYG{n}{epsilon}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{bool} \PYG{n+nf}{doubleCompare}\PYG{p}{(}\PYG{k+kt}{long} \PYG{k+kt}{double} \PYG{n}{d1}\PYG{p}{,} \PYG{k+kt}{long} \PYG{k+kt}{double} \PYG{n}{d2}\PYG{p}{,} \PYG{k+kt}{long} \PYG{k+kt}{double} \PYG{n}{epsilon}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k}{return} \PYG{n}{abs}\PYG{p}{(}\PYG{p}{(}\PYG{n}{d1} \PYG{o}{\PYGZhy{}} \PYG{n}{d2}\PYG{p}{)}\PYG{p}{)} \PYG{o}{\PYGZlt{}} \PYG{n}{epsilon}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{bool} \PYG{n+nf}{doubleCompare}\PYG{p}{(}\PYG{k+kt}{long} \PYG{k+kt}{double} \PYG{n}{d1}\PYG{p}{,} \PYG{k+kt}{long} \PYG{k+kt}{double} \PYG{n}{d2}\PYG{p}{,} \PYG{k+kt}{double} \PYG{n}{epsilon}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k}{return} \PYG{n}{abs}\PYG{p}{(}\PYG{p}{(}\PYG{n}{d1} \PYG{o}{\PYGZhy{}} \PYG{n}{d2}\PYG{p}{)}\PYG{p}{)} \PYG{o}{\PYGZlt{}} \PYG{n}{epsilon}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}


\PYG{n}{CommunityParameters}\PYG{o}{:}\PYG{o}{:}\PYG{n}{CommunityParameters}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{reference\PYGZus{}in}\PYG{p}{,} \PYG{k+kt}{long} \PYG{k+kt}{double} \PYG{n}{speciation\PYGZus{}rate\PYGZus{}in}\PYG{p}{,}
                                         \PYG{k+kt}{long} \PYG{k+kt}{double} \PYG{n}{time\PYGZus{}in}\PYG{p}{,} \PYG{k+kt}{bool} \PYG{n}{fragment\PYGZus{}in}\PYG{p}{,}
                                         \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{metacommunity\PYGZus{}reference\PYGZus{}in}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{n}{setup}\PYG{p}{(}\PYG{n}{reference\PYGZus{}in}\PYG{p}{,} \PYG{n}{speciation\PYGZus{}rate\PYGZus{}in}\PYG{p}{,} \PYG{n}{time\PYGZus{}in}\PYG{p}{,} \PYG{n}{fragment\PYGZus{}in}\PYG{p}{,} \PYG{n}{metacommunity\PYGZus{}reference\PYGZus{}in}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{void} \PYG{n}{CommunityParameters}\PYG{o}{:}\PYG{o}{:}\PYG{n}{setup}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{reference\PYGZus{}in}\PYG{p}{,} \PYG{k+kt}{long} \PYG{k+kt}{double} \PYG{n}{speciation\PYGZus{}rate\PYGZus{}in}\PYG{p}{,} \PYG{k+kt}{long} \PYG{k+kt}{double} \PYG{n}{time\PYGZus{}in}\PYG{p}{,}
                                \PYG{k+kt}{bool} \PYG{n}{fragment\PYGZus{}in}\PYG{p}{,} \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{metacommunity\PYGZus{}reference\PYGZus{}in}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{n}{time} \PYG{o}{=} \PYG{n}{time\PYGZus{}in}\PYG{p}{;}
    \PYG{n}{speciation\PYGZus{}rate} \PYG{o}{=} \PYG{n}{speciation\PYGZus{}rate\PYGZus{}in}\PYG{p}{;}
    \PYG{n}{fragment} \PYG{o}{=} \PYG{n}{fragment\PYGZus{}in}\PYG{p}{;}
    \PYG{n}{reference} \PYG{o}{=} \PYG{n}{reference\PYGZus{}in}\PYG{p}{;}
    \PYG{n}{metacommunity\PYGZus{}reference} \PYG{o}{=} \PYG{n}{metacommunity\PYGZus{}reference\PYGZus{}in}\PYG{p}{;}
    \PYG{n}{updated} \PYG{o}{=} \PYG{n+nb}{false}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{bool} \PYG{n}{CommunityParameters}\PYG{o}{:}\PYG{o}{:}\PYG{n}{compare}\PYG{p}{(}\PYG{k+kt}{long} \PYG{k+kt}{double} \PYG{n}{speciation\PYGZus{}rate\PYGZus{}in}\PYG{p}{,} \PYG{k+kt}{long} \PYG{k+kt}{double} \PYG{n}{time\PYGZus{}in}\PYG{p}{,} \PYG{k+kt}{bool} \PYG{n}{fragment\PYGZus{}in}\PYG{p}{,}
                                  \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{metacommunity\PYGZus{}reference\PYGZus{}in}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k}{if}\PYG{p}{(}\PYG{n}{doubleCompare}\PYG{p}{(}\PYG{k+kt}{double}\PYG{p}{(}\PYG{n}{time\PYGZus{}in}\PYG{p}{)}\PYG{p}{,} \PYG{k+kt}{double}\PYG{p}{(}\PYG{l+m+mf}{0.0}\PYG{p}{)}\PYG{p}{,} \PYG{l+m+mf}{0.00001}\PYG{p}{)}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifdef DEBUG}
        \PYG{n}{stringstream} \PYG{n}{os}\PYG{p}{;}
        \PYG{n}{os} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Detected generation at t=0.0.}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
        \PYG{n}{writeLog}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{,} \PYG{n}{os}\PYG{p}{)}\PYG{p}{;}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif }\PYG{c+c1}{// DEBUG}
        \PYG{k}{return} \PYG{n+nf}{doubleCompare}\PYG{p}{(}\PYG{n}{speciation\PYGZus{}rate}\PYG{p}{,} \PYG{n}{speciation\PYGZus{}rate\PYGZus{}in}\PYG{p}{,} \PYG{n}{speciation\PYGZus{}rate} \PYG{o}{*} \PYG{l+m+mf}{0.000001}\PYG{p}{)} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}}
                \PYG{n}{fragment} \PYG{o}{=}\PYG{o}{=} \PYG{n}{fragment\PYGZus{}in} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{n}{metacommunity\PYGZus{}reference} \PYG{o}{=}\PYG{o}{=} \PYG{n}{metacommunity\PYGZus{}reference\PYGZus{}in}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{return} \PYG{n}{doubleCompare}\PYG{p}{(}\PYG{n}{speciation\PYGZus{}rate}\PYG{p}{,} \PYG{n}{speciation\PYGZus{}rate\PYGZus{}in}\PYG{p}{,} \PYG{n}{speciation\PYGZus{}rate} \PYG{o}{*} \PYG{l+m+mf}{0.000001}\PYG{p}{)} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}}
           \PYG{n}{doubleCompare}\PYG{p}{(}\PYG{n}{time}\PYG{p}{,} \PYG{n}{time\PYGZus{}in}\PYG{p}{,} \PYG{n}{time} \PYG{o}{*} \PYG{l+m+mf}{0.0001}\PYG{p}{)} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{n}{fragment} \PYG{o}{=}\PYG{o}{=} \PYG{n}{fragment\PYGZus{}in} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}}
           \PYG{n}{metacommunity\PYGZus{}reference} \PYG{o}{=}\PYG{o}{=} \PYG{n}{metacommunity\PYGZus{}reference\PYGZus{}in}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{bool} \PYG{n}{CommunityParameters}\PYG{o}{:}\PYG{o}{:}\PYG{n}{compare}\PYG{p}{(}\PYG{k+kt}{long} \PYG{k+kt}{double} \PYG{n}{speciation\PYGZus{}rate\PYGZus{}in}\PYG{p}{,} \PYG{k+kt}{long} \PYG{k+kt}{double} \PYG{n}{time\PYGZus{}in}\PYG{p}{,}
                                  \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{metacommunity\PYGZus{}reference\PYGZus{}in}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k}{return} \PYG{n}{doubleCompare}\PYG{p}{(}\PYG{n}{speciation\PYGZus{}rate}\PYG{p}{,} \PYG{n}{speciation\PYGZus{}rate\PYGZus{}in}\PYG{p}{,} \PYG{n}{speciation\PYGZus{}rate} \PYG{o}{*} \PYG{l+m+mf}{0.000001}\PYG{p}{)} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}}
           \PYG{n}{doubleCompare}\PYG{p}{(}\PYG{n}{time}\PYG{p}{,} \PYG{n}{time\PYGZus{}in}\PYG{p}{,} \PYG{l+m+mf}{0.0001}\PYG{p}{)} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{n}{metacommunity\PYGZus{}reference} \PYG{o}{=}\PYG{o}{=} \PYG{n}{metacommunity\PYGZus{}reference\PYGZus{}in}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{bool} \PYG{n}{CommunityParameters}\PYG{o}{:}\PYG{o}{:}\PYG{n}{compare}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{reference\PYGZus{}in}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k}{return} \PYG{n}{reference} \PYG{o}{=}\PYG{o}{=} \PYG{n}{reference\PYGZus{}in}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{void} \PYG{n}{CommunitiesArray}\PYG{o}{:}\PYG{o}{:}\PYG{n}{pushBack}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{reference}\PYG{p}{,} \PYG{k+kt}{long} \PYG{k+kt}{double} \PYG{n}{speciation\PYGZus{}rate}\PYG{p}{,} \PYG{k+kt}{long} \PYG{k+kt}{double} \PYG{n}{time}\PYG{p}{,} \PYG{k+kt}{bool} \PYG{n}{fragment}\PYG{p}{,}
                                \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{metacommunity\PYGZus{}reference}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{n}{CommunityParameters} \PYG{n}{tmp\PYGZus{}param}\PYG{p}{(}\PYG{n}{reference}\PYG{p}{,} \PYG{n}{speciation\PYGZus{}rate}\PYG{p}{,} \PYG{n}{time}\PYG{p}{,} \PYG{n}{fragment}\PYG{p}{,} \PYG{n}{metacommunity\PYGZus{}reference}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{calc\PYGZus{}array}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{n}{tmp\PYGZus{}param}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{void} \PYG{n}{CommunitiesArray}\PYG{o}{:}\PYG{o}{:}\PYG{n}{pushBack}\PYG{p}{(}\PYG{n}{CommunityParameters} \PYG{n}{tmp\PYGZus{}param}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{n}{calc\PYGZus{}array}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{n}{tmp\PYGZus{}param}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{n}{CommunityParameters} \PYG{o}{\PYGZam{}}\PYG{n}{CommunitiesArray}\PYG{o}{:}\PYG{o}{:}\PYG{n}{addNew}\PYG{p}{(}\PYG{k+kt}{long} \PYG{k+kt}{double} \PYG{n}{speciation\PYGZus{}rate}\PYG{p}{,} \PYG{k+kt}{long} \PYG{k+kt}{double} \PYG{n}{time}\PYG{p}{,} \PYG{k+kt}{bool} \PYG{n}{fragment}\PYG{p}{,}
                                              \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{metacommunity\PYGZus{}reference}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{max\PYGZus{}reference} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;}
    \PYG{k}{for}\PYG{p}{(}\PYG{k}{auto} \PYG{o}{\PYGZam{}}\PYG{n+nl}{i} \PYG{p}{:} \PYG{n}{calc\PYGZus{}array}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{i}\PYG{p}{.}\PYG{n}{compare}\PYG{p}{(}\PYG{n}{speciation\PYGZus{}rate}\PYG{p}{,} \PYG{n}{time}\PYG{p}{,} \PYG{n}{metacommunity\PYGZus{}reference}\PYG{p}{)}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{k}{if}\PYG{p}{(}\PYG{n}{i}\PYG{p}{.}\PYG{n}{fragment} \PYG{o}{=}\PYG{o}{=} \PYG{n}{fragment} \PYG{o}{\textbar{}}\PYG{o}{\textbar{}} \PYG{o}{!}\PYG{n}{fragment}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{k}{throw} \PYG{n}{FatalException}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Tried to get reference for non\PYGZhy{}unique parameter set in communities. }\PYG{l+s}{\PYGZdq{}}
                                             \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Please report this bug.}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
            \PYG{k}{else}
            \PYG{p}{\PYGZob{}}
                \PYG{n}{i}\PYG{p}{.}\PYG{n}{fragment} \PYG{o}{=} \PYG{n+nb}{true}\PYG{p}{;}
                \PYG{n}{i}\PYG{p}{.}\PYG{n}{updated} \PYG{o}{=} \PYG{n+nb}{true}\PYG{p}{;}
                \PYG{k}{return} \PYG{n}{i}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{else}
        \PYG{p}{\PYGZob{}}
            \PYG{k}{if}\PYG{p}{(}\PYG{n}{i}\PYG{p}{.}\PYG{n}{reference} \PYG{o}{\PYGZgt{}}\PYG{o}{=} \PYG{n}{max\PYGZus{}reference}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{n}{max\PYGZus{}reference} \PYG{o}{=} \PYG{n}{i}\PYG{p}{.}\PYG{n}{reference} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
        \PYG{p}{\PYGZcb{}}
    \PYG{p}{\PYGZcb{}}
    \PYG{n}{CommunityParameters} \PYG{n}{tmp\PYGZus{}param}\PYG{p}{(}\PYG{n}{max\PYGZus{}reference}\PYG{p}{,} \PYG{n}{speciation\PYGZus{}rate}\PYG{p}{,} \PYG{n}{time}\PYG{p}{,} \PYG{n}{fragment}\PYG{p}{,} \PYG{n}{metacommunity\PYGZus{}reference}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{calc\PYGZus{}array}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{n}{tmp\PYGZus{}param}\PYG{p}{)}\PYG{p}{;}
    \PYG{k}{return} \PYG{n}{calc\PYGZus{}array}\PYG{p}{.}\PYG{n}{back}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{bool} \PYG{n}{CommunitiesArray}\PYG{o}{:}\PYG{o}{:}\PYG{n}{hasPair}\PYG{p}{(}\PYG{k+kt}{long} \PYG{k+kt}{double} \PYG{n}{speciation\PYGZus{}rate}\PYG{p}{,} \PYG{k+kt}{double} \PYG{n}{time}\PYG{p}{,} \PYG{k+kt}{bool} \PYG{n}{fragment}\PYG{p}{,}
                               \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{metacommunity\PYGZus{}reference}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k}{for}\PYG{p}{(}\PYG{k}{auto} \PYG{o}{\PYGZam{}}\PYG{n+nl}{i} \PYG{p}{:} \PYG{n}{calc\PYGZus{}array}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{i}\PYG{p}{.}\PYG{n}{compare}\PYG{p}{(}\PYG{n}{speciation\PYGZus{}rate}\PYG{p}{,} \PYG{n}{time}\PYG{p}{,} \PYG{n}{fragment}\PYG{p}{,} \PYG{n}{metacommunity\PYGZus{}reference}\PYG{p}{)}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{k}{return} \PYG{n+nb}{true}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{return} \PYG{n+nb}{false}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{n}{MetacommunityParameters}\PYG{o}{:}\PYG{o}{:}\PYG{n}{MetacommunityParameters}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{reference\PYGZus{}in}\PYG{p}{,} \PYG{k+kt}{long} \PYG{k+kt}{double} \PYG{n}{speciation\PYGZus{}rate\PYGZus{}in}\PYG{p}{,}
                                                 \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{metacommunity\PYGZus{}size\PYGZus{}in}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{n}{metacommunity\PYGZus{}size} \PYG{o}{=} \PYG{n}{metacommunity\PYGZus{}size\PYGZus{}in}\PYG{p}{;}
    \PYG{n}{speciation\PYGZus{}rate} \PYG{o}{=} \PYG{n}{speciation\PYGZus{}rate\PYGZus{}in}\PYG{p}{;}
    \PYG{n}{reference} \PYG{o}{=} \PYG{n}{reference\PYGZus{}in}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{bool} \PYG{n}{MetacommunityParameters}\PYG{o}{:}\PYG{o}{:}\PYG{n}{compare}\PYG{p}{(}\PYG{k+kt}{long} \PYG{k+kt}{double} \PYG{n}{speciation\PYGZus{}rate\PYGZus{}in}\PYG{p}{,} \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{metacommunity\PYGZus{}size\PYGZus{}in}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k}{return} \PYG{n}{doubleCompare}\PYG{p}{(}\PYG{n}{speciation\PYGZus{}rate}\PYG{p}{,} \PYG{n}{speciation\PYGZus{}rate\PYGZus{}in}\PYG{p}{,} \PYG{n}{speciation\PYGZus{}rate} \PYG{o}{*} \PYG{l+m+mf}{0.000001}\PYG{p}{)} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}}
           \PYG{n}{metacommunity\PYGZus{}size} \PYG{o}{=}\PYG{o}{=} \PYG{n}{metacommunity\PYGZus{}size\PYGZus{}in}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{bool} \PYG{n}{MetacommunityParameters}\PYG{o}{:}\PYG{o}{:}\PYG{n}{compare}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{reference\PYGZus{}in}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k}{return} \PYG{n}{reference} \PYG{o}{=}\PYG{o}{=} \PYG{n}{reference\PYGZus{}in}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{void}
\PYG{n}{MetacommunitiesArray}\PYG{o}{:}\PYG{o}{:}\PYG{n}{pushBack}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{reference}\PYG{p}{,} \PYG{k+kt}{long} \PYG{k+kt}{double} \PYG{n}{speciation\PYGZus{}rate}\PYG{p}{,} \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{metacommunity\PYGZus{}size}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{n}{MetacommunityParameters} \PYG{n}{tmp\PYGZus{}param}\PYG{p}{(}\PYG{n}{reference}\PYG{p}{,} \PYG{n}{speciation\PYGZus{}rate}\PYG{p}{,} \PYG{n}{metacommunity\PYGZus{}size}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{calc\PYGZus{}array}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{n}{tmp\PYGZus{}param}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{void} \PYG{n}{MetacommunitiesArray}\PYG{o}{:}\PYG{o}{:}\PYG{n}{pushBack}\PYG{p}{(}\PYG{n}{MetacommunityParameters} \PYG{n}{tmp\PYGZus{}param}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{n}{calc\PYGZus{}array}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{n}{tmp\PYGZus{}param}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{MetacommunitiesArray}\PYG{o}{:}\PYG{o}{:}\PYG{n}{addNew}\PYG{p}{(}\PYG{k+kt}{long} \PYG{k+kt}{double} \PYG{n}{speciation\PYGZus{}rate}\PYG{p}{,} \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{metacommunity\PYGZus{}size}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{max\PYGZus{}reference} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;}
    \PYG{k}{for}\PYG{p}{(}\PYG{k}{auto} \PYG{o}{\PYGZam{}}\PYG{n+nl}{i} \PYG{p}{:} \PYG{n}{calc\PYGZus{}array}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{i}\PYG{p}{.}\PYG{n}{compare}\PYG{p}{(}\PYG{n}{speciation\PYGZus{}rate}\PYG{p}{,} \PYG{n}{metacommunity\PYGZus{}size}\PYG{p}{)}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}

            \PYG{k}{throw} \PYG{n}{FatalException}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Tried to get reference for non\PYGZhy{}unique parameter set in metacommunities. }\PYG{l+s}{\PYGZdq{}}
                                         \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Please report this bug.}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{else}
        \PYG{p}{\PYGZob{}}
            \PYG{k}{if}\PYG{p}{(}\PYG{n}{i}\PYG{p}{.}\PYG{n}{reference} \PYG{o}{\PYGZgt{}}\PYG{o}{=} \PYG{n}{max\PYGZus{}reference}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{n}{max\PYGZus{}reference} \PYG{o}{=} \PYG{n}{i}\PYG{p}{.}\PYG{n}{reference} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
        \PYG{p}{\PYGZcb{}}
    \PYG{p}{\PYGZcb{}}
    \PYG{n}{MetacommunityParameters} \PYG{n}{tmp\PYGZus{}param}\PYG{p}{(}\PYG{n}{max\PYGZus{}reference}\PYG{p}{,} \PYG{n}{speciation\PYGZus{}rate}\PYG{p}{,} \PYG{n}{metacommunity\PYGZus{}size}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{calc\PYGZus{}array}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{n}{tmp\PYGZus{}param}\PYG{p}{)}\PYG{p}{;}
    \PYG{k}{return} \PYG{n}{max\PYGZus{}reference}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{bool} \PYG{n}{MetacommunitiesArray}\PYG{o}{:}\PYG{o}{:}\PYG{n}{hasPair}\PYG{p}{(}\PYG{k+kt}{long} \PYG{k+kt}{double} \PYG{n}{speciation\PYGZus{}rate}\PYG{p}{,} \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{metacommunity\PYGZus{}size}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k}{for}\PYG{p}{(}\PYG{k}{auto} \PYG{o}{\PYGZam{}}\PYG{n+nl}{i} \PYG{p}{:} \PYG{n}{calc\PYGZus{}array}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{i}\PYG{p}{.}\PYG{n}{compare}\PYG{p}{(}\PYG{n}{speciation\PYGZus{}rate}\PYG{p}{,} \PYG{n}{metacommunity\PYGZus{}size}\PYG{p}{)}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{k}{return} \PYG{n+nb}{true}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{return} \PYG{n+nb}{false}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{bool} \PYG{n}{MetacommunitiesArray}\PYG{o}{:}\PYG{o}{:}\PYG{n}{hasPair}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{reference}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k}{for}\PYG{p}{(}\PYG{k}{auto} \PYG{o}{\PYGZam{}}\PYG{n+nl}{i} \PYG{p}{:} \PYG{n}{calc\PYGZus{}array}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{i}\PYG{p}{.}\PYG{n}{compare}\PYG{p}{(}\PYG{n}{reference}\PYG{p}{)}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{k}{return} \PYG{n+nb}{true}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{return} \PYG{n+nb}{false}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{MetacommunitiesArray}\PYG{o}{:}\PYG{o}{:}\PYG{n}{getReference}\PYG{p}{(}\PYG{k+kt}{long} \PYG{k+kt}{double} \PYG{n}{speciation\PYGZus{}rate}\PYG{p}{,} \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{metacommunity\PYGZus{}size}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k}{if}\PYG{p}{(}\PYG{n}{metacommunity\PYGZus{}size} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{return} \PYG{l+m+mi}{0}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{for}\PYG{p}{(}\PYG{k}{auto} \PYG{o}{\PYGZam{}}\PYG{n+nl}{i} \PYG{p}{:} \PYG{n}{calc\PYGZus{}array}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{i}\PYG{p}{.}\PYG{n}{compare}\PYG{p}{(}\PYG{n}{speciation\PYGZus{}rate}\PYG{p}{,} \PYG{n}{metacommunity\PYGZus{}size}\PYG{p}{)}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{k}{return} \PYG{n}{i}\PYG{p}{.}\PYG{n}{reference}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{return} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{n}{Samplematrix}\PYG{o}{:}\PYG{o}{:}\PYG{n}{Samplematrix}\PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{n}{bIsFragment} \PYG{o}{=} \PYG{n+nb}{false}\PYG{p}{;}
    \PYG{n}{bIsNull} \PYG{o}{=} \PYG{n+nb}{false}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{bool} \PYG{n}{Samplematrix}\PYG{o}{:}\PYG{o}{:}\PYG{n}{getTestVal}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{xval}\PYG{p}{,} \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{yval}\PYG{p}{,} \PYG{k+kt}{long} \PYG{n}{xwrap}\PYG{p}{,} \PYG{k+kt}{long} \PYG{n}{ywrap}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k}{return} \PYG{n}{getVal}\PYG{p}{(}\PYG{n}{xval}\PYG{p}{,} \PYG{n}{yval}\PYG{p}{,} \PYG{n}{xwrap}\PYG{p}{,} \PYG{n}{ywrap}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{bool} \PYG{n}{Samplematrix}\PYG{o}{:}\PYG{o}{:}\PYG{n}{getMaskVal}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{x1}\PYG{p}{,} \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{y1}\PYG{p}{,} \PYG{k+kt}{long} \PYG{n}{x\PYGZus{}wrap}\PYG{p}{,} \PYG{k+kt}{long} \PYG{n}{y\PYGZus{}wrap}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k}{if}\PYG{p}{(}\PYG{n}{bIsFragment}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k+kt}{long} \PYG{n}{x}\PYG{p}{,} \PYG{n}{y}\PYG{p}{;}
        \PYG{n}{x} \PYG{o}{=} \PYG{n}{x1} \PYG{o}{+} \PYG{p}{(}\PYG{n}{x\PYGZus{}wrap} \PYG{o}{*} \PYG{n}{x\PYGZus{}dim}\PYG{p}{)} \PYG{o}{+} \PYG{n}{x\PYGZus{}offset}\PYG{p}{;}
        \PYG{n}{y} \PYG{o}{=} \PYG{n}{y1} \PYG{o}{+} \PYG{p}{(}\PYG{n}{y\PYGZus{}wrap} \PYG{o}{*} \PYG{n}{y\PYGZus{}dim}\PYG{p}{)} \PYG{o}{+} \PYG{n}{y\PYGZus{}offset}\PYG{p}{;}
        \PYG{k}{return} \PYG{n}{fragment}\PYG{p}{.}\PYG{n}{x\PYGZus{}west} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{n}{x} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{n}{x} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{n}{fragment}\PYG{p}{.}\PYG{n}{x\PYGZus{}east} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{n}{fragment}\PYG{p}{.}\PYG{n}{y\PYGZus{}north} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{n}{y} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}}
               \PYG{n}{y} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{n}{fragment}\PYG{p}{.}\PYG{n}{y\PYGZus{}south}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{if}\PYG{p}{(}\PYG{n}{bIsNull}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{return} \PYG{n+nb}{true}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{return} \PYG{n}{getVal}\PYG{p}{(}\PYG{n}{x1}\PYG{p}{,} \PYG{n}{y1}\PYG{p}{,} \PYG{n}{x\PYGZus{}wrap}\PYG{p}{,} \PYG{n}{y\PYGZus{}wrap}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{void} \PYG{n}{Samplematrix}\PYG{o}{:}\PYG{o}{:}\PYG{n}{setFragment}\PYG{p}{(}\PYG{n}{Fragment} \PYG{o}{\PYGZam{}}\PYG{n}{fragment\PYGZus{}in}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{n}{fragment} \PYG{o}{=} \PYG{n}{fragment\PYGZus{}in}\PYG{p}{;}
\PYG{c+c1}{//          os \PYGZlt{}\PYGZlt{} \PYGZdq{}W,E,N,S: \PYGZdq{} \PYGZlt{}\PYGZlt{} fragment.x\PYGZus{}west \PYGZlt{}\PYGZlt{} \PYGZdq{}, \PYGZdq{} \PYGZlt{}\PYGZlt{} fragment.x\PYGZus{}east \PYGZlt{}\PYGZlt{} \PYGZdq{}, \PYGZdq{} \PYGZlt{}\PYGZlt{} fragment.y\PYGZus{}north \PYGZlt{}\PYGZlt{} \PYGZdq{}, \PYGZdq{} \PYGZlt{}\PYGZlt{} fragment.y\PYGZus{}south \PYGZlt{}\PYGZlt{} endl;}
    \PYG{n}{bIsFragment} \PYG{o}{=} \PYG{n+nb}{true}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{void} \PYG{n}{Samplematrix}\PYG{o}{:}\PYG{o}{:}\PYG{n}{removeFragment}\PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{n}{bIsFragment} \PYG{o}{=} \PYG{n+nb}{false}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{void} \PYG{n}{Community}\PYG{o}{:}\PYG{o}{:}\PYG{n}{setList}\PYG{p}{(}\PYG{n}{Row}\PYG{o}{\PYGZlt{}}\PYG{n}{TreeNode}\PYG{o}{\PYGZgt{}} \PYG{o}{*}\PYG{n}{l}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{n}{nodes} \PYG{o}{=} \PYG{n}{l}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{void} \PYG{n}{Community}\PYG{o}{:}\PYG{o}{:}\PYG{n}{setDatabase}\PYG{p}{(}\PYG{n}{sqlite3} \PYG{o}{*}\PYG{n}{dbin}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k}{if}\PYG{p}{(}\PYG{o}{!}\PYG{n}{bFileSet}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{database} \PYG{o}{=} \PYG{n}{dbin}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{else}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{throw} \PYG{n}{SpeciesException}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ERROR\PYGZus{}SPEC\PYGZus{}002: Attempt to set database \PYGZhy{} database link has already been set}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{n}{bFileSet} \PYG{o}{=} \PYG{n+nb}{true}\PYG{p}{;}  \PYG{c+c1}{// this just specifies that the database has been created in memory.}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{bool} \PYG{n}{Community}\PYG{o}{:}\PYG{o}{:}\PYG{n}{hasImportedData}\PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k}{return} \PYG{n}{bDataImport}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{long} \PYG{k+kt}{double} \PYG{n}{Community}\PYG{o}{:}\PYG{o}{:}\PYG{n}{getMinimumSpeciation}\PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k}{return} \PYG{n}{min\PYGZus{}spec\PYGZus{}rate}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{void} \PYG{n}{Community}\PYG{o}{:}\PYG{o}{:}\PYG{n}{importSamplemask}\PYG{p}{(}\PYG{n}{string} \PYG{n}{sSamplemask}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{c+c1}{// Check that the sim data has been imported.}
    \PYG{k}{if}\PYG{p}{(}\PYG{o}{!}\PYG{n}{bDataImport}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{throw} \PYG{n}{SpeciesException}\PYG{p}{(}
                \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ERROR\PYGZus{}SPEC\PYGZus{}003: Attempt to importSpatialParameters samplemask object before simulation parameters: dimensions not known}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{c+c1}{// Check that the main data has been imported already, otherwise the dimensions of the samplemask will not be correct}
    \PYG{k}{if}\PYG{p}{(}\PYG{o}{!}\PYG{n}{bSample}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{stringstream} \PYG{n}{os}\PYG{p}{;}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{sSamplemask} \PYG{o}{!}\PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{null}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{samplemask}\PYG{p}{.}\PYG{n}{importBooleanMask}\PYG{p}{(}\PYG{n}{grid\PYGZus{}x\PYGZus{}size}\PYG{p}{,} \PYG{n}{grid\PYGZus{}y\PYGZus{}size}\PYG{p}{,} \PYG{n}{samplemask\PYGZus{}x\PYGZus{}size}\PYG{p}{,} \PYG{n}{samplemask\PYGZus{}y\PYGZus{}size}\PYG{p}{,}
                                         \PYG{n}{samplemask\PYGZus{}x\PYGZus{}offset}\PYG{p}{,} \PYG{n}{samplemask\PYGZus{}y\PYGZus{}offset}\PYG{p}{,} \PYG{n}{sSamplemask}\PYG{p}{)}\PYG{p}{;}
            \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{total} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
            \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{samplemask}\PYG{p}{.}\PYG{n}{sample\PYGZus{}mask}\PYG{p}{.}\PYG{n}{GetCols}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{j} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{j} \PYG{o}{\PYGZlt{}} \PYG{n}{samplemask}\PYG{p}{.}\PYG{n}{sample\PYGZus{}mask}\PYG{p}{.}\PYG{n}{GetRows}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{n}{j}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
                \PYG{p}{\PYGZob{}}
                    \PYG{k}{if}\PYG{p}{(}\PYG{n}{samplemask}\PYG{p}{.}\PYG{n}{sample\PYGZus{}mask}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}
                    \PYG{p}{\PYGZob{}}
                        \PYG{n}{total}\PYG{o}{+}\PYG{o}{+}\PYG{p}{;}
                    \PYG{p}{\PYGZcb{}}
                \PYG{p}{\PYGZcb{}}
            \PYG{p}{\PYGZcb{}}
            \PYG{n}{os} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Sampling }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{total} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ cells.}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{else}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{samplemask}\PYG{p}{.}\PYG{n}{importBooleanMask}\PYG{p}{(}\PYG{n}{grid\PYGZus{}x\PYGZus{}size}\PYG{p}{,} \PYG{n}{grid\PYGZus{}y\PYGZus{}size}\PYG{p}{,} \PYG{n}{samplemask\PYGZus{}x\PYGZus{}size}\PYG{p}{,} \PYG{n}{samplemask\PYGZus{}y\PYGZus{}size}\PYG{p}{,}
                                         \PYG{n}{samplemask\PYGZus{}x\PYGZus{}offset}\PYG{p}{,} \PYG{n}{samplemask\PYGZus{}y\PYGZus{}offset}\PYG{p}{,} \PYG{n}{sSamplemask}\PYG{p}{)}\PYG{p}{;}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifdef DEBUG}
            \PYG{n}{os} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Sampling all areas.}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif}
        \PYG{p}{\PYGZcb{}}
        \PYG{n}{writeInfo}\PYG{p}{(}\PYG{n}{os}\PYG{p}{.}\PYG{n}{str}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{bSample} \PYG{o}{=} \PYG{n+nb}{true}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{Community}\PYG{o}{:}\PYG{o}{:}\PYG{n}{countSpecies}\PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k+kt}{unsigned} \PYG{k+kt}{int} \PYG{n}{precount} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
    \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{nodes}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{if}\PYG{p}{(}\PYG{p}{(}\PYG{o}{*}\PYG{n}{nodes}\PYG{p}{)}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{hasSpeciated}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{precount}\PYG{o}{+}\PYG{o}{+}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{return} \PYG{n}{precount}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{Community}\PYG{o}{:}\PYG{o}{:}\PYG{n}{calcSpecies}\PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{n}{resetTree}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
    \PYG{k}{if}\PYG{p}{(}\PYG{o}{!}\PYG{n}{bSample}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifdef DEBUG}
        \PYG{n}{writeInfo}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{No samplemask imported. Defaulting to null.}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif}
        \PYG{n}{importSamplemask}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{null}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{c+c1}{//      os \PYGZlt{}\PYGZlt{} \PYGZdq{}listsize: \PYGZdq{} \PYGZlt{}\PYGZlt{} nodes\PYGZhy{}\PYGZgt{}size() \PYGZlt{}\PYGZlt{} endl;}
    \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{iSpecCount} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}  \PYG{c+c1}{// start at 2 because the last species has been burnt already.}
    \PYG{c+c1}{// check that tips exist within the spatial and temporal frame of interest.}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifdef DEBUG}
    \PYG{n}{writeLog}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Assigning tips.}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif }\PYG{c+c1}{// DEBUG}
    \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{nodes}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{TreeNode} \PYG{o}{*}\PYG{n}{this\PYGZus{}node} \PYG{o}{=} \PYG{o}{\PYGZam{}}\PYG{p}{(}\PYG{o}{*}\PYG{n}{nodes}\PYG{p}{)}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{;}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifdef DEBUG}
        \PYG{k}{if}\PYG{p}{(}\PYG{p}{(}\PYG{o}{*}\PYG{n}{nodes}\PYG{p}{)}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getParent}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZgt{}}\PYG{o}{=} \PYG{n}{nodes}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{writeLog}\PYG{p}{(}\PYG{l+m+mi}{50}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{i: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{+} \PYG{n}{to\PYGZus{}string}\PYG{p}{(}\PYG{n}{i}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
            \PYG{n}{this\PYGZus{}node}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{logLineageInformation}\PYG{p}{(}\PYG{l+m+mi}{50}\PYG{p}{)}\PYG{p}{;}
            \PYG{n}{writeLog}\PYG{p}{(}\PYG{l+m+mi}{50}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{size: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{+} \PYG{n}{to\PYGZus{}string}\PYG{p}{(}\PYG{n}{nodes}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
            \PYG{k}{throw} \PYG{n+nf}{SpeciesException}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ERROR\PYGZus{}SQL\PYGZus{}017: The parent is outside the size of the the data object. Bug }\PYG{l+s}{\PYGZdq{}}
                                           \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{in expansion of data structures or object set up likely.}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif }\PYG{c+c1}{//DEBUG}
        \PYG{n}{this\PYGZus{}node}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{setExistence}\PYG{p}{(}\PYG{n}{this\PYGZus{}node}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{isTip}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{n}{samplemask}\PYG{p}{.}\PYG{n}{getMaskVal}\PYG{p}{(}\PYG{n}{this\PYGZus{}node}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{getXpos}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{n}{this\PYGZus{}node}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{getYpos}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,}
                                                                            \PYG{n}{this\PYGZus{}node}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{getXwrap}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,}
                                                                            \PYG{n}{this\PYGZus{}node}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{getYwrap}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}}
                                \PYG{n}{doubleCompare}\PYG{p}{(}\PYG{n}{this\PYGZus{}node}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{getGeneration}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{n}{current\PYGZus{}community\PYGZus{}parameters}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{time}\PYG{p}{,} \PYG{l+m+mf}{0.0001}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
        \PYG{c+c1}{// Calculate if speciation occured at any point in the lineage\PYGZsq{}s branch}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{protracted}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{k+kt}{long} \PYG{k+kt}{double} \PYG{n}{lineage\PYGZus{}age} \PYG{o}{=} \PYG{n}{this\PYGZus{}node}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{getGeneration}\PYG{p}{(}\PYG{p}{)} \PYG{o}{+} \PYG{n}{this\PYGZus{}node}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{getGenRate}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
            \PYG{k}{if}\PYG{p}{(}\PYG{n}{lineage\PYGZus{}age} \PYG{o}{\PYGZgt{}}\PYG{o}{=} \PYG{n}{applied\PYGZus{}min\PYGZus{}speciation\PYGZus{}gen}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{k}{if}\PYG{p}{(}\PYG{n}{checkSpeciation}\PYG{p}{(}\PYG{n}{this\PYGZus{}node}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{getSpecRate}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{n}{current\PYGZus{}community\PYGZus{}parameters}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{speciation\PYGZus{}rate}\PYG{p}{,}
                                   \PYG{n}{this\PYGZus{}node}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{getGenRate}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
                \PYG{p}{\PYGZob{}}
                    \PYG{n}{this\PYGZus{}node}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{speciate}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
                \PYG{p}{\PYGZcb{}}
                \PYG{k}{if}\PYG{p}{(}\PYG{n}{lineage\PYGZus{}age} \PYG{o}{\PYGZgt{}}\PYG{o}{=} \PYG{n}{applied\PYGZus{}max\PYGZus{}speciation\PYGZus{}gen}\PYG{p}{)}
                \PYG{p}{\PYGZob{}}
                    \PYG{n}{this\PYGZus{}node}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{speciate}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
                \PYG{p}{\PYGZcb{}}
            \PYG{p}{\PYGZcb{}}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{else}
        \PYG{p}{\PYGZob{}}
            \PYG{k}{if}\PYG{p}{(}\PYG{n}{checkSpeciation}\PYG{p}{(}\PYG{n}{this\PYGZus{}node}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{getSpecRate}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{n}{current\PYGZus{}community\PYGZus{}parameters}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{speciation\PYGZus{}rate}\PYG{p}{,}
                               \PYG{n}{this\PYGZus{}node}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{getGenRate}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{n}{this\PYGZus{}node}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{speciate}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
        \PYG{p}{\PYGZcb{}}
    \PYG{p}{\PYGZcb{}}

\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifdef DEBUG}
    \PYG{n}{writeLog}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Calculating lineage existence.}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif }\PYG{c+c1}{// DEBUG}
    \PYG{c+c1}{// now continue looping to calculate species identities for lineages given the new speciation probabilities.}
    \PYG{k+kt}{bool} \PYG{n}{bSorter} \PYG{o}{=} \PYG{n+nb}{true}\PYG{p}{;}
    \PYG{k}{while}\PYG{p}{(}\PYG{n}{bSorter}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{bSorter} \PYG{o}{=} \PYG{n+nb}{false}\PYG{p}{;}
        \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{nodes}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{TreeNode} \PYG{o}{*}\PYG{n}{this\PYGZus{}node} \PYG{o}{=} \PYG{o}{\PYGZam{}}\PYG{p}{(}\PYG{o}{*}\PYG{n}{nodes}\PYG{p}{)}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{;}
            \PYG{c+c1}{// check if any parents exist}
            \PYG{k}{if}\PYG{p}{(}\PYG{o}{!}\PYG{p}{(}\PYG{o}{*}\PYG{n}{nodes}\PYG{p}{)}\PYG{p}{[}\PYG{n}{this\PYGZus{}node}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{getParent}\PYG{p}{(}\PYG{p}{)}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getExistence}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{n}{this\PYGZus{}node}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{getExistence}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}}
               \PYG{o}{!}\PYG{n}{this\PYGZus{}node}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{hasSpeciated}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{n}{bSorter} \PYG{o}{=} \PYG{n+nb}{true}\PYG{p}{;}
                \PYG{p}{(}\PYG{o}{*}\PYG{n}{nodes}\PYG{p}{)}\PYG{p}{[}\PYG{n}{this\PYGZus{}node}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{getParent}\PYG{p}{(}\PYG{p}{)}\PYG{p}{]}\PYG{p}{.}\PYG{n}{setExistence}\PYG{p}{(}\PYG{n+nb}{true}\PYG{p}{)}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
        \PYG{p}{\PYGZcb{}}
    \PYG{p}{\PYGZcb{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifdef DEBUG}
    \PYG{n}{writeLog}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Speciating lineages.}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif }\PYG{c+c1}{// DEBUG}
    \PYG{n}{iSpecCount} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
    \PYG{n}{set}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{unsigned} \PYG{k+kt}{long}\PYG{o}{\PYGZgt{}} \PYG{n}{species\PYGZus{}list}\PYG{p}{;}
    \PYG{c+c1}{// Now loop again, creating a new species for each species that actually exists.}
    \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{nodes}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{TreeNode} \PYG{o}{*}\PYG{n}{this\PYGZus{}node} \PYG{o}{=} \PYG{o}{\PYGZam{}}\PYG{p}{(}\PYG{o}{*}\PYG{n}{nodes}\PYG{p}{)}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{;}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{this\PYGZus{}node}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{getExistence}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{n}{this\PYGZus{}node}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{hasSpeciated}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{addSpecies}\PYG{p}{(}\PYG{n}{iSpecCount}\PYG{p}{,} \PYG{n}{this\PYGZus{}node}\PYG{p}{,} \PYG{n}{species\PYGZus{}list}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
    \PYG{p}{\PYGZcb{}}
    \PYG{c+c1}{// Compress the species IDs so that the we have full mapping of species\PYGZus{}ids to integers in range 0:n}
    \PYG{c+c1}{// Only do so if the numbers do not match initially}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifdef DEBUG}
    \PYG{n}{writeLog}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Counting species.}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif }\PYG{c+c1}{// DEBUG}
    \PYG{k}{if}\PYG{p}{(}\PYG{o}{!}\PYG{n}{species\PYGZus{}list}\PYG{p}{.}\PYG{n}{empty}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{n}{iSpecCount} \PYG{o}{!}\PYG{o}{=} \PYG{o}{*}\PYG{n}{species\PYGZus{}list}\PYG{p}{.}\PYG{n}{rbegin}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{tmp\PYGZus{}species\PYGZus{}count} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
        \PYG{n}{unordered\PYGZus{}map}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{unsigned} \PYG{k+kt}{long}\PYG{p}{,} \PYG{k+kt}{unsigned} \PYG{k+kt}{long}\PYG{o}{\PYGZgt{}} \PYG{n}{ids\PYGZus{}map}\PYG{p}{;}
        \PYG{n}{ids\PYGZus{}map}\PYG{p}{.}\PYG{n}{reserve}\PYG{p}{(}\PYG{n}{iSpecCount}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{nodes}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{n}{i} \PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{TreeNode} \PYG{o}{*}\PYG{n}{this\PYGZus{}node} \PYG{o}{=} \PYG{o}{\PYGZam{}}\PYG{p}{(}\PYG{o}{*}\PYG{n}{nodes}\PYG{p}{)}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{;}
            \PYG{k}{if}\PYG{p}{(}\PYG{n}{this\PYGZus{}node}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{hasSpeciated}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{n}{this\PYGZus{}node}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{getExistence}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{k}{auto} \PYG{n}{map\PYGZus{}id} \PYG{o}{=} \PYG{n}{ids\PYGZus{}map}\PYG{p}{.}\PYG{n}{find}\PYG{p}{(}\PYG{n}{this\PYGZus{}node}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{getSpeciesID}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
                \PYG{k}{if}\PYG{p}{(}\PYG{n}{map\PYGZus{}id} \PYG{o}{=}\PYG{o}{=} \PYG{n}{ids\PYGZus{}map}\PYG{p}{.}\PYG{n}{end}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
                \PYG{p}{\PYGZob{}}
                    \PYG{n}{tmp\PYGZus{}species\PYGZus{}count} \PYG{o}{+}\PYG{o}{+}\PYG{p}{;}
                    \PYG{n}{this\PYGZus{}node}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{resetSpecies}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
                    \PYG{n}{this\PYGZus{}node}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{burnSpecies}\PYG{p}{(}\PYG{n}{tmp\PYGZus{}species\PYGZus{}count}\PYG{p}{)}\PYG{p}{;}
                    \PYG{n}{ids\PYGZus{}map}\PYG{p}{.}\PYG{n}{emplace}\PYG{p}{(}\PYG{n}{this\PYGZus{}node}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{getSpeciesID}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{n}{tmp\PYGZus{}species\PYGZus{}count}\PYG{p}{)}\PYG{p}{;}
                \PYG{p}{\PYGZcb{}}
                \PYG{k}{else}
                \PYG{p}{\PYGZob{}}
                    \PYG{n}{this\PYGZus{}node}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{resetSpecies}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
                    \PYG{n}{this\PYGZus{}node}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{burnSpecies}\PYG{p}{(}\PYG{n}{map\PYGZus{}id}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{second}\PYG{p}{)}\PYG{p}{;}
                \PYG{p}{\PYGZcb{}}
            \PYG{p}{\PYGZcb{}}
        \PYG{p}{\PYGZcb{}}
        \PYG{n}{iSpecCount} \PYG{o}{=} \PYG{n}{tmp\PYGZus{}species\PYGZus{}count}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{else}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{iSpecCount} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
        \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{nodes}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{TreeNode} \PYG{o}{*}\PYG{n}{this\PYGZus{}node} \PYG{o}{=} \PYG{o}{\PYGZam{}}\PYG{p}{(}\PYG{o}{*}\PYG{n}{nodes}\PYG{p}{)}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{;}
            \PYG{c+c1}{// count all speciation events, not just the ones that exist!}
            \PYG{k}{if}\PYG{p}{(}\PYG{n}{this\PYGZus{}node}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{hasSpeciated}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{n}{this\PYGZus{}node}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{getExistence}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{n}{this\PYGZus{}node}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{getSpeciesID}\PYG{p}{(}\PYG{p}{)} \PYG{o}{!}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{n}{iSpecCount}\PYG{o}{+}\PYG{o}{+}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
        \PYG{p}{\PYGZcb{}}
    \PYG{p}{\PYGZcb{}}
    \PYG{c+c1}{// now loop to correctly assign each species id}
    \PYG{k+kt}{bool} \PYG{n}{loopon} \PYG{o}{=} \PYG{n+nb}{true}\PYG{p}{;}
    \PYG{k+kt}{bool} \PYG{n}{error\PYGZus{}printed} \PYG{o}{=} \PYG{n+nb}{false}\PYG{p}{;}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifdef DEBUG}
    \PYG{n}{writeLog}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Generating species IDs.}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif }\PYG{c+c1}{// DEBUG}
    \PYG{k}{while}\PYG{p}{(}\PYG{n}{loopon}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{loopon} \PYG{o}{=} \PYG{n+nb}{false}\PYG{p}{;}
        \PYG{c+c1}{// if we start at the end of the loop and work backwards, we should remove some of the repeat}
        \PYG{c+c1}{// speciation events.}
        \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{i} \PYG{o}{=} \PYG{p}{(}\PYG{n}{nodes}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{1}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{TreeNode} \PYG{o}{*}\PYG{n}{this\PYGZus{}node} \PYG{o}{=} \PYG{o}{\PYGZam{}}\PYG{p}{(}\PYG{o}{*}\PYG{n}{nodes}\PYG{p}{)}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{;}
            \PYG{c+c1}{//              os \PYGZlt{}\PYGZlt{} i \PYGZlt{}\PYGZlt{} endl;}
            \PYG{k}{if}\PYG{p}{(}\PYG{n}{this\PYGZus{}node}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{getSpeciesID}\PYG{p}{(}\PYG{p}{)} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{0} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{n}{this\PYGZus{}node}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{getExistence}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{n}{loopon} \PYG{o}{=} \PYG{n+nb}{true}\PYG{p}{;}
                \PYG{n}{this\PYGZus{}node}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{burnSpecies}\PYG{p}{(}\PYG{p}{(}\PYG{o}{*}\PYG{n}{nodes}\PYG{p}{)}\PYG{p}{[}\PYG{n}{this\PYGZus{}node}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{getParent}\PYG{p}{(}\PYG{p}{)}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getSpeciesID}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifdef DEBUG}
                \PYG{k}{if}\PYG{p}{(}\PYG{p}{(}\PYG{o}{*}\PYG{n}{nodes}\PYG{p}{)}\PYG{p}{[}\PYG{n}{this\PYGZus{}node}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{getParent}\PYG{p}{(}\PYG{p}{)}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getSpeciesID}\PYG{p}{(}\PYG{p}{)} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{0} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}}
                   \PYG{n}{doubleCompare}\PYG{p}{(}\PYG{n}{this\PYGZus{}node}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{getGeneration}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{n}{current\PYGZus{}community\PYGZus{}parameters}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{time}\PYG{p}{,} \PYG{l+m+mf}{0.001}\PYG{p}{)}\PYG{p}{)}
                \PYG{p}{\PYGZob{}}

                    \PYG{k}{if}\PYG{p}{(}\PYG{o}{!}\PYG{n}{error\PYGZus{}printed}\PYG{p}{)}
                    \PYG{p}{\PYGZob{}}
                        \PYG{n}{stringstream} \PYG{n}{ss}\PYG{p}{;}
                        \PYG{n}{ss} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Potential parent ID error in }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{i} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ \PYGZhy{} incomplete simulation likely.}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
                        \PYG{n}{writeCritical}\PYG{p}{(}\PYG{n}{ss}\PYG{p}{.}\PYG{n}{str}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
                        \PYG{n}{writeLog}\PYG{p}{(}\PYG{l+m+mi}{50}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Lineage information:}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
                        \PYG{n}{this\PYGZus{}node}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{logLineageInformation}\PYG{p}{(}\PYG{l+m+mi}{50}\PYG{p}{)}\PYG{p}{;}
                        \PYG{n}{writeLog}\PYG{p}{(}\PYG{l+m+mi}{50}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Parent information:}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
                        \PYG{p}{(}\PYG{o}{*}\PYG{n}{nodes}\PYG{p}{)}\PYG{p}{[}\PYG{n}{this\PYGZus{}node}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{getParent}\PYG{p}{(}\PYG{p}{)}\PYG{p}{]}\PYG{p}{.}\PYG{n}{logLineageInformation}\PYG{p}{(}\PYG{l+m+mi}{50}\PYG{p}{)}\PYG{p}{;}
                        \PYG{n}{error\PYGZus{}printed} \PYG{o}{=} \PYG{n+nb}{true}\PYG{p}{;}
                        \PYG{k}{break}\PYG{p}{;}
                    \PYG{p}{\PYGZcb{}}
                \PYG{p}{\PYGZcb{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif}

            \PYG{p}{\PYGZcb{}}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{error\PYGZus{}printed}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{k}{throw} \PYG{n}{FatalException}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Parent ID error when calculating coalescence tree.}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
    \PYG{p}{\PYGZcb{}}
    \PYG{c+c1}{// count the number of species that have been created}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifdef DEBUG}
    \PYG{n}{writeLog}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Completed tree creation.}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif }\PYG{c+c1}{// DEBUG}
    \PYG{n}{iSpecies} \PYG{o}{=} \PYG{n}{iSpecCount}\PYG{p}{;}
    \PYG{c+c1}{//      os \PYGZlt{}\PYGZlt{} \PYGZdq{}iSpecies: \PYGZdq{} \PYGZlt{}\PYGZlt{} iSpecies \PYGZlt{}\PYGZlt{} endl;}
    \PYG{k}{return} \PYG{n}{iSpecCount}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{void} \PYG{n}{Community}\PYG{o}{:}\PYG{o}{:}\PYG{n}{addSpecies}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{species\PYGZus{}count}\PYG{p}{,} \PYG{n}{TreeNode} \PYG{o}{*}\PYG{n}{tree\PYGZus{}node}\PYG{p}{,} \PYG{n}{set}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{unsigned} \PYG{k+kt}{long}\PYG{o}{\PYGZgt{}} \PYG{o}{\PYGZam{}}\PYG{n}{species\PYGZus{}list}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{n}{species\PYGZus{}count}\PYG{o}{+}\PYG{o}{+}\PYG{p}{;}
    \PYG{n}{tree\PYGZus{}node}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{burnSpecies}\PYG{p}{(}\PYG{n}{species\PYGZus{}count}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{void} \PYG{n}{Community}\PYG{o}{:}\PYG{o}{:}\PYG{n}{calcSpeciesAbundance}\PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{n}{row\PYGZus{}out}\PYG{p}{.}\PYG{n}{setSize}\PYG{p}{(}\PYG{n}{iSpecies} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
    \PYG{c+c1}{//      os \PYGZlt{}\PYGZlt{} \PYGZdq{}iSpecies: \PYGZdq{} \PYGZlt{}\PYGZlt{} iSpecies \PYGZlt{}\PYGZlt{} endl;}
    \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{row\PYGZus{}out}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{row\PYGZus{}out}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{nodes}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{TreeNode} \PYG{o}{*}\PYG{n}{this\PYGZus{}node} \PYG{o}{=} \PYG{o}{\PYGZam{}}\PYG{p}{(}\PYG{o}{*}\PYG{n}{nodes}\PYG{p}{)}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{;}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{this\PYGZus{}node}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{isTip}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}}
           \PYG{n}{doubleCompare}\PYG{p}{(}\PYG{n}{this\PYGZus{}node}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{getGeneration}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{n}{current\PYGZus{}community\PYGZus{}parameters}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{time}\PYG{p}{,} \PYG{l+m+mf}{0.0001}\PYG{p}{)} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}}
           \PYG{n}{this\PYGZus{}node}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{getExistence}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifdef DEBUG}
            \PYG{k}{if}\PYG{p}{(}\PYG{n}{this\PYGZus{}node}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{getSpeciesID}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZgt{}}\PYG{o}{=} \PYG{n}{row\PYGZus{}out}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{k}{throw} \PYG{n}{out\PYGZus{}of\PYGZus{}range}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Node index out of range of abundances size. Please report this bug.}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif }\PYG{c+c1}{// DEBUG}
            \PYG{c+c1}{// The line that counts the number of individuals}
            \PYG{n}{row\PYGZus{}out}\PYG{p}{[}\PYG{n}{this\PYGZus{}node}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{getSpeciesID}\PYG{p}{(}\PYG{p}{)}\PYG{p}{]}\PYG{o}{+}\PYG{o}{+}\PYG{p}{;}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifdef DEBUG}
            \PYG{k}{if}\PYG{p}{(}\PYG{o}{!}\PYG{n}{samplemask}\PYG{p}{.}\PYG{n}{getMaskVal}\PYG{p}{(}\PYG{n}{this\PYGZus{}node}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{getXpos}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{n}{this\PYGZus{}node}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{getYpos}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,}
                                      \PYG{n}{this\PYGZus{}node}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{getXwrap}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{n}{this\PYGZus{}node}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{getYwrap}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}}
               \PYG{n}{doubleCompare}\PYG{p}{(}\PYG{n}{this\PYGZus{}node}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{getGeneration}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{n}{current\PYGZus{}community\PYGZus{}parameters}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{time}\PYG{p}{,} \PYG{l+m+mf}{0.0001}\PYG{p}{)}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{n}{stringstream} \PYG{n}{ss}\PYG{p}{;}
                \PYG{n}{ss} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{x,y }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{p}{(}\PYG{o}{*}\PYG{n}{nodes}\PYG{p}{)}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getXpos}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{, }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{p}{(}\PYG{o}{*}\PYG{n}{nodes}\PYG{p}{)}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getYpos}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
                \PYG{n}{ss} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{tip: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{p}{(}\PYG{o}{*}\PYG{n}{nodes}\PYG{p}{)}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{isTip}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ Existance: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{p}{(}\PYG{o}{*}\PYG{n}{nodes}\PYG{p}{)}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getExistence}\PYG{p}{(}\PYG{p}{)}
                     \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ samplemask: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{samplemask}\PYG{p}{.}\PYG{n}{getMaskVal}\PYG{p}{(}\PYG{n}{this\PYGZus{}node}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{getXpos}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{n}{this\PYGZus{}node}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{getYpos}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,}
                                                                 \PYG{n}{this\PYGZus{}node}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{getXwrap}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{n}{this\PYGZus{}node}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{getYwrap}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
                \PYG{n}{ss}
                        \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ERROR\PYGZus{}SQL\PYGZus{}005: Tip doesn\PYGZsq{}t exist. Something went wrong either in the importSpatialParameters or }\PYG{l+s}{\PYGZdq{}}
                                \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{main simulation running.}\PYG{l+s}{\PYGZdq{}}
                        \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
                \PYG{n}{writeWarning}\PYG{p}{(}\PYG{n}{ss}\PYG{p}{.}\PYG{n}{str}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}

            \PYG{p}{\PYGZcb{}}
            \PYG{k}{if}\PYG{p}{(}\PYG{n}{this\PYGZus{}node}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{getSpeciesID}\PYG{p}{(}\PYG{p}{)} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{0} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{n}{samplemask}\PYG{p}{.}\PYG{n}{getMaskVal}\PYG{p}{(}\PYG{n}{this\PYGZus{}node}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{getXpos}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{n}{this\PYGZus{}node}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{getYpos}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,}
                                                                       \PYG{n}{this\PYGZus{}node}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{getXwrap}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{n}{this\PYGZus{}node}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{getYwrap}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}}
               \PYG{n}{doubleCompare}\PYG{p}{(}\PYG{n}{this\PYGZus{}node}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{getGeneration}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{n}{current\PYGZus{}community\PYGZus{}parameters}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{time}\PYG{p}{,} \PYG{l+m+mf}{0.0001}\PYG{p}{)}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{n}{stringstream} \PYG{n}{ss}\PYG{p}{;}
                \PYG{n}{ss} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{x,y }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{this\PYGZus{}node}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{getXpos}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{, }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{this\PYGZus{}node}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{getYpos}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
                \PYG{n}{ss} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{generation (point,required): }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{this\PYGZus{}node}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{getGeneration}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{, }\PYG{l+s}{\PYGZdq{}}
                   \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{current\PYGZus{}community\PYGZus{}parameters}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{time} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
                \PYG{n}{TreeNode} \PYG{o}{*}\PYG{n}{p\PYGZus{}node} \PYG{o}{=} \PYG{o}{\PYGZam{}}\PYG{p}{(}\PYG{o}{*}\PYG{n}{nodes}\PYG{p}{)}\PYG{p}{[}\PYG{n}{this\PYGZus{}node}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{getParent}\PYG{p}{(}\PYG{p}{)}\PYG{p}{]}\PYG{p}{;}
                \PYG{n}{ss} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{samplemasktest: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{samplemask}\PYG{p}{.}\PYG{n}{getTestVal}\PYG{p}{(}\PYG{n}{this\PYGZus{}node}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{getXpos}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{n}{this\PYGZus{}node}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{getYpos}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,}
                                                                  \PYG{n}{this\PYGZus{}node}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{getXwrap}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{n}{this\PYGZus{}node}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{getYwrap}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
                \PYG{n}{ss} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{samplemask: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{samplemask}\PYG{p}{.}\PYG{n}{getVal}\PYG{p}{(}\PYG{n}{this\PYGZus{}node}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{getXpos}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{n}{this\PYGZus{}node}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{getYpos}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,}
                                                          \PYG{n}{this\PYGZus{}node}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{getXwrap}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{n}{this\PYGZus{}node}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{getYwrap}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
                \PYG{n}{ss} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{parent (tip, exists, generations): }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{p\PYGZus{}node}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{isTip}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{, }\PYG{l+s}{\PYGZdq{}}
                   \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{p\PYGZus{}node}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{getExistence}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{, }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{p\PYGZus{}node}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{getGeneration}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
                \PYG{n}{ss} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{species id zero \PYGZhy{} i: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{i} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ parent: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{p\PYGZus{}node}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{getParent}\PYG{p}{(}\PYG{p}{)}
                   \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ speciation\PYGZus{}probability: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{p\PYGZus{}node}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{getSpecRate}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{has speciated: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{p\PYGZus{}node}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{hasSpeciated}\PYG{p}{(}\PYG{p}{)}
                   \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
                \PYG{n}{writeCritical}\PYG{p}{(}\PYG{n}{ss}\PYG{p}{.}\PYG{n}{str}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
                \PYG{k}{throw} \PYG{n+nf}{runtime\PYGZus{}error}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Fatal, exiting program.}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif}
        \PYG{p}{\PYGZcb{}}
    \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{void} \PYG{n}{Community}\PYG{o}{:}\PYG{o}{:}\PYG{n}{resetTree}\PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{nodes}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{p}{(}\PYG{o}{*}\PYG{n}{nodes}\PYG{p}{)}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{qReset}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{void} \PYG{n}{Community}\PYG{o}{:}\PYG{o}{:}\PYG{n}{detectDimensions}\PYG{p}{(}\PYG{n}{string} \PYG{n}{db}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{n}{sqlite3} \PYG{o}{*}\PYG{n}{tmpdb}\PYG{p}{;}
    \PYG{k+kt}{int} \PYG{n}{rc} \PYG{o}{=} \PYG{n}{sqlite3\PYGZus{}open\PYGZus{}v2}\PYG{p}{(}\PYG{n}{db}\PYG{p}{.}\PYG{n}{c\PYGZus{}str}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{tmpdb}\PYG{p}{,} \PYG{n}{SQLITE\PYGZus{}OPEN\PYGZus{}READWRITE}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{unix\PYGZhy{}dotfile}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{string} \PYG{n}{to\PYGZus{}exec} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{SELECT MAX(xval),MAX(yval) FROM SPECIES\PYGZus{}LIST;}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
    \PYG{n}{sqlite3\PYGZus{}stmt} \PYG{o}{*}\PYG{n}{stmt}\PYG{p}{;}
    \PYG{n}{rc} \PYG{o}{=} \PYG{n}{sqlite3\PYGZus{}prepare\PYGZus{}v2}\PYG{p}{(}\PYG{n}{tmpdb}\PYG{p}{,} \PYG{n}{to\PYGZus{}exec}\PYG{p}{.}\PYG{n}{c\PYGZus{}str}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{n}{strlen}\PYG{p}{(}\PYG{n}{to\PYGZus{}exec}\PYG{p}{.}\PYG{n}{c\PYGZus{}str}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{stmt}\PYG{p}{,} \PYG{n+nb}{NULL}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{xvalmax}\PYG{p}{,} \PYG{n}{yvalmax}\PYG{p}{;}
    \PYG{n}{rc} \PYG{o}{=} \PYG{n}{sqlite3\PYGZus{}step}\PYG{p}{(}\PYG{n}{stmt}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{xvalmax} \PYG{o}{=} \PYG{k}{static\PYGZus{}cast}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{unsigned} \PYG{k+kt}{long}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{n}{sqlite3\PYGZus{}column\PYGZus{}int}\PYG{p}{(}\PYG{n}{stmt}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{yvalmax} \PYG{o}{=} \PYG{k}{static\PYGZus{}cast}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{unsigned} \PYG{k+kt}{long}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{n}{sqlite3\PYGZus{}column\PYGZus{}int}\PYG{p}{(}\PYG{n}{stmt}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{samplemask}\PYG{p}{.}\PYG{n}{sample\PYGZus{}mask}\PYG{p}{.}\PYG{n}{SetSize}\PYG{p}{(}\PYG{n}{xvalmax}\PYG{p}{,} \PYG{n}{yvalmax}\PYG{p}{)}\PYG{p}{;}
    \PYG{c+c1}{// close the old statement}
    \PYG{n}{rc} \PYG{o}{=} \PYG{n}{sqlite3\PYGZus{}finalize}\PYG{p}{(}\PYG{n}{stmt}\PYG{p}{)}\PYG{p}{;}
    \PYG{k}{if}\PYG{p}{(}\PYG{n}{rc} \PYG{o}{!}\PYG{o}{=} \PYG{n}{SQLITE\PYGZus{}OK} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{n}{rc} \PYG{o}{!}\PYG{o}{=} \PYG{n}{SQLITE\PYGZus{}DONE}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{cerr} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{rc: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{rc} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
        \PYG{k}{throw} \PYG{n+nf}{SpeciesException}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Could not detect dimensions}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{void} \PYG{n}{Community}\PYG{o}{:}\PYG{o}{:}\PYG{n}{openSqlConnection}\PYG{p}{(}\PYG{n}{string} \PYG{n}{inputfile}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{c+c1}{// open the database objects}
    \PYG{n}{sqlite3\PYGZus{}backup} \PYG{o}{*}\PYG{n}{backupdb}\PYG{p}{;}
    \PYG{c+c1}{// open one db in memory and one from the file.}
    \PYG{k}{try}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{openSQLiteDatabase}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{:memory:}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{database}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{openSQLiteDatabase}\PYG{p}{(}\PYG{n}{inputfile}\PYG{p}{,} \PYG{n}{outdatabase}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{bMem} \PYG{o}{=} \PYG{n+nb}{true}\PYG{p}{;}
        \PYG{c+c1}{// copy the db from file into memory.}
        \PYG{n}{backupdb} \PYG{o}{=} \PYG{n}{sqlite3\PYGZus{}backup\PYGZus{}init}\PYG{p}{(}\PYG{n}{database}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{main}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{outdatabase}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{main}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
        \PYG{k+kt}{int} \PYG{n}{rc} \PYG{o}{=} \PYG{n}{sqlite3\PYGZus{}backup\PYGZus{}step}\PYG{p}{(}\PYG{n}{backupdb}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}

        \PYG{k}{if}\PYG{p}{(}\PYG{n}{rc} \PYG{o}{!}\PYG{o}{=} \PYG{n}{SQLITE\PYGZus{}DONE} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{n}{rc} \PYG{o}{!}\PYG{o}{=} \PYG{n}{SQLITE\PYGZus{}OK}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{sqlite3\PYGZus{}close}\PYG{p}{(}\PYG{n}{outdatabase}\PYG{p}{)}\PYG{p}{;}
            \PYG{n}{sqlite3\PYGZus{}open}\PYG{p}{(}\PYG{n}{inputfile}\PYG{p}{.}\PYG{n}{c\PYGZus{}str}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{outdatabase}\PYG{p}{)}\PYG{p}{;}
            \PYG{n}{backupdb} \PYG{o}{=} \PYG{n}{sqlite3\PYGZus{}backup\PYGZus{}init}\PYG{p}{(}\PYG{n}{database}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{main}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{outdatabase}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{main}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{n}{rc} \PYG{o}{=} \PYG{n}{sqlite3\PYGZus{}backup\PYGZus{}finish}\PYG{p}{(}\PYG{n}{backupdb}\PYG{p}{)}\PYG{p}{;}
        \PYG{c+c1}{//          os \PYGZlt{}\PYGZlt{} \PYGZdq{}rc: \PYGZdq{} \PYGZlt{}\PYGZlt{} rc \PYGZlt{}\PYGZlt{} endl;}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{rc} \PYG{o}{!}\PYG{o}{=} \PYG{n}{SQLITE\PYGZus{}DONE} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{n}{rc} \PYG{o}{!}\PYG{o}{=} \PYG{n}{SQLITE\PYGZus{}OK}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{sqlite3\PYGZus{}close}\PYG{p}{(}\PYG{n}{database}\PYG{p}{)}\PYG{p}{;}
            \PYG{n}{sqlite3\PYGZus{}close}\PYG{p}{(}\PYG{n}{outdatabase}\PYG{p}{)}\PYG{p}{;}
            \PYG{k}{throw} \PYG{n+nf}{SpeciesException}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ERROR\PYGZus{}SQL\PYGZus{}002: FATAL. Source file cannot be opened.}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{n}{sqlite3\PYGZus{}close}\PYG{p}{(}\PYG{n}{outdatabase}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{catch}\PYG{p}{(}\PYG{n}{FatalException} \PYG{o}{\PYGZam{}}\PYG{n}{fe}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{writeWarning}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Can\PYGZsq{}t open in\PYGZhy{}memory database. Writing to file instead (this will be slower).}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{bMem} \PYG{o}{=} \PYG{n+nb}{false}\PYG{p}{;}
        \PYG{n}{sqlite3\PYGZus{}close}\PYG{p}{(}\PYG{n}{database}\PYG{p}{)}\PYG{p}{;}
        \PYG{k+kt}{int} \PYG{n}{rc} \PYG{o}{=} \PYG{n}{sqlite3\PYGZus{}open\PYGZus{}v2}\PYG{p}{(}\PYG{n}{inputfile}\PYG{p}{.}\PYG{n}{c\PYGZus{}str}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{database}\PYG{p}{,} \PYG{n}{SQLITE\PYGZus{}OPEN\PYGZus{}READWRITE}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{unix\PYGZhy{}dotfile}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
        \PYG{c+c1}{// Revert to different VFS file opening method if the backup hasn\PYGZsq{}t started properly.}
        \PYG{c+c1}{// Two different versions will be attempted before an error will be thrown.}
        \PYG{c+c1}{// A different way of assigning the VFS method and opening the file correctly could be implemented later.}
        \PYG{c+c1}{// Currently \PYGZdq{}unix\PYGZhy{}dotfile\PYGZdq{} works for HPC runs and \PYGZdq{}unix\PYGZdq{} works for PC runs.}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{rc} \PYG{o}{!}\PYG{o}{=} \PYG{n}{SQLITE\PYGZus{}OK}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{k}{throw} \PYG{n}{SpeciesException}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ERROR\PYGZus{}SQL\PYGZus{}002: FATAL. Source file cannot be opened. Error: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{+} \PYG{n}{string}\PYG{p}{(}\PYG{n}{fe}\PYG{p}{.}\PYG{n}{what}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)} \PYG{o}{+}
                                   \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ and }\PYG{l+s}{\PYGZdq{}} \PYG{o}{+} \PYG{n}{to\PYGZus{}string}\PYG{p}{(}\PYG{n}{rc}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
    \PYG{p}{\PYGZcb{}}
    \PYG{n}{bSqlConnection} \PYG{o}{=} \PYG{n+nb}{true}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{void} \PYG{n}{Community}\PYG{o}{:}\PYG{o}{:}\PYG{n}{setInternalDatabase}\PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{openSQLiteDatabase}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{:memory:}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{database}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{internalOption}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{void} \PYG{n}{Community}\PYG{o}{:}\PYG{o}{:}\PYG{n}{internalOption}\PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{n}{bDataImport} \PYG{o}{=} \PYG{n+nb}{true}\PYG{p}{;}
    \PYG{n}{bSqlConnection} \PYG{o}{=} \PYG{n+nb}{true}\PYG{p}{;}
    \PYG{n}{bFileSet} \PYG{o}{=} \PYG{n+nb}{true}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{void} \PYG{n}{Community}\PYG{o}{:}\PYG{o}{:}\PYG{n}{importData}\PYG{p}{(}\PYG{n}{string} \PYG{n}{inputfile}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k}{if}\PYG{p}{(}\PYG{o}{!}\PYG{n}{bSqlConnection}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{openSqlConnection}\PYG{p}{(}\PYG{n}{inputfile}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{if}\PYG{p}{(}\PYG{o}{!}\PYG{n}{bDataImport}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{importSimParameters}\PYG{p}{(}\PYG{n}{inputfile}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{if}\PYG{p}{(}\PYG{n}{nodes}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)} \PYG{o}{!}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{return}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{n}{writeInfo}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Beginning data import...}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{c+c1}{// The sql statement to store the sql statement message object}
    \PYG{n}{sqlite3\PYGZus{}stmt} \PYG{o}{*}\PYG{n}{stmt}\PYG{p}{;}

    \PYG{c+c1}{// Now find out the max size of the list, so we have a count to work from}
    \PYG{n}{string} \PYG{n}{count\PYGZus{}command} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{SELECT COUNT(*) FROM SPECIES\PYGZus{}LIST;}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
    \PYG{n}{sqlite3\PYGZus{}prepare\PYGZus{}v2}\PYG{p}{(}\PYG{n}{database}\PYG{p}{,} \PYG{n}{count\PYGZus{}command}\PYG{p}{.}\PYG{n}{c\PYGZus{}str}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{k}{static\PYGZus{}cast}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{n}{strlen}\PYG{p}{(}\PYG{n}{count\PYGZus{}command}\PYG{p}{.}\PYG{n}{c\PYGZus{}str}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{stmt}\PYG{p}{,}
                       \PYG{k}{nullptr}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{datasize}\PYG{p}{;}
    \PYG{c+c1}{// skip first row (should be blank)}
    \PYG{n}{sqlite3\PYGZus{}step}\PYG{p}{(}\PYG{n}{stmt}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{datasize} \PYG{o}{=} \PYG{k}{static\PYGZus{}cast}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{unsigned} \PYG{k+kt}{long}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{n}{sqlite3\PYGZus{}column\PYGZus{}int}\PYG{p}{(}\PYG{n}{stmt}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
    \PYG{c+c1}{//      os \PYGZlt{}\PYGZlt{} \PYGZdq{}datasize: \PYGZdq{} \PYGZlt{}\PYGZlt{} datasize \PYGZlt{}\PYGZlt{} endl;}
    \PYG{c+c1}{// close the old statement}
    \PYG{n}{sqlite3\PYGZus{}finalize}\PYG{p}{(}\PYG{n}{stmt}\PYG{p}{)}\PYG{p}{;}

    \PYG{c+c1}{// Create db query}
    \PYG{n}{string} \PYG{n}{all\PYGZus{}commands} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{SELECT * FROM SPECIES\PYGZus{}LIST;}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
    \PYG{n}{sqlite3\PYGZus{}prepare\PYGZus{}v2}\PYG{p}{(}\PYG{n}{database}\PYG{p}{,} \PYG{n}{all\PYGZus{}commands}\PYG{p}{.}\PYG{n}{c\PYGZus{}str}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{k}{static\PYGZus{}cast}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{n}{strlen}\PYG{p}{(}\PYG{n}{all\PYGZus{}commands}\PYG{p}{.}\PYG{n}{c\PYGZus{}str}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{stmt}\PYG{p}{,} \PYG{k}{nullptr}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{nodes}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{setSize}\PYG{p}{(}\PYG{n}{datasize} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
    \PYG{c+c1}{// Check that the file opened correctly.}
    \PYG{n}{sqlite3\PYGZus{}step}\PYG{p}{(}\PYG{n}{stmt}\PYG{p}{)}\PYG{p}{;}
    \PYG{c+c1}{// Copy the data across to the TreeNode data structure.}
    \PYG{c+c1}{// For storing the number of ignored lineages so this can be subtracted off the parent number.}
    \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{ignored\PYGZus{}lineages} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifdef DEBUG}
    \PYG{k+kt}{bool} \PYG{n}{has\PYGZus{}printed\PYGZus{}error} \PYG{o}{=} \PYG{n+nb}{false}\PYG{p}{;}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif}
    \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{n}{datasize}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{auto} \PYG{n}{species\PYGZus{}id} \PYG{o}{=} \PYG{k}{static\PYGZus{}cast}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{unsigned} \PYG{k+kt}{long}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{n}{sqlite3\PYGZus{}column\PYGZus{}int}\PYG{p}{(}\PYG{n}{stmt}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
        \PYG{c+c1}{//      os \PYGZlt{}\PYGZlt{} species\PYGZus{}id \PYGZlt{}\PYGZlt{} endl;}
        \PYG{k+kt}{long} \PYG{n}{xval} \PYG{o}{=} \PYG{n}{sqlite3\PYGZus{}column\PYGZus{}int}\PYG{p}{(}\PYG{n}{stmt}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{;}
        \PYG{k+kt}{long} \PYG{n}{yval} \PYG{o}{=} \PYG{n}{sqlite3\PYGZus{}column\PYGZus{}int}\PYG{p}{(}\PYG{n}{stmt}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{;}
        \PYG{k+kt}{long} \PYG{n}{xwrap} \PYG{o}{=} \PYG{n}{sqlite3\PYGZus{}column\PYGZus{}int}\PYG{p}{(}\PYG{n}{stmt}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{;}
        \PYG{k+kt}{long} \PYG{n}{ywrap} \PYG{o}{=} \PYG{n}{sqlite3\PYGZus{}column\PYGZus{}int}\PYG{p}{(}\PYG{n}{stmt}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{auto} \PYG{n}{tip} \PYG{o}{=} \PYG{k+kt}{bool}\PYG{p}{(}\PYG{n}{sqlite3\PYGZus{}column\PYGZus{}int}\PYG{p}{(}\PYG{n}{stmt}\PYG{p}{,} \PYG{l+m+mi}{6}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{auto} \PYG{n}{speciation} \PYG{o}{=} \PYG{k+kt}{bool}\PYG{p}{(}\PYG{n}{sqlite3\PYGZus{}column\PYGZus{}int}\PYG{p}{(}\PYG{n}{stmt}\PYG{p}{,} \PYG{l+m+mi}{7}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{auto} \PYG{n}{parent} \PYG{o}{=} \PYG{k}{static\PYGZus{}cast}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{unsigned} \PYG{k+kt}{long}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{n}{sqlite3\PYGZus{}column\PYGZus{}int}\PYG{p}{(}\PYG{n}{stmt}\PYG{p}{,} \PYG{l+m+mi}{8}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{auto} \PYG{n}{iGen} \PYG{o}{=} \PYG{k}{static\PYGZus{}cast}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{unsigned} \PYG{k+kt}{long}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{n}{sqlite3\PYGZus{}column\PYGZus{}int}\PYG{p}{(}\PYG{n}{stmt}\PYG{p}{,} \PYG{l+m+mi}{11}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{auto} \PYG{n}{existence} \PYG{o}{=} \PYG{k+kt}{bool}\PYG{p}{(}\PYG{n}{sqlite3\PYGZus{}column\PYGZus{}int}\PYG{p}{(}\PYG{n}{stmt}\PYG{p}{,} \PYG{l+m+mi}{9}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
        \PYG{k+kt}{double} \PYG{n}{dSpec} \PYG{o}{=} \PYG{n}{sqlite3\PYGZus{}column\PYGZus{}double}\PYG{p}{(}\PYG{n}{stmt}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{;}
        \PYG{k+kt}{long} \PYG{k+kt}{double} \PYG{n}{generationin} \PYG{o}{=} \PYG{n}{sqlite3\PYGZus{}column\PYGZus{}double}\PYG{p}{(}\PYG{n}{stmt}\PYG{p}{,} \PYG{l+m+mi}{12}\PYG{p}{)}\PYG{p}{;}
        \PYG{c+c1}{//          os \PYGZlt{}\PYGZlt{} xval \PYGZlt{}\PYGZlt{} \PYGZdq{}, \PYGZdq{} \PYGZlt{}\PYGZlt{} yval \PYGZlt{}\PYGZlt{} endl;}
        \PYG{c+c1}{// ignored lineages are now not ignored!}
        \PYG{c+c1}{// TODO fix this properly and check functionality}
\PYG{c+c1}{//      if(tip \PYGZam{}\PYGZam{} !samplemask.getVal(xval, yval) \PYGZam{}\PYGZam{} generationin \PYGZgt{} generation \PYGZam{}\PYGZam{} false)}
\PYG{c+c1}{//      \PYGZob{}}
\PYG{c+c1}{//          ignored\PYGZus{}lineages++;}
\PYG{c+c1}{//          sqlite3\PYGZus{}step(stmt);}
\PYG{c+c1}{//      \PYGZcb{}}
\PYG{c+c1}{//      else}
\PYG{c+c1}{//      \PYGZob{}}
        \PYG{c+c1}{// the \PYGZhy{}1 is to ensure that the list includes all lineages, but fills the output from the beginning}
        \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{index} \PYG{o}{=} \PYG{n}{i} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{1} \PYG{o}{\PYGZhy{}} \PYG{n}{ignored\PYGZus{}lineages}\PYG{p}{;}
        \PYG{p}{(}\PYG{o}{*}\PYG{n}{nodes}\PYG{p}{)}\PYG{p}{[}\PYG{n}{index}\PYG{p}{]}\PYG{p}{.}\PYG{n}{setup}\PYG{p}{(}\PYG{n}{tip}\PYG{p}{,} \PYG{n}{xval}\PYG{p}{,} \PYG{n}{yval}\PYG{p}{,} \PYG{n}{xwrap}\PYG{p}{,} \PYG{n}{ywrap}\PYG{p}{,} \PYG{n}{generationin}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{(}\PYG{o}{*}\PYG{n}{nodes}\PYG{p}{)}\PYG{p}{[}\PYG{n}{index}\PYG{p}{]}\PYG{p}{.}\PYG{n}{burnSpecies}\PYG{p}{(}\PYG{n}{species\PYGZus{}id}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{(}\PYG{o}{*}\PYG{n}{nodes}\PYG{p}{)}\PYG{p}{[}\PYG{n}{index}\PYG{p}{]}\PYG{p}{.}\PYG{n}{setSpec}\PYG{p}{(}\PYG{n}{dSpec}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{(}\PYG{o}{*}\PYG{n}{nodes}\PYG{p}{)}\PYG{p}{[}\PYG{n}{index}\PYG{p}{]}\PYG{p}{.}\PYG{n}{setExistence}\PYG{p}{(}\PYG{n}{existence}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{(}\PYG{o}{*}\PYG{n}{nodes}\PYG{p}{)}\PYG{p}{[}\PYG{n}{index}\PYG{p}{]}\PYG{p}{.}\PYG{n}{setGenerationRate}\PYG{p}{(}\PYG{n}{iGen}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{(}\PYG{o}{*}\PYG{n}{nodes}\PYG{p}{)}\PYG{p}{[}\PYG{n}{index}\PYG{p}{]}\PYG{p}{.}\PYG{n}{setParent}\PYG{p}{(}\PYG{n}{parent} \PYG{o}{\PYGZhy{}} \PYG{n}{ignored\PYGZus{}lineages}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{index} \PYG{o}{=}\PYG{o}{=} \PYG{n}{parent} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{n}{parent} \PYG{o}{!}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{cerr} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ i: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{index} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ parent: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{parent} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
            \PYG{n}{cerr} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ERROR\PYGZus{}SQL\PYGZus{}001: Import failed as parent is self. Check importSpatialParameters function.}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{p}{(}\PYG{o}{*}\PYG{n}{nodes}\PYG{p}{)}\PYG{p}{[}\PYG{n}{index}\PYG{p}{]}\PYG{p}{.}\PYG{n}{setSpeciation}\PYG{p}{(}\PYG{n}{speciation}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{sqlite3\PYGZus{}step}\PYG{p}{(}\PYG{n}{stmt}\PYG{p}{)}\PYG{p}{;}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifdef DEBUG}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{parent} \PYG{o}{\PYGZlt{}} \PYG{n}{index} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{o}{!}\PYG{n}{speciation}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{k}{if}\PYG{p}{(}\PYG{o}{!}\PYG{n}{has\PYGZus{}printed\PYGZus{}error}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{n}{stringstream} \PYG{n}{ss}\PYG{p}{;}
                \PYG{n}{ss} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{parent: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{parent} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ index: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{index} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
                \PYG{n}{ss} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Parent before index error. Check program.}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
                \PYG{n}{has\PYGZus{}printed\PYGZus{}error} \PYG{o}{=} \PYG{n+nb}{true}\PYG{p}{;}
                \PYG{n}{writeWarning}\PYG{p}{(}\PYG{n}{ss}\PYG{p}{.}\PYG{n}{str}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
        \PYG{p}{\PYGZcb{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif}
\PYG{c+c1}{//      \PYGZcb{}}
    \PYG{p}{\PYGZcb{}}
    \PYG{c+c1}{// Now we need to blank all objects}
    \PYG{n}{sqlite3\PYGZus{}finalize}\PYG{p}{(}\PYG{n}{stmt}\PYG{p}{)}\PYG{p}{;}
    \PYG{c+c1}{// Now read the useful information from the SIMULATION\PYGZus{}PARAMETERS table}
    \PYG{n}{writeInfo}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}r}\PYG{l+s}{Beginning data import...done}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{void} \PYG{n}{Community}\PYG{o}{:}\PYG{o}{:}\PYG{n}{getMaxSpeciesAbundancesID}\PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k}{if}\PYG{p}{(}\PYG{o}{!}\PYG{n}{bSqlConnection}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{throw} \PYG{n}{FatalException}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Attempted to get from sql database without opening database connection.}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{if}\PYG{p}{(}\PYG{n}{max\PYGZus{}species\PYGZus{}id} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{sqlite3\PYGZus{}stmt} \PYG{o}{*}\PYG{n}{stmt}\PYG{p}{;}
        \PYG{c+c1}{// Now find out the max size of the list, so we have a count to work from}
        \PYG{n}{string} \PYG{n}{count\PYGZus{}command} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{SELECT MAX(ID) FROM SPECIES\PYGZus{}ABUNDANCES;}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
        \PYG{n}{sqlite3\PYGZus{}prepare\PYGZus{}v2}\PYG{p}{(}\PYG{n}{database}\PYG{p}{,} \PYG{n}{count\PYGZus{}command}\PYG{p}{.}\PYG{n}{c\PYGZus{}str}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{k}{static\PYGZus{}cast}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{n}{strlen}\PYG{p}{(}\PYG{n}{count\PYGZus{}command}\PYG{p}{.}\PYG{n}{c\PYGZus{}str}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{stmt}\PYG{p}{,}
                           \PYG{k}{nullptr}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{sqlite3\PYGZus{}step}\PYG{p}{(}\PYG{n}{stmt}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{max\PYGZus{}species\PYGZus{}id} \PYG{o}{=} \PYG{k}{static\PYGZus{}cast}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{unsigned} \PYG{k+kt}{long}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{n}{sqlite3\PYGZus{}column\PYGZus{}int}\PYG{p}{(}\PYG{n}{stmt}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{)} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{p}{;}
        \PYG{c+c1}{// close the old statement}
        \PYG{n}{sqlite3\PYGZus{}finalize}\PYG{p}{(}\PYG{n}{stmt}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}

\PYG{n}{Row}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{unsigned} \PYG{k+kt}{long}\PYG{o}{\PYGZgt{}} \PYG{o}{*} \PYG{n}{Community}\PYG{o}{:}\PYG{o}{:}\PYG{n}{getCumulativeAbundances}\PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{total} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
    \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{row\PYGZus{}out}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{n}{i} \PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{total} \PYG{o}{+}\PYG{o}{=} \PYG{n}{row\PYGZus{}out}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{;}
        \PYG{n}{row\PYGZus{}out}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{=} \PYG{n}{total}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{return} \PYG{o}{\PYGZam{}}\PYG{n}{row\PYGZus{}out}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{n}{Row}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{unsigned} \PYG{k+kt}{long}\PYG{o}{\PYGZgt{}} \PYG{n}{Community}\PYG{o}{:}\PYG{o}{:}\PYG{n}{getRowOut}\PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k}{return} \PYG{n}{row\PYGZus{}out}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{Community}\PYG{o}{:}\PYG{o}{:}\PYG{n}{getSpeciesNumber}\PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k}{return} \PYG{n}{iSpecies}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{void} \PYG{n}{Community}\PYG{o}{:}\PYG{o}{:}\PYG{n}{getMaxSpeciesLocationsID}\PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k}{if}\PYG{p}{(}\PYG{o}{!}\PYG{n}{bSqlConnection}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{throw} \PYG{n}{FatalException}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Attempted to get from sql database without opening database connection.}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{if}\PYG{p}{(}\PYG{n}{max\PYGZus{}locations\PYGZus{}id} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{sqlite3\PYGZus{}stmt} \PYG{o}{*}\PYG{n}{stmt}\PYG{p}{;}
        \PYG{c+c1}{// Now find out the max size of the list, so we have a count to work from}
        \PYG{n}{string} \PYG{n}{count\PYGZus{}command} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{SELECT MAX(ID) FROM SPECIES\PYGZus{}LOCATIONS;}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
        \PYG{n}{sqlite3\PYGZus{}prepare\PYGZus{}v2}\PYG{p}{(}\PYG{n}{database}\PYG{p}{,} \PYG{n}{count\PYGZus{}command}\PYG{p}{.}\PYG{n}{c\PYGZus{}str}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{k}{static\PYGZus{}cast}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{n}{strlen}\PYG{p}{(}\PYG{n}{count\PYGZus{}command}\PYG{p}{.}\PYG{n}{c\PYGZus{}str}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{stmt}\PYG{p}{,}
                           \PYG{k}{nullptr}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{sqlite3\PYGZus{}step}\PYG{p}{(}\PYG{n}{stmt}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{max\PYGZus{}locations\PYGZus{}id} \PYG{o}{=} \PYG{k}{static\PYGZus{}cast}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{unsigned} \PYG{k+kt}{long}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{n}{sqlite3\PYGZus{}column\PYGZus{}int}\PYG{p}{(}\PYG{n}{stmt}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{)} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{p}{;}
        \PYG{c+c1}{// close the old statement}
        \PYG{n}{sqlite3\PYGZus{}finalize}\PYG{p}{(}\PYG{n}{stmt}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{void} \PYG{n}{Community}\PYG{o}{:}\PYG{o}{:}\PYG{n}{getMaxFragmentAbundancesID}\PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k}{if}\PYG{p}{(}\PYG{o}{!}\PYG{n}{bSqlConnection}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{throw} \PYG{n}{FatalException}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Attempted to get from sql database without opening database connection.}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{if}\PYG{p}{(}\PYG{n}{max\PYGZus{}fragment\PYGZus{}id} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{sqlite3\PYGZus{}stmt} \PYG{o}{*}\PYG{n}{stmt}\PYG{p}{;}
        \PYG{c+c1}{// Now find out the max size of the list, so we have a count to work from}
        \PYG{n}{string} \PYG{n}{count\PYGZus{}command} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{SELECT MAX(ID) FROM FRAGMENT\PYGZus{}ABUNDANCES;}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
        \PYG{n}{sqlite3\PYGZus{}prepare\PYGZus{}v2}\PYG{p}{(}\PYG{n}{database}\PYG{p}{,} \PYG{n}{count\PYGZus{}command}\PYG{p}{.}\PYG{n}{c\PYGZus{}str}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{k}{static\PYGZus{}cast}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{n}{strlen}\PYG{p}{(}\PYG{n}{count\PYGZus{}command}\PYG{p}{.}\PYG{n}{c\PYGZus{}str}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{stmt}\PYG{p}{,}
                           \PYG{k}{nullptr}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{sqlite3\PYGZus{}step}\PYG{p}{(}\PYG{n}{stmt}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{max\PYGZus{}fragment\PYGZus{}id} \PYG{o}{=} \PYG{k}{static\PYGZus{}cast}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{unsigned} \PYG{k+kt}{long}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{n}{sqlite3\PYGZus{}column\PYGZus{}int}\PYG{p}{(}\PYG{n}{stmt}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{)} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{p}{;}
        \PYG{c+c1}{// close the old statement}
        \PYG{n}{sqlite3\PYGZus{}finalize}\PYG{p}{(}\PYG{n}{stmt}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{void} \PYG{n}{Community}\PYG{o}{:}\PYG{o}{:}\PYG{n}{createDatabase}\PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{n}{generateCoalescenceTree}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{stringstream} \PYG{n}{os}\PYG{p}{;}
    \PYG{n}{os} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Generating new SQL table for speciation rate }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{current\PYGZus{}community\PYGZus{}parameters}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{speciation\PYGZus{}rate}
       \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{...}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{flush}\PYG{p}{;}
    \PYG{n}{writeInfo}\PYG{p}{(}\PYG{n}{os}\PYG{p}{.}\PYG{n}{str}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{string} \PYG{n}{table\PYGZus{}command} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{CREATE TABLE IF NOT EXISTS SPECIES\PYGZus{}ABUNDANCES (ID int PRIMARY KEY NOT NULL, }\PYG{l+s}{\PYGZdq{}}
            \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{species\PYGZus{}id INT NOT NULL, no\PYGZus{}individuals INT NOT }\PYG{l+s}{\PYGZdq{}}
            \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{NULL, community\PYGZus{}reference INT NOT NULL);}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
    \PYG{k+kt}{int} \PYG{n}{rc} \PYG{o}{=} \PYG{n}{sqlite3\PYGZus{}exec}\PYG{p}{(}\PYG{n}{database}\PYG{p}{,} \PYG{n}{table\PYGZus{}command}\PYG{p}{.}\PYG{n}{c\PYGZus{}str}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{k}{nullptr}\PYG{p}{,} \PYG{k}{nullptr}\PYG{p}{,} \PYG{k}{nullptr}\PYG{p}{)}\PYG{p}{;}
    \PYG{k}{if}\PYG{p}{(}\PYG{n}{rc} \PYG{o}{!}\PYG{o}{=} \PYG{n}{SQLITE\PYGZus{}OK}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{throw} \PYG{n}{SpeciesException}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ERROR\PYGZus{}SQL\PYGZus{}002b: Could not create SPECIES\PYGZus{}ABUNDANCES table.}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{n}{getMaxSpeciesAbundancesID}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{outputSpeciesAbundances}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{void} \PYG{n}{Community}\PYG{o}{:}\PYG{o}{:}\PYG{n}{generateCoalescenceTree}\PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{n}{writeInfo}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Calculating tree structure...}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{c+c1}{// Search through past speciation rates}
    \PYG{k}{if}\PYG{p}{(}\PYG{n}{current\PYGZus{}community\PYGZus{}parameters}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{speciation\PYGZus{}rate} \PYG{o}{\PYGZlt{}} \PYG{n}{min\PYGZus{}spec\PYGZus{}rate}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{doubleCompare}\PYG{p}{(}\PYG{n}{current\PYGZus{}community\PYGZus{}parameters}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{speciation\PYGZus{}rate}\PYG{p}{,} \PYG{n}{min\PYGZus{}spec\PYGZus{}rate}\PYG{p}{,} \PYG{n}{min\PYGZus{}spec\PYGZus{}rate} \PYG{o}{*} \PYG{l+m+mf}{0.000001}\PYG{p}{)}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{current\PYGZus{}community\PYGZus{}parameters}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{speciation\PYGZus{}rate} \PYG{o}{=} \PYG{n}{min\PYGZus{}spec\PYGZus{}rate}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{else}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{stringstream} \PYG{n}{ss}\PYG{p}{;}
            \PYG{n}{ss} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ERROR\PYGZus{}SQL\PYGZus{}018: Speciation rate of }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{current\PYGZus{}community\PYGZus{}parameters}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{speciation\PYGZus{}rate}\PYG{p}{;}
            \PYG{n}{ss} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ is less than the minimum possible (}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{min\PYGZus{}spec\PYGZus{}rate} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{. Skipping.}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
            \PYG{k}{throw} \PYG{n+nf}{SpeciesException}\PYG{p}{(}\PYG{n}{ss}\PYG{p}{.}\PYG{n}{str}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
    \PYG{p}{\PYGZcb{}}
    \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{nspec} \PYG{o}{=} \PYG{n}{calcSpecies}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{calcSpeciesAbundance}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{stringstream} \PYG{n}{os}\PYG{p}{;}
    \PYG{n}{os} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{done!}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
    \PYG{n}{os} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Number of species: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{nspec} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
    \PYG{n}{writeInfo}\PYG{p}{(}\PYG{n}{os}\PYG{p}{.}\PYG{n}{str}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{os}\PYG{p}{.}\PYG{n}{str}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{void} \PYG{n}{Community}\PYG{o}{:}\PYG{o}{:}\PYG{n}{outputSpeciesAbundances}\PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{c+c1}{// Only write to SPECIES\PYGZus{}ABUNDANCES if the speciation rate has not already been applied}
    \PYG{k}{if}\PYG{p}{(}\PYG{o}{!}\PYG{n}{current\PYGZus{}community\PYGZus{}parameters}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{updated}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
\PYG{c+c1}{//\PYGZsh{}ifdef DEBUG}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{checkSpeciesAbundancesReference}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{stringstream} \PYG{n}{ss}\PYG{p}{;}
            \PYG{n}{ss} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Duplicate insertion of }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{current\PYGZus{}community\PYGZus{}parameters}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{reference} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{into SPECIES\PYGZus{}ABUNDANCES.}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
            \PYG{n}{ss} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
            \PYG{n}{writeWarning}\PYG{p}{(}\PYG{n}{ss}\PYG{p}{.}\PYG{n}{str}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
            \PYG{k}{return}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
\PYG{c+c1}{//\PYGZsh{}endif // DEBUG}
        \PYG{n}{sqlite3\PYGZus{}stmt} \PYG{o}{*}\PYG{n}{stmt}\PYG{p}{;}
        \PYG{n}{string} \PYG{n}{table\PYGZus{}command} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{INSERT INTO SPECIES\PYGZus{}ABUNDANCES (ID, species\PYGZus{}id, }\PYG{l+s}{\PYGZdq{}}
                \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{no\PYGZus{}individuals, community\PYGZus{}reference) VALUES (?,?,?,?);}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
        \PYG{n}{sqlite3\PYGZus{}prepare\PYGZus{}v2}\PYG{p}{(}\PYG{n}{database}\PYG{p}{,} \PYG{n}{table\PYGZus{}command}\PYG{p}{.}\PYG{n}{c\PYGZus{}str}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{k}{static\PYGZus{}cast}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{n}{strlen}\PYG{p}{(}\PYG{n}{table\PYGZus{}command}\PYG{p}{.}\PYG{n}{c\PYGZus{}str}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{stmt}\PYG{p}{,}
                           \PYG{k}{nullptr}\PYG{p}{)}\PYG{p}{;}

        \PYG{c+c1}{// Start the transaction}
        \PYG{n}{sqlite3\PYGZus{}exec}\PYG{p}{(}\PYG{n}{database}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{BEGIN TRANSACTION;}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{k}{nullptr}\PYG{p}{,} \PYG{k}{nullptr}\PYG{p}{,} \PYG{k}{nullptr}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{row\PYGZus{}out}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{c+c1}{// only do all the export itself if the value of i is not 0}
            \PYG{c+c1}{// if(row\PYGZus{}out[i] != 0)}
            \PYG{c+c1}{//\PYGZob{}}

            \PYG{c+c1}{// fixed precision problem \PYGZhy{} lexical cast allows for printing of very small doubles.}
            \PYG{n}{sqlite3\PYGZus{}bind\PYGZus{}int}\PYG{p}{(}\PYG{n}{stmt}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{k}{static\PYGZus{}cast}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{n}{max\PYGZus{}species\PYGZus{}id}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
            \PYG{n}{sqlite3\PYGZus{}bind\PYGZus{}int}\PYG{p}{(}\PYG{n}{stmt}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{k}{static\PYGZus{}cast}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{n}{i}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
            \PYG{n}{sqlite3\PYGZus{}bind\PYGZus{}int}\PYG{p}{(}\PYG{n}{stmt}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{n}{row\PYGZus{}out}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
            \PYG{n}{sqlite3\PYGZus{}bind\PYGZus{}int}\PYG{p}{(}\PYG{n}{stmt}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{k}{static\PYGZus{}cast}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{n}{current\PYGZus{}community\PYGZus{}parameters}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{reference}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
            \PYG{k+kt}{int} \PYG{n}{step} \PYG{o}{=} \PYG{n}{sqlite3\PYGZus{}step}\PYG{p}{(}\PYG{n}{stmt}\PYG{p}{)}\PYG{p}{;}
            \PYG{c+c1}{// makes sure the while loop doesn\PYGZsq{}t go forever.}
            \PYG{k+kt}{time\PYGZus{}t} \PYG{n}{start\PYGZus{}check}\PYG{p}{,} \PYG{n}{end\PYGZus{}check}\PYG{p}{;}
            \PYG{n}{time}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{start\PYGZus{}check}\PYG{p}{)}\PYG{p}{;}
            \PYG{n}{time}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{end\PYGZus{}check}\PYG{p}{)}\PYG{p}{;}
            \PYG{k}{while}\PYG{p}{(}\PYG{n}{step} \PYG{o}{!}\PYG{o}{=} \PYG{n}{SQLITE\PYGZus{}DONE} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{p}{(}\PYG{n}{end\PYGZus{}check} \PYG{o}{\PYGZhy{}} \PYG{n}{start\PYGZus{}check}\PYG{p}{)} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{1}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{n}{step} \PYG{o}{=} \PYG{n}{sqlite3\PYGZus{}step}\PYG{p}{(}\PYG{n}{stmt}\PYG{p}{)}\PYG{p}{;}
                \PYG{n}{time}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{end\PYGZus{}check}\PYG{p}{)}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
            \PYG{k}{if}\PYG{p}{(}\PYG{n}{step} \PYG{o}{!}\PYG{o}{=} \PYG{n}{SQLITE\PYGZus{}DONE}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{n}{stringstream} \PYG{n}{os}\PYG{p}{;}
                \PYG{n}{os} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{SQLITE error code: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{step} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
                \PYG{n}{os} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ERROR\PYGZus{}SQL\PYGZus{}004d: Could not insert into database. Check destination file has not }\PYG{l+s}{\PYGZdq{}}
                        \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{been moved or deleted and that an entry doesn\PYGZsq{}t already exist with the same ID.}\PYG{l+s}{\PYGZdq{}}
                   \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
                \PYG{n}{os} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{sqlite3\PYGZus{}errmsg}\PYG{p}{(}\PYG{n}{database}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
                \PYG{n}{sqlite3\PYGZus{}clear\PYGZus{}bindings}\PYG{p}{(}\PYG{n}{stmt}\PYG{p}{)}\PYG{p}{;}
                \PYG{n}{sqlite3\PYGZus{}reset}\PYG{p}{(}\PYG{n}{stmt}\PYG{p}{)}\PYG{p}{;}
                \PYG{k}{throw} \PYG{n+nf}{FatalException}\PYG{p}{(}\PYG{n}{os}\PYG{p}{.}\PYG{n}{str}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
            \PYG{n}{sqlite3\PYGZus{}clear\PYGZus{}bindings}\PYG{p}{(}\PYG{n}{stmt}\PYG{p}{)}\PYG{p}{;}
            \PYG{n}{sqlite3\PYGZus{}reset}\PYG{p}{(}\PYG{n}{stmt}\PYG{p}{)}\PYG{p}{;}

        \PYG{p}{\PYGZcb{}}
        \PYG{c+c1}{// execute the command and close the connection to the database}
        \PYG{k+kt}{int} \PYG{n}{rc1} \PYG{o}{=} \PYG{n}{sqlite3\PYGZus{}exec}\PYG{p}{(}\PYG{n}{database}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{END TRANSACTION;}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{k}{nullptr}\PYG{p}{,} \PYG{k}{nullptr}\PYG{p}{,} \PYG{k}{nullptr}\PYG{p}{)}\PYG{p}{;}
        \PYG{c+c1}{// Need to finalise the statement}
        \PYG{k+kt}{int} \PYG{n}{rc2} \PYG{o}{=} \PYG{n}{sqlite3\PYGZus{}finalize}\PYG{p}{(}\PYG{n}{stmt}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{rc1} \PYG{o}{!}\PYG{o}{=} \PYG{n}{SQLITE\PYGZus{}OK} \PYG{o}{\textbar{}}\PYG{o}{\textbar{}} \PYG{n}{rc2} \PYG{o}{!}\PYG{o}{=} \PYG{n}{SQLITE\PYGZus{}OK}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{cerr} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ERROR\PYGZus{}SQL\PYGZus{}013: Could not complete SQL transaction. Check memory database assignment and }\PYG{l+s}{\PYGZdq{}}
                    \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{SQL commands. Ensure SQL statements are properly cleared and that you are not attempting }\PYG{l+s}{\PYGZdq{}}
                    \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{to insert repeat IDs into the database.}\PYG{l+s}{\PYGZdq{}}
                 \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{else}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{stringstream} \PYG{n}{ss}\PYG{p}{;}
            \PYG{n}{ss} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}r}\PYG{l+s}{Generating new SQL table for speciation rate }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{current\PYGZus{}community\PYGZus{}parameters}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{speciation\PYGZus{}rate}
               \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{...done!}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
            \PYG{n}{writeInfo}\PYG{p}{(}\PYG{n}{ss}\PYG{p}{.}\PYG{n}{str}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{else}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{stringstream} \PYG{n}{ss}\PYG{p}{;}
        \PYG{n}{ss} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{parameters already applied, not outputting SPECIES\PYGZus{}ABUNDANCES table...}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
        \PYG{n}{writeInfo}\PYG{p}{(}\PYG{n}{ss}\PYG{p}{.}\PYG{n}{str}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{bool} \PYG{n}{Community}\PYG{o}{:}\PYG{o}{:}\PYG{n}{checkCalculationsPerformed}\PYG{p}{(}\PYG{k+kt}{long} \PYG{k+kt}{double} \PYG{n}{speciation\PYGZus{}rate}\PYG{p}{,} \PYG{k+kt}{double} \PYG{n}{time}\PYG{p}{,} \PYG{k+kt}{bool} \PYG{n}{fragments}\PYG{p}{,}
                                          \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{metacommunity\PYGZus{}size}\PYG{p}{,} \PYG{k+kt}{long} \PYG{k+kt}{double} \PYG{n}{metacommunity\PYGZus{}speciation\PYGZus{}rate}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k}{auto} \PYG{n}{metacommunity\PYGZus{}reference} \PYG{o}{=} \PYG{n}{past\PYGZus{}metacommunities}\PYG{p}{.}\PYG{n}{getReference}\PYG{p}{(}\PYG{n}{metacommunity\PYGZus{}speciation\PYGZus{}rate}\PYG{p}{,} \PYG{n}{metacommunity\PYGZus{}size}\PYG{p}{)}\PYG{p}{;}
    \PYG{k}{if}\PYG{p}{(}\PYG{n}{metacommunity\PYGZus{}reference} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{0} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}}  \PYG{n}{metacommunity\PYGZus{}size} \PYG{o}{!}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{return} \PYG{n+nb}{false}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{k+kt}{bool} \PYG{n}{has\PYGZus{}pair} \PYG{o}{=} \PYG{n}{past\PYGZus{}communities}\PYG{p}{.}\PYG{n}{hasPair}\PYG{p}{(}\PYG{n}{speciation\PYGZus{}rate}\PYG{p}{,} \PYG{n}{time}\PYG{p}{,} \PYG{n}{fragments}\PYG{p}{,}
                                             \PYG{n}{metacommunity\PYGZus{}reference}\PYG{p}{)}\PYG{p}{;}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifdef DEBUG}
    \PYG{n}{stringstream} \PYG{n}{os}\PYG{p}{;}
    \PYG{n}{os} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Checking for calculations with sr=}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{speciation\PYGZus{}rate} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{, t=}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{time}\PYG{p}{;}
    \PYG{n}{os} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ and ref: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{past\PYGZus{}metacommunities}\PYG{p}{.}\PYG{n}{getReference}\PYG{p}{(}\PYG{n}{metacommunity\PYGZus{}speciation\PYGZus{}rate}\PYG{p}{,}
                                                            \PYG{n}{metacommunity\PYGZus{}size}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{has\PYGZus{}pair} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
    \PYG{n}{writeLog}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{,} \PYG{n}{os}\PYG{p}{)}\PYG{p}{;}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif }\PYG{c+c1}{// DEBUG}
    \PYG{k}{if}\PYG{p}{(}\PYG{n}{fragments} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{n}{past\PYGZus{}communities}\PYG{p}{.}\PYG{n}{hasPair}\PYG{p}{(}\PYG{n}{speciation\PYGZus{}rate}\PYG{p}{,} \PYG{n}{time}\PYG{p}{,} \PYG{n+nb}{false}\PYG{p}{,} \PYG{n}{metacommunity\PYGZus{}reference}\PYG{p}{)}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{return} \PYG{n+nb}{false}\PYG{p}{;}

    \PYG{p}{\PYGZcb{}}
    \PYG{k}{if}\PYG{p}{(}\PYG{o}{!}\PYG{n}{fragments} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{n}{past\PYGZus{}communities}\PYG{p}{.}\PYG{n}{hasPair}\PYG{p}{(}\PYG{n}{speciation\PYGZus{}rate}\PYG{p}{,} \PYG{n}{time}\PYG{p}{,} \PYG{n+nb}{true}\PYG{p}{,} \PYG{n}{metacommunity\PYGZus{}reference}\PYG{p}{)}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{return} \PYG{n+nb}{true}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
\PYG{c+c1}{//  if(past\PYGZus{}communities.hasPair(speciation\PYGZus{}rate, time, !fragments,}
\PYG{c+c1}{//                              past\PYGZus{}metacommunities.getReference(metacommunity\PYGZus{}speciation\PYGZus{}rate, metacommunity\PYGZus{}size)))}
\PYG{c+c1}{//  \PYGZob{}}
\PYG{c+c1}{//      return !fragments \textbar{}\textbar{} has\PYGZus{}pair;}
\PYG{c+c1}{//  \PYGZcb{}}
    \PYG{k}{return} \PYG{n}{has\PYGZus{}pair}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{void} \PYG{n}{Community}\PYG{o}{:}\PYG{o}{:}\PYG{n}{createFragmentDatabase}\PYG{p}{(}\PYG{k}{const} \PYG{n}{Fragment} \PYG{o}{\PYGZam{}}\PYG{n}{f}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{c+c1}{//      os \PYGZlt{}\PYGZlt{} \PYGZdq{}Generating new SQL table for speciation rate \PYGZdq{} \PYGZlt{}\PYGZlt{} s \PYGZlt{}\PYGZlt{} \PYGZdq{}...\PYGZdq{} \PYGZlt{}\PYGZlt{} flush;}
    \PYG{n}{string} \PYG{n}{table\PYGZus{}command} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{CREATE TABLE IF NOT EXISTS FRAGMENT\PYGZus{}ABUNDANCES (ID int PRIMARY KEY NOT NULL, fragment }\PYG{l+s}{\PYGZdq{}}
            \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{TEXT NOT NULL, area DOUBLE NOT NULL, size INT NOT NULL,  species\PYGZus{}id INT NOT NULL, }\PYG{l+s}{\PYGZdq{}}
            \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{no\PYGZus{}individuals INT NOT NULL, community\PYGZus{}reference int NOT NULL);}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
    \PYG{n}{sqlite3\PYGZus{}exec}\PYG{p}{(}\PYG{n}{database}\PYG{p}{,} \PYG{n}{table\PYGZus{}command}\PYG{p}{.}\PYG{n}{c\PYGZus{}str}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{k}{nullptr}\PYG{p}{,} \PYG{k}{nullptr}\PYG{p}{,} \PYG{k}{nullptr}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{getMaxFragmentAbundancesID}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{sqlite3\PYGZus{}stmt} \PYG{o}{*}\PYG{n}{stmt}\PYG{p}{;}
    \PYG{n}{table\PYGZus{}command} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{INSERT INTO FRAGMENT\PYGZus{}ABUNDANCES (ID, fragment, area, size, species\PYGZus{}id, }\PYG{l+s}{\PYGZdq{}}
            \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{no\PYGZus{}individuals, community\PYGZus{}reference) VALUES (?,?,?,?,?,?,?);}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
    \PYG{n}{sqlite3\PYGZus{}prepare\PYGZus{}v2}\PYG{p}{(}\PYG{n}{database}\PYG{p}{,} \PYG{n}{table\PYGZus{}command}\PYG{p}{.}\PYG{n}{c\PYGZus{}str}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{k}{static\PYGZus{}cast}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{n}{strlen}\PYG{p}{(}\PYG{n}{table\PYGZus{}command}\PYG{p}{.}\PYG{n}{c\PYGZus{}str}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{stmt}\PYG{p}{,}
                       \PYG{k}{nullptr}\PYG{p}{)}\PYG{p}{;}

    \PYG{c+c1}{// Start the transaction}
    \PYG{n}{sqlite3\PYGZus{}exec}\PYG{p}{(}\PYG{n}{database}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{BEGIN TRANSACTION;}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{k}{nullptr}\PYG{p}{,} \PYG{k}{nullptr}\PYG{p}{,} \PYG{k}{nullptr}\PYG{p}{)}\PYG{p}{;}
    \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{row\PYGZus{}out}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{row\PYGZus{}out}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{!}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{c+c1}{// fixed precision problem \PYGZhy{} lexical cast allows for printing of very small doubles.}
            \PYG{n}{sqlite3\PYGZus{}bind\PYGZus{}int}\PYG{p}{(}\PYG{n}{stmt}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{k}{static\PYGZus{}cast}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{n}{max\PYGZus{}fragment\PYGZus{}id}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
            \PYG{n}{sqlite3\PYGZus{}bind\PYGZus{}text}\PYG{p}{(}\PYG{n}{stmt}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{f}\PYG{p}{.}\PYG{n}{name}\PYG{p}{.}\PYG{n}{c\PYGZus{}str}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{SQLITE\PYGZus{}STATIC}\PYG{p}{)}\PYG{p}{;}
            \PYG{n}{sqlite3\PYGZus{}bind\PYGZus{}double}\PYG{p}{(}\PYG{n}{stmt}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{n}{f}\PYG{p}{.}\PYG{n}{area}\PYG{p}{)}\PYG{p}{;}
            \PYG{n}{sqlite3\PYGZus{}bind\PYGZus{}int}\PYG{p}{(}\PYG{n}{stmt}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{k}{static\PYGZus{}cast}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{n}{f}\PYG{p}{.}\PYG{n}{num}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
            \PYG{n}{sqlite3\PYGZus{}bind\PYGZus{}int}\PYG{p}{(}\PYG{n}{stmt}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{,} \PYG{k}{static\PYGZus{}cast}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{n}{i}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
            \PYG{n}{sqlite3\PYGZus{}bind\PYGZus{}int}\PYG{p}{(}\PYG{n}{stmt}\PYG{p}{,} \PYG{l+m+mi}{6}\PYG{p}{,} \PYG{n}{row\PYGZus{}out}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
            \PYG{n}{sqlite3\PYGZus{}bind\PYGZus{}int}\PYG{p}{(}\PYG{n}{stmt}\PYG{p}{,} \PYG{l+m+mi}{7}\PYG{p}{,} \PYG{k}{static\PYGZus{}cast}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{n}{current\PYGZus{}community\PYGZus{}parameters}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{reference}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
            \PYG{k+kt}{int} \PYG{n}{step} \PYG{o}{=} \PYG{n}{sqlite3\PYGZus{}step}\PYG{p}{(}\PYG{n}{stmt}\PYG{p}{)}\PYG{p}{;}
            \PYG{c+c1}{// makes sure the while loop doesn\PYGZsq{}t go forever.}
            \PYG{k+kt}{time\PYGZus{}t} \PYG{n}{start\PYGZus{}check}\PYG{p}{,} \PYG{n}{end\PYGZus{}check}\PYG{p}{;}
            \PYG{n}{time}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{start\PYGZus{}check}\PYG{p}{)}\PYG{p}{;}
            \PYG{n}{time}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{end\PYGZus{}check}\PYG{p}{)}\PYG{p}{;}
            \PYG{k}{while}\PYG{p}{(}\PYG{n}{step} \PYG{o}{!}\PYG{o}{=} \PYG{n}{SQLITE\PYGZus{}DONE} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{p}{(}\PYG{n}{end\PYGZus{}check} \PYG{o}{\PYGZhy{}} \PYG{n}{start\PYGZus{}check}\PYG{p}{)} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{10}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{n}{step} \PYG{o}{=} \PYG{n}{sqlite3\PYGZus{}step}\PYG{p}{(}\PYG{n}{stmt}\PYG{p}{)}\PYG{p}{;}
                \PYG{n}{time}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{end\PYGZus{}check}\PYG{p}{)}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
            \PYG{k}{if}\PYG{p}{(}\PYG{n}{step} \PYG{o}{!}\PYG{o}{=} \PYG{n}{SQLITE\PYGZus{}DONE}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{n}{stringstream} \PYG{n}{ss}\PYG{p}{;}
                \PYG{n}{ss} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{SQLITE error code: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{step} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
                \PYG{n}{cerr} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ERROR\PYGZus{}SQL\PYGZus{}004e: Could not insert into database. Check destination file has not }\PYG{l+s}{\PYGZdq{}}
                        \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{been moved or deleted and that an entry doesn\PYGZsq{}t already exist with the same ID.}\PYG{l+s}{\PYGZdq{}}
                     \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
                \PYG{n}{ss} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{sqlite3\PYGZus{}errmsg}\PYG{p}{(}\PYG{n}{database}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
                \PYG{n}{writeWarning}\PYG{p}{(}\PYG{n}{ss}\PYG{p}{.}\PYG{n}{str}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
                \PYG{n}{sqlite3\PYGZus{}clear\PYGZus{}bindings}\PYG{p}{(}\PYG{n}{stmt}\PYG{p}{)}\PYG{p}{;}
                \PYG{n}{sqlite3\PYGZus{}reset}\PYG{p}{(}\PYG{n}{stmt}\PYG{p}{)}\PYG{p}{;}
                \PYG{k}{break}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
            \PYG{n}{sqlite3\PYGZus{}clear\PYGZus{}bindings}\PYG{p}{(}\PYG{n}{stmt}\PYG{p}{)}\PYG{p}{;}
            \PYG{n}{sqlite3\PYGZus{}reset}\PYG{p}{(}\PYG{n}{stmt}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
    \PYG{p}{\PYGZcb{}}
    \PYG{c+c1}{// execute the command and close the connection to the database}
    \PYG{k+kt}{int} \PYG{n}{rc1} \PYG{o}{=} \PYG{n}{sqlite3\PYGZus{}exec}\PYG{p}{(}\PYG{n}{database}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{END TRANSACTION;}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{k}{nullptr}\PYG{p}{,} \PYG{k}{nullptr}\PYG{p}{,} \PYG{k}{nullptr}\PYG{p}{)}\PYG{p}{;}
    \PYG{c+c1}{// Need to finalise the statement}
    \PYG{k+kt}{int} \PYG{n}{rc2} \PYG{o}{=} \PYG{n}{sqlite3\PYGZus{}finalize}\PYG{p}{(}\PYG{n}{stmt}\PYG{p}{)}\PYG{p}{;}
    \PYG{k}{if}\PYG{p}{(}\PYG{n}{rc1} \PYG{o}{!}\PYG{o}{=} \PYG{n}{SQLITE\PYGZus{}OK} \PYG{o}{\textbar{}}\PYG{o}{\textbar{}} \PYG{n}{rc2} \PYG{o}{!}\PYG{o}{=} \PYG{n}{SQLITE\PYGZus{}OK}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{cerr} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ERROR\PYGZus{}SQL\PYGZus{}013: Could not complete SQL transaction. Check memory database assignment and SQL }\PYG{l+s}{\PYGZdq{}}
                \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{commands. Ensure SQL statements are properly cleared and that you are not attempting to insert }\PYG{l+s}{\PYGZdq{}}
                \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{repeat IDs into the database.}\PYG{l+s}{\PYGZdq{}}
             \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{void} \PYG{n}{Community}\PYG{o}{:}\PYG{o}{:}\PYG{n}{exportDatabase}\PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k}{if}\PYG{p}{(}\PYG{n}{bMem}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{stringstream} \PYG{n}{ss}\PYG{p}{;}
        \PYG{n}{stringstream} \PYG{n}{os}\PYG{p}{;}
        \PYG{n}{os} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Writing out to }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{spec\PYGZus{}sim\PYGZus{}parameters}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{filename} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{...}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{flush}\PYG{p}{;}
        \PYG{c+c1}{// Now write the database to the file object.}
        \PYG{n}{sqlite3} \PYG{o}{*}\PYG{n}{outdatabase2}\PYG{p}{;}
        \PYG{n}{writeInfo}\PYG{p}{(}\PYG{n}{os}\PYG{p}{.}\PYG{n}{str}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
        \PYG{k+kt}{int} \PYG{n}{rc} \PYG{o}{=} \PYG{n}{sqlite3\PYGZus{}open\PYGZus{}v2}\PYG{p}{(}\PYG{n}{spec\PYGZus{}sim\PYGZus{}parameters}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{filename}\PYG{p}{.}\PYG{n}{c\PYGZus{}str}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{outdatabase2}\PYG{p}{,} \PYG{n}{SQLITE\PYGZus{}OPEN\PYGZus{}READWRITE}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{unix\PYGZhy{}dotfile}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
        \PYG{c+c1}{// check that the connection to file has opened correctly}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{rc} \PYG{o}{!}\PYG{o}{=} \PYG{n}{SQLITE\PYGZus{}OK} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{n}{rc} \PYG{o}{!}\PYG{o}{=} \PYG{n}{SQLITE\PYGZus{}DONE}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{c+c1}{// attempt other output method}
            \PYG{n}{sqlite3\PYGZus{}close}\PYG{p}{(}\PYG{n}{outdatabase2}\PYG{p}{)}\PYG{p}{;}
            \PYG{n}{rc} \PYG{o}{=} \PYG{n}{sqlite3\PYGZus{}open}\PYG{p}{(}\PYG{n}{spec\PYGZus{}sim\PYGZus{}parameters}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{filename}\PYG{p}{.}\PYG{n}{c\PYGZus{}str}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{outdatabase2}\PYG{p}{)}\PYG{p}{;}
            \PYG{k}{if}\PYG{p}{(}\PYG{n}{rc} \PYG{o}{!}\PYG{o}{=} \PYG{n}{SQLITE\PYGZus{}OK} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{n}{rc} \PYG{o}{!}\PYG{o}{=} \PYG{n}{SQLITE\PYGZus{}DONE}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{n}{ss} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ERROR\PYGZus{}SQL\PYGZus{}016: Connection to output database cannot be opened. Check write access }\PYG{l+s}{\PYGZdq{}}
                        \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{on output folder. Error code: }\PYG{l+s}{\PYGZdq{}}
                     \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{rc} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{.}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
                \PYG{k}{throw} \PYG{n+nf}{FatalException}\PYG{p}{(}\PYG{n}{ss}\PYG{p}{.}\PYG{n}{str}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
        \PYG{p}{\PYGZcb{}}

        \PYG{c+c1}{// create the backup object to write data to the file from memory.}

        \PYG{n}{sqlite3\PYGZus{}backup} \PYG{o}{*}\PYG{n}{backupdb}\PYG{p}{;}
        \PYG{n}{backupdb} \PYG{o}{=} \PYG{n}{sqlite3\PYGZus{}backup\PYGZus{}init}\PYG{p}{(}\PYG{n}{outdatabase2}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{main}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{database}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{main}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{if}\PYG{p}{(}\PYG{o}{!}\PYG{n}{backupdb}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{ss} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ERROR\PYGZus{}SQL\PYGZus{}003: Could not backup to SQL database. Check destination file has not been }\PYG{l+s}{\PYGZdq{}}
                    \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{moved or deleted.}\PYG{l+s}{\PYGZdq{}}
                 \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
            \PYG{k}{throw} \PYG{n+nf}{FatalException}\PYG{p}{(}\PYG{n}{ss}\PYG{p}{.}\PYG{n}{str}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{c+c1}{// Perform the backup}
        \PYG{n}{rc} \PYG{o}{=} \PYG{n}{sqlite3\PYGZus{}backup\PYGZus{}step}\PYG{p}{(}\PYG{n}{backupdb}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{rc} \PYG{o}{!}\PYG{o}{=} \PYG{n}{SQLITE\PYGZus{}OK} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{n}{rc} \PYG{o}{!}\PYG{o}{=} \PYG{n}{SQLITE\PYGZus{}DONE}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{ss} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ERROR\PYGZus{}SQL\PYGZus{}016: Connection to output database cannot be opened. Check write access on }\PYG{l+s}{\PYGZdq{}}
                    \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{output folder. Error code: }\PYG{l+s}{\PYGZdq{}}
                 \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{rc} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{.}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
            \PYG{k}{throw} \PYG{n+nf}{FatalException}\PYG{p}{(}\PYG{n}{ss}\PYG{p}{.}\PYG{n}{str}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{n}{rc} \PYG{o}{=} \PYG{n}{sqlite3\PYGZus{}backup\PYGZus{}finish}\PYG{p}{(}\PYG{n}{backupdb}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{rc} \PYG{o}{!}\PYG{o}{=} \PYG{n}{SQLITE\PYGZus{}OK} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{n}{rc} \PYG{o}{!}\PYG{o}{=} \PYG{n}{SQLITE\PYGZus{}DONE}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{ss} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ERROR\PYGZus{}SQL\PYGZus{}016: Connection to output database cannot be opened. Check write access on }\PYG{l+s}{\PYGZdq{}}
                    \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{output folder. Error code: }\PYG{l+s}{\PYGZdq{}}
                 \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{rc} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{.}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
            \PYG{k}{throw} \PYG{n+nf}{FatalException}\PYG{p}{(}\PYG{n}{ss}\PYG{p}{.}\PYG{n}{str}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{n}{sqlite3\PYGZus{}close}\PYG{p}{(}\PYG{n}{outdatabase2}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{sqlite3\PYGZus{}close}\PYG{p}{(}\PYG{n}{database}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{writeInfo}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{done!}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{else}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{sqlite3\PYGZus{}close}\PYG{p}{(}\PYG{n}{database}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{bool} \PYG{n}{Community}\PYG{o}{:}\PYG{o}{:}\PYG{n}{checkSpeciesLocationsReference}\PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k}{if}\PYG{p}{(}\PYG{o}{!}\PYG{n}{bSqlConnection}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{throw} \PYG{n}{FatalException}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Attempted to get from sql database without opening database connection.}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{n}{sqlite3\PYGZus{}stmt} \PYG{o}{*}\PYG{n}{stmt}\PYG{p}{;}
    \PYG{c+c1}{// Now find out the max size of the list, so we have a count to work from}
    \PYG{n}{string} \PYG{n}{count\PYGZus{}command} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{SELECT COUNT(*) FROM SPECIES\PYGZus{}LOCATIONS WHERE community\PYGZus{}reference == }\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
    \PYG{n}{count\PYGZus{}command} \PYG{o}{+}\PYG{o}{=} \PYG{n}{to\PYGZus{}string}\PYG{p}{(}\PYG{n}{current\PYGZus{}community\PYGZus{}parameters}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{reference}\PYG{p}{)} \PYG{o}{+} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{;}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
    \PYG{n}{sqlite3\PYGZus{}prepare\PYGZus{}v2}\PYG{p}{(}\PYG{n}{database}\PYG{p}{,} \PYG{n}{count\PYGZus{}command}\PYG{p}{.}\PYG{n}{c\PYGZus{}str}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{k}{static\PYGZus{}cast}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{n}{strlen}\PYG{p}{(}\PYG{n}{count\PYGZus{}command}\PYG{p}{.}\PYG{n}{c\PYGZus{}str}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{stmt}\PYG{p}{,}
                       \PYG{k}{nullptr}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{sqlite3\PYGZus{}step}\PYG{p}{(}\PYG{n}{stmt}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kt}{int} \PYG{n}{tmp\PYGZus{}val} \PYG{o}{=} \PYG{n}{sqlite3\PYGZus{}column\PYGZus{}int}\PYG{p}{(}\PYG{n}{stmt}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}
    \PYG{c+c1}{// close the old statement}
    \PYG{n}{sqlite3\PYGZus{}finalize}\PYG{p}{(}\PYG{n}{stmt}\PYG{p}{)}\PYG{p}{;}
    \PYG{k}{return} \PYG{n}{tmp\PYGZus{}val} \PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{bool} \PYG{n}{Community}\PYG{o}{:}\PYG{o}{:}\PYG{n}{checkSpeciesAbundancesReference}\PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k}{if}\PYG{p}{(}\PYG{o}{!}\PYG{n}{bSqlConnection}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{throw} \PYG{n}{FatalException}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Attempted to get from sql database without opening database connection.}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{n}{sqlite3\PYGZus{}stmt} \PYG{o}{*}\PYG{n}{stmt}\PYG{p}{;}
    \PYG{c+c1}{// Now find out the max size of the list, so we have a count to work from}
    \PYG{n}{string} \PYG{n}{count\PYGZus{}command} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{SELECT COUNT(*) FROM SPECIES\PYGZus{}ABUNDANCES WHERE community\PYGZus{}reference = }\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
    \PYG{n}{count\PYGZus{}command} \PYG{o}{+}\PYG{o}{=} \PYG{n}{to\PYGZus{}string}\PYG{p}{(}\PYG{n}{current\PYGZus{}community\PYGZus{}parameters}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{reference}\PYG{p}{)} \PYG{o}{+} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{;}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
    \PYG{n}{sqlite3\PYGZus{}prepare\PYGZus{}v2}\PYG{p}{(}\PYG{n}{database}\PYG{p}{,} \PYG{n}{count\PYGZus{}command}\PYG{p}{.}\PYG{n}{c\PYGZus{}str}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{k}{static\PYGZus{}cast}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{n}{strlen}\PYG{p}{(}\PYG{n}{count\PYGZus{}command}\PYG{p}{.}\PYG{n}{c\PYGZus{}str}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{stmt}\PYG{p}{,}
                       \PYG{k}{nullptr}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{sqlite3\PYGZus{}step}\PYG{p}{(}\PYG{n}{stmt}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kt}{int} \PYG{n}{tmp\PYGZus{}val} \PYG{o}{=} \PYG{n}{sqlite3\PYGZus{}column\PYGZus{}int}\PYG{p}{(}\PYG{n}{stmt}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}
    \PYG{c+c1}{// close the old statement}
    \PYG{n}{sqlite3\PYGZus{}finalize}\PYG{p}{(}\PYG{n}{stmt}\PYG{p}{)}\PYG{p}{;}
    \PYG{k}{return} \PYG{n}{tmp\PYGZus{}val} \PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{void} \PYG{n}{Community}\PYG{o}{:}\PYG{o}{:}\PYG{n}{recordSpatial}\PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
\PYG{c+c1}{//  os \PYGZlt{}\PYGZlt{} \PYGZdq{}Recording spatial data for speciation rate \PYGZdq{} \PYGZlt{}\PYGZlt{} current\PYGZus{}community\PYGZus{}parameters\PYGZhy{}\PYGZgt{}speciation\PYGZus{}rate \PYGZlt{}\PYGZlt{} \PYGZdq{}...\PYGZdq{} \PYGZlt{}\PYGZlt{} flush;}
    \PYG{n}{string} \PYG{n}{table\PYGZus{}command} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{CREATE TABLE IF NOT EXISTS SPECIES\PYGZus{}LOCATIONS (ID int PRIMARY KEY NOT NULL, species\PYGZus{}id INT }\PYG{l+s}{\PYGZdq{}}
            \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{NOT NULL, x INT NOT NULL, y INT NOT NULL, community\PYGZus{}reference INT NOT NULL);}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
    \PYG{n}{sqlite3\PYGZus{}exec}\PYG{p}{(}\PYG{n}{database}\PYG{p}{,} \PYG{n}{table\PYGZus{}command}\PYG{p}{.}\PYG{n}{c\PYGZus{}str}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{k}{nullptr}\PYG{p}{,} \PYG{k}{nullptr}\PYG{p}{,} \PYG{k}{nullptr}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{getMaxSpeciesLocationsID}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{sqlite3\PYGZus{}stmt} \PYG{o}{*}\PYG{n}{stmt}\PYG{p}{;}
    \PYG{c+c1}{// Checks that the SPECIES\PYGZus{}LOCATIONS table doesn\PYGZsq{}t already have a reference in matching the current reference}
    \PYG{k}{if}\PYG{p}{(}\PYG{n}{current\PYGZus{}community\PYGZus{}parameters}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{updated}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{checkSpeciesLocationsReference}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{k}{return}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
    \PYG{p}{\PYGZcb{}}
    \PYG{n}{table\PYGZus{}command} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{INSERT INTO SPECIES\PYGZus{}LOCATIONS (ID,species\PYGZus{}id, x, y, community\PYGZus{}reference) VALUES (?,?,?,?,?);}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}

    \PYG{n}{sqlite3\PYGZus{}prepare\PYGZus{}v2}\PYG{p}{(}\PYG{n}{database}\PYG{p}{,} \PYG{n}{table\PYGZus{}command}\PYG{p}{.}\PYG{n}{c\PYGZus{}str}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{k}{static\PYGZus{}cast}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{n}{strlen}\PYG{p}{(}\PYG{n}{table\PYGZus{}command}\PYG{p}{.}\PYG{n}{c\PYGZus{}str}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{stmt}\PYG{p}{,}
                       \PYG{k}{nullptr}\PYG{p}{)}\PYG{p}{;}
    \PYG{c+c1}{//      os \PYGZlt{}\PYGZlt{} \PYGZdq{}test1\PYGZdq{} \PYGZlt{}\PYGZlt{} endl;}
    \PYG{c+c1}{// Start the transaction}
    \PYG{n}{sqlite3\PYGZus{}exec}\PYG{p}{(}\PYG{n}{database}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{BEGIN TRANSACTION;}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{k}{nullptr}\PYG{p}{,} \PYG{k}{nullptr}\PYG{p}{,} \PYG{k}{nullptr}\PYG{p}{)}\PYG{p}{;}
    \PYG{c+c1}{// Make sure only the tips which we want to check are recorded}
    \PYG{c+c1}{//      os \PYGZlt{}\PYGZlt{} \PYGZdq{}nodes\PYGZhy{}\PYGZgt{}size(): \PYGZdq{} \PYGZlt{}\PYGZlt{} nodes\PYGZhy{}\PYGZgt{}size() \PYGZlt{}\PYGZlt{} endl;}
    \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{nodes}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{TreeNode} \PYG{o}{*}\PYG{n}{this\PYGZus{}node} \PYG{o}{=} \PYG{o}{\PYGZam{}}\PYG{p}{(}\PYG{o}{*}\PYG{n}{nodes}\PYG{p}{)}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{;}
        \PYG{c+c1}{//          os \PYGZlt{}\PYGZlt{} nodes[i].getExistence() \PYGZlt{}\PYGZlt{} endl;}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{this\PYGZus{}node}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{isTip}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}}
           \PYG{n}{this\PYGZus{}node}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{getExistence}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{n}{doubleCompare}\PYG{p}{(}\PYG{k}{static\PYGZus{}cast}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{double}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{n}{this\PYGZus{}node}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{getGeneration}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{,}
                                                      \PYG{k}{static\PYGZus{}cast}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{double}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{n}{current\PYGZus{}community\PYGZus{}parameters}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{time}\PYG{p}{)}\PYG{p}{,} \PYG{l+m+mf}{0.0001}\PYG{p}{)}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{k}{if}\PYG{p}{(}\PYG{n}{samplemask}\PYG{p}{.}\PYG{n}{getMaskVal}\PYG{p}{(}\PYG{n}{this\PYGZus{}node}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{getXpos}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{n}{this\PYGZus{}node}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{getYpos}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,}
                                     \PYG{n}{this\PYGZus{}node}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{getXwrap}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{n}{this\PYGZus{}node}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{getYwrap}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{k+kt}{long} \PYG{n}{x} \PYG{o}{=} \PYG{n}{this\PYGZus{}node}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{getXpos}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
                \PYG{k+kt}{long} \PYG{n}{y} \PYG{o}{=} \PYG{n}{this\PYGZus{}node}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{getYpos}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
                \PYG{k+kt}{long} \PYG{n}{xwrap} \PYG{o}{=} \PYG{n}{this\PYGZus{}node}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{getXwrap}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
                \PYG{k+kt}{long} \PYG{n}{ywrap} \PYG{o}{=} \PYG{n}{this\PYGZus{}node}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{getYwrap}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
                \PYG{k+kt}{long} \PYG{n}{xval} \PYG{o}{=} \PYG{n}{x} \PYG{o}{+} \PYG{p}{(}\PYG{n}{xwrap} \PYG{o}{*} \PYG{n}{grid\PYGZus{}x\PYGZus{}size}\PYG{p}{)} \PYG{o}{+} \PYG{n}{samplemask\PYGZus{}x\PYGZus{}offset}\PYG{p}{;}
                \PYG{k+kt}{long} \PYG{n}{yval} \PYG{o}{=} \PYG{n}{y} \PYG{o}{+} \PYG{p}{(}\PYG{n}{ywrap} \PYG{o}{*} \PYG{n}{grid\PYGZus{}y\PYGZus{}size}\PYG{p}{)} \PYG{o}{+} \PYG{n}{samplemask\PYGZus{}y\PYGZus{}offset}\PYG{p}{;}
                \PYG{n}{sqlite3\PYGZus{}bind\PYGZus{}int}\PYG{p}{(}\PYG{n}{stmt}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{k}{static\PYGZus{}cast}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{n}{max\PYGZus{}locations\PYGZus{}id}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
                \PYG{n}{sqlite3\PYGZus{}bind\PYGZus{}int}\PYG{p}{(}\PYG{n}{stmt}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{k}{static\PYGZus{}cast}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{n}{this\PYGZus{}node}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{getSpeciesID}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
                \PYG{n}{sqlite3\PYGZus{}bind\PYGZus{}int}\PYG{p}{(}\PYG{n}{stmt}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{k}{static\PYGZus{}cast}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{n}{xval}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
                \PYG{n}{sqlite3\PYGZus{}bind\PYGZus{}int}\PYG{p}{(}\PYG{n}{stmt}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{k}{static\PYGZus{}cast}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{n}{yval}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
                \PYG{n}{sqlite3\PYGZus{}bind\PYGZus{}int}\PYG{p}{(}\PYG{n}{stmt}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{,} \PYG{k}{static\PYGZus{}cast}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{n}{current\PYGZus{}community\PYGZus{}parameters}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{reference}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
                \PYG{k+kt}{int} \PYG{n}{step} \PYG{o}{=} \PYG{n}{sqlite3\PYGZus{}step}\PYG{p}{(}\PYG{n}{stmt}\PYG{p}{)}\PYG{p}{;}
                \PYG{c+c1}{// makes sure the while loop doesn\PYGZsq{}t go forever.}
                \PYG{k+kt}{time\PYGZus{}t} \PYG{n}{start\PYGZus{}check}\PYG{p}{,} \PYG{n}{end\PYGZus{}check}\PYG{p}{;}
                \PYG{n}{time}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{start\PYGZus{}check}\PYG{p}{)}\PYG{p}{;}
                \PYG{n}{time}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{end\PYGZus{}check}\PYG{p}{)}\PYG{p}{;}
                \PYG{k}{while}\PYG{p}{(}\PYG{n}{step} \PYG{o}{!}\PYG{o}{=} \PYG{n}{SQLITE\PYGZus{}DONE} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{p}{(}\PYG{n}{end\PYGZus{}check} \PYG{o}{\PYGZhy{}} \PYG{n}{start\PYGZus{}check}\PYG{p}{)} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{10} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{n}{step} \PYG{o}{!}\PYG{o}{=} \PYG{n}{SQLITE\PYGZus{}OK}\PYG{p}{)}
                \PYG{p}{\PYGZob{}}
                    \PYG{n}{step} \PYG{o}{=} \PYG{n}{sqlite3\PYGZus{}step}\PYG{p}{(}\PYG{n}{stmt}\PYG{p}{)}\PYG{p}{;}
                    \PYG{n}{time}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{end\PYGZus{}check}\PYG{p}{)}\PYG{p}{;}
                \PYG{p}{\PYGZcb{}}
                \PYG{k}{if}\PYG{p}{(}\PYG{n}{step} \PYG{o}{!}\PYG{o}{=} \PYG{n}{SQLITE\PYGZus{}DONE}\PYG{p}{)}
                \PYG{p}{\PYGZob{}}
                    \PYG{n}{stringstream} \PYG{n}{ss}\PYG{p}{;}
                    \PYG{n}{ss} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{SQLITE error code: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{step} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
                    \PYG{n}{ss} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ERROR\PYGZus{}SQL\PYGZus{}004f: Could not insert into database. Check destination file has not }\PYG{l+s}{\PYGZdq{}}
                            \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{been moved or deleted and that an entry doesn\PYGZsq{}t already exist with the same ID.}\PYG{l+s}{\PYGZdq{}}
                       \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
                    \PYG{n}{ss} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{sqlite3\PYGZus{}errmsg}\PYG{p}{(}\PYG{n}{database}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
                    \PYG{n}{writeWarning}\PYG{p}{(}\PYG{n}{ss}\PYG{p}{.}\PYG{n}{str}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
                    \PYG{k}{break}\PYG{p}{;}
                \PYG{p}{\PYGZcb{}}
                \PYG{n}{sqlite3\PYGZus{}clear\PYGZus{}bindings}\PYG{p}{(}\PYG{n}{stmt}\PYG{p}{)}\PYG{p}{;}
                \PYG{n}{sqlite3\PYGZus{}reset}\PYG{p}{(}\PYG{n}{stmt}\PYG{p}{)}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
        \PYG{p}{\PYGZcb{}}
    \PYG{p}{\PYGZcb{}}
    \PYG{c+c1}{// execute the command and close the connection to the database}
    \PYG{k+kt}{int} \PYG{n}{rc1} \PYG{o}{=} \PYG{n}{sqlite3\PYGZus{}exec}\PYG{p}{(}\PYG{n}{database}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{END TRANSACTION;}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{k}{nullptr}\PYG{p}{,} \PYG{k}{nullptr}\PYG{p}{,} \PYG{k}{nullptr}\PYG{p}{)}\PYG{p}{;}
    \PYG{c+c1}{// Need to finalise the statement}
    \PYG{k+kt}{int} \PYG{n}{rc2} \PYG{o}{=} \PYG{n}{sqlite3\PYGZus{}finalize}\PYG{p}{(}\PYG{n}{stmt}\PYG{p}{)}\PYG{p}{;}
    \PYG{k}{if}\PYG{p}{(}\PYG{n}{rc1} \PYG{o}{!}\PYG{o}{=} \PYG{n}{SQLITE\PYGZus{}OK} \PYG{o}{\textbar{}}\PYG{o}{\textbar{}} \PYG{n}{rc2} \PYG{o}{!}\PYG{o}{=} \PYG{n}{SQLITE\PYGZus{}OK}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{cerr} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ERROR\PYGZus{}SQL\PYGZus{}013: Could not complete SQL transaction. Check memory database assignment and SQL }\PYG{l+s}{\PYGZdq{}}
                \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{commands. Ensure SQL statements are properly cleared and that you are not attempting to insert }\PYG{l+s}{\PYGZdq{}}
                \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{repeat IDs into the database.}\PYG{l+s}{\PYGZdq{}}
             \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{void} \PYG{n}{Community}\PYG{o}{:}\PYG{o}{:}\PYG{n}{calcFragments}\PYG{p}{(}\PYG{n}{string} \PYG{n}{fragment\PYGZus{}file}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{c+c1}{// Loop over every grid cell in the samplemask to determine if it is the start (top left corner) of a fragment.}
    \PYG{c+c1}{// Note that fragment detection only works for squares and rectangles. Adjacent squares and rectangles will be}
    \PYG{c+c1}{// treated as separate fragments if they are different sizes.}
    \PYG{c+c1}{// Downwards shapes are prioritised (i.e. a vertical rectangle on top of a horizontal rectangle will produce 3}
    \PYG{c+c1}{// fragments instead of two \PYGZhy{} this is a known bug).}
    \PYG{k}{if}\PYG{p}{(}\PYG{n}{fragment\PYGZus{}file} \PYG{o}{=}\PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{null}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{fragment\PYGZus{}number} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
        \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{samplemask}\PYG{p}{.}\PYG{n}{sample\PYGZus{}mask}\PYG{p}{.}\PYG{n}{GetCols}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{j} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{j} \PYG{o}{\PYGZlt{}} \PYG{n}{samplemask}\PYG{p}{.}\PYG{n}{sample\PYGZus{}mask}\PYG{p}{.}\PYG{n}{GetRows}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{n}{j}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{k+kt}{bool} \PYG{n}{in\PYGZus{}fragment} \PYG{o}{=} \PYG{n+nb}{false}\PYG{p}{;}
                \PYG{c+c1}{// Make sure is isn\PYGZsq{}t on the top or left edge}
                \PYG{k}{if}\PYG{p}{(}\PYG{n}{samplemask}\PYG{p}{.}\PYG{n}{sample\PYGZus{}mask}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}
                \PYG{p}{\PYGZob{}}
                    \PYG{k}{if}\PYG{p}{(}\PYG{n}{i} \PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{0} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{n}{j} \PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{0}\PYG{p}{)}
                    \PYG{p}{\PYGZob{}}
                        \PYG{c+c1}{// Perform the check}
                        \PYG{n}{in\PYGZus{}fragment} \PYG{o}{=} \PYG{o}{!}\PYG{p}{(}\PYG{n}{samplemask}\PYG{p}{.}\PYG{n}{sample\PYGZus{}mask}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{p}{[}\PYG{n}{i} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{\textbar{}}\PYG{o}{\textbar{}} \PYG{n}{samplemask}\PYG{p}{.}\PYG{n}{sample\PYGZus{}mask}\PYG{p}{[}\PYG{n}{j} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
                    \PYG{p}{\PYGZcb{}}
                        \PYG{c+c1}{// if it is on an edge, we need to check the fragment}
                    \PYG{k}{else}
                    \PYG{p}{\PYGZob{}}
                        \PYG{c+c1}{// if it is on the left edge we need to check above it \PYGZhy{} if there is forest}
                        \PYG{c+c1}{// there, it is not a fragment.}
                        \PYG{k}{if}\PYG{p}{(}\PYG{n}{i} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{0} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{n}{j} \PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{0}\PYG{p}{)}
                        \PYG{p}{\PYGZob{}}
                            \PYG{k}{if}\PYG{p}{(}\PYG{o}{!}\PYG{n}{samplemask}\PYG{p}{.}\PYG{n}{sample\PYGZus{}mask}\PYG{p}{[}\PYG{n}{j} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}
                            \PYG{p}{\PYGZob{}}
                                \PYG{n}{in\PYGZus{}fragment} \PYG{o}{=} \PYG{n+nb}{true}\PYG{p}{;}
                            \PYG{p}{\PYGZcb{}}
                        \PYG{p}{\PYGZcb{}}
                            \PYG{c+c1}{// if it is on the top edge, need to check to the left of it \PYGZhy{}  if there is}
                            \PYG{c+c1}{// forest there, it is not a fragment.}
                        \PYG{k}{else} \PYG{k}{if}\PYG{p}{(}\PYG{n}{j} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{0} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{n}{i} \PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{0}\PYG{p}{)}
                        \PYG{p}{\PYGZob{}}
                            \PYG{k}{if}\PYG{p}{(}\PYG{o}{!}\PYG{n}{samplemask}\PYG{p}{.}\PYG{n}{sample\PYGZus{}mask}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{p}{[}\PYG{n}{i} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}
                            \PYG{p}{\PYGZob{}}
                                \PYG{n}{in\PYGZus{}fragment} \PYG{o}{=} \PYG{n+nb}{true}\PYG{p}{;}
                            \PYG{p}{\PYGZcb{}}
                        \PYG{p}{\PYGZcb{}}
                        \PYG{k}{else} \PYG{k}{if}\PYG{p}{(}\PYG{n}{i} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{0} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{n}{j} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)}
                        \PYG{p}{\PYGZob{}}
                            \PYG{n}{in\PYGZus{}fragment} \PYG{o}{=} \PYG{n+nb}{true}\PYG{p}{;}
                        \PYG{p}{\PYGZcb{}}
                    \PYG{p}{\PYGZcb{}}
                \PYG{p}{\PYGZcb{}}
                \PYG{k}{if}\PYG{p}{(}\PYG{n}{in\PYGZus{}fragment}\PYG{p}{)}
                \PYG{p}{\PYGZob{}}
                    \PYG{c+c1}{// Now move along the x and y axis (separately) until we hit a non\PYGZhy{}forest patch.}
                    \PYG{c+c1}{// This marks the edge of the fragment and the value is recorded.}
                    \PYG{k+kt}{bool} \PYG{n}{x\PYGZus{}continue} \PYG{o}{=} \PYG{n+nb}{true}\PYG{p}{;}
                    \PYG{k+kt}{bool} \PYG{n}{y\PYGZus{}continue} \PYG{o}{=} \PYG{n+nb}{true}\PYG{p}{;}
                    \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{x}\PYG{p}{,} \PYG{n}{y}\PYG{p}{;}
                    \PYG{n}{x} \PYG{o}{=} \PYG{n}{i}\PYG{p}{;}
                    \PYG{n}{y} \PYG{o}{=} \PYG{n}{j}\PYG{p}{;}
                    \PYG{n}{fragment\PYGZus{}number}\PYG{o}{+}\PYG{o}{+}\PYG{p}{;}
                    \PYG{c+c1}{// Also need to check that fragments that lie partly next to each other aren\PYGZsq{}t}
                    \PYG{c+c1}{// counted twice.}
                    \PYG{c+c1}{// So count along the x axis until we hit non\PYGZhy{}habitat. Then count down the y axis}
                    \PYG{c+c1}{// checking both extremes of the square for non\PYGZhy{}habitat.}
                    \PYG{c+c1}{// Perform a check on the x axis to make sure that the square above is empty, as}
                    \PYG{c+c1}{// fragments give priority in a downwards motion.}
                    \PYG{k}{while}\PYG{p}{(}\PYG{n}{x\PYGZus{}continue}\PYG{p}{)}
                    \PYG{p}{\PYGZob{}}
                        \PYG{n}{x}\PYG{o}{+}\PYG{o}{+}\PYG{p}{;}
                        \PYG{k}{if}\PYG{p}{(}\PYG{n}{samplemask}\PYG{p}{.}\PYG{n}{sample\PYGZus{}mask}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{p}{[}\PYG{n}{x}\PYG{p}{]}\PYG{p}{)}
                        \PYG{p}{\PYGZob{}}
                            \PYG{c+c1}{// Check we\PYGZsq{}re not on top edge of the map.}
                            \PYG{k}{if}\PYG{p}{(}\PYG{n}{j} \PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{0}\PYG{p}{)}
                            \PYG{p}{\PYGZob{}}
                                \PYG{c+c1}{// if the cell above is non\PYGZhy{}fragment then we don\PYGZsq{}t need to}
                                \PYG{c+c1}{// continue (downwards fragments get priority).}
                                \PYG{k}{if}\PYG{p}{(}\PYG{n}{samplemask}\PYG{p}{.}\PYG{n}{sample\PYGZus{}mask}\PYG{p}{[}\PYG{n}{j} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{[}\PYG{n}{x}\PYG{p}{]}\PYG{p}{)}
                                \PYG{p}{\PYGZob{}}
                                    \PYG{n}{x\PYGZus{}continue} \PYG{o}{=} \PYG{n+nb}{true}\PYG{p}{;}
                                \PYG{p}{\PYGZcb{}}
                                \PYG{k}{else}
                                \PYG{p}{\PYGZob{}}
                                    \PYG{n}{x\PYGZus{}continue} \PYG{o}{=} \PYG{n+nb}{false}\PYG{p}{;}
                                \PYG{p}{\PYGZcb{}}
                            \PYG{p}{\PYGZcb{}}
                            \PYG{k}{else}
                            \PYG{p}{\PYGZob{}}
                                \PYG{n}{x\PYGZus{}continue} \PYG{o}{=} \PYG{n+nb}{true}\PYG{p}{;}
                            \PYG{p}{\PYGZcb{}}
                        \PYG{p}{\PYGZcb{}}
                        \PYG{k}{else}
                        \PYG{p}{\PYGZob{}}
                            \PYG{n}{x\PYGZus{}continue} \PYG{o}{=} \PYG{n+nb}{false}\PYG{p}{;}
                        \PYG{p}{\PYGZcb{}}
                    \PYG{p}{\PYGZcb{}}
                    \PYG{k}{while}\PYG{p}{(}\PYG{n}{y\PYGZus{}continue}\PYG{p}{)}
                    \PYG{p}{\PYGZob{}}
                        \PYG{n}{y}\PYG{o}{+}\PYG{o}{+}\PYG{p}{;}
                        \PYG{c+c1}{// Make sure both extremes of the rectangle are still within patch.}
                        \PYG{k}{if}\PYG{p}{(}\PYG{n}{samplemask}\PYG{p}{.}\PYG{n}{sample\PYGZus{}mask}\PYG{p}{[}\PYG{n}{y}\PYG{p}{]}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{n}{samplemask}\PYG{p}{.}\PYG{n}{sample\PYGZus{}mask}\PYG{p}{[}\PYG{n}{y}\PYG{p}{]}\PYG{p}{[}\PYG{n}{i} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}
                        \PYG{p}{\PYGZob{}}
                            \PYG{n}{y\PYGZus{}continue} \PYG{o}{=} \PYG{n+nb}{true}\PYG{p}{;}
                        \PYG{p}{\PYGZcb{}}
                        \PYG{k}{else}
                        \PYG{p}{\PYGZob{}}
                            \PYG{n}{y\PYGZus{}continue} \PYG{o}{=} \PYG{n+nb}{false}\PYG{p}{;}
                        \PYG{p}{\PYGZcb{}}
                    \PYG{p}{\PYGZcb{}}
                    \PYG{c+c1}{// Create the fragment to add.}
                    \PYG{n}{Fragment} \PYG{n}{to\PYGZus{}add}\PYG{p}{;}
                    \PYG{n}{to\PYGZus{}add}\PYG{p}{.}\PYG{n}{name} \PYG{o}{=} \PYG{n}{to\PYGZus{}string}\PYG{p}{(}\PYG{p}{(}\PYG{k+kt}{long} \PYG{k+kt}{long}\PYG{p}{)} \PYG{n}{fragment\PYGZus{}number}\PYG{p}{)}\PYG{p}{;}
                    \PYG{n}{to\PYGZus{}add}\PYG{p}{.}\PYG{n}{x\PYGZus{}west} \PYG{o}{=} \PYG{n}{i}\PYG{p}{;}
                    \PYG{n}{to\PYGZus{}add}\PYG{p}{.}\PYG{n}{x\PYGZus{}east} \PYG{o}{=} \PYG{n}{x} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{1}\PYG{p}{;}
                    \PYG{n}{to\PYGZus{}add}\PYG{p}{.}\PYG{n}{y\PYGZus{}north} \PYG{o}{=} \PYG{n}{j}\PYG{p}{;}
                    \PYG{n}{to\PYGZus{}add}\PYG{p}{.}\PYG{n}{y\PYGZus{}south} \PYG{o}{=} \PYG{n}{y} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{1}\PYG{p}{;}
                    \PYG{c+c1}{// calculate the square area of the plot and record it.}
                    \PYG{n}{to\PYGZus{}add}\PYG{p}{.}\PYG{n}{area} \PYG{o}{=} \PYG{p}{(}\PYG{n}{x} \PYG{o}{\PYGZhy{}} \PYG{n}{i}\PYG{p}{)} \PYG{o}{*} \PYG{p}{(}\PYG{n}{y} \PYG{o}{\PYGZhy{}} \PYG{n}{j}\PYG{p}{)}\PYG{p}{;}
                    \PYG{c+c1}{// Now store the size of the fragment in the vector.}
                    \PYG{n}{fragments}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{n}{to\PYGZus{}add}\PYG{p}{)}\PYG{p}{;}
                \PYG{p}{\PYGZcb{}}
            \PYG{p}{\PYGZcb{}}
        \PYG{p}{\PYGZcb{}}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{else}
    \PYG{p}{\PYGZob{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifdef use\PYGZus{}csv}
        \PYG{n}{stringstream} \PYG{n}{os}\PYG{p}{;}
        \PYG{n}{os} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Importing fragments from }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{fragment\PYGZus{}file} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
        \PYG{n}{writeInfo}\PYG{p}{(}\PYG{n}{os}\PYG{p}{.}\PYG{n}{str}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
        \PYG{c+c1}{// There is a config file to import \PYGZhy{} here we use a specific piece of importSpatialParameters code to parse the csv file.}
        \PYG{c+c1}{// first count the number of lines}
        \PYG{k+kt}{int} \PYG{n}{number\PYGZus{}of\PYGZus{}lines} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
        \PYG{n}{string} \PYG{n}{line}\PYG{p}{;}
        \PYG{n}{ifstream} \PYG{n+nf}{fragment\PYGZus{}configs}\PYG{p}{(}\PYG{n}{fragment\PYGZus{}file}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{while}\PYG{p}{(}\PYG{n}{getline}\PYG{p}{(}\PYG{n}{fragment\PYGZus{}configs}\PYG{p}{,} \PYG{n}{line}\PYG{p}{)}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{number\PYGZus{}of\PYGZus{}lines}\PYG{o}{+}\PYG{o}{+}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{c+c1}{//          os \PYGZlt{}\PYGZlt{} \PYGZdq{}Number of lines in text file: \PYGZdq{} \PYGZlt{}\PYGZlt{} number\PYGZus{}of\PYGZus{}lines \PYGZlt{}\PYGZlt{} endl;}
        \PYG{n}{fragment\PYGZus{}configs}\PYG{p}{.}\PYG{n}{close}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{io}\PYG{o}{:}\PYG{o}{:}\PYG{n}{LineReader} \PYG{n}{in}\PYG{p}{(}\PYG{n}{fragment\PYGZus{}file}\PYG{p}{)}\PYG{p}{;}
        \PYG{c+c1}{// Keep track of whether we\PYGZsq{}ve printed to terminal or not.}
        \PYG{k+kt}{bool} \PYG{n}{bPrint} \PYG{o}{=} \PYG{n+nb}{false}\PYG{p}{;}
        \PYG{n}{fragments}\PYG{p}{.}\PYG{n}{resize}\PYG{p}{(}\PYG{n}{number\PYGZus{}of\PYGZus{}lines}\PYG{p}{)}\PYG{p}{;}
\PYG{c+c1}{//      os \PYGZlt{}\PYGZlt{} \PYGZdq{}size: \PYGZdq{}  \PYGZlt{}\PYGZlt{} fragments.capacity() \PYGZlt{}\PYGZlt{} endl;}
        \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{number\PYGZus{}of\PYGZus{}lines}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}

            \PYG{c+c1}{//              os \PYGZlt{}\PYGZlt{} i \PYGZlt{}\PYGZlt{} endl;}
            \PYG{k+kt}{char} \PYG{o}{*}\PYG{n}{line} \PYG{o}{=} \PYG{n}{in}\PYG{p}{.}\PYG{n}{next\PYGZus{}line}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{c+c1}{//          os \PYGZlt{}\PYGZlt{} line \PYGZlt{}\PYGZlt{} endl;}
            \PYG{k}{if}\PYG{p}{(}\PYG{n}{line} \PYG{o}{=}\PYG{o}{=} \PYG{k}{nullptr}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{k}{if}\PYG{p}{(}\PYG{o}{!}\PYG{n}{bPrint}\PYG{p}{)}
                \PYG{p}{\PYGZob{}}
                    \PYG{n}{cerr} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Input dimensions incorrect \PYGZhy{} read past end of file.}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
                    \PYG{n}{bPrint} \PYG{o}{=} \PYG{n+nb}{true}\PYG{p}{;}
                \PYG{p}{\PYGZcb{}}
                \PYG{k}{break}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
            \PYG{k}{else}
            \PYG{p}{\PYGZob{}}
                \PYG{k+kt}{char} \PYG{o}{*}\PYG{n}{dToken}\PYG{p}{;}
                \PYG{n}{dToken} \PYG{o}{=} \PYG{n}{strtok}\PYG{p}{(}\PYG{n}{line}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{,}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
                \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{j} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{j} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{6}\PYG{p}{;} \PYG{n}{j}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
                \PYG{p}{\PYGZob{}}
                    \PYG{c+c1}{//                      os \PYGZlt{}\PYGZlt{} j \PYGZlt{}\PYGZlt{} endl;}
                    \PYG{k}{if}\PYG{p}{(}\PYG{n}{dToken} \PYG{o}{=}\PYG{o}{=} \PYG{k}{nullptr}\PYG{p}{)}
                    \PYG{p}{\PYGZob{}}
                        \PYG{k}{if}\PYG{p}{(}\PYG{o}{!}\PYG{n}{bPrint}\PYG{p}{)}
                        \PYG{p}{\PYGZob{}}
                            \PYG{n}{cerr} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Input dimensions incorrect \PYGZhy{} read past end of file.}\PYG{l+s}{\PYGZdq{}}
                                 \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
                            \PYG{n}{bPrint} \PYG{o}{=} \PYG{n+nb}{true}\PYG{p}{;}
                        \PYG{p}{\PYGZcb{}}
                        \PYG{k}{break}\PYG{p}{;}
                    \PYG{p}{\PYGZcb{}}
                    \PYG{k}{else}
                    \PYG{p}{\PYGZob{}}
                        \PYG{c+c1}{//                          os \PYGZlt{}\PYGZlt{} \PYGZdq{}\PYGZhy{}\PYGZdq{} \PYGZlt{}\PYGZlt{} endl;}
                        \PYG{k}{switch}\PYG{p}{(}\PYG{n}{j}\PYG{p}{)}
                        \PYG{p}{\PYGZob{}}
                            \PYG{k}{case} \PYG{l+m+mi}{0}\PYG{o}{:}
                                \PYG{n}{fragments}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{name} \PYG{o}{=} \PYG{n}{string}\PYG{p}{(}\PYG{n}{dToken}\PYG{p}{)}\PYG{p}{;}
                                \PYG{k}{break}\PYG{p}{;}
                            \PYG{k}{case} \PYG{l+m+mi}{1}\PYG{o}{:}
                                \PYG{n}{fragments}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{x\PYGZus{}west} \PYG{o}{=} \PYG{n}{atoi}\PYG{p}{(}\PYG{n}{dToken}\PYG{p}{)}\PYG{p}{;}
                                \PYG{k}{break}\PYG{p}{;}
                            \PYG{k}{case} \PYG{l+m+mi}{2}\PYG{o}{:}
                                \PYG{n}{fragments}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{y\PYGZus{}north} \PYG{o}{=} \PYG{n}{atoi}\PYG{p}{(}\PYG{n}{dToken}\PYG{p}{)}\PYG{p}{;}
                                \PYG{k}{break}\PYG{p}{;}
                            \PYG{k}{case} \PYG{l+m+mi}{3}\PYG{o}{:}
                                \PYG{n}{fragments}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{x\PYGZus{}east} \PYG{o}{=} \PYG{n}{atoi}\PYG{p}{(}\PYG{n}{dToken}\PYG{p}{)}\PYG{p}{;}
                                \PYG{k}{break}\PYG{p}{;}
                            \PYG{k}{case} \PYG{l+m+mi}{4}\PYG{o}{:}
                                \PYG{n}{fragments}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{y\PYGZus{}south} \PYG{o}{=} \PYG{n}{atoi}\PYG{p}{(}\PYG{n}{dToken}\PYG{p}{)}\PYG{p}{;}
                                \PYG{k}{break}\PYG{p}{;}
                            \PYG{k}{case} \PYG{l+m+mi}{5}\PYG{o}{:}
                                \PYG{n}{fragments}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{area} \PYG{o}{=} \PYG{n}{atof}\PYG{p}{(}\PYG{n}{dToken}\PYG{p}{)}\PYG{p}{;}
                                \PYG{k}{break}\PYG{p}{;}
                        \PYG{p}{\PYGZcb{}}
                        \PYG{n}{dToken} \PYG{o}{=} \PYG{n}{strtok}\PYG{p}{(}\PYG{n+nb}{NULL}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{,}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
                    \PYG{p}{\PYGZcb{}}
                \PYG{p}{\PYGZcb{}}
            \PYG{p}{\PYGZcb{}}
        \PYG{p}{\PYGZcb{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifndef use\PYGZus{}csv}
        \PYG{n}{cerr} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Cannot importSpatialParameters fragments from }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{fragment\PYGZus{}file} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ without fast\PYGZhy{}cpp\PYGZhy{}csv\PYGZhy{}parser.}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
        \PYG{n}{cerr} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Make sure the program has been compiled with \PYGZhy{}D use\PYGZus{}csv.}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif}
    \PYG{p}{\PYGZcb{}}
\PYG{c+c1}{//  os \PYGZlt{}\PYGZlt{} \PYGZdq{}Completed fragmentation analysis: \PYGZdq{} \PYGZlt{}\PYGZlt{} fragments.size() \PYGZlt{}\PYGZlt{} \PYGZdq{} fragments identified.\PYGZdq{} \PYGZlt{}\PYGZlt{} endl;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{void} \PYG{n}{Community}\PYG{o}{:}\PYG{o}{:}\PYG{n}{applyFragments}\PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{c+c1}{// For each fragment in the vector, perform the analysis and record the data in to a new data object, which will}
    \PYG{c+c1}{// then be outputted to an SQL file.}
    \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{fragments}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{stringstream} \PYG{n}{os}\PYG{p}{;}
        \PYG{n}{os} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}r}\PYG{l+s}{Applying fragments... }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{p}{(}\PYG{n}{i} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{/}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{fragments}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{      }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{flush}\PYG{p}{;}
        \PYG{n}{writeInfo}\PYG{p}{(}\PYG{n}{os}\PYG{p}{.}\PYG{n}{str}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
        \PYG{c+c1}{// Set the new samplemask to the fragment}
        \PYG{n}{samplemask}\PYG{p}{.}\PYG{n}{setFragment}\PYG{p}{(}\PYG{n}{fragments}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
        \PYG{c+c1}{// Now filter only those lineages which exist in the fragments.}
        \PYG{c+c1}{// We also want to count the number of individuals that actually exist}
        \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{iSpecCount} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
        \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{j} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{j} \PYG{o}{\PYGZlt{}} \PYG{n}{nodes}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{n}{j}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{TreeNode} \PYG{o}{*}\PYG{n}{this\PYGZus{}node} \PYG{o}{=} \PYG{o}{\PYGZam{}}\PYG{p}{(}\PYG{o}{*}\PYG{n}{nodes}\PYG{p}{)}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{p}{;}
            \PYG{k}{if}\PYG{p}{(}\PYG{n}{this\PYGZus{}node}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{isTip}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{n}{samplemask}\PYG{p}{.}\PYG{n}{getMaskVal}\PYG{p}{(}\PYG{n}{this\PYGZus{}node}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{getXpos}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{n}{this\PYGZus{}node}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{getYpos}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,}
                                                           \PYG{n}{this\PYGZus{}node}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{getXwrap}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{n}{this\PYGZus{}node}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{getYwrap}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}}
               \PYG{n}{doubleCompare}\PYG{p}{(}\PYG{n}{this\PYGZus{}node}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{getGeneration}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{n}{current\PYGZus{}community\PYGZus{}parameters}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{time}\PYG{p}{,} \PYG{l+m+mf}{0.0001}\PYG{p}{)}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{c+c1}{// if they exist exactly in the generation of interest.}
                \PYG{n}{this\PYGZus{}node}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{setExistence}\PYG{p}{(}\PYG{n+nb}{true}\PYG{p}{)}\PYG{p}{;}
                \PYG{n}{iSpecCount}\PYG{o}{+}\PYG{o}{+}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
            \PYG{k}{else} \PYG{k}{if}\PYG{p}{(}\PYG{n}{this\PYGZus{}node}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{isTip}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{n}{this\PYGZus{}node}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{setExistence}\PYG{p}{(}\PYG{n+nb}{false}\PYG{p}{)}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
        \PYG{p}{\PYGZcb{}}
        \PYG{n}{fragments}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{num} \PYG{o}{=} \PYG{n}{iSpecCount}\PYG{p}{;}
        \PYG{c+c1}{// Now calculate the species abundance. This will create a vector with lots of zeros in it. However, the}
        \PYG{c+c1}{// database creation will filter these out.}
        \PYG{n}{calcSpeciesAbundance}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{createFragmentDatabase}\PYG{p}{(}\PYG{n}{fragments}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
        \PYG{c+c1}{//          os \PYGZlt{}\PYGZlt{} \PYGZdq{}done!\PYGZdq{} \PYGZlt{}\PYGZlt{} endl;}
    \PYG{p}{\PYGZcb{}}
    \PYG{n}{samplemask}\PYG{p}{.}\PYG{n}{removeFragment}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{writeInfo}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{done!}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{void} \PYG{n}{Community}\PYG{o}{:}\PYG{o}{:}\PYG{n}{importSimParameters}\PYG{p}{(}\PYG{n}{string} \PYG{n}{file}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k}{if}\PYG{p}{(}\PYG{n}{bDataImport}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{return}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{if}\PYG{p}{(}\PYG{o}{!}\PYG{n}{bSqlConnection}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifdef DEBUG}
        \PYG{n}{stringstream} \PYG{n}{os}\PYG{p}{;}
        \PYG{n}{os} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{opening connection...}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{flush}\PYG{p}{;}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif}
        \PYG{n}{openSqlConnection}\PYG{p}{(}\PYG{n}{file}\PYG{p}{)}\PYG{p}{;}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifdef DEBUG}
        \PYG{n}{os} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{done!}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
        \PYG{n}{writeInfo}\PYG{p}{(}\PYG{n}{os}\PYG{p}{.}\PYG{n}{str}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{try}
    \PYG{p}{\PYGZob{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifdef DEBUG}
        \PYG{n}{stringstream} \PYG{n}{os}\PYG{p}{;}
        \PYG{n}{os} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Reading parameters...}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{flush}\PYG{p}{;}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif}
        \PYG{n}{sqlite3\PYGZus{}stmt} \PYG{o}{*}\PYG{n}{stmt2}\PYG{p}{;}
        \PYG{n}{string} \PYG{n}{sql\PYGZus{}parameters} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{SELECT speciation\PYGZus{}rate, grid\PYGZus{}x, grid\PYGZus{}y, protracted, min\PYGZus{}speciation\PYGZus{}gen, max\PYGZus{}speciation\PYGZus{}gen, }\PYG{l+s}{\PYGZdq{}}
                \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{sample\PYGZus{}x\PYGZus{}offset, sample\PYGZus{}y\PYGZus{}offset, sample\PYGZus{}x, sample\PYGZus{}y  FROM SIMULATION\PYGZus{}PARAMETERS;}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
        \PYG{k+kt}{int} \PYG{n}{rc} \PYG{o}{=} \PYG{n}{sqlite3\PYGZus{}prepare\PYGZus{}v2}\PYG{p}{(}\PYG{n}{database}\PYG{p}{,} \PYG{n}{sql\PYGZus{}parameters}\PYG{p}{.}\PYG{n}{c\PYGZus{}str}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{k}{static\PYGZus{}cast}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{n}{strlen}\PYG{p}{(}\PYG{n}{sql\PYGZus{}parameters}\PYG{p}{.}\PYG{n}{c\PYGZus{}str}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}\PYG{p}{,}
                                    \PYG{o}{\PYGZam{}}\PYG{n}{stmt2}\PYG{p}{,} \PYG{k}{nullptr}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{rc} \PYG{o}{!}\PYG{o}{=} \PYG{n}{SQLITE\PYGZus{}DONE} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{n}{rc} \PYG{o}{!}\PYG{o}{=} \PYG{n}{SQLITE\PYGZus{}OK}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{stringstream} \PYG{n}{ss}\PYG{p}{;}
            \PYG{n}{ss} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ERROR\PYGZus{}SQL\PYGZus{}020: FATAL. Could not open simulation parameters in }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{file} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{. Error code: }\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
            \PYG{n}{ss} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{sqlite3\PYGZus{}errmsg}\PYG{p}{(}\PYG{n}{database}\PYG{p}{)}\PYG{p}{;}
            \PYG{n}{sqlite3\PYGZus{}close}\PYG{p}{(}\PYG{n}{outdatabase}\PYG{p}{)}\PYG{p}{;}
            \PYG{n}{sqlite3\PYGZus{}close}\PYG{p}{(}\PYG{n}{database}\PYG{p}{)}\PYG{p}{;}
            \PYG{k}{throw} \PYG{n+nf}{SpeciesException}\PYG{p}{(}\PYG{n}{ss}\PYG{p}{.}\PYG{n}{str}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{n}{sqlite3\PYGZus{}step}\PYG{p}{(}\PYG{n}{stmt2}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{min\PYGZus{}spec\PYGZus{}rate} \PYG{o}{=} \PYG{n}{sqlite3\PYGZus{}column\PYGZus{}double}\PYG{p}{(}\PYG{n}{stmt2}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{grid\PYGZus{}x\PYGZus{}size} \PYG{o}{=} \PYG{k}{static\PYGZus{}cast}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{unsigned} \PYG{k+kt}{long}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{n}{sqlite3\PYGZus{}column\PYGZus{}int}\PYG{p}{(}\PYG{n}{stmt2}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{grid\PYGZus{}y\PYGZus{}size} \PYG{o}{=} \PYG{k}{static\PYGZus{}cast}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{unsigned} \PYG{k+kt}{long}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{n}{sqlite3\PYGZus{}column\PYGZus{}int}\PYG{p}{(}\PYG{n}{stmt2}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{protracted} \PYG{o}{=} \PYG{k+kt}{bool}\PYG{p}{(}\PYG{n}{sqlite3\PYGZus{}column\PYGZus{}int}\PYG{p}{(}\PYG{n}{stmt2}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{min\PYGZus{}speciation\PYGZus{}gen} \PYG{o}{=} \PYG{n}{sqlite3\PYGZus{}column\PYGZus{}double}\PYG{p}{(}\PYG{n}{stmt2}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{max\PYGZus{}speciation\PYGZus{}gen} \PYG{o}{=} \PYG{n}{sqlite3\PYGZus{}column\PYGZus{}double}\PYG{p}{(}\PYG{n}{stmt2}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{samplemask\PYGZus{}x\PYGZus{}offset} \PYG{o}{=} \PYG{k}{static\PYGZus{}cast}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{unsigned} \PYG{k+kt}{long}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{n}{sqlite3\PYGZus{}column\PYGZus{}int}\PYG{p}{(}\PYG{n}{stmt2}\PYG{p}{,} \PYG{l+m+mi}{6}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{samplemask\PYGZus{}y\PYGZus{}offset} \PYG{o}{=} \PYG{k}{static\PYGZus{}cast}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{unsigned} \PYG{k+kt}{long}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{n}{sqlite3\PYGZus{}column\PYGZus{}int}\PYG{p}{(}\PYG{n}{stmt2}\PYG{p}{,} \PYG{l+m+mi}{7}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{samplemask\PYGZus{}x\PYGZus{}size} \PYG{o}{=} \PYG{k}{static\PYGZus{}cast}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{unsigned} \PYG{k+kt}{long}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{n}{sqlite3\PYGZus{}column\PYGZus{}int}\PYG{p}{(}\PYG{n}{stmt2}\PYG{p}{,} \PYG{l+m+mi}{8}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{samplemask\PYGZus{}y\PYGZus{}size} \PYG{o}{=} \PYG{k}{static\PYGZus{}cast}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{unsigned} \PYG{k+kt}{long}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{n}{sqlite3\PYGZus{}column\PYGZus{}int}\PYG{p}{(}\PYG{n}{stmt2}\PYG{p}{,} \PYG{l+m+mi}{9}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{protracted}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{k}{if}\PYG{p}{(}\PYG{n}{max\PYGZus{}speciation\PYGZus{}gen} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mf}{0.0}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{k}{throw} \PYG{n}{SpeciesException}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Protracted speciation does not make sense when maximum speciation gen is 0.0.}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
            \PYG{k}{if}\PYG{p}{(}\PYG{n}{min\PYGZus{}speciation\PYGZus{}gen} \PYG{o}{\PYGZgt{}} \PYG{n}{max\PYGZus{}speciation\PYGZus{}gen}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{k}{throw} \PYG{n}{SpeciesException}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Cannot have simulation with minimum speciation generation less than maximum!}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
        \PYG{p}{\PYGZcb{}}
        \PYG{n}{sqlite3\PYGZus{}step}\PYG{p}{(}\PYG{n}{stmt2}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{sqlite3\PYGZus{}finalize}\PYG{p}{(}\PYG{n}{stmt2}\PYG{p}{)}\PYG{p}{;}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifdef DEBUG}
        \PYG{n}{os} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{done!}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
        \PYG{n}{writeInfo}\PYG{p}{(}\PYG{n}{os}\PYG{p}{.}\PYG{n}{str}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{catch}\PYG{p}{(}\PYG{n}{exception} \PYG{o}{\PYGZam{}}\PYG{n}{er}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{throw} \PYG{n}{SpeciesException}\PYG{p}{(}\PYG{n}{er}\PYG{p}{.}\PYG{n}{what}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{n}{bDataImport} \PYG{o}{=} \PYG{n+nb}{true}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{void} \PYG{n}{Community}\PYG{o}{:}\PYG{o}{:}\PYG{n}{setProtractedParameters}\PYG{p}{(}\PYG{k+kt}{double} \PYG{n}{max\PYGZus{}speciation\PYGZus{}gen\PYGZus{}in}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k}{if}\PYG{p}{(}\PYG{n}{max\PYGZus{}speciation\PYGZus{}gen\PYGZus{}in} \PYG{o}{\PYGZgt{}} \PYG{n}{max\PYGZus{}speciation\PYGZus{}gen}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{throw} \PYG{n}{SpeciesException}\PYG{p}{(}
                \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Maximum protracted speciation generation is higher than original value for simulation.}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{else}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{applied\PYGZus{}max\PYGZus{}speciation\PYGZus{}gen} \PYG{o}{=} \PYG{n}{max\PYGZus{}speciation\PYGZus{}gen\PYGZus{}in}\PYG{p}{;}
        \PYG{n}{protracted} \PYG{o}{=} \PYG{n+nb}{true}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{void} \PYG{n}{Community}\PYG{o}{:}\PYG{o}{:}\PYG{n}{setProtractedParameters}\PYG{p}{(}\PYG{k}{const} \PYG{k+kt}{double} \PYG{o}{\PYGZam{}}\PYG{n}{min\PYGZus{}speciation\PYGZus{}gen\PYGZus{}in}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{double} \PYG{o}{\PYGZam{}}\PYG{n}{max\PYGZus{}speciation\PYGZus{}gen\PYGZus{}in}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{n}{applied\PYGZus{}max\PYGZus{}speciation\PYGZus{}gen} \PYG{o}{=} \PYG{n}{max\PYGZus{}speciation\PYGZus{}gen\PYGZus{}in}\PYG{p}{;}
    \PYG{n}{applied\PYGZus{}min\PYGZus{}speciation\PYGZus{}gen} \PYG{o}{=} \PYG{n}{min\PYGZus{}speciation\PYGZus{}gen\PYGZus{}in}\PYG{p}{;}
    \PYG{k}{if}\PYG{p}{(}\PYG{n}{min\PYGZus{}speciation\PYGZus{}gen} \PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{0} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{n}{max\PYGZus{}speciation\PYGZus{}gen} \PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{0} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}}
            \PYG{p}{(}\PYG{n}{applied\PYGZus{}min\PYGZus{}speciation\PYGZus{}gen} \PYG{o}{\PYGZgt{}} \PYG{n}{min\PYGZus{}speciation\PYGZus{}gen} \PYG{o}{\textbar{}}\PYG{o}{\textbar{}} \PYG{n}{applied\PYGZus{}max\PYGZus{}speciation\PYGZus{}gen} \PYG{o}{\PYGZgt{}} \PYG{n}{max\PYGZus{}speciation\PYGZus{}gen}\PYG{p}{)}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifdef DEBUG}
        \PYG{n}{writeLog}\PYG{p}{(}\PYG{l+m+mi}{50}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Applied speciation parameters: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{+} \PYG{n}{to\PYGZus{}string}\PYG{p}{(}\PYG{n}{applied\PYGZus{}min\PYGZus{}speciation\PYGZus{}gen}\PYG{p}{)} \PYG{o}{+} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{, }\PYG{l+s}{\PYGZdq{}} \PYG{o}{+}
                \PYG{n}{to\PYGZus{}string}\PYG{p}{(}\PYG{n}{applied\PYGZus{}max\PYGZus{}speciation\PYGZus{}gen}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{writeLog}\PYG{p}{(}\PYG{l+m+mi}{50}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Simulated speciation parameters: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{+} \PYG{n}{to\PYGZus{}string}\PYG{p}{(}\PYG{n}{min\PYGZus{}speciation\PYGZus{}gen\PYGZus{}in}\PYG{p}{)} \PYG{o}{+} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{, }\PYG{l+s}{\PYGZdq{}} \PYG{o}{+}
                     \PYG{n}{to\PYGZus{}string}\PYG{p}{(}\PYG{n}{max\PYGZus{}speciation\PYGZus{}gen\PYGZus{}in}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif }\PYG{c+c1}{// DEBUG}
        \PYG{k}{throw} \PYG{n+nf}{SpeciesException}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Cannot use protracted parameters with minimum \PYGZgt{} simulated minimum or }\PYG{l+s}{\PYGZdq{}}
                                       \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{maximum \PYGZgt{} simulated maximums.}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{void} \PYG{n}{Community}\PYG{o}{:}\PYG{o}{:}\PYG{n}{overrideProtractedParameters}\PYG{p}{(}\PYG{k}{const} \PYG{k+kt}{double} \PYG{o}{\PYGZam{}}\PYG{n}{min\PYGZus{}speciation\PYGZus{}gen\PYGZus{}in}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{double} \PYG{o}{\PYGZam{}}\PYG{n}{max\PYGZus{}speciation\PYGZus{}gen\PYGZus{}in}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{n}{min\PYGZus{}speciation\PYGZus{}gen} \PYG{o}{=} \PYG{n}{min\PYGZus{}speciation\PYGZus{}gen\PYGZus{}in}\PYG{p}{;}
    \PYG{n}{max\PYGZus{}speciation\PYGZus{}gen} \PYG{o}{=} \PYG{n}{max\PYGZus{}speciation\PYGZus{}gen\PYGZus{}in}\PYG{p}{;}
    \PYG{n}{applied\PYGZus{}max\PYGZus{}speciation\PYGZus{}gen} \PYG{o}{=} \PYG{n}{max\PYGZus{}speciation\PYGZus{}gen\PYGZus{}in}\PYG{p}{;}
    \PYG{n}{applied\PYGZus{}min\PYGZus{}speciation\PYGZus{}gen} \PYG{o}{=} \PYG{n}{min\PYGZus{}speciation\PYGZus{}gen\PYGZus{}in}\PYG{p}{;}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{void} \PYG{n}{Community}\PYG{o}{:}\PYG{o}{:}\PYG{n}{setProtracted}\PYG{p}{(}\PYG{k+kt}{bool} \PYG{n}{protracted\PYGZus{}in}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{n}{protracted} \PYG{o}{=} \PYG{n}{protracted\PYGZus{}in}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}


\PYG{k+kt}{void} \PYG{n}{Community}\PYG{o}{:}\PYG{o}{:}\PYG{n}{getPreviousCalcs}\PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{c+c1}{// Read the community parameters and store them in the relevant objects}
    \PYG{n}{sqlite3\PYGZus{}stmt} \PYG{o}{*}\PYG{n}{stmt1}\PYG{p}{;}
    \PYG{n}{string} \PYG{n}{call1} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{select count(type) from sqlite\PYGZus{}master where type=\PYGZsq{}table\PYGZsq{} and name=\PYGZsq{}COMMUNITY\PYGZus{}PARAMETERS\PYGZsq{}}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
    \PYG{k+kt}{int} \PYG{n}{rc} \PYG{o}{=} \PYG{n}{sqlite3\PYGZus{}prepare\PYGZus{}v2}\PYG{p}{(}\PYG{n}{database}\PYG{p}{,} \PYG{n}{call1}\PYG{p}{.}\PYG{n}{c\PYGZus{}str}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{k}{static\PYGZus{}cast}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{n}{strlen}\PYG{p}{(}\PYG{n}{call1}\PYG{p}{.}\PYG{n}{c\PYGZus{}str}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{stmt1}\PYG{p}{,} \PYG{k}{nullptr}\PYG{p}{)}\PYG{p}{;}
    \PYG{k}{if}\PYG{p}{(}\PYG{n}{rc} \PYG{o}{!}\PYG{o}{=} \PYG{n}{SQLITE\PYGZus{}DONE} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{n}{rc} \PYG{o}{!}\PYG{o}{=} \PYG{n}{SQLITE\PYGZus{}OK}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{sqlite3\PYGZus{}close}\PYG{p}{(}\PYG{n}{outdatabase}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{sqlite3\PYGZus{}close}\PYG{p}{(}\PYG{n}{database}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{throw} \PYG{n+nf}{SpeciesException}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ERROR\PYGZus{}SQL\PYGZus{}020: FATAL. Could not check for COMMUNITY\PYGZus{}PARAMETERS table. Error code: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{+}
                               \PYG{n}{to\PYGZus{}string}\PYG{p}{(}\PYG{n}{rc}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
        \PYG{c+c1}{//              exit(EXIT\PYGZus{}FAILURE);}
    \PYG{p}{\PYGZcb{}}
    \PYG{n}{sqlite3\PYGZus{}step}\PYG{p}{(}\PYG{n}{stmt1}\PYG{p}{)}\PYG{p}{;}
    \PYG{k}{auto} \PYG{n}{has\PYGZus{}community\PYGZus{}parameters} \PYG{o}{=} \PYG{k}{static\PYGZus{}cast}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{bool}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{n}{sqlite3\PYGZus{}column\PYGZus{}int}\PYG{p}{(}\PYG{n}{stmt1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{sqlite3\PYGZus{}step}\PYG{p}{(}\PYG{n}{stmt1}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{sqlite3\PYGZus{}finalize}\PYG{p}{(}\PYG{n}{stmt1}\PYG{p}{)}\PYG{p}{;}
    \PYG{c+c1}{// Read the speciation rates from the community\PYGZus{}parameters table}
    \PYG{k}{if}\PYG{p}{(}\PYG{n}{has\PYGZus{}community\PYGZus{}parameters}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{sqlite3\PYGZus{}stmt} \PYG{o}{*}\PYG{n}{stmt2}\PYG{p}{;}
        \PYG{n}{string} \PYG{n}{call2} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{SELECT reference, speciation\PYGZus{}rate, time, fragments, metacommunity\PYGZus{}reference FROM }\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
        \PYG{n}{call2} \PYG{o}{+}\PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{COMMUNITY\PYGZus{}PARAMETERS}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
        \PYG{n}{rc} \PYG{o}{=} \PYG{n}{sqlite3\PYGZus{}prepare\PYGZus{}v2}\PYG{p}{(}\PYG{n}{database}\PYG{p}{,} \PYG{n}{call2}\PYG{p}{.}\PYG{n}{c\PYGZus{}str}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{k}{static\PYGZus{}cast}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{n}{strlen}\PYG{p}{(}\PYG{n}{call2}\PYG{p}{.}\PYG{n}{c\PYGZus{}str}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{stmt2}\PYG{p}{,}
                                \PYG{k}{nullptr}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{rc} \PYG{o}{!}\PYG{o}{=} \PYG{n}{SQLITE\PYGZus{}DONE} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{n}{rc} \PYG{o}{!}\PYG{o}{=} \PYG{n}{SQLITE\PYGZus{}OK}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{sqlite3\PYGZus{}close}\PYG{p}{(}\PYG{n}{outdatabase}\PYG{p}{)}\PYG{p}{;}
            \PYG{n}{sqlite3\PYGZus{}close}\PYG{p}{(}\PYG{n}{database}\PYG{p}{)}\PYG{p}{;}
            \PYG{k}{throw} \PYG{n+nf}{SpeciesException}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ERROR\PYGZus{}SQL\PYGZus{}020: FATAL. Could not detect COMMUNITY\PYGZus{}PARAMETERS table. Error code: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{+}
                                   \PYG{n}{to\PYGZus{}string}\PYG{p}{(}\PYG{n}{rc}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{n}{rc} \PYG{o}{=} \PYG{n}{sqlite3\PYGZus{}step}\PYG{p}{(}\PYG{n}{stmt2}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{while}\PYG{p}{(}\PYG{n}{rc} \PYG{o}{=}\PYG{o}{=} \PYG{n}{SQLITE\PYGZus{}ROW}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{k}{auto} \PYG{n}{row\PYGZus{}val} \PYG{o}{=} \PYG{n}{sqlite3\PYGZus{}column\PYGZus{}int}\PYG{p}{(}\PYG{n}{stmt2}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}
            \PYG{k}{if}\PYG{p}{(}\PYG{n}{row\PYGZus{}val} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{n}{writeWarning}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Reference of 0 found in community parameters in database, skipping...}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
            \PYG{k}{else}
            \PYG{p}{\PYGZob{}}
                \PYG{n}{past\PYGZus{}communities}\PYG{p}{.}\PYG{n}{pushBack}\PYG{p}{(}\PYG{k}{static\PYGZus{}cast}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{unsigned} \PYG{k+kt}{long}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{n}{row\PYGZus{}val}\PYG{p}{)}\PYG{p}{,}
                                          \PYG{n}{sqlite3\PYGZus{}column\PYGZus{}double}\PYG{p}{(}\PYG{n}{stmt2}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{,}
                                          \PYG{n}{sqlite3\PYGZus{}column\PYGZus{}double}\PYG{p}{(}\PYG{n}{stmt2}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{,}
                                          \PYG{k+kt}{bool}\PYG{p}{(}\PYG{n}{sqlite3\PYGZus{}column\PYGZus{}int}\PYG{p}{(}\PYG{n}{stmt2}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{)}\PYG{p}{,}
                                          \PYG{k}{static\PYGZus{}cast}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{unsigned} \PYG{k+kt}{long}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{n}{sqlite3\PYGZus{}column\PYGZus{}int}\PYG{p}{(}\PYG{n}{stmt2}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
            \PYG{n}{rc} \PYG{o}{=} \PYG{n}{sqlite3\PYGZus{}step}\PYG{p}{(}\PYG{n}{stmt2}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{rc} \PYG{o}{!}\PYG{o}{=} \PYG{n}{SQLITE\PYGZus{}OK} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{n}{rc} \PYG{o}{!}\PYG{o}{=} \PYG{n}{SQLITE\PYGZus{}DONE}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{stringstream} \PYG{n}{ss}\PYG{p}{;}
            \PYG{n}{ss} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ERROR\PYGZus{}SQL\PYGZus{}020b: FATAL. Could not read community parameters.}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
            \PYG{n}{ss} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Code: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{rc} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Errmsg: }\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
            \PYG{n}{ss} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{sqlite3\PYGZus{}errmsg}\PYG{p}{(}\PYG{n}{database}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
            \PYG{n}{sqlite3\PYGZus{}clear\PYGZus{}bindings}\PYG{p}{(}\PYG{n}{stmt2}\PYG{p}{)}\PYG{p}{;}
            \PYG{n}{sqlite3\PYGZus{}reset}\PYG{p}{(}\PYG{n}{stmt2}\PYG{p}{)}\PYG{p}{;}
            \PYG{k}{throw} \PYG{n+nf}{SpeciesException}\PYG{p}{(}\PYG{n}{ss}\PYG{p}{.}\PYG{n}{str}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{n}{sqlite3\PYGZus{}finalize}\PYG{p}{(}\PYG{n}{stmt2}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{c+c1}{// And the same for metacommunity parameters}
    \PYG{n}{sqlite3\PYGZus{}stmt} \PYG{o}{*}\PYG{n}{stmt3}\PYG{p}{;}
    \PYG{n}{string} \PYG{n}{call3} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{select count(type) from sqlite\PYGZus{}master where type=\PYGZsq{}table\PYGZsq{} and name=\PYGZsq{}METACOMMUNITY\PYGZus{}PARAMETERS\PYGZsq{}}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
    \PYG{n}{rc} \PYG{o}{=} \PYG{n}{sqlite3\PYGZus{}prepare\PYGZus{}v2}\PYG{p}{(}\PYG{n}{database}\PYG{p}{,} \PYG{n}{call3}\PYG{p}{.}\PYG{n}{c\PYGZus{}str}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{k}{static\PYGZus{}cast}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{n}{strlen}\PYG{p}{(}\PYG{n}{call3}\PYG{p}{.}\PYG{n}{c\PYGZus{}str}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{stmt3}\PYG{p}{,} \PYG{k}{nullptr}\PYG{p}{)}\PYG{p}{;}
    \PYG{k}{if}\PYG{p}{(}\PYG{n}{rc} \PYG{o}{!}\PYG{o}{=} \PYG{n}{SQLITE\PYGZus{}DONE} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{n}{rc} \PYG{o}{!}\PYG{o}{=} \PYG{n}{SQLITE\PYGZus{}OK}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{sqlite3\PYGZus{}close}\PYG{p}{(}\PYG{n}{outdatabase}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{sqlite3\PYGZus{}close}\PYG{p}{(}\PYG{n}{database}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{throw} \PYG{n+nf}{SpeciesException}\PYG{p}{(}
                \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ERROR\PYGZus{}SQL\PYGZus{}020: FATAL. Could not check for METACOMMUNITY\PYGZus{}PARAMETERS table. Error code: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{+}
                \PYG{n}{to\PYGZus{}string}\PYG{p}{(}\PYG{n}{rc}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{n}{sqlite3\PYGZus{}step}\PYG{p}{(}\PYG{n}{stmt3}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{has\PYGZus{}community\PYGZus{}parameters} \PYG{o}{=} \PYG{k}{static\PYGZus{}cast}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{bool}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{n}{sqlite3\PYGZus{}column\PYGZus{}int}\PYG{p}{(}\PYG{n}{stmt3}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{sqlite3\PYGZus{}step}\PYG{p}{(}\PYG{n}{stmt3}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{sqlite3\PYGZus{}finalize}\PYG{p}{(}\PYG{n}{stmt3}\PYG{p}{)}\PYG{p}{;}
    \PYG{c+c1}{// Read the speciation rates from the community\PYGZus{}parameters table}
    \PYG{k}{if}\PYG{p}{(}\PYG{n}{has\PYGZus{}community\PYGZus{}parameters}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{sqlite3\PYGZus{}stmt} \PYG{o}{*}\PYG{n}{stmt4}\PYG{p}{;}
        \PYG{n}{string} \PYG{n}{call4} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{SELECT reference, speciation\PYGZus{}rate, metacommunity\PYGZus{}size FROM }\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
        \PYG{n}{call4} \PYG{o}{+}\PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{METACOMMUNITY\PYGZus{}PARAMETERS}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
        \PYG{n}{rc} \PYG{o}{=} \PYG{n}{sqlite3\PYGZus{}prepare\PYGZus{}v2}\PYG{p}{(}\PYG{n}{database}\PYG{p}{,} \PYG{n}{call4}\PYG{p}{.}\PYG{n}{c\PYGZus{}str}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{k}{static\PYGZus{}cast}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{n}{strlen}\PYG{p}{(}\PYG{n}{call4}\PYG{p}{.}\PYG{n}{c\PYGZus{}str}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{stmt4}\PYG{p}{,}
                                \PYG{k}{nullptr}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{rc} \PYG{o}{!}\PYG{o}{=} \PYG{n}{SQLITE\PYGZus{}DONE} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{n}{rc} \PYG{o}{!}\PYG{o}{=} \PYG{n}{SQLITE\PYGZus{}OK}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{sqlite3\PYGZus{}close}\PYG{p}{(}\PYG{n}{outdatabase}\PYG{p}{)}\PYG{p}{;}
            \PYG{n}{sqlite3\PYGZus{}close}\PYG{p}{(}\PYG{n}{database}\PYG{p}{)}\PYG{p}{;}
            \PYG{k}{throw} \PYG{n+nf}{SpeciesException}\PYG{p}{(}
                    \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ERROR\PYGZus{}SQL\PYGZus{}020: FATAL. Could not detect METACOMMUNITY\PYGZus{}PARAMETERS table. Error code: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{+}
                    \PYG{n}{to\PYGZus{}string}\PYG{p}{(}\PYG{n}{rc}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{n}{rc} \PYG{o}{=} \PYG{n}{sqlite3\PYGZus{}step}\PYG{p}{(}\PYG{n}{stmt4}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{while}\PYG{p}{(}\PYG{n}{rc} \PYG{o}{=}\PYG{o}{=} \PYG{n}{SQLITE\PYGZus{}ROW}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{past\PYGZus{}metacommunities}\PYG{p}{.}\PYG{n}{pushBack}\PYG{p}{(}\PYG{k}{static\PYGZus{}cast}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{unsigned} \PYG{k+kt}{long}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{n}{sqlite3\PYGZus{}column\PYGZus{}int}\PYG{p}{(}\PYG{n}{stmt4}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{)}\PYG{p}{,}
                                          \PYG{n}{sqlite3\PYGZus{}column\PYGZus{}double}\PYG{p}{(}\PYG{n}{stmt4}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{,}
                                          \PYG{k}{static\PYGZus{}cast}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{unsigned} \PYG{k+kt}{long}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{n}{sqlite3\PYGZus{}column\PYGZus{}int}\PYG{p}{(}\PYG{n}{stmt4}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
            \PYG{n}{rc} \PYG{o}{=} \PYG{n}{sqlite3\PYGZus{}step}\PYG{p}{(}\PYG{n}{stmt4}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{rc} \PYG{o}{!}\PYG{o}{=} \PYG{n}{SQLITE\PYGZus{}OK} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{n}{rc} \PYG{o}{!}\PYG{o}{=} \PYG{n}{SQLITE\PYGZus{}DONE}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{stringstream} \PYG{n}{ss}\PYG{p}{;}
            \PYG{n}{ss} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ERROR\PYGZus{}SQL\PYGZus{}020: FATAL. Could not read metacommunity parameters.}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
            \PYG{n}{ss} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Code: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{rc} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Errmsg: }\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
            \PYG{n}{ss} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{sqlite3\PYGZus{}errmsg}\PYG{p}{(}\PYG{n}{database}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
            \PYG{n}{sqlite3\PYGZus{}clear\PYGZus{}bindings}\PYG{p}{(}\PYG{n}{stmt4}\PYG{p}{)}\PYG{p}{;}
            \PYG{n}{sqlite3\PYGZus{}reset}\PYG{p}{(}\PYG{n}{stmt4}\PYG{p}{)}\PYG{p}{;}
            \PYG{k}{throw} \PYG{n+nf}{SpeciesException}\PYG{p}{(}\PYG{n}{ss}\PYG{p}{.}\PYG{n}{str}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{n}{sqlite3\PYGZus{}step}\PYG{p}{(}\PYG{n}{stmt4}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{sqlite3\PYGZus{}finalize}\PYG{p}{(}\PYG{n}{stmt4}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{void} \PYG{n}{Community}\PYG{o}{:}\PYG{o}{:}\PYG{n}{addCalculationPerformed}\PYG{p}{(}\PYG{k+kt}{long} \PYG{k+kt}{double} \PYG{n}{speciation\PYGZus{}rate}\PYG{p}{,} \PYG{k+kt}{double} \PYG{n}{time}\PYG{p}{,} \PYG{k+kt}{bool} \PYG{n}{fragments}\PYG{p}{,}
                                       \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{metacommunity\PYGZus{}size}\PYG{p}{,} \PYG{k+kt}{long} \PYG{k+kt}{double} \PYG{n}{metacommunity\PYGZus{}speciation\PYGZus{}rate}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k}{auto} \PYG{n}{meta\PYGZus{}reference} \PYG{o}{=} \PYG{n}{past\PYGZus{}metacommunities}\PYG{p}{.}\PYG{n}{getReference}\PYG{p}{(}\PYG{n}{metacommunity\PYGZus{}speciation\PYGZus{}rate}\PYG{p}{,}
                                                            \PYG{n}{metacommunity\PYGZus{}size}\PYG{p}{)}\PYG{p}{;}
    \PYG{k}{if}\PYG{p}{(}\PYG{n}{meta\PYGZus{}reference} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{0} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{n}{metacommunity\PYGZus{}size} \PYG{o}{!}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{meta\PYGZus{}reference} \PYG{o}{=} \PYG{n}{past\PYGZus{}metacommunities}\PYG{p}{.}\PYG{n}{addNew}\PYG{p}{(}\PYG{n}{metacommunity\PYGZus{}speciation\PYGZus{}rate}\PYG{p}{,} \PYG{n}{metacommunity\PYGZus{}size}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{else}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{meta\PYGZus{}reference} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{n}{current\PYGZus{}community\PYGZus{}parameters} \PYG{o}{=} \PYG{o}{\PYGZam{}}\PYG{n}{past\PYGZus{}communities}\PYG{p}{.}\PYG{n}{addNew}\PYG{p}{(}\PYG{n}{speciation\PYGZus{}rate}\PYG{p}{,} \PYG{n}{time}\PYG{p}{,} \PYG{n}{fragments}\PYG{p}{,} \PYG{n}{meta\PYGZus{}reference}\PYG{p}{)}\PYG{p}{;}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifdef DEBUG}
    \PYG{k}{for}\PYG{p}{(}\PYG{k}{auto} \PYG{o}{\PYGZam{}}\PYG{n+nl}{i} \PYG{p}{:} \PYG{n}{past\PYGZus{}communities}\PYG{p}{.}\PYG{n}{calc\PYGZus{}array}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{doubleCompare}\PYG{p}{(}\PYG{n}{i}\PYG{p}{.}\PYG{n}{time}\PYG{p}{,} \PYG{n}{current\PYGZus{}community\PYGZus{}parameters}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{time}\PYG{p}{,} \PYG{l+m+mf}{0.00001}\PYG{p}{)} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}}
            \PYG{n}{doubleCompare}\PYG{p}{(}\PYG{n}{i}\PYG{p}{.}\PYG{n}{speciation\PYGZus{}rate}\PYG{p}{,} \PYG{n}{current\PYGZus{}community\PYGZus{}parameters}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{speciation\PYGZus{}rate}\PYG{p}{,}
                          \PYG{n}{i}\PYG{p}{.}\PYG{n}{speciation\PYGZus{}rate}\PYG{o}{*}\PYG{l+m+mf}{0.00001}\PYG{p}{)} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}}
                \PYG{n}{i}\PYG{p}{.}\PYG{n}{metacommunity\PYGZus{}reference} \PYG{o}{=}\PYG{o}{=} \PYG{n}{current\PYGZus{}community\PYGZus{}parameters}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{metacommunity\PYGZus{}reference} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}}
                \PYG{n}{i}\PYG{p}{.}\PYG{n}{reference} \PYG{o}{!}\PYG{o}{=} \PYG{n}{current\PYGZus{}community\PYGZus{}parameters}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{reference}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{k}{throw} \PYG{n}{FatalException}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Communities are identical, but references differ! Please report this bug.}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
    \PYG{p}{\PYGZcb{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif }\PYG{c+c1}{// DEBUG}
\PYG{p}{\PYGZcb{}}

\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{unsigned} \PYG{k+kt}{long}\PYG{o}{\PYGZgt{}} \PYG{n}{Community}\PYG{o}{:}\PYG{o}{:}\PYG{n}{getUniqueCommunityRefs}\PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{unsigned} \PYG{k+kt}{long}\PYG{o}{\PYGZgt{}} \PYG{n}{unique\PYGZus{}community\PYGZus{}refs}\PYG{p}{;}
    \PYG{c+c1}{// Read the community parameters and store them in the relevant objects}
    \PYG{n}{sqlite3\PYGZus{}stmt} \PYG{o}{*}\PYG{n}{stmt1}\PYG{p}{;}
    \PYG{n}{string} \PYG{n}{call1} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{select count(type) from sqlite\PYGZus{}master where type=\PYGZsq{}table\PYGZsq{} and name=\PYGZsq{}COMMUNITY\PYGZus{}PARAMETERS\PYGZsq{}}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
    \PYG{k+kt}{int} \PYG{n}{rc} \PYG{o}{=} \PYG{n}{sqlite3\PYGZus{}prepare\PYGZus{}v2}\PYG{p}{(}\PYG{n}{database}\PYG{p}{,} \PYG{n}{call1}\PYG{p}{.}\PYG{n}{c\PYGZus{}str}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{k}{static\PYGZus{}cast}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{n}{strlen}\PYG{p}{(}\PYG{n}{call1}\PYG{p}{.}\PYG{n}{c\PYGZus{}str}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{stmt1}\PYG{p}{,} \PYG{k}{nullptr}\PYG{p}{)}\PYG{p}{;}
    \PYG{k}{if}\PYG{p}{(}\PYG{n}{rc} \PYG{o}{!}\PYG{o}{=} \PYG{n}{SQLITE\PYGZus{}DONE} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{n}{rc} \PYG{o}{!}\PYG{o}{=} \PYG{n}{SQLITE\PYGZus{}OK}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{sqlite3\PYGZus{}close}\PYG{p}{(}\PYG{n}{outdatabase}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{sqlite3\PYGZus{}close}\PYG{p}{(}\PYG{n}{database}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{throw} \PYG{n+nf}{SpeciesException}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ERROR\PYGZus{}SQL\PYGZus{}020: FATAL. Could not check for COMMUNITY\PYGZus{}PARAMETERS table. Error code: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{+}
                               \PYG{n}{to\PYGZus{}string}\PYG{p}{(}\PYG{n}{rc}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
        \PYG{c+c1}{//              exit(EXIT\PYGZus{}FAILURE);}
    \PYG{p}{\PYGZcb{}}
    \PYG{n}{sqlite3\PYGZus{}step}\PYG{p}{(}\PYG{n}{stmt1}\PYG{p}{)}\PYG{p}{;}
    \PYG{k}{auto} \PYG{n}{has\PYGZus{}community\PYGZus{}parameters} \PYG{o}{=} \PYG{k}{static\PYGZus{}cast}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{bool}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{n}{sqlite3\PYGZus{}column\PYGZus{}int}\PYG{p}{(}\PYG{n}{stmt1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{sqlite3\PYGZus{}step}\PYG{p}{(}\PYG{n}{stmt1}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{sqlite3\PYGZus{}finalize}\PYG{p}{(}\PYG{n}{stmt1}\PYG{p}{)}\PYG{p}{;}
    \PYG{c+c1}{// Read the speciation rates from the community\PYGZus{}parameters table}
    \PYG{k}{if}\PYG{p}{(}\PYG{n}{has\PYGZus{}community\PYGZus{}parameters}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{sqlite3\PYGZus{}stmt} \PYG{o}{*}\PYG{n}{stmt2}\PYG{p}{;}
        \PYG{n}{string} \PYG{n}{call2} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{SELECT DISTINCT(reference) FROM COMMUNITY\PYGZus{}PARAMETERS}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
        \PYG{n}{rc} \PYG{o}{=} \PYG{n}{sqlite3\PYGZus{}prepare\PYGZus{}v2}\PYG{p}{(}\PYG{n}{database}\PYG{p}{,} \PYG{n}{call2}\PYG{p}{.}\PYG{n}{c\PYGZus{}str}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{k}{static\PYGZus{}cast}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{n}{strlen}\PYG{p}{(}\PYG{n}{call2}\PYG{p}{.}\PYG{n}{c\PYGZus{}str}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{stmt2}\PYG{p}{,}
                                \PYG{k}{nullptr}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{rc} \PYG{o}{!}\PYG{o}{=} \PYG{n}{SQLITE\PYGZus{}DONE} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{n}{rc} \PYG{o}{!}\PYG{o}{=} \PYG{n}{SQLITE\PYGZus{}OK}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{sqlite3\PYGZus{}close}\PYG{p}{(}\PYG{n}{outdatabase}\PYG{p}{)}\PYG{p}{;}
            \PYG{n}{sqlite3\PYGZus{}close}\PYG{p}{(}\PYG{n}{database}\PYG{p}{)}\PYG{p}{;}
            \PYG{k}{throw} \PYG{n+nf}{SpeciesException}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ERROR\PYGZus{}SQL\PYGZus{}020: FATAL. Could not detect COMMUNITY\PYGZus{}PARAMETERS table. Error code: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{+}
                                   \PYG{n}{to\PYGZus{}string}\PYG{p}{(}\PYG{n}{rc}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{n}{rc} \PYG{o}{=} \PYG{n}{sqlite3\PYGZus{}step}\PYG{p}{(}\PYG{n}{stmt2}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{while}\PYG{p}{(}\PYG{n}{rc} \PYG{o}{!}\PYG{o}{=} \PYG{n}{SQLITE\PYGZus{}DONE}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{unique\PYGZus{}community\PYGZus{}refs}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{k}{static\PYGZus{}cast}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{unsigned} \PYG{k+kt}{long}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{n}{sqlite3\PYGZus{}column\PYGZus{}int}\PYG{p}{(}\PYG{n}{stmt2}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
            \PYG{n}{rc} \PYG{o}{=} \PYG{n}{sqlite3\PYGZus{}step}\PYG{p}{(}\PYG{n}{stmt2}\PYG{p}{)}\PYG{p}{;}
            \PYG{k}{if}\PYG{p}{(}\PYG{n}{rc} \PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{10000}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{k}{throw} \PYG{n}{SpeciesException}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ERROR\PYGZus{}SQL\PYGZus{}020: FATAL. Could not read speciation rates.}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
        \PYG{p}{\PYGZcb{}}
        \PYG{n}{sqlite3\PYGZus{}step}\PYG{p}{(}\PYG{n}{stmt2}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{sqlite3\PYGZus{}finalize}\PYG{p}{(}\PYG{n}{stmt2}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{return} \PYG{n}{unique\PYGZus{}community\PYGZus{}refs}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{unsigned} \PYG{k+kt}{long}\PYG{o}{\PYGZgt{}} \PYG{n}{Community}\PYG{o}{:}\PYG{o}{:}\PYG{n}{getUniqueMetacommunityRefs}\PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{unsigned} \PYG{k+kt}{long}\PYG{o}{\PYGZgt{}} \PYG{n}{unique\PYGZus{}metacommunity\PYGZus{}refs}\PYG{p}{;}
    \PYG{c+c1}{// Read the community parameters and store them in the relevant objects}
    \PYG{n}{sqlite3\PYGZus{}stmt} \PYG{o}{*}\PYG{n}{stmt1}\PYG{p}{;}
    \PYG{n}{string} \PYG{n}{call1} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{select count(type) from sqlite\PYGZus{}master where type=\PYGZsq{}table\PYGZsq{} and name=\PYGZsq{}METACOMMUNITY\PYGZus{}PARAMETERS\PYGZsq{}}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
    \PYG{k+kt}{int} \PYG{n}{rc} \PYG{o}{=} \PYG{n}{sqlite3\PYGZus{}prepare\PYGZus{}v2}\PYG{p}{(}\PYG{n}{database}\PYG{p}{,} \PYG{n}{call1}\PYG{p}{.}\PYG{n}{c\PYGZus{}str}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{k}{static\PYGZus{}cast}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{n}{strlen}\PYG{p}{(}\PYG{n}{call1}\PYG{p}{.}\PYG{n}{c\PYGZus{}str}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{stmt1}\PYG{p}{,} \PYG{k}{nullptr}\PYG{p}{)}\PYG{p}{;}
    \PYG{k}{if}\PYG{p}{(}\PYG{n}{rc} \PYG{o}{!}\PYG{o}{=} \PYG{n}{SQLITE\PYGZus{}DONE} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{n}{rc} \PYG{o}{!}\PYG{o}{=} \PYG{n}{SQLITE\PYGZus{}OK}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{sqlite3\PYGZus{}close}\PYG{p}{(}\PYG{n}{outdatabase}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{sqlite3\PYGZus{}close}\PYG{p}{(}\PYG{n}{database}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{throw} \PYG{n+nf}{SpeciesException}\PYG{p}{(}
                \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ERROR\PYGZus{}SQL\PYGZus{}020: FATAL. Could not check for METACOMMUNITY\PYGZus{}PARAMETERS table. Error code: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{+}
                \PYG{n}{to\PYGZus{}string}\PYG{p}{(}\PYG{n}{rc}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{n}{sqlite3\PYGZus{}step}\PYG{p}{(}\PYG{n}{stmt1}\PYG{p}{)}\PYG{p}{;}
    \PYG{k}{auto} \PYG{n}{has\PYGZus{}metacommunity\PYGZus{}parameters} \PYG{o}{=} \PYG{k}{static\PYGZus{}cast}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{bool}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{n}{sqlite3\PYGZus{}column\PYGZus{}int}\PYG{p}{(}\PYG{n}{stmt1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{sqlite3\PYGZus{}step}\PYG{p}{(}\PYG{n}{stmt1}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{sqlite3\PYGZus{}finalize}\PYG{p}{(}\PYG{n}{stmt1}\PYG{p}{)}\PYG{p}{;}
    \PYG{c+c1}{// Read the speciation rates from the community\PYGZus{}parameters table}
    \PYG{k}{if}\PYG{p}{(}\PYG{n}{has\PYGZus{}metacommunity\PYGZus{}parameters}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{sqlite3\PYGZus{}stmt} \PYG{o}{*}\PYG{n}{stmt2}\PYG{p}{;}
        \PYG{n}{string} \PYG{n}{call2} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{SELECT DISTINCT(reference) FROM METACOMMUNITY\PYGZus{}PARAMETERS}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
        \PYG{n}{rc} \PYG{o}{=} \PYG{n}{sqlite3\PYGZus{}prepare\PYGZus{}v2}\PYG{p}{(}\PYG{n}{database}\PYG{p}{,} \PYG{n}{call2}\PYG{p}{.}\PYG{n}{c\PYGZus{}str}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{k}{static\PYGZus{}cast}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{n}{strlen}\PYG{p}{(}\PYG{n}{call2}\PYG{p}{.}\PYG{n}{c\PYGZus{}str}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{stmt2}\PYG{p}{,}
                                \PYG{k}{nullptr}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{rc} \PYG{o}{!}\PYG{o}{=} \PYG{n}{SQLITE\PYGZus{}DONE} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{n}{rc} \PYG{o}{!}\PYG{o}{=} \PYG{n}{SQLITE\PYGZus{}OK}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{sqlite3\PYGZus{}close}\PYG{p}{(}\PYG{n}{outdatabase}\PYG{p}{)}\PYG{p}{;}
            \PYG{n}{sqlite3\PYGZus{}close}\PYG{p}{(}\PYG{n}{database}\PYG{p}{)}\PYG{p}{;}
            \PYG{k}{throw} \PYG{n+nf}{SpeciesException}\PYG{p}{(}
                    \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ERROR\PYGZus{}SQL\PYGZus{}020: FATAL. Could not detect METACOMMUNITY\PYGZus{}PARAMETERS table. Error code: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{+}
                    \PYG{n}{to\PYGZus{}string}\PYG{p}{(}\PYG{n}{rc}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{n}{rc} \PYG{o}{=} \PYG{n}{sqlite3\PYGZus{}step}\PYG{p}{(}\PYG{n}{stmt2}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{while}\PYG{p}{(}\PYG{n}{rc} \PYG{o}{!}\PYG{o}{=} \PYG{n}{SQLITE\PYGZus{}DONE}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{unique\PYGZus{}metacommunity\PYGZus{}refs}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{k}{static\PYGZus{}cast}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{unsigned} \PYG{k+kt}{long}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{n}{sqlite3\PYGZus{}column\PYGZus{}int}\PYG{p}{(}\PYG{n}{stmt2}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
            \PYG{n}{rc} \PYG{o}{=} \PYG{n}{sqlite3\PYGZus{}step}\PYG{p}{(}\PYG{n}{stmt2}\PYG{p}{)}\PYG{p}{;}
            \PYG{k}{if}\PYG{p}{(}\PYG{n}{rc} \PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{10000}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{k}{throw} \PYG{n}{SpeciesException}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ERROR\PYGZus{}SQL\PYGZus{}020: FATAL. Could not read speciation rates.}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
        \PYG{p}{\PYGZcb{}}
        \PYG{n}{sqlite3\PYGZus{}step}\PYG{p}{(}\PYG{n}{stmt2}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{sqlite3\PYGZus{}finalize}\PYG{p}{(}\PYG{n}{stmt2}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{return} \PYG{n}{unique\PYGZus{}metacommunity\PYGZus{}refs}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{void} \PYG{n}{Community}\PYG{o}{:}\PYG{o}{:}\PYG{n}{writeNewCommunityParameters}\PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{c+c1}{// Find new community parameters to add}
    \PYG{k}{auto} \PYG{n}{unique\PYGZus{}community\PYGZus{}refs} \PYG{o}{=} \PYG{n}{getUniqueCommunityRefs}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{CommunitiesArray} \PYG{n}{communities\PYGZus{}to\PYGZus{}write}\PYG{p}{;}
    \PYG{k}{for}\PYG{p}{(}\PYG{k}{auto} \PYG{o}{\PYGZam{}}\PYG{n+nl}{community\PYGZus{}param} \PYG{p}{:} \PYG{n}{past\PYGZus{}communities}\PYG{p}{.}\PYG{n}{calc\PYGZus{}array}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{find}\PYG{p}{(}\PYG{n}{unique\PYGZus{}community\PYGZus{}refs}\PYG{p}{.}\PYG{n}{begin}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,}
                \PYG{n}{unique\PYGZus{}community\PYGZus{}refs}\PYG{p}{.}\PYG{n}{end}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{n}{community\PYGZus{}param}\PYG{p}{.}\PYG{n}{reference}\PYG{p}{)} \PYG{o}{=}\PYG{o}{=} \PYG{n}{unique\PYGZus{}community\PYGZus{}refs}\PYG{p}{.}\PYG{n}{end}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{communities\PYGZus{}to\PYGZus{}write}\PYG{p}{.}\PYG{n}{pushBack}\PYG{p}{(}\PYG{n}{community\PYGZus{}param}\PYG{p}{)}\PYG{p}{;}
            \PYG{n}{unique\PYGZus{}community\PYGZus{}refs}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{n}{community\PYGZus{}param}\PYG{p}{.}\PYG{n}{reference}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{if}\PYG{p}{(}\PYG{o}{!}\PYG{n}{communities\PYGZus{}to\PYGZus{}write}\PYG{p}{.}\PYG{n}{calc\PYGZus{}array}\PYG{p}{.}\PYG{n}{empty}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{c+c1}{// Create the table if it doesn\PYGZsq{}t exist}
        \PYG{n}{string} \PYG{n}{table\PYGZus{}command} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{CREATE TABLE IF NOT EXISTS COMMUNITY\PYGZus{}PARAMETERS (reference INT PRIMARY KEY NOT NULL,}\PYG{l+s}{\PYGZdq{}}
                \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ speciation\PYGZus{}rate DOUBLE NOT NULL, time DOUBLE NOT NULL, fragments INT NOT NULL, }\PYG{l+s}{\PYGZdq{}}
                \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{metacommunity\PYGZus{}reference INT);}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
        \PYG{n}{sqlite3\PYGZus{}exec}\PYG{p}{(}\PYG{n}{database}\PYG{p}{,} \PYG{n}{table\PYGZus{}command}\PYG{p}{.}\PYG{n}{c\PYGZus{}str}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{k}{nullptr}\PYG{p}{,} \PYG{k}{nullptr}\PYG{p}{,} \PYG{k}{nullptr}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{sqlite3\PYGZus{}stmt} \PYG{o}{*}\PYG{n}{stmt}\PYG{p}{;}
        \PYG{n}{table\PYGZus{}command} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{INSERT INTO COMMUNITY\PYGZus{}PARAMETERS (reference, speciation\PYGZus{}rate, time, fragments,}\PYG{l+s}{\PYGZdq{}}
                \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ metacommunity\PYGZus{}reference) VALUES (?,?,?,?,?);}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
        \PYG{n}{sqlite3\PYGZus{}prepare\PYGZus{}v2}\PYG{p}{(}\PYG{n}{database}\PYG{p}{,} \PYG{n}{table\PYGZus{}command}\PYG{p}{.}\PYG{n}{c\PYGZus{}str}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{k}{static\PYGZus{}cast}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{n}{strlen}\PYG{p}{(}\PYG{n}{table\PYGZus{}command}\PYG{p}{.}\PYG{n}{c\PYGZus{}str}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{stmt}\PYG{p}{,}
                           \PYG{k}{nullptr}\PYG{p}{)}\PYG{p}{;}
        \PYG{c+c1}{// Then add the required elements}
        \PYG{n}{sqlite3\PYGZus{}exec}\PYG{p}{(}\PYG{n}{database}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{BEGIN TRANSACTION;}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{k}{nullptr}\PYG{p}{,} \PYG{k}{nullptr}\PYG{p}{,} \PYG{k}{nullptr}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{for}\PYG{p}{(}\PYG{k}{auto} \PYG{o}{\PYGZam{}}\PYG{n+nl}{item} \PYG{p}{:} \PYG{n}{communities\PYGZus{}to\PYGZus{}write}\PYG{p}{.}\PYG{n}{calc\PYGZus{}array}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{k}{if}\PYG{p}{(}\PYG{n}{item}\PYG{p}{.}\PYG{n}{reference} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{k}{continue}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
            \PYG{n}{sqlite3\PYGZus{}bind\PYGZus{}int}\PYG{p}{(}\PYG{n}{stmt}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{k}{static\PYGZus{}cast}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{n}{item}\PYG{p}{.}\PYG{n}{reference}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
            \PYG{n}{sqlite3\PYGZus{}bind\PYGZus{}double}\PYG{p}{(}\PYG{n}{stmt}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{k}{static\PYGZus{}cast}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{double}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{n}{item}\PYG{p}{.}\PYG{n}{speciation\PYGZus{}rate}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
            \PYG{n}{sqlite3\PYGZus{}bind\PYGZus{}double}\PYG{p}{(}\PYG{n}{stmt}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{k}{static\PYGZus{}cast}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{double}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{n}{item}\PYG{p}{.}\PYG{n}{time}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
            \PYG{n}{sqlite3\PYGZus{}bind\PYGZus{}int}\PYG{p}{(}\PYG{n}{stmt}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{k}{static\PYGZus{}cast}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{n}{item}\PYG{p}{.}\PYG{n}{fragment}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
            \PYG{n}{sqlite3\PYGZus{}bind\PYGZus{}int}\PYG{p}{(}\PYG{n}{stmt}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{,} \PYG{k}{static\PYGZus{}cast}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{n}{item}\PYG{p}{.}\PYG{n}{metacommunity\PYGZus{}reference}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
            \PYG{k+kt}{time\PYGZus{}t} \PYG{n}{start\PYGZus{}check}\PYG{p}{,} \PYG{n}{end\PYGZus{}check}\PYG{p}{;}
            \PYG{n}{time}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{start\PYGZus{}check}\PYG{p}{)}\PYG{p}{;}
            \PYG{n}{time}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{end\PYGZus{}check}\PYG{p}{)}\PYG{p}{;}
            \PYG{k+kt}{int} \PYG{n}{step} \PYG{o}{=} \PYG{n}{sqlite3\PYGZus{}step}\PYG{p}{(}\PYG{n}{stmt}\PYG{p}{)}\PYG{p}{;}
            \PYG{k}{while}\PYG{p}{(}\PYG{n}{step} \PYG{o}{!}\PYG{o}{=} \PYG{n}{SQLITE\PYGZus{}DONE} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{p}{(}\PYG{n}{end\PYGZus{}check} \PYG{o}{\PYGZhy{}} \PYG{n}{start\PYGZus{}check}\PYG{p}{)} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{10} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{n}{step} \PYG{o}{!}\PYG{o}{=} \PYG{n}{SQLITE\PYGZus{}OK}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{n}{step} \PYG{o}{=} \PYG{n}{sqlite3\PYGZus{}step}\PYG{p}{(}\PYG{n}{stmt}\PYG{p}{)}\PYG{p}{;}
                \PYG{n}{time}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{end\PYGZus{}check}\PYG{p}{)}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
            \PYG{k}{if}\PYG{p}{(}\PYG{n}{step} \PYG{o}{!}\PYG{o}{=} \PYG{n}{SQLITE\PYGZus{}DONE}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{n}{stringstream} \PYG{n}{ss}\PYG{p}{;}
                \PYG{n}{ss} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{SQLITE error code: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{step} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
                \PYG{n}{ss} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{sqlite3\PYGZus{}errmsg}\PYG{p}{(}\PYG{n}{database}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
                \PYG{n}{ss} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ERROR\PYGZus{}SQL\PYGZus{}004a: Could not insert into database. Check destination file has not }\PYG{l+s}{\PYGZdq{}}
                        \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{been moved or deleted and that an entry doesn\PYGZsq{}t already exist with the same ID.}\PYG{l+s}{\PYGZdq{}}
                   \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
                \PYG{n}{sqlite3\PYGZus{}clear\PYGZus{}bindings}\PYG{p}{(}\PYG{n}{stmt}\PYG{p}{)}\PYG{p}{;}
                \PYG{n}{sqlite3\PYGZus{}reset}\PYG{p}{(}\PYG{n}{stmt}\PYG{p}{)}\PYG{p}{;}
                \PYG{n}{writeWarning}\PYG{p}{(}\PYG{n}{ss}\PYG{p}{.}\PYG{n}{str}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
                \PYG{k}{break}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
            \PYG{n}{sqlite3\PYGZus{}clear\PYGZus{}bindings}\PYG{p}{(}\PYG{n}{stmt}\PYG{p}{)}\PYG{p}{;}
            \PYG{n}{sqlite3\PYGZus{}reset}\PYG{p}{(}\PYG{n}{stmt}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{k+kt}{int} \PYG{n}{rc1} \PYG{o}{=} \PYG{n}{sqlite3\PYGZus{}exec}\PYG{p}{(}\PYG{n}{database}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{END TRANSACTION;}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{k}{nullptr}\PYG{p}{,} \PYG{k}{nullptr}\PYG{p}{,} \PYG{k}{nullptr}\PYG{p}{)}\PYG{p}{;}
        \PYG{c+c1}{// Need to finalise the statement}
        \PYG{k+kt}{int} \PYG{n}{rc2} \PYG{o}{=} \PYG{n}{sqlite3\PYGZus{}finalize}\PYG{p}{(}\PYG{n}{stmt}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{rc1} \PYG{o}{!}\PYG{o}{=} \PYG{n}{SQLITE\PYGZus{}OK} \PYG{o}{\textbar{}}\PYG{o}{\textbar{}} \PYG{n}{rc2} \PYG{o}{!}\PYG{o}{=} \PYG{n}{SQLITE\PYGZus{}OK}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{stringstream} \PYG{n}{ss}\PYG{p}{;}
            \PYG{n}{ss} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ERROR\PYGZus{}SQL\PYGZus{}013: Could not complete SQL transaction. Check memory database assignment and SQL }\PYG{l+s}{\PYGZdq{}}
                    \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{commands. Please report this bug.}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
            \PYG{n}{writeWarning}\PYG{p}{(}\PYG{n}{ss}\PYG{p}{.}\PYG{n}{str}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
    \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{void} \PYG{n}{Community}\PYG{o}{:}\PYG{o}{:}\PYG{n}{writeNewMetacommuntyParameters}\PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k}{auto} \PYG{n}{unique\PYGZus{}metacommunity\PYGZus{}refs} \PYG{o}{=} \PYG{n}{getUniqueMetacommunityRefs}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{MetacommunitiesArray} \PYG{n}{metacommunities\PYGZus{}to\PYGZus{}write}\PYG{p}{;}
    \PYG{k}{if}\PYG{p}{(}\PYG{n}{unique\PYGZus{}metacommunity\PYGZus{}refs}\PYG{p}{.}\PYG{n}{empty}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{for}\PYG{p}{(}\PYG{k}{auto} \PYG{o}{\PYGZam{}}\PYG{n+nl}{community\PYGZus{}param} \PYG{p}{:} \PYG{n}{past\PYGZus{}metacommunities}\PYG{p}{.}\PYG{n}{calc\PYGZus{}array}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{metacommunities\PYGZus{}to\PYGZus{}write}\PYG{p}{.}\PYG{n}{pushBack}\PYG{p}{(}\PYG{n}{community\PYGZus{}param}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{else}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{for}\PYG{p}{(}\PYG{k}{auto} \PYG{o}{\PYGZam{}}\PYG{n+nl}{community\PYGZus{}param} \PYG{p}{:} \PYG{n}{past\PYGZus{}metacommunities}\PYG{p}{.}\PYG{n}{calc\PYGZus{}array}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{k}{if}\PYG{p}{(}\PYG{n}{find}\PYG{p}{(}\PYG{n}{unique\PYGZus{}metacommunity\PYGZus{}refs}\PYG{p}{.}\PYG{n}{begin}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,}
                    \PYG{n}{unique\PYGZus{}metacommunity\PYGZus{}refs}\PYG{p}{.}\PYG{n}{end}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{n}{community\PYGZus{}param}\PYG{p}{.}\PYG{n}{reference}\PYG{p}{)} \PYG{o}{=}\PYG{o}{=} \PYG{n}{unique\PYGZus{}metacommunity\PYGZus{}refs}\PYG{p}{.}\PYG{n}{end}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{n}{metacommunities\PYGZus{}to\PYGZus{}write}\PYG{p}{.}\PYG{n}{pushBack}\PYG{p}{(}\PYG{n}{community\PYGZus{}param}\PYG{p}{)}\PYG{p}{;}
                \PYG{n}{unique\PYGZus{}metacommunity\PYGZus{}refs}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{n}{community\PYGZus{}param}\PYG{p}{.}\PYG{n}{reference}\PYG{p}{)}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
        \PYG{p}{\PYGZcb{}}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{if}\PYG{p}{(}\PYG{o}{!}\PYG{n}{metacommunities\PYGZus{}to\PYGZus{}write}\PYG{p}{.}\PYG{n}{calc\PYGZus{}array}\PYG{p}{.}\PYG{n}{empty}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{c+c1}{// Create the table if it doesn\PYGZsq{}t exist}
        \PYG{n}{string} \PYG{n}{table\PYGZus{}command} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{CREATE TABLE IF NOT EXISTS METACOMMUNITY\PYGZus{}PARAMETERS (reference INT PRIMARY KEY NOT NULL,}\PYG{l+s}{\PYGZdq{}}
                \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ speciation\PYGZus{}rate DOUBLE NOT NULL, metacommunity\PYGZus{}size DOUBLE NOT NULL);}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
        \PYG{n}{sqlite3\PYGZus{}exec}\PYG{p}{(}\PYG{n}{database}\PYG{p}{,} \PYG{n}{table\PYGZus{}command}\PYG{p}{.}\PYG{n}{c\PYGZus{}str}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{k}{nullptr}\PYG{p}{,} \PYG{k}{nullptr}\PYG{p}{,} \PYG{k}{nullptr}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{sqlite3\PYGZus{}stmt} \PYG{o}{*}\PYG{n}{stmt}\PYG{p}{;}
        \PYG{n}{table\PYGZus{}command} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{INSERT INTO METACOMMUNITY\PYGZus{}PARAMETERS (reference, speciation\PYGZus{}rate, metacommunity\PYGZus{}size}\PYG{l+s}{\PYGZdq{}}
                \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{) VALUES (?,?,?);}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
        \PYG{n}{sqlite3\PYGZus{}prepare\PYGZus{}v2}\PYG{p}{(}\PYG{n}{database}\PYG{p}{,} \PYG{n}{table\PYGZus{}command}\PYG{p}{.}\PYG{n}{c\PYGZus{}str}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{k}{static\PYGZus{}cast}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{n}{strlen}\PYG{p}{(}\PYG{n}{table\PYGZus{}command}\PYG{p}{.}\PYG{n}{c\PYGZus{}str}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{stmt}\PYG{p}{,}
                           \PYG{k}{nullptr}\PYG{p}{)}\PYG{p}{;}
        \PYG{c+c1}{// Then add the required elements}
        \PYG{n}{sqlite3\PYGZus{}exec}\PYG{p}{(}\PYG{n}{database}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{BEGIN TRANSACTION;}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{k}{nullptr}\PYG{p}{,} \PYG{k}{nullptr}\PYG{p}{,} \PYG{k}{nullptr}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{for}\PYG{p}{(}\PYG{k}{auto} \PYG{o}{\PYGZam{}}\PYG{n+nl}{item} \PYG{p}{:} \PYG{n}{metacommunities\PYGZus{}to\PYGZus{}write}\PYG{p}{.}\PYG{n}{calc\PYGZus{}array}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{k}{if}\PYG{p}{(}\PYG{n}{item}\PYG{p}{.}\PYG{n}{reference} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{k}{continue}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
            \PYG{n}{sqlite3\PYGZus{}bind\PYGZus{}int}\PYG{p}{(}\PYG{n}{stmt}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{k}{static\PYGZus{}cast}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{n}{item}\PYG{p}{.}\PYG{n}{reference}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
            \PYG{n}{sqlite3\PYGZus{}bind\PYGZus{}double}\PYG{p}{(}\PYG{n}{stmt}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{k}{static\PYGZus{}cast}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{double}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{n}{item}\PYG{p}{.}\PYG{n}{speciation\PYGZus{}rate}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
            \PYG{n}{sqlite3\PYGZus{}bind\PYGZus{}int}\PYG{p}{(}\PYG{n}{stmt}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{k}{static\PYGZus{}cast}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{n}{item}\PYG{p}{.}\PYG{n}{metacommunity\PYGZus{}size}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
            \PYG{k+kt}{time\PYGZus{}t} \PYG{n}{start\PYGZus{}check}\PYG{p}{,} \PYG{n}{end\PYGZus{}check}\PYG{p}{;}
            \PYG{n}{time}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{start\PYGZus{}check}\PYG{p}{)}\PYG{p}{;}
            \PYG{n}{time}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{end\PYGZus{}check}\PYG{p}{)}\PYG{p}{;}
            \PYG{k+kt}{int} \PYG{n}{step} \PYG{o}{=} \PYG{n}{sqlite3\PYGZus{}step}\PYG{p}{(}\PYG{n}{stmt}\PYG{p}{)}\PYG{p}{;}
            \PYG{k}{while}\PYG{p}{(}\PYG{n}{step} \PYG{o}{!}\PYG{o}{=} \PYG{n}{SQLITE\PYGZus{}DONE} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{p}{(}\PYG{n}{end\PYGZus{}check} \PYG{o}{\PYGZhy{}} \PYG{n}{start\PYGZus{}check}\PYG{p}{)} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{10} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{n}{step} \PYG{o}{!}\PYG{o}{=} \PYG{n}{SQLITE\PYGZus{}OK}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{n}{step} \PYG{o}{=} \PYG{n}{sqlite3\PYGZus{}step}\PYG{p}{(}\PYG{n}{stmt}\PYG{p}{)}\PYG{p}{;}
                \PYG{n}{time}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{end\PYGZus{}check}\PYG{p}{)}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
            \PYG{k}{if}\PYG{p}{(}\PYG{n}{step} \PYG{o}{!}\PYG{o}{=} \PYG{n}{SQLITE\PYGZus{}DONE}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifdef DEBUG}
                \PYG{n}{stringstream} \PYG{n}{ss}\PYG{p}{;}
                \PYG{n}{ss} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{SQLITE error code: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{step} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
                \PYG{n}{ss} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Metacommunity reference: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{item}\PYG{p}{.}\PYG{n}{reference} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
                \PYG{n}{ss} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Speciation rate: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{item}\PYG{p}{.}\PYG{n}{speciation\PYGZus{}rate} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{, metacommunity size: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{item}\PYG{p}{.}\PYG{n}{metacommunity\PYGZus{}size} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
                \PYG{n}{ss} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{sqlite3\PYGZus{}errmsg}\PYG{p}{(}\PYG{n}{database}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
                \PYG{n}{writeLog}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{,} \PYG{n}{ss}\PYG{p}{)}\PYG{p}{;}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif }\PYG{c+c1}{// DEBUG}
                \PYG{k}{throw} \PYG{n+nf}{SpeciesException}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ERROR\PYGZus{}SQL\PYGZus{}004b: Could not insert into database. Check destination file has not }\PYG{l+s}{\PYGZdq{}}
                                               \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{been moved or deleted and that an entry doesn\PYGZsq{}t already exist with the}\PYG{l+s}{\PYGZdq{}}
                                               \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ same ID.}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
            \PYG{n}{sqlite3\PYGZus{}clear\PYGZus{}bindings}\PYG{p}{(}\PYG{n}{stmt}\PYG{p}{)}\PYG{p}{;}
            \PYG{n}{sqlite3\PYGZus{}reset}\PYG{p}{(}\PYG{n}{stmt}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{k+kt}{int} \PYG{n}{rc1} \PYG{o}{=} \PYG{n}{sqlite3\PYGZus{}exec}\PYG{p}{(}\PYG{n}{database}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{END TRANSACTION;}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{k}{nullptr}\PYG{p}{,} \PYG{k}{nullptr}\PYG{p}{,} \PYG{k}{nullptr}\PYG{p}{)}\PYG{p}{;}
        \PYG{c+c1}{// Need to finalise the statement}
        \PYG{k+kt}{int} \PYG{n}{rc2} \PYG{o}{=} \PYG{n}{sqlite3\PYGZus{}finalize}\PYG{p}{(}\PYG{n}{stmt}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{rc1} \PYG{o}{!}\PYG{o}{=} \PYG{n}{SQLITE\PYGZus{}OK} \PYG{o}{\textbar{}}\PYG{o}{\textbar{}} \PYG{n}{rc2} \PYG{o}{!}\PYG{o}{=} \PYG{n}{SQLITE\PYGZus{}OK}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{stringstream} \PYG{n}{ss}\PYG{p}{;}
            \PYG{n}{ss} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ERROR\PYGZus{}SQL\PYGZus{}013: Could not complete SQL transaction. Check memory database assignment and SQL }\PYG{l+s}{\PYGZdq{}}
                    \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{commands. Please report this bug.}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
            \PYG{n}{ss} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{sqlite3\PYGZus{}errmsg}\PYG{p}{(}\PYG{n}{database}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
            \PYG{n}{writeWarning}\PYG{p}{(}\PYG{n}{ss}\PYG{p}{.}\PYG{n}{str}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
    \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{void} \PYG{n}{Community}\PYG{o}{:}\PYG{o}{:}\PYG{n}{updateCommunityParameters}\PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k}{for}\PYG{p}{(}\PYG{k}{auto} \PYG{n+nl}{parameter} \PYG{p}{:} \PYG{n}{past\PYGZus{}communities}\PYG{p}{.}\PYG{n}{calc\PYGZus{}array}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{parameter}\PYG{p}{.}\PYG{n}{updated}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{k}{if}\PYG{p}{(}\PYG{o}{!}\PYG{n}{bSqlConnection}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{k}{throw} \PYG{n}{FatalException}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Attempted to update sql database without opening database connection.}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}

            \PYG{c+c1}{// Now find out the max size of the list, so we have a count to work from}
            \PYG{n}{string} \PYG{n}{count\PYGZus{}command} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{UPDATE COMMUNITY\PYGZus{}PARAMETERS SET fragments = 1 WHERE reference = }\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
            \PYG{n}{count\PYGZus{}command} \PYG{o}{+}\PYG{o}{=} \PYG{n}{to\PYGZus{}string}\PYG{p}{(}\PYG{n}{parameter}\PYG{p}{.}\PYG{n}{reference}\PYG{p}{)} \PYG{o}{+} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{;}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
            \PYG{k+kt}{int} \PYG{n}{rc} \PYG{o}{=} \PYG{n}{sqlite3\PYGZus{}exec}\PYG{p}{(}\PYG{n}{database}\PYG{p}{,} \PYG{n}{count\PYGZus{}command}\PYG{p}{.}\PYG{n}{c\PYGZus{}str}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{k}{nullptr}\PYG{p}{,} \PYG{k}{nullptr}\PYG{p}{,} \PYG{k}{nullptr}\PYG{p}{)}\PYG{p}{;}
            \PYG{c+c1}{// Need to finalise the statement}
            \PYG{k}{if}\PYG{p}{(}\PYG{n}{rc} \PYG{o}{!}\PYG{o}{=} \PYG{n}{SQLITE\PYGZus{}OK} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{n}{rc} \PYG{o}{!}\PYG{o}{=} \PYG{n}{SQLITE\PYGZus{}DONE}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{n}{stringstream} \PYG{n}{ss}\PYG{p}{;}
                \PYG{n}{ss} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ERROR\PYGZus{}SQL\PYGZus{}013: Could not update sql database. Check file write access. }\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
                \PYG{n}{ss} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Otherwise, please report this bug.}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
                \PYG{n}{ss} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{sqlite3\PYGZus{}errmsg}\PYG{p}{(}\PYG{n}{database}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
                \PYG{n}{writeWarning}\PYG{p}{(}\PYG{n}{ss}\PYG{p}{.}\PYG{n}{str}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
        \PYG{p}{\PYGZcb{}}
    \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}


\PYG{k+kt}{void} \PYG{n}{Community}\PYG{o}{:}\PYG{o}{:}\PYG{n}{writeSpeciationRates}\PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{n}{stringstream} \PYG{n}{os}\PYG{p}{;}
    \PYG{n}{os} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{***************************}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
    \PYG{n}{os} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{STARTING CALCULATIONS}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
    \PYG{n}{os} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Input file is }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{spec\PYGZus{}sim\PYGZus{}parameters}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{filename} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
    \PYG{n}{sort}\PYG{p}{(}\PYG{n}{spec\PYGZus{}sim\PYGZus{}parameters}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{all\PYGZus{}speciation\PYGZus{}rates}\PYG{p}{.}\PYG{n}{begin}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{n}{spec\PYGZus{}sim\PYGZus{}parameters}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{all\PYGZus{}speciation\PYGZus{}rates}\PYG{p}{.}\PYG{n}{end}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
    \PYG{k}{if}\PYG{p}{(}\PYG{o}{!}\PYG{n}{spec\PYGZus{}sim\PYGZus{}parameters}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{bMultiRun}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{os} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Speciation rate is }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{spec\PYGZus{}sim\PYGZus{}parameters}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{all\PYGZus{}speciation\PYGZus{}rates}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{else}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{os} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Speciation rates are: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{flush}\PYG{p}{;}
        \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{spec\PYGZus{}sim\PYGZus{}parameters}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{all\PYGZus{}speciation\PYGZus{}rates}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{os} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{spec\PYGZus{}sim\PYGZus{}parameters}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{all\PYGZus{}speciation\PYGZus{}rates}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{flush}\PYG{p}{;}
            \PYG{k}{if}\PYG{p}{(}\PYG{n}{i} \PYG{o}{+} \PYG{l+m+mi}{1} \PYG{o}{=}\PYG{o}{=} \PYG{n}{spec\PYGZus{}sim\PYGZus{}parameters}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{all\PYGZus{}speciation\PYGZus{}rates}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{n}{os} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{.}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
            \PYG{k}{else}
            \PYG{p}{\PYGZob{}}
                \PYG{n}{os} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{, }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{flush}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
        \PYG{p}{\PYGZcb{}}
    \PYG{p}{\PYGZcb{}}
    \PYG{n}{writeInfo}\PYG{p}{(}\PYG{n}{os}\PYG{p}{.}\PYG{n}{str}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{void} \PYG{n}{Community}\PYG{o}{:}\PYG{o}{:}\PYG{n}{calculateTree}\PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{n}{stringstream} \PYG{n}{os}\PYG{p}{;}
    \PYG{k}{for}\PYG{p}{(}\PYG{k}{auto} \PYG{n+nl}{sr} \PYG{p}{:} \PYG{n}{spec\PYGZus{}sim\PYGZus{}parameters}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{all\PYGZus{}speciation\PYGZus{}rates}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{os} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Calculating speciation rate }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{sr} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
        \PYG{n}{writeInfo}\PYG{p}{(}\PYG{n}{os}\PYG{p}{.}\PYG{n}{str}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{os}\PYG{p}{.}\PYG{n}{str}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{for}\PYG{p}{(}\PYG{k}{auto} \PYG{n+nl}{time} \PYG{p}{:} \PYG{n}{spec\PYGZus{}sim\PYGZus{}parameters}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{all\PYGZus{}times}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{os}\PYG{p}{.}\PYG{n}{str}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
            \PYG{n}{os} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Calculating generation }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{time} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
            \PYG{n}{writeInfo}\PYG{p}{(}\PYG{n}{os}\PYG{p}{.}\PYG{n}{str}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
            \PYG{n}{resetTree}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
            \PYG{k}{if}\PYG{p}{(}\PYG{o}{!}\PYG{n}{checkCalculationsPerformed}\PYG{p}{(}\PYG{n}{sr}\PYG{p}{,} \PYG{n}{time}\PYG{p}{,} \PYG{n}{spec\PYGZus{}sim\PYGZus{}parameters}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{use\PYGZus{}fragments}\PYG{p}{,}
                                           \PYG{n}{spec\PYGZus{}sim\PYGZus{}parameters}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{metacommunity\PYGZus{}size}\PYG{p}{,}
                                           \PYG{n}{spec\PYGZus{}sim\PYGZus{}parameters}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{metacommunity\PYGZus{}speciation\PYGZus{}rate}\PYG{p}{)}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{n}{addCalculationPerformed}\PYG{p}{(}\PYG{n}{sr}\PYG{p}{,} \PYG{n}{time}\PYG{p}{,} \PYG{n}{spec\PYGZus{}sim\PYGZus{}parameters}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{use\PYGZus{}fragments}\PYG{p}{,}
                                        \PYG{n}{spec\PYGZus{}sim\PYGZus{}parameters}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{metacommunity\PYGZus{}size}\PYG{p}{,}
                                        \PYG{n}{spec\PYGZus{}sim\PYGZus{}parameters}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{metacommunity\PYGZus{}speciation\PYGZus{}rate}\PYG{p}{)}\PYG{p}{;}
                \PYG{n}{createDatabase}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
                \PYG{k}{if}\PYG{p}{(}\PYG{n}{spec\PYGZus{}sim\PYGZus{}parameters}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{use\PYGZus{}spatial}\PYG{p}{)}
                \PYG{p}{\PYGZob{}}
                    \PYG{n}{recordSpatial}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
                \PYG{p}{\PYGZcb{}}
                \PYG{k}{if}\PYG{p}{(}\PYG{n}{spec\PYGZus{}sim\PYGZus{}parameters}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{use\PYGZus{}fragments}\PYG{p}{)}
                \PYG{p}{\PYGZob{}}
                    \PYG{n}{applyFragments}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
                \PYG{p}{\PYGZcb{}}
            \PYG{p}{\PYGZcb{}}
            \PYG{k}{else}
            \PYG{p}{\PYGZob{}}
                \PYG{n}{os}\PYG{p}{.}\PYG{n}{str}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
                \PYG{n}{os} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{calculation already performed for }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{sr} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ at time }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{time} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
                \PYG{n}{writeInfo}\PYG{p}{(}\PYG{n}{os}\PYG{p}{.}\PYG{n}{str}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
        \PYG{p}{\PYGZcb{}}
    \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{void} \PYG{n}{Community}\PYG{o}{:}\PYG{o}{:}\PYG{n}{output}\PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{n}{writeNewCommunityParameters}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{writeNewMetacommuntyParameters}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{updateCommunityParameters}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{exportDatabase}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{void} \PYG{n}{Community}\PYG{o}{:}\PYG{o}{:}\PYG{n}{printEndTimes}\PYG{p}{(}\PYG{k+kt}{time\PYGZus{}t} \PYG{n}{tStart}\PYG{p}{,} \PYG{k+kt}{time\PYGZus{}t} \PYG{n}{tEnd}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{n}{time}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{tEnd}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{stringstream} \PYG{n}{os}\PYG{p}{;}
    \PYG{n}{os} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Calculations complete.}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
    \PYG{n}{os} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Time taken was }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{floor}\PYG{p}{(}\PYG{p}{(}\PYG{n}{tEnd} \PYG{o}{\PYGZhy{}} \PYG{n}{tStart}\PYG{p}{)} \PYG{o}{/} \PYG{l+m+mi}{3600}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ hours }\PYG{l+s}{\PYGZdq{}}
       \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{p}{(}\PYG{n}{floor}\PYG{p}{(}\PYG{p}{(}\PYG{n}{tEnd} \PYG{o}{\PYGZhy{}} \PYG{n}{tStart}\PYG{p}{)} \PYG{o}{/} \PYG{l+m+mi}{60}\PYG{p}{)} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{60} \PYG{o}{*} \PYG{n}{floor}\PYG{p}{(}\PYG{p}{(}\PYG{n}{tEnd} \PYG{o}{\PYGZhy{}} \PYG{n}{tStart}\PYG{p}{)} \PYG{o}{/} \PYG{l+m+mi}{3600}\PYG{p}{)}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ minutes }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{p}{(}\PYG{n}{tEnd} \PYG{o}{\PYGZhy{}} \PYG{n}{tStart}\PYG{p}{)} \PYG{o}{\PYGZpc{}} \PYG{l+m+mi}{60}
       \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ seconds}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
    \PYG{n}{writeInfo}\PYG{p}{(}\PYG{n}{os}\PYG{p}{.}\PYG{n}{str}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{void} \PYG{n}{Community}\PYG{o}{:}\PYG{o}{:}\PYG{n}{apply}\PYG{p}{(}\PYG{n}{SpecSimParameters} \PYG{o}{*}\PYG{n}{sp}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k+kt}{time\PYGZus{}t} \PYG{n}{tStart}\PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
    \PYG{k+kt}{time\PYGZus{}t} \PYG{n}{tEnd}\PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
    \PYG{c+c1}{// Start the clock}
    \PYG{n}{time}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{tStart}\PYG{p}{)}\PYG{p}{;}
    \PYG{c+c1}{// First print the variables}
    \PYG{n}{doApplication}\PYG{p}{(}\PYG{n}{sp}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{output}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{printEndTimes}\PYG{p}{(}\PYG{n}{tStart}\PYG{p}{,} \PYG{n}{tEnd}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{void} \PYG{n}{Community}\PYG{o}{:}\PYG{o}{:}\PYG{n}{doApplication}\PYG{p}{(}\PYG{n}{SpecSimParameters} \PYG{o}{*}\PYG{n}{sp}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{n}{Row}\PYG{o}{\PYGZlt{}}\PYG{n}{TreeNode}\PYG{o}{\PYGZgt{}} \PYG{n}{data}\PYG{p}{;}
    \PYG{n}{doApplication}\PYG{p}{(}\PYG{n}{sp}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{data}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{void} \PYG{n}{Community}\PYG{o}{:}\PYG{o}{:}\PYG{n}{doApplication}\PYG{p}{(}\PYG{n}{SpecSimParameters} \PYG{o}{*}\PYG{n}{sp}\PYG{p}{,} \PYG{n}{Row}\PYG{o}{\PYGZlt{}}\PYG{n}{TreeNode}\PYG{o}{\PYGZgt{}} \PYG{o}{*}\PYG{n}{data}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{n}{spec\PYGZus{}sim\PYGZus{}parameters} \PYG{o}{=} \PYG{n}{sp}\PYG{p}{;}
    \PYG{n}{writeSpeciationRates}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
    \PYG{c+c1}{// Set up the objects}
    \PYG{n}{setList}\PYG{p}{(}\PYG{n}{data}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{importSimParameters}\PYG{p}{(}\PYG{n}{sp}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{filename}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{setProtractedParameters}\PYG{p}{(}\PYG{n}{sp}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{min\PYGZus{}speciation\PYGZus{}gen}\PYG{p}{,} \PYG{n}{sp}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{max\PYGZus{}speciation\PYGZus{}gen}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{importSamplemask}\PYG{p}{(}\PYG{n}{sp}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{samplemask}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{importData}\PYG{p}{(}\PYG{n}{sp}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{filename}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{getPreviousCalcs}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
    \PYG{k}{if}\PYG{p}{(}\PYG{n}{sp}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{use\PYGZus{}fragments}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{calcFragments}\PYG{p}{(}\PYG{n}{sp}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{fragment\PYGZus{}config\PYGZus{}file}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{n}{calculateTree}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{void} \PYG{n}{Community}\PYG{o}{:}\PYG{o}{:}\PYG{n}{doApplicationInternal}\PYG{p}{(}\PYG{n}{SpecSimParameters} \PYG{o}{*}\PYG{n}{sp}\PYG{p}{,} \PYG{n}{Row}\PYG{o}{\PYGZlt{}}\PYG{n}{TreeNode}\PYG{o}{\PYGZgt{}} \PYG{o}{*}\PYG{n}{data}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{n}{setInternalDatabase}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{doApplication}\PYG{p}{(}\PYG{n}{sp}\PYG{p}{,} \PYG{n}{data}\PYG{p}{)}\PYG{p}{;}

\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}


\subsubsection{Detailed Description}
\label{\detokenize{api/file_necsim_Community.cpp:detailed-description}}
Samuel Thompson
BSD-3 Licence.


\subsubsection{Includes}
\label{\detokenize{api/file_necsim_Community.cpp:includes}}\begin{itemize}
\item {} 
\sphinxcode{Community.h} ({\hyperref[\detokenize{api/file_necsim_Community.h:file-necsim-community-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File Community.h}}}})

\item {} 
\sphinxcode{Filesystem.h} ({\hyperref[\detokenize{api/file_necsim_Filesystem.h:file-necsim-filesystem-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File Filesystem.h}}}})

\item {} 
\sphinxcode{algorithm}

\item {} 
\sphinxcode{set}

\item {} 
\sphinxcode{unordered\_map}

\end{itemize}


\subsubsection{Functions}
\label{\detokenize{api/file_necsim_Community.cpp:functions}}\begin{itemize}
\item {} 
{\hyperref[\detokenize{api/function_checkSpeciation:function-checkspeciation}]{\sphinxcrossref{\DUrole{std,std-ref}{Function checkSpeciation}}}}

\item {} 
{\hyperref[\detokenize{api/function_doubleCompare:function-doublecompare}]{\sphinxcrossref{\DUrole{std,std-ref}{Function doubleCompare}}}}

\item {} 
{\hyperref[\detokenize{api/function_doubleCompare:function-doublecompare}]{\sphinxcrossref{\DUrole{std,std-ref}{Function doubleCompare}}}}

\item {} 
{\hyperref[\detokenize{api/function_doubleCompare:function-doublecompare}]{\sphinxcrossref{\DUrole{std,std-ref}{Function doubleCompare}}}}

\end{itemize}


\subsection{File Community.h}
\label{\detokenize{api/file_necsim_Community.h:file-necsim-community-h}}\label{\detokenize{api/file_necsim_Community.h::doc}}\label{\detokenize{api/file_necsim_Community.h:file-community-h}}
Contains the {\hyperref[\detokenize{api/class_Community:class-community}]{\sphinxcrossref{\DUrole{std,std-ref}{Class Community}}}} object, which is used for reconstructing the coalescence tree after simulations are complete.

\begin{sphinxShadowBox}
\sphinxstyletopictitle{Contents}
\begin{itemize}
\item {} 
\phantomsection\label{\detokenize{api/file_necsim_Community.h:id1}}{\hyperref[\detokenize{api/file_necsim_Community.h:definition-necsim-community-h}]{\sphinxcrossref{Definition (\sphinxcode{necsim/Community.h})}}}

\item {} 
\phantomsection\label{\detokenize{api/file_necsim_Community.h:id2}}{\hyperref[\detokenize{api/file_necsim_Community.h:detailed-description}]{\sphinxcrossref{Detailed Description}}}

\item {} 
\phantomsection\label{\detokenize{api/file_necsim_Community.h:id3}}{\hyperref[\detokenize{api/file_necsim_Community.h:includes}]{\sphinxcrossref{Includes}}}

\item {} 
\phantomsection\label{\detokenize{api/file_necsim_Community.h:id4}}{\hyperref[\detokenize{api/file_necsim_Community.h:included-by}]{\sphinxcrossref{Included By}}}

\item {} 
\phantomsection\label{\detokenize{api/file_necsim_Community.h:id5}}{\hyperref[\detokenize{api/file_necsim_Community.h:classes}]{\sphinxcrossref{Classes}}}

\item {} 
\phantomsection\label{\detokenize{api/file_necsim_Community.h:id6}}{\hyperref[\detokenize{api/file_necsim_Community.h:functions}]{\sphinxcrossref{Functions}}}

\end{itemize}
\end{sphinxShadowBox}


\subsubsection{Definition (\sphinxstyleliteralintitle{necsim/Community.h})}
\label{\detokenize{api/file_necsim_Community.h:definition-necsim-community-h}}

\paragraph{Program Listing for File Community.h}
\label{\detokenize{api/program_listing_file_necsim_Community.h:program-listing-file-necsim-community-h}}\label{\detokenize{api/program_listing_file_necsim_Community.h:program-listing-for-file-community-h}}\label{\detokenize{api/program_listing_file_necsim_Community.h::doc}}\begin{itemize}
\item {} 
Return to documentation for {\hyperref[\detokenize{api/file_necsim_Community.h:file-necsim-community-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File Community.h}}}}

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{//This file is part of NECSim project which is released under BSD\PYGZhy{}3 license.}
\PYG{c+c1}{//See file **LICENSE.txt** or visit https://opensource.org/licenses/BSD\PYGZhy{}3\PYGZhy{}Clause) for full license details.}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifndef TREELIST}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define TREELIST}

\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}cmath\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}sqlite3.h\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}cstring\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}cmath\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}stdexcept\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}string\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ include \PYGZlt{}boost}\PYG{c+cp}{/}\PYG{c+cp}{filesystem.hpp\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}boost/lexical\PYGZus{}cast.hpp\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}set\PYGZgt{}}

\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZdq{}TreeNode.h\PYGZdq{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZdq{}Matrix.h\PYGZdq{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZdq{}DataMask.h\PYGZdq{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZdq{}SpecSimParameters.h\PYGZdq{}}

\PYG{k}{using} \PYG{k}{namespace} \PYG{n}{std}\PYG{p}{;}
\PYG{k}{using} \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{string}\PYG{p}{;}

\PYG{k+kt}{bool} \PYG{n+nf}{checkSpeciation}\PYG{p}{(}\PYG{k}{const} \PYG{k+kt}{long} \PYG{k+kt}{double} \PYG{o}{\PYGZam{}}\PYG{n}{random\PYGZus{}number}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{long} \PYG{k+kt}{double} \PYG{o}{\PYGZam{}}\PYG{n}{speciation\PYGZus{}rate}\PYG{p}{,}
                     \PYG{k}{const} \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{no\PYGZus{}generations}\PYG{p}{)}\PYG{p}{;}

\PYG{k+kt}{bool} \PYG{n+nf}{doubleCompare}\PYG{p}{(}\PYG{k+kt}{double} \PYG{n}{d1}\PYG{p}{,} \PYG{k+kt}{double} \PYG{n}{d2}\PYG{p}{,} \PYG{k+kt}{double} \PYG{n}{epsilon}\PYG{p}{)}\PYG{p}{;}

\PYG{k+kt}{bool} \PYG{n+nf}{doubleCompare}\PYG{p}{(}\PYG{k+kt}{long} \PYG{k+kt}{double} \PYG{n}{d1}\PYG{p}{,} \PYG{k+kt}{long} \PYG{k+kt}{double} \PYG{n}{d2}\PYG{p}{,} \PYG{k+kt}{long} \PYG{k+kt}{double} \PYG{n}{epsilon}\PYG{p}{)}\PYG{p}{;}

\PYG{k+kt}{bool} \PYG{n+nf}{doubleCompare}\PYG{p}{(}\PYG{k+kt}{long} \PYG{k+kt}{double} \PYG{n}{d1}\PYG{p}{,} \PYG{k+kt}{long} \PYG{k+kt}{double} \PYG{n}{d2}\PYG{p}{,} \PYG{k+kt}{double} \PYG{n}{epsilon}\PYG{p}{)}\PYG{p}{;}

\PYG{k}{struct} \PYG{n}{CommunityParameters}
\PYG{p}{\PYGZob{}}
    \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{reference}\PYG{p}{;}
    \PYG{k+kt}{long} \PYG{k+kt}{double} \PYG{n}{speciation\PYGZus{}rate}\PYG{p}{;}
    \PYG{k+kt}{long} \PYG{k+kt}{double} \PYG{n}{time}\PYG{p}{;}
    \PYG{k+kt}{bool} \PYG{n}{fragment}\PYG{p}{;}
    \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{metacommunity\PYGZus{}reference}\PYG{p}{;} \PYG{c+c1}{// will be 0 if no metacommunity used.}
    \PYG{k+kt}{bool} \PYG{n}{updated}\PYG{p}{;} \PYG{c+c1}{// set to true if the fragment reference needs updating in the database}

    \PYG{n}{CommunityParameters}\PYG{p}{(}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{reference} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
        \PYG{n}{speciation\PYGZus{}rate} \PYG{o}{=} \PYG{l+m+mf}{0.0}\PYG{p}{;}
        \PYG{n}{time} \PYG{o}{=} \PYG{l+m+mf}{0.0}\PYG{p}{;}
        \PYG{n}{fragment} \PYG{o}{=} \PYG{n+nb}{false}\PYG{p}{;}
        \PYG{n}{metacommunity\PYGZus{}reference} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
        \PYG{n}{updated} \PYG{o}{=} \PYG{n+nb}{false}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{n}{CommunityParameters}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{reference\PYGZus{}in}\PYG{p}{,} \PYG{k+kt}{long} \PYG{k+kt}{double} \PYG{n}{speciation\PYGZus{}rate\PYGZus{}in}\PYG{p}{,} \PYG{k+kt}{long} \PYG{k+kt}{double} \PYG{n}{time\PYGZus{}in}\PYG{p}{,}
                        \PYG{k+kt}{bool} \PYG{n}{fragment\PYGZus{}in}\PYG{p}{,} \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{metacommunity\PYGZus{}reference\PYGZus{}in}\PYG{p}{)}\PYG{p}{;}

    \PYG{k+kt}{void} \PYG{n+nf}{setup}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{reference\PYGZus{}in}\PYG{p}{,} \PYG{k+kt}{long} \PYG{k+kt}{double} \PYG{n}{speciation\PYGZus{}rate\PYGZus{}in}\PYG{p}{,} \PYG{k+kt}{long} \PYG{k+kt}{double} \PYG{n}{time\PYGZus{}in}\PYG{p}{,}
               \PYG{k+kt}{bool} \PYG{n}{fragment\PYGZus{}in}\PYG{p}{,} \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{metacommunity\PYGZus{}reference\PYGZus{}in}\PYG{p}{)}\PYG{p}{;}

    \PYG{k+kt}{bool} \PYG{n+nf}{compare}\PYG{p}{(}\PYG{k+kt}{long} \PYG{k+kt}{double} \PYG{n}{speciation\PYGZus{}rate\PYGZus{}in}\PYG{p}{,} \PYG{k+kt}{long} \PYG{k+kt}{double} \PYG{n}{time\PYGZus{}in}\PYG{p}{,} \PYG{k+kt}{bool} \PYG{n}{fragment\PYGZus{}in}\PYG{p}{,}
                 \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{metacommunity\PYGZus{}reference\PYGZus{}in}\PYG{p}{)}\PYG{p}{;}

    \PYG{k+kt}{bool} \PYG{n+nf}{compare}\PYG{p}{(}\PYG{k+kt}{long} \PYG{k+kt}{double} \PYG{n}{speciation\PYGZus{}rate\PYGZus{}in}\PYG{p}{,} \PYG{k+kt}{long} \PYG{k+kt}{double} \PYG{n}{time\PYGZus{}in}\PYG{p}{,} \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{metacommunity\PYGZus{}reference\PYGZus{}in}\PYG{p}{)}\PYG{p}{;}

    \PYG{k+kt}{bool} \PYG{n+nf}{compare}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{reference\PYGZus{}in}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}

\PYG{k}{struct} \PYG{n}{CommunitiesArray}
\PYG{p}{\PYGZob{}}
    \PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{n}{CommunityParameters}\PYG{o}{\PYGZgt{}} \PYG{n}{calc\PYGZus{}array}\PYG{p}{;}

    \PYG{k+kt}{void} \PYG{n+nf}{pushBack}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{reference}\PYG{p}{,} \PYG{k+kt}{long} \PYG{k+kt}{double} \PYG{n}{speciation\PYGZus{}rate}\PYG{p}{,} \PYG{k+kt}{long} \PYG{k+kt}{double} \PYG{n}{time}\PYG{p}{,} \PYG{k+kt}{bool} \PYG{n}{fragment}\PYG{p}{,}
                  \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{metacommunity\PYGZus{}reference}\PYG{p}{)}\PYG{p}{;}

    \PYG{k+kt}{void} \PYG{n+nf}{pushBack}\PYG{p}{(}\PYG{n}{CommunityParameters} \PYG{n}{tmp\PYGZus{}param}\PYG{p}{)}\PYG{p}{;}

    \PYG{n}{CommunityParameters} \PYG{o}{\PYGZam{}}\PYG{n}{addNew}\PYG{p}{(}\PYG{k+kt}{long} \PYG{k+kt}{double} \PYG{n}{speciation\PYGZus{}rate}\PYG{p}{,} \PYG{k+kt}{long} \PYG{k+kt}{double} \PYG{n}{time}\PYG{p}{,} \PYG{k+kt}{bool} \PYG{n}{fragment}\PYG{p}{,}
                                \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{metacommunity\PYGZus{}reference}\PYG{p}{)}\PYG{p}{;}

    \PYG{k+kt}{bool} \PYG{n+nf}{hasPair}\PYG{p}{(}\PYG{k+kt}{long} \PYG{k+kt}{double} \PYG{n}{speciation\PYGZus{}rate}\PYG{p}{,} \PYG{k+kt}{double} \PYG{n}{time}\PYG{p}{,} \PYG{k+kt}{bool} \PYG{n}{fragment}\PYG{p}{,} \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{metacommunity\PYGZus{}reference}\PYG{p}{)}\PYG{p}{;}

\PYG{p}{\PYGZcb{}}\PYG{p}{;}

\PYG{k}{struct} \PYG{n}{MetacommunityParameters}
\PYG{p}{\PYGZob{}}
    \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{reference}\PYG{p}{;}
    \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{metacommunity\PYGZus{}size}\PYG{p}{;}
    \PYG{k+kt}{long} \PYG{k+kt}{double} \PYG{n}{speciation\PYGZus{}rate}\PYG{p}{;}

    \PYG{n}{MetacommunityParameters}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{reference\PYGZus{}in}\PYG{p}{,} \PYG{k+kt}{long} \PYG{k+kt}{double} \PYG{n}{speciation\PYGZus{}rate\PYGZus{}in}\PYG{p}{,}
                            \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{metacommunity\PYGZus{}size\PYGZus{}in}\PYG{p}{)}\PYG{p}{;}

    \PYG{k+kt}{bool} \PYG{n+nf}{compare}\PYG{p}{(}\PYG{k+kt}{long} \PYG{k+kt}{double} \PYG{n}{speciation\PYGZus{}rate\PYGZus{}in}\PYG{p}{,} \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{metacommunity\PYGZus{}size\PYGZus{}in}\PYG{p}{)}\PYG{p}{;}

    \PYG{k+kt}{bool} \PYG{n+nf}{compare}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{reference\PYGZus{}in}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}

\PYG{k}{struct} \PYG{n}{MetacommunitiesArray}
\PYG{p}{\PYGZob{}}
    \PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{n}{MetacommunityParameters}\PYG{o}{\PYGZgt{}} \PYG{n}{calc\PYGZus{}array}\PYG{p}{;}

    \PYG{k+kt}{void} \PYG{n+nf}{pushBack}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{reference}\PYG{p}{,} \PYG{k+kt}{long} \PYG{k+kt}{double} \PYG{n}{speciation\PYGZus{}rate}\PYG{p}{,} \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{metacommunity\PYGZus{}size}\PYG{p}{)}\PYG{p}{;}

    \PYG{k+kt}{void} \PYG{n+nf}{pushBack}\PYG{p}{(}\PYG{n}{MetacommunityParameters} \PYG{n}{tmp\PYGZus{}param}\PYG{p}{)}\PYG{p}{;}

    \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n+nf}{addNew}\PYG{p}{(}\PYG{k+kt}{long} \PYG{k+kt}{double} \PYG{n}{speciation\PYGZus{}rate}\PYG{p}{,} \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{metacommunity\PYGZus{}size}\PYG{p}{)}\PYG{p}{;}

    \PYG{k+kt}{bool} \PYG{n+nf}{hasPair}\PYG{p}{(}\PYG{k+kt}{long} \PYG{k+kt}{double} \PYG{n}{speciation\PYGZus{}rate}\PYG{p}{,} \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{metacommunity\PYGZus{}size}\PYG{p}{)}\PYG{p}{;}

    \PYG{k+kt}{bool} \PYG{n+nf}{hasPair}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{reference}\PYG{p}{)}\PYG{p}{;}

    \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n+nf}{getReference}\PYG{p}{(}\PYG{k+kt}{long} \PYG{k+kt}{double} \PYG{n}{speciation\PYGZus{}rate}\PYG{p}{,} \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{metacommunity\PYGZus{}size}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}


\PYG{k}{struct} \PYG{n}{Fragment}
\PYG{p}{\PYGZob{}}
    \PYG{c+c1}{// the name for the fragment (for reference purposes)}
    \PYG{n}{string} \PYG{n}{name}\PYG{p}{;}
    \PYG{c+c1}{// coordinates for the extremes of the site}
    \PYG{k+kt}{long} \PYG{n}{x\PYGZus{}east}\PYG{p}{,} \PYG{n}{x\PYGZus{}west}\PYG{p}{,} \PYG{n}{y\PYGZus{}north}\PYG{p}{,} \PYG{n}{y\PYGZus{}south}\PYG{p}{;}
    \PYG{c+c1}{// the number of lineages in the fragment.}
    \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{num}\PYG{p}{;}
    \PYG{k+kt}{double} \PYG{n}{area}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}


\PYG{k}{class} \PYG{n+nc}{Samplematrix} \PYG{o}{:} \PYG{k}{public} \PYG{n}{DataMask}
\PYG{p}{\PYGZob{}}
\PYG{k}{private}\PYG{o}{:}
    \PYG{k+kt}{bool} \PYG{n}{bIsNull}\PYG{p}{;}
    \PYG{k+kt}{bool} \PYG{n}{bIsFragment}\PYG{p}{;}
    \PYG{n}{Fragment} \PYG{n}{fragment}\PYG{p}{;}
\PYG{k}{public}\PYG{o}{:}
    \PYG{n}{Samplematrix}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{//  /**}
\PYG{c+c1}{//   * @brief Returns the value at the x,y position.}
\PYG{c+c1}{//   * This is used for testing purposes only.}
\PYG{c+c1}{//   * @param xval the x coordinate.}
\PYG{c+c1}{//   * @param yval the y coordinate}
\PYG{c+c1}{//   * @param xwrap the x wrapping}
\PYG{c+c1}{//   * @param ywrap the y wrapping}
\PYG{c+c1}{//   * @return the value at x,y.}
\PYG{c+c1}{//   */}
    \PYG{k+kt}{bool} \PYG{n+nf}{getTestVal}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{xval}\PYG{p}{,} \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{yval}\PYG{p}{,} \PYG{k+kt}{long} \PYG{n}{xwrap}\PYG{p}{,} \PYG{k+kt}{long} \PYG{n}{ywrap}\PYG{p}{)}\PYG{p}{;}

    \PYG{k+kt}{bool} \PYG{n+nf}{getMaskVal}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{x1}\PYG{p}{,} \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{y1}\PYG{p}{,} \PYG{k+kt}{long} \PYG{n}{x\PYGZus{}wrap}\PYG{p}{,} \PYG{k+kt}{long} \PYG{n}{y\PYGZus{}wrap}\PYG{p}{)}\PYG{p}{;}

    \PYG{k+kt}{void} \PYG{n+nf}{setFragment}\PYG{p}{(}\PYG{n}{Fragment} \PYG{o}{\PYGZam{}}\PYG{n}{fragment\PYGZus{}in}\PYG{p}{)}\PYG{p}{;}

    \PYG{k+kt}{void} \PYG{n+nf}{removeFragment}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}

\PYG{k}{class} \PYG{n+nc}{Community}
\PYG{p}{\PYGZob{}}
\PYG{k}{protected}\PYG{o}{:}
    \PYG{k+kt}{bool} \PYG{n}{bMem}\PYG{p}{;} \PYG{c+c1}{// boolean for whether the database is in memory or not.}
    \PYG{k+kt}{bool} \PYG{n}{bFileSet}\PYG{p}{;} \PYG{c+c1}{// boolean for whether the database has been set already.}
    \PYG{n}{sqlite3} \PYG{o}{*}\PYG{n}{database}\PYG{p}{;} \PYG{c+c1}{// stores the in\PYGZhy{}memory database connection.}
    \PYG{n}{sqlite3} \PYG{o}{*}\PYG{n}{outdatabase}\PYG{p}{;} \PYG{c+c1}{// stores the file database connection}
    \PYG{k+kt}{bool} \PYG{n}{bSqlConnection}\PYG{p}{;} \PYG{c+c1}{// true if the data connection has been established.}
    \PYG{n}{Row}\PYG{o}{\PYGZlt{}}\PYG{n}{TreeNode}\PYG{o}{\PYGZgt{}} \PYG{o}{*}\PYG{n}{nodes}\PYG{p}{;} \PYG{c+c1}{// in older versions this was called list. Changed to avoid confusion with the built\PYGZhy{}in class.}
    \PYG{n}{Row}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{unsigned} \PYG{k+kt}{long}\PYG{o}{\PYGZgt{}} \PYG{n}{row\PYGZus{}out}\PYG{p}{;}
    \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{iSpecies}\PYG{p}{;}
    \PYG{k+kt}{bool} \PYG{n}{bSample}\PYG{p}{;} \PYG{c+c1}{// checks whether the samplemask has already been imported.}
    \PYG{k+kt}{bool} \PYG{n}{bDataImport}\PYG{p}{;} \PYG{c+c1}{// checks whether the main sim data has been imported.}
    \PYG{n}{Samplematrix} \PYG{n}{samplemask}\PYG{p}{;} \PYG{c+c1}{// the samplemask object for defining the areas we want to sample from.}
    \PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{n}{Fragment}\PYG{o}{\PYGZgt{}} \PYG{n}{fragments}\PYG{p}{;} \PYG{c+c1}{// a vector of fragments for storing each fragment\PYGZsq{}s coordinates.}
    \PYG{n}{CommunityParameters} \PYG{o}{*}\PYG{n}{current\PYGZus{}community\PYGZus{}parameters}\PYG{p}{;}
    \PYG{c+c1}{// the minimum speciation rate the original simulation was run with (this is read from the database SIMULATION\PYGZus{}PARAMETERS table)}
    \PYG{k+kt}{long} \PYG{k+kt}{double} \PYG{n}{min\PYGZus{}spec\PYGZus{}rate}\PYG{p}{;}
    \PYG{c+c1}{// The dimensions of the sample grid size.}
    \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{grid\PYGZus{}x\PYGZus{}size}\PYG{p}{,} \PYG{n}{grid\PYGZus{}y\PYGZus{}size}\PYG{p}{;}
    \PYG{c+c1}{// The dimensions of the original sample map file}
    \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{samplemask\PYGZus{}x\PYGZus{}size}\PYG{p}{,} \PYG{n}{samplemask\PYGZus{}y\PYGZus{}size}\PYG{p}{,} \PYG{n}{samplemask\PYGZus{}x\PYGZus{}offset}\PYG{p}{,} \PYG{n}{samplemask\PYGZus{}y\PYGZus{}offset}\PYG{p}{;}
    \PYG{c+c1}{// Vector containing past speciation rates}
    \PYG{n}{CommunitiesArray} \PYG{n}{past\PYGZus{}communities}\PYG{p}{;}
    \PYG{n}{MetacommunitiesArray} \PYG{n}{past\PYGZus{}metacommunities}\PYG{p}{;}
    \PYG{c+c1}{// Protracted speciation parameters}
    \PYG{k+kt}{bool} \PYG{n}{protracted}\PYG{p}{;}
    \PYG{k+kt}{double} \PYG{n}{min\PYGZus{}speciation\PYGZus{}gen}\PYG{p}{,} \PYG{n}{max\PYGZus{}speciation\PYGZus{}gen}\PYG{p}{,} \PYG{n}{applied\PYGZus{}min\PYGZus{}speciation\PYGZus{}gen}\PYG{p}{,} \PYG{n}{applied\PYGZus{}max\PYGZus{}speciation\PYGZus{}gen}\PYG{p}{;}
    \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{max\PYGZus{}species\PYGZus{}id}\PYG{p}{,} \PYG{n}{max\PYGZus{}fragment\PYGZus{}id}\PYG{p}{,} \PYG{n}{max\PYGZus{}locations\PYGZus{}id}\PYG{p}{;}
    \PYG{c+c1}{// Does not need to be stored during simulation pause}
    \PYG{n}{SpecSimParameters} \PYG{o}{*}\PYG{n}{spec\PYGZus{}sim\PYGZus{}parameters}\PYG{p}{;}
\PYG{k}{public}\PYG{o}{:}

    \PYG{n}{Community}\PYG{p}{(}\PYG{n}{Row}\PYG{o}{\PYGZlt{}}\PYG{n}{TreeNode}\PYG{o}{\PYGZgt{}} \PYG{o}{*}\PYG{n}{r}\PYG{p}{)} \PYG{o}{:} \PYG{n}{nodes}\PYG{p}{(}\PYG{n}{r}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{bMem} \PYG{o}{=} \PYG{n+nb}{false}\PYG{p}{;}
        \PYG{n}{iSpecies} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
        \PYG{n}{bSample} \PYG{o}{=} \PYG{n+nb}{false}\PYG{p}{;}
        \PYG{n}{bSqlConnection} \PYG{o}{=} \PYG{n+nb}{false}\PYG{p}{;}
        \PYG{n}{bFileSet} \PYG{o}{=} \PYG{n+nb}{false}\PYG{p}{;}
        \PYG{n}{bDataImport} \PYG{o}{=} \PYG{n+nb}{false}\PYG{p}{;}
        \PYG{n}{min\PYGZus{}speciation\PYGZus{}gen} \PYG{o}{=} \PYG{l+m+mf}{0.0}\PYG{p}{;}
        \PYG{n}{max\PYGZus{}speciation\PYGZus{}gen} \PYG{o}{=} \PYG{l+m+mf}{0.0}\PYG{p}{;}
        \PYG{n}{applied\PYGZus{}max\PYGZus{}speciation\PYGZus{}gen} \PYG{o}{=} \PYG{l+m+mf}{0.0}\PYG{p}{;}
        \PYG{n}{protracted} \PYG{o}{=} \PYG{n+nb}{false}\PYG{p}{;}
        \PYG{n}{current\PYGZus{}community\PYGZus{}parameters} \PYG{o}{=} \PYG{k}{nullptr}\PYG{p}{;}
        \PYG{n}{max\PYGZus{}species\PYGZus{}id} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
        \PYG{n}{max\PYGZus{}locations\PYGZus{}id} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}

    \PYG{p}{\PYGZcb{}}

    \PYG{n}{Community}\PYG{p}{(}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{bMem} \PYG{o}{=} \PYG{n+nb}{false}\PYG{p}{;}
        \PYG{n}{iSpecies} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
        \PYG{n}{bSample} \PYG{o}{=} \PYG{n+nb}{false}\PYG{p}{;}
        \PYG{n}{bSqlConnection} \PYG{o}{=} \PYG{n+nb}{false}\PYG{p}{;}
        \PYG{n}{bFileSet} \PYG{o}{=} \PYG{n+nb}{false}\PYG{p}{;}
        \PYG{n}{bDataImport} \PYG{o}{=} \PYG{n+nb}{false}\PYG{p}{;}
        \PYG{n}{min\PYGZus{}speciation\PYGZus{}gen} \PYG{o}{=} \PYG{l+m+mf}{0.0}\PYG{p}{;}
        \PYG{n}{max\PYGZus{}speciation\PYGZus{}gen} \PYG{o}{=} \PYG{l+m+mf}{0.0}\PYG{p}{;}
        \PYG{n}{applied\PYGZus{}max\PYGZus{}speciation\PYGZus{}gen} \PYG{o}{=} \PYG{l+m+mf}{0.0}\PYG{p}{;}
        \PYG{n}{protracted} \PYG{o}{=} \PYG{n+nb}{false}\PYG{p}{;}
        \PYG{n}{current\PYGZus{}community\PYGZus{}parameters} \PYG{o}{=} \PYG{k}{nullptr}\PYG{p}{;}
        \PYG{n}{max\PYGZus{}species\PYGZus{}id} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
        \PYG{n}{max\PYGZus{}locations\PYGZus{}id} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{o}{\PYGZti{}}\PYG{n}{Community}\PYG{p}{(}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{nodes} \PYG{o}{=} \PYG{k}{nullptr}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{k+kt}{void} \PYG{n}{setList}\PYG{p}{(}\PYG{n}{Row}\PYG{o}{\PYGZlt{}}\PYG{n}{TreeNode}\PYG{o}{\PYGZgt{}} \PYG{o}{*}\PYG{n}{l}\PYG{p}{)}\PYG{p}{;}

    \PYG{k+kt}{void} \PYG{n+nf}{setDatabase}\PYG{p}{(}\PYG{n}{sqlite3} \PYG{o}{*}\PYG{n}{dbin}\PYG{p}{)}\PYG{p}{;}

    \PYG{k+kt}{bool} \PYG{n+nf}{hasImportedData}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

    \PYG{k+kt}{long} \PYG{k+kt}{double} \PYG{n+nf}{getMinimumSpeciation}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

    \PYG{k+kt}{void} \PYG{n+nf}{importSamplemask}\PYG{p}{(}\PYG{n}{string} \PYG{n}{sSamplemask}\PYG{p}{)}\PYG{p}{;}

    \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n+nf}{countSpecies}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

    \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n+nf}{calcSpecies}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

    \PYG{k}{virtual} \PYG{k+kt}{void} \PYG{n+nf}{addSpecies}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{species\PYGZus{}count}\PYG{p}{,} \PYG{n}{TreeNode} \PYG{o}{*}\PYG{n}{treenode}\PYG{p}{,} \PYG{n}{set}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{unsigned} \PYG{k+kt}{long}\PYG{o}{\PYGZgt{}} \PYG{o}{\PYGZam{}}\PYG{n}{species\PYGZus{}list}\PYG{p}{)}\PYG{p}{;}

    \PYG{k+kt}{void} \PYG{n+nf}{calcSpeciesAbundance}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

    \PYG{k}{virtual} \PYG{k+kt}{void} \PYG{n+nf}{resetTree}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

    \PYG{k+kt}{void} \PYG{n+nf}{detectDimensions}\PYG{p}{(}\PYG{n}{string} \PYG{n}{db}\PYG{p}{)}\PYG{p}{;}

    \PYG{k+kt}{void} \PYG{n+nf}{openSqlConnection}\PYG{p}{(}\PYG{n}{string} \PYG{n}{inputfile}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kt}{void} \PYG{n+nf}{setInternalDatabase}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

    \PYG{k+kt}{void} \PYG{n+nf}{internalOption}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

    \PYG{k+kt}{void} \PYG{n+nf}{importData}\PYG{p}{(}\PYG{n}{string} \PYG{n}{inputfile}\PYG{p}{)}\PYG{p}{;}

    \PYG{k+kt}{void} \PYG{n+nf}{importSimParameters}\PYG{p}{(}\PYG{n}{string} \PYG{n}{file}\PYG{p}{)}\PYG{p}{;}

    \PYG{k+kt}{void} \PYG{n+nf}{getMaxSpeciesAbundancesID}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

    \PYG{n}{Row}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{unsigned} \PYG{k+kt}{long}\PYG{o}{\PYGZgt{}} \PYG{o}{*} \PYG{n}{getCumulativeAbundances}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

    \PYG{n}{Row}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{unsigned} \PYG{k+kt}{long}\PYG{o}{\PYGZgt{}} \PYG{n}{getRowOut}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

    \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n+nf}{getSpeciesNumber}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

    \PYG{k+kt}{void} \PYG{n+nf}{getMaxFragmentAbundancesID}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

    \PYG{k+kt}{void} \PYG{n+nf}{getMaxSpeciesLocationsID}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

    \PYG{k+kt}{void} \PYG{n+nf}{setProtractedParameters}\PYG{p}{(}\PYG{k+kt}{double} \PYG{n}{max\PYGZus{}speciation\PYGZus{}gen\PYGZus{}in}\PYG{p}{)}\PYG{p}{;}

    \PYG{k+kt}{void} \PYG{n+nf}{setProtractedParameters}\PYG{p}{(}\PYG{k}{const} \PYG{k+kt}{double} \PYG{o}{\PYGZam{}}\PYG{n}{max\PYGZus{}speciation\PYGZus{}gen\PYGZus{}in}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{double} \PYG{o}{\PYGZam{}}\PYG{n}{mix\PYGZus{}speciation\PYGZus{}gen\PYGZus{}in}\PYG{p}{)}\PYG{p}{;}

    \PYG{k+kt}{void} \PYG{n+nf}{overrideProtractedParameters}\PYG{p}{(}\PYG{k}{const} \PYG{k+kt}{double} \PYG{o}{\PYGZam{}}\PYG{n}{min\PYGZus{}speciation\PYGZus{}gen\PYGZus{}in}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{double} \PYG{o}{\PYGZam{}}\PYG{n}{max\PYGZus{}speciation\PYGZus{}gen\PYGZus{}in}\PYG{p}{)}\PYG{p}{;}

    \PYG{k+kt}{void} \PYG{n+nf}{setProtracted}\PYG{p}{(}\PYG{k+kt}{bool} \PYG{n}{protracted\PYGZus{}in}\PYG{p}{)}\PYG{p}{;}

    \PYG{k+kt}{void} \PYG{n+nf}{createDatabase}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

    \PYG{k+kt}{void} \PYG{n+nf}{generateCoalescenceTree}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

    \PYG{k+kt}{void} \PYG{n+nf}{outputSpeciesAbundances}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

    \PYG{k+kt}{bool} \PYG{n+nf}{checkCalculationsPerformed}\PYG{p}{(}\PYG{k+kt}{long} \PYG{k+kt}{double} \PYG{n}{speciation\PYGZus{}rate}\PYG{p}{,} \PYG{k+kt}{double} \PYG{n}{time}\PYG{p}{,} \PYG{k+kt}{bool} \PYG{n}{fragments}\PYG{p}{,}
                                    \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{metacommunity\PYGZus{}size}\PYG{p}{,} \PYG{k+kt}{long} \PYG{k+kt}{double} \PYG{n}{metacommunity\PYGZus{}speciation\PYGZus{}rate}\PYG{p}{)}\PYG{p}{;}

    \PYG{k+kt}{void} \PYG{n+nf}{addCalculationPerformed}\PYG{p}{(}\PYG{k+kt}{long} \PYG{k+kt}{double} \PYG{n}{speciation\PYGZus{}rate}\PYG{p}{,} \PYG{k+kt}{double} \PYG{n}{time}\PYG{p}{,} \PYG{k+kt}{bool} \PYG{n}{fragments}\PYG{p}{,}
                                 \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{metacommunity\PYGZus{}size}\PYG{p}{,} \PYG{k+kt}{long} \PYG{k+kt}{double} \PYG{n}{metacommunity\PYGZus{}speciation\PYGZus{}rate}\PYG{p}{)}\PYG{p}{;}

    \PYG{k+kt}{void} \PYG{n+nf}{createFragmentDatabase}\PYG{p}{(}\PYG{k}{const} \PYG{n}{Fragment} \PYG{o}{\PYGZam{}}\PYG{n}{f}\PYG{p}{)}\PYG{p}{;}

    \PYG{k+kt}{void} \PYG{n+nf}{exportDatabase}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

    \PYG{k+kt}{bool} \PYG{n+nf}{checkSpeciesLocationsReference}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

    \PYG{k+kt}{bool} \PYG{n+nf}{checkSpeciesAbundancesReference}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

    \PYG{k+kt}{void} \PYG{n+nf}{recordSpatial}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

    \PYG{k+kt}{void} \PYG{n+nf}{calcFragments}\PYG{p}{(}\PYG{n}{string} \PYG{n}{fragment\PYGZus{}file}\PYG{p}{)}\PYG{p}{;}

    \PYG{k+kt}{void} \PYG{n+nf}{applyFragments}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

    \PYG{k+kt}{void} \PYG{n+nf}{getPreviousCalcs}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

    \PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{unsigned} \PYG{k+kt}{long}\PYG{o}{\PYGZgt{}} \PYG{n}{getUniqueCommunityRefs}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

    \PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{unsigned} \PYG{k+kt}{long}\PYG{o}{\PYGZgt{}} \PYG{n}{getUniqueMetacommunityRefs}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

    \PYG{k+kt}{void} \PYG{n+nf}{writeNewCommunityParameters}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

    \PYG{k+kt}{void} \PYG{n+nf}{writeNewMetacommuntyParameters}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}


    \PYG{k+kt}{void} \PYG{n+nf}{updateCommunityParameters}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

    \PYG{k+kt}{void} \PYG{n+nf}{writeSpeciationRates}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

    \PYG{k+kt}{void} \PYG{n+nf}{calculateTree}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

    \PYG{k+kt}{void} \PYG{n+nf}{output}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

    \PYG{k+kt}{void} \PYG{n+nf}{printEndTimes}\PYG{p}{(}\PYG{k+kt}{time\PYGZus{}t} \PYG{n}{tStart}\PYG{p}{,} \PYG{k+kt}{time\PYGZus{}t} \PYG{n}{tEnd}\PYG{p}{)}\PYG{p}{;}

    \PYG{k}{virtual} \PYG{k+kt}{void} \PYG{n+nf}{apply}\PYG{p}{(}\PYG{n}{SpecSimParameters} \PYG{o}{*}\PYG{n}{sp}\PYG{p}{)}\PYG{p}{;}

    \PYG{k+kt}{void} \PYG{n+nf}{doApplication}\PYG{p}{(}\PYG{n}{SpecSimParameters} \PYG{o}{*}\PYG{n}{sp}\PYG{p}{)}\PYG{p}{;}

    \PYG{k+kt}{void} \PYG{n+nf}{doApplication}\PYG{p}{(}\PYG{n}{SpecSimParameters} \PYG{o}{*}\PYG{n}{sp}\PYG{p}{,} \PYG{n}{Row}\PYG{o}{\PYGZlt{}}\PYG{n}{TreeNode}\PYG{o}{\PYGZgt{}} \PYG{o}{*}\PYG{n}{data}\PYG{p}{)}\PYG{p}{;}

    \PYG{k+kt}{void} \PYG{n+nf}{doApplicationInternal}\PYG{p}{(}\PYG{n}{SpecSimParameters} \PYG{o}{*}\PYG{n}{sp}\PYG{p}{,} \PYG{n}{Row}\PYG{o}{\PYGZlt{}}\PYG{n}{TreeNode}\PYG{o}{\PYGZgt{}} \PYG{o}{*}\PYG{n}{data}\PYG{p}{)}\PYG{p}{;}

\PYG{p}{\PYGZcb{}}\PYG{p}{;}

\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif}
\end{sphinxVerbatim}


\subsubsection{Detailed Description}
\label{\detokenize{api/file_necsim_Community.h:detailed-description}}
Samuel Thompson
31/08/16
BSD-3 Licence.


\subsubsection{Includes}
\label{\detokenize{api/file_necsim_Community.h:includes}}\begin{itemize}
\item {} 
\sphinxcode{DataMask.h} ({\hyperref[\detokenize{api/file_necsim_DataMask.h:file-necsim-datamask-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File DataMask.h}}}})

\item {} 
\sphinxcode{Matrix.h} ({\hyperref[\detokenize{api/file_necsim_Matrix.h:file-necsim-matrix-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File Matrix.h}}}})

\item {} 
\sphinxcode{SpecSimParameters.h} ({\hyperref[\detokenize{api/file_necsim_SpecSimParameters.h:file-necsim-specsimparameters-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File SpecSimParameters.h}}}})

\item {} 
\sphinxcode{TreeNode.h} ({\hyperref[\detokenize{api/file_necsim_TreeNode.h:file-necsim-treenode-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File TreeNode.h}}}})

\item {} 
\sphinxcode{boost/filesystem.hpp}

\item {} 
\sphinxcode{boost/lexical\_cast.hpp}

\item {} 
\sphinxcode{cmath}

\item {} 
\sphinxcode{cstring}

\item {} 
\sphinxcode{set}

\item {} 
\sphinxcode{sqlite3.h}

\item {} 
\sphinxcode{stdexcept}

\item {} 
\sphinxcode{string}

\end{itemize}


\subsubsection{Included By}
\label{\detokenize{api/file_necsim_Community.h:included-by}}\begin{itemize}
\item {} 
{\hyperref[\detokenize{api/file_necsim_Community.cpp:file-necsim-community-cpp}]{\sphinxcrossref{\DUrole{std,std-ref}{File Community.cpp}}}}

\item {} 
{\hyperref[\detokenize{api/file_necsim_Tree.h:file-necsim-tree-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File Tree.h}}}}

\item {} 
{\hyperref[\detokenize{api/file_necsim_SpatialTree.h:file-necsim-spatialtree-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File SpatialTree.h}}}}

\item {} 
{\hyperref[\detokenize{api/file_necsim_Metacommunity.h:file-necsim-metacommunity-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File Metacommunity.h}}}}

\item {} 
{\hyperref[\detokenize{api/file_necsim_SimulateDispersal.cpp:file-necsim-simulatedispersal-cpp}]{\sphinxcrossref{\DUrole{std,std-ref}{File SimulateDispersal.cpp}}}}

\item {} 
{\hyperref[\detokenize{api/file_necsim_SpeciationCommands.h:file-necsim-speciationcommands-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File SpeciationCommands.h}}}}

\end{itemize}


\subsubsection{Classes}
\label{\detokenize{api/file_necsim_Community.h:classes}}\begin{itemize}
\item {} 
{\hyperref[\detokenize{api/struct_CommunityParameters:struct-communityparameters}]{\sphinxcrossref{\DUrole{std,std-ref}{Struct CommunityParameters}}}}

\item {} 
{\hyperref[\detokenize{api/struct_Fragment:struct-fragment}]{\sphinxcrossref{\DUrole{std,std-ref}{Struct Fragment}}}}

\item {} 
{\hyperref[\detokenize{api/struct_MetacommunitiesArray:struct-metacommunitiesarray}]{\sphinxcrossref{\DUrole{std,std-ref}{Struct MetacommunitiesArray}}}}

\item {} 
{\hyperref[\detokenize{api/struct_MetacommunityParameters:struct-metacommunityparameters}]{\sphinxcrossref{\DUrole{std,std-ref}{Struct MetacommunityParameters}}}}

\item {} 
{\hyperref[\detokenize{api/class_CommunitiesArray:class-communitiesarray}]{\sphinxcrossref{\DUrole{std,std-ref}{Class CommunitiesArray}}}}

\item {} 
{\hyperref[\detokenize{api/class_Community:class-community}]{\sphinxcrossref{\DUrole{std,std-ref}{Class Community}}}}

\item {} 
{\hyperref[\detokenize{api/class_Samplematrix:class-samplematrix}]{\sphinxcrossref{\DUrole{std,std-ref}{Class Samplematrix}}}}

\end{itemize}


\subsubsection{Functions}
\label{\detokenize{api/file_necsim_Community.h:functions}}\begin{itemize}
\item {} 
{\hyperref[\detokenize{api/function_checkSpeciation:function-checkspeciation}]{\sphinxcrossref{\DUrole{std,std-ref}{Function checkSpeciation}}}}

\item {} 
{\hyperref[\detokenize{api/function_doubleCompare:function-doublecompare}]{\sphinxcrossref{\DUrole{std,std-ref}{Function doubleCompare}}}}

\item {} 
{\hyperref[\detokenize{api/function_doubleCompare:function-doublecompare}]{\sphinxcrossref{\DUrole{std,std-ref}{Function doubleCompare}}}}

\item {} 
{\hyperref[\detokenize{api/function_doubleCompare:function-doublecompare}]{\sphinxcrossref{\DUrole{std,std-ref}{Function doubleCompare}}}}

\end{itemize}


\subsection{File ConfigFileParser.cpp}
\label{\detokenize{api/file_necsim_ConfigFileParser.cpp:file-necsim-configfileparser-cpp}}\label{\detokenize{api/file_necsim_ConfigFileParser.cpp::doc}}\label{\detokenize{api/file_necsim_ConfigFileParser.cpp:file-configfileparser-cpp}}
Contains implementation of the {\hyperref[\detokenize{api/file_necsim_ConfigFileParser.h:file-necsim-configfileparser-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File ConfigFileParser.h}}}} functions.

\begin{sphinxShadowBox}
\sphinxstyletopictitle{Contents}
\begin{itemize}
\item {} 
\phantomsection\label{\detokenize{api/file_necsim_ConfigFileParser.cpp:id1}}{\hyperref[\detokenize{api/file_necsim_ConfigFileParser.cpp:definition-necsim-configfileparser-cpp}]{\sphinxcrossref{Definition (\sphinxcode{necsim/ConfigFileParser.cpp})}}}

\item {} 
\phantomsection\label{\detokenize{api/file_necsim_ConfigFileParser.cpp:id2}}{\hyperref[\detokenize{api/file_necsim_ConfigFileParser.cpp:detailed-description}]{\sphinxcrossref{Detailed Description}}}

\item {} 
\phantomsection\label{\detokenize{api/file_necsim_ConfigFileParser.cpp:id3}}{\hyperref[\detokenize{api/file_necsim_ConfigFileParser.cpp:includes}]{\sphinxcrossref{Includes}}}

\item {} 
\phantomsection\label{\detokenize{api/file_necsim_ConfigFileParser.cpp:id4}}{\hyperref[\detokenize{api/file_necsim_ConfigFileParser.cpp:functions}]{\sphinxcrossref{Functions}}}

\end{itemize}
\end{sphinxShadowBox}


\subsubsection{Definition (\sphinxstyleliteralintitle{necsim/ConfigFileParser.cpp})}
\label{\detokenize{api/file_necsim_ConfigFileParser.cpp:definition-necsim-configfileparser-cpp}}

\paragraph{Program Listing for File ConfigFileParser.cpp}
\label{\detokenize{api/program_listing_file_necsim_ConfigFileParser.cpp:program-listing-file-necsim-configfileparser-cpp}}\label{\detokenize{api/program_listing_file_necsim_ConfigFileParser.cpp::doc}}\label{\detokenize{api/program_listing_file_necsim_ConfigFileParser.cpp:program-listing-for-file-configfileparser-cpp}}\begin{itemize}
\item {} 
Return to documentation for {\hyperref[\detokenize{api/file_necsim_ConfigFileParser.cpp:file-necsim-configfileparser-cpp}]{\sphinxcrossref{\DUrole{std,std-ref}{File ConfigFileParser.cpp}}}}

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{//This file is part of NECSim project which is released under BSD\PYGZhy{}3 license.}
\PYG{c+c1}{//See file **LICENSE.txt** or visit https://opensource.org/licenses/BSD\PYGZhy{}3\PYGZhy{}Clause) for full license details.}
\PYG{c+c1}{//}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZdq{}ConfigFileParser.h\PYGZdq{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZdq{}CustomExceptions.h\PYGZdq{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZdq{}Logging.h\PYGZdq{}}

\PYG{k+kt}{void} \PYG{n+nf}{importArgs}\PYG{p}{(}\PYG{k}{const} \PYG{k+kt}{unsigned} \PYG{k+kt}{int} \PYG{o}{\PYGZam{}}\PYG{n}{argc}\PYG{p}{,} \PYG{k+kt}{char} \PYG{o}{*}\PYG{n}{argv}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,} \PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{n}{string}\PYG{o}{\PYGZgt{}} \PYG{o}{\PYGZam{}}\PYG{n}{comargs}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{argc}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{comargs}\PYG{p}{.}\PYG{n}{emplace\PYGZus{}back}\PYG{p}{(}\PYG{n}{argv}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{c+c1}{// check size is correct}
    \PYG{k}{if}\PYG{p}{(}\PYG{n}{comargs}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)} \PYG{o}{!}\PYG{o}{=} \PYG{n}{argc}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{cerr} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ERROR\PYGZus{}MAIN\PYGZus{}010: Incorrect command line parsing.}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}

\PYG{n}{string} \PYG{n}{SectionOption}\PYG{o}{:}\PYG{o}{:}\PYG{n}{getOption}\PYG{p}{(}\PYG{n}{string} \PYG{n}{refval}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{refs}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{refs}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{=}\PYG{o}{=} \PYG{n}{refval}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{k}{return} \PYG{p}{(}\PYG{n}{val}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
    \PYG{p}{\PYGZcb{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifdef DEBUG}
    \PYG{n}{stringstream} \PYG{n}{ss}\PYG{p}{;}
        \PYG{n}{ss} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Reference }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{refval} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ not found in keyoption.}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
    \PYG{n}{writeInfo}\PYG{p}{(}\PYG{n}{ss}\PYG{p}{.}\PYG{n}{str}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif}
    \PYG{k}{return} \PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{null}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{n}{ostream} \PYG{o}{\PYGZam{}}\PYG{k}{operator}\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{p}{(}\PYG{n}{ostream} \PYG{o}{\PYGZam{}}\PYG{n}{os}\PYG{p}{,} \PYG{k}{const} \PYG{n}{SectionOption} \PYG{o}{\PYGZam{}}\PYG{n}{k}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{n}{os} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{k}\PYG{p}{.}\PYG{n}{section} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{k}\PYG{p}{.}\PYG{n}{val}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{k}\PYG{p}{.}\PYG{n}{refs}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
    \PYG{k}{for}\PYG{p}{(}\PYG{k}{const} \PYG{k}{auto} \PYG{o}{\PYGZam{}}\PYG{n+nl}{i} \PYG{p}{:} \PYG{n}{k}\PYG{p}{.}\PYG{n}{val}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{os} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{i} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{for}\PYG{p}{(}\PYG{k}{const} \PYG{k}{auto} \PYG{o}{\PYGZam{}}\PYG{n+nl}{ref} \PYG{p}{:} \PYG{n}{k}\PYG{p}{.}\PYG{n}{refs}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{os} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{ref} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{return} \PYG{n}{os}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{n}{istream} \PYG{o}{\PYGZam{}}\PYG{k}{operator}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{n}{istream} \PYG{o}{\PYGZam{}}\PYG{n}{is}\PYG{p}{,} \PYG{n}{SectionOption} \PYG{o}{\PYGZam{}}\PYG{n}{k}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{c+c1}{// os \PYGZlt{}\PYGZlt{} m.numRows\PYGZlt{}\PYGZlt{}\PYGZdq{} , \PYGZdq{}\PYGZlt{}\PYGZlt{}m.numCols\PYGZlt{}\PYGZlt{}\PYGZdq{} , \PYGZdq{}\PYGZlt{}\PYGZlt{}endl;}
    \PYG{k+kt}{unsigned} \PYG{k+kt}{int} \PYG{n}{valsize}\PYG{p}{,} \PYG{n}{refsize}\PYG{p}{;}
    \PYG{n}{is} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{k}\PYG{p}{.}\PYG{n}{section} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{valsize} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{refsize}\PYG{p}{;}
    \PYG{n}{is}\PYG{p}{.}\PYG{n}{ignore}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{string} \PYG{n}{tmp}\PYG{p}{;}
    \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{valsize}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{getline}\PYG{p}{(}\PYG{n}{is}\PYG{p}{,} \PYG{n}{tmp}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{k}\PYG{p}{.}\PYG{n}{val}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{n}{tmp}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{refsize}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{getline}\PYG{p}{(}\PYG{n}{is}\PYG{p}{,} \PYG{n}{tmp}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{k}\PYG{p}{.}\PYG{n}{refs}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{n}{tmp}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{return} \PYG{n}{is}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{void} \PYG{n}{ConfigOption}\PYG{o}{:}\PYG{o}{:}\PYG{n}{setConfig}\PYG{p}{(}\PYG{k}{const} \PYG{n}{string} \PYG{o}{\PYGZam{}}\PYG{n}{file}\PYG{p}{,} \PYG{k+kt}{bool} \PYG{n}{main}\PYG{p}{,} \PYG{k+kt}{bool} \PYG{n}{full\PYGZus{}parse}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k}{if}\PYG{p}{(}\PYG{o}{!}\PYG{n}{bConfig}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{bMain} \PYG{o}{=} \PYG{n}{main}\PYG{p}{;}
        \PYG{n}{configfile} \PYG{o}{=} \PYG{n}{file}\PYG{p}{;}
        \PYG{n}{bConfig} \PYG{o}{=} \PYG{n+nb}{true}\PYG{p}{;}
        \PYG{n}{bFullParse} \PYG{o}{=} \PYG{n}{full\PYGZus{}parse}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{else}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{throw} \PYG{n}{ConfigException}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Attempt to set config file twice.}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{void} \PYG{n}{ConfigOption}\PYG{o}{:}\PYG{o}{:}\PYG{n}{parseConfig}\PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{n}{ifstream} \PYG{n}{is\PYGZus{}file}\PYG{p}{;}
    \PYG{k}{try}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{is\PYGZus{}file}\PYG{p}{.}\PYG{n}{open}\PYG{p}{(}\PYG{n}{configfile}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{catch}\PYG{p}{(}\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{throw} \PYG{n}{ConfigException}\PYG{p}{(}
                \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ERROR\PYGZus{}CONF\PYGZus{}004c: Could not open the config file. Check file exists and is readable.}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{if}\PYG{p}{(}\PYG{o}{!}\PYG{n}{is\PYGZus{}file}\PYG{p}{.}\PYG{n}{fail}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\textbar{}}\PYG{o}{\textbar{}} \PYG{o}{!}\PYG{n}{is\PYGZus{}file}\PYG{p}{.}\PYG{n}{good}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{string} \PYG{n}{line}\PYG{p}{;}
        \PYG{c+c1}{// Get the first line of the file.}
        \PYG{k}{while}\PYG{p}{(}\PYG{n}{getline}\PYG{p}{(}\PYG{n}{is\PYGZus{}file}\PYG{p}{,} \PYG{n}{line}\PYG{p}{)}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
\PYG{c+c1}{//              os \PYGZlt{}\PYGZlt{} line \PYGZlt{}\PYGZlt{} endl;}
            \PYG{n}{istringstream} \PYG{n}{is\PYGZus{}line}\PYG{p}{(}\PYG{n}{line}\PYG{p}{)}\PYG{p}{;}
            \PYG{n}{string} \PYG{n}{key}\PYG{p}{;}
            \PYG{n}{string} \PYG{n}{val}\PYG{p}{;}
            \PYG{c+c1}{// Skip all whitespace}
            \PYG{n}{is\PYGZus{}line} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{skipws}\PYG{p}{;}
            \PYG{c+c1}{// start a new section}
            \PYG{k}{if}\PYG{p}{(}\PYG{n}{line}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{=}\PYG{o}{=} \PYG{l+s+sc}{\PYGZsq{}}\PYG{l+s+sc}{[}\PYG{l+s+sc}{\PYGZsq{}}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{n}{SectionOption} \PYG{n}{tempSections}\PYG{p}{;}
                \PYG{c+c1}{// get the section name}
                \PYG{n}{string} \PYG{n}{section}\PYG{p}{;}
                \PYG{k}{if}\PYG{p}{(}\PYG{n}{getline}\PYG{p}{(}\PYG{n}{is\PYGZus{}line}\PYG{p}{,} \PYG{n}{section}\PYG{p}{,} \PYG{l+s+sc}{\PYGZsq{}}\PYG{l+s+sc}{]}\PYG{l+s+sc}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{)}
                \PYG{p}{\PYGZob{}}
                    \PYG{n}{section} \PYG{o}{=} \PYG{n}{section}\PYG{p}{.}\PYG{n}{erase}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
                    \PYG{n}{tempSections}\PYG{p}{.}\PYG{n}{section} \PYG{o}{=} \PYG{n}{section}\PYG{p}{;}
\PYG{c+c1}{//                      os \PYGZlt{}\PYGZlt{} section \PYGZlt{}\PYGZlt{} endl;}
                \PYG{p}{\PYGZcb{}}
                \PYG{c+c1}{// read each line}
                \PYG{k}{while}\PYG{p}{(}\PYG{n}{getline}\PYG{p}{(}\PYG{n}{is\PYGZus{}file}\PYG{p}{,} \PYG{n}{line}\PYG{p}{)}\PYG{p}{)}
                \PYG{p}{\PYGZob{}}
                    \PYG{c+c1}{// end the section when a new one starts.}
                    \PYG{k}{if}\PYG{p}{(}\PYG{n}{line}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{=}\PYG{o}{=} \PYG{l+s+sc}{\PYGZsq{}}\PYG{l+s+sc}{[}\PYG{l+s+sc}{\PYGZsq{}} \PYG{o}{\textbar{}}\PYG{o}{\textbar{}} \PYG{n}{line}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)}
                    \PYG{p}{\PYGZob{}}
                        \PYG{k}{break}\PYG{p}{;}
                    \PYG{p}{\PYGZcb{}}
                    \PYG{n}{istringstream} \PYG{n}{is\PYGZus{}line2}\PYG{p}{(}\PYG{n}{line}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{// update the input\PYGZhy{}line stream}
                    \PYG{k}{if}\PYG{p}{(}\PYG{n}{getline}\PYG{p}{(}\PYG{n}{is\PYGZus{}line2}\PYG{p}{,} \PYG{n}{key}\PYG{p}{,} \PYG{l+s+sc}{\PYGZsq{}}\PYG{l+s+sc}{=}\PYG{l+s+sc}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{)}
                    \PYG{p}{\PYGZob{}}

                        \PYG{n}{key}\PYG{p}{.}\PYG{n}{erase}\PYG{p}{(}\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{remove}\PYG{p}{(}\PYG{n}{key}\PYG{p}{.}\PYG{n}{begin}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{n}{key}\PYG{p}{.}\PYG{n}{end}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{l+s+sc}{\PYGZsq{}}\PYG{l+s+sc}{ }\PYG{l+s+sc}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{,} \PYG{n}{key}\PYG{p}{.}\PYG{n}{end}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
                        \PYG{n}{is\PYGZus{}line2} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{skipws}\PYG{p}{;}
                    \PYG{p}{\PYGZcb{}}
                    \PYG{k}{if}\PYG{p}{(}\PYG{o}{!}\PYG{n}{is\PYGZus{}line2}\PYG{p}{)}
                    \PYG{p}{\PYGZob{}}
\PYG{c+c1}{//                          os \PYGZlt{}\PYGZlt{} is\PYGZus{}line2 \PYGZlt{}\PYGZlt{} endl;}
                        \PYG{k}{throw} \PYG{n}{ConfigException}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ERROR\PYGZus{}CONF\PYGZus{}001: Read error in config file.}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
                    \PYG{p}{\PYGZcb{}}
                    \PYG{k}{if}\PYG{p}{(}\PYG{n}{getline}\PYG{p}{(}\PYG{n}{is\PYGZus{}line2}\PYG{p}{,} \PYG{n}{val}\PYG{p}{)}\PYG{p}{)}
                    \PYG{p}{\PYGZob{}}
\PYG{c+c1}{//                          This line has been removed to allow for white spaces in file names and paths}
\PYG{c+c1}{//                          val.erase(std::remove(val.begin(), val.end(), \PYGZsq{} \PYGZsq{}), val.end());}
                        \PYG{k}{while}\PYG{p}{(}\PYG{n}{val}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{=}\PYG{o}{=} \PYG{l+s+sc}{\PYGZsq{}}\PYG{l+s+sc}{ }\PYG{l+s+sc}{\PYGZsq{}}\PYG{p}{)}
                        \PYG{p}{\PYGZob{}}
                            \PYG{n}{val}\PYG{p}{.}\PYG{n}{erase}\PYG{p}{(}\PYG{n}{val}\PYG{p}{.}\PYG{n}{begin}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{n}{val}\PYG{p}{.}\PYG{n}{begin}\PYG{p}{(}\PYG{p}{)} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
                        \PYG{p}{\PYGZcb{}}

                    \PYG{p}{\PYGZcb{}}
                    \PYG{k}{if}\PYG{p}{(}\PYG{o}{!}\PYG{n}{is\PYGZus{}line2}\PYG{p}{)}
                    \PYG{p}{\PYGZob{}}
                        \PYG{k}{throw} \PYG{n}{ConfigException}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ERROR\PYGZus{}CONF\PYGZus{}001: Read error in config file.}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
                    \PYG{p}{\PYGZcb{}}
                    \PYG{n}{tempSections}\PYG{p}{.}\PYG{n}{refs}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{n}{key}\PYG{p}{)}\PYG{p}{;}
                    \PYG{n}{tempSections}\PYG{p}{.}\PYG{n}{val}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{n}{val}\PYG{p}{)}\PYG{p}{;}
                \PYG{p}{\PYGZcb{}}
                \PYG{n}{configs}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{n}{tempSections}\PYG{p}{)}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
        \PYG{p}{\PYGZcb{}}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{else}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{throw} \PYG{n}{ConfigException}\PYG{p}{(}
                \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ERROR\PYGZus{}CONF\PYGZus{}004b: Could not open the config file }\PYG{l+s}{\PYGZdq{}} \PYG{o}{+} \PYG{n}{configfile} \PYG{o}{+}
                \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{. Check file exists and is readable.}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{if}\PYG{p}{(}\PYG{n}{is\PYGZus{}file}\PYG{p}{.}\PYG{n}{eof}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{is\PYGZus{}file}\PYG{p}{.}\PYG{n}{close}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{else}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{throw} \PYG{n}{ConfigException}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ERROR\PYGZus{}CONF\PYGZus{}002: End of file not reached. Check input file formating.}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}

\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{n}{SectionOption}\PYG{o}{\PYGZgt{}} \PYG{n}{ConfigOption}\PYG{o}{:}\PYG{o}{:}\PYG{n}{getSectionOptions}\PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k}{return} \PYG{n}{configs}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{void} \PYG{n}{ConfigOption}\PYG{o}{:}\PYG{o}{:}\PYG{n}{setSectionOption}\PYG{p}{(}\PYG{n}{string} \PYG{n}{section}\PYG{p}{,} \PYG{n}{string} \PYG{n}{reference}\PYG{p}{,} \PYG{n}{string} \PYG{n}{value}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{n}{SectionOption} \PYG{o}{*}\PYG{n}{section\PYGZus{}option} \PYG{o}{=} \PYG{k}{nullptr}\PYG{p}{;}
    \PYG{k}{for}\PYG{p}{(}\PYG{k}{auto} \PYG{o}{\PYGZam{}}\PYG{n+nl}{option} \PYG{p}{:} \PYG{n}{configs}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{option}\PYG{p}{.}\PYG{n}{section} \PYG{o}{=}\PYG{o}{=} \PYG{n}{section}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{section\PYGZus{}option} \PYG{o}{=} \PYG{o}{\PYGZam{}}\PYG{n}{option}\PYG{p}{;}
            \PYG{k}{break}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{if}\PYG{p}{(}\PYG{o}{!}\PYG{n}{section\PYGZus{}option}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{SectionOption} \PYG{n}{tmp}\PYG{p}{;}
        \PYG{n}{tmp}\PYG{p}{.}\PYG{n}{section} \PYG{o}{=} \PYG{n}{section}\PYG{p}{;}
        \PYG{n}{configs}\PYG{p}{.}\PYG{n}{emplace\PYGZus{}back}\PYG{p}{(}\PYG{n}{tmp}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{section\PYGZus{}option} \PYG{o}{=} \PYG{o}{\PYGZam{}}\PYG{n}{configs}\PYG{p}{.}\PYG{n}{back}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{n}{section\PYGZus{}option}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{refs}\PYG{p}{.}\PYG{n}{emplace\PYGZus{}back}\PYG{p}{(}\PYG{n}{reference}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{section\PYGZus{}option}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{val}\PYG{p}{.}\PYG{n}{emplace\PYGZus{}back}\PYG{p}{(}\PYG{n}{value}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{n}{SectionOption} \PYG{n}{ConfigOption}\PYG{o}{:}\PYG{o}{:}\PYG{k}{operator}\PYG{p}{[}\PYG{p}{]}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{index}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k}{return} \PYG{n}{configs}\PYG{p}{[}\PYG{n}{index}\PYG{p}{]}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{unsigned} \PYG{k+kt}{int} \PYG{n}{ConfigOption}\PYG{o}{:}\PYG{o}{:}\PYG{n}{getSectionOptionsSize}\PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k}{return} \PYG{n}{configs}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{n}{string}\PYG{o}{\PYGZgt{}} \PYG{n}{ConfigOption}\PYG{o}{:}\PYG{o}{:}\PYG{n}{getSections}\PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{n}{string}\PYG{o}{\PYGZgt{}} \PYG{n}{toret}\PYG{p}{;}
    \PYG{k}{for}\PYG{p}{(}\PYG{k}{auto} \PYG{o}{\PYGZam{}}\PYG{n+nl}{config} \PYG{p}{:} \PYG{n}{configs}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{toret}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{n}{config}\PYG{p}{.}\PYG{n}{section}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{return} \PYG{n}{toret}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{bool} \PYG{n}{ConfigOption}\PYG{o}{:}\PYG{o}{:}\PYG{n}{hasSection}\PYG{p}{(}\PYG{k}{const} \PYG{n}{string} \PYG{o}{\PYGZam{}}\PYG{n}{sec}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k}{for}\PYG{p}{(}\PYG{k}{auto} \PYG{o}{\PYGZam{}}\PYG{n+nl}{config} \PYG{p}{:} \PYG{n}{configs}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{config}\PYG{p}{.}\PYG{n}{section} \PYG{o}{=}\PYG{o}{=} \PYG{n}{sec}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{k}{return} \PYG{p}{(}\PYG{n+nb}{true}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{return} \PYG{n+nb}{false}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{n}{string}\PYG{o}{\PYGZgt{}} \PYG{n}{ConfigOption}\PYG{o}{:}\PYG{o}{:}\PYG{n}{getSectionValues}\PYG{p}{(}\PYG{n}{string} \PYG{n}{sec}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k}{for}\PYG{p}{(}\PYG{k}{auto} \PYG{o}{\PYGZam{}}\PYG{n+nl}{config} \PYG{p}{:} \PYG{n}{configs}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{config}\PYG{p}{.}\PYG{n}{section} \PYG{o}{=}\PYG{o}{=} \PYG{n}{sec}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{k}{return} \PYG{p}{(}\PYG{n}{config}\PYG{p}{.}\PYG{n}{val}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{throw} \PYG{n}{ConfigException}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Section not found in config file: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{+} \PYG{n}{sec}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{n}{string} \PYG{n}{ConfigOption}\PYG{o}{:}\PYG{o}{:}\PYG{n}{getSectionOptions}\PYG{p}{(}\PYG{n}{string} \PYG{n}{section}\PYG{p}{,} \PYG{n}{string} \PYG{n}{ref}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k}{for}\PYG{p}{(}\PYG{k}{auto} \PYG{o}{\PYGZam{}}\PYG{n+nl}{config} \PYG{p}{:} \PYG{n}{configs}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{config}\PYG{p}{.}\PYG{n}{section} \PYG{o}{=}\PYG{o}{=} \PYG{n}{section}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{int} \PYG{n}{j} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{j} \PYG{o}{\PYGZlt{}} \PYG{n}{config}\PYG{p}{.}\PYG{n}{refs}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{n}{j}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{k}{if}\PYG{p}{(}\PYG{n}{config}\PYG{p}{.}\PYG{n}{refs}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]} \PYG{o}{=}\PYG{o}{=} \PYG{n}{ref}\PYG{p}{)}
                \PYG{p}{\PYGZob{}}
                    \PYG{k}{return} \PYG{p}{(}\PYG{n}{config}\PYG{p}{.}\PYG{n}{val}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
                \PYG{p}{\PYGZcb{}}
            \PYG{p}{\PYGZcb{}}
        \PYG{p}{\PYGZcb{}}
    \PYG{p}{\PYGZcb{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifdef DEBUG}
    \PYG{n}{writeWarning}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{No reference found for }\PYG{l+s}{\PYGZdq{}} \PYG{o}{+} \PYG{n}{section} \PYG{o}{+} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{, }\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif}
    \PYG{k}{return} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{null}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{n}{string} \PYG{n}{ConfigOption}\PYG{o}{:}\PYG{o}{:}\PYG{n}{getSectionOptions}\PYG{p}{(}\PYG{n}{string} \PYG{n}{section}\PYG{p}{,} \PYG{n}{string} \PYG{n}{ref}\PYG{p}{,} \PYG{n}{string} \PYG{n}{def}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k}{for}\PYG{p}{(}\PYG{k}{auto} \PYG{o}{\PYGZam{}}\PYG{n+nl}{config} \PYG{p}{:} \PYG{n}{configs}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{config}\PYG{p}{.}\PYG{n}{section} \PYG{o}{=}\PYG{o}{=} \PYG{n}{section}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{int} \PYG{n}{j} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{j} \PYG{o}{\PYGZlt{}} \PYG{n}{config}\PYG{p}{.}\PYG{n}{refs}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{n}{j}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{k}{if}\PYG{p}{(}\PYG{n}{config}\PYG{p}{.}\PYG{n}{refs}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]} \PYG{o}{=}\PYG{o}{=} \PYG{n}{ref}\PYG{p}{)}
                \PYG{p}{\PYGZob{}}
                    \PYG{k}{return} \PYG{p}{(}\PYG{n}{config}\PYG{p}{.}\PYG{n}{val}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
                \PYG{p}{\PYGZcb{}}
            \PYG{p}{\PYGZcb{}}
        \PYG{p}{\PYGZcb{}}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{return} \PYG{n}{def}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{int} \PYG{n}{ConfigOption}\PYG{o}{:}\PYG{o}{:}\PYG{n}{importConfig}\PYG{p}{(}\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{n}{string}\PYG{o}{\PYGZgt{}} \PYG{o}{\PYGZam{}}\PYG{n}{comargs}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{c+c1}{// Check that the previous arguments have already been imported.}
    \PYG{k}{if}\PYG{p}{(}\PYG{n}{bMain}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{comargs}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)} \PYG{o}{!}\PYG{o}{=} \PYG{l+m+mi}{3}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{k}{throw} \PYG{n}{ConfigException}\PYG{p}{(}
                    \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ERROR\PYGZus{}CONF\PYGZus{}003: Number of command line arguments not correct before importSpatialParameters.}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
    \PYG{p}{\PYGZcb{}}
    \PYG{n}{ifstream} \PYG{n}{is\PYGZus{}file}\PYG{p}{;}
    \PYG{k}{try}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{is\PYGZus{}file}\PYG{p}{.}\PYG{n}{open}\PYG{p}{(}\PYG{n}{configfile}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{catch}\PYG{p}{(}\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{throw} \PYG{n}{ConfigException}\PYG{p}{(}
                \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ERROR\PYGZus{}CONF\PYGZus{}004a: Could not open the config file. Check file exists and is readable.}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{if}\PYG{p}{(}\PYG{o}{!}\PYG{n}{is\PYGZus{}file}\PYG{p}{.}\PYG{n}{fail}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{string} \PYG{n}{line}\PYG{p}{;}
        \PYG{k}{while}\PYG{p}{(}\PYG{n}{getline}\PYG{p}{(}\PYG{n}{is\PYGZus{}file}\PYG{p}{,} \PYG{n}{line}\PYG{p}{)}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{istringstream} \PYG{n}{is\PYGZus{}line}\PYG{p}{(}\PYG{n}{line}\PYG{p}{)}\PYG{p}{;}
            \PYG{n}{string} \PYG{n}{key}\PYG{p}{;}
            \PYG{n}{is\PYGZus{}line} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{skipws}\PYG{p}{;}
            \PYG{k}{if}\PYG{p}{(}\PYG{n}{line}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{=}\PYG{o}{=} \PYG{l+s+sc}{\PYGZsq{}}\PYG{l+s+sc}{[}\PYG{l+s+sc}{\PYGZsq{}}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{k}{continue}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
            \PYG{k}{if}\PYG{p}{(}\PYG{n}{getline}\PYG{p}{(}\PYG{n}{is\PYGZus{}line}\PYG{p}{,} \PYG{n}{key}\PYG{p}{,} \PYG{l+s+sc}{\PYGZsq{}}\PYG{l+s+sc}{=}\PYG{l+s+sc}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{c+c1}{// Could implement proper data parsing based on the key object.}
                \PYG{n}{is\PYGZus{}line} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{skipws}\PYG{p}{;}
                \PYG{n}{string} \PYG{n}{value}\PYG{p}{;}
                \PYG{k}{if}\PYG{p}{(}\PYG{n}{getline}\PYG{p}{(}\PYG{n}{is\PYGZus{}line}\PYG{p}{,} \PYG{n}{value}\PYG{p}{)}\PYG{p}{)}
                \PYG{p}{\PYGZob{}}
                    \PYG{n}{value}\PYG{p}{.}\PYG{n}{erase}\PYG{p}{(}\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{remove}\PYG{p}{(}\PYG{n}{value}\PYG{p}{.}\PYG{n}{begin}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{n}{value}\PYG{p}{.}\PYG{n}{end}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{l+s+sc}{\PYGZsq{}}\PYG{l+s+sc}{ }\PYG{l+s+sc}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{,} \PYG{n}{value}\PYG{p}{.}\PYG{n}{end}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
                    \PYG{k}{if}\PYG{p}{(}\PYG{o}{!}\PYG{n}{is\PYGZus{}line}\PYG{p}{)}
                    \PYG{p}{\PYGZob{}}
                        \PYG{n}{stringstream} \PYG{n}{os}\PYG{p}{;}
                        \PYG{n}{os} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{value} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
                        \PYG{n}{writeWarning}\PYG{p}{(}\PYG{n}{os}\PYG{p}{.}\PYG{n}{str}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
                        \PYG{k}{throw} \PYG{n+nf}{ConfigException}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ERROR\PYGZus{}CONF\PYGZus{}001: Read error in config file.}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
                    \PYG{p}{\PYGZcb{}}
                    \PYG{k}{auto} \PYG{o}{*}\PYG{n}{tmp} \PYG{o}{=} \PYG{k}{new} \PYG{k+kt}{char}\PYG{p}{[}\PYG{n}{value}\PYG{p}{.}\PYG{n}{length}\PYG{p}{(}\PYG{p}{)} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{;}
                    \PYG{n}{strcpy}\PYG{p}{(}\PYG{n}{tmp}\PYG{p}{,} \PYG{n}{value}\PYG{p}{.}\PYG{n}{c\PYGZus{}str}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
                    \PYG{n}{comargs}\PYG{p}{.}\PYG{n}{emplace\PYGZus{}back}\PYG{p}{(}\PYG{n}{tmp}\PYG{p}{)}\PYG{p}{;}
                \PYG{p}{\PYGZcb{}}
            \PYG{p}{\PYGZcb{}}
        \PYG{p}{\PYGZcb{}}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{else}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{throw} \PYG{n}{ConfigException}\PYG{p}{(}
                \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ERROR\PYGZus{}CONF\PYGZus{}004d: Could not open the config file. Check file exists and is readable.}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{if}\PYG{p}{(}\PYG{n}{is\PYGZus{}file}\PYG{p}{.}\PYG{n}{eof}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{is\PYGZus{}file}\PYG{p}{.}\PYG{n}{close}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{else}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{throw} \PYG{n}{ConfigException}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ERROR\PYGZus{}CONF\PYGZus{}002: End of file not reached. Check input file formating.}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{if}\PYG{p}{(}\PYG{n}{bMain}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{c+c1}{// remove the file name from the command line arguments to maintain the vector format.}
        \PYG{n}{comargs}\PYG{p}{.}\PYG{n}{erase}\PYG{p}{(}\PYG{n}{comargs}\PYG{p}{.}\PYG{n}{begin}\PYG{p}{(}\PYG{p}{)} \PYG{o}{+} \PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{return} \PYG{n}{comargs}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{n}{ostream} \PYG{o}{\PYGZam{}}\PYG{k}{operator}\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{p}{(}\PYG{n}{ostream} \PYG{o}{\PYGZam{}}\PYG{n}{os}\PYG{p}{,} \PYG{k}{const} \PYG{n}{ConfigOption} \PYG{o}{\PYGZam{}}\PYG{n}{c}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{n}{os} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{c}\PYG{p}{.}\PYG{n}{configfile} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{c}\PYG{p}{.}\PYG{n}{bConfig} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{c}\PYG{p}{.}\PYG{n}{bMain} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{c}\PYG{p}{.}\PYG{n}{bFullParse} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{c}\PYG{p}{.}\PYG{n}{configs}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}
       \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
    \PYG{k}{for}\PYG{p}{(}\PYG{k}{const} \PYG{k}{auto} \PYG{o}{\PYGZam{}}\PYG{n+nl}{config} \PYG{p}{:} \PYG{n}{c}\PYG{p}{.}\PYG{n}{configs}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{os} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{config}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{return} \PYG{n}{os}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{n}{istream} \PYG{o}{\PYGZam{}}\PYG{k}{operator}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{n}{istream} \PYG{o}{\PYGZam{}}\PYG{n}{is}\PYG{p}{,} \PYG{n}{ConfigOption} \PYG{o}{\PYGZam{}}\PYG{n}{c}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k+kt}{unsigned} \PYG{k+kt}{int} \PYG{n}{configsize}\PYG{p}{;}
    \PYG{n}{is}\PYG{p}{.}\PYG{n}{ignore}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{getline}\PYG{p}{(}\PYG{n}{is}\PYG{p}{,} \PYG{n}{c}\PYG{p}{.}\PYG{n}{configfile}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{is} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{c}\PYG{p}{.}\PYG{n}{bConfig} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{c}\PYG{p}{.}\PYG{n}{bMain} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{c}\PYG{p}{.}\PYG{n}{bFullParse} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{configsize}\PYG{p}{;}
    \PYG{n}{SectionOption} \PYG{n}{tmpoption}\PYG{p}{;}
    \PYG{k}{if}\PYG{p}{(}\PYG{n}{configsize} \PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{10000}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{throw} \PYG{n}{runtime\PYGZus{}error}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Config size extremely large, check file: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{+} \PYG{n}{to\PYGZus{}string}\PYG{p}{(}\PYG{n}{configsize}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{if}\PYG{p}{(}\PYG{n}{configsize} \PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{0}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{configsize}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{is} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{tmpoption}\PYG{p}{;}
            \PYG{n}{c}\PYG{p}{.}\PYG{n}{configs}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{n}{tmpoption}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
    \PYG{p}{\PYGZcb{}}
\PYG{c+c1}{//      os \PYGZlt{}\PYGZlt{} \PYGZdq{}end config\PYGZdq{} \PYGZlt{}\PYGZlt{} endl;}
    \PYG{k}{return} \PYG{n}{is}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}


\subsubsection{Detailed Description}
\label{\detokenize{api/file_necsim_ConfigFileParser.cpp:detailed-description}}
Sam Thompson
31/08/2016
Contact: \sphinxhref{mailto:samuel.thompson14@imperial.ac.uk}{samuel.thompson14@imperial.ac.uk} or \sphinxhref{mailto:thompsonsed@gmail.com}{thompsonsed@gmail.com} BSD-3 Licence.


\subsubsection{Includes}
\label{\detokenize{api/file_necsim_ConfigFileParser.cpp:includes}}\begin{itemize}
\item {} 
\sphinxcode{ConfigFileParser.h} ({\hyperref[\detokenize{api/file_necsim_ConfigFileParser.h:file-necsim-configfileparser-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File ConfigFileParser.h}}}})

\item {} 
\sphinxcode{CustomExceptions.h} ({\hyperref[\detokenize{api/file_necsim_CustomExceptions.h:file-necsim-customexceptions-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File CustomExceptions.h}}}})

\item {} 
\sphinxcode{Logging.h} ({\hyperref[\detokenize{api/file_necsim_Logging.h:file-necsim-logging-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File Logging.h}}}})

\end{itemize}


\subsubsection{Functions}
\label{\detokenize{api/file_necsim_ConfigFileParser.cpp:functions}}\begin{itemize}
\item {} 
{\hyperref[\detokenize{api/function_importArgs:function-importargs}]{\sphinxcrossref{\DUrole{std,std-ref}{Function importArgs}}}}

\item {} 
{\hyperref[\detokenize{api/function_operator_LT__LT:function-operator-lt-lt}]{\sphinxcrossref{\DUrole{std,std-ref}{Function operator\textless{}\textless{}}}}}

\item {} 
{\hyperref[\detokenize{api/function_operator_LT__LT:function-operator-lt-lt}]{\sphinxcrossref{\DUrole{std,std-ref}{Function operator\textless{}\textless{}}}}}

\item {} 
{\hyperref[\detokenize{api/function_operator_GT__GT:function-operator-gt-gt}]{\sphinxcrossref{\DUrole{std,std-ref}{Function operator\textgreater{}\textgreater{}}}}}

\item {} 
{\hyperref[\detokenize{api/function_operator_GT__GT:function-operator-gt-gt}]{\sphinxcrossref{\DUrole{std,std-ref}{Function operator\textgreater{}\textgreater{}}}}}

\end{itemize}


\subsection{File ConfigFileParser.h}
\label{\detokenize{api/file_necsim_ConfigFileParser.h:file-configfileparser-h}}\label{\detokenize{api/file_necsim_ConfigFileParser.h::doc}}\label{\detokenize{api/file_necsim_ConfigFileParser.h:file-necsim-configfileparser-h}}
{\hyperref[\detokenize{api/class_ConfigOption:class-configoption}]{\sphinxcrossref{\DUrole{std,std-ref}{Class ConfigOption}}}} and {\hyperref[\detokenize{api/struct_SectionOption:struct-sectionoption}]{\sphinxcrossref{\DUrole{std,std-ref}{Struct SectionOption}}}} classes for importing command line parameters from a config text file, originally designed for usage within coalescence simulations on a cluster.

\begin{sphinxShadowBox}
\sphinxstyletopictitle{Contents}
\begin{itemize}
\item {} 
\phantomsection\label{\detokenize{api/file_necsim_ConfigFileParser.h:id1}}{\hyperref[\detokenize{api/file_necsim_ConfigFileParser.h:definition-necsim-configfileparser-h}]{\sphinxcrossref{Definition (\sphinxcode{necsim/ConfigFileParser.h})}}}

\item {} 
\phantomsection\label{\detokenize{api/file_necsim_ConfigFileParser.h:id2}}{\hyperref[\detokenize{api/file_necsim_ConfigFileParser.h:detailed-description}]{\sphinxcrossref{Detailed Description}}}

\item {} 
\phantomsection\label{\detokenize{api/file_necsim_ConfigFileParser.h:id3}}{\hyperref[\detokenize{api/file_necsim_ConfigFileParser.h:includes}]{\sphinxcrossref{Includes}}}

\item {} 
\phantomsection\label{\detokenize{api/file_necsim_ConfigFileParser.h:id4}}{\hyperref[\detokenize{api/file_necsim_ConfigFileParser.h:included-by}]{\sphinxcrossref{Included By}}}

\item {} 
\phantomsection\label{\detokenize{api/file_necsim_ConfigFileParser.h:id5}}{\hyperref[\detokenize{api/file_necsim_ConfigFileParser.h:classes}]{\sphinxcrossref{Classes}}}

\item {} 
\phantomsection\label{\detokenize{api/file_necsim_ConfigFileParser.h:id6}}{\hyperref[\detokenize{api/file_necsim_ConfigFileParser.h:functions}]{\sphinxcrossref{Functions}}}

\end{itemize}
\end{sphinxShadowBox}


\subsubsection{Definition (\sphinxstyleliteralintitle{necsim/ConfigFileParser.h})}
\label{\detokenize{api/file_necsim_ConfigFileParser.h:definition-necsim-configfileparser-h}}

\paragraph{Program Listing for File ConfigFileParser.h}
\label{\detokenize{api/program_listing_file_necsim_ConfigFileParser.h:program-listing-for-file-configfileparser-h}}\label{\detokenize{api/program_listing_file_necsim_ConfigFileParser.h::doc}}\label{\detokenize{api/program_listing_file_necsim_ConfigFileParser.h:program-listing-file-necsim-configfileparser-h}}\begin{itemize}
\item {} 
Return to documentation for {\hyperref[\detokenize{api/file_necsim_ConfigFileParser.h:file-necsim-configfileparser-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File ConfigFileParser.h}}}}

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{// This file is part of NECSim project which is released under BSD\PYGZhy{}3 license.}
\PYG{c+c1}{// See file **LICENSE.txt** or visit https://opensource.org/licenses/BSD\PYGZhy{}3\PYGZhy{}Clause) for full license details.}
\PYG{c+c1}{//}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifndef CONFIGCLASS}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define CONFIGCLASS}

\PYG{c+cm}{/************************************************************}
\PYG{c+cm}{                                                                                                                                                                                                INCLUDES}
\PYG{c+cm}{ ************************************************************/}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}string\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}iostream\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}sstream\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}fstream\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}stdexcept\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}vector\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}cstring\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}unistd.h\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}cmath\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}cctype\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}algorithm\PYGZgt{}}


\PYG{k}{using} \PYG{k}{namespace} \PYG{n}{std}\PYG{p}{;}
\PYG{k}{using} \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{string}\PYG{p}{;}

\PYG{k+kt}{void} \PYG{n+nf}{importArgs}\PYG{p}{(}\PYG{k}{const} \PYG{k+kt}{unsigned} \PYG{k+kt}{int} \PYG{o}{\PYGZam{}}\PYG{n}{argc}\PYG{p}{,} \PYG{k+kt}{char} \PYG{o}{*}\PYG{n}{argv}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,} \PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{n}{string}\PYG{o}{\PYGZgt{}} \PYG{o}{\PYGZam{}}\PYG{n}{comargs}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{//}

\PYG{k}{struct} \PYG{n}{SectionOption}
\PYG{p}{\PYGZob{}}
    \PYG{n}{string} \PYG{n}{section}\PYG{p}{;}
    \PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{n}{string}\PYG{o}{\PYGZgt{}} \PYG{n}{val}\PYG{p}{;}
    \PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{n}{string}\PYG{o}{\PYGZgt{}} \PYG{n}{refs}\PYG{p}{;}

    \PYG{n}{SectionOption}\PYG{p}{(}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{section} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{nullSectionOption}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{n}{string} \PYG{n}{getOption}\PYG{p}{(}\PYG{n}{string} \PYG{n}{refval}\PYG{p}{)}\PYG{p}{;}

    \PYG{k}{friend} \PYG{n}{ostream} \PYG{o}{\PYGZam{}}\PYG{k}{operator}\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{p}{(}\PYG{n}{ostream} \PYG{o}{\PYGZam{}}\PYG{n}{os}\PYG{p}{,} \PYG{k}{const} \PYG{n}{SectionOption} \PYG{o}{\PYGZam{}}\PYG{n}{k}\PYG{p}{)}\PYG{p}{;}

    \PYG{k}{friend} \PYG{n}{istream} \PYG{o}{\PYGZam{}}\PYG{k}{operator}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{n}{istream} \PYG{o}{\PYGZam{}}\PYG{n}{is}\PYG{p}{,} \PYG{n}{SectionOption} \PYG{o}{\PYGZam{}}\PYG{n}{k}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}

\PYG{k}{class} \PYG{n+nc}{ConfigOption}
\PYG{p}{\PYGZob{}}
\PYG{k}{private}\PYG{o}{:}
    \PYG{n}{string} \PYG{n}{configfile}\PYG{p}{;}
    \PYG{k+kt}{bool} \PYG{n}{bConfig}\PYG{p}{;}
    \PYG{k+kt}{bool} \PYG{n}{bMain}\PYG{p}{;}  \PYG{c+c1}{// is true if this is the main command line importSpatialParameters (and therefore we want to delete the first few}
    \PYG{c+c1}{// command line options)}
    \PYG{k+kt}{bool} \PYG{n}{bFullParse}\PYG{p}{;}  \PYG{c+c1}{// if this is true, each KeyOption structure will be returned after each read.}
    \PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{n}{SectionOption}\PYG{o}{\PYGZgt{}} \PYG{n}{configs}\PYG{p}{;}  \PYG{c+c1}{// all config data if full parse is true.}
\PYG{k}{public}\PYG{o}{:}
    \PYG{n}{ConfigOption}\PYG{p}{(}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{bConfig} \PYG{o}{=} \PYG{n+nb}{false}\PYG{p}{;}
        \PYG{n}{configfile} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{none}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
        \PYG{n}{bMain} \PYG{o}{=} \PYG{n+nb}{false}\PYG{p}{;}
        \PYG{n}{bFullParse} \PYG{o}{=} \PYG{n+nb}{false}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{k+kt}{void} \PYG{n}{setConfig}\PYG{p}{(}\PYG{k}{const} \PYG{n}{string} \PYG{o}{\PYGZam{}}\PYG{n}{file}\PYG{p}{,} \PYG{k+kt}{bool} \PYG{n}{main}\PYG{p}{,} \PYG{k+kt}{bool} \PYG{n}{full\PYGZus{}parse} \PYG{o}{=} \PYG{n+nb}{false}\PYG{p}{)}\PYG{p}{;}

    \PYG{k+kt}{void} \PYG{n+nf}{parseConfig}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

    \PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{n}{SectionOption}\PYG{o}{\PYGZgt{}} \PYG{n}{getSectionOptions}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

    \PYG{k+kt}{void} \PYG{n+nf}{setSectionOption}\PYG{p}{(}\PYG{n}{string} \PYG{n}{section}\PYG{p}{,} \PYG{n}{string} \PYG{n}{reference}\PYG{p}{,} \PYG{n}{string} \PYG{n}{value}\PYG{p}{)}\PYG{p}{;}

    \PYG{n}{SectionOption} \PYG{k}{operator}\PYG{p}{[}\PYG{p}{]}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{index}\PYG{p}{)}\PYG{p}{;}

    \PYG{k+kt}{unsigned} \PYG{k+kt}{int} \PYG{n+nf}{getSectionOptionsSize}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

    \PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{n}{string}\PYG{o}{\PYGZgt{}} \PYG{n}{getSections}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

    \PYG{k+kt}{bool} \PYG{n+nf}{hasSection}\PYG{p}{(}\PYG{k}{const} \PYG{n}{string} \PYG{o}{\PYGZam{}}\PYG{n}{sec}\PYG{p}{)}\PYG{p}{;}

    \PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{n}{string}\PYG{o}{\PYGZgt{}} \PYG{n}{getSectionValues}\PYG{p}{(}\PYG{n}{string} \PYG{n}{sec}\PYG{p}{)}\PYG{p}{;}

    \PYG{n}{string} \PYG{n+nf}{getSectionOptions}\PYG{p}{(}\PYG{n}{string} \PYG{n}{section}\PYG{p}{,} \PYG{n}{string} \PYG{n}{ref}\PYG{p}{)}\PYG{p}{;}

    \PYG{n}{string} \PYG{n+nf}{getSectionOptions}\PYG{p}{(}\PYG{n}{string} \PYG{n}{section}\PYG{p}{,} \PYG{n}{string} \PYG{n}{ref}\PYG{p}{,} \PYG{n}{string} \PYG{n}{def}\PYG{p}{)}\PYG{p}{;}

    \PYG{k+kt}{int} \PYG{n+nf}{importConfig}\PYG{p}{(}\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{n}{string}\PYG{o}{\PYGZgt{}} \PYG{o}{\PYGZam{}}\PYG{n}{comargs}\PYG{p}{)}\PYG{p}{;}

    \PYG{k}{friend} \PYG{n}{ostream} \PYG{o}{\PYGZam{}}\PYG{k}{operator}\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{p}{(}\PYG{n}{ostream} \PYG{o}{\PYGZam{}}\PYG{n}{os}\PYG{p}{,} \PYG{k}{const} \PYG{n}{ConfigOption} \PYG{o}{\PYGZam{}}\PYG{n}{c}\PYG{p}{)}\PYG{p}{;}

    \PYG{k}{friend} \PYG{n}{istream} \PYG{o}{\PYGZam{}}\PYG{k}{operator}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{n}{istream} \PYG{o}{\PYGZam{}}\PYG{n}{is}\PYG{p}{,} \PYG{n}{ConfigOption} \PYG{o}{\PYGZam{}}\PYG{n}{c}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}

\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif}
\end{sphinxVerbatim}


\subsubsection{Detailed Description}
\label{\detokenize{api/file_necsim_ConfigFileParser.h:detailed-description}}
Sam Thompson
31/08/2016
Contact: \sphinxhref{mailto:samuel.thompson14@imperial.ac.uk}{samuel.thompson14@imperial.ac.uk} or \sphinxhref{mailto:thompsonsed@gmail.com}{thompsonsed@gmail.com} BSD-3 Licence.


\subsubsection{Includes}
\label{\detokenize{api/file_necsim_ConfigFileParser.h:includes}}\begin{itemize}
\item {} 
\sphinxcode{algorithm}

\item {} 
\sphinxcode{cctype}

\item {} 
\sphinxcode{cmath}

\item {} 
\sphinxcode{cstring}

\item {} 
\sphinxcode{fstream}

\item {} 
\sphinxcode{iostream}

\item {} 
\sphinxcode{sstream}

\item {} 
\sphinxcode{stdexcept}

\item {} 
\sphinxcode{string}

\item {} 
\sphinxcode{unistd.h}

\item {} 
\sphinxcode{vector}

\end{itemize}


\subsubsection{Included By}
\label{\detokenize{api/file_necsim_ConfigFileParser.h:included-by}}\begin{itemize}
\item {} 
{\hyperref[\detokenize{api/file_necsim_SimParameters.h:file-necsim-simparameters-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File SimParameters.h}}}}

\item {} 
{\hyperref[\detokenize{api/file_necsim_ConfigFileParser.cpp:file-necsim-configfileparser-cpp}]{\sphinxcrossref{\DUrole{std,std-ref}{File ConfigFileParser.cpp}}}}

\end{itemize}


\subsubsection{Classes}
\label{\detokenize{api/file_necsim_ConfigFileParser.h:classes}}\begin{itemize}
\item {} 
{\hyperref[\detokenize{api/struct_SectionOption:struct-sectionoption}]{\sphinxcrossref{\DUrole{std,std-ref}{Struct SectionOption}}}}

\item {} 
{\hyperref[\detokenize{api/class_ConfigOption:class-configoption}]{\sphinxcrossref{\DUrole{std,std-ref}{Class ConfigOption}}}}

\end{itemize}


\subsubsection{Functions}
\label{\detokenize{api/file_necsim_ConfigFileParser.h:functions}}\begin{itemize}
\item {} 
{\hyperref[\detokenize{api/function_importArgs:function-importargs}]{\sphinxcrossref{\DUrole{std,std-ref}{Function importArgs}}}}

\end{itemize}


\subsection{File CustomExceptions.h}
\label{\detokenize{api/file_necsim_CustomExceptions.h:file-customexceptions-h}}\label{\detokenize{api/file_necsim_CustomExceptions.h:file-necsim-customexceptions-h}}\label{\detokenize{api/file_necsim_CustomExceptions.h::doc}}
Contains the various exceptions used by NECSim.

\begin{sphinxShadowBox}
\sphinxstyletopictitle{Contents}
\begin{itemize}
\item {} 
\phantomsection\label{\detokenize{api/file_necsim_CustomExceptions.h:id1}}{\hyperref[\detokenize{api/file_necsim_CustomExceptions.h:definition-necsim-customexceptions-h}]{\sphinxcrossref{Definition (\sphinxcode{necsim/CustomExceptions.h})}}}

\item {} 
\phantomsection\label{\detokenize{api/file_necsim_CustomExceptions.h:id2}}{\hyperref[\detokenize{api/file_necsim_CustomExceptions.h:detailed-description}]{\sphinxcrossref{Detailed Description}}}

\item {} 
\phantomsection\label{\detokenize{api/file_necsim_CustomExceptions.h:id3}}{\hyperref[\detokenize{api/file_necsim_CustomExceptions.h:includes}]{\sphinxcrossref{Includes}}}

\item {} 
\phantomsection\label{\detokenize{api/file_necsim_CustomExceptions.h:id4}}{\hyperref[\detokenize{api/file_necsim_CustomExceptions.h:included-by}]{\sphinxcrossref{Included By}}}

\item {} 
\phantomsection\label{\detokenize{api/file_necsim_CustomExceptions.h:id5}}{\hyperref[\detokenize{api/file_necsim_CustomExceptions.h:classes}]{\sphinxcrossref{Classes}}}

\end{itemize}
\end{sphinxShadowBox}


\subsubsection{Definition (\sphinxstyleliteralintitle{necsim/CustomExceptions.h})}
\label{\detokenize{api/file_necsim_CustomExceptions.h:definition-necsim-customexceptions-h}}

\paragraph{Program Listing for File CustomExceptions.h}
\label{\detokenize{api/program_listing_file_necsim_CustomExceptions.h:program-listing-file-necsim-customexceptions-h}}\label{\detokenize{api/program_listing_file_necsim_CustomExceptions.h::doc}}\label{\detokenize{api/program_listing_file_necsim_CustomExceptions.h:program-listing-for-file-customexceptions-h}}\begin{itemize}
\item {} 
Return to documentation for {\hyperref[\detokenize{api/file_necsim_CustomExceptions.h:file-necsim-customexceptions-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File CustomExceptions.h}}}}

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{//This file is part of NECSim project which is released under BSD\PYGZhy{}3 license.}
\PYG{c+c1}{//See file **LICENSE.txt** or visit https://opensource.org/licenses/BSD\PYGZhy{}3\PYGZhy{}Clause) for full license details.}
\PYG{c+c1}{// Author: Samuel Thompson}
\PYG{c+c1}{// Contact: samuel.thompson14@imperial.ac.uk or thompsonsed@gmail.com}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifndef EXCEPTION}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define EXCEPTION}

\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}stdexcept\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZdq{}Logging.h\PYGZdq{}}

\PYG{k}{using} \PYG{k}{namespace} \PYG{n}{std}\PYG{p}{;}


\PYG{k}{struct} \PYG{n+nl}{FatalException} \PYG{p}{:} \PYG{k}{public} \PYG{n}{runtime\PYGZus{}error}
\PYG{p}{\PYGZob{}}
    \PYG{n}{FatalException}\PYG{p}{(}\PYG{p}{)} \PYG{o}{:} \PYG{n}{runtime\PYGZus{}error}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Fatal exception thrown at run time, quitting program. }\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}

    \PYG{k}{explicit} \PYG{n}{FatalException}\PYG{p}{(}\PYG{n}{string} \PYG{n}{msg}\PYG{p}{)} \PYG{o}{:} \PYG{n}{runtime\PYGZus{}error}\PYG{p}{(}\PYG{n}{msg}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifdef DEBUG}
        \PYG{n}{writeLog}\PYG{p}{(}\PYG{l+m+mi}{50}\PYG{p}{,} \PYG{n}{msg}\PYG{p}{)}\PYG{p}{;}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif }\PYG{c+c1}{//DEBUG}
    \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}

\PYG{k}{struct} \PYG{n+nl}{ConfigException} \PYG{p}{:} \PYG{k}{public} \PYG{n}{FatalException}
\PYG{p}{\PYGZob{}}
    \PYG{n}{ConfigException}\PYG{p}{(}\PYG{p}{)} \PYG{o}{:} \PYG{n}{FatalException}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Exception thrown at run time in config: }\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}

    \PYG{k}{explicit} \PYG{n}{ConfigException}\PYG{p}{(}\PYG{n}{string} \PYG{n}{msg}\PYG{p}{)} \PYG{o}{:} \PYG{n}{FatalException}\PYG{p}{(}\PYG{n}{msg}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}


\PYG{k}{struct} \PYG{n+nl}{SpeciesException} \PYG{p}{:} \PYG{k}{public} \PYG{n}{FatalException}
\PYG{p}{\PYGZob{}}
    \PYG{n}{SpeciesException}\PYG{p}{(}\PYG{p}{)} \PYG{o}{:} \PYG{n}{FatalException}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Exception thrown at run time in SpeciationCounter: }\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}

    \PYG{k}{explicit} \PYG{n}{SpeciesException}\PYG{p}{(}\PYG{n}{string} \PYG{n}{msg}\PYG{p}{)} \PYG{o}{:} \PYG{n}{FatalException}\PYG{p}{(}\PYG{n}{msg}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}

\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif}
\end{sphinxVerbatim}


\subsubsection{Detailed Description}
\label{\detokenize{api/file_necsim_CustomExceptions.h:detailed-description}}
Samuel Thompson
BSD-3 Licence.


\subsubsection{Includes}
\label{\detokenize{api/file_necsim_CustomExceptions.h:includes}}\begin{itemize}
\item {} 
\sphinxcode{Logging.h} ({\hyperref[\detokenize{api/file_necsim_Logging.h:file-necsim-logging-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File Logging.h}}}})

\item {} 
\sphinxcode{stdexcept}

\end{itemize}


\subsubsection{Included By}
\label{\detokenize{api/file_necsim_CustomExceptions.h:included-by}}\begin{itemize}
\item {} 
{\hyperref[\detokenize{api/file_necsim_LogFile.h:file-necsim-logfile-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File LogFile.h}}}}

\item {} 
{\hyperref[\detokenize{api/file_necsim_ConfigFileParser.cpp:file-necsim-configfileparser-cpp}]{\sphinxcrossref{\DUrole{std,std-ref}{File ConfigFileParser.cpp}}}}

\item {} 
{\hyperref[\detokenize{api/file_necsim_DispersalCoordinator.cpp:file-necsim-dispersalcoordinator-cpp}]{\sphinxcrossref{\DUrole{std,std-ref}{File DispersalCoordinator.cpp}}}}

\item {} 
{\hyperref[\detokenize{api/file_necsim_Filesystem.cpp:file-necsim-filesystem-cpp}]{\sphinxcrossref{\DUrole{std,std-ref}{File Filesystem.cpp}}}}

\item {} 
{\hyperref[\detokenize{api/file_necsim_Tree.h:file-necsim-tree-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File Tree.h}}}}

\item {} 
{\hyperref[\detokenize{api/file_necsim_SimulationTemplates.h:file-necsim-simulationtemplates-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File SimulationTemplates.h}}}}

\item {} 
{\hyperref[\detokenize{api/file_necsim_Map.cpp:file-necsim-map-cpp}]{\sphinxcrossref{\DUrole{std,std-ref}{File Map.cpp}}}}

\item {} 
{\hyperref[\detokenize{api/file_necsim_SimulateDispersal.cpp:file-necsim-simulatedispersal-cpp}]{\sphinxcrossref{\DUrole{std,std-ref}{File SimulateDispersal.cpp}}}}

\end{itemize}


\subsubsection{Classes}
\label{\detokenize{api/file_necsim_CustomExceptions.h:classes}}\begin{itemize}
\item {} 
{\hyperref[\detokenize{api/struct_ConfigException:struct-configexception}]{\sphinxcrossref{\DUrole{std,std-ref}{Struct ConfigException}}}}

\item {} 
{\hyperref[\detokenize{api/struct_FatalException:struct-fatalexception}]{\sphinxcrossref{\DUrole{std,std-ref}{Struct FatalException}}}}

\item {} 
{\hyperref[\detokenize{api/struct_SpeciesException:struct-speciesexception}]{\sphinxcrossref{\DUrole{std,std-ref}{Struct SpeciesException}}}}

\end{itemize}


\subsection{File DataMask.cpp}
\label{\detokenize{api/file_necsim_DataMask.cpp:file-necsim-datamask-cpp}}\label{\detokenize{api/file_necsim_DataMask.cpp:file-datamask-cpp}}\label{\detokenize{api/file_necsim_DataMask.cpp::doc}}
Contains the {\hyperref[\detokenize{api/class_DataMask:class-datamask}]{\sphinxcrossref{\DUrole{std,std-ref}{Class DataMask}}}} class for describing the spatial sampling pattern on a landscape.

\begin{sphinxShadowBox}
\sphinxstyletopictitle{Contents}
\begin{itemize}
\item {} 
\phantomsection\label{\detokenize{api/file_necsim_DataMask.cpp:id1}}{\hyperref[\detokenize{api/file_necsim_DataMask.cpp:definition-necsim-datamask-cpp}]{\sphinxcrossref{Definition (\sphinxcode{necsim/DataMask.cpp})}}}

\item {} 
\phantomsection\label{\detokenize{api/file_necsim_DataMask.cpp:id2}}{\hyperref[\detokenize{api/file_necsim_DataMask.cpp:detailed-description}]{\sphinxcrossref{Detailed Description}}}

\item {} 
\phantomsection\label{\detokenize{api/file_necsim_DataMask.cpp:id3}}{\hyperref[\detokenize{api/file_necsim_DataMask.cpp:includes}]{\sphinxcrossref{Includes}}}

\end{itemize}
\end{sphinxShadowBox}


\subsubsection{Definition (\sphinxstyleliteralintitle{necsim/DataMask.cpp})}
\label{\detokenize{api/file_necsim_DataMask.cpp:definition-necsim-datamask-cpp}}

\paragraph{Program Listing for File DataMask.cpp}
\label{\detokenize{api/program_listing_file_necsim_DataMask.cpp:program-listing-file-necsim-datamask-cpp}}\label{\detokenize{api/program_listing_file_necsim_DataMask.cpp:program-listing-for-file-datamask-cpp}}\label{\detokenize{api/program_listing_file_necsim_DataMask.cpp::doc}}\begin{itemize}
\item {} 
Return to documentation for {\hyperref[\detokenize{api/file_necsim_DataMask.cpp:file-necsim-datamask-cpp}]{\sphinxcrossref{\DUrole{std,std-ref}{File DataMask.cpp}}}}

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZdq{}DataMask.h\PYGZdq{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZdq{}Map.h\PYGZdq{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZdq{}Logging.h\PYGZdq{}}

\PYG{n}{DataMask}\PYG{o}{:}\PYG{o}{:}\PYG{n}{DataMask}\PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{n}{bDefault} \PYG{o}{=} \PYG{n+nb}{true}\PYG{p}{;}
    \PYG{n}{x\PYGZus{}dim} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
    \PYG{n}{y\PYGZus{}dim} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
    \PYG{n}{x\PYGZus{}offset} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
    \PYG{n}{y\PYGZus{}offset} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
    \PYG{n}{mask\PYGZus{}x\PYGZus{}dim} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
    \PYG{n}{mask\PYGZus{}y\PYGZus{}dim} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
    \PYG{n}{getProportionfptr} \PYG{o}{=} \PYG{o}{\PYGZam{}}\PYG{n}{DataMask}\PYG{o}{:}\PYG{o}{:}\PYG{n}{getBoolProportion}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{bool} \PYG{n}{DataMask}\PYG{o}{:}\PYG{o}{:}\PYG{n}{getDefault}\PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k}{return} \PYG{n}{bDefault}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{bool} \PYG{n}{DataMask}\PYG{o}{:}\PYG{o}{:}\PYG{n}{setup}\PYG{p}{(}\PYG{k}{const} \PYG{n}{string} \PYG{o}{\PYGZam{}}\PYG{n}{sample\PYGZus{}mask\PYGZus{}file}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{x\PYGZus{}in}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{y\PYGZus{}in}\PYG{p}{,}
                     \PYG{k}{const} \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{mask\PYGZus{}x\PYGZus{}in}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{mask\PYGZus{}y\PYGZus{}in}\PYG{p}{,}
                     \PYG{k}{const} \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{x\PYGZus{}offset\PYGZus{}in}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{y\PYGZus{}offset\PYGZus{}in}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifdef DEBUG}
    \PYG{k}{if}\PYG{p}{(}\PYG{p}{(}\PYG{n}{x\PYGZus{}in} \PYG{o}{\PYGZgt{}} \PYG{n}{mask\PYGZus{}x\PYGZus{}in} \PYG{o}{\textbar{}}\PYG{o}{\textbar{}} \PYG{n}{y\PYGZus{}in} \PYG{o}{\PYGZgt{}} \PYG{n}{mask\PYGZus{}y\PYGZus{}in}\PYG{p}{)} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{o}{!}\PYG{n}{bDefault}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{writeLog}\PYG{p}{(}\PYG{l+m+mi}{50}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Grid size: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{+} \PYG{n}{to\PYGZus{}string}\PYG{p}{(}\PYG{n}{x\PYGZus{}in}\PYG{p}{)} \PYG{o}{+} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{, }\PYG{l+s}{\PYGZdq{}} \PYG{o}{+} \PYG{n}{to\PYGZus{}string}\PYG{p}{(}\PYG{n}{y\PYGZus{}in}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{writeLog}\PYG{p}{(}\PYG{l+m+mi}{50}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Sample mask size: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{+} \PYG{n}{to\PYGZus{}string}\PYG{p}{(}\PYG{n}{mask\PYGZus{}x\PYGZus{}in}\PYG{p}{)} \PYG{o}{+} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{, }\PYG{l+s}{\PYGZdq{}} \PYG{o}{+} \PYG{n}{to\PYGZus{}string}\PYG{p}{(}\PYG{n}{mask\PYGZus{}y\PYGZus{}in}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{throw} \PYG{n+nf}{FatalException}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Datamask dimensions do not make sense}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif }\PYG{c+c1}{// DEBUG}
    \PYG{n}{inputfile} \PYG{o}{=} \PYG{n}{sample\PYGZus{}mask\PYGZus{}file}\PYG{p}{;}
    \PYG{n}{x\PYGZus{}dim} \PYG{o}{=} \PYG{n}{x\PYGZus{}in}\PYG{p}{;}
    \PYG{n}{y\PYGZus{}dim} \PYG{o}{=} \PYG{n}{y\PYGZus{}in}\PYG{p}{;}
    \PYG{n}{mask\PYGZus{}x\PYGZus{}dim} \PYG{o}{=} \PYG{n}{mask\PYGZus{}x\PYGZus{}in}\PYG{p}{;}
    \PYG{n}{mask\PYGZus{}y\PYGZus{}dim}  \PYG{o}{=} \PYG{n}{mask\PYGZus{}y\PYGZus{}in}\PYG{p}{;}
    \PYG{n}{x\PYGZus{}offset} \PYG{o}{=} \PYG{n}{x\PYGZus{}offset\PYGZus{}in}\PYG{p}{;}
    \PYG{n}{y\PYGZus{}offset} \PYG{o}{=} \PYG{n}{y\PYGZus{}offset\PYGZus{}in}\PYG{p}{;}
    \PYG{k}{if}\PYG{p}{(}\PYG{n}{inputfile} \PYG{o}{=}\PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{null}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\textbar{}}\PYG{o}{\textbar{}} \PYG{n}{inputfile} \PYG{o}{=}\PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{none}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{bDefault} \PYG{o}{=} \PYG{n+nb}{true}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{else}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{bDefault} \PYG{o}{=} \PYG{n+nb}{false}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{return} \PYG{n}{bDefault}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{void} \PYG{n}{DataMask}\PYG{o}{:}\PYG{o}{:}\PYG{n}{importBooleanMask}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{xdim}\PYG{p}{,} \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{ydim}\PYG{p}{,} \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{mask\PYGZus{}xdim}\PYG{p}{,}
                                 \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{mask\PYGZus{}ydim}\PYG{p}{,}
                                 \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{xoffset}\PYG{p}{,} \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{yoffset}\PYG{p}{,} \PYG{n}{string} \PYG{n}{inputfile}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k}{if}\PYG{p}{(}\PYG{o}{!}\PYG{n}{setup}\PYG{p}{(}\PYG{n}{inputfile}\PYG{p}{,} \PYG{n}{xdim}\PYG{p}{,} \PYG{n}{ydim}\PYG{p}{,} \PYG{n}{mask\PYGZus{}xdim}\PYG{p}{,} \PYG{n}{mask\PYGZus{}ydim}\PYG{p}{,} \PYG{n}{xoffset}\PYG{p}{,} \PYG{n}{yoffset}\PYG{p}{)}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{doImport}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{void} \PYG{n}{DataMask}\PYG{o}{:}\PYG{o}{:}\PYG{n}{doImport}\PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{n}{sample\PYGZus{}mask}\PYG{p}{.}\PYG{n}{SetSize}\PYG{p}{(}\PYG{n}{mask\PYGZus{}y\PYGZus{}dim}\PYG{p}{,} \PYG{n}{mask\PYGZus{}x\PYGZus{}dim}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{sample\PYGZus{}mask}\PYG{p}{.}\PYG{n}{import}\PYG{p}{(}\PYG{n}{inputfile}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{getProportionfptr} \PYG{o}{=} \PYG{o}{\PYGZam{}}\PYG{n}{DataMask}\PYG{o}{:}\PYG{o}{:}\PYG{n}{getBoolProportion}\PYG{p}{;}

\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{void} \PYG{n}{DataMask}\PYG{o}{:}\PYG{o}{:}\PYG{n}{importSampleMask}\PYG{p}{(}\PYG{n}{SimParameters} \PYG{o}{\PYGZam{}}\PYG{n}{mapvarin}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k}{if}\PYG{p}{(}\PYG{o}{!}\PYG{n}{setup}\PYG{p}{(}\PYG{n}{mapvarin}\PYG{p}{.}\PYG{n}{sample\PYGZus{}mask\PYGZus{}file}\PYG{p}{,} \PYG{n}{mapvarin}\PYG{p}{.}\PYG{n}{grid\PYGZus{}x\PYGZus{}size}\PYG{p}{,} \PYG{n}{mapvarin}\PYG{p}{.}\PYG{n}{grid\PYGZus{}y\PYGZus{}size}\PYG{p}{,}
             \PYG{n}{mapvarin}\PYG{p}{.}\PYG{n}{sample\PYGZus{}x\PYGZus{}size}\PYG{p}{,} \PYG{n}{mapvarin}\PYG{p}{.}\PYG{n}{sample\PYGZus{}y\PYGZus{}size}\PYG{p}{,} \PYG{n}{mapvarin}\PYG{p}{.}\PYG{n}{sample\PYGZus{}x\PYGZus{}offset}\PYG{p}{,} \PYG{n}{mapvarin}\PYG{p}{.}\PYG{n}{sample\PYGZus{}y\PYGZus{}offset}\PYG{p}{)}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{mapvarin}\PYG{p}{.}\PYG{n}{uses\PYGZus{}spatial\PYGZus{}sampling}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifdef DEBUG}
            \PYG{n}{writeLog}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Using spatial sampling.}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
            \PYG{n}{writeLog}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Mask dimensions: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{+} \PYG{n}{to\PYGZus{}string}\PYG{p}{(}\PYG{n}{mask\PYGZus{}x\PYGZus{}dim}\PYG{p}{)} \PYG{o}{+} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{, }\PYG{l+s}{\PYGZdq{}} \PYG{o}{+} \PYG{n}{to\PYGZus{}string}\PYG{p}{(}\PYG{n}{mask\PYGZus{}y\PYGZus{}dim}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif }\PYG{c+c1}{// DEBUG}
            \PYG{n}{sample\PYGZus{}mask\PYGZus{}exact}\PYG{p}{.}\PYG{n}{SetSize}\PYG{p}{(}\PYG{n}{mask\PYGZus{}y\PYGZus{}dim}\PYG{p}{,} \PYG{n}{mask\PYGZus{}x\PYGZus{}dim}\PYG{p}{)}\PYG{p}{;}
            \PYG{n}{sample\PYGZus{}mask\PYGZus{}exact}\PYG{p}{.}\PYG{n}{import}\PYG{p}{(}\PYG{n}{inputfile}\PYG{p}{)}\PYG{p}{;}
            \PYG{n}{getProportionfptr} \PYG{o}{=} \PYG{o}{\PYGZam{}}\PYG{n}{DataMask}\PYG{o}{:}\PYG{o}{:}\PYG{n}{getSampleProportion}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{else}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{doImport}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{else}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{mapvarin}\PYG{p}{.}\PYG{n}{uses\PYGZus{}spatial\PYGZus{}sampling}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{c+c1}{// This could perhaps be a warning, but I\PYGZsq{}d prefer to have the warning/prohibit potential in python}
            \PYG{c+c1}{// and throw a full exception here.}
            \PYG{k}{throw} \PYG{n}{FatalException}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Cannot use a spatial sampling routine when the map file is null.}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{n}{getProportionfptr} \PYG{o}{=} \PYG{o}{\PYGZam{}}\PYG{n}{DataMask}\PYG{o}{:}\PYG{o}{:}\PYG{n}{getNullProportion}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{bool} \PYG{n}{DataMask}\PYG{o}{:}\PYG{o}{:}\PYG{n}{getVal}\PYG{p}{(}\PYG{k}{const} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{x}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{y}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{xwrap}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{ywrap}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k+kt}{long} \PYG{n}{xval} \PYG{o}{=} \PYG{n}{x} \PYG{o}{+} \PYG{p}{(}\PYG{n}{xwrap} \PYG{o}{*} \PYG{n}{x\PYGZus{}dim}\PYG{p}{)} \PYG{o}{+} \PYG{n}{x\PYGZus{}offset}\PYG{p}{;}
    \PYG{k+kt}{long} \PYG{n}{yval} \PYG{o}{=} \PYG{n}{y} \PYG{o}{+} \PYG{p}{(}\PYG{n}{ywrap} \PYG{o}{*} \PYG{n}{y\PYGZus{}dim}\PYG{p}{)} \PYG{o}{+} \PYG{n}{y\PYGZus{}offset}\PYG{p}{;}
    \PYG{k}{if}\PYG{p}{(}\PYG{n}{bDefault}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{return} \PYG{n+nb}{true}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifdef DEBUG}
    \PYG{k}{if}\PYG{p}{(}\PYG{n}{xval} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{0} \PYG{o}{\textbar{}}\PYG{o}{\textbar{}} \PYG{n}{xval} \PYG{o}{\PYGZgt{}}\PYG{o}{=} \PYG{p}{(}\PYG{k+kt}{long}\PYG{p}{)} \PYG{n}{mask\PYGZus{}x\PYGZus{}dim} \PYG{o}{\textbar{}}\PYG{o}{\textbar{}} \PYG{n}{yval} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{0} \PYG{o}{\textbar{}}\PYG{o}{\textbar{}} \PYG{n}{yval} \PYG{o}{\PYGZgt{}}\PYG{o}{=} \PYG{p}{(}\PYG{k+kt}{long}\PYG{p}{)} \PYG{n}{mask\PYGZus{}y\PYGZus{}dim}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{stringstream} \PYG{n}{ss}\PYG{p}{;}
        \PYG{n}{ss} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Get value on samplemask requested for non index.}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
        \PYG{n}{ss} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{x, y: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{x} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{, }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{y} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
        \PYG{n}{ss} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{dimensions x,y: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{mask\PYGZus{}x\PYGZus{}dim} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{, }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{mask\PYGZus{}y\PYGZus{}dim} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
        \PYG{n}{ss} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{x, y wrap: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{xwrap} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{, }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{ywrap} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
        \PYG{n}{ss} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{xval, yval: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{xval} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{, }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{yval} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
        \PYG{n}{ss} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{offsets x, y: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{x\PYGZus{}offset} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{, }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{y\PYGZus{}offset} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
        \PYG{n}{writeLog}\PYG{p}{(}\PYG{l+m+mi}{50}\PYG{p}{,} \PYG{n}{ss}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{ss}\PYG{p}{.}\PYG{n}{str}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Get value on samplemask requested for non index.}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{throw} \PYG{n+nf}{out\PYGZus{}of\PYGZus{}range}\PYG{p}{(}\PYG{n}{ss}\PYG{p}{.}\PYG{n}{str}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif}
    \PYG{k}{return} \PYG{n}{sample\PYGZus{}mask}\PYG{p}{[}\PYG{n}{yval}\PYG{p}{]}\PYG{p}{[}\PYG{n}{xval}\PYG{p}{]}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}


\PYG{k+kt}{double} \PYG{n}{DataMask}\PYG{o}{:}\PYG{o}{:}\PYG{n}{getNullProportion}\PYG{p}{(}\PYG{k}{const} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{x}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{y}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{xwrap}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{ywrap}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k}{return} \PYG{l+m+mf}{1.0}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{double} \PYG{n}{DataMask}\PYG{o}{:}\PYG{o}{:}\PYG{n}{getBoolProportion}\PYG{p}{(}\PYG{k}{const} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{x}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{y}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{xwrap}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{ywrap}\PYG{p}{)}
\PYG{p}{\PYGZob{}}

    \PYG{k}{if}\PYG{p}{(}\PYG{n}{getVal}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,} \PYG{n}{y}\PYG{p}{,} \PYG{n}{xwrap}\PYG{p}{,} \PYG{n}{ywrap}\PYG{p}{)}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{return} \PYG{l+m+mf}{1.0}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{else}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{return} \PYG{l+m+mf}{0.0}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{double} \PYG{n}{DataMask}\PYG{o}{:}\PYG{o}{:}\PYG{n}{getSampleProportion}\PYG{p}{(}\PYG{k}{const} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{x}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{y}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{xwrap}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{ywrap}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifdef DEBUG}
    \PYG{k}{if}\PYG{p}{(}\PYG{n}{bDefault} \PYG{o}{\textbar{}}\PYG{o}{\textbar{}} \PYG{n}{sample\PYGZus{}mask\PYGZus{}exact}\PYG{p}{.}\PYG{n}{GetCols}\PYG{p}{(}\PYG{p}{)} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{throw} \PYG{n}{out\PYGZus{}of\PYGZus{}range}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Cannot get the exact value from a samplemask if we are using a null mask, or the }\PYG{l+s}{\PYGZdq{}}
                                   \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{exact samplemask has not been properly imported.}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif }\PYG{c+c1}{// DEBUG}
    \PYG{k+kt}{long} \PYG{n}{xval} \PYG{o}{=} \PYG{n}{x} \PYG{o}{+} \PYG{p}{(}\PYG{n}{xwrap} \PYG{o}{*} \PYG{n}{x\PYGZus{}dim}\PYG{p}{)} \PYG{o}{+} \PYG{n}{x\PYGZus{}offset}\PYG{p}{;}
    \PYG{k+kt}{long} \PYG{n}{yval} \PYG{o}{=} \PYG{n}{y} \PYG{o}{+} \PYG{p}{(}\PYG{n}{ywrap} \PYG{o}{*} \PYG{n}{y\PYGZus{}dim}\PYG{p}{)} \PYG{o}{+} \PYG{n}{y\PYGZus{}offset}\PYG{p}{;}
    \PYG{k}{return} \PYG{n}{sample\PYGZus{}mask\PYGZus{}exact}\PYG{p}{[}\PYG{n}{yval}\PYG{p}{]}\PYG{p}{[}\PYG{n}{xval}\PYG{p}{]}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{double} \PYG{n}{DataMask}\PYG{o}{:}\PYG{o}{:}\PYG{n}{getExactValue}\PYG{p}{(}\PYG{k}{const} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{x}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{y}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{xwrap}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{ywrap}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k}{return} \PYG{p}{(}\PYG{k}{this}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{o}{*}\PYG{n}{getProportionfptr}\PYG{p}{)}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,} \PYG{n}{y}\PYG{p}{,} \PYG{n}{xwrap}\PYG{p}{,} \PYG{n}{ywrap}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{void} \PYG{n}{DataMask}\PYG{o}{:}\PYG{o}{:}\PYG{n}{convertBoolean}\PYG{p}{(}\PYG{n}{Map} \PYG{o}{\PYGZam{}}\PYG{n}{map1}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{double} \PYG{o}{\PYGZam{}}\PYG{n}{deme\PYGZus{}sampling}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{double} \PYG{o}{\PYGZam{}}\PYG{n}{generation}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{c+c1}{// Clear the old boolean object and set the new size}
    \PYG{n}{sample\PYGZus{}mask}\PYG{p}{.}\PYG{n}{SetSize}\PYG{p}{(}\PYG{n}{y\PYGZus{}dim}\PYG{p}{,} \PYG{n}{x\PYGZus{}dim}\PYG{p}{)}\PYG{p}{;}
    \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{y} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{y} \PYG{o}{\PYGZlt{}} \PYG{n}{y\PYGZus{}dim}\PYG{p}{;} \PYG{n}{y}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{x} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{x} \PYG{o}{\PYGZlt{}} \PYG{n}{x\PYGZus{}dim}\PYG{p}{;} \PYG{n}{x}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{k+kt}{long} \PYG{n}{tmp\PYGZus{}x} \PYG{o}{=} \PYG{n}{x}\PYG{p}{;}
            \PYG{k+kt}{long} \PYG{n}{tmp\PYGZus{}y} \PYG{o}{=} \PYG{n}{y}\PYG{p}{;}
            \PYG{k+kt}{long} \PYG{n}{tmp\PYGZus{}xwrap} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
            \PYG{k+kt}{long} \PYG{n}{tmp\PYGZus{}ywrap} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
            \PYG{n}{recalculate\PYGZus{}coordinates}\PYG{p}{(}\PYG{n}{tmp\PYGZus{}x}\PYG{p}{,} \PYG{n}{tmp\PYGZus{}y}\PYG{p}{,} \PYG{n}{tmp\PYGZus{}xwrap}\PYG{p}{,} \PYG{n}{tmp\PYGZus{}ywrap}\PYG{p}{)}\PYG{p}{;}
            \PYG{k+kt}{double} \PYG{n}{density} \PYG{o}{=} \PYG{n}{map1}\PYG{p}{.}\PYG{n}{getVal}\PYG{p}{(}\PYG{n}{tmp\PYGZus{}x}\PYG{p}{,} \PYG{n}{tmp\PYGZus{}y}\PYG{p}{,} \PYG{n}{tmp\PYGZus{}xwrap}\PYG{p}{,} \PYG{n}{tmp\PYGZus{}ywrap}\PYG{p}{,} \PYG{n}{generation}\PYG{p}{)} \PYG{o}{*} \PYG{n}{deme\PYGZus{}sampling}\PYG{p}{;}
            \PYG{n}{sample\PYGZus{}mask}\PYG{p}{[}\PYG{n}{y}\PYG{p}{]}\PYG{p}{[}\PYG{n}{x}\PYG{p}{]} \PYG{o}{=} \PYG{n}{density} \PYG{o}{\PYGZgt{}}\PYG{o}{=} \PYG{l+m+mf}{1.0}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
    \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{void} \PYG{n}{DataMask}\PYG{o}{:}\PYG{o}{:}\PYG{n}{clearSpatialMask}\PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{n}{sample\PYGZus{}mask\PYGZus{}exact}\PYG{p}{.}\PYG{n}{SetSize}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{void} \PYG{n}{DataMask}\PYG{o}{:}\PYG{o}{:}\PYG{n}{recalculate\PYGZus{}coordinates}\PYG{p}{(}\PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{x}\PYG{p}{,} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{y}\PYG{p}{,} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{x\PYGZus{}wrap}\PYG{p}{,} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{y\PYGZus{}wrap}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k}{if}\PYG{p}{(}\PYG{o}{!}\PYG{n}{bDefault}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{x\PYGZus{}wrap} \PYG{o}{=} \PYG{p}{(}\PYG{k+kt}{long}\PYG{p}{)}\PYG{p}{(}\PYG{p}{(}\PYG{n}{floor}\PYG{p}{(}\PYG{p}{(}\PYG{n}{x} \PYG{o}{\PYGZhy{}} \PYG{p}{(}\PYG{k+kt}{double}\PYG{p}{)} \PYG{n}{x\PYGZus{}offset}\PYG{p}{)} \PYG{o}{/} \PYG{p}{(}\PYG{k+kt}{double}\PYG{p}{)} \PYG{n}{x\PYGZus{}dim}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{y\PYGZus{}wrap} \PYG{o}{=} \PYG{p}{(}\PYG{k+kt}{long}\PYG{p}{)}\PYG{p}{(}\PYG{p}{(}\PYG{n}{floor}\PYG{p}{(}\PYG{p}{(}\PYG{n}{y} \PYG{o}{\PYGZhy{}} \PYG{p}{(}\PYG{k+kt}{double}\PYG{p}{)} \PYG{n}{y\PYGZus{}offset}\PYG{p}{)} \PYG{o}{/} \PYG{p}{(}\PYG{k+kt}{double}\PYG{p}{)} \PYG{n}{y\PYGZus{}dim}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{x} \PYG{o}{+}\PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{n}{x\PYGZus{}offset} \PYG{o}{\PYGZhy{}} \PYG{p}{(}\PYG{n}{x\PYGZus{}wrap} \PYG{o}{*} \PYG{n}{x\PYGZus{}dim}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{y} \PYG{o}{+}\PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{n}{y\PYGZus{}offset} \PYG{o}{\PYGZhy{}} \PYG{p}{(}\PYG{n}{y\PYGZus{}wrap} \PYG{o}{*} \PYG{n}{y\PYGZus{}dim}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}


\subsubsection{Detailed Description}
\label{\detokenize{api/file_necsim_DataMask.cpp:detailed-description}}
Samuel Thompson
BSD-3 Licence.


\subsubsection{Includes}
\label{\detokenize{api/file_necsim_DataMask.cpp:includes}}\begin{itemize}
\item {} 
\sphinxcode{DataMask.h} ({\hyperref[\detokenize{api/file_necsim_DataMask.h:file-necsim-datamask-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File DataMask.h}}}})

\item {} 
\sphinxcode{Logging.h} ({\hyperref[\detokenize{api/file_necsim_Logging.h:file-necsim-logging-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File Logging.h}}}})

\item {} 
\sphinxcode{Map.h} ({\hyperref[\detokenize{api/file_necsim_Map.h:file-necsim-map-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File Map.h}}}})

\end{itemize}


\subsection{File DataMask.h}
\label{\detokenize{api/file_necsim_DataMask.h:file-necsim-datamask-h}}\label{\detokenize{api/file_necsim_DataMask.h::doc}}\label{\detokenize{api/file_necsim_DataMask.h:file-datamask-h}}
Contains {\hyperref[\detokenize{api/class_DataMask:class-datamask}]{\sphinxcrossref{\DUrole{std,std-ref}{Class DataMask}}}} for describing the spatial sampling pattern on a landscape.

\begin{sphinxShadowBox}
\sphinxstyletopictitle{Contents}
\begin{itemize}
\item {} 
\phantomsection\label{\detokenize{api/file_necsim_DataMask.h:id1}}{\hyperref[\detokenize{api/file_necsim_DataMask.h:definition-necsim-datamask-h}]{\sphinxcrossref{Definition (\sphinxcode{necsim/DataMask.h})}}}

\item {} 
\phantomsection\label{\detokenize{api/file_necsim_DataMask.h:id2}}{\hyperref[\detokenize{api/file_necsim_DataMask.h:detailed-description}]{\sphinxcrossref{Detailed Description}}}

\item {} 
\phantomsection\label{\detokenize{api/file_necsim_DataMask.h:id3}}{\hyperref[\detokenize{api/file_necsim_DataMask.h:includes}]{\sphinxcrossref{Includes}}}

\item {} 
\phantomsection\label{\detokenize{api/file_necsim_DataMask.h:id4}}{\hyperref[\detokenize{api/file_necsim_DataMask.h:included-by}]{\sphinxcrossref{Included By}}}

\item {} 
\phantomsection\label{\detokenize{api/file_necsim_DataMask.h:id5}}{\hyperref[\detokenize{api/file_necsim_DataMask.h:classes}]{\sphinxcrossref{Classes}}}

\end{itemize}
\end{sphinxShadowBox}


\subsubsection{Definition (\sphinxstyleliteralintitle{necsim/DataMask.h})}
\label{\detokenize{api/file_necsim_DataMask.h:definition-necsim-datamask-h}}

\paragraph{Program Listing for File DataMask.h}
\label{\detokenize{api/program_listing_file_necsim_DataMask.h:program-listing-file-necsim-datamask-h}}\label{\detokenize{api/program_listing_file_necsim_DataMask.h::doc}}\label{\detokenize{api/program_listing_file_necsim_DataMask.h:program-listing-for-file-datamask-h}}\begin{itemize}
\item {} 
Return to documentation for {\hyperref[\detokenize{api/file_necsim_DataMask.h:file-necsim-datamask-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File DataMask.h}}}}

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{// This file is part of NECSim project which is released under BSD\PYGZhy{}3 license.}
\PYG{c+c1}{// See file **LICENSE.txt** or visit https://opensource.org/licenses/BSD\PYGZhy{}3\PYGZhy{}Clause) for full license details.}


\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifndef SPECIATIONCOUNTER\PYGZus{}DataMask\PYGZus{}H}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define SPECIATIONCOUNTER\PYGZus{}DataMask\PYGZus{}H}

\PYG{c+c1}{// Forward declaration of map}
\PYG{k}{class} \PYG{n+nc}{Map}\PYG{p}{;}

\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}string\PYGZgt{}}

\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZdq{}Matrix.h\PYGZdq{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZdq{}SimParameters.h\PYGZdq{}}


\PYG{c+c1}{// Class which contains the DataMask object, telling us where to sample from within the habitat map.}
\PYG{k}{class} \PYG{n+nc}{DataMask}
\PYG{p}{\PYGZob{}}
\PYG{k}{protected}\PYG{o}{:}
    \PYG{c+c1}{// the file to read in from}
    \PYG{n}{string} \PYG{n}{inputfile}\PYG{p}{;}
    \PYG{k+kt}{bool} \PYG{n}{bDefault}\PYG{p}{;}
    \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{x\PYGZus{}offset}\PYG{p}{,} \PYG{n}{y\PYGZus{}offset}\PYG{p}{;}
    \PYG{c+c1}{// Stores the size of the grid which is stored as a full species list}
    \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{x\PYGZus{}dim}\PYG{p}{,} \PYG{n}{y\PYGZus{}dim}\PYG{p}{;}
    \PYG{c+c1}{// Stores the size of the samplemask from which spatially sampling is read}
    \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{mask\PYGZus{}x\PYGZus{}dim}\PYG{p}{,} \PYG{n}{mask\PYGZus{}y\PYGZus{}dim}\PYG{p}{;}
    \PYG{c+c1}{// Function pointer for obtaining the proportional sampling from the sample mask.}
    \PYG{k}{typedef} \PYG{n+nf}{double} \PYG{p}{(}\PYG{n}{DataMask}\PYG{o}{:}\PYG{o}{:}\PYG{o}{*}\PYG{n}{fptr}\PYG{p}{)}\PYG{p}{(}\PYG{k}{const} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{x}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{y}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{xwrap}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{ywrap}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{fptr} \PYG{n}{getProportionfptr}\PYG{p}{;}
\PYG{k}{public}\PYG{o}{:}
    \PYG{n}{Matrix}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{bool}\PYG{o}{\PYGZgt{}} \PYG{n}{sample\PYGZus{}mask}\PYG{p}{;}
    \PYG{c+c1}{// Stores the exact values from the input tif file.}
    \PYG{n}{Matrix}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{double}\PYG{o}{\PYGZgt{}} \PYG{n}{sample\PYGZus{}mask\PYGZus{}exact}\PYG{p}{;}
    \PYG{n}{DataMask}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

    \PYG{o}{\PYGZti{}}\PYG{n}{DataMask}\PYG{p}{(}\PYG{p}{)} \PYG{o}{=} \PYG{k}{default}\PYG{p}{;}

    \PYG{k+kt}{bool} \PYG{n+nf}{getDefault}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

    \PYG{k+kt}{bool} \PYG{n+nf}{setup}\PYG{p}{(}\PYG{k}{const} \PYG{n}{string} \PYG{o}{\PYGZam{}}\PYG{n}{sample\PYGZus{}mask\PYGZus{}file}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{x\PYGZus{}in}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{y\PYGZus{}in}\PYG{p}{,}
               \PYG{k}{const} \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{mask\PYGZus{}x\PYGZus{}in}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{mask\PYGZus{}y\PYGZus{}in}\PYG{p}{,}
               \PYG{k}{const} \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{x\PYGZus{}offset\PYGZus{}in}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{y\PYGZus{}offset\PYGZus{}in}\PYG{p}{)}\PYG{p}{;}

    \PYG{k+kt}{void} \PYG{n+nf}{importBooleanMask}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{xdim}\PYG{p}{,} \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{ydim}\PYG{p}{,} \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{mask\PYGZus{}xdim}\PYG{p}{,} \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{mask\PYGZus{}ydim}\PYG{p}{,}
                           \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{xoffset}\PYG{p}{,} \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{yoffset}\PYG{p}{,} \PYG{n}{string} \PYG{n}{inputfile}\PYG{p}{)}\PYG{p}{;}

    \PYG{k+kt}{void} \PYG{n+nf}{doImport}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

    \PYG{k+kt}{void} \PYG{n+nf}{importSampleMask}\PYG{p}{(}\PYG{n}{SimParameters} \PYG{o}{\PYGZam{}}\PYG{n}{mapvarin}\PYG{p}{)}\PYG{p}{;}


    \PYG{k+kt}{bool} \PYG{n+nf}{getVal}\PYG{p}{(}\PYG{k}{const} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{x}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{y}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{xwrap}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{ywrap}\PYG{p}{)}\PYG{p}{;}

    \PYG{k+kt}{double} \PYG{n+nf}{getNullProportion}\PYG{p}{(}\PYG{k}{const} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{x}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{y}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{xwrap}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{ywrap}\PYG{p}{)}\PYG{p}{;}

    \PYG{k+kt}{double} \PYG{n+nf}{getBoolProportion}\PYG{p}{(}\PYG{k}{const} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{x}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{y}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{xwrap}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{ywrap}\PYG{p}{)}\PYG{p}{;}

    \PYG{k+kt}{double} \PYG{n+nf}{getSampleProportion}\PYG{p}{(}\PYG{k}{const} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{x}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{y}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{xwrap}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{ywrap}\PYG{p}{)}\PYG{p}{;}

    \PYG{k+kt}{double} \PYG{n+nf}{getExactValue}\PYG{p}{(}\PYG{k}{const} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{x}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{y}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{xwrap}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{ywrap}\PYG{p}{)}\PYG{p}{;}

    \PYG{k+kt}{void} \PYG{n+nf}{convertBoolean}\PYG{p}{(}\PYG{n}{Map} \PYG{o}{\PYGZam{}}\PYG{n}{map1}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{double} \PYG{o}{\PYGZam{}}\PYG{n}{deme\PYGZus{}sampling}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{double} \PYG{o}{\PYGZam{}}\PYG{n}{generation}\PYG{p}{)}\PYG{p}{;}

    \PYG{k+kt}{void} \PYG{n+nf}{clearSpatialMask}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

    \PYG{k+kt}{void} \PYG{n+nf}{recalculate\PYGZus{}coordinates}\PYG{p}{(}\PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{x}\PYG{p}{,} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{y}\PYG{p}{,} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{x\PYGZus{}wrap}\PYG{p}{,} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{y\PYGZus{}wrap}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}


\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif }\PYG{c+c1}{//SPECIATIONCOUNTER\PYGZus{}DataMask\PYGZus{}H}
\end{sphinxVerbatim}


\subsubsection{Detailed Description}
\label{\detokenize{api/file_necsim_DataMask.h:detailed-description}}
Samuel Thompson
BSD-3 Licence.


\subsubsection{Includes}
\label{\detokenize{api/file_necsim_DataMask.h:includes}}\begin{itemize}
\item {} 
\sphinxcode{Matrix.h} ({\hyperref[\detokenize{api/file_necsim_Matrix.h:file-necsim-matrix-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File Matrix.h}}}})

\item {} 
\sphinxcode{SimParameters.h} ({\hyperref[\detokenize{api/file_necsim_SimParameters.h:file-necsim-simparameters-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File SimParameters.h}}}})

\item {} 
\sphinxcode{string}

\end{itemize}


\subsubsection{Included By}
\label{\detokenize{api/file_necsim_DataMask.h:included-by}}\begin{itemize}
\item {} 
{\hyperref[\detokenize{api/file_necsim_Community.h:file-necsim-community-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File Community.h}}}}

\item {} 
{\hyperref[\detokenize{api/file_necsim_DataMask.cpp:file-necsim-datamask-cpp}]{\sphinxcrossref{\DUrole{std,std-ref}{File DataMask.cpp}}}}

\item {} 
{\hyperref[\detokenize{api/file_necsim_Map.h:file-necsim-map-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File Map.h}}}}

\end{itemize}


\subsubsection{Classes}
\label{\detokenize{api/file_necsim_DataMask.h:classes}}\begin{itemize}
\item {} 
{\hyperref[\detokenize{api/class_DataMask:class-datamask}]{\sphinxcrossref{\DUrole{std,std-ref}{Class DataMask}}}}

\end{itemize}


\subsection{File DataPoint.cpp}
\label{\detokenize{api/file_necsim_DataPoint.cpp:file-necsim-datapoint-cpp}}\label{\detokenize{api/file_necsim_DataPoint.cpp::doc}}\label{\detokenize{api/file_necsim_DataPoint.cpp:file-datapoint-cpp}}
Contains the Datapoint class for storing objects during simulation run time.

\begin{sphinxShadowBox}
\sphinxstyletopictitle{Contents}
\begin{itemize}
\item {} 
\phantomsection\label{\detokenize{api/file_necsim_DataPoint.cpp:id1}}{\hyperref[\detokenize{api/file_necsim_DataPoint.cpp:definition-necsim-datapoint-cpp}]{\sphinxcrossref{Definition (\sphinxcode{necsim/DataPoint.cpp})}}}

\item {} 
\phantomsection\label{\detokenize{api/file_necsim_DataPoint.cpp:id2}}{\hyperref[\detokenize{api/file_necsim_DataPoint.cpp:detailed-description}]{\sphinxcrossref{Detailed Description}}}

\item {} 
\phantomsection\label{\detokenize{api/file_necsim_DataPoint.cpp:id3}}{\hyperref[\detokenize{api/file_necsim_DataPoint.cpp:includes}]{\sphinxcrossref{Includes}}}

\item {} 
\phantomsection\label{\detokenize{api/file_necsim_DataPoint.cpp:id4}}{\hyperref[\detokenize{api/file_necsim_DataPoint.cpp:functions}]{\sphinxcrossref{Functions}}}

\end{itemize}
\end{sphinxShadowBox}


\subsubsection{Definition (\sphinxstyleliteralintitle{necsim/DataPoint.cpp})}
\label{\detokenize{api/file_necsim_DataPoint.cpp:definition-necsim-datapoint-cpp}}

\paragraph{Program Listing for File DataPoint.cpp}
\label{\detokenize{api/program_listing_file_necsim_DataPoint.cpp:program-listing-file-necsim-datapoint-cpp}}\label{\detokenize{api/program_listing_file_necsim_DataPoint.cpp:program-listing-for-file-datapoint-cpp}}\label{\detokenize{api/program_listing_file_necsim_DataPoint.cpp::doc}}\begin{itemize}
\item {} 
Return to documentation for {\hyperref[\detokenize{api/file_necsim_DataPoint.cpp:file-necsim-datapoint-cpp}]{\sphinxcrossref{\DUrole{std,std-ref}{File DataPoint.cpp}}}}

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{//This file is part of NECSim project which is released under BSD\PYGZhy{}3 license.}
\PYG{c+c1}{//See file **LICENSE.txt** or visit https://opensource.org/licenses/BSD\PYGZhy{}3\PYGZhy{}Clause) for full license details.}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZdq{}DataPoint.h\PYGZdq{}}

\PYG{k+kt}{void} \PYG{n}{DataPoint}\PYG{o}{:}\PYG{o}{:}\PYG{n}{setup}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{x}\PYG{p}{,} \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{y}\PYG{p}{,} \PYG{k+kt}{long} \PYG{n}{xwrap\PYGZus{}in}\PYG{p}{,} \PYG{k+kt}{long} \PYG{n}{ywrap\PYGZus{}in}\PYG{p}{,} \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{reference\PYGZus{}in}\PYG{p}{,}
                      \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{list\PYGZus{}position\PYGZus{}in}\PYG{p}{,} \PYG{k+kt}{double} \PYG{n}{min\PYGZus{}max\PYGZus{}in}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{n}{xpos} \PYG{o}{=} \PYG{n}{x}\PYG{p}{;}
    \PYG{n}{ypos} \PYG{o}{=} \PYG{n}{y}\PYG{p}{;}
    \PYG{n}{xwrap} \PYG{o}{=} \PYG{n}{xwrap\PYGZus{}in}\PYG{p}{;}
    \PYG{n}{ywrap} \PYG{o}{=} \PYG{n}{ywrap\PYGZus{}in}\PYG{p}{;}
    \PYG{n}{next\PYGZus{}lineage} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
    \PYG{n}{reference} \PYG{o}{=} \PYG{n}{reference\PYGZus{}in}\PYG{p}{;}
    \PYG{n}{list\PYGZus{}position} \PYG{o}{=} \PYG{n}{list\PYGZus{}position\PYGZus{}in}\PYG{p}{;}
    \PYG{n}{nwrap} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
    \PYG{n}{min\PYGZus{}max} \PYG{o}{=} \PYG{n}{min\PYGZus{}max\PYGZus{}in}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{void} \PYG{n}{DataPoint}\PYG{o}{:}\PYG{o}{:}\PYG{n}{setup}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{reference\PYGZus{}in}\PYG{p}{,} \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{list\PYGZus{}position\PYGZus{}in}\PYG{p}{,} \PYG{k+kt}{double} \PYG{n}{min\PYGZus{}max\PYGZus{}in}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{n}{setup}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{reference\PYGZus{}in}\PYG{p}{,} \PYG{n}{list\PYGZus{}position\PYGZus{}in}\PYG{p}{,} \PYG{n}{min\PYGZus{}max\PYGZus{}in}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{void} \PYG{n}{DataPoint}\PYG{o}{:}\PYG{o}{:}\PYG{n}{setup}\PYG{p}{(}\PYG{n}{DataPoint} \PYG{n}{datin}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{n}{xpos} \PYG{o}{=} \PYG{n}{datin}\PYG{p}{.}\PYG{n}{getXpos}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{ypos} \PYG{o}{=} \PYG{n}{datin}\PYG{p}{.}\PYG{n}{getYpos}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{xwrap} \PYG{o}{=} \PYG{n}{datin}\PYG{p}{.}\PYG{n}{getXwrap}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{ywrap} \PYG{o}{=} \PYG{n}{datin}\PYG{p}{.}\PYG{n}{getYwrap}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{next\PYGZus{}lineage} \PYG{o}{=} \PYG{n}{datin}\PYG{p}{.}\PYG{n}{getNext}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{c+c1}{//      last = datin.get\PYGZus{}last(); // removed as of version 3.1}
    \PYG{n}{reference} \PYG{o}{=} \PYG{n}{datin}\PYG{p}{.}\PYG{n}{getReference}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{list\PYGZus{}position} \PYG{o}{=} \PYG{n}{datin}\PYG{p}{.}\PYG{n}{getListpos}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{nwrap} \PYG{o}{=} \PYG{n}{datin}\PYG{p}{.}\PYG{n}{getNwrap}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{min\PYGZus{}max} \PYG{o}{=} \PYG{n}{datin}\PYG{p}{.}\PYG{n}{getMinmax}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{void} \PYG{n}{DataPoint}\PYG{o}{:}\PYG{o}{:}\PYG{n}{setReference}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{z}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{n}{reference} \PYG{o}{=} \PYG{n}{z}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{void} \PYG{n}{DataPoint}\PYG{o}{:}\PYG{o}{:}\PYG{n}{setNext}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{x}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{n}{next\PYGZus{}lineage} \PYG{o}{=} \PYG{n}{x}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{void} \PYG{n}{DataPoint}\PYG{o}{:}\PYG{o}{:}\PYG{n}{setListPosition}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{l}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{n}{list\PYGZus{}position} \PYG{o}{=} \PYG{n}{l}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{void} \PYG{n}{DataPoint}\PYG{o}{:}\PYG{o}{:}\PYG{n}{setNwrap}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{n}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{n}{nwrap} \PYG{o}{=} \PYG{n}{n}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{void} \PYG{n}{DataPoint}\PYG{o}{:}\PYG{o}{:}\PYG{n}{setMinmax}\PYG{p}{(}\PYG{k+kt}{double} \PYG{n}{d}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{n}{min\PYGZus{}max} \PYG{o}{=} \PYG{n}{d}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{DataPoint}\PYG{o}{:}\PYG{o}{:}\PYG{n}{getXpos}\PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k}{return} \PYG{n}{xpos}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{DataPoint}\PYG{o}{:}\PYG{o}{:}\PYG{n}{getYpos}\PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k}{return} \PYG{n}{ypos}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{long} \PYG{n}{DataPoint}\PYG{o}{:}\PYG{o}{:}\PYG{n}{getXwrap}\PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k}{return} \PYG{n}{xwrap}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{long} \PYG{n}{DataPoint}\PYG{o}{:}\PYG{o}{:}\PYG{n}{getYwrap}\PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k}{return} \PYG{n}{ywrap}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{DataPoint}\PYG{o}{:}\PYG{o}{:}\PYG{n}{getReference}\PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k}{return} \PYG{n}{reference}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{DataPoint}\PYG{o}{:}\PYG{o}{:}\PYG{n}{getNext}\PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k}{return} \PYG{n}{next\PYGZus{}lineage}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{DataPoint}\PYG{o}{:}\PYG{o}{:}\PYG{n}{getListpos}\PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k}{return} \PYG{n}{list\PYGZus{}position}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{DataPoint}\PYG{o}{:}\PYG{o}{:}\PYG{n}{getNwrap}\PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k}{return} \PYG{n}{nwrap}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{double} \PYG{n}{DataPoint}\PYG{o}{:}\PYG{o}{:}\PYG{n}{getMinmax}\PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k}{return} \PYG{n}{min\PYGZus{}max}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{void} \PYG{n}{DataPoint}\PYG{o}{:}\PYG{o}{:}\PYG{n}{decreaseNwrap}\PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k}{try}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{nwrap}\PYG{o}{=}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{k}{throw} \PYG{n}{out\PYGZus{}of\PYGZus{}range}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ERROR\PYGZus{}DATA\PYGZus{}001: Trying to decrease  nwrap less than 0.}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{else}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{nwrap} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{catch}\PYG{p}{(}\PYG{n}{out\PYGZus{}of\PYGZus{}range}\PYG{o}{\PYGZam{}} \PYG{n}{oor}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{cerr} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{oor}\PYG{p}{.}\PYG{n}{what}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{void} \PYG{n}{DataPoint}\PYG{o}{:}\PYG{o}{:}\PYG{n}{setEndpoint}\PYG{p}{(}\PYG{k+kt}{long} \PYG{n}{x}\PYG{p}{,} \PYG{k+kt}{long} \PYG{n}{y}\PYG{p}{,} \PYG{k+kt}{long} \PYG{n}{xwrapin}\PYG{p}{,} \PYG{k+kt}{long} \PYG{n}{ywrapin}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{n}{xpos} \PYG{o}{=} \PYG{n}{x}\PYG{p}{;}
    \PYG{n}{ypos} \PYG{o}{=} \PYG{n}{y}\PYG{p}{;}
    \PYG{n}{xwrap} \PYG{o}{=} \PYG{n}{xwrapin}\PYG{p}{;}
    \PYG{n}{ywrap} \PYG{o}{=} \PYG{n}{ywrapin}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{n}{ostream} \PYG{o}{\PYGZam{}}\PYG{k}{operator}\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{p}{(}\PYG{n}{ostream} \PYG{o}{\PYGZam{}}\PYG{n}{os}\PYG{p}{,} \PYG{k}{const} \PYG{n}{DataPoint} \PYG{o}{\PYGZam{}}\PYG{n}{d}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{n}{os} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{d}\PYG{p}{.}\PYG{n}{xpos} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{,}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{d}\PYG{p}{.}\PYG{n}{ypos}  \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{,}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{d}\PYG{p}{.}\PYG{n}{xwrap} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{,}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{d}\PYG{p}{.}\PYG{n}{ywrap} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{,}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{d}\PYG{p}{.}\PYG{n}{next\PYGZus{}lineage} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{,}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{d}\PYG{p}{.}\PYG{n}{reference} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{,}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{d}\PYG{p}{.}\PYG{n}{list\PYGZus{}position} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{,}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{d}\PYG{p}{.}\PYG{n}{nwrap}\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{,}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
    \PYG{n}{os} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{d}\PYG{p}{.}\PYG{n}{min\PYGZus{}max} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
    \PYG{k}{return} \PYG{n}{os}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{n}{istream} \PYG{o}{\PYGZam{}}\PYG{k}{operator}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{n}{istream} \PYG{o}{\PYGZam{}}\PYG{n}{is}\PYG{p}{,} \PYG{n}{DataPoint} \PYG{o}{\PYGZam{}}\PYG{n}{d}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{c+c1}{//os \PYGZlt{}\PYGZlt{} m.numRows\PYGZlt{}\PYGZlt{}\PYGZdq{} , \PYGZdq{}\PYGZlt{}\PYGZlt{}m.numCols\PYGZlt{}\PYGZlt{}\PYGZdq{} , \PYGZdq{}\PYGZlt{}\PYGZlt{}endl;}
    \PYG{k+kt}{char} \PYG{n}{delim}\PYG{p}{;}
    \PYG{c+c1}{//os \PYGZlt{}\PYGZlt{} \PYGZdq{}datapoint\PYGZdq{} \PYGZlt{}\PYGZlt{} endl;}
    \PYG{n}{is} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{d}\PYG{p}{.}\PYG{n}{xpos} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{delim} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{d}\PYG{p}{.}\PYG{n}{ypos}  \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{delim} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{d}\PYG{p}{.}\PYG{n}{xwrap} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{delim} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{d}\PYG{p}{.}\PYG{n}{ywrap} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{delim} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{d}\PYG{p}{.}\PYG{n}{next\PYGZus{}lineage} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{delim} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{d}\PYG{p}{.}\PYG{n}{reference} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{delim} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{d}\PYG{p}{.}\PYG{n}{list\PYGZus{}position} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{delim} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{d}\PYG{p}{.}\PYG{n}{nwrap}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{delim}\PYG{p}{;}
    \PYG{n}{is} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{d}\PYG{p}{.}\PYG{n}{min\PYGZus{}max}\PYG{p}{;}
    \PYG{k}{return} \PYG{n}{is}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}


\subsubsection{Detailed Description}
\label{\detokenize{api/file_necsim_DataPoint.cpp:detailed-description}}
Samuel Thompson
30/08/2016
BSD-3 Licence. This class is only used during simulation runs and is not outputted to a database. A {\hyperref[\detokenize{api/class_Row:template-class-row}]{\sphinxcrossref{\DUrole{std,std-ref}{Template Class Row}}}} of Datapoint objects is utilised by the main {\hyperref[\detokenize{api/class_Tree:class-tree}]{\sphinxcrossref{\DUrole{std,std-ref}{Class Tree}}}} objects.


\subsubsection{Includes}
\label{\detokenize{api/file_necsim_DataPoint.cpp:includes}}\begin{itemize}
\item {} 
\sphinxcode{DataPoint.h} ({\hyperref[\detokenize{api/file_necsim_DataPoint.h:file-necsim-datapoint-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File DataPoint.h}}}})

\end{itemize}


\subsubsection{Functions}
\label{\detokenize{api/file_necsim_DataPoint.cpp:functions}}\begin{itemize}
\item {} 
{\hyperref[\detokenize{api/function_operator_LT__LT:function-operator-lt-lt}]{\sphinxcrossref{\DUrole{std,std-ref}{Function operator\textless{}\textless{}}}}}

\item {} 
{\hyperref[\detokenize{api/function_operator_GT__GT:function-operator-gt-gt}]{\sphinxcrossref{\DUrole{std,std-ref}{Function operator\textgreater{}\textgreater{}}}}}

\end{itemize}


\subsection{File DataPoint.h}
\label{\detokenize{api/file_necsim_DataPoint.h:file-datapoint-h}}\label{\detokenize{api/file_necsim_DataPoint.h:file-necsim-datapoint-h}}\label{\detokenize{api/file_necsim_DataPoint.h::doc}}
Contains the {\hyperref[\detokenize{api/class_DataPoint:class-datapoint}]{\sphinxcrossref{\DUrole{std,std-ref}{Class DataPoint}}}} class for storing objects during simulation run time.

\begin{sphinxShadowBox}
\sphinxstyletopictitle{Contents}
\begin{itemize}
\item {} 
\phantomsection\label{\detokenize{api/file_necsim_DataPoint.h:id1}}{\hyperref[\detokenize{api/file_necsim_DataPoint.h:definition-necsim-datapoint-h}]{\sphinxcrossref{Definition (\sphinxcode{necsim/DataPoint.h})}}}

\item {} 
\phantomsection\label{\detokenize{api/file_necsim_DataPoint.h:id2}}{\hyperref[\detokenize{api/file_necsim_DataPoint.h:detailed-description}]{\sphinxcrossref{Detailed Description}}}

\item {} 
\phantomsection\label{\detokenize{api/file_necsim_DataPoint.h:id3}}{\hyperref[\detokenize{api/file_necsim_DataPoint.h:includes}]{\sphinxcrossref{Includes}}}

\item {} 
\phantomsection\label{\detokenize{api/file_necsim_DataPoint.h:id4}}{\hyperref[\detokenize{api/file_necsim_DataPoint.h:included-by}]{\sphinxcrossref{Included By}}}

\item {} 
\phantomsection\label{\detokenize{api/file_necsim_DataPoint.h:id5}}{\hyperref[\detokenize{api/file_necsim_DataPoint.h:classes}]{\sphinxcrossref{Classes}}}

\end{itemize}
\end{sphinxShadowBox}


\subsubsection{Definition (\sphinxstyleliteralintitle{necsim/DataPoint.h})}
\label{\detokenize{api/file_necsim_DataPoint.h:definition-necsim-datapoint-h}}

\paragraph{Program Listing for File DataPoint.h}
\label{\detokenize{api/program_listing_file_necsim_DataPoint.h:program-listing-file-necsim-datapoint-h}}\label{\detokenize{api/program_listing_file_necsim_DataPoint.h:program-listing-for-file-datapoint-h}}\label{\detokenize{api/program_listing_file_necsim_DataPoint.h::doc}}\begin{itemize}
\item {} 
Return to documentation for {\hyperref[\detokenize{api/file_necsim_DataPoint.h:file-necsim-datapoint-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File DataPoint.h}}}}

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{//This file is part of NECSim project which is released under BSD\PYGZhy{}3 license.}
\PYG{c+c1}{//See file **LICENSE.txt** or visit https://opensource.org/licenses/BSD\PYGZhy{}3\PYGZhy{}Clause) for full license details.}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifndef DATAPOINT\PYGZus{}H}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define DATAPOINT\PYGZus{}H}

\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}iostream\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZdq{}Logging.h\PYGZdq{}}

\PYG{k}{using} \PYG{k}{namespace} \PYG{n}{std}\PYG{p}{;}
\PYG{k}{class} \PYG{n+nc}{DataPoint}
\PYG{p}{\PYGZob{}}

\PYG{k}{private}\PYG{o}{:}
    \PYG{c+c1}{// x position}
    \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{xpos}\PYG{p}{;}
    \PYG{c+c1}{// y position}
    \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{ypos}\PYG{p}{;}
    \PYG{c+c1}{// number of wraps of x around the torus}
    \PYG{k+kt}{long} \PYG{n}{xwrap}\PYG{p}{;}
    \PYG{c+c1}{// number of wraps of y around the torus}
    \PYG{k+kt}{long} \PYG{n}{ywrap}\PYG{p}{;}
    \PYG{c+c1}{// the next individual in the loop of those that have the same xypos}
    \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{next\PYGZus{}lineage}\PYG{p}{;}
    \PYG{c+c1}{// points to the position in output of this lineage}
    \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{reference}\PYG{p}{;}
    \PYG{c+c1}{// points to the position in the SpeciesList file.}
    \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{list\PYGZus{}position}\PYG{p}{;}
    \PYG{c+c1}{// the reference number within the linked list of wrapped lineages}
    \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{nwrap}\PYG{p}{;}
    \PYG{c+c1}{// the max\PYGZhy{}min number}
    \PYG{k+kt}{double} \PYG{n}{min\PYGZus{}max}\PYG{p}{;}
\PYG{k}{public}\PYG{o}{:}

    \PYG{n}{DataPoint}\PYG{p}{(}\PYG{p}{)} \PYG{o}{:} \PYG{n}{xpos}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{,}\PYG{n}{ypos}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{,}\PYG{n}{xwrap}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{,}\PYG{n}{ywrap}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{,}\PYG{n}{next\PYGZus{}lineage}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{,}\PYG{n}{reference}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{,}\PYG{n}{list\PYGZus{}position}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{,}\PYG{n}{nwrap}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{,}\PYG{n}{min\PYGZus{}max}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}

    \PYG{p}{\PYGZcb{}}

    \PYG{o}{\PYGZti{}}\PYG{n}{DataPoint}\PYG{p}{(}\PYG{p}{)} \PYG{o}{=} \PYG{k}{default}\PYG{p}{;}

    \PYG{k+kt}{void} \PYG{n+nf}{setup}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{x} \PYG{p}{,} \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{y} \PYG{p}{,} \PYG{k+kt}{long} \PYG{n}{xwrap\PYGZus{}in}\PYG{p}{,} \PYG{k+kt}{long} \PYG{n}{ywrap\PYGZus{}in}\PYG{p}{,} \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{reference\PYGZus{}in}\PYG{p}{,}
               \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{list\PYGZus{}position\PYGZus{}in}\PYG{p}{,} \PYG{k+kt}{double} \PYG{n}{min\PYGZus{}max\PYGZus{}in}\PYG{p}{)}\PYG{p}{;}

    \PYG{k+kt}{void} \PYG{n+nf}{setup}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{reference\PYGZus{}in}\PYG{p}{,} \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{list\PYGZus{}position\PYGZus{}in}\PYG{p}{,} \PYG{k+kt}{double} \PYG{n}{min\PYGZus{}max\PYGZus{}in}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kt}{void} \PYG{n+nf}{setup}\PYG{p}{(}\PYG{n}{DataPoint} \PYG{n}{datin}\PYG{p}{)}\PYG{p}{;}


    \PYG{k+kt}{void} \PYG{n+nf}{setReference}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{z}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kt}{void} \PYG{n+nf}{setNext}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{x}\PYG{p}{)}\PYG{p}{;}

    \PYG{k+kt}{void} \PYG{n+nf}{setListPosition}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{l}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kt}{void} \PYG{n+nf}{setNwrap}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{n}\PYG{p}{)}\PYG{p}{;}

    \PYG{k+kt}{void} \PYG{n+nf}{setMinmax}\PYG{p}{(}\PYG{k+kt}{double} \PYG{n}{d}\PYG{p}{)}\PYG{p}{;}


    \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n+nf}{getXpos}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

    \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n+nf}{getYpos}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

    \PYG{k+kt}{long} \PYG{n+nf}{getXwrap}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

    \PYG{k+kt}{long} \PYG{n+nf}{getYwrap}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

    \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n+nf}{getReference}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

    \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n+nf}{getNext}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

    \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n+nf}{getListpos}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

    \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n+nf}{getNwrap}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

    \PYG{k+kt}{double} \PYG{n+nf}{getMinmax}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

    \PYG{k+kt}{void} \PYG{n+nf}{decreaseNwrap}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

    \PYG{k+kt}{void} \PYG{n+nf}{setEndpoint}\PYG{p}{(}\PYG{k+kt}{long} \PYG{n}{x}\PYG{p}{,} \PYG{k+kt}{long} \PYG{n}{y}\PYG{p}{,} \PYG{k+kt}{long} \PYG{n}{xwrapin}\PYG{p}{,} \PYG{k+kt}{long} \PYG{n}{ywrapin}\PYG{p}{)}\PYG{p}{;}

    \PYG{k}{friend} \PYG{n}{ostream}\PYG{o}{\PYGZam{}} \PYG{k}{operator}\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{p}{(}\PYG{n}{ostream}\PYG{o}{\PYGZam{}} \PYG{n}{os}\PYG{p}{,} \PYG{k}{const} \PYG{n}{DataPoint}\PYG{o}{\PYGZam{}} \PYG{n}{d}\PYG{p}{)}\PYG{p}{;}

    \PYG{k}{friend} \PYG{n}{istream}\PYG{o}{\PYGZam{}} \PYG{k}{operator}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{n}{istream}\PYG{o}{\PYGZam{}} \PYG{n}{is}\PYG{p}{,} \PYG{n}{DataPoint}\PYG{o}{\PYGZam{}} \PYG{n}{d}\PYG{p}{)}\PYG{p}{;}

\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifdef DEBUG}
    \PYG{k+kt}{void} \PYG{n+nf}{logActive}\PYG{p}{(}\PYG{k}{const} \PYG{k+kt}{int} \PYG{o}{\PYGZam{}}\PYG{n}{level}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{writeLog}\PYG{p}{(}\PYG{l+m+mi}{50}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{x, y, (x wrap, y wrap): }\PYG{l+s}{\PYGZdq{}} \PYG{o}{+} \PYG{n}{to\PYGZus{}string}\PYG{p}{(}\PYG{n}{xpos}\PYG{p}{)} \PYG{o}{+} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{, }\PYG{l+s}{\PYGZdq{}} \PYG{o}{+} \PYG{n}{to\PYGZus{}string}\PYG{p}{(}\PYG{n}{ypos}\PYG{p}{)} \PYG{o}{+} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{, (}\PYG{l+s}{\PYGZdq{}} \PYG{o}{+}
                \PYG{n}{to\PYGZus{}string}\PYG{p}{(}\PYG{n}{xwrap}\PYG{p}{)} \PYG{o}{+} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{, }\PYG{l+s}{\PYGZdq{}} \PYG{o}{+} \PYG{n}{to\PYGZus{}string}\PYG{p}{(}\PYG{n}{ywrap}\PYG{p}{)} \PYG{o}{+} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{)}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{writeLog}\PYG{p}{(}\PYG{l+m+mi}{50}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Lineage next: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{+} \PYG{n}{to\PYGZus{}string}\PYG{p}{(}\PYG{n}{next\PYGZus{}lineage}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{writeLog}\PYG{p}{(}\PYG{l+m+mi}{50}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Reference: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{+} \PYG{n}{to\PYGZus{}string}\PYG{p}{(}\PYG{n}{reference}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{writeLog}\PYG{p}{(}\PYG{l+m+mi}{50}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{List position: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{+} \PYG{n}{to\PYGZus{}string}\PYG{p}{(}\PYG{n}{list\PYGZus{}position}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{writeLog}\PYG{p}{(}\PYG{l+m+mi}{50}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Number in wrapped lineages: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{+} \PYG{n}{to\PYGZus{}string}\PYG{p}{(}\PYG{n}{nwrap}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{writeLog}\PYG{p}{(}\PYG{l+m+mi}{50}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Minimum maximum: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{+} \PYG{n}{to\PYGZus{}string}\PYG{p}{(}\PYG{n}{min\PYGZus{}max}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif }\PYG{c+c1}{// DEBUG}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}

\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif }\PYG{c+c1}{// DATAPOINT\PYGZus{}H}
\end{sphinxVerbatim}


\subsubsection{Detailed Description}
\label{\detokenize{api/file_necsim_DataPoint.h:detailed-description}}
Samuel Thompson
30/08/2016
BSD-3 Licence. This class is only used during simulation runs and is not outputted to a database. A {\hyperref[\detokenize{api/class_Row:template-class-row}]{\sphinxcrossref{\DUrole{std,std-ref}{Template Class Row}}}} of {\hyperref[\detokenize{api/class_DataPoint:class-datapoint}]{\sphinxcrossref{\DUrole{std,std-ref}{Class DataPoint}}}} objects is utilised by the main {\hyperref[\detokenize{api/class_Tree:class-tree}]{\sphinxcrossref{\DUrole{std,std-ref}{Class Tree}}}} objects.


\subsubsection{Includes}
\label{\detokenize{api/file_necsim_DataPoint.h:includes}}\begin{itemize}
\item {} 
\sphinxcode{Logging.h} ({\hyperref[\detokenize{api/file_necsim_Logging.h:file-necsim-logging-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File Logging.h}}}})

\item {} 
\sphinxcode{iostream}

\end{itemize}


\subsubsection{Included By}
\label{\detokenize{api/file_necsim_DataPoint.h:included-by}}\begin{itemize}
\item {} 
{\hyperref[\detokenize{api/file_necsim_DataPoint.cpp:file-necsim-datapoint-cpp}]{\sphinxcrossref{\DUrole{std,std-ref}{File DataPoint.cpp}}}}

\item {} 
{\hyperref[\detokenize{api/file_necsim_Tree.h:file-necsim-tree-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File Tree.h}}}}

\item {} 
{\hyperref[\detokenize{api/file_necsim_SpatialTree.h:file-necsim-spatialtree-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File SpatialTree.h}}}}

\end{itemize}


\subsubsection{Classes}
\label{\detokenize{api/file_necsim_DataPoint.h:classes}}\begin{itemize}
\item {} 
{\hyperref[\detokenize{api/class_DataPoint:class-datapoint}]{\sphinxcrossref{\DUrole{std,std-ref}{Class DataPoint}}}}

\end{itemize}


\subsection{File DispersalCoordinator.cpp}
\label{\detokenize{api/file_necsim_DispersalCoordinator.cpp:file-necsim-dispersalcoordinator-cpp}}\label{\detokenize{api/file_necsim_DispersalCoordinator.cpp::doc}}\label{\detokenize{api/file_necsim_DispersalCoordinator.cpp:file-dispersalcoordinator-cpp}}
Contains the {\hyperref[\detokenize{api/class_DispersalCoordinator:class-dispersalcoordinator}]{\sphinxcrossref{\DUrole{std,std-ref}{Class DispersalCoordinator}}}}, which contains all routines related to dispersal including utilisation of density maps and dispersal probability maps.

\begin{sphinxShadowBox}
\sphinxstyletopictitle{Contents}
\begin{itemize}
\item {} 
\phantomsection\label{\detokenize{api/file_necsim_DispersalCoordinator.cpp:id1}}{\hyperref[\detokenize{api/file_necsim_DispersalCoordinator.cpp:definition-necsim-dispersalcoordinator-cpp}]{\sphinxcrossref{Definition (\sphinxcode{necsim/DispersalCoordinator.cpp})}}}

\item {} 
\phantomsection\label{\detokenize{api/file_necsim_DispersalCoordinator.cpp:id2}}{\hyperref[\detokenize{api/file_necsim_DispersalCoordinator.cpp:detailed-description}]{\sphinxcrossref{Detailed Description}}}

\item {} 
\phantomsection\label{\detokenize{api/file_necsim_DispersalCoordinator.cpp:id3}}{\hyperref[\detokenize{api/file_necsim_DispersalCoordinator.cpp:includes}]{\sphinxcrossref{Includes}}}

\end{itemize}
\end{sphinxShadowBox}


\subsubsection{Definition (\sphinxstyleliteralintitle{necsim/DispersalCoordinator.cpp})}
\label{\detokenize{api/file_necsim_DispersalCoordinator.cpp:definition-necsim-dispersalcoordinator-cpp}}

\paragraph{Program Listing for File DispersalCoordinator.cpp}
\label{\detokenize{api/program_listing_file_necsim_DispersalCoordinator.cpp:program-listing-file-necsim-dispersalcoordinator-cpp}}\label{\detokenize{api/program_listing_file_necsim_DispersalCoordinator.cpp::doc}}\label{\detokenize{api/program_listing_file_necsim_DispersalCoordinator.cpp:program-listing-for-file-dispersalcoordinator-cpp}}\begin{itemize}
\item {} 
Return to documentation for {\hyperref[\detokenize{api/file_necsim_DispersalCoordinator.cpp:file-necsim-dispersalcoordinator-cpp}]{\sphinxcrossref{\DUrole{std,std-ref}{File DispersalCoordinator.cpp}}}}

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{//This file is part of NECSim project which is released under BSD\PYGZhy{}3 license.}
\PYG{c+c1}{//See file **LICENSE.txt** or visit https://opensource.org/licenses/BSD\PYGZhy{}3\PYGZhy{}Clause) for full license details.}

\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZdq{}DispersalCoordinator.h\PYGZdq{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZdq{}CustomExceptions.h\PYGZdq{}}

\PYG{n}{DispersalCoordinator}\PYG{o}{:}\PYG{o}{:}\PYG{n}{DispersalCoordinator}\PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
\PYG{p}{\PYGZcb{}}

\PYG{n}{DispersalCoordinator}\PYG{o}{:}\PYG{o}{:}\PYG{o}{\PYGZti{}}\PYG{n}{DispersalCoordinator}\PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}

\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{void} \PYG{n}{DispersalCoordinator}\PYG{o}{:}\PYG{o}{:}\PYG{n}{setRandomNumber}\PYG{p}{(}\PYG{n}{NRrand} \PYG{o}{*} \PYG{n}{NR\PYGZus{}ptr}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{n}{NR} \PYG{o}{=} \PYG{n}{NR\PYGZus{}ptr}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}


\PYG{k+kt}{void} \PYG{n}{DispersalCoordinator}\PYG{o}{:}\PYG{o}{:}\PYG{n}{setHabitatMap}\PYG{p}{(}\PYG{n}{Map} \PYG{o}{*}\PYG{n}{map\PYGZus{}ptr}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{n}{habitat\PYGZus{}map} \PYG{o}{=} \PYG{n}{map\PYGZus{}ptr}\PYG{p}{;}
    \PYG{n}{xdim} \PYG{o}{=} \PYG{n}{habitat\PYGZus{}map}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{getSimParameters}\PYG{p}{(}\PYG{p}{)}\PYG{p}{.}\PYG{n}{fine\PYGZus{}map\PYGZus{}x\PYGZus{}size}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{void} \PYG{n}{DispersalCoordinator}\PYG{o}{:}\PYG{o}{:}\PYG{n}{setGenerationPtr}\PYG{p}{(}\PYG{k+kt}{double} \PYG{o}{*} \PYG{n}{generation\PYGZus{}ptr}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{n}{generation} \PYG{o}{=} \PYG{n}{generation\PYGZus{}ptr}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}


\PYG{k+kt}{void} \PYG{n}{DispersalCoordinator}\PYG{o}{:}\PYG{o}{:}\PYG{n}{setDispersal}\PYG{p}{(}\PYG{k}{const} \PYG{n}{string} \PYG{o}{\PYGZam{}}\PYG{n}{dispersal\PYGZus{}method}\PYG{p}{,} \PYG{k}{const} \PYG{n}{string} \PYG{o}{\PYGZam{}}\PYG{n}{dispersal\PYGZus{}file}\PYG{p}{,}
                              \PYG{k}{const} \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{dispersal\PYGZus{}x}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{dispersal\PYGZus{}y}\PYG{p}{,}
                              \PYG{k}{const} \PYG{k+kt}{double} \PYG{o}{\PYGZam{}}\PYG{n}{m\PYGZus{}probin}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{double} \PYG{o}{\PYGZam{}}\PYG{n}{cutoffin}\PYG{p}{,}
                              \PYG{k}{const} \PYG{k+kt}{double} \PYG{o}{\PYGZam{}}\PYG{n}{sigmain}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{double} \PYG{o}{\PYGZam{}}\PYG{n}{tauin}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{bool} \PYG{o}{\PYGZam{}}\PYG{n}{restrict\PYGZus{}self}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{c+c1}{// Open our file connection}
    \PYG{k}{if}\PYG{p}{(}\PYG{n}{dispersal\PYGZus{}file} \PYG{o}{=}\PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{none}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{setEndPointFptr}\PYG{p}{(}\PYG{n}{restrict\PYGZus{}self}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{NR}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{setDispersalParams}\PYG{p}{(}\PYG{n}{sigmain}\PYG{p}{,} \PYG{n}{tauin}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{NR}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{setDispersalMethod}\PYG{p}{(}\PYG{n}{dispersal\PYGZus{}method}\PYG{p}{,} \PYG{n}{m\PYGZus{}probin}\PYG{p}{,} \PYG{n}{cutoffin}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{doDispersal} \PYG{o}{=} \PYG{o}{\PYGZam{}}\PYG{n}{DispersalCoordinator}\PYG{o}{:}\PYG{o}{:}\PYG{n}{disperseDensityMap}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{else} \PYG{k}{if}\PYG{p}{(}\PYG{n}{dispersal\PYGZus{}file} \PYG{o}{=}\PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{null}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{doDispersal} \PYG{o}{=} \PYG{o}{\PYGZam{}}\PYG{n}{DispersalCoordinator}\PYG{o}{:}\PYG{o}{:}\PYG{n}{disperseNullDispersalMap}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{else}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{doDispersal} \PYG{o}{=} \PYG{o}{\PYGZam{}}\PYG{n}{DispersalCoordinator}\PYG{o}{:}\PYG{o}{:}\PYG{n}{disperseDispersalMap}\PYG{p}{;}
        \PYG{c+c1}{// Check file existance}
        \PYG{n}{ifstream} \PYG{n+nf}{infile}\PYG{p}{(}\PYG{n}{dispersal\PYGZus{}file}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{if}\PYG{p}{(}\PYG{o}{!}\PYG{n}{infile}\PYG{p}{.}\PYG{n}{good}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{string} \PYG{n}{msg} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Could not access dispersal map file }\PYG{l+s}{\PYGZdq{}} \PYG{o}{+} \PYG{n}{dispersal\PYGZus{}file} \PYG{o}{+} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{. Check file exists and is readable.}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
            \PYG{k}{throw} \PYG{n+nf}{FatalException}\PYG{p}{(}\PYG{n}{msg}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{n}{infile}\PYG{p}{.}\PYG{n}{close}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{dispersal\PYGZus{}prob\PYGZus{}map}\PYG{p}{.}\PYG{n}{SetSize}\PYG{p}{(}\PYG{n}{dispersal\PYGZus{}x} \PYG{o}{*} \PYG{n}{dispersal\PYGZus{}y}\PYG{p}{,} \PYG{n}{dispersal\PYGZus{}x} \PYG{o}{*} \PYG{n}{dispersal\PYGZus{}y}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{dispersal\PYGZus{}prob\PYGZus{}map}\PYG{p}{.}\PYG{n}{import}\PYG{p}{(}\PYG{n}{dispersal\PYGZus{}file}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{void} \PYG{n}{DispersalCoordinator}\PYG{o}{:}\PYG{o}{:}\PYG{n}{disperseNullDispersalMap}\PYG{p}{(}\PYG{n}{Step} \PYG{o}{\PYGZam{}}\PYG{n}{this\PYGZus{}step}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{c+c1}{// Pick a random cell \PYGZhy{} that\PYGZsq{}s all we need}
    \PYG{n}{this\PYGZus{}step}\PYG{p}{.}\PYG{n}{oldx} \PYG{o}{=} \PYG{n}{floor}\PYG{p}{(}\PYG{n}{NR}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{d01}\PYG{p}{(}\PYG{p}{)}\PYG{o}{*}\PYG{p}{(}\PYG{n}{xdim}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{this\PYGZus{}step}\PYG{p}{.}\PYG{n}{oldy} \PYG{o}{=} \PYG{n}{floor}\PYG{p}{(}\PYG{n}{NR}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{d01}\PYG{p}{(}\PYG{p}{)}\PYG{o}{*}\PYG{p}{(}\PYG{n}{xdim} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{void} \PYG{n}{DispersalCoordinator}\PYG{o}{:}\PYG{o}{:}\PYG{n}{disperseDispersalMap}\PYG{p}{(}\PYG{n}{Step} \PYG{o}{\PYGZam{}}\PYG{n}{this\PYGZus{}step}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{c+c1}{// Generate random number 0\PYGZhy{}1}
    \PYG{k+kt}{double} \PYG{n}{random\PYGZus{}no} \PYG{o}{=} \PYG{n}{NR}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{d01}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
    \PYG{c+c1}{// Now find the cell with that value}
    \PYG{c+c1}{// Now we get the cell reference}
    \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{row\PYGZus{}ref} \PYG{o}{=} \PYG{n}{calculateCellReference}\PYG{p}{(}\PYG{n}{this\PYGZus{}step}\PYG{p}{)}\PYG{p}{;}
    \PYG{c+c1}{// Interval bisection on the cells to get the dispersal value}
    \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{min\PYGZus{}col} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
    \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{max\PYGZus{}col} \PYG{o}{=} \PYG{n}{dispersal\PYGZus{}prob\PYGZus{}map}\PYG{p}{.}\PYG{n}{GetCols}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{1}\PYG{p}{;}
    \PYG{k}{while}\PYG{p}{(}\PYG{n}{max\PYGZus{}col} \PYG{o}{\PYGZhy{}} \PYG{n}{min\PYGZus{}col} \PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{1}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{to\PYGZus{}check} \PYG{o}{=} \PYG{n}{floor}\PYG{p}{(}\PYG{k+kt}{double}\PYG{p}{(}\PYG{n}{max\PYGZus{}col}\PYG{o}{\PYGZhy{}}\PYG{n}{min\PYGZus{}col}\PYG{p}{)}\PYG{o}{/}\PYG{l+m+mf}{2.0}\PYG{p}{)} \PYG{o}{+} \PYG{n}{min\PYGZus{}col}\PYG{p}{;}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{dispersal\PYGZus{}prob\PYGZus{}map}\PYG{p}{[}\PYG{n}{row\PYGZus{}ref}\PYG{p}{]}\PYG{p}{[}\PYG{n}{to\PYGZus{}check}\PYG{p}{]} \PYG{o}{\PYGZgt{}} \PYG{n}{random\PYGZus{}no}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{min\PYGZus{}col} \PYG{o}{=} \PYG{n}{to\PYGZus{}check}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{else}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{max\PYGZus{}col} \PYG{o}{=} \PYG{n}{to\PYGZus{}check}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
    \PYG{p}{\PYGZcb{}}
    \PYG{c+c1}{// Now get the coordinates of our cell reference}
    \PYG{n}{calculateCellCoordinates}\PYG{p}{(}\PYG{n}{this\PYGZus{}step}\PYG{p}{,} \PYG{n}{max\PYGZus{}col}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{void} \PYG{n}{DispersalCoordinator}\PYG{o}{:}\PYG{o}{:}\PYG{n}{calculateCellCoordinates}\PYG{p}{(}\PYG{n}{Step} \PYG{o}{\PYGZam{}} \PYG{n}{this\PYGZus{}step}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{col\PYGZus{}ref}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{n}{this\PYGZus{}step}\PYG{p}{.}\PYG{n}{oldx} \PYG{o}{=} \PYG{k+kt}{long}\PYG{p}{(}\PYG{n}{floor}\PYG{p}{(}\PYG{n}{fmod}\PYG{p}{(}\PYG{k+kt}{double}\PYG{p}{(}\PYG{n}{col\PYGZus{}ref}\PYG{p}{)}\PYG{p}{,} \PYG{n}{xdim}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{this\PYGZus{}step}\PYG{p}{.}\PYG{n}{oldy} \PYG{o}{=} \PYG{k+kt}{long}\PYG{p}{(}\PYG{n}{floor}\PYG{p}{(}\PYG{k+kt}{double}\PYG{p}{(}\PYG{n}{col\PYGZus{}ref}\PYG{p}{)}\PYG{o}{/}\PYG{n}{xdim}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{this\PYGZus{}step}\PYG{p}{.}\PYG{n}{oldxwrap} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
    \PYG{n}{this\PYGZus{}step}\PYG{p}{.}\PYG{n}{oldywrap} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
    \PYG{c+c1}{// Convert back to sample map}
    \PYG{n}{habitat\PYGZus{}map}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{convertFineToSample}\PYG{p}{(}\PYG{n}{this\PYGZus{}step}\PYG{p}{.}\PYG{n}{oldx}\PYG{p}{,} \PYG{n}{this\PYGZus{}step}\PYG{p}{.}\PYG{n}{oldxwrap}\PYG{p}{,} \PYG{n}{this\PYGZus{}step}\PYG{p}{.}\PYG{n}{oldy}\PYG{p}{,} \PYG{n}{this\PYGZus{}step}\PYG{p}{.}\PYG{n}{oldywrap}\PYG{p}{)}\PYG{p}{;}

\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{DispersalCoordinator}\PYG{o}{:}\PYG{o}{:}\PYG{n}{calculateCellReference}\PYG{p}{(}\PYG{n}{Step} \PYG{o}{\PYGZam{}}\PYG{n}{this\PYGZus{}step}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{x} \PYG{o}{=} \PYG{n}{habitat\PYGZus{}map}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{convertSampleXToFineX}\PYG{p}{(}\PYG{n}{this\PYGZus{}step}\PYG{p}{.}\PYG{n}{oldx}\PYG{p}{,} \PYG{n}{this\PYGZus{}step}\PYG{p}{.}\PYG{n}{oldxwrap}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{y} \PYG{o}{=} \PYG{n}{habitat\PYGZus{}map}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{convertSampleYToFineY}\PYG{p}{(}\PYG{n}{this\PYGZus{}step}\PYG{p}{.}\PYG{n}{oldy}\PYG{p}{,} \PYG{n}{this\PYGZus{}step}\PYG{p}{.}\PYG{n}{oldywrap}\PYG{p}{)}\PYG{p}{;}
    \PYG{k}{return} \PYG{n}{x} \PYG{o}{+} \PYG{p}{(}\PYG{n}{y} \PYG{o}{*} \PYG{n}{xdim}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{void} \PYG{n}{DispersalCoordinator}\PYG{o}{:}\PYG{o}{:}\PYG{n}{disperseDensityMap}\PYG{p}{(}\PYG{n}{Step} \PYG{o}{\PYGZam{}}\PYG{n}{this\PYGZus{}step}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k+kt}{bool} \PYG{n}{fail}\PYG{p}{;}
    \PYG{n}{fail} \PYG{o}{=} \PYG{n+nb}{true}\PYG{p}{;}
    \PYG{c+c1}{// Store the starting positions}
    \PYG{k+kt}{long} \PYG{n}{startx}\PYG{p}{,} \PYG{n}{starty}\PYG{p}{,} \PYG{n}{startxwrap}\PYG{p}{,} \PYG{n}{startywrap}\PYG{p}{;}
    \PYG{n}{startx} \PYG{o}{=} \PYG{n}{this\PYGZus{}step}\PYG{p}{.}\PYG{n}{oldx}\PYG{p}{;}
    \PYG{n}{starty} \PYG{o}{=} \PYG{n}{this\PYGZus{}step}\PYG{p}{.}\PYG{n}{oldy}\PYG{p}{;}
    \PYG{n}{startxwrap} \PYG{o}{=} \PYG{n}{this\PYGZus{}step}\PYG{p}{.}\PYG{n}{oldxwrap}\PYG{p}{;}
    \PYG{n}{startywrap} \PYG{o}{=} \PYG{n}{this\PYGZus{}step}\PYG{p}{.}\PYG{n}{oldywrap}\PYG{p}{;}
    \PYG{c+c1}{// keep looping until we reach a viable place to move from.}
    \PYG{c+c1}{// Store the density in the end location.}
    \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{density}\PYG{p}{;}
    \PYG{k+kt}{double} \PYG{n}{dist}\PYG{p}{,} \PYG{n}{angle}\PYG{p}{;}
    \PYG{k}{while}\PYG{p}{(}\PYG{n}{fail}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{angle} \PYG{o}{=} \PYG{n}{NR}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{direction}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{dist} \PYG{o}{=} \PYG{n}{NR}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{dispersal}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{density} \PYG{o}{=} \PYG{n}{habitat\PYGZus{}map}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{runDispersal}\PYG{p}{(}\PYG{n}{dist}\PYG{p}{,} \PYG{n}{angle}\PYG{p}{,} \PYG{n}{this\PYGZus{}step}\PYG{p}{.}\PYG{n}{oldx}\PYG{p}{,}
                                          \PYG{n}{this\PYGZus{}step}\PYG{p}{.}\PYG{n}{oldy}\PYG{p}{,} \PYG{n}{this\PYGZus{}step}\PYG{p}{.}\PYG{n}{oldxwrap}\PYG{p}{,} \PYG{n}{this\PYGZus{}step}\PYG{p}{.}\PYG{n}{oldywrap}\PYG{p}{,} \PYG{n}{fail}\PYG{p}{,} \PYG{o}{*}\PYG{n}{generation}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{if}\PYG{p}{(}\PYG{o}{!}\PYG{n}{fail}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{fail} \PYG{o}{=} \PYG{o}{!}\PYG{n}{checkEndPoint}\PYG{p}{(}\PYG{n}{density}\PYG{p}{,} \PYG{n}{this\PYGZus{}step}\PYG{p}{.}\PYG{n}{oldx}\PYG{p}{,} \PYG{n}{this\PYGZus{}step}\PYG{p}{.}\PYG{n}{oldy}\PYG{p}{,} \PYG{n}{this\PYGZus{}step}\PYG{p}{.}\PYG{n}{oldxwrap}\PYG{p}{,} \PYG{n}{this\PYGZus{}step}\PYG{p}{.}\PYG{n}{oldywrap}\PYG{p}{,}
                                  \PYG{n}{startx}\PYG{p}{,} \PYG{n}{starty}\PYG{p}{,} \PYG{n}{startxwrap}\PYG{p}{,} \PYG{n}{startywrap}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{c+c1}{// Discard the dispersal event a percentage of the time, based on the maximum value of the habitat map.}
        \PYG{c+c1}{// This is to correctly mimic less\PYGZhy{}dense cells having a lower likelihood of being the parent to the cell.}

\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifdef DEBUG}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{habitat\PYGZus{}map}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{getVal}\PYG{p}{(}\PYG{n}{this\PYGZus{}step}\PYG{p}{.}\PYG{n}{oldx}\PYG{p}{,} \PYG{n}{this\PYGZus{}step}\PYG{p}{.}\PYG{n}{oldy}\PYG{p}{,} \PYG{n}{this\PYGZus{}step}\PYG{p}{.}\PYG{n}{oldxwrap}\PYG{p}{,} \PYG{n}{this\PYGZus{}step}\PYG{p}{.}\PYG{n}{oldywrap}\PYG{p}{,} \PYG{o}{*}\PYG{n}{generation}\PYG{p}{)} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{0} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}}
            \PYG{o}{!}\PYG{n}{fail}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{stringstream} \PYG{n}{ss}\PYG{p}{;}
            \PYG{n}{ss} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{x,y: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{this\PYGZus{}step}\PYG{p}{.}\PYG{n}{oldx} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{,}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{this\PYGZus{}step}\PYG{p}{.}\PYG{n}{oldy}\PYG{p}{;}
            \PYG{n}{ss} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ x,y wrap: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{this\PYGZus{}step}\PYG{p}{.}\PYG{n}{oldxwrap} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{,}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{this\PYGZus{}step}\PYG{p}{.}\PYG{n}{oldywrap} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Habitat cover: }\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
            \PYG{n}{ss} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{habitat\PYGZus{}map}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{getVal}\PYG{p}{(}\PYG{n}{this\PYGZus{}step}\PYG{p}{.}\PYG{n}{oldx}\PYG{p}{,} \PYG{n}{this\PYGZus{}step}\PYG{p}{.}\PYG{n}{oldy}\PYG{p}{,} \PYG{n}{this\PYGZus{}step}\PYG{p}{.}\PYG{n}{oldxwrap}\PYG{p}{,}
                                      \PYG{n}{this\PYGZus{}step}\PYG{p}{.}\PYG{n}{oldywrap}\PYG{p}{,} \PYG{o}{*}\PYG{n}{generation}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
            \PYG{n}{writeLog}\PYG{p}{(}\PYG{l+m+mi}{50}\PYG{p}{,} \PYG{n}{ss}\PYG{p}{)}\PYG{p}{;}
            \PYG{k}{throw} \PYG{n+nf}{FatalException}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ERROR\PYGZus{}MOVE\PYGZus{}007: Dispersal attempted to non\PYGZhy{}habitat. Check dispersal function.}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif}
    \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{void} \PYG{n}{DispersalCoordinator}\PYG{o}{:}\PYG{o}{:}\PYG{n}{setEndPointFptr}\PYG{p}{(}\PYG{k}{const} \PYG{k+kt}{bool} \PYG{o}{\PYGZam{}}\PYG{n}{restrict\PYGZus{}self}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k}{if}\PYG{p}{(}\PYG{n}{restrict\PYGZus{}self}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{checkEndPointFptr} \PYG{o}{=} \PYG{o}{\PYGZam{}}\PYG{n}{DispersalCoordinator}\PYG{o}{:}\PYG{o}{:}\PYG{n}{checkEndPointRestricted}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{else}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{checkEndPointFptr} \PYG{o}{=} \PYG{o}{\PYGZam{}}\PYG{n}{DispersalCoordinator}\PYG{o}{:}\PYG{o}{:}\PYG{n}{checkEndPointDensity}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}


\PYG{k+kt}{bool} \PYG{n}{DispersalCoordinator}\PYG{o}{:}\PYG{o}{:}\PYG{n}{checkEndPoint}\PYG{p}{(}\PYG{k}{const} \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}} \PYG{n}{density}\PYG{p}{,} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{oldx}\PYG{p}{,} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{oldy}\PYG{p}{,}
                                         \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{oldxwrap}\PYG{p}{,} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{oldywrap}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{startx}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{starty}\PYG{p}{,}
                                         \PYG{k}{const} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{startxwrap}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{startywrap}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k}{return} \PYG{p}{(}\PYG{k}{this}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{o}{*}\PYG{n}{checkEndPointFptr}\PYG{p}{)}\PYG{p}{(}\PYG{n}{density}\PYG{p}{,} \PYG{n}{oldx}\PYG{p}{,} \PYG{n}{oldy}\PYG{p}{,} \PYG{n}{oldxwrap}\PYG{p}{,} \PYG{n}{oldywrap}\PYG{p}{,} \PYG{n}{startx}\PYG{p}{,} \PYG{n}{starty}\PYG{p}{,} \PYG{n}{startxwrap}\PYG{p}{,} \PYG{n}{startywrap}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{bool} \PYG{n}{DispersalCoordinator}\PYG{o}{:}\PYG{o}{:}\PYG{n}{checkEndPointDensity}\PYG{p}{(}\PYG{k}{const} \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{density}\PYG{p}{,} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{oldx}\PYG{p}{,} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{oldy}\PYG{p}{,}
                                                \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{oldxwrap}\PYG{p}{,} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{oldywrap}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{startx}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{starty}\PYG{p}{,}
                                                \PYG{k}{const} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{startxwrap}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{startywrap}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k}{if}\PYG{p}{(}\PYG{p}{(}\PYG{k+kt}{double}\PYG{p}{(}\PYG{n}{density}\PYG{p}{)} \PYG{o}{/} \PYG{k+kt}{double}\PYG{p}{(}\PYG{n}{habitat\PYGZus{}map}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{getHabitatMax}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)} \PYG{o}{\PYGZlt{}}
       \PYG{n}{NR}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{d01}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{oldx} \PYG{o}{=} \PYG{n}{startx}\PYG{p}{;}
        \PYG{n}{oldy} \PYG{o}{=} \PYG{n}{starty}\PYG{p}{;}
        \PYG{n}{oldxwrap} \PYG{o}{=} \PYG{n}{startxwrap}\PYG{p}{;}
        \PYG{n}{oldywrap} \PYG{o}{=} \PYG{n}{startywrap}\PYG{p}{;}
        \PYG{k}{return} \PYG{n+nb}{false}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{return} \PYG{n+nb}{true}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{bool} \PYG{n}{DispersalCoordinator}\PYG{o}{:}\PYG{o}{:}\PYG{n}{checkEndPointRestricted}\PYG{p}{(}\PYG{k}{const} \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{density}\PYG{p}{,} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{oldx}\PYG{p}{,} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{oldy}\PYG{p}{,} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{oldxwrap}\PYG{p}{,} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{oldywrap}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{startx}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{starty}\PYG{p}{,}
                              \PYG{k}{const} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{startxwrap}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{startywrap}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k}{if}\PYG{p}{(}\PYG{n}{startx} \PYG{o}{=}\PYG{o}{=} \PYG{n}{oldx} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{n}{starty} \PYG{o}{=}\PYG{o}{=} \PYG{n}{oldy} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{n}{startxwrap} \PYG{o}{=}\PYG{o}{=} \PYG{n}{oldxwrap} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{n}{startywrap} \PYG{o}{=}\PYG{o}{=} \PYG{n}{oldywrap}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{return} \PYG{n+nb}{false}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{return} \PYG{n}{checkEndPointDensity}\PYG{p}{(}\PYG{n}{density}\PYG{p}{,} \PYG{n}{oldx}\PYG{p}{,} \PYG{n}{oldy}\PYG{p}{,} \PYG{n}{oldxwrap}\PYG{p}{,} \PYG{n}{oldywrap}\PYG{p}{,} \PYG{n}{startx}\PYG{p}{,} \PYG{n}{starty}\PYG{p}{,} \PYG{n}{startxwrap}\PYG{p}{,} \PYG{n}{startywrap}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{void} \PYG{n}{DispersalCoordinator}\PYG{o}{:}\PYG{o}{:}\PYG{n}{disperse}\PYG{p}{(}\PYG{n}{Step} \PYG{o}{\PYGZam{}}\PYG{n}{this\PYGZus{}step}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{p}{(}\PYG{k}{this}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{o}{*}\PYG{n}{doDispersal}\PYG{p}{)}\PYG{p}{(}\PYG{n}{this\PYGZus{}step}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}


\subsubsection{Detailed Description}
\label{\detokenize{api/file_necsim_DispersalCoordinator.cpp:detailed-description}}
Samuel Thompson
07/08/2017
BSD-3 Licence.


\subsubsection{Includes}
\label{\detokenize{api/file_necsim_DispersalCoordinator.cpp:includes}}\begin{itemize}
\item {} 
\sphinxcode{CustomExceptions.h} ({\hyperref[\detokenize{api/file_necsim_CustomExceptions.h:file-necsim-customexceptions-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File CustomExceptions.h}}}})

\item {} 
\sphinxcode{DispersalCoordinator.h} ({\hyperref[\detokenize{api/file_necsim_DispersalCoordinator.h:file-necsim-dispersalcoordinator-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File DispersalCoordinator.h}}}})

\end{itemize}


\subsection{File DispersalCoordinator.h}
\label{\detokenize{api/file_necsim_DispersalCoordinator.h:file-dispersalcoordinator-h}}\label{\detokenize{api/file_necsim_DispersalCoordinator.h::doc}}\label{\detokenize{api/file_necsim_DispersalCoordinator.h:file-necsim-dispersalcoordinator-h}}
Contains the {\hyperref[\detokenize{api/class_DispersalCoordinator:class-dispersalcoordinator}]{\sphinxcrossref{\DUrole{std,std-ref}{Class DispersalCoordinator}}}}, which contains all routines related to dispersal including utilisation of density maps and dispersal probability maps.

\begin{sphinxShadowBox}
\sphinxstyletopictitle{Contents}
\begin{itemize}
\item {} 
\phantomsection\label{\detokenize{api/file_necsim_DispersalCoordinator.h:id1}}{\hyperref[\detokenize{api/file_necsim_DispersalCoordinator.h:definition-necsim-dispersalcoordinator-h}]{\sphinxcrossref{Definition (\sphinxcode{necsim/DispersalCoordinator.h})}}}

\item {} 
\phantomsection\label{\detokenize{api/file_necsim_DispersalCoordinator.h:id2}}{\hyperref[\detokenize{api/file_necsim_DispersalCoordinator.h:detailed-description}]{\sphinxcrossref{Detailed Description}}}

\item {} 
\phantomsection\label{\detokenize{api/file_necsim_DispersalCoordinator.h:id3}}{\hyperref[\detokenize{api/file_necsim_DispersalCoordinator.h:includes}]{\sphinxcrossref{Includes}}}

\item {} 
\phantomsection\label{\detokenize{api/file_necsim_DispersalCoordinator.h:id4}}{\hyperref[\detokenize{api/file_necsim_DispersalCoordinator.h:included-by}]{\sphinxcrossref{Included By}}}

\item {} 
\phantomsection\label{\detokenize{api/file_necsim_DispersalCoordinator.h:id5}}{\hyperref[\detokenize{api/file_necsim_DispersalCoordinator.h:classes}]{\sphinxcrossref{Classes}}}

\end{itemize}
\end{sphinxShadowBox}


\subsubsection{Definition (\sphinxstyleliteralintitle{necsim/DispersalCoordinator.h})}
\label{\detokenize{api/file_necsim_DispersalCoordinator.h:definition-necsim-dispersalcoordinator-h}}

\paragraph{Program Listing for File DispersalCoordinator.h}
\label{\detokenize{api/program_listing_file_necsim_DispersalCoordinator.h:program-listing-for-file-dispersalcoordinator-h}}\label{\detokenize{api/program_listing_file_necsim_DispersalCoordinator.h::doc}}\label{\detokenize{api/program_listing_file_necsim_DispersalCoordinator.h:program-listing-file-necsim-dispersalcoordinator-h}}\begin{itemize}
\item {} 
Return to documentation for {\hyperref[\detokenize{api/file_necsim_DispersalCoordinator.h:file-necsim-dispersalcoordinator-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File DispersalCoordinator.h}}}}

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{//This file is part of NECSim project which is released under BSD\PYGZhy{}3 license.}
\PYG{c+c1}{//See file **LICENSE.txt** or visit https://opensource.org/licenses/BSD\PYGZhy{}3\PYGZhy{}Clause) for full license details.}

\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifndef DISPERSALCOORDINATOR\PYGZus{}H}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define DISPERSALCOORDINATOR\PYGZus{}H}

\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}cstring\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}cstdio\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}iostream\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}fstream\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}stdexcept\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}cmath\PYGZgt{}}

\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZdq{}NRrand.h\PYGZdq{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZdq{}Matrix.h\PYGZdq{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZdq{}Step.h\PYGZdq{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZdq{}Map.h\PYGZdq{}}

\PYG{k}{class} \PYG{n+nc}{DispersalCoordinator}
\PYG{p}{\PYGZob{}}
\PYG{k}{protected}\PYG{o}{:}

    \PYG{c+c1}{// Our map of dispersal probabilities (if required)}
    \PYG{c+c1}{// This will contain cummulative probabilities across rows}
    \PYG{n}{Matrix}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{double}\PYG{o}{\PYGZgt{}} \PYG{n}{dispersal\PYGZus{}prob\PYGZus{}map}\PYG{p}{;}
    \PYG{c+c1}{// Our random number generator for dispersal distances}
    \PYG{c+c1}{// This is a pointer so that the random number generator is the same}
    \PYG{c+c1}{// across the program.}

    \PYG{n}{NRrand} \PYG{o}{*} \PYG{n}{NR}\PYG{p}{;}
    \PYG{c+c1}{// Pointer to the habitat map object for getting density values.}
    \PYG{n}{Map} \PYG{o}{*} \PYG{n}{habitat\PYGZus{}map}\PYG{p}{;}
    \PYG{c+c1}{// Pointer to the generation counter for the simulation}
    \PYG{k+kt}{double} \PYG{o}{*} \PYG{n}{generation}\PYG{p}{;}

    \PYG{c+c1}{// function ptr for our getDispersal function}
    \PYG{k}{typedef} \PYG{n+nf}{void} \PYG{p}{(}\PYG{n}{DispersalCoordinator}\PYG{o}{:}\PYG{o}{:}\PYG{o}{*}\PYG{n}{dispersal\PYGZus{}fptr}\PYG{p}{)}\PYG{p}{(}\PYG{n}{Step} \PYG{o}{\PYGZam{}}\PYG{n}{this\PYGZus{}step}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{dispersal\PYGZus{}fptr} \PYG{n}{doDispersal}\PYG{p}{;}

    \PYG{c+c1}{// Function pointer for end checks}
    \PYG{k}{typedef} \PYG{n+nf}{bool} \PYG{p}{(}\PYG{n}{DispersalCoordinator}\PYG{o}{:}\PYG{o}{:}\PYG{o}{*}\PYG{n}{end\PYGZus{}fptr}\PYG{p}{)}\PYG{p}{(}\PYG{k}{const} \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{density}\PYG{p}{,} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{oldx}\PYG{p}{,} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{oldy}\PYG{p}{,} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{oldxwrap}\PYG{p}{,}
                                         \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{oldywrap}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{startx}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{starty}\PYG{p}{,}
                                         \PYG{k}{const} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{startxwrap}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{startywrap}\PYG{p}{)}\PYG{p}{;}
    \PYG{c+c1}{// once setup will contain the end check function to use for this simulation.}
    \PYG{n}{end\PYGZus{}fptr} \PYG{n}{checkEndPointFptr}\PYG{p}{;}
    \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{xdim}\PYG{p}{;}

\PYG{k}{public}\PYG{o}{:}
    \PYG{n}{DispersalCoordinator}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

    \PYG{o}{\PYGZti{}}\PYG{n}{DispersalCoordinator}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

    \PYG{k+kt}{void} \PYG{n+nf}{setRandomNumber}\PYG{p}{(}\PYG{n}{NRrand} \PYG{o}{*} \PYG{n}{NR\PYGZus{}ptr}\PYG{p}{)}\PYG{p}{;}

    \PYG{k+kt}{void} \PYG{n+nf}{setHabitatMap}\PYG{p}{(}\PYG{n}{Map} \PYG{o}{*}\PYG{n}{map\PYGZus{}ptr}\PYG{p}{)}\PYG{p}{;}

    \PYG{k+kt}{void} \PYG{n+nf}{setGenerationPtr}\PYG{p}{(}\PYG{k+kt}{double} \PYG{o}{*} \PYG{n}{generation\PYGZus{}ptr}\PYG{p}{)}\PYG{p}{;}


    \PYG{k+kt}{void} \PYG{n+nf}{setDispersal}\PYG{p}{(}\PYG{k}{const} \PYG{n}{string} \PYG{o}{\PYGZam{}}\PYG{n}{dispersal\PYGZus{}method}\PYG{p}{,} \PYG{k}{const} \PYG{n}{string} \PYG{o}{\PYGZam{}}\PYG{n}{dispersal\PYGZus{}file}\PYG{p}{,}
                      \PYG{k}{const} \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{dispersal\PYGZus{}x}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{dispersal\PYGZus{}y}\PYG{p}{,}
                      \PYG{k}{const} \PYG{k+kt}{double} \PYG{o}{\PYGZam{}}\PYG{n}{m\PYGZus{}probin}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{double} \PYG{o}{\PYGZam{}}\PYG{n}{cutoffin}\PYG{p}{,}
                      \PYG{k}{const} \PYG{k+kt}{double} \PYG{o}{\PYGZam{}}\PYG{n}{sigmain}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{double} \PYG{o}{\PYGZam{}}\PYG{n}{tauin}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{bool} \PYG{o}{\PYGZam{}}\PYG{n}{restrict\PYGZus{}self}\PYG{p}{)}\PYG{p}{;}

    \PYG{k+kt}{void} \PYG{n+nf}{disperseNullDispersalMap}\PYG{p}{(}\PYG{n}{Step} \PYG{o}{\PYGZam{}}\PYG{n}{this\PYGZus{}step}\PYG{p}{)}\PYG{p}{;}

    \PYG{k+kt}{void} \PYG{n+nf}{disperseDispersalMap}\PYG{p}{(}\PYG{n}{Step} \PYG{o}{\PYGZam{}}\PYG{n}{this\PYGZus{}step}\PYG{p}{)}\PYG{p}{;}


    \PYG{k+kt}{void} \PYG{n+nf}{calculateCellCoordinates}\PYG{p}{(}\PYG{n}{Step} \PYG{o}{\PYGZam{}} \PYG{n}{this\PYGZus{}step}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{col\PYGZus{}ref}\PYG{p}{)}\PYG{p}{;}

    \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n+nf}{calculateCellReference}\PYG{p}{(}\PYG{n}{Step} \PYG{o}{\PYGZam{}}\PYG{n}{this\PYGZus{}step}\PYG{p}{)}\PYG{p}{;}

    \PYG{k+kt}{void} \PYG{n+nf}{disperseDensityMap}\PYG{p}{(}\PYG{n}{Step} \PYG{o}{\PYGZam{}}\PYG{n}{this\PYGZus{}step}\PYG{p}{)}\PYG{p}{;}

    \PYG{k+kt}{void} \PYG{n+nf}{setEndPointFptr}\PYG{p}{(}\PYG{k}{const} \PYG{k+kt}{bool} \PYG{o}{\PYGZam{}}\PYG{n}{restrict\PYGZus{}self}\PYG{p}{)}\PYG{p}{;}

    \PYG{k+kt}{bool} \PYG{n+nf}{checkEndPoint}\PYG{p}{(}\PYG{k}{const} \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}} \PYG{n}{density}\PYG{p}{,} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{oldx}\PYG{p}{,} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{oldy}\PYG{p}{,} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{oldxwrap}\PYG{p}{,} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{oldywrap}\PYG{p}{,}
                        \PYG{k}{const} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{startx}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{starty}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{startxwrap}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{startywrap}\PYG{p}{)}\PYG{p}{;}


    \PYG{k+kt}{bool} \PYG{n+nf}{checkEndPointDensity}\PYG{p}{(}\PYG{k}{const} \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{density}\PYG{p}{,} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{oldx}\PYG{p}{,} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{oldy}\PYG{p}{,} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{oldxwrap}\PYG{p}{,} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{oldywrap}\PYG{p}{,}
                               \PYG{k}{const} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{startx}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{starty}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{startxwrap}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{startywrap}\PYG{p}{)}\PYG{p}{;}


    \PYG{k+kt}{bool} \PYG{n+nf}{checkEndPointRestricted}\PYG{p}{(}\PYG{k}{const} \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{density}\PYG{p}{,} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{oldx}\PYG{p}{,} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{oldy}\PYG{p}{,} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{oldxwrap}\PYG{p}{,} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{oldywrap}\PYG{p}{,}
                                  \PYG{k}{const} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{startx}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{starty}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{startxwrap}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{startywrap}\PYG{p}{)}\PYG{p}{;}


    \PYG{k+kt}{void} \PYG{n+nf}{disperse}\PYG{p}{(}\PYG{n}{Step} \PYG{o}{\PYGZam{}}\PYG{n}{this\PYGZus{}step}\PYG{p}{)}\PYG{p}{;}

\PYG{p}{\PYGZcb{}}\PYG{p}{;}

\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif }\PYG{c+c1}{// DISPERSAL\PYGZus{}H}
\end{sphinxVerbatim}


\subsubsection{Detailed Description}
\label{\detokenize{api/file_necsim_DispersalCoordinator.h:detailed-description}}
Samuel Thompson
07/08/2017
BSD-3 Licence.


\subsubsection{Includes}
\label{\detokenize{api/file_necsim_DispersalCoordinator.h:includes}}\begin{itemize}
\item {} 
\sphinxcode{Map.h} ({\hyperref[\detokenize{api/file_necsim_Map.h:file-necsim-map-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File Map.h}}}})

\item {} 
\sphinxcode{Matrix.h} ({\hyperref[\detokenize{api/file_necsim_Matrix.h:file-necsim-matrix-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File Matrix.h}}}})

\item {} 
\sphinxcode{NRrand.h} ({\hyperref[\detokenize{api/file_necsim_NRrand.h:file-necsim-nrrand-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File NRrand.h}}}})

\item {} 
\sphinxcode{Step.h} ({\hyperref[\detokenize{api/file_necsim_Step.h:file-necsim-step-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File Step.h}}}})

\item {} 
\sphinxcode{cmath}

\item {} 
\sphinxcode{cstdio}

\item {} 
\sphinxcode{cstring}

\item {} 
\sphinxcode{fstream}

\item {} 
\sphinxcode{iostream}

\item {} 
\sphinxcode{stdexcept}

\end{itemize}


\subsubsection{Included By}
\label{\detokenize{api/file_necsim_DispersalCoordinator.h:included-by}}\begin{itemize}
\item {} 
{\hyperref[\detokenize{api/file_necsim_DispersalCoordinator.cpp:file-necsim-dispersalcoordinator-cpp}]{\sphinxcrossref{\DUrole{std,std-ref}{File DispersalCoordinator.cpp}}}}

\item {} 
{\hyperref[\detokenize{api/file_necsim_SpatialTree.h:file-necsim-spatialtree-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File SpatialTree.h}}}}

\end{itemize}


\subsubsection{Classes}
\label{\detokenize{api/file_necsim_DispersalCoordinator.h:classes}}\begin{itemize}
\item {} 
{\hyperref[\detokenize{api/class_DispersalCoordinator:class-dispersalcoordinator}]{\sphinxcrossref{\DUrole{std,std-ref}{Class DispersalCoordinator}}}}

\end{itemize}


\subsection{File dispersalmodule.cpp}
\label{\detokenize{api/file_dispersalmodule.cpp::doc}}\label{\detokenize{api/file_dispersalmodule.cpp:file-dispersalmodule-cpp}}\label{\detokenize{api/file_dispersalmodule.cpp:id1}}
Contains the functions for testing dispersal methods using efficient c++ routines.

\begin{sphinxShadowBox}
\sphinxstyletopictitle{Contents}
\begin{itemize}
\item {} 
\phantomsection\label{\detokenize{api/file_dispersalmodule.cpp:id2}}{\hyperref[\detokenize{api/file_dispersalmodule.cpp:definition-dispersalmodule-cpp}]{\sphinxcrossref{Definition (\sphinxcode{dispersalmodule.cpp})}}}

\item {} 
\phantomsection\label{\detokenize{api/file_dispersalmodule.cpp:id3}}{\hyperref[\detokenize{api/file_dispersalmodule.cpp:detailed-description}]{\sphinxcrossref{Detailed Description}}}

\item {} 
\phantomsection\label{\detokenize{api/file_dispersalmodule.cpp:id4}}{\hyperref[\detokenize{api/file_dispersalmodule.cpp:includes}]{\sphinxcrossref{Includes}}}

\item {} 
\phantomsection\label{\detokenize{api/file_dispersalmodule.cpp:id5}}{\hyperref[\detokenize{api/file_dispersalmodule.cpp:functions}]{\sphinxcrossref{Functions}}}

\item {} 
\phantomsection\label{\detokenize{api/file_dispersalmodule.cpp:id6}}{\hyperref[\detokenize{api/file_dispersalmodule.cpp:defines}]{\sphinxcrossref{Defines}}}

\item {} 
\phantomsection\label{\detokenize{api/file_dispersalmodule.cpp:id7}}{\hyperref[\detokenize{api/file_dispersalmodule.cpp:variables}]{\sphinxcrossref{Variables}}}

\end{itemize}
\end{sphinxShadowBox}


\subsubsection{Definition (\sphinxstyleliteralintitle{dispersalmodule.cpp})}
\label{\detokenize{api/file_dispersalmodule.cpp:definition-dispersalmodule-cpp}}

\paragraph{Program Listing for File dispersalmodule.cpp}
\label{\detokenize{api/program_listing_file_dispersalmodule.cpp:program-listing-for-file-dispersalmodule-cpp}}\label{\detokenize{api/program_listing_file_dispersalmodule.cpp::doc}}\label{\detokenize{api/program_listing_file_dispersalmodule.cpp:program-listing-file-dispersalmodule-cpp}}\begin{itemize}
\item {} 
Return to documentation for {\hyperref[\detokenize{api/file_dispersalmodule.cpp:file-dispersalmodule-cpp}]{\sphinxcrossref{\DUrole{std,std-ref}{File dispersalmodule.cpp}}}}

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{// This file is part of NECSim project which is released under BSD\PYGZhy{}3 license.}
\PYG{c+c1}{// See file **LICENSE.txt** or visit https://opensource.org/licenses/BSD\PYGZhy{}3\PYGZhy{}Clause) for full license details}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifndef PYTHON\PYGZus{}COMPILE}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define PYTHON\PYGZus{}COMPILE}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}Python.h\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}vector\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}string\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZdq{}dispersalmodule.h\PYGZdq{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZdq{}PyLogging.h\PYGZdq{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZdq{}necsim/SimulateDispersal.h\PYGZdq{}}

\PYG{n}{PyObject} \PYG{o}{*} \PYG{n}{loggingmodule}\PYG{p}{;}
\PYG{n}{PyGILState\PYGZus{}STATE} \PYG{n}{gstate}\PYG{p}{;}
\PYG{k+kt}{bool} \PYG{n}{log\PYGZus{}set} \PYG{o}{=} \PYG{n+nb}{false}\PYG{p}{;}
\PYG{k+kt}{bool} \PYG{n}{logger\PYGZus{}set} \PYG{o}{=} \PYG{n+nb}{false}\PYG{p}{;}
\PYG{n}{PyObject} \PYG{o}{*} \PYG{n}{logger}\PYG{p}{;}

\PYG{k}{static} \PYG{n}{PyObject} \PYG{o}{*} \PYG{n+nf}{test\PYGZus{}mean\PYGZus{}dispersal}\PYG{p}{(}\PYG{n}{PyObject} \PYG{o}{*}\PYG{n}{self}\PYG{p}{,} \PYG{n}{PyObject} \PYG{o}{*}\PYG{n}{args}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k+kt}{char} \PYG{o}{*} \PYG{n}{output\PYGZus{}database}\PYG{p}{;}
    \PYG{k+kt}{char} \PYG{o}{*} \PYG{n}{map\PYGZus{}file}\PYG{p}{;}
    \PYG{k+kt}{char} \PYG{o}{*} \PYG{n}{dispersal\PYGZus{}method}\PYG{p}{;}
    \PYG{k+kt}{char} \PYG{o}{*} \PYG{n}{landscape\PYGZus{}type}\PYG{p}{;}
    \PYG{k+kt}{int} \PYG{n}{map\PYGZus{}x}\PYG{p}{,} \PYG{n}{map\PYGZus{}y}\PYG{p}{;}
    \PYG{k+kt}{double} \PYG{n}{sigma}\PYG{p}{,} \PYG{n}{tau}\PYG{p}{,} \PYG{n}{m\PYGZus{}prob}\PYG{p}{,} \PYG{n}{cutoff}\PYG{p}{;}
    \PYG{k+kt}{int} \PYG{n}{num\PYGZus{}repeats}\PYG{p}{,} \PYG{n}{seed}\PYG{p}{,} \PYG{n}{is\PYGZus{}sequential}\PYG{p}{;}

    \PYG{c+c1}{// parse arguments}
    \PYG{k}{if}\PYG{p}{(}\PYG{o}{!}\PYG{n}{PyArg\PYGZus{}ParseTuple}\PYG{p}{(}\PYG{n}{args}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ssssddddiiiii}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{output\PYGZus{}database}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{map\PYGZus{}file}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{dispersal\PYGZus{}method}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{landscape\PYGZus{}type}\PYG{p}{,}
                         \PYG{o}{\PYGZam{}}\PYG{n}{sigma}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{tau}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{m\PYGZus{}prob}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{cutoff}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{num\PYGZus{}repeats}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{seed}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{map\PYGZus{}x}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{map\PYGZus{}y}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{is\PYGZus{}sequential}\PYG{p}{)}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{return} \PYG{k}{nullptr}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{try}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{Py\PYGZus{}INCREF}\PYG{p}{(}\PYG{n}{logger}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{SimulateDispersal} \PYG{n}{disp\PYGZus{}sim}\PYG{p}{;}
        \PYG{n}{disp\PYGZus{}sim}\PYG{p}{.}\PYG{n}{setDispersalParameters}\PYG{p}{(}\PYG{n}{dispersal\PYGZus{}method}\PYG{p}{,} \PYG{n}{sigma}\PYG{p}{,} \PYG{n}{tau}\PYG{p}{,} \PYG{n}{m\PYGZus{}prob}\PYG{p}{,} \PYG{n}{cutoff}\PYG{p}{,} \PYG{n}{landscape\PYGZus{}type}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{disp\PYGZus{}sim}\PYG{p}{.}\PYG{n}{setSequential}\PYG{p}{(}\PYG{k+kt}{bool}\PYG{p}{(}\PYG{n}{is\PYGZus{}sequential}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{disp\PYGZus{}sim}\PYG{p}{.}\PYG{n}{setOutputDatabase}\PYG{p}{(}\PYG{n}{output\PYGZus{}database}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{disp\PYGZus{}sim}\PYG{p}{.}\PYG{n}{setSeed}\PYG{p}{(}\PYG{k}{static\PYGZus{}cast}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{unsigned} \PYG{k+kt}{long}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{n}{seed}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{disp\PYGZus{}sim}\PYG{p}{.}\PYG{n}{setNumberRepeats}\PYG{p}{(}\PYG{k}{static\PYGZus{}cast}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{unsigned} \PYG{k+kt}{long}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{n}{num\PYGZus{}repeats}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{disp\PYGZus{}sim}\PYG{p}{.}\PYG{n}{setSizes}\PYG{p}{(}\PYG{k}{static\PYGZus{}cast}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{unsigned} \PYG{k+kt}{long}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{n}{map\PYGZus{}x}\PYG{p}{)}\PYG{p}{,} \PYG{k}{static\PYGZus{}cast}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{unsigned} \PYG{k+kt}{long}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{n}{map\PYGZus{}y}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{disp\PYGZus{}sim}\PYG{p}{.}\PYG{n}{importMaps}\PYG{p}{(}\PYG{n}{map\PYGZus{}file}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{disp\PYGZus{}sim}\PYG{p}{.}\PYG{n}{runMeanDispersalDistance}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{disp\PYGZus{}sim}\PYG{p}{.}\PYG{n}{writeDatabase}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{DISPERSAL\PYGZus{}DISTANCES}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{Py\PYGZus{}DECREF}\PYG{p}{(}\PYG{n}{logger}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{catch}\PYG{p}{(}\PYG{n}{exception} \PYG{o}{\PYGZam{}}\PYG{n}{e}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{Py\PYGZus{}DECREF}\PYG{p}{(}\PYG{n}{logger}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{PyErr\PYGZus{}SetString}\PYG{p}{(}\PYG{n}{DispersalError}\PYG{p}{,} \PYG{n}{e}\PYG{p}{.}\PYG{n}{what}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{return} \PYG{k}{nullptr}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{n}{Py\PYGZus{}RETURN\PYGZus{}NONE}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{k}{static} \PYG{n}{PyObject} \PYG{o}{*} \PYG{n+nf}{test\PYGZus{}mean\PYGZus{}distance\PYGZus{}travelled}\PYG{p}{(}\PYG{n}{PyObject} \PYG{o}{*}\PYG{n}{self}\PYG{p}{,} \PYG{n}{PyObject} \PYG{o}{*}\PYG{n}{args}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k+kt}{char} \PYG{o}{*} \PYG{n}{output\PYGZus{}database}\PYG{p}{;}
    \PYG{k+kt}{char} \PYG{o}{*} \PYG{n}{map\PYGZus{}file}\PYG{p}{;}
    \PYG{k+kt}{char} \PYG{o}{*} \PYG{n}{dispersal\PYGZus{}method}\PYG{p}{;}
    \PYG{k+kt}{char} \PYG{o}{*} \PYG{n}{landscape\PYGZus{}type}\PYG{p}{;}
    \PYG{k+kt}{int} \PYG{n}{map\PYGZus{}x}\PYG{p}{,} \PYG{n}{map\PYGZus{}y}\PYG{p}{;}
    \PYG{k+kt}{double} \PYG{n}{sigma}\PYG{p}{,} \PYG{n}{tau}\PYG{p}{,} \PYG{n}{m\PYGZus{}prob}\PYG{p}{,} \PYG{n}{cutoff}\PYG{p}{;}
    \PYG{k+kt}{int} \PYG{n}{num\PYGZus{}repeats}\PYG{p}{,} \PYG{n}{seed}\PYG{p}{,} \PYG{n}{num\PYGZus{}steps}\PYG{p}{;}

    \PYG{c+c1}{// parse arguments}
    \PYG{k}{if}\PYG{p}{(}\PYG{o}{!}\PYG{n}{PyArg\PYGZus{}ParseTuple}\PYG{p}{(}\PYG{n}{args}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ssssddddiiiii}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{output\PYGZus{}database}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{map\PYGZus{}file}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{dispersal\PYGZus{}method}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{landscape\PYGZus{}type}\PYG{p}{,}
                         \PYG{o}{\PYGZam{}}\PYG{n}{sigma}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{tau}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{m\PYGZus{}prob}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{cutoff}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{num\PYGZus{}repeats}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{num\PYGZus{}steps}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{seed}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{map\PYGZus{}x}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{map\PYGZus{}y}\PYG{p}{)}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{return} \PYG{k}{nullptr}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{try}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{Py\PYGZus{}INCREF}\PYG{p}{(}\PYG{n}{logger}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{SimulateDispersal} \PYG{n}{disp\PYGZus{}sim}\PYG{p}{;}
        \PYG{n}{disp\PYGZus{}sim}\PYG{p}{.}\PYG{n}{setDispersalParameters}\PYG{p}{(}\PYG{n}{dispersal\PYGZus{}method}\PYG{p}{,} \PYG{n}{sigma}\PYG{p}{,} \PYG{n}{tau}\PYG{p}{,} \PYG{n}{m\PYGZus{}prob}\PYG{p}{,} \PYG{n}{cutoff}\PYG{p}{,} \PYG{n}{landscape\PYGZus{}type}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{disp\PYGZus{}sim}\PYG{p}{.}\PYG{n}{setOutputDatabase}\PYG{p}{(}\PYG{n}{output\PYGZus{}database}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{disp\PYGZus{}sim}\PYG{p}{.}\PYG{n}{setSeed}\PYG{p}{(}\PYG{k}{static\PYGZus{}cast}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{unsigned} \PYG{k+kt}{long}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{n}{seed}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{disp\PYGZus{}sim}\PYG{p}{.}\PYG{n}{setNumberRepeats}\PYG{p}{(}\PYG{k}{static\PYGZus{}cast}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{unsigned} \PYG{k+kt}{long}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{n}{num\PYGZus{}repeats}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{disp\PYGZus{}sim}\PYG{p}{.}\PYG{n}{setNumberSteps}\PYG{p}{(}\PYG{k}{static\PYGZus{}cast}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{unsigned} \PYG{k+kt}{long}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{n}{num\PYGZus{}steps}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{disp\PYGZus{}sim}\PYG{p}{.}\PYG{n}{setSizes}\PYG{p}{(}\PYG{k}{static\PYGZus{}cast}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{unsigned} \PYG{k+kt}{long}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{n}{map\PYGZus{}x}\PYG{p}{)}\PYG{p}{,} \PYG{k}{static\PYGZus{}cast}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{unsigned} \PYG{k+kt}{long}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{n}{map\PYGZus{}y}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{disp\PYGZus{}sim}\PYG{p}{.}\PYG{n}{importMaps}\PYG{p}{(}\PYG{n}{map\PYGZus{}file}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{disp\PYGZus{}sim}\PYG{p}{.}\PYG{n}{runMeanDistanceTravelled}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{disp\PYGZus{}sim}\PYG{p}{.}\PYG{n}{writeDatabase}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{DISTANCES\PYGZus{}TRAVELLED}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{Py\PYGZus{}DECREF}\PYG{p}{(}\PYG{n}{logger}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{catch}\PYG{p}{(}\PYG{n}{exception} \PYG{o}{\PYGZam{}}\PYG{n}{e}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifdef DEBUG}
        \PYG{n}{writeLog}\PYG{p}{(}\PYG{l+m+mi}{50}\PYG{p}{,} \PYG{n}{e}\PYG{p}{.}\PYG{n}{what}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif }\PYG{c+c1}{// DEBUG}
        \PYG{n}{Py\PYGZus{}DECREF}\PYG{p}{(}\PYG{n}{logger}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{PyErr\PYGZus{}SetString}\PYG{p}{(}\PYG{n}{DispersalError}\PYG{p}{,} \PYG{n}{e}\PYG{p}{.}\PYG{n}{what}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{return} \PYG{k}{nullptr}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{n}{Py\PYGZus{}RETURN\PYGZus{}NONE}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}


\PYG{k}{static} \PYG{n}{PyMethodDef} \PYG{n}{DispersalMethods}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=}
\PYG{p}{\PYGZob{}}
    \PYG{p}{\PYGZob{}}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{test\PYGZus{}mean\PYGZus{}dispersal}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{test\PYGZus{}mean\PYGZus{}dispersal}\PYG{p}{,} \PYG{n}{METH\PYGZus{}VARARGS}\PYG{p}{,}
     \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Simulates the dispersal function on the provided map, recording the mean dispersal distance.}\PYG{l+s}{\PYGZdq{}}\PYG{p}{\PYGZcb{}}\PYG{p}{,}
    \PYG{p}{\PYGZob{}}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{test\PYGZus{}mean\PYGZus{}distance\PYGZus{}travelled}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{test\PYGZus{}mean\PYGZus{}distance\PYGZus{}travelled}\PYG{p}{,} \PYG{n}{METH\PYGZus{}VARARGS}\PYG{p}{,}
     \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Simulates the dispersal function on the provided map,}\PYG{l+s}{\PYGZdq{}}
             \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ recording the mean distance travelled in the number of steps.}\PYG{l+s}{\PYGZdq{}}\PYG{p}{\PYGZcb{}}\PYG{p}{,}
    \PYG{p}{\PYGZob{}}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{set\PYGZus{}log\PYGZus{}function}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{set\PYGZus{}log\PYGZus{}function}\PYG{p}{,} \PYG{n}{METH\PYGZus{}VARARGS}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{calls logging}\PYG{l+s}{\PYGZdq{}}\PYG{p}{\PYGZcb{}}\PYG{p}{,}
    \PYG{p}{\PYGZob{}}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{set\PYGZus{}logger}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{set\PYGZus{}logger}\PYG{p}{,} \PYG{n}{METH\PYGZus{}VARARGS}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Sets the logger to use}\PYG{l+s}{\PYGZdq{}}\PYG{p}{\PYGZcb{}}\PYG{p}{,}
    \PYG{p}{\PYGZob{}}\PYG{k}{nullptr}\PYG{p}{,} \PYG{k}{nullptr}\PYG{p}{,} \PYG{l+m+mi}{0} \PYG{p}{,} \PYG{k}{nullptr}\PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}

\PYG{c+c1}{// Conditional compilation for python \PYGZgt{}= 3.0 (changed how python integration worked)}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{if PY\PYGZus{}MAJOR\PYGZus{}VERSION \PYGZgt{}= 3}
\PYG{k}{static} \PYG{k+kt}{int} \PYG{n+nf}{dispersal\PYGZus{}traverse}\PYG{p}{(}\PYG{n}{PyObject} \PYG{o}{*}\PYG{n}{m}\PYG{p}{,} \PYG{n}{visitproc} \PYG{n}{visit}\PYG{p}{,} \PYG{k+kt}{void} \PYG{o}{*}\PYG{n}{arg}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{n}{Py\PYGZus{}VISIT}\PYG{p}{(}\PYG{n}{GETSTATE}\PYG{p}{(}\PYG{n}{m}\PYG{p}{)}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{error}\PYG{p}{)}\PYG{p}{;}
    \PYG{k}{return} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k}{static} \PYG{k+kt}{int} \PYG{n+nf}{dispersal\PYGZus{}clear}\PYG{p}{(}\PYG{n}{PyObject} \PYG{o}{*}\PYG{n}{m}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{n}{Py\PYGZus{}CLEAR}\PYG{p}{(}\PYG{n}{GETSTATE}\PYG{p}{(}\PYG{n}{m}\PYG{p}{)}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{error}\PYG{p}{)}\PYG{p}{;}
    \PYG{k}{return} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif}


\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{if PY\PYGZus{}MAJOR\PYGZus{}VERSION \PYGZgt{}= 3}
\PYG{k}{static} \PYG{k}{struct} \PYG{n}{PyModuleDef} \PYG{n}{moduledef} \PYG{o}{=}
\PYG{p}{\PYGZob{}}
    \PYG{n}{PyModuleDef\PYGZus{}HEAD\PYGZus{}INIT}\PYG{p}{,}
    \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{dispersalmodule}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}
    \PYG{k}{nullptr}\PYG{p}{,}
    \PYG{k}{sizeof}\PYG{p}{(}\PYG{k}{struct} \PYG{n}{module\PYGZus{}state}\PYG{p}{)}\PYG{p}{,}
    \PYG{n}{DispersalMethods}\PYG{p}{,}
    \PYG{k}{nullptr}\PYG{p}{,}
    \PYG{n}{dispersal\PYGZus{}traverse}\PYG{p}{,}
    \PYG{n}{dispersal\PYGZus{}clear}\PYG{p}{,}
    \PYG{k}{nullptr}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}


\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define INITERROR return NULL}

\PYG{n}{PyMODINIT\PYGZus{}FUNC}
\PYG{n+nf}{PyInit\PYGZus{}dispersalmodule}\PYG{p}{(}\PYG{k+kt}{void}\PYG{p}{)}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{else}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define INITERROR return}

\PYG{n}{PyMODINIT\PYGZus{}FUNC}
\PYG{n}{initdispersalmodule}\PYG{p}{(}\PYG{k+kt}{void}\PYG{p}{)}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif}
\PYG{p}{\PYGZob{}}
    \PYG{n}{PyObject} \PYG{o}{*}\PYG{n}{module}\PYG{p}{;}
    \PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{if PY\PYGZus{}MAJOR\PYGZus{}VERSION\PYGZgt{}=3}
    \PYG{n}{module} \PYG{o}{=} \PYG{n}{PyModule\PYGZus{}Create}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{moduledef}\PYG{p}{)}\PYG{p}{;}
    \PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{else}
    \PYG{n}{module} \PYG{o}{=} \PYG{n}{Py\PYGZus{}InitModule}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{dispersalmodule}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{DispersalMethods}\PYG{p}{)}\PYG{p}{;}
    \PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif}
    \PYG{k}{if}\PYG{p}{(}\PYG{n}{module} \PYG{o}{=}\PYG{o}{=} \PYG{k}{nullptr}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{INITERROR}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{c+c1}{// Threading support}
    \PYG{k}{if}\PYG{p}{(}\PYG{o}{!}\PYG{n}{PyEval\PYGZus{}ThreadsInitialized}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{PyEval\PYGZus{}InitThreads}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

    \PYG{p}{\PYGZcb{}}
    \PYG{n}{DispersalError} \PYG{o}{=} \PYG{n}{PyErr\PYGZus{}NewException}\PYG{p}{(}\PYG{p}{(}\PYG{k+kt}{char}\PYG{o}{*}\PYG{p}{)}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{dispersal.Error}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{k}{nullptr}\PYG{p}{,} \PYG{k}{nullptr}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{Py\PYGZus{}INCREF}\PYG{p}{(}\PYG{n}{DispersalError}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{PyModule\PYGZus{}AddObject}\PYG{p}{(}\PYG{n}{module}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{DispersalError}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{DispersalError}\PYG{p}{)}\PYG{p}{;}
    \PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{if PY\PYGZus{}MAJOR\PYGZus{}VERSION \PYGZgt{}= 3}
    \PYG{k}{return} \PYG{n}{module}\PYG{p}{;}
    \PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}


\subsubsection{Detailed Description}
\label{\detokenize{api/file_dispersalmodule.cpp:detailed-description}}
Samuel Thompson
BSD-3 Licence.


\subsubsection{Includes}
\label{\detokenize{api/file_dispersalmodule.cpp:includes}}\begin{itemize}
\item {} 
\sphinxcode{/Users/samthompson/Documents/PhD/Code/pycoalescence/pycoalescence/lib/necsim/Matrix.h}

\item {} 
\sphinxcode{/Users/samthompson/Documents/PhD/Code/pycoalescence/pycoalescence/lib/necsim/NRrand.h}

\item {} 
\sphinxcode{PyLogging.h} ({\hyperref[\detokenize{api/file_PyLogging.h:file-pylogging-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File PyLogging.h}}}})

\item {} 
\sphinxcode{Python.h}

\item {} 
\sphinxcode{cmath}

\item {} 
\sphinxcode{dispersalmodule.h} ({\hyperref[\detokenize{api/file_dispersalmodule.h:file-dispersalmodule-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File dispersalmodule.h}}}})

\item {} 
\sphinxcode{fstream}

\item {} 
\sphinxcode{iostream}

\item {} 
\sphinxcode{necsim/SimulateDispersal.h} ({\hyperref[\detokenize{api/file_necsim_SimulateDispersal.h:file-necsim-simulatedispersal-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File SimulateDispersal.h}}}})

\item {} 
\sphinxcode{sqlite3.h}

\item {} 
\sphinxcode{stdexcept}

\item {} 
\sphinxcode{stdio.h}

\item {} 
\sphinxcode{string}

\item {} 
\sphinxcode{vector}

\end{itemize}


\subsubsection{Functions}
\label{\detokenize{api/file_dispersalmodule.cpp:functions}}\begin{itemize}
\item {} 
{\hyperref[\detokenize{api/function_initdispersalmodule:function-initdispersalmodule}]{\sphinxcrossref{\DUrole{std,std-ref}{Function initdispersalmodule}}}}

\item {} 
{\hyperref[\detokenize{api/function_test_mean_dispersal:function-test-mean-dispersal}]{\sphinxcrossref{\DUrole{std,std-ref}{Function test\_mean\_dispersal}}}}

\item {} 
{\hyperref[\detokenize{api/function_test_mean_distance_travelled:function-test-mean-distance-travelled}]{\sphinxcrossref{\DUrole{std,std-ref}{Function test\_mean\_distance\_travelled}}}}

\end{itemize}


\subsubsection{Defines}
\label{\detokenize{api/file_dispersalmodule.cpp:defines}}\begin{itemize}
\item {} 
{\hyperref[\detokenize{api/define_INITERROR:define-initerror}]{\sphinxcrossref{\DUrole{std,std-ref}{Define INITERROR}}}}

\item {} 
{\hyperref[\detokenize{api/define_PYTHON_COMPILE:define-python-compile}]{\sphinxcrossref{\DUrole{std,std-ref}{Define PYTHON\_COMPILE}}}}

\end{itemize}


\subsubsection{Variables}
\label{\detokenize{api/file_dispersalmodule.cpp:variables}}\begin{itemize}
\item {} 
{\hyperref[\detokenize{api/variable_DispersalMethods:variable-dispersalmethods}]{\sphinxcrossref{\DUrole{std,std-ref}{Variable DispersalMethods}}}}

\item {} 
{\hyperref[\detokenize{api/variable_gstate:variable-gstate}]{\sphinxcrossref{\DUrole{std,std-ref}{Variable gstate}}}}

\item {} 
{\hyperref[\detokenize{api/variable_log_set:variable-log-set}]{\sphinxcrossref{\DUrole{std,std-ref}{Variable log\_set}}}}

\item {} 
{\hyperref[\detokenize{api/variable_logger:variable-logger}]{\sphinxcrossref{\DUrole{std,std-ref}{Variable logger}}}}

\item {} 
{\hyperref[\detokenize{api/variable_logger_set:variable-logger-set}]{\sphinxcrossref{\DUrole{std,std-ref}{Variable logger\_set}}}}

\item {} 
{\hyperref[\detokenize{api/variable_loggingmodule:variable-loggingmodule}]{\sphinxcrossref{\DUrole{std,std-ref}{Variable loggingmodule}}}}

\end{itemize}


\subsection{File dispersalmodule.h}
\label{\detokenize{api/file_dispersalmodule.h:file-dispersalmodule-h}}\label{\detokenize{api/file_dispersalmodule.h::doc}}\label{\detokenize{api/file_dispersalmodule.h:id1}}
Contains the functions for testing dispersal methods using efficient c++ routines.

\begin{sphinxShadowBox}
\sphinxstyletopictitle{Contents}
\begin{itemize}
\item {} 
\phantomsection\label{\detokenize{api/file_dispersalmodule.h:id2}}{\hyperref[\detokenize{api/file_dispersalmodule.h:definition-dispersalmodule-h}]{\sphinxcrossref{Definition (\sphinxcode{dispersalmodule.h})}}}

\item {} 
\phantomsection\label{\detokenize{api/file_dispersalmodule.h:id3}}{\hyperref[\detokenize{api/file_dispersalmodule.h:detailed-description}]{\sphinxcrossref{Detailed Description}}}

\item {} 
\phantomsection\label{\detokenize{api/file_dispersalmodule.h:id4}}{\hyperref[\detokenize{api/file_dispersalmodule.h:includes}]{\sphinxcrossref{Includes}}}

\item {} 
\phantomsection\label{\detokenize{api/file_dispersalmodule.h:id5}}{\hyperref[\detokenize{api/file_dispersalmodule.h:included-by}]{\sphinxcrossref{Included By}}}

\item {} 
\phantomsection\label{\detokenize{api/file_dispersalmodule.h:id6}}{\hyperref[\detokenize{api/file_dispersalmodule.h:classes}]{\sphinxcrossref{Classes}}}

\item {} 
\phantomsection\label{\detokenize{api/file_dispersalmodule.h:id7}}{\hyperref[\detokenize{api/file_dispersalmodule.h:functions}]{\sphinxcrossref{Functions}}}

\item {} 
\phantomsection\label{\detokenize{api/file_dispersalmodule.h:id8}}{\hyperref[\detokenize{api/file_dispersalmodule.h:defines}]{\sphinxcrossref{Defines}}}

\item {} 
\phantomsection\label{\detokenize{api/file_dispersalmodule.h:id9}}{\hyperref[\detokenize{api/file_dispersalmodule.h:variables}]{\sphinxcrossref{Variables}}}

\end{itemize}
\end{sphinxShadowBox}


\subsubsection{Definition (\sphinxstyleliteralintitle{dispersalmodule.h})}
\label{\detokenize{api/file_dispersalmodule.h:definition-dispersalmodule-h}}

\paragraph{Program Listing for File dispersalmodule.h}
\label{\detokenize{api/program_listing_file_dispersalmodule.h:program-listing-for-file-dispersalmodule-h}}\label{\detokenize{api/program_listing_file_dispersalmodule.h:program-listing-file-dispersalmodule-h}}\label{\detokenize{api/program_listing_file_dispersalmodule.h::doc}}\begin{itemize}
\item {} 
Return to documentation for {\hyperref[\detokenize{api/file_dispersalmodule.h:file-dispersalmodule-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File dispersalmodule.h}}}}

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{// This file is part of NECSim project which is released under BSD\PYGZhy{}3 license.}
\PYG{c+c1}{// See file **LICENSE.txt** or visit https://opensource.org/licenses/BSD\PYGZhy{}3\PYGZhy{}Clause) for full license details}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}Python.h\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifndef PYTHON\PYGZus{}COMPILE}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define PYTHON\PYGZus{}COMPILE}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}vector\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}string\PYGZgt{}}



\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifndef DISPERSAL\PYGZus{}IMPORT}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define DISPERSAL\PYGZus{}IMPORT}
\PYG{k}{using} \PYG{k}{namespace} \PYG{n}{std}\PYG{p}{;}
\PYG{k}{struct} \PYG{n}{module\PYGZus{}state}
\PYG{p}{\PYGZob{}}
    \PYG{n}{PyObject} \PYG{o}{*}\PYG{n}{error}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}

\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{if PY\PYGZus{}MAJOR\PYGZus{}VERSION \PYGZgt{}= 3}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define GETSTATE(m) ((struct module\PYGZus{}state*)PyModule\PYGZus{}GetState(m))}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{else}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define GETSTATE(m) (\PYGZam{}\PYGZus{}state)}
\PYG{k}{static} \PYG{k}{struct} \PYG{n}{module\PYGZus{}state} \PYG{n}{\PYGZus{}state}\PYG{p}{;}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif}

\PYG{k}{static} \PYG{n}{PyObject} \PYG{o}{*}\PYG{n}{DispersalError}\PYG{p}{;}

\PYG{c+c1}{// Conditional compilation for python \PYGZgt{}= 3.0 (changed how python integration worked)}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{if PY\PYGZus{}MAJOR\PYGZus{}VERSION \PYGZgt{}= 3}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define INITERROR return NULL}

\PYG{n}{PyMODINIT\PYGZus{}FUNC}
\PYG{n+nf}{PyInit\PYGZus{}dispersalmodule}\PYG{p}{(}\PYG{k+kt}{void}\PYG{p}{)}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{else}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define INITERROR return}

\PYG{n}{PyMODINIT\PYGZus{}FUNC}
\PYG{n}{initdispersalmodule}\PYG{p}{(}\PYG{k+kt}{void}\PYG{p}{)}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif}
\PYG{p}{;}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif}
\end{sphinxVerbatim}


\subsubsection{Detailed Description}
\label{\detokenize{api/file_dispersalmodule.h:detailed-description}}
Samuel Thompson
BSD-3 Licence.


\subsubsection{Includes}
\label{\detokenize{api/file_dispersalmodule.h:includes}}\begin{itemize}
\item {} 
\sphinxcode{Python.h}

\item {} 
\sphinxcode{string}

\item {} 
\sphinxcode{vector}

\end{itemize}


\subsubsection{Included By}
\label{\detokenize{api/file_dispersalmodule.h:included-by}}\begin{itemize}
\item {} 
{\hyperref[\detokenize{api/file_dispersalmodule.cpp:file-dispersalmodule-cpp}]{\sphinxcrossref{\DUrole{std,std-ref}{File dispersalmodule.cpp}}}}

\end{itemize}


\subsubsection{Classes}
\label{\detokenize{api/file_dispersalmodule.h:classes}}\begin{itemize}
\item {} 
{\hyperref[\detokenize{api/struct_module_state:struct-module-state}]{\sphinxcrossref{\DUrole{std,std-ref}{Struct module\_state}}}}

\end{itemize}


\subsubsection{Functions}
\label{\detokenize{api/file_dispersalmodule.h:functions}}\begin{itemize}
\item {} 
{\hyperref[\detokenize{api/function_initdispersalmodule:function-initdispersalmodule}]{\sphinxcrossref{\DUrole{std,std-ref}{Function initdispersalmodule}}}}

\end{itemize}


\subsubsection{Defines}
\label{\detokenize{api/file_dispersalmodule.h:defines}}\begin{itemize}
\item {} 
{\hyperref[\detokenize{api/define_DISPERSAL_IMPORT:define-dispersal-import}]{\sphinxcrossref{\DUrole{std,std-ref}{Define DISPERSAL\_IMPORT}}}}

\item {} 
{\hyperref[\detokenize{api/define_GETSTATE:define-getstate}]{\sphinxcrossref{\DUrole{std,std-ref}{Define GETSTATE}}}}

\item {} 
{\hyperref[\detokenize{api/define_INITERROR:define-initerror}]{\sphinxcrossref{\DUrole{std,std-ref}{Define INITERROR}}}}

\end{itemize}


\subsubsection{Variables}
\label{\detokenize{api/file_dispersalmodule.h:variables}}\begin{itemize}
\item {} 
{\hyperref[\detokenize{api/variable__state:variable-state}]{\sphinxcrossref{\DUrole{std,std-ref}{Variable \_state}}}}

\item {} 
{\hyperref[\detokenize{api/variable_DispersalError:variable-dispersalerror}]{\sphinxcrossref{\DUrole{std,std-ref}{Variable DispersalError}}}}

\end{itemize}


\subsection{File Filesystem.cpp}
\label{\detokenize{api/file_necsim_Filesystem.cpp:file-filesystem-cpp}}\label{\detokenize{api/file_necsim_Filesystem.cpp::doc}}\label{\detokenize{api/file_necsim_Filesystem.cpp:file-necsim-filesystem-cpp}}
Contains routines for checking files and folder exist, opening sqlite databases safely, with support for various virtual filesystems, and checking parents of a file exist.

\begin{sphinxShadowBox}
\sphinxstyletopictitle{Contents}
\begin{itemize}
\item {} 
\phantomsection\label{\detokenize{api/file_necsim_Filesystem.cpp:id1}}{\hyperref[\detokenize{api/file_necsim_Filesystem.cpp:definition-necsim-filesystem-cpp}]{\sphinxcrossref{Definition (\sphinxcode{necsim/Filesystem.cpp})}}}

\item {} 
\phantomsection\label{\detokenize{api/file_necsim_Filesystem.cpp:id2}}{\hyperref[\detokenize{api/file_necsim_Filesystem.cpp:detailed-description}]{\sphinxcrossref{Detailed Description}}}

\item {} 
\phantomsection\label{\detokenize{api/file_necsim_Filesystem.cpp:id3}}{\hyperref[\detokenize{api/file_necsim_Filesystem.cpp:includes}]{\sphinxcrossref{Includes}}}

\item {} 
\phantomsection\label{\detokenize{api/file_necsim_Filesystem.cpp:id4}}{\hyperref[\detokenize{api/file_necsim_Filesystem.cpp:functions}]{\sphinxcrossref{Functions}}}

\end{itemize}
\end{sphinxShadowBox}


\subsubsection{Definition (\sphinxstyleliteralintitle{necsim/Filesystem.cpp})}
\label{\detokenize{api/file_necsim_Filesystem.cpp:definition-necsim-filesystem-cpp}}

\paragraph{Program Listing for File Filesystem.cpp}
\label{\detokenize{api/program_listing_file_necsim_Filesystem.cpp:program-listing-for-file-filesystem-cpp}}\label{\detokenize{api/program_listing_file_necsim_Filesystem.cpp::doc}}\label{\detokenize{api/program_listing_file_necsim_Filesystem.cpp:program-listing-file-necsim-filesystem-cpp}}\begin{itemize}
\item {} 
Return to documentation for {\hyperref[\detokenize{api/file_necsim_Filesystem.cpp:file-necsim-filesystem-cpp}]{\sphinxcrossref{\DUrole{std,std-ref}{File Filesystem.cpp}}}}

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{// This file is part of NECSim project which is released under BSD\PYGZhy{}3 license.}
\PYG{c+c1}{// See file **LICENSE.txt** or visit https://opensource.org/licenses/BSD\PYGZhy{}3\PYGZhy{}Clause) for full license details.}

\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}string\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}sstream\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}zconf.h\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}boost/filesystem.hpp\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZdq{}Filesystem.h\PYGZdq{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZdq{}CustomExceptions.h\PYGZdq{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZdq{}Logging.h\PYGZdq{}}

\PYG{k+kt}{void} \PYG{n+nf}{openSQLiteDatabase}\PYG{p}{(}\PYG{k}{const} \PYG{n}{string} \PYG{o}{\PYGZam{}}\PYG{n}{database\PYGZus{}name}\PYG{p}{,} \PYG{n}{sqlite3} \PYG{o}{*} \PYG{o}{\PYGZam{}}\PYG{n}{database}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k+kt}{int} \PYG{n}{rc}\PYG{p}{;}
    \PYG{k}{if}\PYG{p}{(}\PYG{n}{database\PYGZus{}name} \PYG{o}{=}\PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{:memory:}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{rc} \PYG{o}{=} \PYG{n}{sqlite3\PYGZus{}open}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{:memory:}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{database}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{rc} \PYG{o}{!}\PYG{o}{=} \PYG{n}{SQLITE\PYGZus{}OK} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{n}{rc} \PYG{o}{!}\PYG{o}{=} \PYG{n}{SQLITE\PYGZus{}DONE}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{stringstream} \PYG{n}{ss}\PYG{p}{;}
            \PYG{n}{ss} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Could not connect to in\PYGZhy{}memory database. Error: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{rc} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
            \PYG{n}{ss} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ (}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{sqlite3\PYGZus{}errmsg}\PYG{p}{(}\PYG{n}{database}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{)}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
            \PYG{k}{throw} \PYG{n}{FatalException}\PYG{p}{(}\PYG{n}{ss}\PYG{p}{.}\PYG{n}{str}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
    \PYG{p}{\PYGZcb{}}
    \PYG{n}{rc} \PYG{o}{=} \PYG{n}{sqlite3\PYGZus{}open\PYGZus{}v2}\PYG{p}{(}\PYG{n}{database\PYGZus{}name}\PYG{p}{.}\PYG{n}{c\PYGZus{}str}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{database}\PYG{p}{,} \PYG{n}{SQLITE\PYGZus{}OPEN\PYGZus{}READWRITE} \PYG{o}{\textbar{}} \PYG{n}{SQLITE\PYGZus{}OPEN\PYGZus{}CREATE}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{unix\PYGZhy{}dotfile}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{k}{if}\PYG{p}{(}\PYG{n}{rc} \PYG{o}{!}\PYG{o}{=} \PYG{n}{SQLITE\PYGZus{}OK} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{n}{rc} \PYG{o}{!}\PYG{o}{=} \PYG{n}{SQLITE\PYGZus{}DONE}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
        \PYG{k}{while}\PYG{p}{(}\PYG{p}{(}\PYG{n}{rc} \PYG{o}{!}\PYG{o}{=} \PYG{n}{SQLITE\PYGZus{}OK} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{n}{rc} \PYG{o}{!}\PYG{o}{=} \PYG{n}{SQLITE\PYGZus{}DONE}\PYG{p}{)} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{10}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{;}
            \PYG{n}{sleep}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
            \PYG{n}{rc} \PYG{o}{=} \PYG{n}{sqlite3\PYGZus{}open\PYGZus{}v2}\PYG{p}{(}\PYG{n}{database\PYGZus{}name}\PYG{p}{.}\PYG{n}{c\PYGZus{}str}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{database}\PYG{p}{,} \PYG{n}{SQLITE\PYGZus{}OPEN\PYGZus{}READWRITE} \PYG{o}{\textbar{}} \PYG{n}{SQLITE\PYGZus{}OPEN\PYGZus{}CREATE}\PYG{p}{,}
                                 \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{unix\PYGZhy{}dotfile}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{c+c1}{// Attempt different opening method if the first fails.}
        \PYG{k+kt}{int} \PYG{n}{j} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
        \PYG{k}{while}\PYG{p}{(}\PYG{p}{(}\PYG{n}{rc} \PYG{o}{!}\PYG{o}{=} \PYG{n}{SQLITE\PYGZus{}OK} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{n}{rc} \PYG{o}{!}\PYG{o}{=} \PYG{n}{SQLITE\PYGZus{}DONE}\PYG{p}{)} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{n}{j} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{10}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{j}\PYG{o}{+}\PYG{o}{+}\PYG{p}{;}
            \PYG{n}{sleep}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
            \PYG{n}{rc} \PYG{o}{=} \PYG{n}{sqlite3\PYGZus{}open}\PYG{p}{(}\PYG{n}{database\PYGZus{}name}\PYG{p}{.}\PYG{n}{c\PYGZus{}str}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{database}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{rc} \PYG{o}{!}\PYG{o}{=} \PYG{n}{SQLITE\PYGZus{}OK} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{n}{rc} \PYG{o}{!}\PYG{o}{=} \PYG{n}{SQLITE\PYGZus{}DONE}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{stringstream} \PYG{n}{ss}\PYG{p}{;}
            \PYG{n}{ss} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ERROR\PYGZus{}SQL\PYGZus{}010: SQLite database file could not be opened. Check the folder exists and you }\PYG{l+s}{\PYGZdq{}}
                    \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{have write permissions. (REF1) Error code: }\PYG{l+s}{\PYGZdq{}}
                 \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{rc} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
            \PYG{n}{ss} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ Attempted call }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{max}\PYG{p}{(}\PYG{n}{i}\PYG{p}{,} \PYG{n}{j}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ times}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
            \PYG{k}{throw} \PYG{n}{FatalException}\PYG{p}{(}\PYG{n}{ss}\PYG{p}{.}\PYG{n}{str}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
    \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{void} \PYG{n+nf}{createParent}\PYG{p}{(}\PYG{k}{const} \PYG{n}{string} \PYG{o}{\PYGZam{}}\PYG{n}{file}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{n}{boost}\PYG{o}{:}\PYG{o}{:}\PYG{n}{filesystem}\PYG{o}{:}\PYG{o}{:}\PYG{n}{path} \PYG{n}{file\PYGZus{}path}\PYG{p}{(}\PYG{n}{file}\PYG{p}{)}\PYG{p}{;}
    \PYG{k}{if}\PYG{p}{(}\PYG{o}{!}\PYG{n}{boost}\PYG{o}{:}\PYG{o}{:}\PYG{n}{filesystem}\PYG{o}{:}\PYG{o}{:}\PYG{n}{exists}\PYG{p}{(}\PYG{n}{file\PYGZus{}path}\PYG{p}{.}\PYG{n}{parent\PYGZus{}path}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{if}\PYG{p}{(}\PYG{o}{!}\PYG{n}{boost}\PYG{o}{:}\PYG{o}{:}\PYG{n}{filesystem}\PYG{o}{:}\PYG{o}{:}\PYG{n}{create\PYGZus{}directories}\PYG{p}{(}\PYG{n}{file\PYGZus{}path}\PYG{p}{.}\PYG{n}{parent\PYGZus{}path}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{k}{throw} \PYG{n}{FatalException}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Cannot create parent folder for }\PYG{l+s}{\PYGZdq{}} \PYG{o}{+} \PYG{n}{file}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
    \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}



\PYG{k+kt}{bool} \PYG{n+nf}{doesExist}\PYG{p}{(}\PYG{n}{string} \PYG{n}{testfile}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k}{if}\PYG{p}{(}\PYG{n}{boost}\PYG{o}{:}\PYG{o}{:}\PYG{n}{filesystem}\PYG{o}{:}\PYG{o}{:}\PYG{n}{exists}\PYG{p}{(}\PYG{n}{testfile}\PYG{p}{)}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{stringstream} \PYG{n}{os}\PYG{p}{;}
        \PYG{n}{os} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}r}\PYG{l+s}{Checking folder existance...}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{testfile} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ exists!               }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
        \PYG{n}{writeInfo}\PYG{p}{(}\PYG{n}{os}\PYG{p}{.}\PYG{n}{str}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{return} \PYG{n+nb}{true}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{else}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{throw} \PYG{n}{runtime\PYGZus{}error}\PYG{p}{(}\PYG{n}{string}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ERROR\PYGZus{}MAIN\PYGZus{}008: FATAL. Input or output folder does not exist: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{+} \PYG{n}{testfile} \PYG{o}{+} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{.}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{bool} \PYG{n+nf}{doesExistNull}\PYG{p}{(}\PYG{n}{string} \PYG{n}{testfile}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k}{return} \PYG{n}{testfile} \PYG{o}{=}\PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{null}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\textbar{}}\PYG{o}{\textbar{}} \PYG{n}{testfile} \PYG{o}{=}\PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{none}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\textbar{}}\PYG{o}{\textbar{}} \PYG{n}{doesExist}\PYG{p}{(}\PYG{n}{testfile}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n+nf}{cantorPairing}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{x1}\PYG{p}{,} \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{x2}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k}{return} \PYG{p}{(}\PYG{p}{(}\PYG{n}{x1} \PYG{o}{+} \PYG{n}{x2}\PYG{p}{)} \PYG{o}{*} \PYG{p}{(}\PYG{n}{x1} \PYG{o}{+} \PYG{n}{x2} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{p}{)} \PYG{o}{+} \PYG{n}{x2}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}


\subsubsection{Detailed Description}
\label{\detokenize{api/file_necsim_Filesystem.cpp:detailed-description}}
Samuel Thompson
19/07/2017
BSD-3 Licence. Contact: \sphinxhref{mailto:samuel.thompson14@imperial.ac.uk}{samuel.thompson14@imperial.ac.uk} or \sphinxhref{mailto:thompsonsed@gmail.com}{thompsonsed@gmail.com}


\subsubsection{Includes}
\label{\detokenize{api/file_necsim_Filesystem.cpp:includes}}\begin{itemize}
\item {} 
\sphinxcode{CustomExceptions.h} ({\hyperref[\detokenize{api/file_necsim_CustomExceptions.h:file-necsim-customexceptions-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File CustomExceptions.h}}}})

\item {} 
\sphinxcode{Filesystem.h} ({\hyperref[\detokenize{api/file_necsim_Filesystem.h:file-necsim-filesystem-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File Filesystem.h}}}})

\item {} 
\sphinxcode{Logging.h} ({\hyperref[\detokenize{api/file_necsim_Logging.h:file-necsim-logging-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File Logging.h}}}})

\item {} 
\sphinxcode{boost/filesystem.hpp}

\item {} 
\sphinxcode{sstream}

\item {} 
\sphinxcode{string}

\item {} 
\sphinxcode{zconf.h}

\end{itemize}


\subsubsection{Functions}
\label{\detokenize{api/file_necsim_Filesystem.cpp:functions}}\begin{itemize}
\item {} 
{\hyperref[\detokenize{api/function_cantorPairing:function-cantorpairing}]{\sphinxcrossref{\DUrole{std,std-ref}{Function cantorPairing}}}}

\item {} 
{\hyperref[\detokenize{api/function_createParent:function-createparent}]{\sphinxcrossref{\DUrole{std,std-ref}{Function createParent}}}}

\item {} 
{\hyperref[\detokenize{api/function_doesExist:function-doesexist}]{\sphinxcrossref{\DUrole{std,std-ref}{Function doesExist}}}}

\item {} 
{\hyperref[\detokenize{api/function_doesExistNull:function-doesexistnull}]{\sphinxcrossref{\DUrole{std,std-ref}{Function doesExistNull}}}}

\item {} 
{\hyperref[\detokenize{api/function_openSQLiteDatabase:function-opensqlitedatabase}]{\sphinxcrossref{\DUrole{std,std-ref}{Function openSQLiteDatabase}}}}

\end{itemize}


\subsection{File Filesystem.h}
\label{\detokenize{api/file_necsim_Filesystem.h:file-filesystem-h}}\label{\detokenize{api/file_necsim_Filesystem.h::doc}}\label{\detokenize{api/file_necsim_Filesystem.h:file-necsim-filesystem-h}}
Contains routines for checking files and folder exist, opening sqlite databases safely, with support for various virtual filesystems, and checking parents of a file exist.

\begin{sphinxShadowBox}
\sphinxstyletopictitle{Contents}
\begin{itemize}
\item {} 
\phantomsection\label{\detokenize{api/file_necsim_Filesystem.h:id1}}{\hyperref[\detokenize{api/file_necsim_Filesystem.h:definition-necsim-filesystem-h}]{\sphinxcrossref{Definition (\sphinxcode{necsim/Filesystem.h})}}}

\item {} 
\phantomsection\label{\detokenize{api/file_necsim_Filesystem.h:id2}}{\hyperref[\detokenize{api/file_necsim_Filesystem.h:detailed-description}]{\sphinxcrossref{Detailed Description}}}

\item {} 
\phantomsection\label{\detokenize{api/file_necsim_Filesystem.h:id3}}{\hyperref[\detokenize{api/file_necsim_Filesystem.h:includes}]{\sphinxcrossref{Includes}}}

\item {} 
\phantomsection\label{\detokenize{api/file_necsim_Filesystem.h:id4}}{\hyperref[\detokenize{api/file_necsim_Filesystem.h:included-by}]{\sphinxcrossref{Included By}}}

\item {} 
\phantomsection\label{\detokenize{api/file_necsim_Filesystem.h:id5}}{\hyperref[\detokenize{api/file_necsim_Filesystem.h:functions}]{\sphinxcrossref{Functions}}}

\end{itemize}
\end{sphinxShadowBox}


\subsubsection{Definition (\sphinxstyleliteralintitle{necsim/Filesystem.h})}
\label{\detokenize{api/file_necsim_Filesystem.h:definition-necsim-filesystem-h}}

\paragraph{Program Listing for File Filesystem.h}
\label{\detokenize{api/program_listing_file_necsim_Filesystem.h:program-listing-for-file-filesystem-h}}\label{\detokenize{api/program_listing_file_necsim_Filesystem.h::doc}}\label{\detokenize{api/program_listing_file_necsim_Filesystem.h:program-listing-file-necsim-filesystem-h}}\begin{itemize}
\item {} 
Return to documentation for {\hyperref[\detokenize{api/file_necsim_Filesystem.h:file-necsim-filesystem-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File Filesystem.h}}}}

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{// This file is part of NECSim project which is released under BSD\PYGZhy{}3 license.}
\PYG{c+c1}{// See file **LICENSE.txt** or visit https://opensource.org/licenses/BSD\PYGZhy{}3\PYGZhy{}Clause) for full license details.}

\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}sqlite3.h\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}string\PYGZgt{}}

\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifndef SPECIATIONCOUNTER\PYGZus{}FILESYSTEM\PYGZus{}H}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define SPECIATIONCOUNTER\PYGZus{}FILESYSTEM\PYGZus{}H}

\PYG{k}{using} \PYG{k}{namespace} \PYG{n}{std}\PYG{p}{;}

\PYG{k+kt}{void} \PYG{n+nf}{openSQLiteDatabase}\PYG{p}{(}\PYG{k}{const} \PYG{n}{string} \PYG{o}{\PYGZam{}}\PYG{n}{database\PYGZus{}name}\PYG{p}{,} \PYG{n}{sqlite3} \PYG{o}{*}\PYG{o}{\PYGZam{}} \PYG{n}{database}\PYG{p}{)}\PYG{p}{;}

\PYG{k+kt}{void} \PYG{n+nf}{createParent}\PYG{p}{(}\PYG{k}{const} \PYG{n}{string} \PYG{o}{\PYGZam{}}\PYG{n}{file}\PYG{p}{)}\PYG{p}{;}


\PYG{k+kt}{bool} \PYG{n+nf}{doesExist}\PYG{p}{(}\PYG{n}{string} \PYG{n}{testfile}\PYG{p}{)}\PYG{p}{;}

\PYG{k+kt}{bool} \PYG{n+nf}{doesExistNull}\PYG{p}{(}\PYG{n}{string} \PYG{n}{testfile}\PYG{p}{)}\PYG{p}{;}

\PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n+nf}{cantorPairing}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{x1}\PYG{p}{,} \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{x2}\PYG{p}{)}\PYG{p}{;}

\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif }\PYG{c+c1}{//SPECIATIONCOUNTER\PYGZus{}FILESYSTEM\PYGZus{}H}
\end{sphinxVerbatim}


\subsubsection{Detailed Description}
\label{\detokenize{api/file_necsim_Filesystem.h:detailed-description}}
Samuel Thompson
19/07/2017
BSD-3 Licence. Contact: \sphinxhref{mailto:samuel.thompson14@imperial.ac.uk}{samuel.thompson14@imperial.ac.uk} or \sphinxhref{mailto:thompsonsed@gmail.com}{thompsonsed@gmail.com}


\subsubsection{Includes}
\label{\detokenize{api/file_necsim_Filesystem.h:includes}}\begin{itemize}
\item {} 
\sphinxcode{sqlite3.h}

\item {} 
\sphinxcode{string}

\end{itemize}


\subsubsection{Included By}
\label{\detokenize{api/file_necsim_Filesystem.h:included-by}}\begin{itemize}
\item {} 
{\hyperref[\detokenize{api/file_necsim_Community.cpp:file-necsim-community-cpp}]{\sphinxcrossref{\DUrole{std,std-ref}{File Community.cpp}}}}

\item {} 
{\hyperref[\detokenize{api/file_necsim_Filesystem.cpp:file-necsim-filesystem-cpp}]{\sphinxcrossref{\DUrole{std,std-ref}{File Filesystem.cpp}}}}

\item {} 
{\hyperref[\detokenize{api/file_necsim_LogFile.cpp:file-necsim-logfile-cpp}]{\sphinxcrossref{\DUrole{std,std-ref}{File LogFile.cpp}}}}

\item {} 
{\hyperref[\detokenize{api/file_necsim_Tree.h:file-necsim-tree-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File Tree.h}}}}

\item {} 
{\hyperref[\detokenize{api/file_necsim_Map.cpp:file-necsim-map-cpp}]{\sphinxcrossref{\DUrole{std,std-ref}{File Map.cpp}}}}

\item {} 
{\hyperref[\detokenize{api/file_necsim_SimulateDispersal.cpp:file-necsim-simulatedispersal-cpp}]{\sphinxcrossref{\DUrole{std,std-ref}{File SimulateDispersal.cpp}}}}

\end{itemize}


\subsubsection{Functions}
\label{\detokenize{api/file_necsim_Filesystem.h:functions}}\begin{itemize}
\item {} 
{\hyperref[\detokenize{api/function_cantorPairing:function-cantorpairing}]{\sphinxcrossref{\DUrole{std,std-ref}{Function cantorPairing}}}}

\item {} 
{\hyperref[\detokenize{api/function_createParent:function-createparent}]{\sphinxcrossref{\DUrole{std,std-ref}{Function createParent}}}}

\item {} 
{\hyperref[\detokenize{api/function_doesExist:function-doesexist}]{\sphinxcrossref{\DUrole{std,std-ref}{Function doesExist}}}}

\item {} 
{\hyperref[\detokenize{api/function_doesExistNull:function-doesexistnull}]{\sphinxcrossref{\DUrole{std,std-ref}{Function doesExistNull}}}}

\item {} 
{\hyperref[\detokenize{api/function_openSQLiteDatabase:function-opensqlitedatabase}]{\sphinxcrossref{\DUrole{std,std-ref}{Function openSQLiteDatabase}}}}

\end{itemize}


\subsection{File LicenseHeader.h}
\label{\detokenize{api/file_necsim_LicenseHeader.h:file-licenseheader-h}}\label{\detokenize{api/file_necsim_LicenseHeader.h::doc}}\label{\detokenize{api/file_necsim_LicenseHeader.h:file-necsim-licenseheader-h}}
\begin{sphinxShadowBox}
\sphinxstyletopictitle{Contents}
\begin{itemize}
\item {} 
\phantomsection\label{\detokenize{api/file_necsim_LicenseHeader.h:id1}}{\hyperref[\detokenize{api/file_necsim_LicenseHeader.h:definition-necsim-licenseheader-h}]{\sphinxcrossref{Definition (\sphinxcode{necsim/LicenseHeader.h})}}}

\end{itemize}
\end{sphinxShadowBox}


\subsubsection{Definition (\sphinxstyleliteralintitle{necsim/LicenseHeader.h})}
\label{\detokenize{api/file_necsim_LicenseHeader.h:definition-necsim-licenseheader-h}}

\paragraph{Program Listing for File LicenseHeader.h}
\label{\detokenize{api/program_listing_file_necsim_LicenseHeader.h::doc}}\label{\detokenize{api/program_listing_file_necsim_LicenseHeader.h:program-listing-file-necsim-licenseheader-h}}\label{\detokenize{api/program_listing_file_necsim_LicenseHeader.h:program-listing-for-file-licenseheader-h}}\begin{itemize}
\item {} 
Return to documentation for {\hyperref[\detokenize{api/file_necsim_LicenseHeader.h:file-necsim-licenseheader-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File LicenseHeader.h}}}}

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{//This file is part of Coalescence\PYGZus{}Sim project which is released under BSD\PYGZhy{}3 license.}
\PYG{c+c1}{//See file **LICENSE.txt** or visit https://opensource.org/licenses/BSD\PYGZhy{}3\PYGZhy{}Clause) for full license details.}
\end{sphinxVerbatim}


\subsection{File LogFile.cpp}
\label{\detokenize{api/file_necsim_LogFile.cpp:file-necsim-logfile-cpp}}\label{\detokenize{api/file_necsim_LogFile.cpp:file-logfile-cpp}}\label{\detokenize{api/file_necsim_LogFile.cpp::doc}}
Contains a class for logging to a logfile, including reporting level and timestamps.

\begin{sphinxShadowBox}
\sphinxstyletopictitle{Contents}
\begin{itemize}
\item {} 
\phantomsection\label{\detokenize{api/file_necsim_LogFile.cpp:id1}}{\hyperref[\detokenize{api/file_necsim_LogFile.cpp:definition-necsim-logfile-cpp}]{\sphinxcrossref{Definition (\sphinxcode{necsim/LogFile.cpp})}}}

\item {} 
\phantomsection\label{\detokenize{api/file_necsim_LogFile.cpp:id2}}{\hyperref[\detokenize{api/file_necsim_LogFile.cpp:detailed-description}]{\sphinxcrossref{Detailed Description}}}

\item {} 
\phantomsection\label{\detokenize{api/file_necsim_LogFile.cpp:id3}}{\hyperref[\detokenize{api/file_necsim_LogFile.cpp:includes}]{\sphinxcrossref{Includes}}}

\item {} 
\phantomsection\label{\detokenize{api/file_necsim_LogFile.cpp:id4}}{\hyperref[\detokenize{api/file_necsim_LogFile.cpp:functions}]{\sphinxcrossref{Functions}}}

\end{itemize}
\end{sphinxShadowBox}


\subsubsection{Definition (\sphinxstyleliteralintitle{necsim/LogFile.cpp})}
\label{\detokenize{api/file_necsim_LogFile.cpp:definition-necsim-logfile-cpp}}

\paragraph{Program Listing for File LogFile.cpp}
\label{\detokenize{api/program_listing_file_necsim_LogFile.cpp:program-listing-file-necsim-logfile-cpp}}\label{\detokenize{api/program_listing_file_necsim_LogFile.cpp:program-listing-for-file-logfile-cpp}}\label{\detokenize{api/program_listing_file_necsim_LogFile.cpp::doc}}\begin{itemize}
\item {} 
Return to documentation for {\hyperref[\detokenize{api/file_necsim_LogFile.cpp:file-necsim-logfile-cpp}]{\sphinxcrossref{\DUrole{std,std-ref}{File LogFile.cpp}}}}

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{// This file is part of NECSim project which is released under BSD\PYGZhy{}3 license.}
\PYG{c+c1}{// See file **LICENSE.txt** or visit https://opensource.org/licenses/BSD\PYGZhy{}3\PYGZhy{}Clause) for full license details.}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}sstream\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}iomanip\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}boost/filesystem.hpp\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZdq{}LogFile.h\PYGZdq{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZdq{}Filesystem.h\PYGZdq{}}

\PYG{n}{string} \PYG{n+nf}{getTime}\PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifdef DEBUG}
    \PYG{k}{auto} \PYG{n}{t} \PYG{o}{=} \PYG{n}{time}\PYG{p}{(}\PYG{k}{nullptr}\PYG{p}{)}\PYG{p}{;}
    \PYG{k}{auto} \PYG{n}{tm} \PYG{o}{=} \PYG{o}{*}\PYG{n}{localtime}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{t}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{stringstream} \PYG{n}{ss}\PYG{p}{;}
    \PYG{n}{ss} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{put\PYGZus{}time}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{tm}\PYG{p}{,} \PYG{n}{LOGNAME\PYGZus{}FORMAT}\PYG{p}{)}\PYG{p}{;}
    \PYG{k}{return} \PYG{n}{ss}\PYG{p}{.}\PYG{n}{str}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif}
    \PYG{k}{return} \PYG{n}{string}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{n}{string} \PYG{n+nf}{getDefaultLogFile}\PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k+kt}{time\PYGZus{}t} \PYG{n}{now} \PYG{o}{=} \PYG{n}{time}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}
    \PYG{k}{static} \PYG{k+kt}{char} \PYG{n}{name}\PYG{p}{[}\PYG{l+m+mi}{30}\PYG{p}{]}\PYG{p}{;}
    \PYG{n}{strftime}\PYG{p}{(}\PYG{n}{name}\PYG{p}{,} \PYG{k}{sizeof}\PYG{p}{(}\PYG{n}{name}\PYG{p}{)}\PYG{p}{,} \PYG{n}{LOGNAME\PYGZus{}FORMAT}\PYG{p}{,} \PYG{n}{localtime}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{now}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{string} \PYG{n}{out} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{log/}\PYG{l+s}{\PYGZdq{}} \PYG{o}{+} \PYG{n}{string}\PYG{p}{(}\PYG{n}{name}\PYG{p}{)} \PYG{o}{+} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{.log}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
    \PYG{k}{return} \PYG{n}{out}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{void} \PYG{n+nf}{getUniqueFileName}\PYG{p}{(}\PYG{n}{string} \PYG{o}{\PYGZam{}}\PYG{n}{basic\PYGZus{}string}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{n}{boost}\PYG{o}{:}\PYG{o}{:}\PYG{n}{filesystem}\PYG{o}{:}\PYG{o}{:}\PYG{n}{path} \PYG{n}{file\PYGZus{}path}\PYG{p}{(}\PYG{n}{basic\PYGZus{}string}\PYG{p}{)}\PYG{p}{;}
    \PYG{k}{const} \PYG{n}{string} \PYG{n}{file\PYGZus{}name} \PYG{o}{=} \PYG{n}{basic\PYGZus{}string}\PYG{p}{.}\PYG{n}{substr}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{basic\PYGZus{}string}\PYG{p}{.}\PYG{n}{find}\PYG{p}{(}\PYG{l+s+sc}{\PYGZsq{}}\PYG{l+s+sc}{.}\PYG{l+s+sc}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
    \PYG{k}{const} \PYG{n}{string} \PYG{n}{file\PYGZus{}extension} \PYG{o}{=} \PYG{n}{basic\PYGZus{}string}\PYG{p}{.}\PYG{n}{substr}\PYG{p}{(}\PYG{n}{basic\PYGZus{}string}\PYG{p}{.}\PYG{n}{find}\PYG{p}{(}\PYG{l+s+sc}{\PYGZsq{}}\PYG{l+s+sc}{.}\PYG{l+s+sc}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{iterator} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
    \PYG{k}{while}\PYG{p}{(}\PYG{n}{boost}\PYG{o}{:}\PYG{o}{:}\PYG{n}{filesystem}\PYG{o}{:}\PYG{o}{:}\PYG{n}{exists}\PYG{p}{(}\PYG{n}{file\PYGZus{}path}\PYG{p}{)} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{n}{iterator} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{10000000}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{iterator} \PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{10000000}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{basic\PYGZus{}string} \PYG{o}{=} \PYG{n}{file\PYGZus{}name} \PYG{o}{+} \PYG{n}{file\PYGZus{}extension}\PYG{p}{;}
            \PYG{k}{throw} \PYG{n}{FatalException}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Could not create unique file name after 10000000 tries.}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{n}{basic\PYGZus{}string} \PYG{o}{=} \PYG{n}{file\PYGZus{}name} \PYG{o}{+} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZus{}}\PYG{l+s}{\PYGZdq{}} \PYG{o}{+} \PYG{n}{to\PYGZus{}string}\PYG{p}{(}\PYG{n}{iterator}\PYG{p}{)} \PYG{o}{+} \PYG{n}{file\PYGZus{}extension}\PYG{p}{;} \PYG{c+c1}{// NOLINT}
        \PYG{n}{file\PYGZus{}path} \PYG{o}{=} \PYG{n}{boost}\PYG{o}{:}\PYG{o}{:}\PYG{n}{filesystem}\PYG{o}{:}\PYG{o}{:}\PYG{n}{path}\PYG{p}{(}\PYG{n}{basic\PYGZus{}string}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{iterator} \PYG{o}{+}\PYG{o}{+}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\PYG{n}{LogFile}\PYG{o}{:}\PYG{o}{:}\PYG{n}{LogFile}\PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{n}{init}\PYG{p}{(}\PYG{n}{getDefaultLogFile}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{n}{LogFile}\PYG{o}{:}\PYG{o}{:}\PYG{n}{LogFile}\PYG{p}{(}\PYG{k}{const} \PYG{n}{string} \PYG{o}{\PYGZam{}}\PYG{n}{file\PYGZus{}name\PYGZus{}in}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{n}{init}\PYG{p}{(}\PYG{n}{file\PYGZus{}name\PYGZus{}in}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}


\PYG{n}{LogFile}\PYG{o}{:}\PYG{o}{:}\PYG{o}{\PYGZti{}}\PYG{n}{LogFile}\PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}

    \PYG{n}{output\PYGZus{}stream} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{getTime}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ LOGGING ENDED}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
    \PYG{n}{output\PYGZus{}stream}\PYG{p}{.}\PYG{n}{close}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}


\PYG{k+kt}{void} \PYG{n}{LogFile}\PYG{o}{:}\PYG{o}{:}\PYG{n}{init}\PYG{p}{(}\PYG{k}{const} \PYG{n}{string} \PYG{o}{\PYGZam{}}\PYG{n}{file\PYGZus{}name\PYGZus{}in}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{n}{createParent}\PYG{p}{(}\PYG{n}{file\PYGZus{}name\PYGZus{}in}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{file\PYGZus{}name} \PYG{o}{=} \PYG{n}{file\PYGZus{}name\PYGZus{}in}\PYG{p}{;}
    \PYG{n}{getUniqueFileName}\PYG{p}{(}\PYG{n}{file\PYGZus{}name}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{output\PYGZus{}stream}\PYG{p}{.}\PYG{n}{open}\PYG{p}{(}\PYG{n}{file\PYGZus{}name}\PYG{p}{)}\PYG{p}{;}
    \PYG{k}{if}\PYG{p}{(}\PYG{o}{!}\PYG{n}{output\PYGZus{}stream}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{throw} \PYG{n}{FatalException}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Could not create log file at }\PYG{l+s}{\PYGZdq{}} \PYG{o}{+} \PYG{n}{file\PYGZus{}name\PYGZus{}in} \PYG{o}{+} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{.}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{n}{levels\PYGZus{}map}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{noneset}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
    \PYG{n}{levels\PYGZus{}map}\PYG{p}{[}\PYG{l+m+mi}{10}\PYG{p}{]} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{debug}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
    \PYG{n}{levels\PYGZus{}map}\PYG{p}{[}\PYG{l+m+mi}{20}\PYG{p}{]} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{info}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
    \PYG{n}{levels\PYGZus{}map}\PYG{p}{[}\PYG{l+m+mi}{30}\PYG{p}{]} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{warning}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
    \PYG{n}{levels\PYGZus{}map}\PYG{p}{[}\PYG{l+m+mi}{40}\PYG{p}{]} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{error}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
    \PYG{n}{levels\PYGZus{}map}\PYG{p}{[}\PYG{l+m+mi}{50}\PYG{p}{]} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{critical}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
    \PYG{n}{output\PYGZus{}stream} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{getTime}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ LOGGING STARTED}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{void} \PYG{n}{LogFile}\PYG{o}{:}\PYG{o}{:}\PYG{n}{write}\PYG{p}{(}\PYG{k}{const} \PYG{k+kt}{int} \PYG{o}{\PYGZam{}}\PYG{n}{level}\PYG{p}{,} \PYG{n}{string} \PYG{n}{message}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k}{if}\PYG{p}{(}\PYG{n}{levels\PYGZus{}map}\PYG{p}{.}\PYG{n}{count}\PYG{p}{(}\PYG{n}{level}\PYG{p}{)} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{throw} \PYG{n}{FatalException}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Logging level must be one of 0, 10, 20, 30, 40 or 50.}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{n}{output\PYGZus{}stream} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{getTime}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
    \PYG{n}{replace}\PYG{p}{(}\PYG{n}{message}\PYG{p}{.}\PYG{n}{begin}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{n}{message}\PYG{p}{.}\PYG{n}{end}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{l+s+sc}{\PYGZsq{}}\PYG{l+s+sc}{\PYGZbs{}n}\PYG{l+s+sc}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+sc}{\PYGZsq{}}\PYG{l+s+sc}{ }\PYG{l+s+sc}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{output\PYGZus{}stream} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{levels\PYGZus{}map}\PYG{p}{[}\PYG{n}{level}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{message} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}

\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{void} \PYG{n}{LogFile}\PYG{o}{:}\PYG{o}{:}\PYG{n}{write}\PYG{p}{(}\PYG{k}{const} \PYG{k+kt}{int} \PYG{o}{\PYGZam{}}\PYG{n}{level}\PYG{p}{,} \PYG{n}{stringstream} \PYG{o}{\PYGZam{}}\PYG{n}{message}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{n}{write}\PYG{p}{(}\PYG{n}{level}\PYG{p}{,} \PYG{n}{message}\PYG{p}{.}\PYG{n}{str}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}


\subsubsection{Detailed Description}
\label{\detokenize{api/file_necsim_LogFile.cpp:detailed-description}}
Sam Thompson
BSD-3 Licence.


\subsubsection{Includes}
\label{\detokenize{api/file_necsim_LogFile.cpp:includes}}\begin{itemize}
\item {} 
\sphinxcode{Filesystem.h} ({\hyperref[\detokenize{api/file_necsim_Filesystem.h:file-necsim-filesystem-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File Filesystem.h}}}})

\item {} 
\sphinxcode{LogFile.h} ({\hyperref[\detokenize{api/file_necsim_LogFile.h:file-necsim-logfile-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File LogFile.h}}}})

\item {} 
\sphinxcode{boost/filesystem.hpp}

\item {} 
\sphinxcode{iomanip}

\item {} 
\sphinxcode{sstream}

\end{itemize}


\subsubsection{Functions}
\label{\detokenize{api/file_necsim_LogFile.cpp:functions}}\begin{itemize}
\item {} 
{\hyperref[\detokenize{api/function_getDefaultLogFile:function-getdefaultlogfile}]{\sphinxcrossref{\DUrole{std,std-ref}{Function getDefaultLogFile}}}}

\item {} 
{\hyperref[\detokenize{api/function_getTime:function-gettime}]{\sphinxcrossref{\DUrole{std,std-ref}{Function getTime}}}}

\item {} 
{\hyperref[\detokenize{api/function_getUniqueFileName:function-getuniquefilename}]{\sphinxcrossref{\DUrole{std,std-ref}{Function getUniqueFileName}}}}

\end{itemize}


\subsection{File LogFile.h}
\label{\detokenize{api/file_necsim_LogFile.h:file-necsim-logfile-h}}\label{\detokenize{api/file_necsim_LogFile.h::doc}}\label{\detokenize{api/file_necsim_LogFile.h:file-logfile-h}}
Contains a class for logging to a logfile, including reporting level and timestamps.

\begin{sphinxShadowBox}
\sphinxstyletopictitle{Contents}
\begin{itemize}
\item {} 
\phantomsection\label{\detokenize{api/file_necsim_LogFile.h:id1}}{\hyperref[\detokenize{api/file_necsim_LogFile.h:definition-necsim-logfile-h}]{\sphinxcrossref{Definition (\sphinxcode{necsim/LogFile.h})}}}

\item {} 
\phantomsection\label{\detokenize{api/file_necsim_LogFile.h:id2}}{\hyperref[\detokenize{api/file_necsim_LogFile.h:detailed-description}]{\sphinxcrossref{Detailed Description}}}

\item {} 
\phantomsection\label{\detokenize{api/file_necsim_LogFile.h:id3}}{\hyperref[\detokenize{api/file_necsim_LogFile.h:includes}]{\sphinxcrossref{Includes}}}

\item {} 
\phantomsection\label{\detokenize{api/file_necsim_LogFile.h:id4}}{\hyperref[\detokenize{api/file_necsim_LogFile.h:included-by}]{\sphinxcrossref{Included By}}}

\item {} 
\phantomsection\label{\detokenize{api/file_necsim_LogFile.h:id5}}{\hyperref[\detokenize{api/file_necsim_LogFile.h:classes}]{\sphinxcrossref{Classes}}}

\item {} 
\phantomsection\label{\detokenize{api/file_necsim_LogFile.h:id6}}{\hyperref[\detokenize{api/file_necsim_LogFile.h:functions}]{\sphinxcrossref{Functions}}}

\item {} 
\phantomsection\label{\detokenize{api/file_necsim_LogFile.h:id7}}{\hyperref[\detokenize{api/file_necsim_LogFile.h:defines}]{\sphinxcrossref{Defines}}}

\end{itemize}
\end{sphinxShadowBox}


\subsubsection{Definition (\sphinxstyleliteralintitle{necsim/LogFile.h})}
\label{\detokenize{api/file_necsim_LogFile.h:definition-necsim-logfile-h}}

\paragraph{Program Listing for File LogFile.h}
\label{\detokenize{api/program_listing_file_necsim_LogFile.h:program-listing-file-necsim-logfile-h}}\label{\detokenize{api/program_listing_file_necsim_LogFile.h::doc}}\label{\detokenize{api/program_listing_file_necsim_LogFile.h:program-listing-for-file-logfile-h}}\begin{itemize}
\item {} 
Return to documentation for {\hyperref[\detokenize{api/file_necsim_LogFile.h:file-necsim-logfile-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File LogFile.h}}}}

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{// This file is part of NECSim project which is released under BSD\PYGZhy{}3 license.}
\PYG{c+c1}{// See file **LICENSE.txt** or visit https://opensource.org/licenses/BSD\PYGZhy{}3\PYGZhy{}Clause) for full license details.}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifndef LOGFILE\PYGZus{}H}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define LOGFILE\PYGZus{}H}

\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}cstring\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}fstream\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}ctime\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}map\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZdq{}CustomExceptions.h\PYGZdq{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define LOGNAME\PYGZus{}FORMAT \PYGZdq{}\PYGZpc{}d\PYGZpc{}m\PYGZpc{}Y\PYGZus{}\PYGZpc{}H\PYGZpc{}M\PYGZpc{}S\PYGZdq{}}

\PYG{k}{using} \PYG{k}{namespace} \PYG{n}{std}\PYG{p}{;}
\PYG{n}{string} \PYG{n+nf}{getDefaultLogFile}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

\PYG{k+kt}{void} \PYG{n+nf}{getUniqueFileName}\PYG{p}{(}\PYG{n}{string} \PYG{o}{\PYGZam{}}\PYG{n}{basic\PYGZus{}string}\PYG{p}{)}\PYG{p}{;}

\PYG{k}{class} \PYG{n+nc}{LogFile}
\PYG{p}{\PYGZob{}}
\PYG{k}{protected}\PYG{o}{:}
    \PYG{c+c1}{// output stream to log file}
    \PYG{n}{ofstream} \PYG{n}{output\PYGZus{}stream}\PYG{p}{;}
    \PYG{c+c1}{// log file name}
    \PYG{n}{string} \PYG{n}{file\PYGZus{}name}\PYG{p}{;}
    \PYG{c+c1}{// mapping integer levels to logging level}
    \PYG{n}{map}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{p}{,} \PYG{n}{string}\PYG{o}{\PYGZgt{}} \PYG{n}{levels\PYGZus{}map}\PYG{p}{;}
    \PYG{c+c1}{// Makes the class non\PYGZhy{}copyable as we don\PYGZsq{}t want to copy file streams}
    \PYG{n}{LogFile}\PYG{p}{(}\PYG{k}{const} \PYG{n}{LogFile}\PYG{o}{\PYGZam{}}\PYG{p}{)} \PYG{o}{=} \PYG{k}{delete}\PYG{p}{;}
    \PYG{n}{LogFile}\PYG{o}{\PYGZam{}} \PYG{k}{operator}\PYG{o}{=}\PYG{p}{(}\PYG{k}{const} \PYG{n}{LogFile}\PYG{o}{\PYGZam{}}\PYG{p}{)} \PYG{o}{=} \PYG{k}{delete}\PYG{p}{;}
\PYG{k}{public}\PYG{o}{:}
    \PYG{n}{LogFile}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

    \PYG{k}{explicit} \PYG{n+nf}{LogFile}\PYG{p}{(}\PYG{k}{const} \PYG{n}{string} \PYG{o}{\PYGZam{}}\PYG{n}{file\PYGZus{}name\PYGZus{}in}\PYG{p}{)}\PYG{p}{;}
    \PYG{o}{\PYGZti{}}\PYG{n}{LogFile}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

    \PYG{k+kt}{void} \PYG{n+nf}{init}\PYG{p}{(}\PYG{k}{const} \PYG{n}{string} \PYG{o}{\PYGZam{}}\PYG{n}{file\PYGZus{}name\PYGZus{}in}\PYG{p}{)}\PYG{p}{;}

    \PYG{k+kt}{void} \PYG{n+nf}{write}\PYG{p}{(}\PYG{k}{const} \PYG{k+kt}{int} \PYG{o}{\PYGZam{}}\PYG{n}{level}\PYG{p}{,} \PYG{n}{string} \PYG{n}{message}\PYG{p}{)}\PYG{p}{;}

    \PYG{k+kt}{void} \PYG{n+nf}{write}\PYG{p}{(}\PYG{k}{const} \PYG{k+kt}{int} \PYG{o}{\PYGZam{}}\PYG{n}{level}\PYG{p}{,} \PYG{n}{stringstream} \PYG{o}{\PYGZam{}}\PYG{n}{message}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}


\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif }\PYG{c+c1}{//LOGFILE\PYGZus{}H}
\end{sphinxVerbatim}


\subsubsection{Detailed Description}
\label{\detokenize{api/file_necsim_LogFile.h:detailed-description}}
Sam Thompson
BSD-3 Licence.


\subsubsection{Includes}
\label{\detokenize{api/file_necsim_LogFile.h:includes}}\begin{itemize}
\item {} 
\sphinxcode{CustomExceptions.h} ({\hyperref[\detokenize{api/file_necsim_CustomExceptions.h:file-necsim-customexceptions-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File CustomExceptions.h}}}})

\item {} 
\sphinxcode{cstring}

\item {} 
\sphinxcode{ctime}

\item {} 
\sphinxcode{fstream}

\item {} 
\sphinxcode{map}

\end{itemize}


\subsubsection{Included By}
\label{\detokenize{api/file_necsim_LogFile.h:included-by}}\begin{itemize}
\item {} 
{\hyperref[\detokenize{api/file_necsim_Logging.h:file-necsim-logging-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File Logging.h}}}}

\item {} 
{\hyperref[\detokenize{api/file_necsim_LogFile.cpp:file-necsim-logfile-cpp}]{\sphinxcrossref{\DUrole{std,std-ref}{File LogFile.cpp}}}}

\end{itemize}


\subsubsection{Classes}
\label{\detokenize{api/file_necsim_LogFile.h:classes}}\begin{itemize}
\item {} 
{\hyperref[\detokenize{api/class_LogFile:class-logfile}]{\sphinxcrossref{\DUrole{std,std-ref}{Class LogFile}}}}

\end{itemize}


\subsubsection{Functions}
\label{\detokenize{api/file_necsim_LogFile.h:functions}}\begin{itemize}
\item {} 
{\hyperref[\detokenize{api/function_getDefaultLogFile:function-getdefaultlogfile}]{\sphinxcrossref{\DUrole{std,std-ref}{Function getDefaultLogFile}}}}

\item {} 
{\hyperref[\detokenize{api/function_getUniqueFileName:function-getuniquefilename}]{\sphinxcrossref{\DUrole{std,std-ref}{Function getUniqueFileName}}}}

\end{itemize}


\subsubsection{Defines}
\label{\detokenize{api/file_necsim_LogFile.h:defines}}\begin{itemize}
\item {} 
{\hyperref[\detokenize{api/define_LOGNAME_FORMAT:define-logname-format}]{\sphinxcrossref{\DUrole{std,std-ref}{Define LOGNAME\_FORMAT}}}}

\end{itemize}


\subsection{File Logging.cpp}
\label{\detokenize{api/file_necsim_Logging.cpp:file-necsim-logging-cpp}}\label{\detokenize{api/file_necsim_Logging.cpp::doc}}\label{\detokenize{api/file_necsim_Logging.cpp:file-logging-cpp}}
Routines for writing to cout. Intended to be overloaded for pythonic versions with the logging module.

\begin{sphinxShadowBox}
\sphinxstyletopictitle{Contents}
\begin{itemize}
\item {} 
\phantomsection\label{\detokenize{api/file_necsim_Logging.cpp:id1}}{\hyperref[\detokenize{api/file_necsim_Logging.cpp:definition-necsim-logging-cpp}]{\sphinxcrossref{Definition (\sphinxcode{necsim/Logging.cpp})}}}

\item {} 
\phantomsection\label{\detokenize{api/file_necsim_Logging.cpp:id2}}{\hyperref[\detokenize{api/file_necsim_Logging.cpp:detailed-description}]{\sphinxcrossref{Detailed Description}}}

\item {} 
\phantomsection\label{\detokenize{api/file_necsim_Logging.cpp:id3}}{\hyperref[\detokenize{api/file_necsim_Logging.cpp:includes}]{\sphinxcrossref{Includes}}}

\item {} 
\phantomsection\label{\detokenize{api/file_necsim_Logging.cpp:id4}}{\hyperref[\detokenize{api/file_necsim_Logging.cpp:functions}]{\sphinxcrossref{Functions}}}

\end{itemize}
\end{sphinxShadowBox}


\subsubsection{Definition (\sphinxstyleliteralintitle{necsim/Logging.cpp})}
\label{\detokenize{api/file_necsim_Logging.cpp:definition-necsim-logging-cpp}}

\paragraph{Program Listing for File Logging.cpp}
\label{\detokenize{api/program_listing_file_necsim_Logging.cpp:program-listing-for-file-logging-cpp}}\label{\detokenize{api/program_listing_file_necsim_Logging.cpp:program-listing-file-necsim-logging-cpp}}\label{\detokenize{api/program_listing_file_necsim_Logging.cpp::doc}}\begin{itemize}
\item {} 
Return to documentation for {\hyperref[\detokenize{api/file_necsim_Logging.cpp:file-necsim-logging-cpp}]{\sphinxcrossref{\DUrole{std,std-ref}{File Logging.cpp}}}}

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{// This file is part of NECSim project which is released under BSD\PYGZhy{}3 license.}
\PYG{c+c1}{// See file **LICENSE.txt** or visit https://opensource.org/licenses/BSD\PYGZhy{}3\PYGZhy{}Clause) for full license details.}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}sstream\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZdq{}Logging.h\PYGZdq{}}


\PYG{k}{using} \PYG{k}{namespace} \PYG{n}{std}\PYG{p}{;}

\PYG{k+kt}{void} \PYG{n+nf}{writeInfo}\PYG{p}{(}\PYG{n}{string} \PYG{n}{message}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifdef DEBUG}
    \PYG{n}{writeLog}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{,} \PYG{n}{message}\PYG{p}{)}\PYG{p}{;}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif }\PYG{c+c1}{// DEBUG}
    \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{message} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{flush}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{void} \PYG{n+nf}{writeWarning}\PYG{p}{(}\PYG{n}{string} \PYG{n}{message}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifdef DEBUG}
    \PYG{n}{writeLog}\PYG{p}{(}\PYG{l+m+mi}{20}\PYG{p}{,} \PYG{n}{message}\PYG{p}{)}\PYG{p}{;}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif }\PYG{c+c1}{// DEBUG}
    \PYG{n}{cerr} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{message} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{flush}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{void} \PYG{n+nf}{writeError}\PYG{p}{(}\PYG{n}{string} \PYG{n}{message}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifdef DEBUG}
    \PYG{n}{writeLog}\PYG{p}{(}\PYG{l+m+mi}{30}\PYG{p}{,} \PYG{n}{message}\PYG{p}{)}\PYG{p}{;}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif }\PYG{c+c1}{// DEBUG}
    \PYG{n}{cerr} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{message} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{flush}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{void} \PYG{n+nf}{writeCritical}\PYG{p}{(}\PYG{n}{string} \PYG{n}{message}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifdef DEBUG}
    \PYG{n}{writeLog}\PYG{p}{(}\PYG{l+m+mi}{40}\PYG{p}{,} \PYG{n}{message}\PYG{p}{)}\PYG{p}{;}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif }\PYG{c+c1}{// DEBUG}
    \PYG{n}{cerr} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{message} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{flush}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifdef DEBUG}
\PYG{k+kt}{void} \PYG{n+nf}{writeLog}\PYG{p}{(}\PYG{k}{const} \PYG{k+kt}{int} \PYG{o}{\PYGZam{}}\PYG{n}{level}\PYG{p}{,} \PYG{n}{string} \PYG{n}{message}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k}{static} \PYG{n}{LogFile} \PYG{n}{logfile}\PYG{p}{;}
    \PYG{n}{logfile}\PYG{p}{.}\PYG{n}{write}\PYG{p}{(}\PYG{n}{level}\PYG{p}{,} \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{move}\PYG{p}{(}\PYG{n}{message}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{void} \PYG{n+nf}{writeLog}\PYG{p}{(}\PYG{k}{const} \PYG{k+kt}{int} \PYG{o}{\PYGZam{}}\PYG{n}{level}\PYG{p}{,} \PYG{n}{stringstream} \PYG{o}{\PYGZam{}}\PYG{n}{message}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{n}{writeLog}\PYG{p}{(}\PYG{n}{level}\PYG{p}{,} \PYG{n}{message}\PYG{p}{.}\PYG{n}{str}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif }\PYG{c+c1}{// DEBUG}
\end{sphinxVerbatim}


\subsubsection{Detailed Description}
\label{\detokenize{api/file_necsim_Logging.cpp:detailed-description}}
Sam Thompson
BSD-3 Licence.


\subsubsection{Includes}
\label{\detokenize{api/file_necsim_Logging.cpp:includes}}\begin{itemize}
\item {} 
\sphinxcode{Logging.h} ({\hyperref[\detokenize{api/file_necsim_Logging.h:file-necsim-logging-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File Logging.h}}}})

\item {} 
\sphinxcode{sstream}

\end{itemize}


\subsubsection{Functions}
\label{\detokenize{api/file_necsim_Logging.cpp:functions}}\begin{itemize}
\item {} 
{\hyperref[\detokenize{api/function_writeCritical:function-writecritical}]{\sphinxcrossref{\DUrole{std,std-ref}{Function writeCritical}}}}

\item {} 
{\hyperref[\detokenize{api/function_writeError:function-writeerror}]{\sphinxcrossref{\DUrole{std,std-ref}{Function writeError}}}}

\item {} 
{\hyperref[\detokenize{api/function_writeInfo:function-writeinfo}]{\sphinxcrossref{\DUrole{std,std-ref}{Function writeInfo}}}}

\item {} 
{\hyperref[\detokenize{api/function_writeWarning:function-writewarning}]{\sphinxcrossref{\DUrole{std,std-ref}{Function writeWarning}}}}

\end{itemize}


\subsection{File Logging.h}
\label{\detokenize{api/file_necsim_Logging.h:file-necsim-logging-h}}\label{\detokenize{api/file_necsim_Logging.h:file-logging-h}}\label{\detokenize{api/file_necsim_Logging.h::doc}}
Routines for writing to cout. Intended to be overloaded for pythonic versions with the logging module.

\begin{sphinxShadowBox}
\sphinxstyletopictitle{Contents}
\begin{itemize}
\item {} 
\phantomsection\label{\detokenize{api/file_necsim_Logging.h:id1}}{\hyperref[\detokenize{api/file_necsim_Logging.h:definition-necsim-logging-h}]{\sphinxcrossref{Definition (\sphinxcode{necsim/Logging.h})}}}

\item {} 
\phantomsection\label{\detokenize{api/file_necsim_Logging.h:id2}}{\hyperref[\detokenize{api/file_necsim_Logging.h:detailed-description}]{\sphinxcrossref{Detailed Description}}}

\item {} 
\phantomsection\label{\detokenize{api/file_necsim_Logging.h:id3}}{\hyperref[\detokenize{api/file_necsim_Logging.h:includes}]{\sphinxcrossref{Includes}}}

\item {} 
\phantomsection\label{\detokenize{api/file_necsim_Logging.h:id4}}{\hyperref[\detokenize{api/file_necsim_Logging.h:included-by}]{\sphinxcrossref{Included By}}}

\end{itemize}
\end{sphinxShadowBox}


\subsubsection{Definition (\sphinxstyleliteralintitle{necsim/Logging.h})}
\label{\detokenize{api/file_necsim_Logging.h:definition-necsim-logging-h}}

\paragraph{Program Listing for File Logging.h}
\label{\detokenize{api/program_listing_file_necsim_Logging.h:program-listing-file-necsim-logging-h}}\label{\detokenize{api/program_listing_file_necsim_Logging.h::doc}}\label{\detokenize{api/program_listing_file_necsim_Logging.h:program-listing-for-file-logging-h}}\begin{itemize}
\item {} 
Return to documentation for {\hyperref[\detokenize{api/file_necsim_Logging.h:file-necsim-logging-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File Logging.h}}}}

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{// This file is part of NECSim project which is released under BSD\PYGZhy{}3 license.}
\PYG{c+c1}{// See file **LICENSE.txt** or visit https://opensource.org/licenses/BSD\PYGZhy{}3\PYGZhy{}Clause) for full license details.}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}string\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}iostream\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}cstdio\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}stdexcept\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZdq{}LogFile.h\PYGZdq{}}

\PYG{k}{using} \PYG{k}{namespace} \PYG{n}{std}\PYG{p}{;}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifndef LOGGING\PYGZus{}IMPORT}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define LOGGING\PYGZus{}IMPORT}

\PYG{k+kt}{void} \PYG{n+nf}{writeInfo}\PYG{p}{(}\PYG{n}{string} \PYG{n}{message}\PYG{p}{)}\PYG{p}{;}

\PYG{k+kt}{void} \PYG{n+nf}{writeWarning}\PYG{p}{(}\PYG{n}{string} \PYG{n}{message}\PYG{p}{)}\PYG{p}{;}

\PYG{k+kt}{void} \PYG{n+nf}{writeError}\PYG{p}{(}\PYG{n}{string} \PYG{n}{message}\PYG{p}{)}\PYG{p}{;}

\PYG{k+kt}{void} \PYG{n+nf}{writeCritical}\PYG{p}{(}\PYG{n}{string} \PYG{n}{message}\PYG{p}{)}\PYG{p}{;}


\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifdef DEBUG}

\PYG{k+kt}{void} \PYG{n+nf}{writeLog}\PYG{p}{(}\PYG{k}{const} \PYG{k+kt}{int} \PYG{o}{\PYGZam{}}\PYG{n}{level}\PYG{p}{,} \PYG{n}{string} \PYG{n}{message}\PYG{p}{)}\PYG{p}{;}

\PYG{k+kt}{void} \PYG{n+nf}{writeLog}\PYG{p}{(}\PYG{k}{const} \PYG{k+kt}{int} \PYG{o}{\PYGZam{}}\PYG{n}{level}\PYG{p}{,} \PYG{n}{stringstream} \PYG{o}{\PYGZam{}}\PYG{n}{message}\PYG{p}{)}\PYG{p}{;}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif}
\end{sphinxVerbatim}


\subsubsection{Detailed Description}
\label{\detokenize{api/file_necsim_Logging.h:detailed-description}}
Sam Thompson
BSD-3 Licence.


\subsubsection{Includes}
\label{\detokenize{api/file_necsim_Logging.h:includes}}\begin{itemize}
\item {} 
\sphinxcode{LogFile.h} ({\hyperref[\detokenize{api/file_necsim_LogFile.h:file-necsim-logfile-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File LogFile.h}}}})

\item {} 
\sphinxcode{cstdio}

\item {} 
\sphinxcode{iostream}

\item {} 
\sphinxcode{stdexcept}

\item {} 
\sphinxcode{string}

\end{itemize}


\subsubsection{Included By}
\label{\detokenize{api/file_necsim_Logging.h:included-by}}\begin{itemize}
\item {} 
{\hyperref[\detokenize{api/file_necsim_TreeNode.h:file-necsim-treenode-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File TreeNode.h}}}}

\item {} 
{\hyperref[\detokenize{api/file_necsim_CustomExceptions.h:file-necsim-customexceptions-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File CustomExceptions.h}}}}

\item {} 
{\hyperref[\detokenize{api/file_necsim_Matrix.h:file-necsim-matrix-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File Matrix.h}}}}

\item {} 
{\hyperref[\detokenize{api/file_necsim_SimParameters.h:file-necsim-simparameters-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File SimParameters.h}}}}

\item {} 
{\hyperref[\detokenize{api/file_necsim_ConfigFileParser.cpp:file-necsim-configfileparser-cpp}]{\sphinxcrossref{\DUrole{std,std-ref}{File ConfigFileParser.cpp}}}}

\item {} 
{\hyperref[\detokenize{api/file_necsim_DataMask.cpp:file-necsim-datamask-cpp}]{\sphinxcrossref{\DUrole{std,std-ref}{File DataMask.cpp}}}}

\item {} 
{\hyperref[\detokenize{api/file_necsim_DataPoint.h:file-necsim-datapoint-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File DataPoint.h}}}}

\item {} 
{\hyperref[\detokenize{api/file_necsim_NRrand.h:file-necsim-nrrand-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File NRrand.h}}}}

\item {} 
{\hyperref[\detokenize{api/file_necsim_Filesystem.cpp:file-necsim-filesystem-cpp}]{\sphinxcrossref{\DUrole{std,std-ref}{File Filesystem.cpp}}}}

\item {} 
{\hyperref[\detokenize{api/file_necsim_Logging.cpp:file-necsim-logging-cpp}]{\sphinxcrossref{\DUrole{std,std-ref}{File Logging.cpp}}}}

\item {} 
{\hyperref[\detokenize{api/file_necsim_SpatialTree.h:file-necsim-spatialtree-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File SpatialTree.h}}}}

\item {} 
{\hyperref[\detokenize{api/file_necsim_SimulationTemplates.h:file-necsim-simulationtemplates-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File SimulationTemplates.h}}}}

\item {} 
{\hyperref[\detokenize{api/file_necsim_Setup.cpp:file-necsim-setup-cpp}]{\sphinxcrossref{\DUrole{std,std-ref}{File Setup.cpp}}}}

\item {} 
{\hyperref[\detokenize{api/file_necsim_TreeNode.cpp:file-necsim-treenode-cpp}]{\sphinxcrossref{\DUrole{std,std-ref}{File TreeNode.cpp}}}}

\end{itemize}


\subsection{File main.cpp}
\label{\detokenize{api/file_necsim_main.cpp::doc}}\label{\detokenize{api/file_necsim_main.cpp:file-main-cpp}}\label{\detokenize{api/file_necsim_main.cpp:file-necsim-main-cpp}}
A generic simulator for spatially explicit coalescence models suitable for HPC applications. It contains all functions for running large-scale simulations backwards in time using coalescence techniques. Outputs include an SQLite database containing spatial and temporal information about tracked lineages, and allow for rebuilding of the coalescence tree. Currently, a fat-tailed dispersal kernel or normal distribution can be used for dispersal processes.

\begin{sphinxShadowBox}
\sphinxstyletopictitle{Contents}
\begin{itemize}
\item {} 
\phantomsection\label{\detokenize{api/file_necsim_main.cpp:id1}}{\hyperref[\detokenize{api/file_necsim_main.cpp:definition-necsim-main-cpp}]{\sphinxcrossref{Definition (\sphinxcode{necsim/main.cpp})}}}

\item {} 
\phantomsection\label{\detokenize{api/file_necsim_main.cpp:id2}}{\hyperref[\detokenize{api/file_necsim_main.cpp:detailed-description}]{\sphinxcrossref{Detailed Description}}}

\item {} 
\phantomsection\label{\detokenize{api/file_necsim_main.cpp:id3}}{\hyperref[\detokenize{api/file_necsim_main.cpp:includes}]{\sphinxcrossref{Includes}}}

\item {} 
\phantomsection\label{\detokenize{api/file_necsim_main.cpp:id4}}{\hyperref[\detokenize{api/file_necsim_main.cpp:functions}]{\sphinxcrossref{Functions}}}

\end{itemize}
\end{sphinxShadowBox}


\subsubsection{Definition (\sphinxstyleliteralintitle{necsim/main.cpp})}
\label{\detokenize{api/file_necsim_main.cpp:definition-necsim-main-cpp}}

\paragraph{Program Listing for File main.cpp}
\label{\detokenize{api/program_listing_file_necsim_main.cpp:program-listing-for-file-main-cpp}}\label{\detokenize{api/program_listing_file_necsim_main.cpp::doc}}\label{\detokenize{api/program_listing_file_necsim_main.cpp:program-listing-file-necsim-main-cpp}}\begin{itemize}
\item {} 
Return to documentation for {\hyperref[\detokenize{api/file_necsim_main.cpp:file-necsim-main-cpp}]{\sphinxcrossref{\DUrole{std,std-ref}{File main.cpp}}}}

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{// This file is part of NECSim project which is released under BSD\PYGZhy{}3 license.}
\PYG{c+c1}{// See file **LICENSE.txt** or visit https://opensource.org/licenses/BSD\PYGZhy{}3\PYGZhy{}Clause) for full license details.}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifdef DEBUG}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifndef verbose}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define verbose}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif}

\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZdq{}SpatialTree.h\PYGZdq{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZdq{}SimulationTemplates.h\PYGZdq{}}

\PYG{c+c1}{// \PYGZsh{}define pristine\PYGZus{}mode // not required unless you experience problems.}
\PYG{c+c1}{// This performs a more thorough check after each move operation.}
\PYG{c+c1}{// Currently, it will also check that the pristine state value is greater than the returned value within every map cell.}
\PYG{c+c1}{// Note that this may cause problems if the pristine state is not the state with the highest number of individuals.}



\PYG{c+cm}{/************************************************************}
\PYG{c+cm}{        MAIN ROUTINE AND COMMAND LINE ARG ROUTINES}

\PYG{c+cm}{ ************************************************************/}



\PYG{k+kt}{int} \PYG{n+nf}{main}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{argc}\PYG{p}{,} \PYG{k+kt}{char} \PYG{o}{*}\PYG{n}{argv}\PYG{p}{[}\PYG{p}{]}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{n}{string}\PYG{o}{\PYGZgt{}} \PYG{n}{comargs}\PYG{p}{;}
    \PYG{n}{importArgs}\PYG{p}{(}\PYG{k}{static\PYGZus{}cast}\PYG{o}{\PYGZlt{}}\PYG{k}{const} \PYG{k+kt}{unsigned} \PYG{k+kt}{int} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{n}{argc}\PYG{p}{)}\PYG{p}{,} \PYG{n}{argv}\PYG{p}{,} \PYG{n}{comargs}\PYG{p}{)}\PYG{p}{;}
    \PYG{k}{const} \PYG{n}{string} \PYG{o}{\PYGZam{}}\PYG{n}{config\PYGZus{}file} \PYG{o}{=} \PYG{n}{getConfigFileFromCmdArgs}\PYG{p}{(}\PYG{n}{comargs}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{runMain}\PYG{o}{\PYGZlt{}}\PYG{n}{SpatialTree}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{n}{config\PYGZus{}file}\PYG{p}{)}\PYG{p}{;}
    \PYG{k}{return} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}


\subsubsection{Detailed Description}
\label{\detokenize{api/file_necsim_main.cpp:detailed-description}}
Run with -h to see full input options.
Outputs include
\begin{itemize}
\item {} 
habitat map file(s)

\item {} 
species richness and species abundances for the supplied minimum speciation rate.

\item {} 
SQL database containing full spatial data. This can be later analysed by the Speciation\_Counter program for applying higher speciation rates.

\end{itemize}

Contact: \sphinxhref{mailto:samuel.thompson14@imperial.ac.uk}{samuel.thompson14@imperial.ac.uk} or \sphinxhref{mailto:thompsonsed@gmail.com}{thompsonsed@gmail.com}
Based heavily on code written by James Rosindell
Contact: \sphinxhref{mailto:j.rosindell@imperial.ac.uk}{j.rosindell@imperial.ac.uk}
Samuel Thompson
BSD-3 Licence.


\subsubsection{Includes}
\label{\detokenize{api/file_necsim_main.cpp:includes}}\begin{itemize}
\item {} 
\sphinxcode{SimulationTemplates.h} ({\hyperref[\detokenize{api/file_necsim_SimulationTemplates.h:file-necsim-simulationtemplates-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File SimulationTemplates.h}}}})

\item {} 
\sphinxcode{SpatialTree.h} ({\hyperref[\detokenize{api/file_necsim_ProtractedSpatialTree.h:file-necsim-protractedspatialtree-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File ProtractedSpatialTree.h}}}})

\end{itemize}


\subsubsection{Functions}
\label{\detokenize{api/file_necsim_main.cpp:functions}}\begin{itemize}
\item {} 
{\hyperref[\detokenize{api/function_main:function-main}]{\sphinxcrossref{\DUrole{std,std-ref}{Function main}}}}

\end{itemize}


\subsection{File Map.cpp}
\label{\detokenize{api/file_necsim_Map.cpp::doc}}\label{\detokenize{api/file_necsim_Map.cpp:file-necsim-map-cpp}}\label{\detokenize{api/file_necsim_Map.cpp:file-map-cpp}}
Contains the {\hyperref[\detokenize{api/class_Map:class-map}]{\sphinxcrossref{\DUrole{std,std-ref}{Class Map}}}} class implementation for easy referencing of the respective coarse and fine map within the same coordinate system.

\begin{sphinxShadowBox}
\sphinxstyletopictitle{Contents}
\begin{itemize}
\item {} 
\phantomsection\label{\detokenize{api/file_necsim_Map.cpp:id1}}{\hyperref[\detokenize{api/file_necsim_Map.cpp:definition-necsim-map-cpp}]{\sphinxcrossref{Definition (\sphinxcode{necsim/Map.cpp})}}}

\item {} 
\phantomsection\label{\detokenize{api/file_necsim_Map.cpp:id2}}{\hyperref[\detokenize{api/file_necsim_Map.cpp:detailed-description}]{\sphinxcrossref{Detailed Description}}}

\item {} 
\phantomsection\label{\detokenize{api/file_necsim_Map.cpp:id3}}{\hyperref[\detokenize{api/file_necsim_Map.cpp:includes}]{\sphinxcrossref{Includes}}}

\end{itemize}
\end{sphinxShadowBox}


\subsubsection{Definition (\sphinxstyleliteralintitle{necsim/Map.cpp})}
\label{\detokenize{api/file_necsim_Map.cpp:definition-necsim-map-cpp}}

\paragraph{Program Listing for File Map.cpp}
\label{\detokenize{api/program_listing_file_necsim_Map.cpp::doc}}\label{\detokenize{api/program_listing_file_necsim_Map.cpp:program-listing-for-file-map-cpp}}\label{\detokenize{api/program_listing_file_necsim_Map.cpp:program-listing-file-necsim-map-cpp}}\begin{itemize}
\item {} 
Return to documentation for {\hyperref[\detokenize{api/file_necsim_Map.cpp:file-necsim-map-cpp}]{\sphinxcrossref{\DUrole{std,std-ref}{File Map.cpp}}}}

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{// This file is part of NECSim project which is released under BSD\PYGZhy{}3 license.}
\PYG{c+c1}{// See file **LICENSE.txt** or visit https://opensource.org/licenses/BSD\PYGZhy{}3\PYGZhy{}Clause) for full license details}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZdq{}Map.h\PYGZdq{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZdq{}Filesystem.h\PYGZdq{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZdq{}CustomExceptions.h\PYGZdq{}}

\PYG{k+kt}{void} \PYG{n}{Map}\PYG{o}{:}\PYG{o}{:}\PYG{n}{setDims}\PYG{p}{(}\PYG{n}{SimParameters} \PYG{n}{mapvarsin}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k}{if}\PYG{p}{(}\PYG{o}{!}\PYG{n}{check\PYGZus{}set\PYGZus{}dim}\PYG{p}{)}  \PYG{c+c1}{// checks to make sure it hasn\PYGZsq{}t been run already.}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{mapvars} \PYG{o}{=} \PYG{n}{mapvarsin}\PYG{p}{;}
        \PYG{n}{deme} \PYG{o}{=} \PYG{n}{mapvarsin}\PYG{p}{.}\PYG{n}{deme}\PYG{p}{;}
        \PYG{n}{x\PYGZus{}dim} \PYG{o}{=} \PYG{n}{mapvarsin}\PYG{p}{.}\PYG{n}{grid\PYGZus{}x\PYGZus{}size}\PYG{p}{;}
        \PYG{n}{y\PYGZus{}dim} \PYG{o}{=} \PYG{n}{mapvarsin}\PYG{p}{.}\PYG{n}{grid\PYGZus{}y\PYGZus{}size}\PYG{p}{;}
        \PYG{n}{scale} \PYG{o}{=} \PYG{n}{mapvarsin}\PYG{p}{.}\PYG{n}{coarse\PYGZus{}map\PYGZus{}scale}\PYG{p}{;}
        \PYG{n}{nUpdate} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
        \PYG{n}{check\PYGZus{}set\PYGZus{}dim} \PYG{o}{=} \PYG{n+nb}{true}\PYG{p}{;}
        \PYG{n}{update\PYGZus{}time} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
        \PYG{n}{gen\PYGZus{}since\PYGZus{}pristine} \PYG{o}{=} \PYG{n}{mapvarsin}\PYG{p}{.}\PYG{n}{gen\PYGZus{}since\PYGZus{}pristine}\PYG{p}{;}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{gen\PYGZus{}since\PYGZus{}pristine} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{gen\PYGZus{}since\PYGZus{}pristine} \PYG{o}{=} \PYG{l+m+mf}{0.000000000000000001}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{n}{habitat\PYGZus{}change\PYGZus{}rate} \PYG{o}{=} \PYG{n}{mapvarsin}\PYG{p}{.}\PYG{n}{habitat\PYGZus{}change\PYGZus{}rate}\PYG{p}{;}
        \PYG{n}{landscape\PYGZus{}type} \PYG{o}{=} \PYG{n}{mapvarsin}\PYG{p}{.}\PYG{n}{landscape\PYGZus{}type}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{else}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{cerr} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ERROR\PYGZus{}MAP\PYGZus{}001: Dimensions have already been set}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
        \PYG{k}{return}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{return}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{bool} \PYG{n}{Map}\PYG{o}{:}\PYG{o}{:}\PYG{n}{checkMapExists}\PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{mapvars}\PYG{p}{.}\PYG{n}{configs}\PYG{p}{.}\PYG{n}{getSectionOptionsSize}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{string} \PYG{n}{tmppath} \PYG{o}{=} \PYG{n}{mapvars}\PYG{p}{.}\PYG{n}{configs}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getOption}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{path}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{if}\PYG{p}{(}\PYG{o}{!}\PYG{n}{doesExistNull}\PYG{p}{(}\PYG{n}{tmppath}\PYG{p}{)}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{k}{return} \PYG{p}{(}\PYG{n+nb}{false}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{return} \PYG{p}{(}\PYG{n+nb}{true}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{void} \PYG{n}{Map}\PYG{o}{:}\PYG{o}{:}\PYG{n}{calcFineMap}\PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{n}{string} \PYG{n}{fileinput} \PYG{o}{=} \PYG{n}{mapvars}\PYG{p}{.}\PYG{n}{fine\PYGZus{}map\PYGZus{}file}\PYG{p}{;}
    \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{mapxsize} \PYG{o}{=} \PYG{n}{mapvars}\PYG{p}{.}\PYG{n}{fine\PYGZus{}map\PYGZus{}x\PYGZus{}size}\PYG{p}{;}
    \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{mapysize} \PYG{o}{=} \PYG{n}{mapvars}\PYG{p}{.}\PYG{n}{fine\PYGZus{}map\PYGZus{}y\PYGZus{}size}\PYG{p}{;}
    \PYG{k}{if}\PYG{p}{(}\PYG{o}{!}\PYG{n}{check\PYGZus{}set\PYGZus{}dim}\PYG{p}{)}  \PYG{c+c1}{// checks that the dimensions have been set.}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{throw} \PYG{n}{FatalException}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ERROR\PYGZus{}MAP\PYGZus{}002: dimensions not set.}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{c+c1}{// Note that the default \PYGZdq{}null\PYGZdq{} type is to have 100\PYGZpc{} forest cover in every cell.}
    \PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifndef SIZE\PYGZus{}LIMIT}
    \PYG{k}{if}\PYG{p}{(}\PYG{n}{mapxsize} \PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{1000000} \PYG{o}{\textbar{}}\PYG{o}{\textbar{}} \PYG{n}{mapysize} \PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{1000000}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{throw} \PYG{n}{runtime\PYGZus{}error}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Extremely large map sizes set for }\PYG{l+s}{\PYGZdq{}} \PYG{o}{+} \PYG{n}{fileinput} \PYG{o}{+} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{+} \PYG{n}{to\PYGZus{}string}\PYG{p}{(}\PYG{n}{mapxsize}\PYG{p}{)} \PYG{o}{+} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{, }\PYG{l+s}{\PYGZdq{}} \PYG{o}{+} \PYG{n}{to\PYGZus{}string}\PYG{p}{(}\PYG{n}{mapysize}\PYG{p}{)} \PYG{o}{+} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif}
    \PYG{n}{Matrix}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{float}\PYG{o}{\PYGZgt{}} \PYG{n}{toret}\PYG{p}{;}
    \PYG{n}{toret}\PYG{p}{.}\PYG{n}{SetSize}\PYG{p}{(}\PYG{n}{mapysize}\PYG{p}{,} \PYG{n}{mapxsize}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{fine\PYGZus{}map}\PYG{p}{.}\PYG{n}{SetSize}\PYG{p}{(}\PYG{n}{mapysize}\PYG{p}{,} \PYG{n}{mapxsize}\PYG{p}{)}\PYG{p}{;}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifdef DEBUG}
    \PYG{n}{writeInfo}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Calculating fine map}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif}
    \PYG{k}{if}\PYG{p}{(}\PYG{n}{fileinput} \PYG{o}{=}\PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{null}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{mapysize}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{j} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{j} \PYG{o}{\PYGZlt{}} \PYG{n}{mapxsize}\PYG{p}{;} \PYG{n}{j}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{n}{toret}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mf}{1.0}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
        \PYG{p}{\PYGZcb{}}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{else}  \PYG{c+c1}{// There is a map to read in.}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{toret}\PYG{p}{.}\PYG{n}{import}\PYG{p}{(}\PYG{n}{fileinput}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifdef DEBUG}
    \PYG{n}{writeInfo}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{import complete}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif}
    \PYG{n}{fine\PYGZus{}max} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}

    \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{mapysize}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{j} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{j} \PYG{o}{\PYGZlt{}} \PYG{n}{mapxsize}\PYG{p}{;} \PYG{n}{j}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{fine\PYGZus{}map}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]} \PYG{o}{=} \PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{long}\PYG{p}{)}\PYG{p}{(}\PYG{n}{max}\PYG{p}{(}\PYG{p}{(}\PYG{k+kt}{double}\PYG{p}{)}\PYG{n}{round}\PYG{p}{(}\PYG{n}{toret}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]} \PYG{o}{*} \PYG{n}{deme}\PYG{p}{)}\PYG{p}{,} \PYG{l+m+mf}{0.0}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
            \PYG{k}{if}\PYG{p}{(}\PYG{n}{fine\PYGZus{}map}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]} \PYG{o}{\PYGZgt{}} \PYG{n}{fine\PYGZus{}max}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{n}{fine\PYGZus{}max} \PYG{o}{=} \PYG{n}{fine\PYGZus{}map}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
        \PYG{p}{\PYGZcb{}}
    \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{void} \PYG{n}{Map}\PYG{o}{:}\PYG{o}{:}\PYG{n}{calcPristineFineMap}\PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{n}{string} \PYG{n}{fileinput} \PYG{o}{=} \PYG{n}{mapvars}\PYG{p}{.}\PYG{n}{pristine\PYGZus{}fine\PYGZus{}map\PYGZus{}file}\PYG{p}{;}
    \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{mapxsize} \PYG{o}{=} \PYG{n}{mapvars}\PYG{p}{.}\PYG{n}{fine\PYGZus{}map\PYGZus{}x\PYGZus{}size}\PYG{p}{;}
    \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{mapysize} \PYG{o}{=} \PYG{n}{mapvars}\PYG{p}{.}\PYG{n}{fine\PYGZus{}map\PYGZus{}y\PYGZus{}size}\PYG{p}{;}
    \PYG{k}{if}\PYG{p}{(}\PYG{o}{!}\PYG{n}{check\PYGZus{}set\PYGZus{}dim}\PYG{p}{)}  \PYG{c+c1}{// checks that the dimensions have been set.}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{throw} \PYG{n}{FatalException}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ERROR\PYGZus{}MAP\PYGZus{}002: dimensions not set.}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifndef SIZE\PYGZus{}LIMIT}
    \PYG{k}{if}\PYG{p}{(}\PYG{n}{mapxsize} \PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{1000000} \PYG{o}{\textbar{}}\PYG{o}{\textbar{}} \PYG{n}{mapysize} \PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{1000000}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{throw} \PYG{n}{runtime\PYGZus{}error}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Extremely large map sizes set for }\PYG{l+s}{\PYGZdq{}} \PYG{o}{+} \PYG{n}{fileinput} \PYG{o}{+} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{+} \PYG{n}{to\PYGZus{}string}\PYG{p}{(}\PYG{n}{mapxsize}\PYG{p}{)} \PYG{o}{+} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{, }\PYG{l+s}{\PYGZdq{}} \PYG{o}{+} \PYG{n}{to\PYGZus{}string}\PYG{p}{(}\PYG{n}{mapysize}\PYG{p}{)} \PYG{o}{+} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif}
    \PYG{c+c1}{// Note that the default \PYGZdq{}null\PYGZdq{} type is to have 100\PYGZpc{} forest cover in every cell.}
    \PYG{n}{Matrix}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{float}\PYG{o}{\PYGZgt{}} \PYG{n}{toret}\PYG{p}{;}
    \PYG{n}{has\PYGZus{}pristine} \PYG{o}{=} \PYG{n+nb}{true}\PYG{p}{;}
    \PYG{n}{pristine\PYGZus{}fine\PYGZus{}max} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
    \PYG{k}{if}\PYG{p}{(}\PYG{n}{fileinput} \PYG{o}{=}\PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{null}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{toret}\PYG{p}{.}\PYG{n}{SetSize}\PYG{p}{(}\PYG{n}{mapysize}\PYG{p}{,} \PYG{n}{mapxsize}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{pristine\PYGZus{}fine\PYGZus{}map}\PYG{p}{.}\PYG{n}{SetSize}\PYG{p}{(}\PYG{n}{mapysize}\PYG{p}{,} \PYG{n}{mapxsize}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{mapxsize}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{j} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{j} \PYG{o}{\PYGZlt{}} \PYG{n}{mapysize}\PYG{p}{;} \PYG{n}{j}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{n}{toret}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mf}{1.0}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
        \PYG{p}{\PYGZcb{}}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{else} \PYG{k}{if}\PYG{p}{(}\PYG{n}{fileinput} \PYG{o}{=}\PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{none}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{has\PYGZus{}pristine} \PYG{o}{=} \PYG{n+nb}{false}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{else}  \PYG{c+c1}{// There is a map to read in.}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{toret}\PYG{p}{.}\PYG{n}{SetSize}\PYG{p}{(}\PYG{n}{mapysize}\PYG{p}{,} \PYG{n}{mapxsize}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{pristine\PYGZus{}fine\PYGZus{}map}\PYG{p}{.}\PYG{n}{SetSize}\PYG{p}{(}\PYG{n}{mapysize}\PYG{p}{,} \PYG{n}{mapxsize}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{toret}\PYG{p}{.}\PYG{n}{import}\PYG{p}{(}\PYG{n}{fileinput}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{c+c1}{// os \PYGZlt{}\PYGZlt{} toret \PYGZlt{}\PYGZlt{} endl;}
    \PYG{k}{if}\PYG{p}{(}\PYG{n}{has\PYGZus{}pristine}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{mapysize}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{j} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{j} \PYG{o}{\PYGZlt{}} \PYG{n}{mapxsize}\PYG{p}{;} \PYG{n}{j}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{n}{pristine\PYGZus{}fine\PYGZus{}map}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]} \PYG{o}{=} \PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{long}\PYG{p}{)}\PYG{p}{(}\PYG{n}{max}\PYG{p}{(}\PYG{p}{(}\PYG{k+kt}{double}\PYG{p}{)}\PYG{n}{round}\PYG{p}{(}\PYG{n}{toret}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]} \PYG{o}{*} \PYG{n}{deme}\PYG{p}{)}\PYG{p}{,} \PYG{l+m+mf}{0.0}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
                \PYG{k}{if}\PYG{p}{(}\PYG{n}{pristine\PYGZus{}fine\PYGZus{}map}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]} \PYG{o}{\PYGZgt{}} \PYG{n}{pristine\PYGZus{}fine\PYGZus{}max}\PYG{p}{)}
                \PYG{p}{\PYGZob{}}
                    \PYG{n}{pristine\PYGZus{}fine\PYGZus{}max} \PYG{o}{=} \PYG{n}{pristine\PYGZus{}fine\PYGZus{}map}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{p}{;}
                \PYG{p}{\PYGZcb{}}
            \PYG{p}{\PYGZcb{}}
        \PYG{p}{\PYGZcb{}}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{return}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{void} \PYG{n}{Map}\PYG{o}{:}\PYG{o}{:}\PYG{n}{calcCoarseMap}\PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{n}{string} \PYG{n}{fileinput} \PYG{o}{=} \PYG{n}{mapvars}\PYG{p}{.}\PYG{n}{coarse\PYGZus{}map\PYGZus{}file}\PYG{p}{;}
    \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{mapxsize} \PYG{o}{=} \PYG{n}{mapvars}\PYG{p}{.}\PYG{n}{coarse\PYGZus{}map\PYGZus{}x\PYGZus{}size}\PYG{p}{;}
    \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{mapysize} \PYG{o}{=} \PYG{n}{mapvars}\PYG{p}{.}\PYG{n}{coarse\PYGZus{}map\PYGZus{}y\PYGZus{}size}\PYG{p}{;}
    \PYG{k}{if}\PYG{p}{(}\PYG{o}{!}\PYG{n}{check\PYGZus{}set\PYGZus{}dim}\PYG{p}{)}  \PYG{c+c1}{// checks that the dimensions have been set.}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{throw} \PYG{n}{FatalException}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ERROR\PYGZus{}MAP\PYGZus{}003: dimensions not set.}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifndef SIZE\PYGZus{}LIMIT}
    \PYG{k}{if}\PYG{p}{(}\PYG{n}{mapxsize} \PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{1000000} \PYG{o}{\textbar{}}\PYG{o}{\textbar{}} \PYG{n}{mapysize} \PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{1000000}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{throw} \PYG{n}{runtime\PYGZus{}error}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Extremely large map sizes set for }\PYG{l+s}{\PYGZdq{}} \PYG{o}{+} \PYG{n}{fileinput} \PYG{o}{+} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{+} \PYG{n}{to\PYGZus{}string}\PYG{p}{(}\PYG{n}{mapxsize}\PYG{p}{)} \PYG{o}{+} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{, }\PYG{l+s}{\PYGZdq{}} \PYG{o}{+} \PYG{n}{to\PYGZus{}string}\PYG{p}{(}\PYG{n}{mapysize}\PYG{p}{)} \PYG{o}{+} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif}
    \PYG{c+c1}{// Note that the default \PYGZdq{}null\PYGZdq{} type for the coarse type is to have a density of 1 in every cell. \PYGZdq{}none\PYGZdq{} defaults to no}
    \PYG{c+c1}{// pristine map}
    \PYG{n}{Matrix}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{float}\PYG{o}{\PYGZgt{}} \PYG{n}{toret}\PYG{p}{;}
    \PYG{n}{bCoarse} \PYG{o}{=} \PYG{n+nb}{true}\PYG{p}{;}
    \PYG{n}{coarse\PYGZus{}max} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
    \PYG{k}{if}\PYG{p}{(}\PYG{n}{fileinput} \PYG{o}{=}\PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{null}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{toret}\PYG{p}{.}\PYG{n}{SetSize}\PYG{p}{(}\PYG{n}{mapysize}\PYG{p}{,} \PYG{n}{mapxsize}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{coarse\PYGZus{}map}\PYG{p}{.}\PYG{n}{SetSize}\PYG{p}{(}\PYG{n}{mapysize}\PYG{p}{,} \PYG{n}{mapxsize}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{mapxsize}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{j} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{j} \PYG{o}{\PYGZlt{}} \PYG{n}{mapysize}\PYG{p}{;} \PYG{n}{j}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{n}{toret}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mf}{1.0}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
        \PYG{p}{\PYGZcb{}}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{else} \PYG{k}{if}\PYG{p}{(}\PYG{n}{fileinput} \PYG{o}{=}\PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{none}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{bCoarse} \PYG{o}{=} \PYG{n+nb}{false}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{else}  \PYG{c+c1}{// There is a map to read in.}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{toret}\PYG{p}{.}\PYG{n}{SetSize}\PYG{p}{(}\PYG{n}{mapysize}\PYG{p}{,} \PYG{n}{mapxsize}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{coarse\PYGZus{}map}\PYG{p}{.}\PYG{n}{SetSize}\PYG{p}{(}\PYG{n}{mapysize}\PYG{p}{,} \PYG{n}{mapxsize}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{toret}\PYG{p}{.}\PYG{n}{import}\PYG{p}{(}\PYG{n}{fileinput}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{if}\PYG{p}{(}\PYG{n}{bCoarse}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{mapysize}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{j} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{j} \PYG{o}{\PYGZlt{}} \PYG{n}{mapxsize}\PYG{p}{;} \PYG{n}{j}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{n}{coarse\PYGZus{}map}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]} \PYG{o}{=} \PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{long}\PYG{p}{)}\PYG{p}{(}\PYG{n}{max}\PYG{p}{(}\PYG{p}{(}\PYG{k+kt}{double}\PYG{p}{)}\PYG{n}{round}\PYG{p}{(}\PYG{n}{toret}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]} \PYG{o}{*} \PYG{n}{deme}\PYG{p}{)}\PYG{p}{,} \PYG{l+m+mf}{0.0}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
                \PYG{k}{if}\PYG{p}{(}\PYG{n}{coarse\PYGZus{}map}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]} \PYG{o}{\PYGZgt{}} \PYG{n}{coarse\PYGZus{}max}\PYG{p}{)}
                \PYG{p}{\PYGZob{}}
                    \PYG{n}{coarse\PYGZus{}max} \PYG{o}{=} \PYG{n}{coarse\PYGZus{}map}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{p}{;}
                \PYG{p}{\PYGZcb{}}
            \PYG{p}{\PYGZcb{}}
        \PYG{p}{\PYGZcb{}}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{return}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{void} \PYG{n}{Map}\PYG{o}{:}\PYG{o}{:}\PYG{n}{calcPristineCoarseMap}\PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{c+c1}{//  os \PYGZlt{}\PYGZlt{} \PYGZdq{}pristine coarse map file: \PYGZdq{} \PYGZlt{}\PYGZlt{} mapvars.pristine\PYGZus{}coarse\PYGZus{}map\PYGZus{}file \PYGZlt{}\PYGZlt{} endl;}
    \PYG{n}{string} \PYG{n}{fileinput} \PYG{o}{=} \PYG{n}{mapvars}\PYG{p}{.}\PYG{n}{pristine\PYGZus{}coarse\PYGZus{}map\PYGZus{}file}\PYG{p}{;}
    \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{mapxsize} \PYG{o}{=} \PYG{n}{mapvars}\PYG{p}{.}\PYG{n}{coarse\PYGZus{}map\PYGZus{}x\PYGZus{}size}\PYG{p}{;}
    \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{mapysize} \PYG{o}{=} \PYG{n}{mapvars}\PYG{p}{.}\PYG{n}{coarse\PYGZus{}map\PYGZus{}y\PYGZus{}size}\PYG{p}{;}
    \PYG{k}{if}\PYG{p}{(}\PYG{o}{!}\PYG{n}{check\PYGZus{}set\PYGZus{}dim}\PYG{p}{)}  \PYG{c+c1}{// checks that the dimensions have been set.}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{throw} \PYG{n}{FatalException}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ERROR\PYGZus{}MAP\PYGZus{}003: dimensions not set.}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifndef SIZE\PYGZus{}LIMIT}
    \PYG{k}{if}\PYG{p}{(}\PYG{n}{mapxsize} \PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{1000000} \PYG{o}{\textbar{}}\PYG{o}{\textbar{}} \PYG{n}{mapysize} \PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{1000000}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{throw} \PYG{n}{runtime\PYGZus{}error}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Extremely large map sizes set for }\PYG{l+s}{\PYGZdq{}} \PYG{o}{+} \PYG{n}{fileinput} \PYG{o}{+} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{+} \PYG{n}{to\PYGZus{}string}\PYG{p}{(}\PYG{n}{mapxsize}\PYG{p}{)} \PYG{o}{+} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{, }\PYG{l+s}{\PYGZdq{}} \PYG{o}{+} \PYG{n}{to\PYGZus{}string}\PYG{p}{(}\PYG{n}{mapysize}\PYG{p}{)} \PYG{o}{+} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif}
    \PYG{c+c1}{// Note that the default \PYGZdq{}null\PYGZdq{} type for the coarse type is to have non\PYGZhy{}forest in every cell.}
    \PYG{n}{Matrix}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{float}\PYG{o}{\PYGZgt{}} \PYG{n}{toret}\PYG{p}{;}
    \PYG{n}{pristine\PYGZus{}coarse\PYGZus{}max} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
    \PYG{k}{if}\PYG{p}{(}\PYG{n}{bCoarse}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{fileinput} \PYG{o}{=}\PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{null}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{toret}\PYG{p}{.}\PYG{n}{SetSize}\PYG{p}{(}\PYG{n}{mapysize}\PYG{p}{,} \PYG{n}{mapxsize}\PYG{p}{)}\PYG{p}{;}
            \PYG{n}{pristine\PYGZus{}coarse\PYGZus{}map}\PYG{p}{.}\PYG{n}{SetSize}\PYG{p}{(}\PYG{n}{mapysize}\PYG{p}{,} \PYG{n}{mapxsize}\PYG{p}{)}\PYG{p}{;}
            \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{mapxsize}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{j} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{j} \PYG{o}{\PYGZlt{}} \PYG{n}{mapysize}\PYG{p}{;} \PYG{n}{j}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
                \PYG{p}{\PYGZob{}}
                    \PYG{n}{toret}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mf}{1.0}\PYG{p}{;}
                \PYG{p}{\PYGZcb{}}
            \PYG{p}{\PYGZcb{}}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{else} \PYG{k}{if}\PYG{p}{(}\PYG{n}{fileinput} \PYG{o}{=}\PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{none}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{has\PYGZus{}pristine} \PYG{o}{=} \PYG{n+nb}{false}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{else}  \PYG{c+c1}{// There is a map to read in.}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{toret}\PYG{p}{.}\PYG{n}{SetSize}\PYG{p}{(}\PYG{n}{mapysize}\PYG{p}{,} \PYG{n}{mapxsize}\PYG{p}{)}\PYG{p}{;}
            \PYG{n}{pristine\PYGZus{}coarse\PYGZus{}map}\PYG{p}{.}\PYG{n}{SetSize}\PYG{p}{(}\PYG{n}{mapysize}\PYG{p}{,} \PYG{n}{mapxsize}\PYG{p}{)}\PYG{p}{;}
            \PYG{n}{toret}\PYG{p}{.}\PYG{n}{import}\PYG{p}{(}\PYG{n}{fileinput}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{if}\PYG{p}{(}\PYG{n}{bCoarse} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{n}{has\PYGZus{}pristine}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{mapysize}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{j} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{j} \PYG{o}{\PYGZlt{}} \PYG{n}{mapxsize}\PYG{p}{;} \PYG{n}{j}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{n}{pristine\PYGZus{}coarse\PYGZus{}map}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]} \PYG{o}{=} \PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{long}\PYG{p}{)}\PYG{p}{(}\PYG{n}{max}\PYG{p}{(}\PYG{p}{(}\PYG{k+kt}{double}\PYG{p}{)}\PYG{n}{round}\PYG{p}{(}\PYG{n}{toret}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]} \PYG{o}{*} \PYG{n}{deme}\PYG{p}{)}\PYG{p}{,} \PYG{l+m+mf}{0.0}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
                \PYG{k}{if}\PYG{p}{(}\PYG{n}{pristine\PYGZus{}coarse\PYGZus{}map}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]} \PYG{o}{\PYGZgt{}} \PYG{n}{pristine\PYGZus{}coarse\PYGZus{}max}\PYG{p}{)}
                \PYG{p}{\PYGZob{}}
                    \PYG{n}{pristine\PYGZus{}coarse\PYGZus{}max} \PYG{o}{=} \PYG{n}{pristine\PYGZus{}coarse\PYGZus{}map}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{p}{;}
                \PYG{p}{\PYGZcb{}}
            \PYG{p}{\PYGZcb{}}
        \PYG{p}{\PYGZcb{}}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{return}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{void} \PYG{n}{Map}\PYG{o}{:}\PYG{o}{:}\PYG{n}{setTimeVars}\PYG{p}{(}\PYG{k+kt}{double} \PYG{n}{gen\PYGZus{}since\PYGZus{}pristine\PYGZus{}in}\PYG{p}{,} \PYG{k+kt}{double} \PYG{n}{habitat\PYGZus{}change\PYGZus{}rate\PYGZus{}in}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{n}{update\PYGZus{}time} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
    \PYG{n}{gen\PYGZus{}since\PYGZus{}pristine} \PYG{o}{=} \PYG{n}{gen\PYGZus{}since\PYGZus{}pristine\PYGZus{}in}\PYG{p}{;}
    \PYG{n}{habitat\PYGZus{}change\PYGZus{}rate} \PYG{o}{=} \PYG{n}{habitat\PYGZus{}change\PYGZus{}rate\PYGZus{}in}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{void} \PYG{n}{Map}\PYG{o}{:}\PYG{o}{:}\PYG{n}{calcOffset}\PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k}{if}\PYG{p}{(}\PYG{n}{mapvars}\PYG{p}{.}\PYG{n}{times\PYGZus{}file} \PYG{o}{!}\PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{null}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{mapvars}\PYG{p}{.}\PYG{n}{setPristine}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{c+c1}{//  os \PYGZlt{}\PYGZlt{} mapvars.times\PYGZus{}file \PYGZlt{}\PYGZlt{} endl;}
    \PYG{k}{if}\PYG{p}{(}\PYG{n}{fine\PYGZus{}map}\PYG{p}{.}\PYG{n}{GetCols}\PYG{p}{(}\PYG{p}{)} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{0} \PYG{o}{\textbar{}}\PYG{o}{\textbar{}} \PYG{n}{fine\PYGZus{}map}\PYG{p}{.}\PYG{n}{GetRows}\PYG{p}{(}\PYG{p}{)} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{throw} \PYG{n}{FatalException}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ERROR\PYGZus{}MAP\PYGZus{}004: fine map not set.}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{if}\PYG{p}{(}\PYG{n}{coarse\PYGZus{}map}\PYG{p}{.}\PYG{n}{GetCols}\PYG{p}{(}\PYG{p}{)} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{0} \PYG{o}{\textbar{}}\PYG{o}{\textbar{}} \PYG{n}{coarse\PYGZus{}map}\PYG{p}{.}\PYG{n}{GetRows}\PYG{p}{(}\PYG{p}{)} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{bCoarse}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{coarse\PYGZus{}map}\PYG{p}{.}\PYG{n}{SetSize}\PYG{p}{(}\PYG{n}{fine\PYGZus{}map}\PYG{p}{.}\PYG{n}{GetRows}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{n}{fine\PYGZus{}map}\PYG{p}{.}\PYG{n}{GetCols}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{c+c1}{//      throw FatalException(\PYGZdq{}ERROR\PYGZus{}MAP\PYGZus{}004: coarse map not set.\PYGZdq{});}
    \PYG{p}{\PYGZcb{}}
    \PYG{n}{fine\PYGZus{}x\PYGZus{}offset} \PYG{o}{=} \PYG{n}{mapvars}\PYG{p}{.}\PYG{n}{fine\PYGZus{}map\PYGZus{}x\PYGZus{}offset} \PYG{o}{+} \PYG{n}{mapvars}\PYG{p}{.}\PYG{n}{sample\PYGZus{}x\PYGZus{}offset}\PYG{p}{;}
    \PYG{n}{fine\PYGZus{}y\PYGZus{}offset} \PYG{o}{=} \PYG{n}{mapvars}\PYG{p}{.}\PYG{n}{fine\PYGZus{}map\PYGZus{}y\PYGZus{}offset} \PYG{o}{+} \PYG{n}{mapvars}\PYG{p}{.}\PYG{n}{sample\PYGZus{}y\PYGZus{}offset}\PYG{p}{;}
    \PYG{n}{coarse\PYGZus{}x\PYGZus{}offset} \PYG{o}{=} \PYG{n}{mapvars}\PYG{p}{.}\PYG{n}{coarse\PYGZus{}map\PYGZus{}x\PYGZus{}offset}\PYG{p}{;}
    \PYG{n}{coarse\PYGZus{}y\PYGZus{}offset} \PYG{o}{=} \PYG{n}{mapvars}\PYG{p}{.}\PYG{n}{coarse\PYGZus{}map\PYGZus{}y\PYGZus{}offset}\PYG{p}{;}
    \PYG{n}{scale} \PYG{o}{=} \PYG{n}{mapvars}\PYG{p}{.}\PYG{n}{coarse\PYGZus{}map\PYGZus{}scale}\PYG{p}{;}
    \PYG{c+c1}{// this is the location of the top left (or north west) corner of the respective map}
    \PYG{c+c1}{// and the x and y distance from the top left of the grid object that contains the initial lineages.}
    \PYG{n}{fine\PYGZus{}x\PYGZus{}min} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{n}{fine\PYGZus{}x\PYGZus{}offset}\PYG{p}{;}
    \PYG{n}{fine\PYGZus{}y\PYGZus{}min} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{n}{fine\PYGZus{}y\PYGZus{}offset}\PYG{p}{;}
    \PYG{n}{fine\PYGZus{}x\PYGZus{}max} \PYG{o}{=} \PYG{n}{fine\PYGZus{}x\PYGZus{}min} \PYG{o}{+} \PYG{p}{(}\PYG{n}{fine\PYGZus{}map}\PYG{p}{.}\PYG{n}{GetCols}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{fine\PYGZus{}y\PYGZus{}max} \PYG{o}{=} \PYG{n}{fine\PYGZus{}y\PYGZus{}min} \PYG{o}{+} \PYG{p}{(}\PYG{n}{fine\PYGZus{}map}\PYG{p}{.}\PYG{n}{GetRows}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
    \PYG{k}{if}\PYG{p}{(}\PYG{n}{bCoarse}\PYG{p}{)} \PYG{c+c1}{// Check if there is a coarse map}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{coarse\PYGZus{}x\PYGZus{}min} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{n}{coarse\PYGZus{}x\PYGZus{}offset} \PYG{o}{\PYGZhy{}} \PYG{n}{fine\PYGZus{}x\PYGZus{}offset}\PYG{p}{;}
        \PYG{n}{coarse\PYGZus{}y\PYGZus{}min} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{n}{coarse\PYGZus{}y\PYGZus{}offset} \PYG{o}{\PYGZhy{}} \PYG{n}{fine\PYGZus{}y\PYGZus{}offset}\PYG{p}{;}
        \PYG{n}{coarse\PYGZus{}x\PYGZus{}max} \PYG{o}{=} \PYG{n}{coarse\PYGZus{}x\PYGZus{}min} \PYG{o}{+} \PYG{n}{scale} \PYG{o}{*} \PYG{p}{(}\PYG{n}{coarse\PYGZus{}map}\PYG{p}{.}\PYG{n}{GetCols}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{coarse\PYGZus{}y\PYGZus{}max} \PYG{o}{=} \PYG{n}{coarse\PYGZus{}y\PYGZus{}min} \PYG{o}{+} \PYG{n}{scale} \PYG{o}{*} \PYG{p}{(}\PYG{n}{coarse\PYGZus{}map}\PYG{p}{.}\PYG{n}{GetRows}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{else} \PYG{c+c1}{// Just set the offsets to the same as the fine map}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{coarse\PYGZus{}x\PYGZus{}min} \PYG{o}{=} \PYG{n}{fine\PYGZus{}x\PYGZus{}min}\PYG{p}{;}
        \PYG{n}{coarse\PYGZus{}y\PYGZus{}min} \PYG{o}{=} \PYG{n}{fine\PYGZus{}y\PYGZus{}min}\PYG{p}{;}
        \PYG{n}{coarse\PYGZus{}x\PYGZus{}max} \PYG{o}{=} \PYG{n}{fine\PYGZus{}x\PYGZus{}max}\PYG{p}{;}
        \PYG{n}{coarse\PYGZus{}y\PYGZus{}max} \PYG{o}{=} \PYG{n}{fine\PYGZus{}y\PYGZus{}max}\PYG{p}{;}
        \PYG{n}{scale} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{n}{dispersal\PYGZus{}relative\PYGZus{}cost} \PYG{o}{=} \PYG{n}{mapvars}\PYG{p}{.}\PYG{n}{dispersal\PYGZus{}relative\PYGZus{}cost}\PYG{p}{;}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifdef DEBUG}
    \PYG{n}{stringstream} \PYG{n}{os}\PYG{p}{;}
    \PYG{n}{os} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{finex: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{fine\PYGZus{}x\PYGZus{}min} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{,}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{fine\PYGZus{}x\PYGZus{}max} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
    \PYG{n}{os} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{finey: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{fine\PYGZus{}y\PYGZus{}min} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{,}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{fine\PYGZus{}y\PYGZus{}max} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
    \PYG{n}{os} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{coarsex: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{coarse\PYGZus{}x\PYGZus{}min} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{,}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{coarse\PYGZus{}x\PYGZus{}max} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
    \PYG{n}{os} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{coarsey: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{coarse\PYGZus{}y\PYGZus{}min} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{,}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{coarse\PYGZus{}y\PYGZus{}max} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
    \PYG{n}{os} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{offsets: }\PYG{l+s}{\PYGZdq{}}
         \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{(}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{fine\PYGZus{}x\PYGZus{}offset} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{,}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{fine\PYGZus{}y\PYGZus{}offset} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{)(}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{coarse\PYGZus{}x\PYGZus{}offset} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{,}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{coarse\PYGZus{}y\PYGZus{}offset} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{)}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
    \PYG{n}{os} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{pristine fine file: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{pristine\PYGZus{}fine\PYGZus{}map} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
    \PYG{n}{os} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{pristine coarse file: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{pristine\PYGZus{}coarse\PYGZus{}map} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
    \PYG{n}{writeInfo}\PYG{p}{(}\PYG{n}{os}\PYG{p}{.}\PYG{n}{str}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif}
    \PYG{c+c1}{//      os \PYGZlt{}\PYGZlt{} \PYGZdq{}fine variables: \PYGZdq{} \PYGZlt{}\PYGZlt{} finexmin \PYGZlt{}\PYGZlt{} \PYGZdq{},\PYGZdq{} \PYGZlt{}\PYGZlt{} fine\PYGZus{}x\PYGZus{}max \PYGZlt{}\PYGZlt{} endl;}
    \PYG{c+c1}{//      os \PYGZlt{}\PYGZlt{} \PYGZdq{}coarse variabes: \PYGZdq{} \PYGZlt{}\PYGZlt{} coarse\PYGZus{}x\PYGZus{}min \PYGZlt{}\PYGZlt{} \PYGZdq{},\PYGZdq{} \PYGZlt{}\PYGZlt{} coarse\PYGZus{}x\PYGZus{}max \PYGZlt{}\PYGZlt{} endl;}
    \PYG{k}{if}\PYG{p}{(}\PYG{n}{fine\PYGZus{}x\PYGZus{}min} \PYG{o}{\PYGZlt{}} \PYG{n}{coarse\PYGZus{}x\PYGZus{}min} \PYG{o}{\textbar{}}\PYG{o}{\textbar{}} \PYG{n}{fine\PYGZus{}x\PYGZus{}max} \PYG{o}{\PYGZgt{}} \PYG{n}{coarse\PYGZus{}x\PYGZus{}max} \PYG{o}{\textbar{}}\PYG{o}{\textbar{}} \PYG{p}{(}\PYG{n}{fine\PYGZus{}x\PYGZus{}max} \PYG{o}{\PYGZhy{}} \PYG{n}{fine\PYGZus{}x\PYGZus{}min}\PYG{p}{)} \PYG{o}{\PYGZlt{}} \PYG{n}{x\PYGZus{}dim} \PYG{o}{\textbar{}}\PYG{o}{\textbar{}} \PYG{p}{(}\PYG{n}{fine\PYGZus{}y\PYGZus{}max} \PYG{o}{\PYGZhy{}} \PYG{n}{fine\PYGZus{}y\PYGZus{}min}\PYG{p}{)} \PYG{o}{\PYGZlt{}} \PYG{n}{y\PYGZus{}dim}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{throw} \PYG{n}{FatalException}\PYG{p}{(}
            \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ERROR\PYGZus{}MAP\PYGZus{}006: FATAL \PYGZhy{} fine map extremes outside coarse map or sample grid larger than fine map}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{return}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{void} \PYG{n}{Map}\PYG{o}{:}\PYG{o}{:}\PYG{n}{validateMaps}\PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{n}{stringstream} \PYG{n}{os}\PYG{p}{;}
    \PYG{n}{os} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}r}\PYG{l+s}{Validating maps...}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{flush}\PYG{p}{;}
    \PYG{k+kt}{double} \PYG{n}{dTotal} \PYG{o}{=} \PYG{n}{fine\PYGZus{}map}\PYG{p}{.}\PYG{n}{GetCols}\PYG{p}{(}\PYG{p}{)} \PYG{o}{+} \PYG{n}{coarse\PYGZus{}map}\PYG{p}{.}\PYG{n}{GetCols}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{iCounter} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
    \PYG{k}{if}\PYG{p}{(}\PYG{n}{has\PYGZus{}pristine}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{fine\PYGZus{}map}\PYG{p}{.}\PYG{n}{GetCols}\PYG{p}{(}\PYG{p}{)} \PYG{o}{=}\PYG{o}{=} \PYG{n}{pristine\PYGZus{}fine\PYGZus{}map}\PYG{p}{.}\PYG{n}{GetCols}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{n}{fine\PYGZus{}map}\PYG{p}{.}\PYG{n}{GetRows}\PYG{p}{(}\PYG{p}{)} \PYG{o}{=}\PYG{o}{=} \PYG{n}{pristine\PYGZus{}fine\PYGZus{}map}\PYG{p}{.}\PYG{n}{GetRows}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}}
           \PYG{n}{coarse\PYGZus{}map}\PYG{p}{.}\PYG{n}{GetCols}\PYG{p}{(}\PYG{p}{)} \PYG{o}{=}\PYG{o}{=} \PYG{n}{pristine\PYGZus{}coarse\PYGZus{}map}\PYG{p}{.}\PYG{n}{GetCols}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{n}{coarse\PYGZus{}map}\PYG{p}{.}\PYG{n}{GetRows}\PYG{p}{(}\PYG{p}{)} \PYG{o}{=}\PYG{o}{=} \PYG{n}{pristine\PYGZus{}coarse\PYGZus{}map}\PYG{p}{.}\PYG{n}{GetRows}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{os} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}r}\PYG{l+s}{Validating maps...map sizes okay}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{flush}\PYG{p}{;}
            \PYG{n}{writeInfo}\PYG{p}{(}\PYG{n}{os}\PYG{p}{.}\PYG{n}{str}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{else}
        \PYG{p}{\PYGZob{}}
            \PYG{k}{throw} \PYG{n}{FatalException}\PYG{p}{(}
                    \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ERROR\PYGZus{}MAP\PYGZus{}009: Map validation failed \PYGZhy{} modern and pristine maps are not the same dimensions.}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{fine\PYGZus{}map}\PYG{p}{.}\PYG{n}{GetCols}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{j} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{j} \PYG{o}{\PYGZlt{}} \PYG{n}{fine\PYGZus{}map}\PYG{p}{.}\PYG{n}{GetRows}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{n}{j}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{k}{if}\PYG{p}{(}\PYG{n}{fine\PYGZus{}map}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{\PYGZgt{}} \PYG{n}{pristine\PYGZus{}fine\PYGZus{}map}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}
                \PYG{p}{\PYGZob{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifdef DEBUG}
                    \PYG{n}{stringstream} \PYG{n}{ss}\PYG{p}{;}
                    \PYG{n}{ss} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{fine map: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{fine\PYGZus{}map}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ pristine map: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{pristine\PYGZus{}fine\PYGZus{}map}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{;}
                    \PYG{n}{ss} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ x,y: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{i} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{,}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{j} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
                    \PYG{n}{writeLog}\PYG{p}{(}\PYG{l+m+mi}{50}\PYG{p}{,} \PYG{n}{ss}\PYG{p}{)}\PYG{p}{;}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif }\PYG{c+c1}{//DEBUG}
                    \PYG{k}{throw} \PYG{n+nf}{FatalException}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ERROR\PYGZus{}MAP\PYGZus{}007: Map validation failed \PYGZhy{} fine map value larger }\PYG{l+s}{\PYGZdq{}}
                                              \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{than pristine fine map value.}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
                \PYG{p}{\PYGZcb{}}
            \PYG{p}{\PYGZcb{}}
            \PYG{k+kt}{double} \PYG{n}{dPercentComplete} \PYG{o}{=} \PYG{l+m+mi}{100} \PYG{o}{*} \PYG{p}{(}\PYG{p}{(}\PYG{k+kt}{double}\PYG{p}{)}\PYG{p}{(}\PYG{n}{i} \PYG{o}{+} \PYG{n}{iCounter}\PYG{p}{)} \PYG{o}{/} \PYG{n}{dTotal}\PYG{p}{)}\PYG{p}{;}
            \PYG{k}{if}\PYG{p}{(}\PYG{n}{i} \PYG{o}{\PYGZpc{}} \PYG{l+m+mi}{1000} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{n}{os}\PYG{p}{.}\PYG{n}{str}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
                \PYG{n}{os} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}r}\PYG{l+s}{Validating maps...}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{dPercentComplete} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZpc{}                }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{flush}\PYG{p}{;}
                \PYG{n}{writeInfo}\PYG{p}{(}\PYG{n}{os}\PYG{p}{.}\PYG{n}{str}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
        \PYG{p}{\PYGZcb{}}
    \PYG{p}{\PYGZcb{}}
    \PYG{n}{iCounter} \PYG{o}{=} \PYG{n}{fine\PYGZus{}map}\PYG{p}{.}\PYG{n}{GetCols}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
    \PYG{k}{if}\PYG{p}{(}\PYG{n}{has\PYGZus{}pristine}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{coarse\PYGZus{}map}\PYG{p}{.}\PYG{n}{GetCols}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{j} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{j} \PYG{o}{\PYGZlt{}} \PYG{n}{coarse\PYGZus{}map}\PYG{p}{.}\PYG{n}{GetRows}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{n}{j}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{k}{if}\PYG{p}{(}\PYG{n}{coarse\PYGZus{}map}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{\PYGZgt{}} \PYG{n}{pristine\PYGZus{}coarse\PYGZus{}map}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}
                \PYG{p}{\PYGZob{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifdef DEBUG}
                    \PYG{n}{stringstream} \PYG{n}{ss}\PYG{p}{;}
                    \PYG{n}{ss} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{coarse map: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{coarse\PYGZus{}map}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ pristine map: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{pristine\PYGZus{}coarse\PYGZus{}map}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{;}
                    \PYG{n}{ss} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ coarse map x+1: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{coarse\PYGZus{}map}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{p}{[}\PYG{n}{i} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{p}{]}
                         \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ pristine map: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{pristine\PYGZus{}coarse\PYGZus{}map}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{p}{[}\PYG{n}{i} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{;}
                    \PYG{n}{ss} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ x,y: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{i} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{,}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{j}\PYG{p}{;}
                    \PYG{n}{writeLog}\PYG{p}{(}\PYG{l+m+mi}{50}\PYG{p}{,} \PYG{n}{ss}\PYG{p}{)}\PYG{p}{;}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif }\PYG{c+c1}{// DEBUG}
                    \PYG{k}{throw} \PYG{n+nf}{FatalException}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ERROR\PYGZus{}MAP\PYGZus{}008: Map validation failed \PYGZhy{} coarse map value larger }\PYG{l+s}{\PYGZdq{}}
                                              \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{than pristine coarse map value.}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
                \PYG{p}{\PYGZcb{}}
            \PYG{p}{\PYGZcb{}}
            \PYG{k+kt}{double} \PYG{n}{dPercentComplete} \PYG{o}{=} \PYG{l+m+mi}{100} \PYG{o}{*} \PYG{p}{(}\PYG{p}{(}\PYG{k+kt}{double}\PYG{p}{)}\PYG{p}{(}\PYG{n}{i} \PYG{o}{+} \PYG{n}{iCounter}\PYG{p}{)} \PYG{o}{/} \PYG{n}{dTotal}\PYG{p}{)}\PYG{p}{;}
            \PYG{k}{if}\PYG{p}{(}\PYG{n}{i} \PYG{o}{\PYGZpc{}} \PYG{l+m+mi}{1000} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{n}{os}\PYG{p}{.}\PYG{n}{str}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
                \PYG{n}{os} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}r}\PYG{l+s}{Validating maps...}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{dPercentComplete} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZpc{}                }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{flush}\PYG{p}{;}
                \PYG{n}{writeInfo}\PYG{p}{(}\PYG{n}{os}\PYG{p}{.}\PYG{n}{str}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
        \PYG{p}{\PYGZcb{}}

    \PYG{p}{\PYGZcb{}}
    \PYG{n}{os}\PYG{p}{.}\PYG{n}{str}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{os} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}r}\PYG{l+s}{Validating maps complete                                       }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
    \PYG{n}{writeInfo}\PYG{p}{(}\PYG{n}{os}\PYG{p}{.}\PYG{n}{str}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{void} \PYG{n}{Map}\PYG{o}{:}\PYG{o}{:}\PYG{n}{updateMap}\PYG{p}{(}\PYG{k+kt}{double} \PYG{n}{generation}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{c+c1}{// only update the map if the pristine state has not been reached.}
    \PYG{k}{if}\PYG{p}{(}\PYG{o}{!}\PYG{n}{mapvars}\PYG{p}{.}\PYG{n}{is\PYGZus{}pristine} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{n}{has\PYGZus{}pristine}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{mapvars}\PYG{p}{.}\PYG{n}{gen\PYGZus{}since\PYGZus{}pristine} \PYG{o}{\PYGZlt{}} \PYG{n}{generation}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{c+c1}{// Only update the map if the maps have actually changed}
            \PYG{k}{if}\PYG{p}{(}\PYG{n}{mapvars}\PYG{p}{.}\PYG{n}{setPristine}\PYG{p}{(}\PYG{n}{nUpdate}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{n}{nUpdate}\PYG{o}{+}\PYG{o}{+}\PYG{p}{;}
                \PYG{c+c1}{// pristine\PYGZus{}fine\PYGZus{}map = mapvars.pristine\PYGZus{}fine\PYGZus{}map\PYGZus{}file;}
                \PYG{c+c1}{// pristine\PYGZus{}coarse\PYGZus{}map = mapvars.pristine\PYGZus{}coarse\PYGZus{}map\PYGZus{}file;}
                \PYG{n}{current\PYGZus{}map\PYGZus{}time} \PYG{o}{=} \PYG{n}{gen\PYGZus{}since\PYGZus{}pristine}\PYG{p}{;}
                \PYG{n}{gen\PYGZus{}since\PYGZus{}pristine} \PYG{o}{=} \PYG{n}{mapvars}\PYG{p}{.}\PYG{n}{gen\PYGZus{}since\PYGZus{}pristine}\PYG{p}{;}
                \PYG{k}{if}\PYG{p}{(}\PYG{n}{gen\PYGZus{}since\PYGZus{}pristine} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)}
                \PYG{p}{\PYGZob{}}
                    \PYG{n}{gen\PYGZus{}since\PYGZus{}pristine} \PYG{o}{=} \PYG{l+m+mf}{0.000000000000000001}\PYG{p}{;}
                \PYG{p}{\PYGZcb{}}
                \PYG{n}{habitat\PYGZus{}change\PYGZus{}rate} \PYG{o}{=} \PYG{n}{mapvars}\PYG{p}{.}\PYG{n}{habitat\PYGZus{}change\PYGZus{}rate}\PYG{p}{;}
                \PYG{n}{fine\PYGZus{}max} \PYG{o}{=} \PYG{n}{pristine\PYGZus{}fine\PYGZus{}max}\PYG{p}{;}
                \PYG{n}{fine\PYGZus{}map} \PYG{o}{=} \PYG{n}{pristine\PYGZus{}fine\PYGZus{}map}\PYG{p}{;}
                \PYG{n}{coarse\PYGZus{}max} \PYG{o}{=} \PYG{n}{pristine\PYGZus{}coarse\PYGZus{}max}\PYG{p}{;}
                \PYG{n}{coarse\PYGZus{}map} \PYG{o}{=} \PYG{n}{pristine\PYGZus{}coarse\PYGZus{}map}\PYG{p}{;}
                \PYG{n}{calcPristineCoarseMap}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
                \PYG{n}{calcPristineFineMap}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
                \PYG{k}{if}\PYG{p}{(}\PYG{n}{has\PYGZus{}pristine}\PYG{p}{)}
                \PYG{p}{\PYGZob{}}
                    \PYG{n}{is\PYGZus{}pristine} \PYG{o}{=} \PYG{n}{mapvars}\PYG{p}{.}\PYG{n}{is\PYGZus{}pristine}\PYG{p}{;}
                \PYG{p}{\PYGZcb{}}
                \PYG{n}{recalculateHabitatMax}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}


            \PYG{p}{\PYGZcb{}}
        \PYG{p}{\PYGZcb{}}
    \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{void} \PYG{n}{Map}\PYG{o}{:}\PYG{o}{:}\PYG{n}{setLandscape}\PYG{p}{(}\PYG{n}{string} \PYG{n}{landscape\PYGZus{}type}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k}{if}\PYG{p}{(}\PYG{n}{landscape\PYGZus{}type} \PYG{o}{=}\PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{infinite}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{writeInfo}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Setting infinite landscape.}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{getValFunc} \PYG{o}{=} \PYG{o}{\PYGZam{}}\PYG{n}{Map}\PYG{o}{:}\PYG{o}{:}\PYG{n}{getValInfinite}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{else} \PYG{k}{if}\PYG{p}{(}\PYG{n}{landscape\PYGZus{}type} \PYG{o}{=}\PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{tiled\PYGZus{}coarse}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{writeInfo}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Setting tiled coarse infinite landscape.}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{getValFunc} \PYG{o}{=} \PYG{o}{\PYGZam{}}\PYG{n}{Map}\PYG{o}{:}\PYG{o}{:}\PYG{n}{getValCoarseTiled}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{else} \PYG{k}{if}\PYG{p}{(}\PYG{n}{landscape\PYGZus{}type} \PYG{o}{=}\PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{tiled\PYGZus{}fine}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{writeInfo}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Setting tiled fine infinite landscape.}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{getValFunc} \PYG{o}{=} \PYG{o}{\PYGZam{}}\PYG{n}{Map}\PYG{o}{:}\PYG{o}{:}\PYG{n}{getValFineTiled}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{else} \PYG{k}{if}\PYG{p}{(}\PYG{n}{landscape\PYGZus{}type} \PYG{o}{=}\PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{closed}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{getValFunc} \PYG{o}{=} \PYG{o}{\PYGZam{}}\PYG{n}{Map}\PYG{o}{:}\PYG{o}{:}\PYG{n}{getValFinite}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{else}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{throw} \PYG{n}{FatalException}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Provided landscape type is not a valid option: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{+} \PYG{n}{landscape\PYGZus{}type}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{Map}\PYG{o}{:}\PYG{o}{:}\PYG{n}{getVal}\PYG{p}{(}\PYG{k}{const} \PYG{k+kt}{double}\PYG{o}{\PYGZam{}} \PYG{n}{x}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{double}\PYG{o}{\PYGZam{}} \PYG{n}{y}\PYG{p}{,}
                          \PYG{k}{const} \PYG{k+kt}{long}\PYG{o}{\PYGZam{}} \PYG{n}{xwrap}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{long}\PYG{o}{\PYGZam{}} \PYG{n}{ywrap}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{double}\PYG{o}{\PYGZam{}} \PYG{n}{current\PYGZus{}generation}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k}{return} \PYG{p}{(}\PYG{k}{this}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{o}{*}\PYG{n}{getValFunc}\PYG{p}{)}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,} \PYG{n}{y}\PYG{p}{,} \PYG{n}{xwrap}\PYG{p}{,} \PYG{n}{ywrap}\PYG{p}{,} \PYG{n}{current\PYGZus{}generation}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{Map}\PYG{o}{:}\PYG{o}{:}\PYG{n}{getValInfinite}\PYG{p}{(}
    \PYG{k}{const} \PYG{k+kt}{double}\PYG{o}{\PYGZam{}} \PYG{n}{x}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{double}\PYG{o}{\PYGZam{}} \PYG{n}{y}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{long}\PYG{o}{\PYGZam{}} \PYG{n}{xwrap}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{long}\PYG{o}{\PYGZam{}} \PYG{n}{ywrap}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{double}\PYG{o}{\PYGZam{}} \PYG{n}{current\PYGZus{}generation}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k+kt}{double} \PYG{n}{xval}\PYG{p}{,} \PYG{n}{yval}\PYG{p}{;}
    \PYG{n}{xval} \PYG{o}{=} \PYG{n}{x} \PYG{o}{+} \PYG{p}{(}\PYG{n}{x\PYGZus{}dim} \PYG{o}{*} \PYG{n}{xwrap}\PYG{p}{)}\PYG{p}{;}  \PYG{c+c1}{//}
    \PYG{n}{yval} \PYG{o}{=} \PYG{n}{y} \PYG{o}{+} \PYG{p}{(}\PYG{n}{y\PYGZus{}dim} \PYG{o}{*} \PYG{n}{ywrap}\PYG{p}{)}\PYG{p}{;}
    \PYG{c+c1}{//      // return 0 if the requested coordinate is completely outside the map}
    \PYG{k}{if}\PYG{p}{(}\PYG{n}{xval} \PYG{o}{\PYGZlt{}} \PYG{n}{coarse\PYGZus{}x\PYGZus{}min} \PYG{o}{\textbar{}}\PYG{o}{\textbar{}} \PYG{n}{xval} \PYG{o}{\PYGZgt{}}\PYG{o}{=} \PYG{n}{coarse\PYGZus{}x\PYGZus{}max} \PYG{o}{\textbar{}}\PYG{o}{\textbar{}} \PYG{n}{yval} \PYG{o}{\PYGZlt{}} \PYG{n}{coarse\PYGZus{}y\PYGZus{}min} \PYG{o}{\textbar{}}\PYG{o}{\textbar{}} \PYG{n}{yval} \PYG{o}{\PYGZgt{}}\PYG{o}{=} \PYG{n}{coarse\PYGZus{}y\PYGZus{}max}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{return} \PYG{n}{deme}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{return} \PYG{n}{getValFinite}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,} \PYG{n}{y}\PYG{p}{,} \PYG{n}{xwrap}\PYG{p}{,} \PYG{n}{ywrap}\PYG{p}{,} \PYG{n}{current\PYGZus{}generation}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{Map}\PYG{o}{:}\PYG{o}{:}\PYG{n}{getValCoarseTiled}\PYG{p}{(}
    \PYG{k}{const} \PYG{k+kt}{double}\PYG{o}{\PYGZam{}} \PYG{n}{x}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{double}\PYG{o}{\PYGZam{}} \PYG{n}{y}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{long}\PYG{o}{\PYGZam{}} \PYG{n}{xwrap}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{long}\PYG{o}{\PYGZam{}} \PYG{n}{ywrap}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{double}\PYG{o}{\PYGZam{}} \PYG{n}{current\PYGZus{}generation}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k+kt}{double} \PYG{n}{newx} \PYG{o}{=} \PYG{n}{fmod}\PYG{p}{(}\PYG{n}{x} \PYG{o}{+} \PYG{p}{(}\PYG{n}{xwrap} \PYG{o}{*} \PYG{n}{x\PYGZus{}dim}\PYG{p}{)} \PYG{o}{+} \PYG{n}{fine\PYGZus{}x\PYGZus{}offset} \PYG{o}{+} \PYG{n}{coarse\PYGZus{}x\PYGZus{}offset}\PYG{p}{,} \PYG{n}{coarse\PYGZus{}map}\PYG{p}{.}\PYG{n}{GetCols}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kt}{double} \PYG{n}{newy} \PYG{o}{=} \PYG{n}{fmod}\PYG{p}{(}\PYG{n}{y} \PYG{o}{+} \PYG{p}{(}\PYG{n}{ywrap} \PYG{o}{*} \PYG{n}{y\PYGZus{}dim}\PYG{p}{)} \PYG{o}{+} \PYG{n}{fine\PYGZus{}x\PYGZus{}offset} \PYG{o}{+} \PYG{n}{coarse\PYGZus{}x\PYGZus{}offset}\PYG{p}{,} \PYG{n}{coarse\PYGZus{}map}\PYG{p}{.}\PYG{n}{GetRows}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
    \PYG{k}{if}\PYG{p}{(}\PYG{n}{newx} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{0}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{newx} \PYG{o}{+}\PYG{o}{=} \PYG{n}{coarse\PYGZus{}map}\PYG{p}{.}\PYG{n}{GetCols}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{if}\PYG{p}{(}\PYG{n}{newy} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{0}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{newy} \PYG{o}{+}\PYG{o}{=} \PYG{n}{coarse\PYGZus{}map}\PYG{p}{.}\PYG{n}{GetRows}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{return} \PYG{n}{getValCoarse}\PYG{p}{(}\PYG{n}{newx}\PYG{p}{,} \PYG{n}{newy}\PYG{p}{,} \PYG{n}{current\PYGZus{}generation}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{Map}\PYG{o}{:}\PYG{o}{:}\PYG{n}{getValFineTiled}\PYG{p}{(}
    \PYG{k}{const} \PYG{k+kt}{double}\PYG{o}{\PYGZam{}} \PYG{n}{x}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{double}\PYG{o}{\PYGZam{}} \PYG{n}{y}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{long}\PYG{o}{\PYGZam{}} \PYG{n}{xwrap}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{long}\PYG{o}{\PYGZam{}} \PYG{n}{ywrap}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{double}\PYG{o}{\PYGZam{}} \PYG{n}{current\PYGZus{}generation}\PYG{p}{)}
\PYG{p}{\PYGZob{}}

    \PYG{k+kt}{double} \PYG{n}{newx} \PYG{o}{=} \PYG{n}{fmod}\PYG{p}{(}\PYG{n}{x} \PYG{o}{+} \PYG{p}{(}\PYG{n}{xwrap} \PYG{o}{*} \PYG{n}{x\PYGZus{}dim}\PYG{p}{)} \PYG{o}{+} \PYG{n}{fine\PYGZus{}x\PYGZus{}offset}\PYG{p}{,} \PYG{n}{fine\PYGZus{}map}\PYG{p}{.}\PYG{n}{GetCols}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kt}{double} \PYG{n}{newy} \PYG{o}{=} \PYG{n}{fmod}\PYG{p}{(}\PYG{n}{y} \PYG{o}{+} \PYG{p}{(}\PYG{n}{ywrap} \PYG{o}{*} \PYG{n}{y\PYGZus{}dim}\PYG{p}{)} \PYG{o}{+} \PYG{n}{fine\PYGZus{}y\PYGZus{}offset}\PYG{p}{,} \PYG{n}{fine\PYGZus{}map}\PYG{p}{.}\PYG{n}{GetRows}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
    \PYG{c+c1}{// Now adjust for incorrect wrapping behaviour of fmod}
    \PYG{k}{if}\PYG{p}{(}\PYG{n}{newx} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{0}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{newx} \PYG{o}{+}\PYG{o}{=} \PYG{n}{fine\PYGZus{}map}\PYG{p}{.}\PYG{n}{GetCols}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{if}\PYG{p}{(}\PYG{n}{newy} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{0}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{newy} \PYG{o}{+}\PYG{o}{=} \PYG{n}{fine\PYGZus{}map}\PYG{p}{.}\PYG{n}{GetRows}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifdef DEBUG}
    \PYG{k}{if}\PYG{p}{(}\PYG{n}{newx} \PYG{o}{\PYGZgt{}}\PYG{o}{=} \PYG{n}{fine\PYGZus{}map}\PYG{p}{.}\PYG{n}{GetCols}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\textbar{}}\PYG{o}{\textbar{}} \PYG{n}{newx} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{0} \PYG{o}{\textbar{}}\PYG{o}{\textbar{}} \PYG{n}{newy} \PYG{o}{\PYGZgt{}}\PYG{o}{=} \PYG{n}{fine\PYGZus{}map}\PYG{p}{.}\PYG{n}{GetRows}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\textbar{}}\PYG{o}{\textbar{}} \PYG{n}{newy} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{0}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{stringstream} \PYG{n}{ss}\PYG{p}{;}
        \PYG{n}{ss} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Fine map indexing out of range of fine map.}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
        \PYG{n}{ss} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{x, y: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{newx} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{, }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{newy} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
        \PYG{n}{ss} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{cols, rows: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{fine\PYGZus{}map}\PYG{p}{.}\PYG{n}{GetCols}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{, }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{fine\PYGZus{}map}\PYG{p}{.}\PYG{n}{GetRows}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
        \PYG{k}{throw} \PYG{n+nf}{out\PYGZus{}of\PYGZus{}range}\PYG{p}{(}\PYG{n}{ss}\PYG{p}{.}\PYG{n}{str}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif}
    \PYG{k}{return} \PYG{n}{getValFine}\PYG{p}{(}\PYG{n}{newx}\PYG{p}{,} \PYG{n}{newy}\PYG{p}{,} \PYG{n}{current\PYGZus{}generation}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{Map}\PYG{o}{:}\PYG{o}{:}\PYG{n}{getValCoarse}\PYG{p}{(}\PYG{k}{const} \PYG{k+kt}{double} \PYG{o}{\PYGZam{}}\PYG{n}{xval}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{double} \PYG{o}{\PYGZam{}}\PYG{n}{yval}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{double} \PYG{o}{\PYGZam{}}\PYG{n}{current\PYGZus{}generation}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{retval} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
    \PYG{k}{if}\PYG{p}{(}\PYG{n}{has\PYGZus{}pristine}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{is\PYGZus{}pristine} \PYG{o}{\textbar{}}\PYG{o}{\textbar{}} \PYG{n}{pristine\PYGZus{}coarse\PYGZus{}map}\PYG{p}{[}\PYG{n}{yval}\PYG{p}{]}\PYG{p}{[}\PYG{n}{xval}\PYG{p}{]} \PYG{o}{=}\PYG{o}{=} \PYG{n}{coarse\PYGZus{}map}\PYG{p}{[}\PYG{n}{yval}\PYG{p}{]}\PYG{p}{[}\PYG{n}{xval}\PYG{p}{]}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{k}{return} \PYG{n}{pristine\PYGZus{}coarse\PYGZus{}map}\PYG{p}{[}\PYG{n}{yval}\PYG{p}{]}\PYG{p}{[}\PYG{n}{xval}\PYG{p}{]}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{else}
        \PYG{p}{\PYGZob{}}
            \PYG{k+kt}{double} \PYG{n}{currentTime} \PYG{o}{=} \PYG{n}{current\PYGZus{}generation} \PYG{o}{\PYGZhy{}} \PYG{n}{current\PYGZus{}map\PYGZus{}time}\PYG{p}{;}
            \PYG{n}{retval} \PYG{o}{=} \PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{long}\PYG{p}{)}\PYG{n}{floor}\PYG{p}{(}\PYG{n}{coarse\PYGZus{}map}\PYG{p}{[}\PYG{n}{yval}\PYG{p}{]}\PYG{p}{[}\PYG{n}{xval}\PYG{p}{]} \PYG{o}{+}
                                           \PYG{p}{(}\PYG{n}{habitat\PYGZus{}change\PYGZus{}rate} \PYG{o}{*}
                                            \PYG{p}{(}\PYG{p}{(}\PYG{n}{pristine\PYGZus{}coarse\PYGZus{}map}\PYG{p}{[}\PYG{n}{yval}\PYG{p}{]}\PYG{p}{[}\PYG{n}{xval}\PYG{p}{]} \PYG{o}{\PYGZhy{}} \PYG{n}{coarse\PYGZus{}map}\PYG{p}{[}\PYG{n}{yval}\PYG{p}{]}\PYG{p}{[}\PYG{n}{xval}\PYG{p}{]}\PYG{p}{)} \PYG{o}{/}
                                                    \PYG{p}{(}\PYG{n}{gen\PYGZus{}since\PYGZus{}pristine}\PYG{o}{\PYGZhy{}}\PYG{n}{current\PYGZus{}map\PYGZus{}time}\PYG{p}{)}\PYG{p}{)} \PYG{o}{*} \PYG{n}{currentTime}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{else}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{return} \PYG{n}{coarse\PYGZus{}map}\PYG{p}{[}\PYG{n}{yval}\PYG{p}{]}\PYG{p}{[}\PYG{n}{xval}\PYG{p}{]}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifdef pristine\PYGZus{}mode}
    \PYG{k}{if}\PYG{p}{(}\PYG{n}{retval} \PYG{o}{\PYGZgt{}} \PYG{n}{pristine\PYGZus{}coarse\PYGZus{}map}\PYG{p}{[}\PYG{n}{yval}\PYG{p}{]}\PYG{p}{[}\PYG{n}{xval}\PYG{p}{]}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{string} \PYG{n}{ec} \PYG{o}{=}
                \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Returned value greater than pristine value. Check file input. (or disable this error before }\PYG{l+s}{\PYGZdq{}}
                \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{compilation.}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
            \PYG{n}{ec} \PYG{o}{+}\PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{pristine value: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{+} \PYG{n}{to\PYGZus{}string}\PYG{p}{(}\PYG{p}{(}\PYG{k+kt}{long} \PYG{k+kt}{long}\PYG{p}{)}\PYG{n}{pristine\PYGZus{}coarse\PYGZus{}map}\PYG{p}{[}\PYG{n}{yval}\PYG{p}{]}\PYG{p}{[}\PYG{n}{xval}\PYG{p}{]}\PYG{p}{)} \PYG{o}{+}
                  \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ returned value: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{+} \PYG{n}{to\PYGZus{}string}\PYG{p}{(}\PYG{p}{(}\PYG{k+kt}{long} \PYG{k+kt}{long}\PYG{p}{)}\PYG{n}{retval}\PYG{p}{)}\PYG{p}{;}
            \PYG{k}{throw} \PYG{n+nf}{FatalException}\PYG{p}{(}\PYG{n}{ec}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
\PYG{c+c1}{// Note that debug mode will throw an exception if the returned value is less than the pristine state}

\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif}
    \PYG{k}{return} \PYG{n}{retval}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{Map}\PYG{o}{:}\PYG{o}{:}\PYG{n}{getValFine}\PYG{p}{(}\PYG{k}{const} \PYG{k+kt}{double}\PYG{o}{\PYGZam{}}\PYG{n}{xval}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{double} \PYG{o}{\PYGZam{}}\PYG{n}{yval}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{double}\PYG{o}{\PYGZam{}} \PYG{n}{current\PYGZus{}generation}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{retval} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
    \PYG{k}{if}\PYG{p}{(}\PYG{n}{has\PYGZus{}pristine}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{is\PYGZus{}pristine} \PYG{o}{\textbar{}}\PYG{o}{\textbar{}} \PYG{n}{pristine\PYGZus{}fine\PYGZus{}map}\PYG{p}{[}\PYG{n}{yval}\PYG{p}{]}\PYG{p}{[}\PYG{n}{xval}\PYG{p}{]} \PYG{o}{=}\PYG{o}{=} \PYG{n}{fine\PYGZus{}map}\PYG{p}{[}\PYG{n}{yval}\PYG{p}{]}\PYG{p}{[}\PYG{n}{xval}\PYG{p}{]}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{retval} \PYG{o}{=} \PYG{n}{pristine\PYGZus{}fine\PYGZus{}map}\PYG{p}{[}\PYG{n}{yval}\PYG{p}{]}\PYG{p}{[}\PYG{n}{xval}\PYG{p}{]}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{else}
        \PYG{p}{\PYGZob{}}
            \PYG{k+kt}{double} \PYG{n}{currentTime} \PYG{o}{=} \PYG{n}{current\PYGZus{}generation} \PYG{o}{\PYGZhy{}} \PYG{n}{current\PYGZus{}map\PYGZus{}time}\PYG{p}{;}
            \PYG{n}{retval} \PYG{o}{=} \PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{long}\PYG{p}{)}\PYG{n}{floor}\PYG{p}{(}\PYG{n}{fine\PYGZus{}map}\PYG{p}{[}\PYG{n}{yval}\PYG{p}{]}\PYG{p}{[}\PYG{n}{xval}\PYG{p}{]} \PYG{o}{+}
                                           \PYG{p}{(}\PYG{n}{habitat\PYGZus{}change\PYGZus{}rate} \PYG{o}{*} \PYG{p}{(}\PYG{p}{(}\PYG{n}{pristine\PYGZus{}fine\PYGZus{}map}\PYG{p}{[}\PYG{n}{yval}\PYG{p}{]}\PYG{p}{[}\PYG{n}{xval}\PYG{p}{]} \PYG{o}{\PYGZhy{}} \PYG{n}{fine\PYGZus{}map}\PYG{p}{[}\PYG{n}{yval}\PYG{p}{]}\PYG{p}{[}\PYG{n}{xval}\PYG{p}{]}\PYG{p}{)} \PYG{o}{/}
                                                   \PYG{p}{(}\PYG{n}{gen\PYGZus{}since\PYGZus{}pristine}\PYG{o}{\PYGZhy{}}\PYG{n}{current\PYGZus{}map\PYGZus{}time}\PYG{p}{)}\PYG{p}{)} \PYG{o}{*} \PYG{n}{currentTime}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{else}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{return} \PYG{n}{fine\PYGZus{}map}\PYG{p}{[}\PYG{n}{yval}\PYG{p}{]}\PYG{p}{[}\PYG{n}{xval}\PYG{p}{]}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
\PYG{c+c1}{// os \PYGZlt{}\PYGZlt{}fine\PYGZus{}map[yval][xval] \PYGZlt{}\PYGZlt{} \PYGZdq{}\PYGZhy{}\PYGZdq{}\PYGZlt{}\PYGZlt{} retval \PYGZlt{}\PYGZlt{} endl;}
\PYG{c+c1}{// Note that debug mode will throw an exception if the returned value is less than the pristine state}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifdef pristine\PYGZus{}mode}
    \PYG{k}{if}\PYG{p}{(}\PYG{n}{has\PYGZus{}pristine}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{retval} \PYG{o}{\PYGZgt{}} \PYG{n}{pristine\PYGZus{}fine\PYGZus{}map}\PYG{p}{[}\PYG{n}{yval}\PYG{p}{]}\PYG{p}{[}\PYG{n}{xval}\PYG{p}{]}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{k}{throw} \PYG{n}{FatalException}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Returned value greater than pristine value. Check file input. (or disable this }\PYG{l+s}{\PYGZdq{}}
                                      \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{error before compilation.}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
    \PYG{p}{\PYGZcb{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif}
    \PYG{k}{return} \PYG{n}{retval}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{Map}\PYG{o}{:}\PYG{o}{:}\PYG{n}{getValFinite}\PYG{p}{(}
    \PYG{k}{const} \PYG{k+kt}{double}\PYG{o}{\PYGZam{}} \PYG{n}{x}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{double}\PYG{o}{\PYGZam{}} \PYG{n}{y}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{long}\PYG{o}{\PYGZam{}} \PYG{n}{xwrap}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{long}\PYG{o}{\PYGZam{}} \PYG{n}{ywrap}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{double}\PYG{o}{\PYGZam{}} \PYG{n}{current\PYGZus{}generation}\PYG{p}{)}
\PYG{p}{\PYGZob{}}

    \PYG{k+kt}{double} \PYG{n}{xval}\PYG{p}{,} \PYG{n}{yval}\PYG{p}{;}
    \PYG{n}{xval} \PYG{o}{=} \PYG{n}{x} \PYG{o}{+} \PYG{p}{(}\PYG{n}{x\PYGZus{}dim} \PYG{o}{*} \PYG{n}{xwrap}\PYG{p}{)}\PYG{p}{;}  \PYG{c+c1}{//}
    \PYG{n}{yval} \PYG{o}{=} \PYG{n}{y} \PYG{o}{+} \PYG{p}{(}\PYG{n}{y\PYGZus{}dim} \PYG{o}{*} \PYG{n}{ywrap}\PYG{p}{)}\PYG{p}{;}
    \PYG{c+c1}{//      // return 0 if the requested coordinate is completely outside the map}
    \PYG{k}{if}\PYG{p}{(}\PYG{n}{xval} \PYG{o}{\PYGZlt{}} \PYG{n}{coarse\PYGZus{}x\PYGZus{}min} \PYG{o}{\textbar{}}\PYG{o}{\textbar{}} \PYG{n}{xval} \PYG{o}{\PYGZgt{}}\PYG{o}{=} \PYG{n}{coarse\PYGZus{}x\PYGZus{}max} \PYG{o}{\textbar{}}\PYG{o}{\textbar{}} \PYG{n}{yval} \PYG{o}{\PYGZlt{}} \PYG{n}{coarse\PYGZus{}y\PYGZus{}min} \PYG{o}{\textbar{}}\PYG{o}{\textbar{}} \PYG{n}{yval} \PYG{o}{\PYGZgt{}}\PYG{o}{=} \PYG{n}{coarse\PYGZus{}y\PYGZus{}max}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{return} \PYG{l+m+mi}{0}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{if}\PYG{p}{(}\PYG{p}{(}\PYG{n}{xval} \PYG{o}{\PYGZlt{}} \PYG{n}{fine\PYGZus{}x\PYGZus{}min} \PYG{o}{\textbar{}}\PYG{o}{\textbar{}} \PYG{n}{xval} \PYG{o}{\PYGZgt{}}\PYG{o}{=} \PYG{n}{fine\PYGZus{}x\PYGZus{}max} \PYG{o}{\textbar{}}\PYG{o}{\textbar{}} \PYG{n}{yval} \PYG{o}{\PYGZlt{}} \PYG{n}{fine\PYGZus{}y\PYGZus{}min} \PYG{o}{\textbar{}}\PYG{o}{\textbar{}}
       \PYG{n}{yval} \PYG{o}{\PYGZgt{}}\PYG{o}{=} \PYG{n}{fine\PYGZus{}y\PYGZus{}max}\PYG{p}{)} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{n}{bCoarse}\PYG{p}{)}  \PYG{c+c1}{// check if the coordinate comes from the coarse resolution map.}
    \PYG{p}{\PYGZob{}}
        \PYG{c+c1}{// take in to account the fine map offsetting}
        \PYG{n}{xval} \PYG{o}{+}\PYG{o}{=} \PYG{n}{fine\PYGZus{}x\PYGZus{}offset}\PYG{p}{;}
        \PYG{n}{yval} \PYG{o}{+}\PYG{o}{=} \PYG{n}{fine\PYGZus{}y\PYGZus{}offset}\PYG{p}{;}
        \PYG{c+c1}{// take in to account the coarse map offsetting and the increased scale of the larger map.}
        \PYG{n}{xval} \PYG{o}{=} \PYG{n}{floor}\PYG{p}{(}\PYG{p}{(}\PYG{n}{xval} \PYG{o}{+} \PYG{n}{coarse\PYGZus{}x\PYGZus{}offset}\PYG{p}{)} \PYG{o}{/} \PYG{n}{scale}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{yval} \PYG{o}{=} \PYG{n}{floor}\PYG{p}{(}\PYG{p}{(}\PYG{n}{yval} \PYG{o}{+} \PYG{n}{coarse\PYGZus{}y\PYGZus{}offset}\PYG{p}{)} \PYG{o}{/} \PYG{n}{scale}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{return} \PYG{n+nf}{getValCoarse}\PYG{p}{(}\PYG{n}{xval}\PYG{p}{,} \PYG{n}{yval}\PYG{p}{,} \PYG{n}{current\PYGZus{}generation}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{c+c1}{// take in to account the fine map offsetting}
    \PYG{c+c1}{// this is done twice to avoid having all the comparisons involve additions.}
    \PYG{n}{xval} \PYG{o}{+}\PYG{o}{=} \PYG{n}{fine\PYGZus{}x\PYGZus{}offset}\PYG{p}{;}
    \PYG{n}{yval} \PYG{o}{+}\PYG{o}{=} \PYG{n}{fine\PYGZus{}y\PYGZus{}offset}\PYG{p}{;}
    \PYG{k}{return} \PYG{n+nf}{getValFine}\PYG{p}{(}\PYG{n}{xval}\PYG{p}{,} \PYG{n}{yval}\PYG{p}{,} \PYG{n}{current\PYGZus{}generation}\PYG{p}{)}\PYG{p}{;}

\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{Map}\PYG{o}{:}\PYG{o}{:}\PYG{n}{convertSampleXToFineX}\PYG{p}{(}\PYG{k}{const} \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{x}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{xwrap}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k}{return} \PYG{n}{x} \PYG{o}{+} \PYG{n}{fine\PYGZus{}x\PYGZus{}offset} \PYG{o}{+} \PYG{p}{(}\PYG{n}{xwrap} \PYG{o}{*} \PYG{n}{x\PYGZus{}dim}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{Map}\PYG{o}{:}\PYG{o}{:}\PYG{n}{convertSampleYToFineY}\PYG{p}{(}\PYG{k}{const} \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{y}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{ywrap}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k}{return} \PYG{n}{y} \PYG{o}{+} \PYG{n}{fine\PYGZus{}y\PYGZus{}offset} \PYG{o}{+} \PYG{p}{(}\PYG{n}{ywrap} \PYG{o}{*} \PYG{n}{y\PYGZus{}dim}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{void} \PYG{n}{Map}\PYG{o}{:}\PYG{o}{:}\PYG{n}{convertFineToSample}\PYG{p}{(}\PYG{k+kt}{long} \PYG{o}{\PYGZam{}} \PYG{n}{x}\PYG{p}{,} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}} \PYG{n}{xwrap}\PYG{p}{,} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{y}\PYG{p}{,} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{ywrap}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k}{auto} \PYG{n}{tmpx} \PYG{o}{=} \PYG{k+kt}{double}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}\PYG{p}{;}
    \PYG{k}{auto} \PYG{n}{tmpy} \PYG{o}{=} \PYG{k+kt}{double}\PYG{p}{(}\PYG{n}{y}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{convertCoordinates}\PYG{p}{(}\PYG{n}{tmpx}\PYG{p}{,} \PYG{n}{tmpy}\PYG{p}{,} \PYG{n}{xwrap}\PYG{p}{,} \PYG{n}{ywrap}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{x} \PYG{o}{=} \PYG{n}{floor}\PYG{p}{(}\PYG{n}{tmpx}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{y} \PYG{o}{=} \PYG{n}{floor}\PYG{p}{(}\PYG{n}{tmpy}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}


\PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{Map}\PYG{o}{:}\PYG{o}{:}\PYG{n}{getInitialCount}\PYG{p}{(}\PYG{k+kt}{double} \PYG{n}{dSample}\PYG{p}{,} \PYG{n}{DataMask}\PYG{o}{\PYGZam{}} \PYG{n}{samplemask}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{toret}\PYG{p}{;}
    \PYG{n}{toret} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
    \PYG{k+kt}{long} \PYG{n}{x}\PYG{p}{,} \PYG{n}{y}\PYG{p}{;}
    \PYG{k+kt}{long} \PYG{n}{xwrap}\PYG{p}{,} \PYG{n}{ywrap}\PYG{p}{;}
    \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{max\PYGZus{}x}\PYG{p}{,} \PYG{n}{max\PYGZus{}y}\PYG{p}{;}
    \PYG{k}{if}\PYG{p}{(}\PYG{n}{samplemask}\PYG{p}{.}\PYG{n}{getDefault}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{max\PYGZus{}x} \PYG{o}{=} \PYG{n}{fine\PYGZus{}map}\PYG{p}{.}\PYG{n}{GetCols}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{max\PYGZus{}y} \PYG{o}{=} \PYG{n}{fine\PYGZus{}map}\PYG{p}{.}\PYG{n}{GetRows}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{else}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{max\PYGZus{}x} \PYG{o}{=} \PYG{n}{samplemask}\PYG{p}{.}\PYG{n}{sample\PYGZus{}mask}\PYG{p}{.}\PYG{n}{GetCols}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{max\PYGZus{}y} \PYG{o}{=} \PYG{n}{samplemask}\PYG{p}{.}\PYG{n}{sample\PYGZus{}mask}\PYG{p}{.}\PYG{n}{GetRows}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{max\PYGZus{}x}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{j} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{j} \PYG{o}{\PYGZlt{}} \PYG{n}{max\PYGZus{}y}\PYG{p}{;} \PYG{n}{j}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{x} \PYG{o}{=} \PYG{n}{i}\PYG{p}{;}
            \PYG{n}{y} \PYG{o}{=} \PYG{n}{j}\PYG{p}{;}
            \PYG{n}{xwrap} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
            \PYG{n}{ywrap} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
            \PYG{n}{samplemask}\PYG{p}{.}\PYG{n}{recalculate\PYGZus{}coordinates}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,} \PYG{n}{y}\PYG{p}{,} \PYG{n}{xwrap}\PYG{p}{,} \PYG{n}{ywrap}\PYG{p}{)}\PYG{p}{;}
            \PYG{n}{toret} \PYG{o}{+}\PYG{o}{=} \PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{long}\PYG{p}{)} \PYG{p}{(}\PYG{n}{max}\PYG{p}{(}\PYG{n}{floor}\PYG{p}{(}\PYG{n}{dSample} \PYG{o}{*} \PYG{p}{(}\PYG{n}{getVal}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,} \PYG{n}{y}\PYG{p}{,} \PYG{n}{xwrap}\PYG{p}{,} \PYG{n}{ywrap}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{)} \PYG{o}{*}
                                                \PYG{n}{samplemask}\PYG{p}{.}\PYG{n}{getExactValue}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,} \PYG{n}{y}\PYG{p}{,} \PYG{n}{xwrap}\PYG{p}{,} \PYG{n}{ywrap}\PYG{p}{)}\PYG{p}{)}\PYG{p}{,} \PYG{l+m+mf}{0.0}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{return} \PYG{n}{toret}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{n}{SimParameters} \PYG{n}{Map}\PYG{o}{:}\PYG{o}{:}\PYG{n}{getSimParameters}\PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k}{return} \PYG{n}{mapvars}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{bool} \PYG{n}{Map}\PYG{o}{:}\PYG{o}{:}\PYG{n}{checkMap}\PYG{p}{(}\PYG{k}{const} \PYG{k+kt}{double}\PYG{o}{\PYGZam{}} \PYG{n}{x}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{double}\PYG{o}{\PYGZam{}} \PYG{n}{y}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{long}\PYG{o}{\PYGZam{}} \PYG{n}{xwrap}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{long}\PYG{o}{\PYGZam{}} \PYG{n}{ywrap}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{double} \PYG{n}{generation}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k}{return} \PYG{n}{getVal}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,} \PYG{n}{y}\PYG{p}{,} \PYG{n}{xwrap}\PYG{p}{,} \PYG{n}{ywrap}\PYG{p}{,} \PYG{n}{generation}\PYG{p}{)} \PYG{o}{!}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{bool} \PYG{n}{Map}\PYG{o}{:}\PYG{o}{:}\PYG{n}{checkFine}\PYG{p}{(}\PYG{k}{const} \PYG{k+kt}{double}\PYG{o}{\PYGZam{}} \PYG{n}{x}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{double}\PYG{o}{\PYGZam{}} \PYG{n}{y}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{long}\PYG{o}{\PYGZam{}} \PYG{n}{xwrap}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{long}\PYG{o}{\PYGZam{}} \PYG{n}{ywrap}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k+kt}{double} \PYG{n}{tmpx}\PYG{p}{,} \PYG{n}{tmpy}\PYG{p}{;}
    \PYG{n}{tmpx} \PYG{o}{=} \PYG{n}{x} \PYG{o}{+} \PYG{n}{xwrap} \PYG{o}{*} \PYG{n}{x\PYGZus{}dim}\PYG{p}{;}
    \PYG{n}{tmpy} \PYG{o}{=} \PYG{n}{y} \PYG{o}{+} \PYG{n}{ywrap} \PYG{o}{*} \PYG{n}{y\PYGZus{}dim}\PYG{p}{;}
    \PYG{k}{return} \PYG{o}{!}\PYG{p}{(}\PYG{n}{tmpx} \PYG{o}{\PYGZlt{}} \PYG{n}{fine\PYGZus{}x\PYGZus{}min} \PYG{o}{\textbar{}}\PYG{o}{\textbar{}} \PYG{n}{tmpx} \PYG{o}{\PYGZgt{}}\PYG{o}{=} \PYG{n}{fine\PYGZus{}x\PYGZus{}max} \PYG{o}{\textbar{}}\PYG{o}{\textbar{}} \PYG{n}{tmpy} \PYG{o}{\PYGZlt{}} \PYG{n}{fine\PYGZus{}y\PYGZus{}min} \PYG{o}{\textbar{}}\PYG{o}{\textbar{}} \PYG{n}{tmpy} \PYG{o}{\PYGZgt{}}\PYG{o}{=} \PYG{n}{fine\PYGZus{}y\PYGZus{}max}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{void} \PYG{n}{Map}\PYG{o}{:}\PYG{o}{:}\PYG{n}{convertCoordinates}\PYG{p}{(}\PYG{k+kt}{double}\PYG{o}{\PYGZam{}} \PYG{n}{x}\PYG{p}{,} \PYG{k+kt}{double}\PYG{o}{\PYGZam{}} \PYG{n}{y}\PYG{p}{,} \PYG{k+kt}{long}\PYG{o}{\PYGZam{}} \PYG{n}{xwrap}\PYG{p}{,} \PYG{k+kt}{long}\PYG{o}{\PYGZam{}} \PYG{n}{ywrap}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{n}{xwrap} \PYG{o}{+}\PYG{o}{=} \PYG{n}{floor}\PYG{p}{(}\PYG{n}{x} \PYG{o}{/} \PYG{n}{x\PYGZus{}dim}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{ywrap} \PYG{o}{+}\PYG{o}{=} \PYG{n}{floor}\PYG{p}{(}\PYG{n}{y} \PYG{o}{/} \PYG{n}{y\PYGZus{}dim}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{x} \PYG{o}{=} \PYG{n}{x} \PYG{o}{\PYGZhy{}} \PYG{n}{xwrap} \PYG{o}{*} \PYG{n}{x\PYGZus{}dim}\PYG{p}{;}
    \PYG{n}{y} \PYG{o}{=} \PYG{n}{y} \PYG{o}{\PYGZhy{}} \PYG{n}{ywrap} \PYG{o}{*} \PYG{n}{y\PYGZus{}dim}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{Map}\PYG{o}{:}\PYG{o}{:}\PYG{n}{runDispersal}\PYG{p}{(}\PYG{k}{const} \PYG{k+kt}{double}\PYG{o}{\PYGZam{}} \PYG{n}{dist}\PYG{p}{,}
                       \PYG{k}{const} \PYG{k+kt}{double}\PYG{o}{\PYGZam{}} \PYG{n}{angle}\PYG{p}{,}
                       \PYG{k+kt}{long}\PYG{o}{\PYGZam{}} \PYG{n}{startx}\PYG{p}{,}
                       \PYG{k+kt}{long}\PYG{o}{\PYGZam{}} \PYG{n}{starty}\PYG{p}{,}
                       \PYG{k+kt}{long}\PYG{o}{\PYGZam{}} \PYG{n}{startxwrap}\PYG{p}{,}
                       \PYG{k+kt}{long}\PYG{o}{\PYGZam{}} \PYG{n}{startywrap}\PYG{p}{,}
                       \PYG{k+kt}{bool}\PYG{o}{\PYGZam{}} \PYG{n}{disp\PYGZus{}comp}\PYG{p}{,}
                       \PYG{k}{const} \PYG{k+kt}{double}\PYG{o}{\PYGZam{}} \PYG{n}{generation}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
\PYG{c+c1}{// Checks that the start point is not out of matrix \PYGZhy{} this might have to be disabled to ensure that when updating the}
\PYG{c+c1}{// map, it doesn\PYGZsq{}t cause problems.}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifdef pristine\PYGZus{}mode}
    \PYG{k}{if}\PYG{p}{(}\PYG{o}{!}\PYG{n}{checkMap}\PYG{p}{(}\PYG{n}{startx}\PYG{p}{,} \PYG{n}{starty}\PYG{p}{,} \PYG{n}{startxwrap}\PYG{p}{,} \PYG{n}{startywrap}\PYG{p}{,} \PYG{n}{generation}\PYG{p}{)}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{disp\PYGZus{}comp} \PYG{o}{=} \PYG{n+nb}{true}\PYG{p}{;}
        \PYG{k}{return}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif}

    \PYG{c+c1}{// Different calculations for each quadrant to ensure that the dispersal reads the probabilities correctly.}
    \PYG{k+kt}{double} \PYG{n}{newx}\PYG{p}{,} \PYG{n}{newy}\PYG{p}{;}
    \PYG{n}{newx} \PYG{o}{=} \PYG{n}{startx} \PYG{o}{+} \PYG{p}{(}\PYG{n}{x\PYGZus{}dim} \PYG{o}{*} \PYG{n}{startxwrap}\PYG{p}{)} \PYG{o}{+} \PYG{l+m+mf}{0.5}\PYG{p}{;}
    \PYG{n}{newy} \PYG{o}{=} \PYG{n}{starty} \PYG{o}{+} \PYG{p}{(}\PYG{n}{y\PYGZus{}dim} \PYG{o}{*} \PYG{n}{startywrap}\PYG{p}{)} \PYG{o}{+} \PYG{l+m+mf}{0.5}\PYG{p}{;}
    \PYG{k}{if}\PYG{p}{(}\PYG{n}{dispersal\PYGZus{}relative\PYGZus{}cost} \PYG{o}{=}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{c+c1}{// then nothing complicated is required and we can jump straight to the final point.}
        \PYG{n}{newx} \PYG{o}{+}\PYG{o}{=} \PYG{n}{dist} \PYG{o}{*} \PYG{n}{cos}\PYG{p}{(}\PYG{n}{angle}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{newy} \PYG{o}{+}\PYG{o}{=} \PYG{n}{dist} \PYG{o}{*} \PYG{n}{sin}\PYG{p}{(}\PYG{n}{angle}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{else}  \PYG{c+c1}{// we need to see which deforested patches we pass over}
    \PYG{p}{\PYGZob{}}
        \PYG{k+kt}{long} \PYG{n}{boost}\PYG{p}{;}
        \PYG{n}{boost} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;}
        \PYG{k+kt}{double} \PYG{n}{cur\PYGZus{}dist}\PYG{p}{,} \PYG{n}{tot\PYGZus{}dist}\PYG{p}{,} \PYG{n}{l}\PYG{p}{;}
        \PYG{n}{cur\PYGZus{}dist} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
        \PYG{n}{tot\PYGZus{}dist} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
        \PYG{c+c1}{// Four different calculations for the different quadrants.}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{angle} \PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{7} \PYG{o}{*} \PYG{n}{M\PYGZus{}PI\PYGZus{}4} \PYG{o}{\textbar{}}\PYG{o}{\textbar{}} \PYG{n}{angle} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{n}{M\PYGZus{}PI\PYGZus{}4}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{c+c1}{// Continue while the dist travelled is less than the dist energy}
            \PYG{k}{while}\PYG{p}{(}\PYG{n}{cur\PYGZus{}dist} \PYG{o}{\PYGZlt{}} \PYG{n}{dist}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{c+c1}{// Check if the starting position of the loop is in the fine map or not.}
                \PYG{k}{if}\PYG{p}{(}\PYG{n}{checkFine}\PYG{p}{(}\PYG{n}{newx}\PYG{p}{,} \PYG{n}{newy}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{)}
                \PYG{p}{\PYGZob{}}
                    \PYG{c+c1}{// Keep the standard movement rate}
                    \PYG{n}{boost} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;}
                \PYG{p}{\PYGZcb{}}
                \PYG{k}{else}
                \PYG{p}{\PYGZob{}}
                    \PYG{c+c1}{// Accellerate the travel speed if the point is outside the fine grid.}
                    \PYG{c+c1}{// Note this means that lineages travelling from outside the fine grid to within the}
                    \PYG{c+c1}{// fine grid may}
                    \PYG{c+c1}{// see 1 grid\PYGZsq{}s worth of approximation, rather than exact values.}
                    \PYG{c+c1}{// This is an acceptable approximation!}
                    \PYG{n}{boost} \PYG{o}{=} \PYG{n}{deme}\PYG{p}{;}
                \PYG{p}{\PYGZcb{}}

                \PYG{c+c1}{// Add the value to the new x and y values.}
                \PYG{n}{newx} \PYG{o}{=} \PYG{n}{newx} \PYG{o}{+} \PYG{n}{boost}\PYG{p}{;}
                \PYG{n}{newy} \PYG{o}{=} \PYG{n}{newy} \PYG{o}{+} \PYG{n}{boost} \PYG{o}{*} \PYG{n}{tan}\PYG{p}{(}\PYG{n}{angle}\PYG{p}{)}\PYG{p}{;}
                \PYG{c+c1}{// Check if the new point is within forest.}
                \PYG{k}{if}\PYG{p}{(}\PYG{n}{checkMap}\PYG{p}{(}\PYG{n}{newx}\PYG{p}{,} \PYG{n}{newy}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{generation}\PYG{p}{)}\PYG{p}{)}
                \PYG{p}{\PYGZob{}}
                    \PYG{n}{l} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;}
                \PYG{p}{\PYGZcb{}}
                \PYG{k}{else}
                \PYG{p}{\PYGZob{}}
                    \PYG{n}{l} \PYG{o}{=} \PYG{n}{dispersal\PYGZus{}relative\PYGZus{}cost}\PYG{p}{;}
                \PYG{p}{\PYGZcb{}}
                \PYG{c+c1}{// Move forward different dists based on the difficulty of moving through forest.}
                \PYG{n}{cur\PYGZus{}dist} \PYG{o}{=} \PYG{n}{cur\PYGZus{}dist} \PYG{o}{+} \PYG{n}{l} \PYG{o}{*} \PYG{n}{boost} \PYG{o}{*} \PYG{p}{(}\PYG{l+m+mi}{1} \PYG{o}{/} \PYG{n}{cos}\PYG{p}{(}\PYG{n}{angle}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
                \PYG{n}{tot\PYGZus{}dist} \PYG{o}{=} \PYG{n}{tot\PYGZus{}dist} \PYG{o}{+} \PYG{n}{boost} \PYG{o}{*} \PYG{p}{(}\PYG{l+m+mi}{1} \PYG{o}{/} \PYG{n}{cos}\PYG{p}{(}\PYG{n}{angle}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{else} \PYG{k}{if}\PYG{p}{(}\PYG{n}{angle} \PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{3} \PYG{o}{*} \PYG{n}{M\PYGZus{}PI\PYGZus{}4} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{n}{angle} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{l+m+mi}{5} \PYG{o}{*} \PYG{n}{M\PYGZus{}PI\PYGZus{}4}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{k}{while}\PYG{p}{(}\PYG{n}{cur\PYGZus{}dist} \PYG{o}{\PYGZlt{}} \PYG{n}{dist}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{k}{if}\PYG{p}{(}\PYG{n}{checkFine}\PYG{p}{(}\PYG{n}{newx}\PYG{p}{,} \PYG{n}{newy}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{)}
                \PYG{p}{\PYGZob{}}
                    \PYG{n}{boost} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;}
                \PYG{p}{\PYGZcb{}}
                \PYG{k}{else}
                \PYG{p}{\PYGZob{}}
                    \PYG{n}{boost} \PYG{o}{=} \PYG{n}{deme}\PYG{p}{;}
                \PYG{p}{\PYGZcb{}}
                \PYG{c+c1}{// Add the change to the new x and y values.}
                \PYG{n}{newx} \PYG{o}{=} \PYG{n}{newx} \PYG{o}{\PYGZhy{}} \PYG{n}{boost}\PYG{p}{;}
                \PYG{n}{newy} \PYG{o}{=} \PYG{n}{newy} \PYG{o}{+} \PYG{n}{boost} \PYG{o}{*} \PYG{n}{tan}\PYG{p}{(}\PYG{n}{M\PYGZus{}PI} \PYG{o}{\PYGZhy{}} \PYG{n}{angle}\PYG{p}{)}\PYG{p}{;}
                \PYG{k}{if}\PYG{p}{(}\PYG{n}{checkMap}\PYG{p}{(}\PYG{n}{newx}\PYG{p}{,} \PYG{n}{newy}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{generation}\PYG{p}{)}\PYG{p}{)}
                \PYG{p}{\PYGZob{}}
                    \PYG{n}{l} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;}
                \PYG{p}{\PYGZcb{}}
                \PYG{k}{else}
                \PYG{p}{\PYGZob{}}
                    \PYG{n}{l} \PYG{o}{=} \PYG{n}{dispersal\PYGZus{}relative\PYGZus{}cost}\PYG{p}{;}
                \PYG{p}{\PYGZcb{}}
                \PYG{n}{cur\PYGZus{}dist} \PYG{o}{=} \PYG{n}{cur\PYGZus{}dist} \PYG{o}{+} \PYG{n}{boost} \PYG{o}{*} \PYG{n}{l} \PYG{o}{*} \PYG{p}{(}\PYG{l+m+mi}{1} \PYG{o}{/} \PYG{n}{cos}\PYG{p}{(}\PYG{n}{M\PYGZus{}PI} \PYG{o}{\PYGZhy{}} \PYG{n}{angle}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
                \PYG{n}{tot\PYGZus{}dist} \PYG{o}{=} \PYG{n}{tot\PYGZus{}dist} \PYG{o}{+} \PYG{n}{boost} \PYG{o}{*} \PYG{p}{(}\PYG{l+m+mi}{1} \PYG{o}{/} \PYG{n}{cos}\PYG{p}{(}\PYG{n}{M\PYGZus{}PI} \PYG{o}{\PYGZhy{}} \PYG{n}{angle}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{else} \PYG{k}{if}\PYG{p}{(}\PYG{n}{angle} \PYG{o}{\PYGZgt{}} \PYG{n}{M\PYGZus{}PI\PYGZus{}4} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{n}{angle} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{l+m+mi}{3} \PYG{o}{*} \PYG{n}{M\PYGZus{}PI\PYGZus{}4}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{k}{while}\PYG{p}{(}\PYG{n}{cur\PYGZus{}dist} \PYG{o}{\PYGZlt{}} \PYG{n}{dist}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{k}{if}\PYG{p}{(}\PYG{n}{checkFine}\PYG{p}{(}\PYG{n}{newx}\PYG{p}{,} \PYG{n}{newy}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{)}
                \PYG{p}{\PYGZob{}}
                    \PYG{n}{boost} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;}
                \PYG{p}{\PYGZcb{}}
                \PYG{k}{else}
                \PYG{p}{\PYGZob{}}
                    \PYG{n}{boost} \PYG{o}{=} \PYG{n}{deme}\PYG{p}{;}
                \PYG{p}{\PYGZcb{}}
                \PYG{c+c1}{// Add the change to the new x and y values.}
                \PYG{n}{newx} \PYG{o}{=} \PYG{n}{newx} \PYG{o}{+} \PYG{n}{boost} \PYG{o}{*} \PYG{n}{tan}\PYG{p}{(}\PYG{n}{angle} \PYG{o}{\PYGZhy{}} \PYG{n}{M\PYGZus{}PI\PYGZus{}2}\PYG{p}{)}\PYG{p}{;}
                \PYG{n}{newy} \PYG{o}{=} \PYG{n}{newy} \PYG{o}{+} \PYG{n}{boost}\PYG{p}{;}
                \PYG{k}{if}\PYG{p}{(}\PYG{n}{checkMap}\PYG{p}{(}\PYG{n}{newx}\PYG{p}{,} \PYG{n}{newy}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{generation}\PYG{p}{)}\PYG{p}{)}
                \PYG{p}{\PYGZob{}}
                    \PYG{n}{l} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;}
                \PYG{p}{\PYGZcb{}}
                \PYG{k}{else}
                \PYG{p}{\PYGZob{}}
                    \PYG{n}{l} \PYG{o}{=} \PYG{n}{dispersal\PYGZus{}relative\PYGZus{}cost}\PYG{p}{;}
                \PYG{p}{\PYGZcb{}}
                \PYG{n}{cur\PYGZus{}dist} \PYG{o}{=} \PYG{n}{cur\PYGZus{}dist} \PYG{o}{+} \PYG{n}{l} \PYG{o}{*} \PYG{n}{boost} \PYG{o}{/} \PYG{n}{cos}\PYG{p}{(}\PYG{n}{angle} \PYG{o}{\PYGZhy{}} \PYG{n}{M\PYGZus{}PI\PYGZus{}2}\PYG{p}{)}\PYG{p}{;}
                \PYG{n}{tot\PYGZus{}dist} \PYG{o}{=} \PYG{n}{tot\PYGZus{}dist} \PYG{o}{+} \PYG{n}{boost} \PYG{o}{/} \PYG{n}{cos}\PYG{p}{(}\PYG{n}{angle} \PYG{o}{\PYGZhy{}} \PYG{n}{M\PYGZus{}PI\PYGZus{}2}\PYG{p}{)}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{else} \PYG{k}{if}\PYG{p}{(}\PYG{n}{angle} \PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{5} \PYG{o}{*} \PYG{n}{M\PYGZus{}PI\PYGZus{}4} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{n}{angle} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{l+m+mi}{7} \PYG{o}{*} \PYG{n}{M\PYGZus{}PI\PYGZus{}4}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{c+c1}{//              os \PYGZlt{}\PYGZlt{} \PYGZdq{}...ang4...\PYGZdq{} \PYGZlt{}\PYGZlt{}  flush;}
            \PYG{k}{while}\PYG{p}{(}\PYG{n}{cur\PYGZus{}dist} \PYG{o}{\PYGZlt{}} \PYG{n}{dist}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{k}{if}\PYG{p}{(}\PYG{n}{checkFine}\PYG{p}{(}\PYG{n}{newx}\PYG{p}{,} \PYG{n}{newy}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{)}
                \PYG{p}{\PYGZob{}}
                    \PYG{n}{boost} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;}
                \PYG{p}{\PYGZcb{}}
                \PYG{k}{else}
                \PYG{p}{\PYGZob{}}
                    \PYG{n}{boost} \PYG{o}{=} \PYG{n}{deme}\PYG{p}{;}
                \PYG{p}{\PYGZcb{}}
                \PYG{n}{newx} \PYG{o}{=} \PYG{n}{newx} \PYG{o}{+} \PYG{n}{boost} \PYG{o}{*} \PYG{n}{tan}\PYG{p}{(}\PYG{l+m+mi}{3} \PYG{o}{*} \PYG{n}{M\PYGZus{}PI\PYGZus{}2} \PYG{o}{\PYGZhy{}} \PYG{n}{angle}\PYG{p}{)}\PYG{p}{;}
                \PYG{n}{newy} \PYG{o}{=} \PYG{n}{newy} \PYG{o}{\PYGZhy{}} \PYG{n}{boost}\PYG{p}{;}
                \PYG{k}{if}\PYG{p}{(}\PYG{n}{checkMap}\PYG{p}{(}\PYG{n}{newx}\PYG{p}{,} \PYG{n}{newy}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{generation}\PYG{p}{)}\PYG{p}{)}
                \PYG{p}{\PYGZob{}}
                    \PYG{n}{l} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;}
                \PYG{p}{\PYGZcb{}}
                \PYG{k}{else}
                \PYG{p}{\PYGZob{}}
                    \PYG{n}{l} \PYG{o}{=} \PYG{n}{dispersal\PYGZus{}relative\PYGZus{}cost}\PYG{p}{;}
                \PYG{p}{\PYGZcb{}}
                \PYG{n}{cur\PYGZus{}dist} \PYG{o}{=} \PYG{n}{cur\PYGZus{}dist} \PYG{o}{+} \PYG{n}{l} \PYG{o}{*} \PYG{n}{boost} \PYG{o}{/} \PYG{n}{cos}\PYG{p}{(}\PYG{l+m+mi}{3} \PYG{o}{*} \PYG{n}{M\PYGZus{}PI\PYGZus{}2} \PYG{o}{\PYGZhy{}} \PYG{n}{angle}\PYG{p}{)}\PYG{p}{;}
                \PYG{n}{tot\PYGZus{}dist} \PYG{o}{=} \PYG{n}{tot\PYGZus{}dist} \PYG{o}{+} \PYG{n}{boost} \PYG{o}{/} \PYG{n}{cos}\PYG{p}{(}\PYG{l+m+mi}{3} \PYG{o}{*} \PYG{n}{M\PYGZus{}PI\PYGZus{}2} \PYG{o}{\PYGZhy{}} \PYG{n}{angle}\PYG{p}{)}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
        \PYG{p}{\PYGZcb{}}
        \PYG{c+c1}{// Move the point back to get the exact placement}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{checkMap}\PYG{p}{(}\PYG{n}{newx}\PYG{p}{,} \PYG{n}{newy}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{generation}\PYG{p}{)}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{tot\PYGZus{}dist} \PYG{o}{=} \PYG{n}{tot\PYGZus{}dist} \PYG{o}{\PYGZhy{}} \PYG{n}{min}\PYG{p}{(}\PYG{n}{cur\PYGZus{}dist} \PYG{o}{\PYGZhy{}} \PYG{n}{dist}\PYG{p}{,} \PYG{p}{(}\PYG{k+kt}{double}\PYG{p}{(}\PYG{n}{boost}\PYG{p}{)} \PYG{o}{\PYGZhy{}} \PYG{l+m+mf}{0.001}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{else}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{disp\PYGZus{}comp} \PYG{o}{=} \PYG{n+nb}{true}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{n}{newx} \PYG{o}{=} \PYG{n}{startx} \PYG{o}{+} \PYG{l+m+mf}{0.5} \PYG{o}{+} \PYG{n}{tot\PYGZus{}dist} \PYG{o}{*} \PYG{n}{cos}\PYG{p}{(}\PYG{n}{angle}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{newy} \PYG{o}{=} \PYG{n}{starty} \PYG{o}{+} \PYG{l+m+mf}{0.5} \PYG{o}{+} \PYG{n}{tot\PYGZus{}dist} \PYG{o}{*} \PYG{n}{sin}\PYG{p}{(}\PYG{n}{angle}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{ret} \PYG{o}{=} \PYG{n}{getVal}\PYG{p}{(}\PYG{n}{newx}\PYG{p}{,} \PYG{n}{newy}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{generation}\PYG{p}{)}\PYG{p}{;}
    \PYG{k}{if}\PYG{p}{(}\PYG{n}{ret} \PYG{o}{\PYGZgt{}}\PYG{l+m+mi}{0}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k+kt}{long} \PYG{n}{newxwrap}\PYG{p}{,} \PYG{n}{newywrap}\PYG{p}{;}
        \PYG{n}{newxwrap} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
        \PYG{n}{newywrap} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
        \PYG{n}{convertCoordinates}\PYG{p}{(}\PYG{n}{newx}\PYG{p}{,} \PYG{n}{newy}\PYG{p}{,} \PYG{n}{newxwrap}\PYG{p}{,} \PYG{n}{newywrap}\PYG{p}{)}\PYG{p}{;}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifdef DEBUG}
        \PYG{k}{if}\PYG{p}{(}\PYG{o}{!}\PYG{n}{checkMap}\PYG{p}{(}\PYG{n}{newx}\PYG{p}{,} \PYG{n}{newy}\PYG{p}{,} \PYG{n}{newxwrap}\PYG{p}{,} \PYG{n}{newywrap}\PYG{p}{,} \PYG{n}{generation}\PYG{p}{)}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{k}{throw} \PYG{n}{FatalException}\PYG{p}{(}\PYG{n}{string}\PYG{p}{(}
                \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ERROR\PYGZus{}MOVE\PYGZus{}007: Dispersal attempted to non\PYGZhy{}forest. Check dispersal function. Forest cover: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{+}
                \PYG{n}{to\PYGZus{}string}\PYG{p}{(}\PYG{p}{(}\PYG{k+kt}{long} \PYG{k+kt}{long}\PYG{p}{)}\PYG{n}{getVal}\PYG{p}{(}\PYG{n}{newx}\PYG{p}{,} \PYG{n}{newy}\PYG{p}{,} \PYG{n}{newxwrap}\PYG{p}{,} \PYG{n}{newywrap}\PYG{p}{,} \PYG{n}{generation}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif}
        \PYG{n}{startx} \PYG{o}{=} \PYG{n}{newx}\PYG{p}{;}
        \PYG{n}{starty} \PYG{o}{=} \PYG{n}{newy}\PYG{p}{;}
        \PYG{n}{startxwrap} \PYG{o}{=} \PYG{n}{newxwrap}\PYG{p}{;}
        \PYG{n}{startywrap} \PYG{o}{=} \PYG{n}{newywrap}\PYG{p}{;}
        \PYG{n}{disp\PYGZus{}comp} \PYG{o}{=} \PYG{n+nb}{false}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{return} \PYG{n}{ret}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}

\PYG{k+kt}{void} \PYG{n}{Map}\PYG{o}{:}\PYG{o}{:}\PYG{n}{clearMap}\PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{n}{current\PYGZus{}map\PYGZus{}time} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
    \PYG{n}{check\PYGZus{}set\PYGZus{}dim} \PYG{o}{=} \PYG{n+nb}{false}\PYG{p}{;}
    \PYG{n}{is\PYGZus{}pristine} \PYG{o}{=} \PYG{n+nb}{false}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{n}{string} \PYG{n}{Map}\PYG{o}{:}\PYG{o}{:}\PYG{n}{printVars}\PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{n}{stringstream} \PYG{n}{os}\PYG{p}{;}
    \PYG{n}{os} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{fine x limits: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{fine\PYGZus{}x\PYGZus{}min} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ , }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{fine\PYGZus{}x\PYGZus{}max} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
    \PYG{n}{os} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{fine y limits: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{fine\PYGZus{}y\PYGZus{}min} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ , }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{fine\PYGZus{}y\PYGZus{}max} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
    \PYG{n}{os} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{fine map offset: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{fine\PYGZus{}x\PYGZus{}offset} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ , }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{fine\PYGZus{}y\PYGZus{}offset} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
    \PYG{n}{os} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{coarse x limits: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{coarse\PYGZus{}x\PYGZus{}min} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ , }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{coarse\PYGZus{}x\PYGZus{}max} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
    \PYG{n}{os} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{coarse y limits: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{coarse\PYGZus{}y\PYGZus{}min} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ , }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{coarse\PYGZus{}y\PYGZus{}max} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
    \PYG{n}{os} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{x,y dims: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{x\PYGZus{}dim} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ , }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{y\PYGZus{}dim} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
    \PYG{k}{return} \PYG{n}{os}\PYG{p}{.}\PYG{n}{str}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{Map}\PYG{o}{:}\PYG{o}{:}\PYG{n}{getHabitatMax}\PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k}{return} \PYG{n}{habitat\PYGZus{}max}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{void} \PYG{n}{Map}\PYG{o}{:}\PYG{o}{:}\PYG{n}{recalculateHabitatMax}\PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{n}{habitat\PYGZus{}max} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
    \PYG{k}{if}\PYG{p}{(}\PYG{n}{is\PYGZus{}pristine} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{n}{has\PYGZus{}pristine}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{habitat\PYGZus{}max} \PYG{o}{\PYGZlt{}} \PYG{n}{pristine\PYGZus{}fine\PYGZus{}max}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{habitat\PYGZus{}max} \PYG{o}{=} \PYG{n}{pristine\PYGZus{}fine\PYGZus{}max}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{habitat\PYGZus{}max} \PYG{o}{\PYGZlt{}} \PYG{n}{pristine\PYGZus{}coarse\PYGZus{}max}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{habitat\PYGZus{}max} \PYG{o}{=} \PYG{n}{pristine\PYGZus{}coarse\PYGZus{}max}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{else}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{habitat\PYGZus{}max} \PYG{o}{\PYGZlt{}} \PYG{n}{fine\PYGZus{}max}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{habitat\PYGZus{}max} \PYG{o}{=} \PYG{n}{fine\PYGZus{}max}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{habitat\PYGZus{}max} \PYG{o}{\PYGZlt{}} \PYG{n}{coarse\PYGZus{}max}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{habitat\PYGZus{}max} \PYG{o}{=} \PYG{n}{coarse\PYGZus{}max}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{habitat\PYGZus{}max} \PYG{o}{\PYGZlt{}} \PYG{n}{pristine\PYGZus{}fine\PYGZus{}max}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{habitat\PYGZus{}max} \PYG{o}{=} \PYG{n}{pristine\PYGZus{}fine\PYGZus{}max}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{habitat\PYGZus{}max} \PYG{o}{\PYGZlt{}} \PYG{n}{pristine\PYGZus{}coarse\PYGZus{}max}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{habitat\PYGZus{}max} \PYG{o}{=} \PYG{n}{pristine\PYGZus{}coarse\PYGZus{}max}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
    \PYG{p}{\PYGZcb{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifdef DEBUG}
    \PYG{k}{if}\PYG{p}{(}\PYG{n}{habitat\PYGZus{}max} \PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{10000}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{stringstream} \PYG{n}{ss}\PYG{p}{;}
        \PYG{n}{writeLog}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{habitat\PYGZus{}max may be unreasonably large: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{+} \PYG{n}{to\PYGZus{}string}\PYG{p}{(}\PYG{n}{habitat\PYGZus{}max}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{ss} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{fine, coarse, pfine, pcoarse: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{fine\PYGZus{}max} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{, }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{coarse\PYGZus{}max}\PYG{p}{;}
        \PYG{n}{ss} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{, }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{pristine\PYGZus{}fine\PYGZus{}max} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{, }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{pristine\PYGZus{}coarse\PYGZus{}max} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}


\subsubsection{Detailed Description}
\label{\detokenize{api/file_necsim_Map.cpp:detailed-description}}
Samuel Thompson
BSD-3 Licence.


\subsubsection{Includes}
\label{\detokenize{api/file_necsim_Map.cpp:includes}}\begin{itemize}
\item {} 
\sphinxcode{CustomExceptions.h} ({\hyperref[\detokenize{api/file_necsim_CustomExceptions.h:file-necsim-customexceptions-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File CustomExceptions.h}}}})

\item {} 
\sphinxcode{Filesystem.h} ({\hyperref[\detokenize{api/file_necsim_Filesystem.h:file-necsim-filesystem-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File Filesystem.h}}}})

\item {} 
\sphinxcode{Map.h} ({\hyperref[\detokenize{api/file_necsim_Map.h:file-necsim-map-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File Map.h}}}})

\end{itemize}


\subsection{File Map.h}
\label{\detokenize{api/file_necsim_Map.h:file-map-h}}\label{\detokenize{api/file_necsim_Map.h::doc}}\label{\detokenize{api/file_necsim_Map.h:file-necsim-map-h}}
Contains the {\hyperref[\detokenize{api/class_Map:class-map}]{\sphinxcrossref{\DUrole{std,std-ref}{Class Map}}}} object for easy referencing of the respective coarse and fine map within the same coordinate system.

\begin{sphinxShadowBox}
\sphinxstyletopictitle{Contents}
\begin{itemize}
\item {} 
\phantomsection\label{\detokenize{api/file_necsim_Map.h:id1}}{\hyperref[\detokenize{api/file_necsim_Map.h:definition-necsim-map-h}]{\sphinxcrossref{Definition (\sphinxcode{necsim/Map.h})}}}

\item {} 
\phantomsection\label{\detokenize{api/file_necsim_Map.h:id2}}{\hyperref[\detokenize{api/file_necsim_Map.h:detailed-description}]{\sphinxcrossref{Detailed Description}}}

\item {} 
\phantomsection\label{\detokenize{api/file_necsim_Map.h:id3}}{\hyperref[\detokenize{api/file_necsim_Map.h:includes}]{\sphinxcrossref{Includes}}}

\item {} 
\phantomsection\label{\detokenize{api/file_necsim_Map.h:id4}}{\hyperref[\detokenize{api/file_necsim_Map.h:included-by}]{\sphinxcrossref{Included By}}}

\item {} 
\phantomsection\label{\detokenize{api/file_necsim_Map.h:id5}}{\hyperref[\detokenize{api/file_necsim_Map.h:classes}]{\sphinxcrossref{Classes}}}

\end{itemize}
\end{sphinxShadowBox}


\subsubsection{Definition (\sphinxstyleliteralintitle{necsim/Map.h})}
\label{\detokenize{api/file_necsim_Map.h:definition-necsim-map-h}}

\paragraph{Program Listing for File Map.h}
\label{\detokenize{api/program_listing_file_necsim_Map.h:program-listing-for-file-map-h}}\label{\detokenize{api/program_listing_file_necsim_Map.h::doc}}\label{\detokenize{api/program_listing_file_necsim_Map.h:program-listing-file-necsim-map-h}}\begin{itemize}
\item {} 
Return to documentation for {\hyperref[\detokenize{api/file_necsim_Map.h:file-necsim-map-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File Map.h}}}}

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{//This file is part of NECSim project which is released under BSD\PYGZhy{}3 license.}
\PYG{c+c1}{//See file **LICENSE.txt** or visit https://opensource.org/licenses/BSD\PYGZhy{}3\PYGZhy{}Clause) for full license details}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifndef MAP}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define MAP}

\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ include \PYGZlt{}string\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ include \PYGZlt{}stdio.h\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}vector\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ include \PYGZlt{}iostream\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ include \PYGZlt{}fstream\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ include \PYGZlt{}math.h\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ include \PYGZlt{}stdexcept\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ include \PYGZlt{}boost}\PYG{c+cp}{/}\PYG{c+cp}{filesystem.hpp\PYGZgt{}}

\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZdq{}Matrix.h\PYGZdq{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZdq{}DataMask.h\PYGZdq{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZdq{}SimParameters.h\PYGZdq{}}

\PYG{k}{using} \PYG{k}{namespace} \PYG{n}{std}\PYG{p}{;}

\PYG{c+c1}{// Object containing both the maps (the coarse and fine version) and routines for easy setting up and switching between}
\PYG{c+c1}{// the different coordinate systems.}
\PYG{k}{class} \PYG{n+nc}{Map}
\PYG{p}{\PYGZob{}}
\PYG{k}{protected}\PYG{o}{:}
    \PYG{c+c1}{// The map files which are read in (or generated if running with \PYGZdq{}null\PYGZdq{} as the map file\PYGZdq{}.}
    \PYG{c+c1}{// Pristine maps are meant for before any deforestation occured, whereas the other maps are intended for modern day maps.}
    \PYG{c+c1}{// A linear transformation from modern to pristine maps is used, approaching the habitat\PYGZus{}change\PYGZus{}rate variable times the difference between the pristine and modern maps.}
    \PYG{c+c1}{// Once the gen\PYGZus{}since\PYGZus{}pristine number of generations has been reached, the map will jump to the pristine condition.}
    \PYG{c+c1}{// the finer grid for the area around the sample area.}
    \PYG{n}{Matrix}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{uint32\PYGZus{}t}\PYG{o}{\PYGZgt{}} \PYG{n}{fine\PYGZus{}map}\PYG{p}{;}
    \PYG{c+c1}{// the pristine finer map.}
    \PYG{n}{Matrix}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{uint32\PYGZus{}t}\PYG{o}{\PYGZgt{}} \PYG{n}{pristine\PYGZus{}fine\PYGZus{}map}\PYG{p}{;}
    \PYG{c+c1}{// the coarser grid for the wider zone.}
    \PYG{n}{Matrix}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{uint32\PYGZus{}t}\PYG{o}{\PYGZgt{}} \PYG{n}{coarse\PYGZus{}map}\PYG{p}{;}
    \PYG{c+c1}{// the pristine coarser map.}
    \PYG{n}{Matrix}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{uint32\PYGZus{}t}\PYG{o}{\PYGZgt{}} \PYG{n}{pristine\PYGZus{}coarse\PYGZus{}map}\PYG{p}{;}
    \PYG{c+c1}{// for importing and storing the simulation set\PYGZhy{}up options.}
    \PYG{n}{SimParameters} \PYG{n}{mapvars}\PYG{p}{;}
    \PYG{c+c1}{// the minimum values for each dimension for offsetting.}
    \PYG{k+kt}{long} \PYG{n}{fine\PYGZus{}x\PYGZus{}min}\PYG{p}{,} \PYG{n}{fine\PYGZus{}y\PYGZus{}min}\PYG{p}{,} \PYG{n}{coarse\PYGZus{}x\PYGZus{}min}\PYG{p}{,} \PYG{n}{coarse\PYGZus{}y\PYGZus{}min}\PYG{p}{;}
    \PYG{c+c1}{// the maximum values for each dimension for offsetting.}
    \PYG{k+kt}{long} \PYG{n}{fine\PYGZus{}x\PYGZus{}max}\PYG{p}{,} \PYG{n}{fine\PYGZus{}y\PYGZus{}max}\PYG{p}{,} \PYG{n}{coarse\PYGZus{}x\PYGZus{}max}\PYG{p}{,} \PYG{n}{coarse\PYGZus{}y\PYGZus{}max}\PYG{p}{;}
    \PYG{c+c1}{// the offsetting of the map in FINE map units.}
    \PYG{k+kt}{long} \PYG{n}{fine\PYGZus{}x\PYGZus{}offset}\PYG{p}{,} \PYG{n}{fine\PYGZus{}y\PYGZus{}offset}\PYG{p}{,} \PYG{n}{coarse\PYGZus{}x\PYGZus{}offset}\PYG{p}{,} \PYG{n}{coarse\PYGZus{}y\PYGZus{}offset}\PYG{p}{;}
    \PYG{c+c1}{// the scale of the coarse map compared with the smaller map.}
    \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{scale}\PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
    \PYG{c+c1}{// the length of the grid where the species start.}
    \PYG{k+kt}{long} \PYG{n}{x\PYGZus{}dim}\PYG{p}{;}
    \PYG{c+c1}{// the height of the grid where the species start.}
    \PYG{k+kt}{long} \PYG{n}{y\PYGZus{}dim}\PYG{p}{;}
    \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{deme}\PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
    \PYG{c+c1}{// for checking that the dimensions have been set before attempting to importSpatialParameters the maps.}
    \PYG{k+kt}{bool} \PYG{n}{check\PYGZus{}set\PYGZus{}dim}\PYG{p}{;}
    \PYG{c+c1}{// for setting the movement cost through forest.}
    \PYG{k+kt}{double} \PYG{n}{dispersal\PYGZus{}relative\PYGZus{}cost}\PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
    \PYG{c+c1}{// the last time the map was updated, in generations.}
    \PYG{k+kt}{double} \PYG{n}{update\PYGZus{}time}\PYG{p}{;}
    \PYG{c+c1}{// the rate at which the habitat transforms from the modern forest map to the pristine habitat map.}
    \PYG{c+c1}{// A value of 1 will give a smooth curve from the present day to pristine habitat.}
    \PYG{k+kt}{double} \PYG{n}{habitat\PYGZus{}change\PYGZus{}rate}\PYG{p}{;}
    \PYG{c+c1}{// the number of generations at which point the habitat becomes entirely pristine.}
    \PYG{k+kt}{double} \PYG{n}{gen\PYGZus{}since\PYGZus{}pristine}\PYG{p}{;}
    \PYG{c+c1}{// the time the current map was updated.}
    \PYG{k+kt}{double} \PYG{n}{current\PYGZus{}map\PYGZus{}time}\PYG{p}{;}
    \PYG{c+c1}{// checks whether the simulation has already been set to the pristine state.}
    \PYG{k+kt}{bool} \PYG{n}{is\PYGZus{}pristine}\PYG{p}{;}
    \PYG{c+c1}{// flag of whether the simulation has a pristine state or not.}
    \PYG{k+kt}{bool} \PYG{n}{has\PYGZus{}pristine}\PYG{p}{;}
    \PYG{c+c1}{// the maximum value for habitat}
    \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{habitat\PYGZus{}max}\PYG{p}{;}
    \PYG{c+c1}{// the maximum value on the fine map file}
    \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{fine\PYGZus{}max}\PYG{p}{;}
    \PYG{c+c1}{// the maximum value on the coarse map file}
    \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{coarse\PYGZus{}max}\PYG{p}{;}
    \PYG{c+c1}{// the maximum value on the pristine fine map file}
    \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{pristine\PYGZus{}fine\PYGZus{}max}\PYG{p}{;}
    \PYG{c+c1}{// the maximum value on the pristine coarse map file}
    \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{pristine\PYGZus{}coarse\PYGZus{}max}\PYG{p}{;}
    \PYG{c+c1}{// if true, dispersal is possible from anywhere, only the fine map spatial structure is preserved}
    \PYG{n}{string} \PYG{n}{landscape\PYGZus{}type}\PYG{p}{;}
    \PYG{n}{string} \PYG{n}{NextMap}\PYG{p}{;}
    \PYG{c+c1}{// If this is false, there is no coarse map defined, so ignore the boundaries.}
    \PYG{k+kt}{bool} \PYG{n}{bCoarse}\PYG{p}{;}
    \PYG{c+c1}{// the number of updates to have occured.}
    \PYG{k+kt}{unsigned} \PYG{k+kt}{int} \PYG{n}{nUpdate}\PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
    \PYG{c+c1}{// Typedef for single application of the infinite landscape verses bounded landscape.}
    \PYG{k}{typedef} \PYG{k+kt}{unsigned} \PYG{n+nf}{long} \PYG{p}{(}\PYG{n}{Map}\PYG{o}{:}\PYG{o}{:}\PYG{o}{*}\PYG{n}{fptr}\PYG{p}{)}\PYG{p}{(}\PYG{k}{const} \PYG{k+kt}{double} \PYG{o}{\PYGZam{}}\PYG{n}{x}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{double} \PYG{o}{\PYGZam{}}\PYG{n}{y}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{xwrap}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{ywrap}\PYG{p}{,}
                                       \PYG{k}{const} \PYG{k+kt}{double} \PYG{o}{\PYGZam{}}\PYG{n}{dCurrentGen}\PYG{p}{)}\PYG{p}{;}

    \PYG{n}{fptr} \PYG{n}{getValFunc}\PYG{p}{;}
\PYG{k}{public}\PYG{o}{:}
    \PYG{n}{Map}\PYG{p}{(}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{check\PYGZus{}set\PYGZus{}dim} \PYG{o}{=} \PYG{n+nb}{false}\PYG{p}{;} \PYG{c+c1}{// sets the check to false.}
        \PYG{n}{is\PYGZus{}pristine} \PYG{o}{=} \PYG{n+nb}{false}\PYG{p}{;}
        \PYG{n}{current\PYGZus{}map\PYGZus{}time} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
        \PYG{n}{habitat\PYGZus{}max} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;}
        \PYG{n}{getValFunc} \PYG{o}{=} \PYG{k}{nullptr}\PYG{p}{;}
        \PYG{n}{bCoarse} \PYG{o}{=} \PYG{n+nb}{false}\PYG{p}{;}
        \PYG{n}{has\PYGZus{}pristine} \PYG{o}{=} \PYG{n+nb}{false}\PYG{p}{;}
        \PYG{n}{landscape\PYGZus{}type} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{closed}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
        \PYG{n}{fine\PYGZus{}max} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
        \PYG{n}{coarse\PYGZus{}max} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
        \PYG{n}{pristine\PYGZus{}fine\PYGZus{}max} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
        \PYG{n}{pristine\PYGZus{}coarse\PYGZus{}max} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{getHabitatMax}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

    \PYG{k+kt}{void} \PYG{n+nf}{setDims}\PYG{p}{(}\PYG{n}{SimParameters} \PYG{n}{mapvarsin}\PYG{p}{)}\PYG{p}{;}

    \PYG{k+kt}{bool} \PYG{n+nf}{checkMapExists}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

    \PYG{c+cm}{/********************************************}
\PYG{c+cm}{     * CALC MAP FUNCTIONS}
\PYG{c+cm}{     ********************************************/}

    \PYG{k+kt}{void} \PYG{n+nf}{calcFineMap}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

    \PYG{k+kt}{void} \PYG{n+nf}{calcPristineFineMap}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

    \PYG{k+kt}{void} \PYG{n+nf}{calcCoarseMap}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

    \PYG{k+kt}{void} \PYG{n+nf}{calcPristineCoarseMap}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

    \PYG{k+kt}{void} \PYG{n+nf}{setTimeVars}\PYG{p}{(}\PYG{k+kt}{double} \PYG{n}{gen\PYGZus{}since\PYGZus{}pristine\PYGZus{}in}\PYG{p}{,} \PYG{k+kt}{double} \PYG{n}{habitat\PYGZus{}change\PYGZus{}rate\PYGZus{}in}\PYG{p}{)}\PYG{p}{;}


    \PYG{k+kt}{void} \PYG{n+nf}{calcOffset}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
    \PYG{c+cm}{/********************************************}
\PYG{c+cm}{     * VALIDATE MAPS}
\PYG{c+cm}{     ********************************************/}

    \PYG{k+kt}{void} \PYG{n+nf}{validateMaps}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

    \PYG{c+cm}{/********************************************}
\PYG{c+cm}{     * CHANGE MAP FUNCTIONS}
\PYG{c+cm}{     ********************************************/}

    \PYG{k+kt}{void} \PYG{n+nf}{updateMap}\PYG{p}{(}\PYG{k+kt}{double} \PYG{n}{generation}\PYG{p}{)}\PYG{p}{;}

    \PYG{k+kt}{bool} \PYG{n+nf}{isPristine}\PYG{p}{(}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{has\PYGZus{}pristine}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{k}{return} \PYG{n}{is\PYGZus{}pristine}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{return} \PYG{n+nb}{true}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{k+kt}{void} \PYG{n+nf}{setPristine}\PYG{p}{(}\PYG{k}{const} \PYG{k+kt}{bool} \PYG{o}{\PYGZam{}}\PYG{n}{bPristinein}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{is\PYGZus{}pristine} \PYG{o}{=} \PYG{n}{bPristinein}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{k+kt}{double} \PYG{n+nf}{getPristine}\PYG{p}{(}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{return} \PYG{n}{gen\PYGZus{}since\PYGZus{}pristine}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{n}{string} \PYG{n+nf}{getLandscapeType}\PYG{p}{(}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{return} \PYG{n}{landscape\PYGZus{}type}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{k+kt}{void} \PYG{n+nf}{checkPristine}\PYG{p}{(}\PYG{k+kt}{double} \PYG{n}{generation}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{has\PYGZus{}pristine}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{k}{if}\PYG{p}{(}\PYG{n}{generation} \PYG{o}{\PYGZgt{}}\PYG{o}{=} \PYG{n}{gen\PYGZus{}since\PYGZus{}pristine}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{n}{is\PYGZus{}pristine} \PYG{o}{=} \PYG{n+nb}{true}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
        \PYG{p}{\PYGZcb{}}
    \PYG{p}{\PYGZcb{}}
    \PYG{c+c1}{//}
    \PYG{c+cm}{/********************************************}
\PYG{c+cm}{     * GET VAL FUNCTIONS}
\PYG{c+cm}{     ********************************************/}


    \PYG{c+c1}{// Function for getting the val at a particular coordinate from either the coarse or fine map}
    \PYG{c+c1}{// altered to use the current generation as well to determine the value.}


    \PYG{k+kt}{void} \PYG{n+nf}{setLandscape}\PYG{p}{(}\PYG{n}{string} \PYG{n}{is\PYGZus{}infinite}\PYG{p}{)}\PYG{p}{;}

    \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n+nf}{getVal}\PYG{p}{(}\PYG{k}{const} \PYG{k+kt}{double} \PYG{o}{\PYGZam{}}\PYG{n}{x}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{double} \PYG{o}{\PYGZam{}}\PYG{n}{y}\PYG{p}{,}
                         \PYG{k}{const} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{xwrap}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{ywrap}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{double} \PYG{o}{\PYGZam{}}\PYG{n}{current\PYGZus{}generation}\PYG{p}{)}\PYG{p}{;}

    \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n+nf}{getValCoarse}\PYG{p}{(}\PYG{k}{const} \PYG{k+kt}{double} \PYG{o}{\PYGZam{}}\PYG{n}{xval}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{double} \PYG{o}{\PYGZam{}}\PYG{n}{yval}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{double} \PYG{o}{\PYGZam{}}\PYG{n}{current\PYGZus{}generation}\PYG{p}{)}\PYG{p}{;}

    \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n+nf}{getValFine}\PYG{p}{(}\PYG{k}{const} \PYG{k+kt}{double} \PYG{o}{\PYGZam{}}\PYG{n}{xval}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{double} \PYG{o}{\PYGZam{}}\PYG{n}{yval}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{double} \PYG{o}{\PYGZam{}}\PYG{n}{current\PYGZus{}generation}\PYG{p}{)}\PYG{p}{;}

    \PYG{k+kt}{unsigned} \PYG{k+kt}{long}
    \PYG{n+nf}{getValFinite}\PYG{p}{(}\PYG{k}{const} \PYG{k+kt}{double} \PYG{o}{\PYGZam{}}\PYG{n}{x}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{double} \PYG{o}{\PYGZam{}}\PYG{n}{y}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{xwrap}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{ywrap}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{double} \PYG{o}{\PYGZam{}}\PYG{n}{current\PYGZus{}generation}\PYG{p}{)}\PYG{p}{;}


    \PYG{k+kt}{unsigned} \PYG{k+kt}{long}
    \PYG{n+nf}{getValInfinite}\PYG{p}{(}\PYG{k}{const} \PYG{k+kt}{double} \PYG{o}{\PYGZam{}}\PYG{n}{x}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{double} \PYG{o}{\PYGZam{}}\PYG{n}{y}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{xwrap}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{ywrap}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{double} \PYG{o}{\PYGZam{}}\PYG{n}{current\PYGZus{}generation}\PYG{p}{)}\PYG{p}{;}


    \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n+nf}{getValCoarseTiled}\PYG{p}{(}\PYG{k}{const} \PYG{k+kt}{double} \PYG{o}{\PYGZam{}}\PYG{n}{x}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{double} \PYG{o}{\PYGZam{}}\PYG{n}{y}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{xwrap}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{ywrap}\PYG{p}{,}
                                    \PYG{k}{const} \PYG{k+kt}{double} \PYG{o}{\PYGZam{}}\PYG{n}{current\PYGZus{}generation}\PYG{p}{)}\PYG{p}{;}


    \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n+nf}{getValFineTiled}\PYG{p}{(}\PYG{k}{const} \PYG{k+kt}{double} \PYG{o}{\PYGZam{}}\PYG{n}{x}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{double} \PYG{o}{\PYGZam{}}\PYG{n}{y}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{xwrap}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{ywrap}\PYG{p}{,}
                                  \PYG{k}{const} \PYG{k+kt}{double} \PYG{o}{\PYGZam{}}\PYG{n}{current\PYGZus{}generation}\PYG{p}{)}\PYG{p}{;}

    \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n+nf}{convertSampleXToFineX}\PYG{p}{(}\PYG{k}{const} \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{x}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{xwrap}\PYG{p}{)}\PYG{p}{;}

    \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n+nf}{convertSampleYToFineY}\PYG{p}{(}\PYG{k}{const} \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{y}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{ywrap}\PYG{p}{)}\PYG{p}{;}

    \PYG{k+kt}{void} \PYG{n+nf}{convertFineToSample}\PYG{p}{(}\PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{x}\PYG{p}{,} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{xwrap}\PYG{p}{,} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{y}\PYG{p}{,} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{ywrap}\PYG{p}{)}\PYG{p}{;}


    \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n+nf}{getInitialCount}\PYG{p}{(}\PYG{k+kt}{double} \PYG{n}{dSample}\PYG{p}{,} \PYG{n}{DataMask} \PYG{o}{\PYGZam{}}\PYG{n}{samplemask}\PYG{p}{)}\PYG{p}{;}

    \PYG{n}{SimParameters} \PYG{n+nf}{getSimParameters}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

    \PYG{c+cm}{/********************************************}
\PYG{c+cm}{     * CHECK MAP FUNCTIONS}
\PYG{c+cm}{     ********************************************/}
    \PYG{k+kt}{bool} \PYG{n+nf}{checkMap}\PYG{p}{(}\PYG{k}{const} \PYG{k+kt}{double} \PYG{o}{\PYGZam{}}\PYG{n}{x}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{double} \PYG{o}{\PYGZam{}}\PYG{n}{y}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{xwrap}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{ywrap}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{double} \PYG{n}{generation}\PYG{p}{)}\PYG{p}{;}


    \PYG{k+kt}{bool} \PYG{n+nf}{checkFine}\PYG{p}{(}\PYG{k}{const} \PYG{k+kt}{double} \PYG{o}{\PYGZam{}}\PYG{n}{x}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{double} \PYG{o}{\PYGZam{}}\PYG{n}{y}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{xwrap}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{ywrap}\PYG{p}{)}\PYG{p}{;}


    \PYG{k+kt}{void} \PYG{n+nf}{convertCoordinates}\PYG{p}{(}\PYG{k+kt}{double} \PYG{o}{\PYGZam{}}\PYG{n}{x}\PYG{p}{,} \PYG{k+kt}{double} \PYG{o}{\PYGZam{}}\PYG{n}{y}\PYG{p}{,} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{xwrap}\PYG{p}{,} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{ywrap}\PYG{p}{)}\PYG{p}{;}

    \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n+nf}{runDispersal}\PYG{p}{(}\PYG{k}{const} \PYG{k+kt}{double} \PYG{o}{\PYGZam{}}\PYG{n}{dist}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{double} \PYG{o}{\PYGZam{}}\PYG{n}{angle}\PYG{p}{,} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{startx}\PYG{p}{,} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{starty}\PYG{p}{,} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{startxwrap}\PYG{p}{,}
                               \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{startywrap}\PYG{p}{,} \PYG{k+kt}{bool} \PYG{o}{\PYGZam{}}\PYG{n}{disp\PYGZus{}comp}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{double} \PYG{o}{\PYGZam{}}\PYG{n}{generation}\PYG{p}{)}\PYG{p}{;}


    \PYG{k}{friend} \PYG{n}{ostream} \PYG{o}{\PYGZam{}}\PYG{k}{operator}\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{p}{(}\PYG{n}{ostream} \PYG{o}{\PYGZam{}}\PYG{n}{os}\PYG{p}{,} \PYG{k}{const} \PYG{n}{Map} \PYG{o}{\PYGZam{}}\PYG{n}{r}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{os} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{r}\PYG{p}{.}\PYG{n}{mapvars} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{r}\PYG{p}{.}\PYG{n}{fine\PYGZus{}x\PYGZus{}min} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{r}\PYG{p}{.}\PYG{n}{fine\PYGZus{}x\PYGZus{}max} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{r}\PYG{p}{.}\PYG{n}{coarse\PYGZus{}x\PYGZus{}min} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{r}\PYG{p}{.}\PYG{n}{coarse\PYGZus{}x\PYGZus{}max}\PYG{p}{;}
        \PYG{n}{os} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{r}\PYG{p}{.}\PYG{n}{fine\PYGZus{}y\PYGZus{}min} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{r}\PYG{p}{.}\PYG{n}{fine\PYGZus{}y\PYGZus{}max} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{r}\PYG{p}{.}\PYG{n}{coarse\PYGZus{}y\PYGZus{}min} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{r}\PYG{p}{.}\PYG{n}{coarse\PYGZus{}y\PYGZus{}max} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
        \PYG{n}{os} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{r}\PYG{p}{.}\PYG{n}{fine\PYGZus{}x\PYGZus{}offset} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{r}\PYG{p}{.}\PYG{n}{fine\PYGZus{}y\PYGZus{}offset} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{r}\PYG{p}{.}\PYG{n}{coarse\PYGZus{}x\PYGZus{}offset} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{r}\PYG{p}{.}\PYG{n}{coarse\PYGZus{}y\PYGZus{}offset} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
        \PYG{n}{os} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{r}\PYG{p}{.}\PYG{n}{scale} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{r}\PYG{p}{.}\PYG{n}{x\PYGZus{}dim} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{r}\PYG{p}{.}\PYG{n}{y\PYGZus{}dim} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{r}\PYG{p}{.}\PYG{n}{deme} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{r}\PYG{p}{.}\PYG{n}{check\PYGZus{}set\PYGZus{}dim} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}
           \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{r}\PYG{p}{.}\PYG{n}{dispersal\PYGZus{}relative\PYGZus{}cost} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
        \PYG{n}{os} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{r}\PYG{p}{.}\PYG{n}{update\PYGZus{}time} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{r}\PYG{p}{.}\PYG{n}{habitat\PYGZus{}change\PYGZus{}rate} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{r}\PYG{p}{.}\PYG{n}{gen\PYGZus{}since\PYGZus{}pristine} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{r}\PYG{p}{.}\PYG{n}{current\PYGZus{}map\PYGZus{}time} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}
           \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{r}\PYG{p}{.}\PYG{n}{is\PYGZus{}pristine} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
        \PYG{n}{os} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{r}\PYG{p}{.}\PYG{n}{NextMap} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{r}\PYG{p}{.}\PYG{n}{nUpdate} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{r}\PYG{p}{.}\PYG{n}{landscape\PYGZus{}type} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{r}\PYG{p}{.}\PYG{n}{fine\PYGZus{}max} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}
           \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{r}\PYG{p}{.}\PYG{n}{coarse\PYGZus{}max} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
        \PYG{n}{os} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{r}\PYG{p}{.}\PYG{n}{pristine\PYGZus{}fine\PYGZus{}max} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{r}\PYG{p}{.}\PYG{n}{pristine\PYGZus{}coarse\PYGZus{}max} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{r}\PYG{p}{.}\PYG{n}{habitat\PYGZus{}max} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}
           \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{r}\PYG{p}{.}\PYG{n}{bCoarse} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{r}\PYG{p}{.}\PYG{n}{has\PYGZus{}pristine} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
        \PYG{k}{return} \PYG{n}{os}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{k}{friend} \PYG{n}{istream} \PYG{o}{\PYGZam{}}\PYG{k}{operator}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{n}{istream} \PYG{o}{\PYGZam{}}\PYG{n}{is}\PYG{p}{,} \PYG{n}{Map} \PYG{o}{\PYGZam{}}\PYG{n}{r}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{is} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{r}\PYG{p}{.}\PYG{n}{mapvars} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{r}\PYG{p}{.}\PYG{n}{fine\PYGZus{}x\PYGZus{}min}\PYG{p}{;}
        \PYG{n}{is} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{r}\PYG{p}{.}\PYG{n}{fine\PYGZus{}x\PYGZus{}max} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{r}\PYG{p}{.}\PYG{n}{coarse\PYGZus{}x\PYGZus{}min}\PYG{p}{;}
        \PYG{n}{is} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{r}\PYG{p}{.}\PYG{n}{coarse\PYGZus{}x\PYGZus{}max} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{r}\PYG{p}{.}\PYG{n}{fine\PYGZus{}y\PYGZus{}min} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{r}\PYG{p}{.}\PYG{n}{fine\PYGZus{}y\PYGZus{}max}\PYG{p}{;}
        \PYG{n}{is} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{r}\PYG{p}{.}\PYG{n}{coarse\PYGZus{}y\PYGZus{}min} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{r}\PYG{p}{.}\PYG{n}{coarse\PYGZus{}y\PYGZus{}max}\PYG{p}{;}
        \PYG{n}{is} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{r}\PYG{p}{.}\PYG{n}{fine\PYGZus{}x\PYGZus{}offset} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{r}\PYG{p}{.}\PYG{n}{fine\PYGZus{}y\PYGZus{}offset} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{r}\PYG{p}{.}\PYG{n}{coarse\PYGZus{}x\PYGZus{}offset} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{r}\PYG{p}{.}\PYG{n}{coarse\PYGZus{}y\PYGZus{}offset} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{r}\PYG{p}{.}\PYG{n}{scale} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{r}\PYG{p}{.}\PYG{n}{x\PYGZus{}dim} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{r}\PYG{p}{.}\PYG{n}{y\PYGZus{}dim}
           \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{r}\PYG{p}{.}\PYG{n}{deme} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{r}\PYG{p}{.}\PYG{n}{check\PYGZus{}set\PYGZus{}dim} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{r}\PYG{p}{.}\PYG{n}{dispersal\PYGZus{}relative\PYGZus{}cost}\PYG{p}{;}
        \PYG{n}{is} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{r}\PYG{p}{.}\PYG{n}{update\PYGZus{}time} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{r}\PYG{p}{.}\PYG{n}{habitat\PYGZus{}change\PYGZus{}rate} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{r}\PYG{p}{.}\PYG{n}{gen\PYGZus{}since\PYGZus{}pristine} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{r}\PYG{p}{.}\PYG{n}{current\PYGZus{}map\PYGZus{}time} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{r}\PYG{p}{.}\PYG{n}{is\PYGZus{}pristine}\PYG{p}{;}
        \PYG{n}{getline}\PYG{p}{(}\PYG{n}{is}\PYG{p}{,} \PYG{n}{r}\PYG{p}{.}\PYG{n}{NextMap}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{is} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{r}\PYG{p}{.}\PYG{n}{nUpdate}\PYG{p}{;}
        \PYG{n}{is} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{r}\PYG{p}{.}\PYG{n}{landscape\PYGZus{}type}\PYG{p}{;}
        \PYG{n}{is} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{r}\PYG{p}{.}\PYG{n}{fine\PYGZus{}max} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{r}\PYG{p}{.}\PYG{n}{coarse\PYGZus{}max}\PYG{p}{;}
        \PYG{n}{is} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{r}\PYG{p}{.}\PYG{n}{pristine\PYGZus{}fine\PYGZus{}max} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{r}\PYG{p}{.}\PYG{n}{pristine\PYGZus{}coarse\PYGZus{}max}\PYG{p}{;}
        \PYG{n}{is} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{r}\PYG{p}{.}\PYG{n}{habitat\PYGZus{}max} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{r}\PYG{p}{.}\PYG{n}{bCoarse} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{r}\PYG{p}{.}\PYG{n}{has\PYGZus{}pristine}\PYG{p}{;}
        \PYG{n}{r}\PYG{p}{.}\PYG{n}{setLandscape}\PYG{p}{(}\PYG{n}{r}\PYG{p}{.}\PYG{n}{mapvars}\PYG{p}{.}\PYG{n}{landscape\PYGZus{}type}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{r}\PYG{p}{.}\PYG{n}{calcFineMap}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{r}\PYG{p}{.}\PYG{n}{calcCoarseMap}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{r}\PYG{p}{.}\PYG{n}{calcPristineFineMap}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{r}\PYG{p}{.}\PYG{n}{calcPristineCoarseMap}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{r}\PYG{p}{.}\PYG{n}{recalculateHabitatMax}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{return} \PYG{n}{is}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{n}{string} \PYG{n}{printVars}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

    \PYG{k+kt}{void} \PYG{n+nf}{clearMap}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

    \PYG{k+kt}{void} \PYG{n+nf}{recalculateHabitatMax}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

\PYG{p}{\PYGZcb{}}\PYG{p}{;}

\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif }\PYG{c+c1}{// MAP}
\end{sphinxVerbatim}


\subsubsection{Detailed Description}
\label{\detokenize{api/file_necsim_Map.h:detailed-description}}
Samuel Thompson
31/08/16
BSD-3 Licence.


\subsubsection{Includes}
\label{\detokenize{api/file_necsim_Map.h:includes}}\begin{itemize}
\item {} 
\sphinxcode{DataMask.h} ({\hyperref[\detokenize{api/file_necsim_DataMask.h:file-necsim-datamask-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File DataMask.h}}}})

\item {} 
\sphinxcode{Matrix.h} ({\hyperref[\detokenize{api/file_necsim_Matrix.h:file-necsim-matrix-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File Matrix.h}}}})

\item {} 
\sphinxcode{SimParameters.h} ({\hyperref[\detokenize{api/file_necsim_SimParameters.h:file-necsim-simparameters-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File SimParameters.h}}}})

\item {} 
\sphinxcode{boost/filesystem.hpp}

\item {} 
\sphinxcode{fstream}

\item {} 
\sphinxcode{iostream}

\item {} 
\sphinxcode{math.h}

\item {} 
\sphinxcode{stdexcept}

\item {} 
\sphinxcode{stdio.h}

\item {} 
\sphinxcode{string}

\item {} 
\sphinxcode{vector}

\end{itemize}


\subsubsection{Included By}
\label{\detokenize{api/file_necsim_Map.h:included-by}}\begin{itemize}
\item {} 
{\hyperref[\detokenize{api/file_necsim_DataMask.cpp:file-necsim-datamask-cpp}]{\sphinxcrossref{\DUrole{std,std-ref}{File DataMask.cpp}}}}

\item {} 
{\hyperref[\detokenize{api/file_necsim_DispersalCoordinator.h:file-necsim-dispersalcoordinator-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File DispersalCoordinator.h}}}}

\item {} 
{\hyperref[\detokenize{api/file_necsim_SpatialTree.h:file-necsim-spatialtree-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File SpatialTree.h}}}}

\item {} 
{\hyperref[\detokenize{api/file_necsim_Map.cpp:file-necsim-map-cpp}]{\sphinxcrossref{\DUrole{std,std-ref}{File Map.cpp}}}}

\end{itemize}


\subsubsection{Classes}
\label{\detokenize{api/file_necsim_Map.h:classes}}\begin{itemize}
\item {} 
{\hyperref[\detokenize{api/class_Map:class-map}]{\sphinxcrossref{\DUrole{std,std-ref}{Class Map}}}}

\end{itemize}


\subsection{File Matrix.h}
\label{\detokenize{api/file_necsim_Matrix.h:file-necsim-matrix-h}}\label{\detokenize{api/file_necsim_Matrix.h:file-matrix-h}}\label{\detokenize{api/file_necsim_Matrix.h::doc}}
Contains a template for a matrix with all the basic matrix operations overloaded.

\begin{sphinxShadowBox}
\sphinxstyletopictitle{Contents}
\begin{itemize}
\item {} 
\phantomsection\label{\detokenize{api/file_necsim_Matrix.h:id1}}{\hyperref[\detokenize{api/file_necsim_Matrix.h:definition-necsim-matrix-h}]{\sphinxcrossref{Definition (\sphinxcode{necsim/Matrix.h})}}}

\item {} 
\phantomsection\label{\detokenize{api/file_necsim_Matrix.h:id2}}{\hyperref[\detokenize{api/file_necsim_Matrix.h:detailed-description}]{\sphinxcrossref{Detailed Description}}}

\item {} 
\phantomsection\label{\detokenize{api/file_necsim_Matrix.h:id3}}{\hyperref[\detokenize{api/file_necsim_Matrix.h:includes}]{\sphinxcrossref{Includes}}}

\item {} 
\phantomsection\label{\detokenize{api/file_necsim_Matrix.h:id4}}{\hyperref[\detokenize{api/file_necsim_Matrix.h:included-by}]{\sphinxcrossref{Included By}}}

\item {} 
\phantomsection\label{\detokenize{api/file_necsim_Matrix.h:id5}}{\hyperref[\detokenize{api/file_necsim_Matrix.h:classes}]{\sphinxcrossref{Classes}}}

\item {} 
\phantomsection\label{\detokenize{api/file_necsim_Matrix.h:id6}}{\hyperref[\detokenize{api/file_necsim_Matrix.h:defines}]{\sphinxcrossref{Defines}}}

\item {} 
\phantomsection\label{\detokenize{api/file_necsim_Matrix.h:id7}}{\hyperref[\detokenize{api/file_necsim_Matrix.h:variables}]{\sphinxcrossref{Variables}}}

\end{itemize}
\end{sphinxShadowBox}


\subsubsection{Definition (\sphinxstyleliteralintitle{necsim/Matrix.h})}
\label{\detokenize{api/file_necsim_Matrix.h:definition-necsim-matrix-h}}

\paragraph{Program Listing for File Matrix.h}
\label{\detokenize{api/program_listing_file_necsim_Matrix.h:program-listing-file-necsim-matrix-h}}\label{\detokenize{api/program_listing_file_necsim_Matrix.h::doc}}\label{\detokenize{api/program_listing_file_necsim_Matrix.h:program-listing-for-file-matrix-h}}\begin{itemize}
\item {} 
Return to documentation for {\hyperref[\detokenize{api/file_necsim_Matrix.h:file-necsim-matrix-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File Matrix.h}}}}

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifndef MATRIX}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ define MATRIX}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ define null 0}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ include \PYGZlt{}cstdio\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}iostream\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}sstream\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}fstream\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}cstdlib\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}cstring\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}stdexcept\PYGZgt{}}

\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifdef use\PYGZus{}csv}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{c+cpf}{\PYGZlt{}cmath\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}stdexcept\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZdq{}fast\PYGZhy{}cpp\PYGZhy{}csv\PYGZhy{}parser/csv.h\PYGZdq{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifdef with\PYGZus{}gdal}

\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}gdal\PYGZus{}priv.h\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}cpl\PYGZus{}conv.h\PYGZgt{} // for CPLMalloc()}

\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif}

\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}cstdint\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZdq{}Logging.h\PYGZdq{}}

\PYG{k}{using} \PYG{k}{namespace} \PYG{n}{std}\PYG{p}{;}

\PYG{c+c1}{// Array of data sizes for importing tif files.}
\PYG{k}{const} \PYG{k+kt}{int} \PYG{n}{gdal\PYGZus{}data\PYGZus{}sizes}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{8}\PYG{p}{,} \PYG{l+m+mi}{16}\PYG{p}{,} \PYG{l+m+mi}{16}\PYG{p}{,} \PYG{l+m+mi}{32}\PYG{p}{,} \PYG{l+m+mi}{32}\PYG{p}{,} \PYG{l+m+mi}{32}\PYG{p}{,} \PYG{l+m+mi}{64}\PYG{p}{\PYGZcb{}}\PYG{p}{;}

\PYG{k}{template}\PYG{o}{\PYGZlt{}}\PYG{k}{class} \PYG{n+nc}{T}\PYG{o}{\PYGZgt{}}
\PYG{k}{class} \PYG{n+nc}{Row}
\PYG{p}{\PYGZob{}}
\PYG{k}{private}\PYG{o}{:}
    \PYG{c+c1}{// stores the number of columns in the row}
    \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{numCols}\PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
    \PYG{c+c1}{// an array to store the row}
    \PYG{n}{T} \PYG{o}{*}\PYG{n}{row}\PYG{p}{;}
\PYG{k}{public}\PYG{o}{:}

    \PYG{k}{explicit} \PYG{n}{Row}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{cols} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)} \PYG{o}{:} \PYG{n}{row}\PYG{p}{(}\PYG{k}{nullptr}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{setSize}\PYG{p}{(}\PYG{n}{cols}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{o}{\PYGZti{}}\PYG{n}{Row}\PYG{p}{(}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{row}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{k}{delete}\PYG{p}{[}\PYG{p}{]} \PYG{n}{row}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
    \PYG{p}{\PYGZcb{}}

    \PYG{n}{Row}\PYG{p}{(}\PYG{k}{const} \PYG{n}{Row} \PYG{o}{\PYGZam{}}\PYG{n}{r}\PYG{p}{)} \PYG{o}{:} \PYG{n}{row}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{setSize}\PYG{p}{(}\PYG{n}{r}\PYG{p}{.}\PYG{n}{numCols}\PYG{p}{)}\PYG{p}{;}
        \PYG{c+c1}{// Change to standard copy}
        \PYG{n}{copy}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{r}\PYG{p}{.}\PYG{n}{row}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{r}\PYG{p}{.}\PYG{n}{row}\PYG{p}{[}\PYG{n}{numCols}\PYG{p}{]}\PYG{p}{,} \PYG{n}{row}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}


    \PYG{k+kt}{void} \PYG{n}{setSize}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{n}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{row}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{k}{delete}\PYG{p}{[}\PYG{p}{]} \PYG{n}{row}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{n} \PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{0}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{row} \PYG{o}{=} \PYG{k}{new} \PYG{n}{T}\PYG{p}{[}\PYG{n}{n}\PYG{p}{]}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{else}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{row} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{n}{numCols} \PYG{o}{=} \PYG{n}{n}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{k+kt}{void} \PYG{n}{resize}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{n}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{auto} \PYG{n}{t} \PYG{o}{=} \PYG{k}{new} \PYG{n}{T}\PYG{p}{[}\PYG{n}{n}\PYG{p}{]}\PYG{p}{;}
        \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{numCols}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{t}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{=} \PYG{n}{row}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{delete}\PYG{p}{[}\PYG{p}{]} \PYG{n}{row}\PYG{p}{;}
        \PYG{n}{row} \PYG{o}{=} \PYG{n}{move}\PYG{p}{(}\PYG{n}{t}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{numCols} \PYG{o}{=} \PYG{n}{n}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{size}\PYG{p}{(}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{return} \PYG{n}{numCols}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{n}{T} \PYG{o}{\PYGZam{}}\PYG{k}{operator}\PYG{p}{[}\PYG{p}{]}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{column}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{c+c1}{// assert(column\PYGZlt{}numCols);}
        \PYG{c+c1}{// check we are within bounds}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifdef DEBUG}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{column} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{0} \PYG{o}{\textbar{}}\PYG{o}{\textbar{}} \PYG{n}{column} \PYG{o}{\PYGZgt{}}\PYG{o}{=} \PYG{n}{numCols}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{string} \PYG{n}{err} \PYG{o}{=}
                    \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ERROR\PYGZus{}MAIN\PYGZus{}013b: Tried to call an indices that was out of range of the row. Check row size definition. numCols: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{+}
                    \PYG{n}{to\PYGZus{}string}\PYG{p}{(}\PYG{p}{(}\PYG{k+kt}{long} \PYG{k+kt}{long}\PYG{p}{)} \PYG{n}{numCols}\PYG{p}{)} \PYG{o}{+} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ index: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{+} \PYG{n}{to\PYGZus{}string}\PYG{p}{(}\PYG{p}{(}\PYG{k+kt}{long} \PYG{k+kt}{long}\PYG{p}{)} \PYG{n}{column}\PYG{p}{)}\PYG{p}{;}
            \PYG{k}{throw} \PYG{n+nf}{out\PYGZus{}of\PYGZus{}range}\PYG{p}{(}\PYG{n}{err}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif}
        \PYG{n}{column} \PYG{o}{=} \PYG{n}{column} \PYG{o}{\PYGZpc{}} \PYG{n}{numCols}\PYG{p}{;}
        \PYG{k}{return} \PYG{n}{row}\PYG{p}{[}\PYG{n}{column}\PYG{p}{]}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{n}{Row} \PYG{o}{\PYGZam{}}\PYG{k}{operator}\PYG{o}{=}\PYG{p}{(}\PYG{k}{const} \PYG{n}{Row} \PYG{o}{\PYGZam{}}\PYG{n}{r}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{setSize}\PYG{p}{(}\PYG{n}{r}\PYG{p}{.}\PYG{n}{numCols}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{numCols}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{row}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{=} \PYG{n}{r}\PYG{p}{.}\PYG{n}{row}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{return} \PYG{o}{*}\PYG{k}{this}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{k}{friend} \PYG{n}{ostream} \PYG{o}{\PYGZam{}}\PYG{k}{operator}\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{p}{(}\PYG{n}{ostream} \PYG{o}{\PYGZam{}}\PYG{n}{os}\PYG{p}{,} \PYG{k}{const} \PYG{n}{Row} \PYG{o}{\PYGZam{}}\PYG{n}{r}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{os} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{r}\PYG{p}{.}\PYG{n}{numCols} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{,}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
        \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{c} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{c} \PYG{o}{\PYGZlt{}} \PYG{n}{r}\PYG{p}{.}\PYG{n}{numCols}\PYG{p}{;} \PYG{n}{c}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{os} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{r}\PYG{p}{.}\PYG{n}{row}\PYG{p}{[}\PYG{n}{c}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{,}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{return} \PYG{n}{os}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{k}{friend} \PYG{n}{istream} \PYG{o}{\PYGZam{}}\PYG{k}{operator}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{n}{istream} \PYG{o}{\PYGZam{}}\PYG{n}{is}\PYG{p}{,} \PYG{n}{Row} \PYG{o}{\PYGZam{}}\PYG{n}{r}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k+kt}{char} \PYG{n}{delim}\PYG{p}{;}
        \PYG{k+kt}{int} \PYG{n}{n}\PYG{p}{;}
        \PYG{n}{is} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{n}\PYG{p}{;}
        \PYG{n}{r}\PYG{p}{.}\PYG{n}{setSize}\PYG{p}{(}\PYG{n}{n}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{is} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{delim}\PYG{p}{;}
        \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{c} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{c} \PYG{o}{\PYGZlt{}} \PYG{n}{r}\PYG{p}{.}\PYG{n}{numCols}\PYG{p}{;} \PYG{n}{c}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{is} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{r}\PYG{p}{.}\PYG{n}{row}\PYG{p}{[}\PYG{n}{c}\PYG{p}{]}\PYG{p}{;}
            \PYG{n}{is} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{delim}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{return} \PYG{n}{is}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}


\PYG{k}{template}\PYG{o}{\PYGZlt{}}\PYG{k}{class} \PYG{n+nc}{T}\PYG{o}{\PYGZgt{}}
\PYG{k}{class} \PYG{n+nc}{Matrix}
\PYG{p}{\PYGZob{}}

\PYG{k}{protected}\PYG{o}{:}

    \PYG{c+c1}{// number of rows and columns}
    \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{numCols}\PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}\PYG{p}{,} \PYG{n}{numRows}\PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
    \PYG{c+c1}{// a matrix is an array of rows}
    \PYG{n}{Row}\PYG{o}{\PYGZlt{}}\PYG{n}{T}\PYG{o}{\PYGZgt{}} \PYG{o}{*}\PYG{n}{matrix}\PYG{p}{;}

\PYG{k}{public}\PYG{o}{:}

    \PYG{k}{explicit} \PYG{n}{Matrix}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{rows} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{cols} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)} \PYG{o}{:} \PYG{n}{matrix}\PYG{p}{(}\PYG{n}{null}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{SetSize}\PYG{p}{(}\PYG{n}{rows}\PYG{p}{,} \PYG{n}{cols}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{n}{Matrix}\PYG{p}{(}\PYG{k}{const} \PYG{n}{Matrix} \PYG{o}{\PYGZam{}}\PYG{n}{m}\PYG{p}{)} \PYG{o}{:} \PYG{n}{matrix}\PYG{p}{(}\PYG{n}{null}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{SetSize}\PYG{p}{(}\PYG{n}{m}\PYG{p}{.}\PYG{n}{numRows}\PYG{p}{,} \PYG{n}{m}\PYG{p}{.}\PYG{n}{numCols}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{copy}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{m}\PYG{p}{.}\PYG{n}{matrix}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{m}\PYG{p}{.}\PYG{n}{matrix}\PYG{p}{[}\PYG{n}{numRows}\PYG{p}{]}\PYG{p}{[}\PYG{n}{numCols}\PYG{p}{]}\PYG{p}{,} \PYG{n}{matrix}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{o}{\PYGZti{}}\PYG{n}{Matrix}\PYG{p}{(}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{matrix}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{k}{delete}\PYG{p}{[}\PYG{p}{]} \PYG{n}{matrix}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
    \PYG{p}{\PYGZcb{}}

    \PYG{k+kt}{void} \PYG{n}{SetSize}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{rows}\PYG{p}{,} \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{cols}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{matrix}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{k}{delete}\PYG{p}{[}\PYG{p}{]}\PYG{n}{matrix}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{cols} \PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{0} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{n}{rows} \PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{0}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{matrix} \PYG{o}{=} \PYG{k}{new} \PYG{n}{Row}\PYG{o}{\PYGZlt{}}\PYG{n}{T}\PYG{o}{\PYGZgt{}}\PYG{p}{[}\PYG{n}{rows}\PYG{p}{]}\PYG{p}{;}
            \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{rows}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{n}{matrix}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{setSize}\PYG{p}{(}\PYG{n}{cols}\PYG{p}{)}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{else}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{matrix} \PYG{o}{=} \PYG{n}{null}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{n}{numCols} \PYG{o}{=} \PYG{n}{cols}\PYG{p}{;}
        \PYG{n}{numRows} \PYG{o}{=} \PYG{n}{rows}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{GetCols}\PYG{p}{(}\PYG{p}{)} \PYG{k}{const}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{return} \PYG{n}{numCols}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{GetRows}\PYG{p}{(}\PYG{p}{)} \PYG{k}{const}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{return} \PYG{n}{numRows}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{n}{Row}\PYG{o}{\PYGZlt{}}\PYG{n}{T}\PYG{o}{\PYGZgt{}} \PYG{o}{\PYGZam{}}\PYG{k}{operator}\PYG{p}{[}\PYG{p}{]}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{index}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifdef DEBUG}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{index} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{0} \PYG{o}{\textbar{}}\PYG{o}{\textbar{}} \PYG{n}{index} \PYG{o}{\PYGZgt{}}\PYG{o}{=} \PYG{n}{numRows}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{string} \PYG{n}{err} \PYG{o}{=}
                    \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ERROR\PYGZus{}MAIN\PYGZus{}013: Tried to call an indices that was out of range of the matrix. Check matrix size definition. numRows: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{+}
                    \PYG{n}{to\PYGZus{}string}\PYG{p}{(}\PYG{p}{(}\PYG{k+kt}{long} \PYG{k+kt}{long}\PYG{p}{)} \PYG{n}{numRows}\PYG{p}{)} \PYG{o}{+} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ index: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{+} \PYG{n}{to\PYGZus{}string}\PYG{p}{(}\PYG{p}{(}\PYG{k+kt}{long} \PYG{k+kt}{long}\PYG{p}{)} \PYG{n}{index}\PYG{p}{)}\PYG{p}{;}
            \PYG{k}{throw} \PYG{n+nf}{out\PYGZus{}of\PYGZus{}range}\PYG{p}{(}\PYG{n}{err}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif}
        \PYG{n}{index} \PYG{o}{=} \PYG{n}{index} \PYG{o}{\PYGZpc{}} \PYG{n}{numRows}\PYG{p}{;}
        \PYG{k}{return} \PYG{n}{matrix}\PYG{p}{[}\PYG{n}{index}\PYG{p}{]}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{n}{Matrix} \PYG{o}{\PYGZam{}}\PYG{k}{operator}\PYG{o}{=}\PYG{p}{(}\PYG{k}{const} \PYG{n}{Matrix} \PYG{o}{\PYGZam{}}\PYG{n}{m}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{SetSize}\PYG{p}{(}\PYG{n}{m}\PYG{p}{.}\PYG{n}{numRows}\PYG{p}{,} \PYG{n}{m}\PYG{p}{.}\PYG{n}{numCols}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{r} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{r} \PYG{o}{\PYGZlt{}} \PYG{n}{numRows}\PYG{p}{;} \PYG{n}{r}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{matrix}\PYG{p}{[}\PYG{n}{r}\PYG{p}{]} \PYG{o}{=} \PYG{n}{Row}\PYG{o}{\PYGZlt{}}\PYG{n}{T}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{n}{m}\PYG{p}{.}\PYG{n}{matrix}\PYG{p}{[}\PYG{n}{r}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{return} \PYG{o}{*}\PYG{k}{this}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}


    \PYG{k}{const} \PYG{n}{Matrix} \PYG{k}{operator}\PYG{o}{+}\PYG{p}{(}\PYG{k}{const} \PYG{n}{Matrix} \PYG{o}{\PYGZam{}}\PYG{n}{m}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{c+c1}{//Since addition creates a new matrix, we don\PYGZsq{}t want to return a reference, but an actual matrix object.}
        \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{newnumcols}\PYG{p}{,} \PYG{n}{newnumrows}\PYG{p}{;}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{numCols} \PYG{o}{\PYGZgt{}} \PYG{n}{m}\PYG{p}{.}\PYG{n}{numCols}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{newnumcols} \PYG{o}{=} \PYG{n}{m}\PYG{p}{.}\PYG{n}{numCols}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{else}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{newnumcols} \PYG{o}{=} \PYG{n}{numCols}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{numRows} \PYG{o}{\PYGZgt{}} \PYG{n}{m}\PYG{p}{.}\PYG{n}{numRows}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{newnumrows} \PYG{o}{=} \PYG{n}{m}\PYG{p}{.}\PYG{n}{numRows}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{else}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{newnumrows} \PYG{o}{=} \PYG{n}{numRows}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}

        \PYG{n}{Matrix} \PYG{n}{result}\PYG{p}{(}\PYG{n}{newnumrows}\PYG{p}{,} \PYG{n}{newnumcols}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{r} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{r} \PYG{o}{\PYGZlt{}} \PYG{n}{newnumrows}\PYG{p}{;} \PYG{n}{r}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{c} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{c} \PYG{o}{\PYGZlt{}} \PYG{n}{newnumcols}\PYG{p}{;} \PYG{n}{c}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{n}{result}\PYG{p}{[}\PYG{n}{r}\PYG{p}{]}\PYG{p}{[}\PYG{n}{c}\PYG{p}{]} \PYG{o}{=} \PYG{n}{matrix}\PYG{p}{[}\PYG{n}{r}\PYG{p}{]}\PYG{p}{[}\PYG{n}{c}\PYG{p}{]} \PYG{o}{+} \PYG{n}{m}\PYG{p}{.}\PYG{n}{matrix}\PYG{p}{[}\PYG{n}{r}\PYG{p}{]}\PYG{p}{[}\PYG{n}{c}\PYG{p}{]}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{return} \PYG{n}{result}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{k}{const} \PYG{n}{Matrix} \PYG{k}{operator}\PYG{o}{\PYGZhy{}}\PYG{p}{(}\PYG{k}{const} \PYG{n}{Matrix} \PYG{o}{\PYGZam{}}\PYG{n}{m}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{newnumcols}\PYG{p}{,} \PYG{n}{newnumrows}\PYG{p}{;}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{numCols} \PYG{o}{\PYGZgt{}} \PYG{n}{m}\PYG{p}{.}\PYG{n}{numCols}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{newnumcols} \PYG{o}{=} \PYG{n}{m}\PYG{p}{.}\PYG{n}{numCols}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{else}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{newnumcols} \PYG{o}{=} \PYG{n}{numCols}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{numRows} \PYG{o}{\PYGZgt{}} \PYG{n}{m}\PYG{p}{.}\PYG{n}{numRows}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{newnumrows} \PYG{o}{=} \PYG{n}{m}\PYG{p}{.}\PYG{n}{numRows}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{else}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{newnumrows} \PYG{o}{=} \PYG{n}{numRows}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{n}{Matrix} \PYG{n}{result}\PYG{p}{(}\PYG{n}{newnumrows}\PYG{p}{,} \PYG{n}{newnumcols}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{r} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{r} \PYG{o}{\PYGZlt{}} \PYG{n}{newnumrows}\PYG{p}{;} \PYG{n}{r}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{c} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{c} \PYG{o}{\PYGZlt{}} \PYG{n}{newnumcols}\PYG{p}{;} \PYG{n}{c}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{n}{result}\PYG{p}{[}\PYG{n}{r}\PYG{p}{]}\PYG{p}{[}\PYG{n}{c}\PYG{p}{]} \PYG{o}{=} \PYG{n}{matrix}\PYG{p}{[}\PYG{n}{r}\PYG{p}{]}\PYG{p}{[}\PYG{n}{c}\PYG{p}{]} \PYG{o}{\PYGZhy{}} \PYG{n}{m}\PYG{p}{.}\PYG{n}{matrix}\PYG{p}{[}\PYG{n}{r}\PYG{p}{]}\PYG{p}{[}\PYG{n}{c}\PYG{p}{]}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{return} \PYG{n}{result}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{n}{Matrix} \PYG{o}{\PYGZam{}}\PYG{k}{operator}\PYG{o}{+}\PYG{o}{=}\PYG{p}{(}\PYG{k}{const} \PYG{n}{Matrix} \PYG{o}{\PYGZam{}}\PYG{n}{m}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{newnumcols}\PYG{p}{,} \PYG{n}{newnumrows}\PYG{p}{;}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{numCols} \PYG{o}{\PYGZgt{}} \PYG{n}{m}\PYG{p}{.}\PYG{n}{numCols}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{newnumcols} \PYG{o}{=} \PYG{n}{m}\PYG{p}{.}\PYG{n}{numCols}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{else}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{newnumcols} \PYG{o}{=} \PYG{n}{numCols}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{numRows} \PYG{o}{\PYGZgt{}} \PYG{n}{m}\PYG{p}{.}\PYG{n}{numRows}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{newnumrows} \PYG{o}{=} \PYG{n}{m}\PYG{p}{.}\PYG{n}{numRows}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{else}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{newnumrows} \PYG{o}{=} \PYG{n}{numRows}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{r} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{r} \PYG{o}{\PYGZlt{}} \PYG{n}{newnumrows}\PYG{p}{;} \PYG{n}{r}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{c} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{c} \PYG{o}{\PYGZlt{}} \PYG{n}{newnumcols}\PYG{p}{;} \PYG{n}{c}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{n}{matrix}\PYG{p}{[}\PYG{n}{r}\PYG{p}{]}\PYG{p}{[}\PYG{n}{c}\PYG{p}{]} \PYG{o}{+}\PYG{o}{=} \PYG{n}{m}\PYG{p}{.}\PYG{n}{matrix}\PYG{p}{[}\PYG{n}{r}\PYG{p}{]}\PYG{p}{[}\PYG{n}{c}\PYG{p}{]}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{return} \PYG{o}{*}\PYG{k}{this}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}


    \PYG{n}{Matrix} \PYG{o}{\PYGZam{}}\PYG{k}{operator}\PYG{o}{\PYGZhy{}}\PYG{o}{=}\PYG{p}{(}\PYG{k}{const} \PYG{n}{Matrix} \PYG{o}{\PYGZam{}}\PYG{n}{m}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{newnumcols}\PYG{p}{,} \PYG{n}{newnumrows}\PYG{p}{;}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{numCols} \PYG{o}{\PYGZgt{}} \PYG{n}{m}\PYG{p}{.}\PYG{n}{numCols}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{newnumcols} \PYG{o}{=} \PYG{n}{m}\PYG{p}{.}\PYG{n}{numCols}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{else}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{newnumcols} \PYG{o}{=} \PYG{n}{numCols}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{numRows} \PYG{o}{\PYGZgt{}} \PYG{n}{m}\PYG{p}{.}\PYG{n}{numRows}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{newnumrows} \PYG{o}{=} \PYG{n}{m}\PYG{p}{.}\PYG{n}{numRows}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{else}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{newnumrows} \PYG{o}{=} \PYG{n}{numRows}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{r} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{r} \PYG{o}{\PYGZlt{}} \PYG{n}{newnumrows}\PYG{p}{;} \PYG{n}{r}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{c} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{c} \PYG{o}{\PYGZlt{}} \PYG{n}{newnumcols}\PYG{p}{;} \PYG{n}{c}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{n}{matrix}\PYG{p}{[}\PYG{n}{r}\PYG{p}{]}\PYG{p}{[}\PYG{n}{c}\PYG{p}{]} \PYG{o}{\PYGZhy{}}\PYG{o}{=} \PYG{n}{m}\PYG{p}{.}\PYG{n}{matrix}\PYG{p}{[}\PYG{n}{r}\PYG{p}{]}\PYG{p}{[}\PYG{n}{c}\PYG{p}{]}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{return} \PYG{o}{*}\PYG{k}{this}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{k}{const} \PYG{n}{Matrix} \PYG{k}{operator}\PYG{o}{*}\PYG{p}{(}\PYG{k}{const} \PYG{k+kt}{double} \PYG{n}{s}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{Matrix} \PYG{n}{result}\PYG{p}{(}\PYG{n}{numRows}\PYG{p}{,} \PYG{n}{numCols}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{r} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{r} \PYG{o}{\PYGZlt{}} \PYG{n}{numRows}\PYG{p}{;} \PYG{n}{r}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{c} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{c} \PYG{o}{\PYGZlt{}} \PYG{n}{numCols}\PYG{p}{;} \PYG{n}{c}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{n}{result}\PYG{p}{[}\PYG{n}{r}\PYG{p}{]}\PYG{p}{[}\PYG{n}{c}\PYG{p}{]} \PYG{o}{=} \PYG{n}{matrix}\PYG{p}{[}\PYG{n}{r}\PYG{p}{]}\PYG{p}{[}\PYG{n}{c}\PYG{p}{]} \PYG{o}{*} \PYG{n}{s}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{return} \PYG{n}{result}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}


    \PYG{k}{const} \PYG{n}{Matrix} \PYG{k}{operator}\PYG{o}{*}\PYG{p}{(}\PYG{n}{Matrix} \PYG{o}{\PYGZam{}}\PYG{n}{m}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{newnumcols}\PYG{p}{;}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{numCols} \PYG{o}{\PYGZgt{}} \PYG{n}{m}\PYG{p}{.}\PYG{n}{numRows}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{newnumcols} \PYG{o}{=} \PYG{n}{m}\PYG{p}{.}\PYG{n}{numRows}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{else}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{newnumcols} \PYG{o}{=} \PYG{n}{numCols}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}

        \PYG{n}{Matrix} \PYG{n}{result}\PYG{p}{(}\PYG{n}{numRows}\PYG{p}{,} \PYG{n}{m}\PYG{p}{.}\PYG{n}{numCols}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{r} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{r} \PYG{o}{\PYGZlt{}} \PYG{n}{numRows}\PYG{p}{;} \PYG{n}{r}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{c} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{c} \PYG{o}{\PYGZlt{}} \PYG{n}{m}\PYG{p}{.}\PYG{n}{numCols}\PYG{p}{;} \PYG{n}{c}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{newnumcols}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
                \PYG{p}{\PYGZob{}}
                    \PYG{n}{result}\PYG{p}{[}\PYG{n}{r}\PYG{p}{]}\PYG{p}{[}\PYG{n}{c}\PYG{p}{]} \PYG{o}{+}\PYG{o}{=} \PYG{n}{matrix}\PYG{p}{[}\PYG{n}{r}\PYG{p}{]}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{*} \PYG{n}{m}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{[}\PYG{n}{c}\PYG{p}{]}\PYG{p}{;}
                \PYG{p}{\PYGZcb{}}
            \PYG{p}{\PYGZcb{}}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{return} \PYG{n}{result}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{k}{friend} \PYG{n}{ostream} \PYG{o}{\PYGZam{}}\PYG{k}{operator}\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{p}{(}\PYG{n}{ostream} \PYG{o}{\PYGZam{}}\PYG{n}{os}\PYG{p}{,} \PYG{k}{const} \PYG{n}{Matrix} \PYG{o}{\PYGZam{}}\PYG{n}{m}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{r} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{r} \PYG{o}{\PYGZlt{}} \PYG{n}{m}\PYG{p}{.}\PYG{n}{numRows}\PYG{p}{;} \PYG{n}{r}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{c} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{c} \PYG{o}{\PYGZlt{}} \PYG{n}{m}\PYG{p}{.}\PYG{n}{numCols}\PYG{p}{;} \PYG{n}{c}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{n}{os} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{m}\PYG{p}{.}\PYG{n}{matrix}\PYG{p}{[}\PYG{n}{r}\PYG{p}{]}\PYG{p}{[}\PYG{n}{c}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{,}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
            \PYG{n}{os} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{return} \PYG{n}{os}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{k}{friend} \PYG{n}{istream} \PYG{o}{\PYGZam{}}\PYG{k}{operator}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{n}{istream} \PYG{o}{\PYGZam{}}\PYG{n}{is}\PYG{p}{,} \PYG{n}{Matrix} \PYG{o}{\PYGZam{}}\PYG{n}{m}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k+kt}{char} \PYG{n}{delim}\PYG{p}{;}
        \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{r} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{r} \PYG{o}{\PYGZlt{}} \PYG{n}{m}\PYG{p}{.}\PYG{n}{numRows}\PYG{p}{;} \PYG{n}{r}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{c} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{c} \PYG{o}{\PYGZlt{}} \PYG{n}{m}\PYG{p}{.}\PYG{n}{numCols}\PYG{p}{;} \PYG{n}{c}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{n}{is} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{m}\PYG{p}{.}\PYG{n}{matrix}\PYG{p}{[}\PYG{n}{r}\PYG{p}{]}\PYG{p}{[}\PYG{n}{c}\PYG{p}{]}\PYG{p}{;}
                \PYG{n}{is} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{delim}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{return} \PYG{n}{is}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{k+kt}{void} \PYG{n}{setValue}\PYG{p}{(}\PYG{k}{const} \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{x}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{y}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{char} \PYG{o}{*}\PYG{n}{value}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{matrix}\PYG{p}{[}\PYG{n}{y}\PYG{p}{]}\PYG{p}{[}\PYG{n}{x}\PYG{p}{]} \PYG{o}{=} \PYG{k}{static\PYGZus{}cast}\PYG{o}{\PYGZlt{}}\PYG{n}{T}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{o}{*}\PYG{n}{value}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{k+kt}{void} \PYG{n}{import}\PYG{p}{(}\PYG{k}{const} \PYG{n}{string} \PYG{o}{\PYGZam{}}\PYG{n}{filename}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{filename}\PYG{p}{.}\PYG{n}{find}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{.csv}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)} \PYG{o}{!}\PYG{o}{=} \PYG{n}{string}\PYG{o}{:}\PYG{o}{:}\PYG{n}{npos}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{importCsv}\PYG{p}{(}\PYG{n}{filename}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifdef with\PYGZus{}gdal}
        \PYG{k}{else} \PYG{k}{if}\PYG{p}{(}\PYG{n}{filename}\PYG{p}{.}\PYG{n}{find}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{.tif}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)} \PYG{o}{!}\PYG{o}{=} \PYG{n}{string}\PYG{o}{:}\PYG{o}{:}\PYG{n}{npos}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{importTif}\PYG{p}{(}\PYG{n}{filename}\PYG{p}{)}\PYG{p}{;}
            \PYG{k}{return}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif}
        \PYG{n}{string} \PYG{n}{s} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Type detection failed for }\PYG{l+s}{\PYGZdq{}} \PYG{o}{+} \PYG{n}{filename} \PYG{o}{+} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{. Check filename is correct.}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
        \PYG{k}{throw} \PYG{n+nf}{runtime\PYGZus{}error}\PYG{p}{(}\PYG{n}{s}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifdef with\PYGZus{}gdal}
    \PYG{k+kt}{void} \PYG{n}{importTif}\PYG{p}{(}\PYG{k}{const} \PYG{n}{string} \PYG{o}{\PYGZam{}}\PYG{n}{filename}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{stringstream} \PYG{n}{ss}\PYG{p}{;}
        \PYG{n}{ss} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Importing }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{filename} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{flush}\PYG{p}{;}
        \PYG{n}{writeInfo}\PYG{p}{(}\PYG{n}{ss}\PYG{p}{.}\PYG{n}{str}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{GDALDataset} \PYG{o}{*}\PYG{n}{poDataset}\PYG{p}{;}
        \PYG{n}{GDALAllRegister}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{poDataset} \PYG{o}{=} \PYG{p}{(}\PYG{n}{GDALDataset} \PYG{o}{*}\PYG{p}{)} \PYG{n}{GDALOpen}\PYG{p}{(}\PYG{n}{filename}\PYG{p}{.}\PYG{n}{c\PYGZus{}str}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{n}{GA\PYGZus{}ReadOnly}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{poDataset} \PYG{o}{=}\PYG{o}{=} \PYG{k}{nullptr}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{string} \PYG{n}{s} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{File }\PYG{l+s}{\PYGZdq{}} \PYG{o}{+} \PYG{n}{filename} \PYG{o}{+} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ not found.}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
            \PYG{k}{throw} \PYG{n+nf}{runtime\PYGZus{}error}\PYG{p}{(}\PYG{n}{s}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{n}{GDALRasterBand} \PYG{o}{*}\PYG{n}{poBand}\PYG{p}{;}
        \PYG{k+kt}{int} \PYG{n}{nBlockXSize}\PYG{p}{,} \PYG{n}{nBlockYSize}\PYG{p}{;}
        \PYG{c+c1}{// Import the raster band 1}
        \PYG{n}{poBand} \PYG{o}{=} \PYG{n}{poDataset}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{GetRasterBand}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{nBlockXSize} \PYG{o}{=} \PYG{n}{poDataset}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{GetRasterXSize}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{nBlockYSize} \PYG{o}{=} \PYG{n}{poDataset}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{GetRasterYSize}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
        \PYG{k+kt}{double} \PYG{n}{noDataValue}\PYG{p}{;}
        \PYG{k}{try}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{noDataValue} \PYG{o}{=} \PYG{n}{poBand}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{GetNoDataValue}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{catch}\PYG{p}{(}\PYG{n}{out\PYGZus{}of\PYGZus{}range}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{noDataValue} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{c+c1}{// Check sizes}
        \PYG{k}{if}\PYG{p}{(}\PYG{p}{(}\PYG{n}{numCols} \PYG{o}{!}\PYG{o}{=} \PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{long}\PYG{p}{)} \PYG{n}{nBlockXSize} \PYG{o}{\textbar{}}\PYG{o}{\textbar{}} \PYG{n}{numRows} \PYG{o}{!}\PYG{o}{=} \PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{long}\PYG{p}{)} \PYG{n}{nBlockYSize}\PYG{p}{)} \PYG{o}{\textbar{}}\PYG{o}{\textbar{}} \PYG{n}{numCols} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{0} \PYG{o}{\textbar{}}\PYG{o}{\textbar{}}
           \PYG{n}{numRows} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{stringstream} \PYG{n}{ss}\PYG{p}{;}
            \PYG{n}{ss} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Raster data size does not match inputted dimensions for }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{filename} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{. Using raster sizes.}\PYG{l+s}{\PYGZdq{}}
                 \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
            \PYG{n}{ss} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Old dimensions: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{numCols} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{, }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{numRows} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
            \PYG{n}{ss} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{New dimensions: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{nBlockXSize} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{, }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{nBlockYSize} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
            \PYG{n}{writeWarning}\PYG{p}{(}\PYG{n}{ss}\PYG{p}{.}\PYG{n}{str}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
            \PYG{n}{SetSize}\PYG{p}{(}\PYG{k}{static\PYGZus{}cast}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{unsigned} \PYG{k+kt}{long}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{n}{nBlockYSize}\PYG{p}{)}\PYG{p}{,} \PYG{k}{static\PYGZus{}cast}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{unsigned} \PYG{k+kt}{long}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{n}{nBlockXSize}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{c+c1}{// Check sizes match}
        \PYG{n}{GDALDataType} \PYG{n}{dt} \PYG{o}{=} \PYG{n}{poBand}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{GetRasterDataType}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{const} \PYG{k+kt}{char} \PYG{o}{*}\PYG{n}{dt\PYGZus{}name} \PYG{o}{=} \PYG{n}{GDALGetDataTypeName}\PYG{p}{(}\PYG{n}{dt}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{CPLErr} \PYG{n}{r}\PYG{p}{;}
        \PYG{c+c1}{// Check the data types are support}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{dt} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{0} \PYG{o}{\textbar{}}\PYG{o}{\textbar{}} \PYG{n}{dt} \PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{7}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{k}{throw} \PYG{n}{FatalException}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Data type of }\PYG{l+s}{\PYGZdq{}} \PYG{o}{+} \PYG{n}{string}\PYG{p}{(}\PYG{n}{dt\PYGZus{}name}\PYG{p}{)} \PYG{o}{+} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{is not supported.}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifdef DEBUG}
        \PYG{k}{if}\PYG{p}{(}\PYG{k}{sizeof}\PYG{p}{(}\PYG{n}{T}\PYG{p}{)} \PYG{o}{*} \PYG{l+m+mi}{8} \PYG{o}{!}\PYG{o}{=} \PYG{n}{gdal\PYGZus{}data\PYGZus{}sizes}\PYG{p}{[}\PYG{n}{dt}\PYG{p}{]}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{stringstream} \PYG{n}{ss}\PYG{p}{;}
            \PYG{n}{ss} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Object data size: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k}{sizeof}\PYG{p}{(}\PYG{n}{T}\PYG{p}{)} \PYG{o}{*} \PYG{l+m+mi}{8} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
            \PYG{n}{ss} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Tif data type: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{dt\PYGZus{}name} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{gdal\PYGZus{}data\PYGZus{}sizes}\PYG{p}{[}\PYG{n}{dt}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ bytes}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
            \PYG{n}{ss} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Tif data type does not match object data size in }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{filename} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
            \PYG{n}{writeWarning}\PYG{p}{(}\PYG{n}{ss}\PYG{p}{.}\PYG{n}{str}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif}
        \PYG{c+c1}{// Just use the overloaded method for importing between types}
        \PYG{n}{internalImport}\PYG{p}{(}\PYG{n}{filename}\PYG{p}{,} \PYG{n}{poBand}\PYG{p}{,} \PYG{n}{nBlockXSize}\PYG{p}{,} \PYG{n}{dt}\PYG{p}{,} \PYG{n}{r}\PYG{p}{,} \PYG{n}{noDataValue}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{GDALClose}\PYG{p}{(}\PYG{n}{poDataset}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{writeInfo}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{done!}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{k+kt}{void} \PYG{n}{internalImport}\PYG{p}{(}\PYG{k}{const} \PYG{n}{string} \PYG{o}{\PYGZam{}}\PYG{n}{filename}\PYG{p}{,} \PYG{n}{GDALRasterBand} \PYG{o}{*}\PYG{n}{poBand}\PYG{p}{,} \PYG{k+kt}{int} \PYG{n}{nBlockXSize}\PYG{p}{,}
                                                     \PYG{n}{GDALDataType} \PYG{n}{dt}\PYG{p}{,} \PYG{n}{CPLErr} \PYG{o}{\PYGZam{}}\PYG{n}{r}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{double} \PYG{o}{\PYGZam{}}\PYG{n}{ndv}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{writeWarning}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{No type detected for matrix type. Attempting default importing (undefined behaviour).}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{defaultImport}\PYG{p}{(}\PYG{n}{filename}\PYG{p}{,} \PYG{n}{poBand}\PYG{p}{,} \PYG{n}{nBlockXSize}\PYG{p}{,} \PYG{n}{dt}\PYG{p}{,} \PYG{n}{r}\PYG{p}{,} \PYG{n}{ndv}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{k+kt}{void} \PYG{n}{defaultImport}\PYG{p}{(}\PYG{k}{const} \PYG{n}{string} \PYG{o}{\PYGZam{}}\PYG{n}{filename}\PYG{p}{,} \PYG{n}{GDALRasterBand} \PYG{o}{*}\PYG{n}{poBand}\PYG{p}{,} \PYG{k+kt}{int} \PYG{n}{nBlockXSize}\PYG{p}{,}
                       \PYG{n}{GDALDataType} \PYG{n}{dt}\PYG{p}{,} \PYG{n}{CPLErr} \PYG{o}{\PYGZam{}}\PYG{n}{r}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{double} \PYG{o}{\PYGZam{}}\PYG{n}{ndv}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k+kt}{unsigned} \PYG{k+kt}{int} \PYG{n}{number\PYGZus{}printed} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
        \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{uint32\PYGZus{}t} \PYG{n}{j} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{j} \PYG{o}{\PYGZlt{}} \PYG{n}{numRows}\PYG{p}{;} \PYG{n}{j}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{printNumberComplete}\PYG{p}{(}\PYG{n}{j}\PYG{p}{,} \PYG{n}{number\PYGZus{}printed}\PYG{p}{,} \PYG{n}{filename}\PYG{p}{)}\PYG{p}{;}
            \PYG{n}{r} \PYG{o}{=} \PYG{n}{poBand}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{RasterIO}\PYG{p}{(}\PYG{n}{GF\PYGZus{}Read}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{j}\PYG{p}{,} \PYG{n}{nBlockXSize}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{matrix}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{n}{nBlockXSize}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{dt}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}
            \PYG{n}{checkRasterBandFailure}\PYG{p}{(}\PYG{n}{r}\PYG{p}{)}\PYG{p}{;}
            \PYG{c+c1}{// Now convert the no data values to 0}
            \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{uint32\PYGZus{}t} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{numCols}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{k}{if}\PYG{p}{(}\PYG{n}{matrix}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{=}\PYG{o}{=} \PYG{n}{ndv}\PYG{p}{)}
                \PYG{p}{\PYGZob{}}
                    \PYG{n}{matrix}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
                \PYG{p}{\PYGZcb{}}
            \PYG{p}{\PYGZcb{}}
        \PYG{p}{\PYGZcb{}}
    \PYG{p}{\PYGZcb{}}

    \PYG{k+kt}{void} \PYG{n}{importFromDoubleAndMakeBool}\PYG{p}{(}\PYG{k}{const} \PYG{n}{string} \PYG{o}{\PYGZam{}}\PYG{n}{filename}\PYG{p}{,} \PYG{n}{GDALRasterBand} \PYG{o}{*} \PYG{n}{poBand}\PYG{p}{,} \PYG{k+kt}{int} \PYG{n}{nBlockXSize}\PYG{p}{,}
                                   \PYG{n}{GDALDataType} \PYG{n}{dt}\PYG{p}{,} \PYG{n}{CPLErr} \PYG{o}{\PYGZam{}} \PYG{n}{r}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{double} \PYG{o}{\PYGZam{}} \PYG{n}{ndv}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k+kt}{unsigned} \PYG{k+kt}{int} \PYG{n}{number\PYGZus{}printed} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
        \PYG{c+c1}{// create an empty row of type float}
        \PYG{k+kt}{double} \PYG{o}{*} \PYG{n}{t1}\PYG{p}{;}
        \PYG{n}{t1} \PYG{o}{=} \PYG{p}{(}\PYG{k+kt}{double} \PYG{o}{*}\PYG{p}{)} \PYG{n}{CPLMalloc}\PYG{p}{(}\PYG{k}{sizeof}\PYG{p}{(}\PYG{k+kt}{double}\PYG{p}{)} \PYG{o}{*} \PYG{n}{numCols}\PYG{p}{)}\PYG{p}{;}
        \PYG{c+c1}{// importSpatialParameters the data a row at a time, using our template row.}
        \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{uint32\PYGZus{}t} \PYG{n}{j} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{j} \PYG{o}{\PYGZlt{}} \PYG{n}{numRows}\PYG{p}{;} \PYG{n}{j}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{printNumberComplete}\PYG{p}{(}\PYG{n}{j}\PYG{p}{,} \PYG{n}{number\PYGZus{}printed}\PYG{p}{,} \PYG{n}{filename}\PYG{p}{)}\PYG{p}{;}
            \PYG{n}{r} \PYG{o}{=} \PYG{n}{poBand}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{RasterIO}\PYG{p}{(}\PYG{n}{GF\PYGZus{}Read}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{j}\PYG{p}{,} \PYG{n}{nBlockXSize}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{t1}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{n}{nBlockXSize}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{GDT\PYGZus{}Float64}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}
            \PYG{n}{checkRasterBandFailure}\PYG{p}{(}\PYG{n}{r}\PYG{p}{)}\PYG{p}{;}
            \PYG{c+c1}{// now copy the data to our matrix, converting float to int. Round or floor...? hmm, floor?}
            \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{numCols}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{k}{if}\PYG{p}{(}\PYG{n}{t1}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{=}\PYG{o}{=} \PYG{n}{ndv}\PYG{p}{)}
                \PYG{p}{\PYGZob{}}
                    \PYG{n}{matrix}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{=} \PYG{n+nb}{false}\PYG{p}{;}
                \PYG{p}{\PYGZcb{}}
                \PYG{k}{else}
                \PYG{p}{\PYGZob{}}
                    \PYG{n}{matrix}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{=} \PYG{n}{t1}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{\PYGZgt{}}\PYG{o}{=} \PYG{l+m+mf}{0.5}\PYG{p}{;}
                \PYG{p}{\PYGZcb{}}
            \PYG{p}{\PYGZcb{}}
        \PYG{p}{\PYGZcb{}}
        \PYG{n}{CPLFree}\PYG{p}{(}\PYG{n}{t1}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}\PYG{p}{;}
    \PYG{k}{template}\PYG{o}{\PYGZlt{}}\PYG{k}{typename} \PYG{n}{T2}\PYG{o}{\PYGZgt{}} \PYG{k+kt}{void} \PYG{n}{importUsingBuffer}\PYG{p}{(}\PYG{k}{const} \PYG{n}{string} \PYG{o}{\PYGZam{}}\PYG{n}{filename}\PYG{p}{,} \PYG{n}{GDALRasterBand} \PYG{o}{*} \PYG{n}{poBand}\PYG{p}{,} \PYG{k+kt}{int} \PYG{n}{nBlockXSize}\PYG{p}{,}
                           \PYG{n}{GDALDataType} \PYG{n}{dt}\PYG{p}{,} \PYG{n}{CPLErr} \PYG{o}{\PYGZam{}} \PYG{n}{r}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{double} \PYG{o}{\PYGZam{}} \PYG{n}{ndv}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k+kt}{unsigned} \PYG{k+kt}{int} \PYG{n}{number\PYGZus{}printed} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
        \PYG{c+c1}{// create an empty row of type float}
        \PYG{n}{T2} \PYG{o}{*} \PYG{n}{t1}\PYG{p}{;}
        \PYG{n}{t1} \PYG{o}{=} \PYG{p}{(}\PYG{n}{T2} \PYG{o}{*}\PYG{p}{)} \PYG{n}{CPLMalloc}\PYG{p}{(}\PYG{k}{sizeof}\PYG{p}{(}\PYG{n}{T2}\PYG{p}{)} \PYG{o}{*} \PYG{n}{numCols}\PYG{p}{)}\PYG{p}{;}
        \PYG{c+c1}{// importSpatialParameters the data a row at a time, using our template row.}
        \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{uint32\PYGZus{}t} \PYG{n}{j} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{j} \PYG{o}{\PYGZlt{}} \PYG{n}{numRows}\PYG{p}{;} \PYG{n}{j}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{printNumberComplete}\PYG{p}{(}\PYG{n}{j}\PYG{p}{,} \PYG{n}{number\PYGZus{}printed}\PYG{p}{,} \PYG{n}{filename}\PYG{p}{)}\PYG{p}{;}
            \PYG{n}{r} \PYG{o}{=} \PYG{n}{poBand}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{RasterIO}\PYG{p}{(}\PYG{n}{GF\PYGZus{}Read}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{j}\PYG{p}{,} \PYG{n}{nBlockXSize}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{t1}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{n}{nBlockXSize}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{dt}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}
            \PYG{n}{checkRasterBandFailure}\PYG{p}{(}\PYG{n}{r}\PYG{p}{)}\PYG{p}{;}
            \PYG{c+c1}{// now copy the data to our matrix, converting float to int. Round or floor...? hmm, floor?}
            \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{numCols}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{k}{if}\PYG{p}{(}\PYG{n}{t1}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{=}\PYG{o}{=} \PYG{n}{ndv}\PYG{p}{)}
                \PYG{p}{\PYGZob{}}
                    \PYG{n}{matrix}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{=} \PYG{k}{static\PYGZus{}cast}\PYG{o}{\PYGZlt{}}\PYG{n}{T}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}
                \PYG{p}{\PYGZcb{}}
                \PYG{k}{else}
                \PYG{p}{\PYGZob{}}
                    \PYG{n}{matrix}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{=} \PYG{k}{static\PYGZus{}cast}\PYG{o}{\PYGZlt{}}\PYG{n}{T}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{n}{t1}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
                \PYG{p}{\PYGZcb{}}
            \PYG{p}{\PYGZcb{}}
        \PYG{p}{\PYGZcb{}}
        \PYG{n}{CPLFree}\PYG{p}{(}\PYG{n}{t1}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}\PYG{p}{;}

    \PYG{k+kt}{void} \PYG{n+nf}{printNumberComplete}\PYG{p}{(}\PYG{k}{const} \PYG{k+kt}{uint32\PYGZus{}t} \PYG{o}{\PYGZam{}}\PYG{n}{j}\PYG{p}{,} \PYG{k+kt}{unsigned} \PYG{k+kt}{int} \PYG{o}{\PYGZam{}} \PYG{n}{number\PYGZus{}printed}\PYG{p}{,} \PYG{k}{const} \PYG{n}{string} \PYG{o}{\PYGZam{}} \PYG{n}{filename}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k+kt}{double} \PYG{n}{dComplete} \PYG{o}{=} \PYG{p}{(}\PYG{p}{(}\PYG{k+kt}{double}\PYG{p}{)} \PYG{n}{j} \PYG{o}{/} \PYG{p}{(}\PYG{k+kt}{double}\PYG{p}{)} \PYG{n}{numRows}\PYG{p}{)} \PYG{o}{*} \PYG{l+m+mi}{20}\PYG{p}{;}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{number\PYGZus{}printed} \PYG{o}{\PYGZlt{}} \PYG{n}{dComplete}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{stringstream} \PYG{n}{os}\PYG{p}{;}
            \PYG{n}{os} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}r}\PYG{l+s}{Importing }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{filename} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
            \PYG{n}{number\PYGZus{}printed} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
            \PYG{k}{while}\PYG{p}{(}\PYG{n}{number\PYGZus{}printed} \PYG{o}{\PYGZlt{}} \PYG{n}{dComplete}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{n}{os} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{.}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
                \PYG{n}{number\PYGZus{}printed}\PYG{o}{+}\PYG{o}{+}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
            \PYG{n}{os} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{flush}\PYG{p}{;}
            \PYG{n}{writeInfo}\PYG{p}{(}\PYG{n}{os}\PYG{p}{.}\PYG{n}{str}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
    \PYG{p}{\PYGZcb{}}

    \PYG{k+kt}{void} \PYG{n+nf}{checkRasterBandFailure}\PYG{p}{(}\PYG{k}{const} \PYG{n}{CPLErr} \PYG{o}{\PYGZam{}} \PYG{n}{r}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{r} \PYG{o}{=}\PYG{o}{=} \PYG{n}{CE\PYGZus{}Failure}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{k+kt}{char} \PYG{o}{*}\PYG{n}{fmt} \PYG{o}{=} \PYG{k}{nullptr}\PYG{p}{;}
            \PYG{n}{CPLError}\PYG{p}{(}\PYG{n}{r}\PYG{p}{,} \PYG{n}{CPLGetLastErrorNo}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZpc{}s}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{fmt}\PYG{p}{)}\PYG{p}{;}
            \PYG{k}{throw} \PYG{n}{runtime\PYGZus{}error}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{CPL error during tif importSpatialParameters: CE\PYGZus{}Failure: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{+} \PYG{n}{string}\PYG{p}{(}\PYG{n}{fmt}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
    \PYG{p}{\PYGZcb{}}

\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif}


\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifdef use\PYGZus{}csv}
    \PYG{k+kt}{void} \PYG{n+nf}{importCsv}\PYG{p}{(}\PYG{k}{const} \PYG{n}{string} \PYG{o}{\PYGZam{}}\PYG{n}{filename}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{stringstream} \PYG{n}{os}\PYG{p}{;}
        \PYG{n}{os}  \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Importing }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{filename} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{flush}\PYG{p}{;}
        \PYG{n}{writeInfo}\PYG{p}{(}\PYG{n}{os}\PYG{p}{.}\PYG{n}{str}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
        \PYG{c+c1}{// LineReader option}
        \PYG{n}{io}\PYG{o}{:}\PYG{o}{:}\PYG{n}{LineReader} \PYG{n}{in}\PYG{p}{(}\PYG{n}{filename}\PYG{p}{)}\PYG{p}{;}
        \PYG{c+c1}{// Keep track of whether we\PYGZsq{}ve printed to terminal or not.}
        \PYG{k+kt}{bool} \PYG{n}{bPrint} \PYG{o}{=} \PYG{n+nb}{false}\PYG{p}{;}
        \PYG{c+c1}{// Initialies empty variable so that the setValue operator overloading works properly.}
        \PYG{k+kt}{unsigned} \PYG{k+kt}{int} \PYG{n}{number\PYGZus{}printed} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
        \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{i} \PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i}\PYG{o}{\PYGZlt{}}\PYG{n}{numRows}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{k+kt}{char}\PYG{o}{*} \PYG{n}{line} \PYG{o}{=} \PYG{n}{in}\PYG{p}{.}\PYG{n}{next\PYGZus{}line}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
            \PYG{k}{if}\PYG{p}{(}\PYG{n}{line} \PYG{o}{=}\PYG{o}{=} \PYG{k}{nullptr}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{k}{if}\PYG{p}{(}\PYG{o}{!}\PYG{n}{bPrint}\PYG{p}{)}
                \PYG{p}{\PYGZob{}}
                    \PYG{n}{cerr} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Input dimensions incorrect \PYGZhy{} read past end of file.}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
                    \PYG{n}{bPrint} \PYG{o}{=} \PYG{n+nb}{true}\PYG{p}{;}
                \PYG{p}{\PYGZcb{}}
                \PYG{k}{break}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
            \PYG{k}{else}
            \PYG{p}{\PYGZob{}}
                \PYG{k+kt}{char} \PYG{o}{*}\PYG{n}{dToken}\PYG{p}{;}
                \PYG{n}{dToken} \PYG{o}{=} \PYG{n}{strtok}\PYG{p}{(}\PYG{n}{line}\PYG{p}{,}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{,}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
                \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{j} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{j}\PYG{o}{\PYGZlt{}}\PYG{n}{numCols}\PYG{p}{;} \PYG{n}{j}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
                \PYG{p}{\PYGZob{}}
                    \PYG{k}{if}\PYG{p}{(}\PYG{n}{dToken} \PYG{o}{=}\PYG{o}{=} \PYG{k}{nullptr}\PYG{p}{)}
                    \PYG{p}{\PYGZob{}}
                        \PYG{k}{if}\PYG{p}{(}\PYG{o}{!}\PYG{n}{bPrint}\PYG{p}{)}
                        \PYG{p}{\PYGZob{}}
                            \PYG{n}{cerr} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Input dimensions incorrect \PYGZhy{} read past end of file.}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
                            \PYG{n}{bPrint} \PYG{o}{=} \PYG{n+nb}{true}\PYG{p}{;}
                        \PYG{p}{\PYGZcb{}}
                        \PYG{k}{break}\PYG{p}{;}
                    \PYG{p}{\PYGZcb{}}
                    \PYG{k}{else}
                    \PYG{p}{\PYGZob{}}
                        \PYG{c+c1}{// This function is overloaded to correctly determine the type of the template}
                        \PYG{n}{setValue}\PYG{p}{(}\PYG{n}{j}\PYG{p}{,}\PYG{n}{i}\PYG{p}{,}\PYG{n}{dToken}\PYG{p}{)}\PYG{p}{;}
                        \PYG{n}{dToken} \PYG{o}{=} \PYG{n}{strtok}\PYG{p}{(}\PYG{n+nb}{NULL}\PYG{p}{,}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{,}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
                    \PYG{p}{\PYGZcb{}}
                \PYG{p}{\PYGZcb{}}
                \PYG{c+c1}{// output the percentage complete}
                \PYG{k+kt}{double} \PYG{n}{dComplete} \PYG{o}{=} \PYG{p}{(}\PYG{p}{(}\PYG{k+kt}{double}\PYG{p}{)}\PYG{n}{i}\PYG{o}{/}\PYG{p}{(}\PYG{k+kt}{double}\PYG{p}{)}\PYG{n}{numRows}\PYG{p}{)}\PYG{o}{*}\PYG{l+m+mi}{20}\PYG{p}{;}
                \PYG{k}{if}\PYG{p}{(} \PYG{n}{number\PYGZus{}printed} \PYG{o}{\PYGZlt{}} \PYG{n}{dComplete}\PYG{p}{)}
                \PYG{p}{\PYGZob{}}
                    \PYG{n}{stringstream} \PYG{n}{os}\PYG{p}{;}
                    \PYG{n}{os}  \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}r}\PYG{l+s}{Importing }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{filename} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
                    \PYG{n}{number\PYGZus{}printed} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
                    \PYG{k}{while}\PYG{p}{(}\PYG{n}{number\PYGZus{}printed} \PYG{o}{\PYGZlt{}} \PYG{n}{dComplete}\PYG{p}{)}
                    \PYG{p}{\PYGZob{}}
                        \PYG{n}{os} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{.}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
                        \PYG{n}{number\PYGZus{}printed} \PYG{o}{+}\PYG{o}{+}\PYG{p}{;}
                    \PYG{p}{\PYGZcb{}}
                    \PYG{n}{os} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{flush}\PYG{p}{;}
                    \PYG{n}{writeInfo}\PYG{p}{(}\PYG{n}{os}\PYG{p}{.}\PYG{n}{str}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
                \PYG{p}{\PYGZcb{}}

            \PYG{p}{\PYGZcb{}}
        \PYG{p}{\PYGZcb{}}
        \PYG{n}{writeInfo}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{done!}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifndef use\PYGZus{}csv}

    \PYG{k+kt}{void} \PYG{n+nf}{importCsv}\PYG{p}{(}\PYG{k}{const} \PYG{n}{string} \PYG{o}{\PYGZam{}}\PYG{n}{filename}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{stringstream} \PYG{n}{os}\PYG{p}{;}
        \PYG{n}{os} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Importing}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{filename} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{flush}\PYG{p}{;}
        \PYG{n}{ifstream} \PYG{n}{inputstream}\PYG{p}{;}
        \PYG{n}{inputstream}\PYG{p}{.}\PYG{n}{open}\PYG{p}{(}\PYG{n}{filename}\PYG{p}{.}\PYG{n}{c\PYGZus{}str}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
        \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{number\PYGZus{}printed} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
        \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{uint32\PYGZus{}t} \PYG{n}{j} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{j} \PYG{o}{\PYGZlt{}} \PYG{n}{numRows}\PYG{p}{;} \PYG{n}{j}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{string} \PYG{n}{line}\PYG{p}{;}
            \PYG{n}{getline}\PYG{p}{(}\PYG{n}{inputstream}\PYG{p}{,} \PYG{n}{line}\PYG{p}{)}\PYG{p}{;}
            \PYG{n}{istringstream} \PYG{n}{iss}\PYG{p}{(}\PYG{n}{line}\PYG{p}{)}\PYG{p}{;}
            \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{uint32\PYGZus{}t} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{numCols}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{k+kt}{char} \PYG{n}{delim}\PYG{p}{;}
                \PYG{n}{T} \PYG{n}{val}\PYG{p}{;}
                \PYG{n}{iss} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{val} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{delim}\PYG{p}{;}
                \PYG{n}{matrix}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{=} \PYG{n}{val}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
            \PYG{k+kt}{double} \PYG{n}{dComplete} \PYG{o}{=} \PYG{p}{(}\PYG{p}{(}\PYG{k+kt}{double}\PYG{p}{)} \PYG{n}{j} \PYG{o}{/} \PYG{p}{(}\PYG{k+kt}{double}\PYG{p}{)} \PYG{n}{numRows}\PYG{p}{)} \PYG{o}{*} \PYG{l+m+mi}{5}\PYG{p}{;}
            \PYG{k}{if}\PYG{p}{(}\PYG{n}{number\PYGZus{}printed} \PYG{o}{\PYGZlt{}} \PYG{n}{dComplete}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{n}{os} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}r}\PYG{l+s}{Importing }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{filename} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{flush}\PYG{p}{;}
                \PYG{k}{while}\PYG{p}{(}\PYG{n}{number\PYGZus{}printed} \PYG{o}{\PYGZlt{}} \PYG{n}{dComplete}\PYG{p}{)}
                \PYG{p}{\PYGZob{}}
                    \PYG{n}{os} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{.}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
                    \PYG{n}{number\PYGZus{}printed}\PYG{o}{+}\PYG{o}{+}\PYG{p}{;}
                \PYG{p}{\PYGZcb{}}
                \PYG{n}{os} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{flush}\PYG{p}{;}
                \PYG{n}{writeInfo}\PYG{p}{(}\PYG{n}{os}\PYG{p}{.}\PYG{n}{str}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}

            \PYG{p}{\PYGZcb{}}
        \PYG{p}{\PYGZcb{}}
        \PYG{n}{stringstream} \PYG{n}{os2}\PYG{p}{;}
        \PYG{n}{os2} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}r}\PYG{l+s}{Importing}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{filename} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{...}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{done!}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{                          }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
        \PYG{n}{inputstream}\PYG{p}{.}\PYG{n}{close}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{writeInfo}\PYG{p}{(}\PYG{n}{os2}\PYG{p}{.}\PYG{n}{str}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}

\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifdef with\PYGZus{}gdal}

\PYG{k}{template}\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZgt{}} \PYG{k+kr}{inline} \PYG{k+kt}{void} \PYG{n}{Matrix}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{bool}\PYG{o}{\PYGZgt{}}\PYG{o}{:}\PYG{o}{:}\PYG{n}{internalImport}\PYG{p}{(}\PYG{k}{const} \PYG{n}{string} \PYG{o}{\PYGZam{}}\PYG{n}{filename}\PYG{p}{,} \PYG{n}{GDALRasterBand} \PYG{o}{*}\PYG{n}{poBand}\PYG{p}{,} \PYG{k+kt}{int} \PYG{n}{nBlockXSize}\PYG{p}{,}
                    \PYG{n}{GDALDataType} \PYG{n}{dt}\PYG{p}{,} \PYG{n}{CPLErr} \PYG{o}{\PYGZam{}}\PYG{n}{r}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{double} \PYG{o}{\PYGZam{}}\PYG{n}{ndv}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k}{if}\PYG{p}{(}\PYG{n}{dt} \PYG{o}{\PYGZlt{}}\PYG{o}{=}\PYG{l+m+mi}{7}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{c+c1}{// Then the tif file type is an int/byte}
        \PYG{c+c1}{// we can just import as it is}
        \PYG{n}{importUsingBuffer}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{uint8\PYGZus{}t}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{n}{filename}\PYG{p}{,} \PYG{n}{poBand}\PYG{p}{,} \PYG{n}{nBlockXSize}\PYG{p}{,} \PYG{n}{GDT\PYGZus{}Byte}\PYG{p}{,} \PYG{n}{r}\PYG{p}{,} \PYG{n}{ndv}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{else}
    \PYG{p}{\PYGZob{}}
        \PYG{c+c1}{// Conversion from double to boolean}
        \PYG{n}{importFromDoubleAndMakeBool}\PYG{p}{(}\PYG{n}{filename}\PYG{p}{,} \PYG{n}{poBand}\PYG{p}{,} \PYG{n}{nBlockXSize}\PYG{p}{,} \PYG{n}{dt}\PYG{p}{,} \PYG{n}{r}\PYG{p}{,} \PYG{n}{ndv}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\PYG{k}{template} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZgt{}}\PYG{k+kr}{inline} \PYG{k+kt}{void} \PYG{n}{Matrix}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int8\PYGZus{}t}\PYG{o}{\PYGZgt{}}\PYG{o}{:}\PYG{o}{:}\PYG{n}{internalImport}\PYG{p}{(}\PYG{k}{const} \PYG{n}{string} \PYG{o}{\PYGZam{}}\PYG{n}{filename}\PYG{p}{,} \PYG{n}{GDALRasterBand} \PYG{o}{*}\PYG{n}{poBand}\PYG{p}{,} \PYG{k+kt}{int} \PYG{n}{nBlockXSize}\PYG{p}{,}
                                                   \PYG{n}{GDALDataType} \PYG{n}{dt}\PYG{p}{,} \PYG{n}{CPLErr} \PYG{o}{\PYGZam{}}\PYG{n}{r}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{double} \PYG{o}{\PYGZam{}}\PYG{n}{ndv}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{n}{importUsingBuffer}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int16\PYGZus{}t}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{n}{filename}\PYG{p}{,} \PYG{n}{poBand}\PYG{p}{,} \PYG{n}{nBlockXSize}\PYG{p}{,} \PYG{n}{GDT\PYGZus{}Int16}\PYG{p}{,} \PYG{n}{r}\PYG{p}{,} \PYG{n}{ndv}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k}{template} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZgt{}}\PYG{k+kr}{inline} \PYG{k+kt}{void} \PYG{n}{Matrix}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{uint8\PYGZus{}t}\PYG{o}{\PYGZgt{}}\PYG{o}{:}\PYG{o}{:}\PYG{n}{internalImport}\PYG{p}{(}\PYG{k}{const} \PYG{n}{string} \PYG{o}{\PYGZam{}}\PYG{n}{filename}\PYG{p}{,} \PYG{n}{GDALRasterBand} \PYG{o}{*}\PYG{n}{poBand}\PYG{p}{,} \PYG{k+kt}{int} \PYG{n}{nBlockXSize}\PYG{p}{,}
                                                   \PYG{n}{GDALDataType} \PYG{n}{dt}\PYG{p}{,} \PYG{n}{CPLErr} \PYG{o}{\PYGZam{}}\PYG{n}{r}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{double} \PYG{o}{\PYGZam{}}\PYG{n}{ndv}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{n}{defaultImport}\PYG{p}{(}\PYG{n}{filename}\PYG{p}{,} \PYG{n}{poBand}\PYG{p}{,} \PYG{n}{nBlockXSize}\PYG{p}{,} \PYG{n}{GDT\PYGZus{}Byte}\PYG{p}{,} \PYG{n}{r}\PYG{p}{,} \PYG{n}{ndv}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k}{template} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZgt{}}\PYG{k+kr}{inline} \PYG{k+kt}{void} \PYG{n}{Matrix}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int16\PYGZus{}t}\PYG{o}{\PYGZgt{}}\PYG{o}{:}\PYG{o}{:}\PYG{n}{internalImport}\PYG{p}{(}\PYG{k}{const} \PYG{n}{string} \PYG{o}{\PYGZam{}}\PYG{n}{filename}\PYG{p}{,} \PYG{n}{GDALRasterBand} \PYG{o}{*}\PYG{n}{poBand}\PYG{p}{,} \PYG{k+kt}{int} \PYG{n}{nBlockXSize}\PYG{p}{,}
                                                             \PYG{n}{GDALDataType} \PYG{n}{dt}\PYG{p}{,} \PYG{n}{CPLErr} \PYG{o}{\PYGZam{}}\PYG{n}{r}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{double} \PYG{o}{\PYGZam{}}\PYG{n}{ndv}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{n}{defaultImport}\PYG{p}{(}\PYG{n}{filename}\PYG{p}{,} \PYG{n}{poBand}\PYG{p}{,} \PYG{n}{nBlockXSize}\PYG{p}{,} \PYG{n}{GDT\PYGZus{}Int16}\PYG{p}{,} \PYG{n}{r}\PYG{p}{,} \PYG{n}{ndv}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{k}{template} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZgt{}}\PYG{k+kr}{inline} \PYG{k+kt}{void} \PYG{n}{Matrix}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{uint16\PYGZus{}t}\PYG{o}{\PYGZgt{}}\PYG{o}{:}\PYG{o}{:}\PYG{n}{internalImport}\PYG{p}{(}\PYG{k}{const} \PYG{n}{string} \PYG{o}{\PYGZam{}}\PYG{n}{filename}\PYG{p}{,} \PYG{n}{GDALRasterBand} \PYG{o}{*}\PYG{n}{poBand}\PYG{p}{,} \PYG{k+kt}{int} \PYG{n}{nBlockXSize}\PYG{p}{,}
                                                             \PYG{n}{GDALDataType} \PYG{n}{dt}\PYG{p}{,} \PYG{n}{CPLErr} \PYG{o}{\PYGZam{}}\PYG{n}{r}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{double} \PYG{o}{\PYGZam{}}\PYG{n}{ndv}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{n}{defaultImport}\PYG{p}{(}\PYG{n}{filename}\PYG{p}{,} \PYG{n}{poBand}\PYG{p}{,} \PYG{n}{nBlockXSize}\PYG{p}{,} \PYG{n}{GDT\PYGZus{}UInt16}\PYG{p}{,} \PYG{n}{r}\PYG{p}{,} \PYG{n}{ndv}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{k}{template} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZgt{}}\PYG{k+kr}{inline} \PYG{k+kt}{void} \PYG{n}{Matrix}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{uint32\PYGZus{}t}\PYG{o}{\PYGZgt{}}\PYG{o}{:}\PYG{o}{:}\PYG{n}{internalImport}\PYG{p}{(}\PYG{k}{const} \PYG{n}{string} \PYG{o}{\PYGZam{}}\PYG{n}{filename}\PYG{p}{,} \PYG{n}{GDALRasterBand} \PYG{o}{*}\PYG{n}{poBand}\PYG{p}{,} \PYG{k+kt}{int} \PYG{n}{nBlockXSize}\PYG{p}{,}
                                                              \PYG{n}{GDALDataType} \PYG{n}{dt}\PYG{p}{,} \PYG{n}{CPLErr} \PYG{o}{\PYGZam{}}\PYG{n}{r}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{double} \PYG{o}{\PYGZam{}}\PYG{n}{ndv}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{n}{defaultImport}\PYG{p}{(}\PYG{n}{filename}\PYG{p}{,} \PYG{n}{poBand}\PYG{p}{,} \PYG{n}{nBlockXSize}\PYG{p}{,} \PYG{n}{GDT\PYGZus{}UInt32}\PYG{p}{,} \PYG{n}{r}\PYG{p}{,} \PYG{n}{ndv}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{k}{template} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZgt{}}\PYG{k+kr}{inline} \PYG{k+kt}{void} \PYG{n}{Matrix}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int32\PYGZus{}t}\PYG{o}{\PYGZgt{}}\PYG{o}{:}\PYG{o}{:}\PYG{n}{internalImport}\PYG{p}{(}\PYG{k}{const} \PYG{n}{string} \PYG{o}{\PYGZam{}}\PYG{n}{filename}\PYG{p}{,} \PYG{n}{GDALRasterBand} \PYG{o}{*}\PYG{n}{poBand}\PYG{p}{,} \PYG{k+kt}{int} \PYG{n}{nBlockXSize}\PYG{p}{,}
                                                        \PYG{n}{GDALDataType} \PYG{n}{dt}\PYG{p}{,} \PYG{n}{CPLErr} \PYG{o}{\PYGZam{}}\PYG{n}{r}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{double} \PYG{o}{\PYGZam{}}\PYG{n}{ndv}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{n}{defaultImport}\PYG{p}{(}\PYG{n}{filename}\PYG{p}{,} \PYG{n}{poBand}\PYG{p}{,} \PYG{n}{nBlockXSize}\PYG{p}{,} \PYG{n}{GDT\PYGZus{}Int32}\PYG{p}{,} \PYG{n}{r}\PYG{p}{,} \PYG{n}{ndv}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{k}{template} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZgt{}}\PYG{k+kr}{inline} \PYG{k+kt}{void} \PYG{n}{Matrix}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{float}\PYG{o}{\PYGZgt{}}\PYG{o}{:}\PYG{o}{:}\PYG{n}{internalImport}\PYG{p}{(}\PYG{k}{const} \PYG{n}{string} \PYG{o}{\PYGZam{}}\PYG{n}{filename}\PYG{p}{,} \PYG{n}{GDALRasterBand} \PYG{o}{*}\PYG{n}{poBand}\PYG{p}{,} \PYG{k+kt}{int} \PYG{n}{nBlockXSize}\PYG{p}{,}
                                                              \PYG{n}{GDALDataType} \PYG{n}{dt}\PYG{p}{,} \PYG{n}{CPLErr} \PYG{o}{\PYGZam{}}\PYG{n}{r}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{double} \PYG{o}{\PYGZam{}}\PYG{n}{ndv}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{n}{defaultImport}\PYG{p}{(}\PYG{n}{filename}\PYG{p}{,} \PYG{n}{poBand}\PYG{p}{,} \PYG{n}{nBlockXSize}\PYG{p}{,} \PYG{n}{GDT\PYGZus{}Float32}\PYG{p}{,} \PYG{n}{r}\PYG{p}{,} \PYG{n}{ndv}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k}{template} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZgt{}}\PYG{k+kr}{inline} \PYG{k+kt}{void} \PYG{n}{Matrix}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{double}\PYG{o}{\PYGZgt{}}\PYG{o}{:}\PYG{o}{:}\PYG{n}{internalImport}\PYG{p}{(}\PYG{k}{const} \PYG{n}{string} \PYG{o}{\PYGZam{}}\PYG{n}{filename}\PYG{p}{,} \PYG{n}{GDALRasterBand} \PYG{o}{*}\PYG{n}{poBand}\PYG{p}{,} \PYG{k+kt}{int} \PYG{n}{nBlockXSize}\PYG{p}{,}
                                                              \PYG{n}{GDALDataType} \PYG{n}{dt}\PYG{p}{,} \PYG{n}{CPLErr} \PYG{o}{\PYGZam{}}\PYG{n}{r}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{double} \PYG{o}{\PYGZam{}}\PYG{n}{ndv}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{n}{defaultImport}\PYG{p}{(}\PYG{n}{filename}\PYG{p}{,} \PYG{n}{poBand}\PYG{p}{,} \PYG{n}{nBlockXSize}\PYG{p}{,} \PYG{n}{GDT\PYGZus{}Float64}\PYG{p}{,} \PYG{n}{r}\PYG{p}{,} \PYG{n}{ndv}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif }\PYG{c+c1}{// gdal}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif }\PYG{c+c1}{// MATRIX}
\end{sphinxVerbatim}


\subsubsection{Detailed Description}
\label{\detokenize{api/file_necsim_Matrix.h:detailed-description}}
Samuel Thompson
BSD-3 Licence.
Code supplied by James Rosindell with large usage of  href = \sphinxquotedblleft{}\sphinxurl{http://www.devarticles.com/c/a/Cplusplus/Operator-Overloading-in-C-plus/1}\sphinxquotedblleft{}\textgreater{} this website , and modified and updated by Samuel Thompson. There are two distinct classes, {\hyperref[\detokenize{api/class_Row:template-class-row}]{\sphinxcrossref{\DUrole{std,std-ref}{Template Class Row}}}} and {\hyperref[\detokenize{api/class_Matrix:template-class-matrix}]{\sphinxcrossref{\DUrole{std,std-ref}{Template Class Matrix}}}}. Most operations are low-level, but some higher level functions remain, such as importCsv().
Contact: \sphinxhref{mailto:thompsonsed@gmail.com}{thompsonsed@gmail.com}


\subsubsection{Includes}
\label{\detokenize{api/file_necsim_Matrix.h:includes}}\begin{itemize}
\item {} 
\sphinxcode{Logging.h} ({\hyperref[\detokenize{api/file_necsim_Logging.h:file-necsim-logging-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File Logging.h}}}})

\item {} 
\sphinxcode{cstdint}

\item {} 
\sphinxcode{cstdio}

\item {} 
\sphinxcode{cstdlib}

\item {} 
\sphinxcode{cstring}

\item {} 
\sphinxcode{fstream}

\item {} 
\sphinxcode{iostream}

\item {} 
\sphinxcode{sstream}

\item {} 
\sphinxcode{stdexcept}

\end{itemize}


\subsubsection{Included By}
\label{\detokenize{api/file_necsim_Matrix.h:included-by}}\begin{itemize}
\item {} 
{\hyperref[\detokenize{api/file_necsim_Community.h:file-necsim-community-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File Community.h}}}}

\item {} 
{\hyperref[\detokenize{api/file_necsim_DataMask.h:file-necsim-datamask-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File DataMask.h}}}}

\item {} 
{\hyperref[\detokenize{api/file_necsim_Map.h:file-necsim-map-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File Map.h}}}}

\item {} 
{\hyperref[\detokenize{api/file_necsim_DispersalCoordinator.h:file-necsim-dispersalcoordinator-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File DispersalCoordinator.h}}}}

\item {} 
{\hyperref[\detokenize{api/file_necsim_Tree.h:file-necsim-tree-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File Tree.h}}}}

\item {} 
{\hyperref[\detokenize{api/file_necsim_SpatialTree.h:file-necsim-spatialtree-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File SpatialTree.h}}}}

\item {} 
{\hyperref[\detokenize{api/file_necsim_SpeciesList.h:file-necsim-specieslist-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File SpeciesList.h}}}}

\item {} 
{\hyperref[\detokenize{api/file_necsim_ReproductionMap.h:file-necsim-reproductionmap-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File ReproductionMap.h}}}}

\item {} 
{\hyperref[\detokenize{api/file_necsim_SimulateDispersal.h:file-necsim-simulatedispersal-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File SimulateDispersal.h}}}}

\end{itemize}


\subsubsection{Classes}
\label{\detokenize{api/file_necsim_Matrix.h:classes}}\begin{itemize}
\item {} 
{\hyperref[\detokenize{api/class_Matrix:template-class-matrix}]{\sphinxcrossref{\DUrole{std,std-ref}{Template Class Matrix}}}}

\item {} 
{\hyperref[\detokenize{api/class_Row:template-class-row}]{\sphinxcrossref{\DUrole{std,std-ref}{Template Class Row}}}}

\end{itemize}


\subsubsection{Defines}
\label{\detokenize{api/file_necsim_Matrix.h:defines}}\begin{itemize}
\item {} 
{\hyperref[\detokenize{api/define_null:define-null}]{\sphinxcrossref{\DUrole{std,std-ref}{Define null}}}}

\end{itemize}


\subsubsection{Variables}
\label{\detokenize{api/file_necsim_Matrix.h:variables}}\begin{itemize}
\item {} 
{\hyperref[\detokenize{api/variable_gdal_data_sizes:variable-gdal-data-sizes}]{\sphinxcrossref{\DUrole{std,std-ref}{Variable gdal\_data\_sizes}}}}

\end{itemize}


\subsection{File Metacommunity.cpp}
\label{\detokenize{api/file_necsim_Metacommunity.cpp:file-necsim-metacommunity-cpp}}\label{\detokenize{api/file_necsim_Metacommunity.cpp:file-metacommunity-cpp}}\label{\detokenize{api/file_necsim_Metacommunity.cpp::doc}}
Contains the {\hyperref[\detokenize{api/class_Metacommunity:class-metacommunity}]{\sphinxcrossref{\DUrole{std,std-ref}{Class Metacommunity}}}} class for generating a neutral metacommunity.

\begin{sphinxShadowBox}
\sphinxstyletopictitle{Contents}
\begin{itemize}
\item {} 
\phantomsection\label{\detokenize{api/file_necsim_Metacommunity.cpp:id1}}{\hyperref[\detokenize{api/file_necsim_Metacommunity.cpp:definition-necsim-metacommunity-cpp}]{\sphinxcrossref{Definition (\sphinxcode{necsim/Metacommunity.cpp})}}}

\item {} 
\phantomsection\label{\detokenize{api/file_necsim_Metacommunity.cpp:id2}}{\hyperref[\detokenize{api/file_necsim_Metacommunity.cpp:detailed-description}]{\sphinxcrossref{Detailed Description}}}

\item {} 
\phantomsection\label{\detokenize{api/file_necsim_Metacommunity.cpp:id3}}{\hyperref[\detokenize{api/file_necsim_Metacommunity.cpp:includes}]{\sphinxcrossref{Includes}}}

\end{itemize}
\end{sphinxShadowBox}


\subsubsection{Definition (\sphinxstyleliteralintitle{necsim/Metacommunity.cpp})}
\label{\detokenize{api/file_necsim_Metacommunity.cpp:definition-necsim-metacommunity-cpp}}

\paragraph{Program Listing for File Metacommunity.cpp}
\label{\detokenize{api/program_listing_file_necsim_Metacommunity.cpp:program-listing-file-necsim-metacommunity-cpp}}\label{\detokenize{api/program_listing_file_necsim_Metacommunity.cpp::doc}}\label{\detokenize{api/program_listing_file_necsim_Metacommunity.cpp:program-listing-for-file-metacommunity-cpp}}\begin{itemize}
\item {} 
Return to documentation for {\hyperref[\detokenize{api/file_necsim_Metacommunity.cpp:file-necsim-metacommunity-cpp}]{\sphinxcrossref{\DUrole{std,std-ref}{File Metacommunity.cpp}}}}

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{// This file is part of NECSim project which is released under BSD\PYGZhy{}3 license.}
\PYG{c+c1}{// See file **LICENSE.txt** or visit https://opensource.org/licenses/BSD\PYGZhy{}3\PYGZhy{}Clause) for full license details.}

\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZdq{}Metacommunity.h\PYGZdq{}}


\PYG{n}{Metacommunity}\PYG{o}{:}\PYG{o}{:}\PYG{n}{Metacommunity}\PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{n}{community\PYGZus{}size} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
    \PYG{n}{seed} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
    \PYG{n}{speciation\PYGZus{}rate} \PYG{o}{=} \PYG{l+m+mf}{0.0}\PYG{p}{;}
    \PYG{n}{parameters\PYGZus{}checked} \PYG{o}{=} \PYG{n+nb}{false}\PYG{p}{;}
    \PYG{n}{metacommunity\PYGZus{}cumulative\PYGZus{}abundances} \PYG{o}{=} \PYG{k}{nullptr}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{void} \PYG{n}{Metacommunity}\PYG{o}{:}\PYG{o}{:}\PYG{n}{setCommunityParameters}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{community\PYGZus{}size\PYGZus{}in}\PYG{p}{,} \PYG{k+kt}{long} \PYG{k+kt}{double} \PYG{n}{speciation\PYGZus{}rate\PYGZus{}in}\PYG{p}{,}
                                           \PYG{n}{string} \PYG{n}{database\PYGZus{}name\PYGZus{}in}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{n}{createParent}\PYG{p}{(}\PYG{n}{database\PYGZus{}name\PYGZus{}in}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{community\PYGZus{}size} \PYG{o}{=} \PYG{n}{community\PYGZus{}size\PYGZus{}in}\PYG{p}{;}
    \PYG{n}{speciation\PYGZus{}rate} \PYG{o}{=} \PYG{n}{speciation\PYGZus{}rate\PYGZus{}in}\PYG{p}{;}
    \PYG{c+c1}{// open the sqlite connection to the output database}
    \PYG{n}{openSqlConnection}\PYG{p}{(}\PYG{n}{database\PYGZus{}name\PYGZus{}in}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{void} \PYG{n}{Metacommunity}\PYG{o}{:}\PYG{o}{:}\PYG{n}{checkSimulationParameters}\PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k}{if}\PYG{p}{(}\PYG{o}{!}\PYG{n}{parameters\PYGZus{}checked}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{database} \PYG{o}{=}\PYG{o}{=} \PYG{k}{nullptr}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{k}{throw} \PYG{n}{FatalException}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Cannot read simulation parameters as database is null pointer.}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{c+c1}{// Now do the same for times}
        \PYG{n}{sqlite3\PYGZus{}stmt} \PYG{o}{*}\PYG{n}{stmt}\PYG{p}{;}
        \PYG{n}{string} \PYG{n}{sql\PYGZus{}call} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{SELECT seed, task from SIMULATION\PYGZus{}PARAMETERS}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
        \PYG{k+kt}{int} \PYG{n}{rc} \PYG{o}{=} \PYG{n}{sqlite3\PYGZus{}prepare\PYGZus{}v2}\PYG{p}{(}\PYG{n}{database}\PYG{p}{,} \PYG{n}{sql\PYGZus{}call}\PYG{p}{.}\PYG{n}{c\PYGZus{}str}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{k}{static\PYGZus{}cast}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{n}{strlen}\PYG{p}{(}\PYG{n}{sql\PYGZus{}call}\PYG{p}{.}\PYG{n}{c\PYGZus{}str}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{stmt}\PYG{p}{,}
                                    \PYG{k}{nullptr}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{rc} \PYG{o}{!}\PYG{o}{=} \PYG{n}{SQLITE\PYGZus{}DONE} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{n}{rc} \PYG{o}{!}\PYG{o}{=} \PYG{n}{SQLITE\PYGZus{}OK}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{sqlite3\PYGZus{}close}\PYG{p}{(}\PYG{n}{database}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{n}{sqlite3\PYGZus{}step}\PYG{p}{(}\PYG{n}{stmt}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{seed} \PYG{o}{=} \PYG{k}{static\PYGZus{}cast}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{unsigned} \PYG{k+kt}{long}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{n}{sqlite3\PYGZus{}column\PYGZus{}int}\PYG{p}{(}\PYG{n}{stmt}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{random}\PYG{p}{.}\PYG{n}{setSeed}\PYG{p}{(}\PYG{n}{seed}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{task} \PYG{o}{=} \PYG{k}{static\PYGZus{}cast}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{unsigned} \PYG{k+kt}{long}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{n}{sqlite3\PYGZus{}column\PYGZus{}int}\PYG{p}{(}\PYG{n}{stmt}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{sqlite3\PYGZus{}step}\PYG{p}{(}\PYG{n}{stmt}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{sqlite3\PYGZus{}finalize}\PYG{p}{(}\PYG{n}{stmt}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{parameters\PYGZus{}checked} \PYG{o}{=} \PYG{n+nb}{true}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{void} \PYG{n}{Metacommunity}\PYG{o}{:}\PYG{o}{:}\PYG{n}{addSpecies}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{species\PYGZus{}count}\PYG{p}{,} \PYG{n}{TreeNode} \PYG{o}{*}\PYG{n}{tree\PYGZus{}node}\PYG{p}{,} \PYG{n}{set}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{unsigned} \PYG{k+kt}{long}\PYG{o}{\PYGZgt{}} \PYG{o}{\PYGZam{}}\PYG{n}{species\PYGZus{}list}\PYG{p}{)}
\PYG{p}{\PYGZob{}}

    \PYG{k}{auto} \PYG{n}{species\PYGZus{}id} \PYG{o}{=} \PYG{n}{selectLineageFromMetacommunity}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
    \PYG{k}{if}\PYG{p}{(}\PYG{n}{species\PYGZus{}list}\PYG{p}{.}\PYG{n}{empty}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\textbar{}}\PYG{o}{\textbar{}} \PYG{n}{species\PYGZus{}list}\PYG{p}{.}\PYG{n}{find}\PYG{p}{(}\PYG{n}{species\PYGZus{}id}\PYG{p}{)} \PYG{o}{!}\PYG{o}{=} \PYG{n}{species\PYGZus{}list}\PYG{p}{.}\PYG{n}{end}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{species\PYGZus{}list}\PYG{p}{.}\PYG{n}{insert}\PYG{p}{(}\PYG{n}{species\PYGZus{}id}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{species\PYGZus{}count} \PYG{o}{+}\PYG{o}{+}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{n}{tree\PYGZus{}node}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{burnSpecies}\PYG{p}{(}\PYG{n}{species\PYGZus{}id}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{void} \PYG{n}{Metacommunity}\PYG{o}{:}\PYG{o}{:}\PYG{n}{createMetacommunityNSENeutralModel}\PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifdef DEBUG}
    \PYG{n}{writeLog}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Running spatially\PYGZhy{}implicit model for metacommunity generation.}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif }\PYG{c+c1}{//DEBUG}
    \PYG{c+c1}{// First set up a non\PYGZhy{}spatial coalescence simulation to generate our metacommunity}
    \PYG{n}{SimParameters} \PYG{n}{temp\PYGZus{}parameters}\PYG{p}{;}
    \PYG{n}{temp\PYGZus{}parameters}\PYG{p}{.}\PYG{n}{setMetacommunityParameters}\PYG{p}{(}\PYG{n}{community\PYGZus{}size}\PYG{p}{,} \PYG{n}{speciation\PYGZus{}rate}\PYG{p}{,} \PYG{n}{seed}\PYG{p}{,} \PYG{n}{task}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{metacommunity\PYGZus{}tree}\PYG{p}{.}\PYG{n}{internalSetup}\PYG{p}{(}\PYG{n}{temp\PYGZus{}parameters}\PYG{p}{)}\PYG{p}{;}
    \PYG{c+c1}{// Run our simulation and calculate the species abundance distribution (as this is all that needs to be stored).}
    \PYG{k}{if}\PYG{p}{(}\PYG{o}{!}\PYG{n}{metacommunity\PYGZus{}tree}\PYG{p}{.}\PYG{n}{runSimulation}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{throw} \PYG{n}{FatalException}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Completion of the non\PYGZhy{}spatial coalescence simulation }\PYG{l+s}{\PYGZdq{}}
                                     \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{to create the metacommunity did not finish in time.}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{n}{metacommunity\PYGZus{}tree}\PYG{p}{.}\PYG{n}{applySpecRateInternal}\PYG{p}{(}\PYG{n}{speciation\PYGZus{}rate}\PYG{p}{,} \PYG{l+m+mf}{0.0}\PYG{p}{)}\PYG{p}{;}
    \PYG{c+c1}{// row\PYGZus{}out now contains the number of individuals per species}
    \PYG{c+c1}{// Make it cumulative to increase the speed of indexing using binary search.}
    \PYG{n}{metacommunity\PYGZus{}cumulative\PYGZus{}abundances} \PYG{o}{=} \PYG{n}{metacommunity\PYGZus{}tree}\PYG{p}{.}\PYG{n}{getCumulativeAbundances}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifdef DEBUG}
    \PYG{n}{writeLog}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Spatially\PYGZhy{}implicit simulation completed.}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif }\PYG{c+c1}{//DEBUG}

\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{Metacommunity}\PYG{o}{:}\PYG{o}{:}\PYG{n}{selectLineageFromMetacommunity}\PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k}{auto} \PYG{n}{max\PYGZus{}indices} \PYG{o}{=} \PYG{n}{metacommunity\PYGZus{}cumulative\PYGZus{}abundances}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{1}\PYG{p}{;}
    \PYG{k}{auto} \PYG{n}{random\PYGZus{}value} \PYG{o}{=} \PYG{n}{random}\PYG{p}{.}\PYG{n}{i0}\PYG{p}{(}\PYG{n}{community\PYGZus{}size} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifdef DEBUG}
    \PYG{c+c1}{// binary search}
    \PYG{k}{if}\PYG{p}{(}\PYG{n}{random\PYGZus{}value} \PYG{o}{\PYGZgt{}} \PYG{p}{(}\PYG{o}{*}\PYG{n}{metacommunity\PYGZus{}cumulative\PYGZus{}abundances}\PYG{p}{)}\PYG{p}{[}\PYG{n}{max\PYGZus{}indices}\PYG{p}{]}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{throw} \PYG{n}{FatalException}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Random number generation out of range of the community size in lineage selection.}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif }\PYG{c+c1}{//DEBUG}
    \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{mid\PYGZus{}point}\PYG{p}{;}
    \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{min\PYGZus{}indices} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
    \PYG{k}{while}\PYG{p}{(}\PYG{n}{min\PYGZus{}indices} \PYG{o}{\PYGZlt{}} \PYG{n}{max\PYGZus{}indices}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{mid\PYGZus{}point} \PYG{o}{=} \PYG{k}{static\PYGZus{}cast}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{unsigned} \PYG{k+kt}{long}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{n}{floor}\PYG{p}{(}\PYG{p}{(}\PYG{p}{(}\PYG{n}{max\PYGZus{}indices} \PYG{o}{\PYGZhy{}} \PYG{n}{min\PYGZus{}indices}\PYG{p}{)} \PYG{o}{/} \PYG{l+m+mi}{2}\PYG{p}{)} \PYG{o}{+} \PYG{n}{min\PYGZus{}indices}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{random\PYGZus{}value} \PYG{o}{=}\PYG{o}{=} \PYG{p}{(}\PYG{o}{*}\PYG{n}{metacommunity\PYGZus{}cumulative\PYGZus{}abundances}\PYG{p}{)}\PYG{p}{[}\PYG{n}{mid\PYGZus{}point}\PYG{p}{]}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{min\PYGZus{}indices} \PYG{o}{=} \PYG{n}{mid\PYGZus{}point}\PYG{p}{;}
            \PYG{n}{max\PYGZus{}indices} \PYG{o}{=} \PYG{n}{mid\PYGZus{}point}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{random\PYGZus{}value} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{p}{(}\PYG{o}{*}\PYG{n}{metacommunity\PYGZus{}cumulative\PYGZus{}abundances}\PYG{p}{)}\PYG{p}{[}\PYG{n}{mid\PYGZus{}point}\PYG{p}{]}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{max\PYGZus{}indices} \PYG{o}{=} \PYG{n}{mid\PYGZus{}point}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{else}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{min\PYGZus{}indices} \PYG{o}{=} \PYG{n}{mid\PYGZus{}point}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{if}\PYG{p}{(}\PYG{n}{min\PYGZus{}indices} \PYG{o}{=}\PYG{o}{=} \PYG{n}{max\PYGZus{}indices} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{1}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{return} \PYG{n}{max\PYGZus{}indices}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifdef DEBUG}
    \PYG{k}{if}\PYG{p}{(}\PYG{n}{min\PYGZus{}indices} \PYG{o}{!}\PYG{o}{=} \PYG{n}{max\PYGZus{}indices}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{throw} \PYG{n}{FatalException}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Error in binary search algorithm for lineage selection. Please report this bug.}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif }\PYG{c+c1}{// DEBUG}
    \PYG{k}{return} \PYG{n}{min\PYGZus{}indices}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{void} \PYG{n}{Metacommunity}\PYG{o}{:}\PYG{o}{:}\PYG{n}{apply}\PYG{p}{(}\PYG{n}{SpecSimParameters} \PYG{o}{*}\PYG{n}{sp}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifdef DEBUG}
    \PYG{n}{writeLog}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{********************}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{writeLog}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Metacommunity application}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif }\PYG{c+c1}{//DEBUG}
    \PYG{k+kt}{time\PYGZus{}t} \PYG{n}{tStart}\PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
    \PYG{k+kt}{time\PYGZus{}t} \PYG{n}{tEnd}\PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
    \PYG{c+c1}{// Start the clock}
    \PYG{n}{time}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{tStart}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{setCommunityParameters}\PYG{p}{(}\PYG{n}{sp}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{metacommunity\PYGZus{}size}\PYG{p}{,} \PYG{n}{sp}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{metacommunity\PYGZus{}speciation\PYGZus{}rate}\PYG{p}{,} \PYG{n}{sp}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{filename}\PYG{p}{)}\PYG{p}{;}
    \PYG{c+c1}{// Make sure that the connection is opened to file.}
    \PYG{n}{bSqlConnection} \PYG{o}{=} \PYG{n+nb}{false}\PYG{p}{;}
    \PYG{n}{checkSimulationParameters}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{createMetacommunityNSENeutralModel}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifdef DEBUG}
    \PYG{n}{writeLog}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Creating coalescence tree from metacommunity...}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif }\PYG{c+c1}{//DEBUG}
    \PYG{n}{doApplication}\PYG{p}{(}\PYG{n}{sp}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{output}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{printEndTimes}\PYG{p}{(}\PYG{n}{tStart}\PYG{p}{,} \PYG{n}{tEnd}\PYG{p}{)}\PYG{p}{;}

\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}


\subsubsection{Detailed Description}
\label{\detokenize{api/file_necsim_Metacommunity.cpp:detailed-description}}
Samuel Thompson
BSD-3 Licence. For use with completed simulations from NECSim, using the SpeciationCounter program. Individuals will be drawn from the metacommunity for each speciation event, instead of creating a new species each time.
Contact: \sphinxhref{mailto:samuel.thompson14@imperial.ac.uk}{samuel.thompson14@imperial.ac.uk} or \sphinxhref{mailto:thompsonsed@gmail.com}{thompsonsed@gmail.com}


\subsubsection{Includes}
\label{\detokenize{api/file_necsim_Metacommunity.cpp:includes}}\begin{itemize}
\item {} 
\sphinxcode{Metacommunity.h} ({\hyperref[\detokenize{api/file_necsim_Metacommunity.h:file-necsim-metacommunity-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File Metacommunity.h}}}})

\end{itemize}


\subsection{File Metacommunity.h}
\label{\detokenize{api/file_necsim_Metacommunity.h:file-metacommunity-h}}\label{\detokenize{api/file_necsim_Metacommunity.h::doc}}\label{\detokenize{api/file_necsim_Metacommunity.h:file-necsim-metacommunity-h}}
Generates a neutral metacommunity.

\begin{sphinxShadowBox}
\sphinxstyletopictitle{Contents}
\begin{itemize}
\item {} 
\phantomsection\label{\detokenize{api/file_necsim_Metacommunity.h:id1}}{\hyperref[\detokenize{api/file_necsim_Metacommunity.h:definition-necsim-metacommunity-h}]{\sphinxcrossref{Definition (\sphinxcode{necsim/Metacommunity.h})}}}

\item {} 
\phantomsection\label{\detokenize{api/file_necsim_Metacommunity.h:id2}}{\hyperref[\detokenize{api/file_necsim_Metacommunity.h:detailed-description}]{\sphinxcrossref{Detailed Description}}}

\item {} 
\phantomsection\label{\detokenize{api/file_necsim_Metacommunity.h:id3}}{\hyperref[\detokenize{api/file_necsim_Metacommunity.h:includes}]{\sphinxcrossref{Includes}}}

\item {} 
\phantomsection\label{\detokenize{api/file_necsim_Metacommunity.h:id4}}{\hyperref[\detokenize{api/file_necsim_Metacommunity.h:included-by}]{\sphinxcrossref{Included By}}}

\item {} 
\phantomsection\label{\detokenize{api/file_necsim_Metacommunity.h:id5}}{\hyperref[\detokenize{api/file_necsim_Metacommunity.h:classes}]{\sphinxcrossref{Classes}}}

\end{itemize}
\end{sphinxShadowBox}


\subsubsection{Definition (\sphinxstyleliteralintitle{necsim/Metacommunity.h})}
\label{\detokenize{api/file_necsim_Metacommunity.h:definition-necsim-metacommunity-h}}

\paragraph{Program Listing for File Metacommunity.h}
\label{\detokenize{api/program_listing_file_necsim_Metacommunity.h::doc}}\label{\detokenize{api/program_listing_file_necsim_Metacommunity.h:program-listing-file-necsim-metacommunity-h}}\label{\detokenize{api/program_listing_file_necsim_Metacommunity.h:program-listing-for-file-metacommunity-h}}\begin{itemize}
\item {} 
Return to documentation for {\hyperref[\detokenize{api/file_necsim_Metacommunity.h:file-necsim-metacommunity-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File Metacommunity.h}}}}

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{// This file is part of NECSim project which is released under BSD\PYGZhy{}3 license.}
\PYG{c+c1}{// See file **LICENSE.txt** or visit https://opensource.org/licenses/BSD\PYGZhy{}3\PYGZhy{}Clause) for full license details.}

\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifndef SPECIATIONCOUNTER\PYGZus{}METACOMMUNITY\PYGZus{}H}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define SPECIATIONCOUNTER\PYGZus{}METACOMMUNITY\PYGZus{}H}

\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}string\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}sqlite3.h\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}set\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZdq{}Tree.h\PYGZdq{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZdq{}Community.h\PYGZdq{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZdq{}NRrand.h\PYGZdq{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZdq{}SpecSimParameters.h\PYGZdq{}}

\PYG{k}{using} \PYG{k}{namespace} \PYG{n}{std}\PYG{p}{;}
\PYG{k}{class} \PYG{n+nc}{Metacommunity} \PYG{o}{:} \PYG{k}{public} \PYG{k}{virtual} \PYG{n}{Community}
\PYG{p}{\PYGZob{}}
\PYG{k}{protected}\PYG{o}{:}
    \PYG{c+c1}{// The number of individuals in the metacommunity}
    \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{community\PYGZus{}size}\PYG{p}{;}
    \PYG{c+c1}{// The speciation rate used for creation of the metacommunity}
    \PYG{k+kt}{long} \PYG{k+kt}{double} \PYG{n}{speciation\PYGZus{}rate}\PYG{p}{;}
    \PYG{c+c1}{// Simulation seed and task (read from the output database or set to 1)}
    \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{seed}\PYG{p}{;}
    \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{task}\PYG{p}{;}
    \PYG{k+kt}{bool} \PYG{n}{parameters\PYGZus{}checked}\PYG{p}{;}
    \PYG{n}{Row}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{unsigned} \PYG{k+kt}{long}\PYG{o}{\PYGZgt{}} \PYG{o}{*} \PYG{n}{metacommunity\PYGZus{}cumulative\PYGZus{}abundances}\PYG{p}{;}
    \PYG{n}{NRrand} \PYG{n}{random}\PYG{p}{;}
    \PYG{n}{Tree} \PYG{n}{metacommunity\PYGZus{}tree}\PYG{p}{;}
\PYG{k}{public}\PYG{o}{:}

    \PYG{n}{Metacommunity}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

    \PYG{o}{\PYGZti{}}\PYG{n}{Metacommunity}\PYG{p}{(}\PYG{p}{)} \PYG{o}{=} \PYG{k}{default}\PYG{p}{;}

    \PYG{k+kt}{void} \PYG{n+nf}{setCommunityParameters}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{community\PYGZus{}size\PYGZus{}in}\PYG{p}{,} \PYG{k+kt}{long} \PYG{k+kt}{double} \PYG{n}{speciation\PYGZus{}rate\PYGZus{}in}\PYG{p}{,} \PYG{n}{string} \PYG{n}{database\PYGZus{}name\PYGZus{}in}\PYG{p}{)}\PYG{p}{;}

    \PYG{k+kt}{void} \PYG{n+nf}{checkSimulationParameters}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

    \PYG{k+kt}{void} \PYG{n+nf}{addSpecies}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{species\PYGZus{}count}\PYG{p}{,} \PYG{n}{TreeNode} \PYG{o}{*}\PYG{n}{tree\PYGZus{}node}\PYG{p}{,} \PYG{n}{set}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{unsigned} \PYG{k+kt}{long}\PYG{o}{\PYGZgt{}} \PYG{o}{\PYGZam{}}\PYG{n}{species\PYGZus{}list}\PYG{p}{)} \PYG{k}{override}\PYG{p}{;}

    \PYG{k+kt}{void} \PYG{n+nf}{createMetacommunityNSENeutralModel}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

    \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n+nf}{selectLineageFromMetacommunity}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

    \PYG{k+kt}{void} \PYG{n+nf}{apply}\PYG{p}{(}\PYG{n}{SpecSimParameters} \PYG{o}{*}\PYG{n}{sp}\PYG{p}{)} \PYG{k}{override} \PYG{p}{;}

\PYG{p}{\PYGZcb{}}\PYG{p}{;}


\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif }\PYG{c+c1}{//SPECIATIONCOUNTER\PYGZus{}METACOMMUNITY\PYGZus{}H}
\end{sphinxVerbatim}


\subsubsection{Detailed Description}
\label{\detokenize{api/file_necsim_Metacommunity.h:detailed-description}}
Samuel Thompson
BSD-3 Licence. Individuals will be drawn from the metacommunity for each speciation event, instead of creating a new species each time. The metacommunity itself is generated using spatially-implicit neutral simulations.
Contact: \sphinxhref{mailto:samuel.thompson14@imperial.ac.uk}{samuel.thompson14@imperial.ac.uk} or \sphinxhref{mailto:thompsonsed@gmail.com}{thompsonsed@gmail.com}


\subsubsection{Includes}
\label{\detokenize{api/file_necsim_Metacommunity.h:includes}}\begin{itemize}
\item {} 
\sphinxcode{Community.h} ({\hyperref[\detokenize{api/file_necsim_Community.h:file-necsim-community-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File Community.h}}}})

\item {} 
\sphinxcode{NRrand.h} ({\hyperref[\detokenize{api/file_necsim_NRrand.h:file-necsim-nrrand-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File NRrand.h}}}})

\item {} 
\sphinxcode{SpecSimParameters.h} ({\hyperref[\detokenize{api/file_necsim_SpecSimParameters.h:file-necsim-specsimparameters-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File SpecSimParameters.h}}}})

\item {} 
\sphinxcode{Tree.h} ({\hyperref[\detokenize{api/file_necsim_ProtractedSpatialTree.h:file-necsim-protractedspatialtree-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File ProtractedSpatialTree.h}}}})

\item {} 
\sphinxcode{set}

\item {} 
\sphinxcode{sqlite3.h}

\item {} 
\sphinxcode{string}

\end{itemize}


\subsubsection{Included By}
\label{\detokenize{api/file_necsim_Metacommunity.h:included-by}}\begin{itemize}
\item {} 
{\hyperref[\detokenize{api/file_necsim_Metacommunity.cpp:file-necsim-metacommunity-cpp}]{\sphinxcrossref{\DUrole{std,std-ref}{File Metacommunity.cpp}}}}

\end{itemize}


\subsubsection{Classes}
\label{\detokenize{api/file_necsim_Metacommunity.h:classes}}\begin{itemize}
\item {} 
{\hyperref[\detokenize{api/class_Metacommunity:class-metacommunity}]{\sphinxcrossref{\DUrole{std,std-ref}{Class Metacommunity}}}}

\end{itemize}


\subsection{File necsimmodule.cpp}
\label{\detokenize{api/file_necsimmodule.cpp:file-necsimmodule-cpp}}\label{\detokenize{api/file_necsimmodule.cpp::doc}}\label{\detokenize{api/file_necsimmodule.cpp:id1}}
Contains the functions allowing integration of the PyCoalescence python module directly to the c++.

\begin{sphinxShadowBox}
\sphinxstyletopictitle{Contents}
\begin{itemize}
\item {} 
\phantomsection\label{\detokenize{api/file_necsimmodule.cpp:id2}}{\hyperref[\detokenize{api/file_necsimmodule.cpp:definition-necsimmodule-cpp}]{\sphinxcrossref{Definition (\sphinxcode{necsimmodule.cpp})}}}

\item {} 
\phantomsection\label{\detokenize{api/file_necsimmodule.cpp:id3}}{\hyperref[\detokenize{api/file_necsimmodule.cpp:detailed-description}]{\sphinxcrossref{Detailed Description}}}

\item {} 
\phantomsection\label{\detokenize{api/file_necsimmodule.cpp:id4}}{\hyperref[\detokenize{api/file_necsimmodule.cpp:includes}]{\sphinxcrossref{Includes}}}

\item {} 
\phantomsection\label{\detokenize{api/file_necsimmodule.cpp:id5}}{\hyperref[\detokenize{api/file_necsimmodule.cpp:functions}]{\sphinxcrossref{Functions}}}

\item {} 
\phantomsection\label{\detokenize{api/file_necsimmodule.cpp:id6}}{\hyperref[\detokenize{api/file_necsimmodule.cpp:defines}]{\sphinxcrossref{Defines}}}

\item {} 
\phantomsection\label{\detokenize{api/file_necsimmodule.cpp:id7}}{\hyperref[\detokenize{api/file_necsimmodule.cpp:variables}]{\sphinxcrossref{Variables}}}

\end{itemize}
\end{sphinxShadowBox}


\subsubsection{Definition (\sphinxstyleliteralintitle{necsimmodule.cpp})}
\label{\detokenize{api/file_necsimmodule.cpp:definition-necsimmodule-cpp}}

\paragraph{Program Listing for File necsimmodule.cpp}
\label{\detokenize{api/program_listing_file_necsimmodule.cpp:program-listing-file-necsimmodule-cpp}}\label{\detokenize{api/program_listing_file_necsimmodule.cpp:program-listing-for-file-necsimmodule-cpp}}\label{\detokenize{api/program_listing_file_necsimmodule.cpp::doc}}\begin{itemize}
\item {} 
Return to documentation for {\hyperref[\detokenize{api/file_necsimmodule.cpp:file-necsimmodule-cpp}]{\sphinxcrossref{\DUrole{std,std-ref}{File necsimmodule.cpp}}}}

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{// This file is part of NECSim project which is released under BSD\PYGZhy{}3 license.}
\PYG{c+c1}{// See file **LICENSE.txt** or visit https://opensource.org/licenses/BSD\PYGZhy{}3\PYGZhy{}Clause) for full license details}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define PYTHON\PYGZus{}COMPILE}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}Python.h\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}vector\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}string\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}csignal\PYGZgt{}}

\PYG{c+c1}{// These are included here for compabilitity reasons}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZdq{}necsim/Setup.h\PYGZdq{}}
\PYG{c+c1}{// This provides compability for protracted speciation events.}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZdq{}necsimmodule.h\PYGZdq{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZdq{}PyLogging.h\PYGZdq{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZdq{}necsim/SpatialTree.h\PYGZdq{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZdq{}necsim/ProtractedTree.h\PYGZdq{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZdq{}necsim/SimulationTemplates.h\PYGZdq{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZdq{}necsim/ProtractedSpatialTree.h\PYGZdq{}}


\PYG{k}{using} \PYG{k}{namespace} \PYG{n}{std}\PYG{p}{;}
\PYG{n}{PyObject} \PYG{o}{*} \PYG{n}{loggingmodule}\PYG{p}{;}
\PYG{n}{PyGILState\PYGZus{}STATE} \PYG{n}{gstate}\PYG{p}{;}
\PYG{k+kt}{bool} \PYG{n}{log\PYGZus{}set} \PYG{o}{=} \PYG{n+nb}{false}\PYG{p}{;}
\PYG{k+kt}{bool} \PYG{n}{logger\PYGZus{}set} \PYG{o}{=} \PYG{n+nb}{false}\PYG{p}{;}
\PYG{n}{PyObject} \PYG{o}{*} \PYG{n}{logger}\PYG{p}{;}

\PYG{k}{template}\PYG{o}{\PYGZlt{}}\PYG{k}{class} \PYG{n+nc}{T}\PYG{o}{\PYGZgt{}} \PYG{k}{static} \PYG{n}{PyObject} \PYG{o}{*} \PYG{n}{run\PYGZus{}simulation}\PYG{p}{(}\PYG{n}{PyObject} \PYG{o}{*} \PYG{n}{self}\PYG{p}{,} \PYG{n}{PyObject} \PYG{o}{*} \PYG{n}{args}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k+kt}{char} \PYG{o}{*} \PYG{n}{input}\PYG{p}{;}
    \PYG{c+c1}{// parse arguments}
    \PYG{k}{if}\PYG{p}{(}\PYG{o}{!}\PYG{n}{PyArg\PYGZus{}ParseTuple}\PYG{p}{(}\PYG{n}{args}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{s}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{input}\PYG{p}{)}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{return} \PYG{n+nb}{NULL}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{c+c1}{// Run the main simulation}
    \PYG{c+c1}{// Mimic a command\PYGZhy{}line simulation call}
    \PYG{k}{const} \PYG{n}{string} \PYG{o}{\PYGZam{}}\PYG{n}{config\PYGZus{}file} \PYG{o}{=} \PYG{n}{input}\PYG{p}{;}
    \PYG{k+kt}{int} \PYG{n}{ret} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
    \PYG{c+c1}{// Check that the logging function has been set}
    \PYG{k}{if}\PYG{p}{(}\PYG{o}{!}\PYG{n}{log\PYGZus{}set}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{PyErr\PYGZus{}SetString}\PYG{p}{(}\PYG{n}{NECSimError}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Logging function has not been set. Make sure set\PYGZus{}logging\PYGZus{}function() has been called}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{return} \PYG{n+nb}{NULL}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{if}\PYG{p}{(}\PYG{o}{!}\PYG{n}{logger\PYGZus{}set}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{PyErr\PYGZus{}SetString}\PYG{p}{(}\PYG{n}{NECSimError}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Logger object has not been set. Make sure set\PYGZus{}logger() has been called}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{return} \PYG{n+nb}{NULL}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{c+c1}{// Run the program, catch and return any errors.}
    \PYG{k}{try}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{Py\PYGZus{}INCREF}\PYG{p}{(}\PYG{n}{logger}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{runMain}\PYG{o}{\PYGZlt{}}\PYG{n}{T}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{n}{config\PYGZus{}file}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{Py\PYGZus{}DECREF}\PYG{p}{(}\PYG{n}{logger}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{catch}\PYG{p}{(}\PYG{n}{exception} \PYG{o}{\PYGZam{}}\PYG{n}{e}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{Py\PYGZus{}DECREF}\PYG{p}{(}\PYG{n}{logger}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{PyErr\PYGZus{}SetString}\PYG{p}{(}\PYG{n}{NECSimError}\PYG{p}{,} \PYG{n}{e}\PYG{p}{.}\PYG{n}{what}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{return} \PYG{n+nb}{NULL}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{n}{PyObject} \PYG{o}{*} \PYG{n}{pyret}\PYG{p}{;}
    \PYG{n}{pyret} \PYG{o}{=} \PYG{n}{PyLong\PYGZus{}FromLong}\PYG{p}{(}\PYG{n}{ret}\PYG{p}{)}\PYG{p}{;}
    \PYG{k}{return} \PYG{n}{pyret}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k}{template}\PYG{o}{\PYGZlt{}}\PYG{k}{class} \PYG{n+nc}{T}\PYG{o}{\PYGZgt{}} \PYG{k}{static} \PYG{n}{PyObject} \PYG{o}{*} \PYG{n}{resume\PYGZus{}simulation}\PYG{p}{(}\PYG{n}{PyObject} \PYG{o}{*} \PYG{n}{self}\PYG{p}{,} \PYG{n}{PyObject} \PYG{o}{*} \PYG{n}{args}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k+kt}{char} \PYG{o}{*} \PYG{n}{pause\PYGZus{}directory}\PYG{p}{;}
    \PYG{k+kt}{char}\PYG{o}{*} \PYG{n}{out\PYGZus{}directory}\PYG{p}{;}
    \PYG{k+kt}{int} \PYG{n}{size1}\PYG{p}{,} \PYG{n}{size2}\PYG{p}{,} \PYG{n}{seed}\PYG{p}{,} \PYG{n}{task}\PYG{p}{,} \PYG{n}{max\PYGZus{}time}\PYG{p}{;}
    \PYG{c+c1}{// parse arguments}
    \PYG{k}{if}\PYG{p}{(}\PYG{o}{!}\PYG{n}{PyArg\PYGZus{}ParseTuple}\PYG{p}{(}\PYG{n}{args}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ssiii}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{pause\PYGZus{}directory}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{out\PYGZus{}directory}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{seed}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{task}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{max\PYGZus{}time}\PYG{p}{)}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{return} \PYG{n+nb}{NULL}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{if}\PYG{p}{(}\PYG{o}{!}\PYG{n}{log\PYGZus{}set}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{PyErr\PYGZus{}SetString}\PYG{p}{(}\PYG{n}{NECSimError}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Logging function has not been set. Make sure set\PYGZus{}logging\PYGZus{}function() has been called}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{return} \PYG{n+nb}{NULL}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{if}\PYG{p}{(}\PYG{o}{!}\PYG{n}{logger\PYGZus{}set}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{PyErr\PYGZus{}SetString}\PYG{p}{(}\PYG{n}{NECSimError}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Logger object has not been set. Make sure set\PYGZus{}logger() has been called}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{return} \PYG{n+nb}{NULL}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{c+c1}{// Run the main simulation}
    \PYG{k+kt}{int} \PYG{n}{ret} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
    \PYG{c+c1}{// Run the program, catch and return any errors.}
    \PYG{n}{string} \PYG{n}{pause\PYGZus{}directory\PYGZus{}str}\PYG{p}{,} \PYG{n}{out\PYGZus{}directory\PYGZus{}str}\PYG{p}{;}
    \PYG{n}{pause\PYGZus{}directory\PYGZus{}str} \PYG{o}{=} \PYG{n}{pause\PYGZus{}directory}\PYG{p}{;}
    \PYG{n}{out\PYGZus{}directory\PYGZus{}str} \PYG{o}{=} \PYG{n}{out\PYGZus{}directory}\PYG{p}{;}
    \PYG{k+kt}{bool} \PYG{n}{sim\PYGZus{}complete} \PYG{o}{=} \PYG{n+nb}{false}\PYG{p}{;}
    \PYG{k}{try}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{Py\PYGZus{}INCREF}\PYG{p}{(}\PYG{n}{logger}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{T} \PYG{n}{t}\PYG{p}{;}
        \PYG{n}{t}\PYG{p}{.}\PYG{n}{setResumeParameters}\PYG{p}{(}\PYG{n}{pause\PYGZus{}directory\PYGZus{}str}\PYG{p}{,} \PYG{n}{out\PYGZus{}directory\PYGZus{}str}\PYG{p}{,} \PYG{n}{seed}\PYG{p}{,} \PYG{n}{task}\PYG{p}{,} \PYG{n}{max\PYGZus{}time}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{t}\PYG{p}{.}\PYG{n}{checkSims}\PYG{p}{(}\PYG{n}{pause\PYGZus{}directory\PYGZus{}str}\PYG{p}{,} \PYG{n}{seed}\PYG{p}{,} \PYG{n}{task}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{t}\PYG{p}{.}\PYG{n}{hasPaused}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{t}\PYG{p}{.}\PYG{n}{setup}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
            \PYG{n}{sim\PYGZus{}complete} \PYG{o}{=} \PYG{n}{t}\PYG{p}{.}\PYG{n}{runSimulation}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
            \PYG{k}{if}\PYG{p}{(}\PYG{n}{sim\PYGZus{}complete}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{n}{t}\PYG{p}{.}\PYG{n}{applyMultipleRates}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{else}
        \PYG{p}{\PYGZob{}}
            \PYG{k}{throw} \PYG{n}{runtime\PYGZus{}error}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Couldn\PYGZsq{}t find paused simulation}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{n}{Py\PYGZus{}DECREF}\PYG{p}{(}\PYG{n}{logger}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{sim\PYGZus{}complete}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{Py\PYGZus{}RETURN\PYGZus{}TRUE}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{else}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{Py\PYGZus{}RETURN\PYGZus{}FALSE}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{catch}\PYG{p}{(}\PYG{n}{exception} \PYG{o}{\PYGZam{}}\PYG{n}{e}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{Py\PYGZus{}DECREF}\PYG{p}{(}\PYG{n}{logger}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{PyErr\PYGZus{}SetString}\PYG{p}{(}\PYG{n}{NECSimError}\PYG{p}{,} \PYG{n}{e}\PYG{p}{.}\PYG{n}{what}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{return} \PYG{n+nb}{NULL}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}

\PYG{k}{static} \PYG{n}{PyMethodDef} \PYG{n}{NECSimMethods}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=}
\PYG{p}{\PYGZob{}}
    \PYG{p}{\PYGZob{}}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{run\PYGZus{}spatial}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{run\PYGZus{}simulation}\PYG{o}{\PYGZlt{}}\PYG{n}{SpatialTree}\PYG{o}{\PYGZgt{}}\PYG{p}{,} \PYG{n}{METH\PYGZus{}VARARGS}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Runs the simulation from the provided config file.}\PYG{l+s}{\PYGZdq{}}\PYG{p}{\PYGZcb{}}\PYG{p}{,}
    \PYG{p}{\PYGZob{}}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{run\PYGZus{}spatial\PYGZus{}protracted}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{run\PYGZus{}simulation}\PYG{o}{\PYGZlt{}}\PYG{n}{ProtractedSpatialTree}\PYG{o}{\PYGZgt{}}\PYG{p}{,} \PYG{n}{METH\PYGZus{}VARARGS}\PYG{p}{,}
            \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Runs the protracted simulation from the provided config file.}\PYG{l+s}{\PYGZdq{}}\PYG{p}{\PYGZcb{}}\PYG{p}{,}
    \PYG{p}{\PYGZob{}}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{run\PYGZus{}NSE}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{run\PYGZus{}simulation}\PYG{o}{\PYGZlt{}}\PYG{n}{Tree}\PYG{o}{\PYGZgt{}}\PYG{p}{,} \PYG{n}{METH\PYGZus{}VARARGS}\PYG{p}{,}
            \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Runs the non\PYGZhy{}spatially explicit neutral model from the provided config file.}\PYG{l+s}{\PYGZdq{}}\PYG{p}{\PYGZcb{}}\PYG{p}{,}
    \PYG{p}{\PYGZob{}}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{run\PYGZus{}NSE\PYGZus{}protracted}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{run\PYGZus{}simulation}\PYG{o}{\PYGZlt{}}\PYG{n}{ProtractedTree}\PYG{o}{\PYGZgt{}}\PYG{p}{,} \PYG{n}{METH\PYGZus{}VARARGS}\PYG{p}{,}
            \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Runs the non\PYGZhy{}spatially explicit protracted neutral model from the provided config file.}\PYG{l+s}{\PYGZdq{}}\PYG{p}{\PYGZcb{}}\PYG{p}{,}
    \PYG{p}{\PYGZob{}}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{set\PYGZus{}log\PYGZus{}function}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{set\PYGZus{}log\PYGZus{}function}\PYG{p}{,} \PYG{n}{METH\PYGZus{}VARARGS}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{calls logging}\PYG{l+s}{\PYGZdq{}}\PYG{p}{\PYGZcb{}}\PYG{p}{,}
    \PYG{p}{\PYGZob{}}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{set\PYGZus{}logger}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{set\PYGZus{}logger}\PYG{p}{,} \PYG{n}{METH\PYGZus{}VARARGS}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Sets the logger to use}\PYG{l+s}{\PYGZdq{}}\PYG{p}{\PYGZcb{}}\PYG{p}{,}
    \PYG{p}{\PYGZob{}}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{resume\PYGZus{}spatial}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{resume\PYGZus{}simulation}\PYG{o}{\PYGZlt{}}\PYG{n}{SpatialTree}\PYG{o}{\PYGZgt{}}\PYG{p}{,} \PYG{n}{METH\PYGZus{}VARARGS}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Resumes the simulation with the given parameters.}\PYG{l+s}{\PYGZdq{}}\PYG{p}{\PYGZcb{}}\PYG{p}{,}
    \PYG{p}{\PYGZob{}}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{resume\PYGZus{}spatial\PYGZus{}protracted}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{resume\PYGZus{}simulation}\PYG{o}{\PYGZlt{}}\PYG{n}{ProtractedSpatialTree}\PYG{o}{\PYGZgt{}}\PYG{p}{,} \PYG{n}{METH\PYGZus{}VARARGS}\PYG{p}{,}
            \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Resumes the protracted simulation with the given parameters.}\PYG{l+s}{\PYGZdq{}}\PYG{p}{\PYGZcb{}}\PYG{p}{,}
    \PYG{p}{\PYGZob{}}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{resume\PYGZus{}NSE}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{resume\PYGZus{}simulation}\PYG{o}{\PYGZlt{}}\PYG{n}{Tree}\PYG{o}{\PYGZgt{}}\PYG{p}{,} \PYG{n}{METH\PYGZus{}VARARGS}\PYG{p}{,}
            \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Resumes the non\PYGZhy{}spatially explicit simulation with the given parameters}\PYG{l+s}{\PYGZdq{}}\PYG{p}{\PYGZcb{}}\PYG{p}{,}
    \PYG{p}{\PYGZob{}}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{resume\PYGZus{}NSE\PYGZus{}protracted}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{resume\PYGZus{}simulation}\PYG{o}{\PYGZlt{}}\PYG{n}{ProtractedTree}\PYG{o}{\PYGZgt{}}\PYG{p}{,} \PYG{n}{METH\PYGZus{}VARARGS}\PYG{p}{,}
            \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Resumes the non\PYGZhy{}spatially explicit protracted simulation with the given parameters}\PYG{l+s}{\PYGZdq{}}\PYG{p}{\PYGZcb{}}\PYG{p}{,}
    \PYG{p}{\PYGZob{}}\PYG{n+nb}{NULL}\PYG{p}{,} \PYG{n+nb}{NULL}\PYG{p}{,} \PYG{l+m+mi}{0} \PYG{p}{,} \PYG{n+nb}{NULL}\PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}

\PYG{c+c1}{// Conditional compilation for python \PYGZgt{}= 3.0 (changed how python integration worked)}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{if PY\PYGZus{}MAJOR\PYGZus{}VERSION \PYGZgt{}= 3}
\PYG{k}{static} \PYG{k+kt}{int} \PYG{n+nf}{necsim\PYGZus{}traverse}\PYG{p}{(}\PYG{n}{PyObject} \PYG{o}{*}\PYG{n}{m}\PYG{p}{,} \PYG{n}{visitproc} \PYG{n}{visit}\PYG{p}{,} \PYG{k+kt}{void} \PYG{o}{*}\PYG{n}{arg}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{n}{Py\PYGZus{}VISIT}\PYG{p}{(}\PYG{n}{GETSTATE}\PYG{p}{(}\PYG{n}{m}\PYG{p}{)}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{error}\PYG{p}{)}\PYG{p}{;}
    \PYG{k}{return} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k}{static} \PYG{k+kt}{int} \PYG{n+nf}{necsim\PYGZus{}clear}\PYG{p}{(}\PYG{n}{PyObject} \PYG{o}{*}\PYG{n}{m}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{n}{Py\PYGZus{}CLEAR}\PYG{p}{(}\PYG{n}{GETSTATE}\PYG{p}{(}\PYG{n}{m}\PYG{p}{)}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{error}\PYG{p}{)}\PYG{p}{;}
    \PYG{k}{return} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif}


\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{if PY\PYGZus{}MAJOR\PYGZus{}VERSION \PYGZgt{}= 3}
\PYG{k}{static} \PYG{k}{struct} \PYG{n}{PyModuleDef} \PYG{n}{moduledef} \PYG{o}{=}
\PYG{p}{\PYGZob{}}
    \PYG{n}{PyModuleDef\PYGZus{}HEAD\PYGZus{}INIT}\PYG{p}{,}
    \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{necsimmodule}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}
    \PYG{n+nb}{NULL}\PYG{p}{,}
    \PYG{k}{sizeof}\PYG{p}{(}\PYG{k}{struct} \PYG{n}{module\PYGZus{}state}\PYG{p}{)}\PYG{p}{,}
    \PYG{n}{NECSimMethods}\PYG{p}{,}
    \PYG{n+nb}{NULL}\PYG{p}{,}
    \PYG{n}{necsim\PYGZus{}traverse}\PYG{p}{,}
    \PYG{n}{necsim\PYGZus{}clear}\PYG{p}{,}
    \PYG{n+nb}{NULL}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}


\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define INITERROR return NULL}

\PYG{n}{PyMODINIT\PYGZus{}FUNC}
\PYG{n+nf}{PyInit\PYGZus{}necsimmodule}\PYG{p}{(}\PYG{k+kt}{void}\PYG{p}{)}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{else}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define INITERROR return}

\PYG{n}{PyMODINIT\PYGZus{}FUNC}
\PYG{n}{initnecsimmodule}\PYG{p}{(}\PYG{k+kt}{void}\PYG{p}{)}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif}
\PYG{p}{\PYGZob{}}
    \PYG{n}{PyObject} \PYG{o}{*}\PYG{n}{module}\PYG{p}{;}
    \PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{if PY\PYGZus{}MAJOR\PYGZus{}VERSION\PYGZgt{}=3}
    \PYG{n}{module} \PYG{o}{=} \PYG{n}{PyModule\PYGZus{}Create}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{moduledef}\PYG{p}{)}\PYG{p}{;}
    \PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{else}
    \PYG{n}{module} \PYG{o}{=} \PYG{n}{Py\PYGZus{}InitModule}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{necsimmodule}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{NECSimMethods}\PYG{p}{)}\PYG{p}{;}
    \PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif}
    \PYG{k}{if}\PYG{p}{(}\PYG{n}{module} \PYG{o}{=}\PYG{o}{=} \PYG{n+nb}{NULL}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{INITERROR}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{c+c1}{// Threading support}
    \PYG{k}{if}\PYG{p}{(}\PYG{o}{!}\PYG{n}{PyEval\PYGZus{}ThreadsInitialized}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{PyEval\PYGZus{}InitThreads}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

    \PYG{p}{\PYGZcb{}}
    \PYG{n}{NECSimError} \PYG{o}{=} \PYG{n}{PyErr\PYGZus{}NewException}\PYG{p}{(}\PYG{p}{(}\PYG{k+kt}{char}\PYG{o}{*}\PYG{p}{)}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{necsimmodule.NECSimError}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n+nb}{NULL}\PYG{p}{,} \PYG{n+nb}{NULL}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{Py\PYGZus{}INCREF}\PYG{p}{(}\PYG{n}{NECSimError}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{PyModule\PYGZus{}AddObject}\PYG{p}{(}\PYG{n}{module}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{NECSimError}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{NECSimError}\PYG{p}{)}\PYG{p}{;}
    \PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{if PY\PYGZus{}MAJOR\PYGZus{}VERSION \PYGZgt{}= 3}
    \PYG{k}{return} \PYG{n}{module}\PYG{p}{;}
    \PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}


\subsubsection{Detailed Description}
\label{\detokenize{api/file_necsimmodule.cpp:detailed-description}}
Samuel Thompson
BSD-3 Licence.


\subsubsection{Includes}
\label{\detokenize{api/file_necsimmodule.cpp:includes}}\begin{itemize}
\item {} 
\sphinxcode{/Users/samthompson/Documents/PhD/Code/pycoalescence/pycoalescence/lib/necsim/Community.h}

\item {} 
\sphinxcode{/Users/samthompson/Documents/PhD/Code/pycoalescence/pycoalescence/lib/necsim/CustomExceptions.h}

\item {} 
\sphinxcode{/Users/samthompson/Documents/PhD/Code/pycoalescence/pycoalescence/lib/necsim/DataMask.h}

\item {} 
\sphinxcode{/Users/samthompson/Documents/PhD/Code/pycoalescence/pycoalescence/lib/necsim/DataPoint.h}

\item {} 
\sphinxcode{/Users/samthompson/Documents/PhD/Code/pycoalescence/pycoalescence/lib/necsim/DispersalCoordinator.h}

\item {} 
\sphinxcode{/Users/samthompson/Documents/PhD/Code/pycoalescence/pycoalescence/lib/necsim/Logging.h}

\item {} 
\sphinxcode{/Users/samthompson/Documents/PhD/Code/pycoalescence/pycoalescence/lib/necsim/Map.h}

\item {} 
\sphinxcode{/Users/samthompson/Documents/PhD/Code/pycoalescence/pycoalescence/lib/necsim/Matrix.h}

\item {} 
\sphinxcode{/Users/samthompson/Documents/PhD/Code/pycoalescence/pycoalescence/lib/necsim/NRrand.h}

\item {} 
\sphinxcode{/Users/samthompson/Documents/PhD/Code/pycoalescence/pycoalescence/lib/necsim/ProtractedTree.h}

\item {} 
\sphinxcode{/Users/samthompson/Documents/PhD/Code/pycoalescence/pycoalescence/lib/necsim/ReproductionMap.h}

\item {} 
\sphinxcode{/Users/samthompson/Documents/PhD/Code/pycoalescence/pycoalescence/lib/necsim/Setup.h}

\item {} 
\sphinxcode{/Users/samthompson/Documents/PhD/Code/pycoalescence/pycoalescence/lib/necsim/SimParameters.h}

\item {} 
\sphinxcode{/Users/samthompson/Documents/PhD/Code/pycoalescence/pycoalescence/lib/necsim/SpatialTree.h}

\item {} 
\sphinxcode{/Users/samthompson/Documents/PhD/Code/pycoalescence/pycoalescence/lib/necsim/SpeciesList.h}

\item {} 
\sphinxcode{/Users/samthompson/Documents/PhD/Code/pycoalescence/pycoalescence/lib/necsim/Step.h}

\item {} 
\sphinxcode{/Users/samthompson/Documents/PhD/Code/pycoalescence/pycoalescence/lib/necsim/Tree.h}

\item {} 
\sphinxcode{/Users/samthompson/Documents/PhD/Code/pycoalescence/pycoalescence/lib/necsim/TreeNode.h}

\item {} 
\sphinxcode{PyLogging.h} ({\hyperref[\detokenize{api/file_PyLogging.h:file-pylogging-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File PyLogging.h}}}})

\item {} 
\sphinxcode{Python.h}

\item {} 
\sphinxcode{algorithm}

\item {} 
\sphinxcode{boost/filesystem.hpp}

\item {} 
\sphinxcode{cmath}

\item {} 
\sphinxcode{csignal}

\item {} 
\sphinxcode{cstdio}

\item {} 
\sphinxcode{cstring}

\item {} 
\sphinxcode{ctime}

\item {} 
\sphinxcode{fstream}

\item {} 
\sphinxcode{iomanip}

\item {} 
\sphinxcode{iostream}

\item {} 
\sphinxcode{math.h}

\item {} 
\sphinxcode{necsim/ProtractedSpatialTree.h} ({\hyperref[\detokenize{api/file_necsim_ProtractedSpatialTree.h:file-necsim-protractedspatialtree-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File ProtractedSpatialTree.h}}}})

\item {} 
\sphinxcode{necsim/ProtractedTree.h} ({\hyperref[\detokenize{api/file_necsim_ProtractedTree.h:file-necsim-protractedtree-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File ProtractedTree.h}}}})

\item {} 
\sphinxcode{necsim/Setup.h} ({\hyperref[\detokenize{api/file_necsim_Setup.h:file-necsim-setup-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File Setup.h}}}})

\item {} 
\sphinxcode{necsim/SimulationTemplates.h} ({\hyperref[\detokenize{api/file_necsim_SimulationTemplates.h:file-necsim-simulationtemplates-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File SimulationTemplates.h}}}})

\item {} 
\sphinxcode{necsim/SpatialTree.h} ({\hyperref[\detokenize{api/file_necsim_SpatialTree.h:file-necsim-spatialtree-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File SpatialTree.h}}}})

\item {} 
\sphinxcode{necsimmodule.h} ({\hyperref[\detokenize{api/file_necsimmodule.h:file-necsimmodule-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File necsimmodule.h}}}})

\item {} 
\sphinxcode{sqlite3.h}

\item {} 
\sphinxcode{sstream}

\item {} 
\sphinxcode{stdexcept}

\item {} 
\sphinxcode{stdio.h}

\item {} 
\sphinxcode{string}

\item {} 
\sphinxcode{unistd.h}

\item {} 
\sphinxcode{vector}

\end{itemize}


\subsubsection{Functions}
\label{\detokenize{api/file_necsimmodule.cpp:functions}}\begin{itemize}
\item {} 
{\hyperref[\detokenize{api/function_initnecsimmodule:function-initnecsimmodule}]{\sphinxcrossref{\DUrole{std,std-ref}{Function initnecsimmodule}}}}

\item {} 
{\hyperref[\detokenize{api/function_resume_simulation:function-resume-simulation}]{\sphinxcrossref{\DUrole{std,std-ref}{Function resume\_simulation}}}}

\item {} 
{\hyperref[\detokenize{api/function_run_simulation:function-run-simulation}]{\sphinxcrossref{\DUrole{std,std-ref}{Function run\_simulation}}}}

\end{itemize}


\subsubsection{Defines}
\label{\detokenize{api/file_necsimmodule.cpp:defines}}\begin{itemize}
\item {} 
{\hyperref[\detokenize{api/define_INITERROR:define-initerror}]{\sphinxcrossref{\DUrole{std,std-ref}{Define INITERROR}}}}

\item {} 
{\hyperref[\detokenize{api/define_PYTHON_COMPILE:define-python-compile}]{\sphinxcrossref{\DUrole{std,std-ref}{Define PYTHON\_COMPILE}}}}

\end{itemize}


\subsubsection{Variables}
\label{\detokenize{api/file_necsimmodule.cpp:variables}}\begin{itemize}
\item {} 
{\hyperref[\detokenize{api/variable_gstate:variable-gstate}]{\sphinxcrossref{\DUrole{std,std-ref}{Variable gstate}}}}

\item {} 
{\hyperref[\detokenize{api/variable_log_set:variable-log-set}]{\sphinxcrossref{\DUrole{std,std-ref}{Variable log\_set}}}}

\item {} 
{\hyperref[\detokenize{api/variable_logger:variable-logger}]{\sphinxcrossref{\DUrole{std,std-ref}{Variable logger}}}}

\item {} 
{\hyperref[\detokenize{api/variable_logger_set:variable-logger-set}]{\sphinxcrossref{\DUrole{std,std-ref}{Variable logger\_set}}}}

\item {} 
{\hyperref[\detokenize{api/variable_loggingmodule:variable-loggingmodule}]{\sphinxcrossref{\DUrole{std,std-ref}{Variable loggingmodule}}}}

\item {} 
{\hyperref[\detokenize{api/variable_NECSimMethods:variable-necsimmethods}]{\sphinxcrossref{\DUrole{std,std-ref}{Variable NECSimMethods}}}}

\end{itemize}


\subsection{File necsimmodule.h}
\label{\detokenize{api/file_necsimmodule.h:file-necsimmodule-h}}\label{\detokenize{api/file_necsimmodule.h::doc}}\label{\detokenize{api/file_necsimmodule.h:id1}}
Contains the functions allowing integration of the PyCoalescence python module directly to the c++.

\begin{sphinxShadowBox}
\sphinxstyletopictitle{Contents}
\begin{itemize}
\item {} 
\phantomsection\label{\detokenize{api/file_necsimmodule.h:id2}}{\hyperref[\detokenize{api/file_necsimmodule.h:definition-necsimmodule-h}]{\sphinxcrossref{Definition (\sphinxcode{necsimmodule.h})}}}

\item {} 
\phantomsection\label{\detokenize{api/file_necsimmodule.h:id3}}{\hyperref[\detokenize{api/file_necsimmodule.h:detailed-description}]{\sphinxcrossref{Detailed Description}}}

\item {} 
\phantomsection\label{\detokenize{api/file_necsimmodule.h:id4}}{\hyperref[\detokenize{api/file_necsimmodule.h:includes}]{\sphinxcrossref{Includes}}}

\item {} 
\phantomsection\label{\detokenize{api/file_necsimmodule.h:id5}}{\hyperref[\detokenize{api/file_necsimmodule.h:included-by}]{\sphinxcrossref{Included By}}}

\item {} 
\phantomsection\label{\detokenize{api/file_necsimmodule.h:id6}}{\hyperref[\detokenize{api/file_necsimmodule.h:classes}]{\sphinxcrossref{Classes}}}

\item {} 
\phantomsection\label{\detokenize{api/file_necsimmodule.h:id7}}{\hyperref[\detokenize{api/file_necsimmodule.h:functions}]{\sphinxcrossref{Functions}}}

\item {} 
\phantomsection\label{\detokenize{api/file_necsimmodule.h:id8}}{\hyperref[\detokenize{api/file_necsimmodule.h:defines}]{\sphinxcrossref{Defines}}}

\item {} 
\phantomsection\label{\detokenize{api/file_necsimmodule.h:id9}}{\hyperref[\detokenize{api/file_necsimmodule.h:variables}]{\sphinxcrossref{Variables}}}

\end{itemize}
\end{sphinxShadowBox}


\subsubsection{Definition (\sphinxstyleliteralintitle{necsimmodule.h})}
\label{\detokenize{api/file_necsimmodule.h:definition-necsimmodule-h}}

\paragraph{Program Listing for File necsimmodule.h}
\label{\detokenize{api/program_listing_file_necsimmodule.h:program-listing-file-necsimmodule-h}}\label{\detokenize{api/program_listing_file_necsimmodule.h::doc}}\label{\detokenize{api/program_listing_file_necsimmodule.h:program-listing-for-file-necsimmodule-h}}\begin{itemize}
\item {} 
Return to documentation for {\hyperref[\detokenize{api/file_necsimmodule.h:file-necsimmodule-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File necsimmodule.h}}}}

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{// This file is part of NECSim project which is released under BSD\PYGZhy{}3 license.}
\PYG{c+c1}{// See file **LICENSE.txt** or visit https://opensource.org/licenses/BSD\PYGZhy{}3\PYGZhy{}Clause) for full license details}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}Python.h\PYGZgt{}}

\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}vector\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}string\PYGZgt{}}


\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifndef NECSIM\PYGZus{}IMPORT}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define NECSIM\PYGZus{}IMPORT}
\PYG{k}{using} \PYG{k}{namespace} \PYG{n}{std}\PYG{p}{;}
\PYG{k}{struct} \PYG{n}{module\PYGZus{}state}
\PYG{p}{\PYGZob{}}
    \PYG{n}{PyObject} \PYG{o}{*}\PYG{n}{error}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}

\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{if PY\PYGZus{}MAJOR\PYGZus{}VERSION \PYGZgt{}= 3}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define GETSTATE(m) ((struct module\PYGZus{}state*)PyModule\PYGZus{}GetState(m))}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{else}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define GETSTATE(m) (\PYGZam{}\PYGZus{}state)}
\PYG{k}{static} \PYG{k}{struct} \PYG{n}{module\PYGZus{}state} \PYG{n}{\PYGZus{}state}\PYG{p}{;}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif}

\PYG{k}{static} \PYG{n}{PyObject} \PYG{o}{*}\PYG{n}{NECSimError}\PYG{p}{;}


\PYG{c+c1}{// Conditional compilation for python \PYGZgt{}= 3.0 (changed how python integration worked)}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{if PY\PYGZus{}MAJOR\PYGZus{}VERSION \PYGZgt{}= 3}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define INITERROR return NULL}

\PYG{n}{PyMODINIT\PYGZus{}FUNC}
\PYG{n+nf}{PyInit\PYGZus{}necsimmodule}\PYG{p}{(}\PYG{k+kt}{void}\PYG{p}{)}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{else}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define INITERROR return}

\PYG{n}{PyMODINIT\PYGZus{}FUNC}
\PYG{n}{initnecsimmodule}\PYG{p}{(}\PYG{k+kt}{void}\PYG{p}{)}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif}
\PYG{p}{;}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif}
\end{sphinxVerbatim}


\subsubsection{Detailed Description}
\label{\detokenize{api/file_necsimmodule.h:detailed-description}}
Samuel Thompson
BSD-3 Licence.


\subsubsection{Includes}
\label{\detokenize{api/file_necsimmodule.h:includes}}\begin{itemize}
\item {} 
\sphinxcode{Python.h}

\item {} 
\sphinxcode{string}

\item {} 
\sphinxcode{vector}

\end{itemize}


\subsubsection{Included By}
\label{\detokenize{api/file_necsimmodule.h:included-by}}\begin{itemize}
\item {} 
{\hyperref[\detokenize{api/file_necsimmodule.cpp:file-necsimmodule-cpp}]{\sphinxcrossref{\DUrole{std,std-ref}{File necsimmodule.cpp}}}}

\end{itemize}


\subsubsection{Classes}
\label{\detokenize{api/file_necsimmodule.h:classes}}\begin{itemize}
\item {} 
{\hyperref[\detokenize{api/struct_module_state:struct-module-state}]{\sphinxcrossref{\DUrole{std,std-ref}{Struct module\_state}}}}

\end{itemize}


\subsubsection{Functions}
\label{\detokenize{api/file_necsimmodule.h:functions}}\begin{itemize}
\item {} 
{\hyperref[\detokenize{api/function_initnecsimmodule:function-initnecsimmodule}]{\sphinxcrossref{\DUrole{std,std-ref}{Function initnecsimmodule}}}}

\end{itemize}


\subsubsection{Defines}
\label{\detokenize{api/file_necsimmodule.h:defines}}\begin{itemize}
\item {} 
{\hyperref[\detokenize{api/define_GETSTATE:define-getstate}]{\sphinxcrossref{\DUrole{std,std-ref}{Define GETSTATE}}}}

\item {} 
{\hyperref[\detokenize{api/define_INITERROR:define-initerror}]{\sphinxcrossref{\DUrole{std,std-ref}{Define INITERROR}}}}

\end{itemize}


\subsubsection{Variables}
\label{\detokenize{api/file_necsimmodule.h:variables}}\begin{itemize}
\item {} 
{\hyperref[\detokenize{api/variable__state:variable-state}]{\sphinxcrossref{\DUrole{std,std-ref}{Variable \_state}}}}

\item {} 
{\hyperref[\detokenize{api/variable_NECSimError:variable-necsimerror}]{\sphinxcrossref{\DUrole{std,std-ref}{Variable NECSimError}}}}

\end{itemize}


\subsection{File NRrand.h}
\label{\detokenize{api/file_necsim_NRrand.h:file-nrrand-h}}\label{\detokenize{api/file_necsim_NRrand.h::doc}}\label{\detokenize{api/file_necsim_NRrand.h:file-necsim-nrrand-h}}
Contains a generic random number generator. Provided by James Rosindell (\sphinxhref{mailto:j.rosindell@imperial.ac.uk}{j.rosindell@imperial.ac.uk}) with moderate modifications by Samuel Thompson (\sphinxhref{mailto:thomsonsed@gmail.com}{thomsonsed@gmail.com}).

\begin{sphinxShadowBox}
\sphinxstyletopictitle{Contents}
\begin{itemize}
\item {} 
\phantomsection\label{\detokenize{api/file_necsim_NRrand.h:id1}}{\hyperref[\detokenize{api/file_necsim_NRrand.h:definition-necsim-nrrand-h}]{\sphinxcrossref{Definition (\sphinxcode{necsim/NRrand.h})}}}

\item {} 
\phantomsection\label{\detokenize{api/file_necsim_NRrand.h:id2}}{\hyperref[\detokenize{api/file_necsim_NRrand.h:detailed-description}]{\sphinxcrossref{Detailed Description}}}

\item {} 
\phantomsection\label{\detokenize{api/file_necsim_NRrand.h:id3}}{\hyperref[\detokenize{api/file_necsim_NRrand.h:includes}]{\sphinxcrossref{Includes}}}

\item {} 
\phantomsection\label{\detokenize{api/file_necsim_NRrand.h:id4}}{\hyperref[\detokenize{api/file_necsim_NRrand.h:included-by}]{\sphinxcrossref{Included By}}}

\item {} 
\phantomsection\label{\detokenize{api/file_necsim_NRrand.h:id5}}{\hyperref[\detokenize{api/file_necsim_NRrand.h:classes}]{\sphinxcrossref{Classes}}}

\item {} 
\phantomsection\label{\detokenize{api/file_necsim_NRrand.h:id6}}{\hyperref[\detokenize{api/file_necsim_NRrand.h:defines}]{\sphinxcrossref{Defines}}}

\end{itemize}
\end{sphinxShadowBox}


\subsubsection{Definition (\sphinxstyleliteralintitle{necsim/NRrand.h})}
\label{\detokenize{api/file_necsim_NRrand.h:definition-necsim-nrrand-h}}

\paragraph{Program Listing for File NRrand.h}
\label{\detokenize{api/program_listing_file_necsim_NRrand.h:program-listing-for-file-nrrand-h}}\label{\detokenize{api/program_listing_file_necsim_NRrand.h::doc}}\label{\detokenize{api/program_listing_file_necsim_NRrand.h:program-listing-file-necsim-nrrand-h}}\begin{itemize}
\item {} 
Return to documentation for {\hyperref[\detokenize{api/file_necsim_NRrand.h:file-necsim-nrrand-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File NRrand.h}}}}

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{//This file is part of NECSim project which is released under BSD\PYGZhy{}3 license.}
\PYG{c+c1}{//See file **LICENSE.txt** or visit https://opensource.org/licenses/BSD\PYGZhy{}3\PYGZhy{}Clause) for full license details.}

\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifndef FATTAIL\PYGZus{}H}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define FATTAIL\PYGZus{}H}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define IM1 2147483563}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define IM2 2147483399}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define AM (1.0}\PYG{c+cp}{/}\PYG{c+cp}{IM1)}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define IMM1 (IM1\PYGZhy{}1)}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define IA1 40014}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define IA2 40692}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define IQ1 53668}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define IQ2 5277}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define IR1 12211}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define IR2 3791}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define NTAB 32}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define NDIV (1+IMM1}\PYG{c+cp}{/}\PYG{c+cp}{NTAB)}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define EPS 1.2e\PYGZhy{}8}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define RNMX (1.0\PYGZhy{}EPS)}

\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ include \PYGZlt{}cstdio\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ include \PYGZlt{}string\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ include \PYGZlt{}iomanip\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ include \PYGZlt{}cmath\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ include \PYGZlt{}vector\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ include \PYGZlt{}iostream\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ include \PYGZlt{}fstream\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}climits\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZdq{}Logging.h\PYGZdq{}}

\PYG{k}{using} \PYG{k}{namespace} \PYG{n}{std}\PYG{p}{;}

\PYG{k}{class} \PYG{n+nc}{NRrand}
\PYG{p}{\PYGZob{}}

\PYG{k}{private}\PYG{o}{:}
    \PYG{k+kt}{long} \PYG{n}{idum}\PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
    \PYG{k+kt}{int} \PYG{n}{j}\PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
    \PYG{k+kt}{long} \PYG{n}{k}\PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
    \PYG{k+kt}{long} \PYG{n}{idum2}\PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
    \PYG{k+kt}{long} \PYG{n}{iy}\PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
    \PYG{k+kt}{long} \PYG{n}{iv}\PYG{p}{[}\PYG{n}{NTAB}\PYG{p}{]}\PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
    \PYG{k+kt}{double} \PYG{n}{temp}\PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
    \PYG{k+kt}{bool} \PYG{n}{seeded}\PYG{p}{;}

    \PYG{k+kt}{double} \PYG{n}{lastresult}\PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
    \PYG{k+kt}{bool} \PYG{n}{normflag}\PYG{p}{;}
    \PYG{c+c1}{// for the L value of the dispersal kernel (the width \PYGZhy{} does not affect the shape).}
    \PYG{k+kt}{double} \PYG{n}{tau}\PYG{p}{;}
    \PYG{c+c1}{// for the sigma value of the dispersal kernel (the variance of a normal distribution).}
    \PYG{k+kt}{double} \PYG{n}{sigma}\PYG{p}{;}

    \PYG{k}{typedef} \PYG{n+nf}{double} \PYG{p}{(}\PYG{n}{NRrand}\PYG{o}{:}\PYG{o}{:}\PYG{o}{*}\PYG{n}{fptr}\PYG{p}{)}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{// once setup will contain the dispersal function to use for this simulation.}
    \PYG{n}{fptr} \PYG{n}{dispersalFunction}\PYG{p}{;}
    \PYG{c+c1}{// the probability that dispersal comes from the uniform distribution. This is only relevant for uniform dispersals.}
    \PYG{k+kt}{double} \PYG{n}{m\PYGZus{}prob}\PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
    \PYG{c+c1}{// the cutoff for the uniform dispersal function i.e. the maximum value to be drawn from the uniform distribution.}
    \PYG{k+kt}{double} \PYG{n}{cutoff}\PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{k}{public}\PYG{o}{:}

    \PYG{n}{NRrand}\PYG{p}{(}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{seeded} \PYG{o}{=} \PYG{n+nb}{false}\PYG{p}{;}
        \PYG{n}{normflag} \PYG{o}{=} \PYG{n+nb}{true}\PYG{p}{;}
        \PYG{n}{dispersalFunction} \PYG{o}{=} \PYG{k}{nullptr}\PYG{p}{;}
        \PYG{n}{sigma} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
        \PYG{n}{tau} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{k+kt}{void} \PYG{n}{setSeed}\PYG{p}{(}\PYG{k+kt}{long} \PYG{n}{seed}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{if}\PYG{p}{(}\PYG{o}{!}\PYG{n}{seeded}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{idum2} \PYG{o}{=} \PYG{l+m+mi}{123456789}\PYG{p}{;}
            \PYG{n}{iy} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
            \PYG{n}{idum} \PYG{o}{=} \PYG{n}{seed}\PYG{p}{;}
            \PYG{k}{if}\PYG{p}{(}\PYG{n}{idum} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{1}\PYG{p}{)} \PYG{n}{idum} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;}
            \PYG{c+c1}{//Be sure to prevent idum = 0.}
            \PYG{n}{idum2} \PYG{o}{=} \PYG{p}{(}\PYG{n}{idum}\PYG{p}{)}\PYG{p}{;}
            \PYG{k}{for}\PYG{p}{(}\PYG{n}{j} \PYG{o}{=} \PYG{n}{NTAB} \PYG{o}{+} \PYG{l+m+mi}{7}\PYG{p}{;} \PYG{n}{j} \PYG{o}{\PYGZgt{}}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{j}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{c+c1}{//Load the shuffle table (after 8 warm\PYGZhy{}ups).}
                \PYG{n}{k} \PYG{o}{=} \PYG{p}{(}\PYG{n}{idum}\PYG{p}{)} \PYG{o}{/} \PYG{n}{IQ1}\PYG{p}{;}
                \PYG{n}{idum} \PYG{o}{=} \PYG{n}{IA1} \PYG{o}{*} \PYG{p}{(}\PYG{n}{idum} \PYG{o}{\PYGZhy{}} \PYG{n}{k} \PYG{o}{*} \PYG{n}{IQ1}\PYG{p}{)} \PYG{o}{\PYGZhy{}} \PYG{n}{k} \PYG{o}{*} \PYG{n}{IR1}\PYG{p}{;}
                \PYG{k}{if}\PYG{p}{(}\PYG{n}{idum} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{0}\PYG{p}{)} \PYG{n}{idum} \PYG{o}{+}\PYG{o}{=} \PYG{n}{IM1}\PYG{p}{;}
                \PYG{k}{if}\PYG{p}{(}\PYG{n}{j} \PYG{o}{\PYGZlt{}} \PYG{n}{NTAB}\PYG{p}{)} \PYG{n}{iv}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]} \PYG{o}{=} \PYG{n}{idum}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
            \PYG{n}{iy} \PYG{o}{=} \PYG{n}{iv}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{;}
            \PYG{n}{seeded} \PYG{o}{=} \PYG{n+nb}{true}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{else}
        \PYG{p}{\PYGZob{}}
            \PYG{k}{throw} \PYG{n}{runtime\PYGZus{}error}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Trying to set the seed again: this can only be set once.}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
    \PYG{p}{\PYGZcb{}}

    \PYG{k+kt}{double} \PYG{n}{d01}\PYG{p}{(}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{k} \PYG{o}{=} \PYG{p}{(}\PYG{n}{idum}\PYG{p}{)} \PYG{o}{/} \PYG{n}{IQ1}\PYG{p}{;}
        \PYG{c+c1}{//Start here when not initializing.}
        \PYG{n}{idum} \PYG{o}{=} \PYG{n}{IA1} \PYG{o}{*} \PYG{p}{(}\PYG{n}{idum} \PYG{o}{\PYGZhy{}} \PYG{n}{k} \PYG{o}{*} \PYG{n}{IQ1}\PYG{p}{)} \PYG{o}{\PYGZhy{}} \PYG{n}{k} \PYG{o}{*} \PYG{n}{IR1}\PYG{p}{;}
        \PYG{c+c1}{//Compute idum=(IA1*idum) \PYGZpc{} IM1 without overflows by Schrage\PYGZsq{}s method.}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{idum} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{0}\PYG{p}{)} \PYG{n}{idum} \PYG{o}{+}\PYG{o}{=} \PYG{n}{IM1}\PYG{p}{;}
        \PYG{n}{k} \PYG{o}{=} \PYG{n}{idum2} \PYG{o}{/} \PYG{n}{IQ2}\PYG{p}{;}
        \PYG{n}{idum2} \PYG{o}{=} \PYG{n}{IA2} \PYG{o}{*} \PYG{p}{(}\PYG{n}{idum2} \PYG{o}{\PYGZhy{}} \PYG{n}{k} \PYG{o}{*} \PYG{n}{IQ2}\PYG{p}{)} \PYG{o}{\PYGZhy{}} \PYG{n}{k} \PYG{o}{*} \PYG{n}{IR2}\PYG{p}{;}
        \PYG{c+c1}{//Compute idum2=(IA2*idum) \PYGZpc{} IM2 likewise.}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{idum2} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{0}\PYG{p}{)} \PYG{n}{idum2} \PYG{o}{+}\PYG{o}{=} \PYG{n}{IM2}\PYG{p}{;}
        \PYG{n}{j} \PYG{o}{=} \PYG{n}{iy} \PYG{o}{/} \PYG{n}{NDIV}\PYG{p}{;}
        \PYG{c+c1}{//Will be in the range 0..NTAB\PYGZhy{}1.}
        \PYG{n}{iy} \PYG{o}{=} \PYG{n}{iv}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]} \PYG{o}{\PYGZhy{}} \PYG{n}{idum2}\PYG{p}{;}
        \PYG{c+c1}{//Here idum is shuffled, idum and idum2 are combined to generate output.}
        \PYG{n}{iv}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]} \PYG{o}{=} \PYG{n}{idum}\PYG{p}{;}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{iy} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{1}\PYG{p}{)} \PYG{n}{iy} \PYG{o}{+}\PYG{o}{=} \PYG{n}{IMM1}\PYG{p}{;}
        \PYG{k}{if}\PYG{p}{(}\PYG{p}{(}\PYG{n}{temp} \PYG{o}{=} \PYG{n}{AM} \PYG{o}{*} \PYG{n}{iy}\PYG{p}{)} \PYG{o}{\PYGZgt{}} \PYG{n}{RNMX}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{c+c1}{//os \PYGZlt{}\PYGZlt{} \PYGZdq{}random call = \PYGZdq{} \PYGZlt{}\PYGZlt{} \PYGZdq{}RNMAX\PYGZdq{} \PYGZlt{}\PYGZlt{} \PYGZdq{}\PYGZbs{}n\PYGZdq{};}
            \PYG{k}{return} \PYG{n}{RNMX}\PYG{p}{;} \PYG{c+c1}{//Because users don\PYGZsq{}t expect endpoint values.}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{return} \PYG{n}{temp}\PYG{p}{;}

    \PYG{p}{\PYGZcb{}}

    \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{i0}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{max}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{return} \PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{long}\PYG{p}{)}\PYG{p}{(}\PYG{n}{d01}\PYG{p}{(}\PYG{p}{)} \PYG{o}{*} \PYG{p}{(}\PYG{n}{max} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{k+kt}{double} \PYG{n}{norm}\PYG{p}{(}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{normflag}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{k+kt}{double} \PYG{n}{r2} \PYG{o}{=} \PYG{l+m+mi}{2}\PYG{p}{;}
            \PYG{k+kt}{double} \PYG{n}{xx} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
            \PYG{k+kt}{double} \PYG{n}{yy} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
            \PYG{k}{while}\PYG{p}{(}\PYG{n}{r2} \PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{1}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{n}{xx} \PYG{o}{=} \PYG{l+m+mf}{2.0} \PYG{o}{*} \PYG{n}{d01}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZhy{}} \PYG{l+m+mf}{1.0}\PYG{p}{;}
                \PYG{n}{yy} \PYG{o}{=} \PYG{l+m+mf}{2.0} \PYG{o}{*} \PYG{n}{d01}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZhy{}} \PYG{l+m+mf}{1.0}\PYG{p}{;}
                \PYG{n}{r2} \PYG{o}{=} \PYG{p}{(}\PYG{n}{xx} \PYG{o}{*} \PYG{n}{xx}\PYG{p}{)} \PYG{o}{+} \PYG{p}{(}\PYG{n}{yy} \PYG{o}{*} \PYG{n}{yy}\PYG{p}{)}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
            \PYG{k+kt}{double} \PYG{n}{fac} \PYG{o}{=} \PYG{n}{sqrt}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{2.0} \PYG{o}{*} \PYG{n}{log}\PYG{p}{(}\PYG{n}{r2}\PYG{p}{)} \PYG{o}{/} \PYG{n}{r2}\PYG{p}{)}\PYG{p}{;}
            \PYG{n}{lastresult} \PYG{o}{=} \PYG{n}{xx} \PYG{o}{*} \PYG{n}{fac}\PYG{p}{;}
            \PYG{k+kt}{double} \PYG{n}{result} \PYG{o}{=} \PYG{n}{yy} \PYG{o}{*} \PYG{n}{fac}\PYG{p}{;}
            \PYG{n}{normflag} \PYG{o}{=} \PYG{n+nb}{false}\PYG{p}{;}
            \PYG{k}{return} \PYG{n}{sigma} \PYG{o}{*} \PYG{n}{result}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{else}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{normflag} \PYG{o}{=} \PYG{n+nb}{true}\PYG{p}{;}
            \PYG{k}{return} \PYG{n}{sigma} \PYG{o}{*} \PYG{n}{lastresult}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
    \PYG{p}{\PYGZcb{}}

    \PYG{k+kt}{double} \PYG{n}{norm2D}\PYG{p}{(}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k+kt}{double} \PYG{n}{distx}\PYG{p}{,} \PYG{n}{disty}\PYG{p}{;}
        \PYG{n}{distx} \PYG{o}{=} \PYG{n}{norm}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{disty} \PYG{o}{=} \PYG{n}{norm}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{return} \PYG{n+nf}{pow}\PYG{p}{(}\PYG{n}{pow}\PYG{p}{(}\PYG{n}{distx}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{)} \PYG{o}{+} \PYG{n}{pow}\PYG{p}{(}\PYG{n}{disty}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{,} \PYG{l+m+mf}{0.5}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{k+kt}{void} \PYG{n}{setDispersalParams}\PYG{p}{(}\PYG{k}{const} \PYG{k+kt}{double} \PYG{n}{sigmain}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{double} \PYG{n}{tauin}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{sigma} \PYG{o}{=} \PYG{n}{sigmain}\PYG{p}{;}
        \PYG{n}{tau} \PYG{o}{=} \PYG{n}{tauin}\PYG{p}{;} \PYG{c+c1}{// used to invert the sign here, doesn\PYGZsq{}t any more.}
    \PYG{p}{\PYGZcb{}}


    \PYG{k+kt}{double} \PYG{n}{fattail}\PYG{p}{(}\PYG{k+kt}{double} \PYG{n}{z}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k+kt}{double} \PYG{n}{result}\PYG{p}{;}
        \PYG{n}{result} \PYG{o}{=} \PYG{n}{pow}\PYG{p}{(}\PYG{p}{(}\PYG{n}{pow}\PYG{p}{(}\PYG{n}{d01}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{p}{(}\PYG{l+m+mf}{1.0} \PYG{o}{/} \PYG{p}{(}\PYG{l+m+mf}{1.0} \PYG{o}{\PYGZhy{}} \PYG{n}{z}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)} \PYG{o}{\PYGZhy{}} \PYG{l+m+mf}{1.0}\PYG{p}{)}\PYG{p}{,} \PYG{l+m+mf}{0.5}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{return} \PYG{n}{result}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{c+c1}{// this new version corrects the 1.0 to 2.0 and doesn\PYGZsq{}t require the values to be passed every time.}
    \PYG{k+kt}{double} \PYG{n}{fattail}\PYG{p}{(}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k+kt}{double} \PYG{n}{result}\PYG{p}{;}
        \PYG{c+c1}{// old function version (kept for reference)}
\PYG{c+c1}{//      result = (tau * pow((pow(d01(),(2.0/(2.0\PYGZhy{}sigma)))\PYGZhy{}1.0),0.5));}
        \PYG{n}{result} \PYG{o}{=} \PYG{p}{(}\PYG{n}{sigma} \PYG{o}{*} \PYG{n}{pow}\PYG{p}{(}\PYG{p}{(}\PYG{n}{tau} \PYG{o}{*} \PYG{p}{(}\PYG{n}{pow}\PYG{p}{(}\PYG{n}{d01}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{2.0} \PYG{o}{/} \PYG{n}{tau}\PYG{p}{)}\PYG{p}{)} \PYG{o}{\PYGZhy{}} \PYG{l+m+mf}{1.0}\PYG{p}{)}\PYG{p}{,} \PYG{l+m+mf}{0.5}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{return} \PYG{n}{result}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{k+kt}{double} \PYG{n}{fattail\PYGZus{}old}\PYG{p}{(}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k+kt}{double} \PYG{n}{result}\PYG{p}{;}
        \PYG{n}{result} \PYG{o}{=} \PYG{p}{(}\PYG{n}{sigma} \PYG{o}{*} \PYG{n}{pow}\PYG{p}{(}\PYG{p}{(}\PYG{n}{pow}\PYG{p}{(}\PYG{n}{d01}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{p}{(}\PYG{l+m+mf}{2.0} \PYG{o}{/} \PYG{p}{(}\PYG{l+m+mf}{2.0} \PYG{o}{+} \PYG{n}{tau}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)} \PYG{o}{\PYGZhy{}} \PYG{l+m+mf}{1.0}\PYG{p}{)}\PYG{p}{,} \PYG{l+m+mf}{0.5}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{return} \PYG{n}{result}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{k+kt}{double} \PYG{n}{direction}\PYG{p}{(}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{return}\PYG{p}{(}\PYG{n}{d01}\PYG{p}{(}\PYG{p}{)} \PYG{o}{*} \PYG{l+m+mi}{2} \PYG{o}{*} \PYG{n}{M\PYGZus{}PI}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{k+kt}{bool} \PYG{n}{event}\PYG{p}{(}\PYG{k+kt}{double} \PYG{n}{event\PYGZus{}probability}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{event\PYGZus{}probability} \PYG{o}{\PYGZlt{}} \PYG{l+m+mf}{0.000001}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{k}{if}\PYG{p}{(}\PYG{n}{d01}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{l+m+mf}{0.000001}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{k}{return} \PYG{p}{(}\PYG{n}{event}\PYG{p}{(}\PYG{n}{event\PYGZus{}probability} \PYG{o}{*} \PYG{l+m+mf}{1000000.0}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
            \PYG{k}{return} \PYG{n+nb}{false}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{event\PYGZus{}probability} \PYG{o}{\PYGZgt{}} \PYG{l+m+mf}{0.999999}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{k}{return} \PYG{p}{(}\PYG{o}{!}\PYG{p}{(}\PYG{n}{event}\PYG{p}{(}\PYG{l+m+mf}{1.0} \PYG{o}{\PYGZhy{}} \PYG{n}{event\PYGZus{}probability}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{return} \PYG{p}{(}\PYG{n}{d01}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{n}{event\PYGZus{}probability}\PYG{p}{)}\PYG{p}{;}


    \PYG{p}{\PYGZcb{}}

    \PYG{k+kt}{double} \PYG{n}{normUniform}\PYG{p}{(}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{c+c1}{// Check if the dispersal event comes from the uniform distribution}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{d01}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZlt{}} \PYG{n}{m\PYGZus{}prob}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{c+c1}{// Then it does come from the uniform distribution}
            \PYG{k}{return} \PYG{p}{(}\PYG{n}{d01}\PYG{p}{(}\PYG{p}{)} \PYG{o}{*} \PYG{n}{cutoff}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{return} \PYG{n}{norm2D}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}


    \PYG{k+kt}{double} \PYG{n}{uniformUniform}\PYG{p}{(}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{d01}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZlt{}} \PYG{l+m+mf}{0.5}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{c+c1}{// Then value comes from the first uniform distribution}
            \PYG{k}{return} \PYG{p}{(}\PYG{n}{d01}\PYG{p}{(}\PYG{p}{)} \PYG{o}{*} \PYG{n}{cutoff} \PYG{o}{*} \PYG{l+m+mf}{0.1}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{c+c1}{// Then the value comes from the second uniform distribution}
        \PYG{k}{return} \PYG{l+m+mf}{0.9} \PYG{o}{*} \PYG{n}{cutoff} \PYG{o}{+} \PYG{p}{(}\PYG{n}{d01}\PYG{p}{(}\PYG{p}{)} \PYG{o}{*} \PYG{n}{cutoff} \PYG{o}{*} \PYG{l+m+mf}{0.1}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{k+kt}{void} \PYG{n}{setDispersalMethod}\PYG{p}{(}\PYG{k}{const} \PYG{n}{string} \PYG{o}{\PYGZam{}}\PYG{n}{dispersal\PYGZus{}method}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{double} \PYG{o}{\PYGZam{}}\PYG{n}{m\PYGZus{}probin}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{double} \PYG{o}{\PYGZam{}}\PYG{n}{cutoffin}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{dispersal\PYGZus{}method} \PYG{o}{=}\PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{normal}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{dispersalFunction} \PYG{o}{=} \PYG{o}{\PYGZam{}}\PYG{n}{NRrand}\PYG{o}{:}\PYG{o}{:}\PYG{n}{norm2D}\PYG{p}{;}
            \PYG{k}{if}\PYG{p}{(}\PYG{n}{sigma} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{0}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{k}{throw} \PYG{n}{invalid\PYGZus{}argument}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Cannot have negative sigma with normal dispersal}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{else} \PYG{k}{if}\PYG{p}{(}\PYG{n}{dispersal\PYGZus{}method} \PYG{o}{=}\PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{fat\PYGZhy{}tail}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\textbar{}}\PYG{o}{\textbar{}} \PYG{n}{dispersal\PYGZus{}method} \PYG{o}{=}\PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{fat\PYGZhy{}tailed}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{dispersalFunction} \PYG{o}{=} \PYG{o}{\PYGZam{}}\PYG{n}{NRrand}\PYG{o}{:}\PYG{o}{:}\PYG{n}{fattail}\PYG{p}{;}
            \PYG{k}{if}\PYG{p}{(}\PYG{n}{tau} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{0} \PYG{o}{\textbar{}}\PYG{o}{\textbar{}} \PYG{n}{sigma} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{0}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{k}{throw} \PYG{n}{invalid\PYGZus{}argument}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Cannot have negative sigma or tau with fat\PYGZhy{}tailed dispersal}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{else} \PYG{k}{if}\PYG{p}{(}\PYG{n}{dispersal\PYGZus{}method} \PYG{o}{=}\PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{norm\PYGZhy{}uniform}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{dispersalFunction} \PYG{o}{=} \PYG{o}{\PYGZam{}}\PYG{n}{NRrand}\PYG{o}{:}\PYG{o}{:}\PYG{n}{normUniform}\PYG{p}{;}
            \PYG{k}{if}\PYG{p}{(}\PYG{n}{sigma} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{0}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{k}{throw} \PYG{n}{invalid\PYGZus{}argument}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Cannot have negative sigma with normal dispersal}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{else} \PYG{k}{if}\PYG{p}{(}\PYG{n}{dispersal\PYGZus{}method} \PYG{o}{=}\PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{uniform\PYGZhy{}uniform}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{c+c1}{// This is just here for testing purposes}
            \PYG{n}{dispersalFunction} \PYG{o}{=} \PYG{o}{\PYGZam{}}\PYG{n}{NRrand}\PYG{o}{:}\PYG{o}{:}\PYG{n}{uniformUniform}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
            \PYG{c+c1}{// Also provided the old version of the fat\PYGZhy{}tailed dispersal kernel}
        \PYG{k}{else} \PYG{k}{if}\PYG{p}{(}\PYG{n}{dispersal\PYGZus{}method} \PYG{o}{=}\PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{fat\PYGZhy{}tail\PYGZhy{}old}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{dispersalFunction} \PYG{o}{=} \PYG{o}{\PYGZam{}}\PYG{n}{NRrand}\PYG{o}{:}\PYG{o}{:}\PYG{n}{fattail\PYGZus{}old}\PYG{p}{;}
            \PYG{k}{if}\PYG{p}{(}\PYG{n}{tau} \PYG{o}{\PYGZgt{}} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2} \PYG{o}{\textbar{}}\PYG{o}{\textbar{}} \PYG{n}{sigma} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{0}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{k}{throw} \PYG{n}{invalid\PYGZus{}argument}\PYG{p}{(}
                        \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Cannot have sigma \PYGZlt{} 0 or tau \PYGZgt{} \PYGZhy{}2 with fat\PYGZhy{}tailed dispersal (old implementation).}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{else}
        \PYG{p}{\PYGZob{}}
            \PYG{k}{throw} \PYG{n}{runtime\PYGZus{}error}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Dispersal method not detected. Check implementation exists}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{n}{m\PYGZus{}prob} \PYG{o}{=} \PYG{n}{m\PYGZus{}probin}\PYG{p}{;}
        \PYG{n}{cutoff} \PYG{o}{=} \PYG{n}{cutoffin}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}


    \PYG{k+kt}{double} \PYG{n}{dispersal}\PYG{p}{(}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{return} \PYG{n}{min}\PYG{p}{(}\PYG{k+kt}{double}\PYG{p}{(}\PYG{n}{LONG\PYGZus{}MAX}\PYG{p}{)}\PYG{p}{,} \PYG{p}{(}\PYG{k}{this}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{o}{*}\PYG{n}{dispersalFunction}\PYG{p}{)}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{c+c1}{// to reconstruct distribution, use x = fattail/squrt(1+direction) , y = fattail/squrt(1+(direction\PYGZca{}\PYGZhy{}1))}

    \PYG{k}{friend} \PYG{n}{ostream} \PYG{o}{\PYGZam{}}\PYG{k}{operator}\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{p}{(}\PYG{n}{ostream} \PYG{o}{\PYGZam{}}\PYG{n}{os}\PYG{p}{,} \PYG{k}{const} \PYG{n}{NRrand} \PYG{o}{\PYGZam{}}\PYG{n}{r}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{c+c1}{//os \PYGZlt{}\PYGZlt{} m.numRows\PYGZlt{}\PYGZlt{}\PYGZdq{} , \PYGZdq{}\PYGZlt{}\PYGZlt{}m.numCols\PYGZlt{}\PYGZlt{}\PYGZdq{} , \PYGZdq{}\PYGZlt{}\PYGZlt{}endl;}
        \PYG{n}{os} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{setprecision}\PYG{p}{(}\PYG{l+m+mi}{64}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{os} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{r}\PYG{p}{.}\PYG{n}{idum} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{,}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
        \PYG{n}{os} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{r}\PYG{p}{.}\PYG{n}{j} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{,}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
        \PYG{n}{os} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{r}\PYG{p}{.}\PYG{n}{k} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{,}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
        \PYG{n}{os} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{r}\PYG{p}{.}\PYG{n}{idum2} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{,}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
        \PYG{n}{os} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{r}\PYG{p}{.}\PYG{n}{iy} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{,}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
        \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{long} \PYG{n+nl}{i} \PYG{p}{:} \PYG{n}{r}\PYG{p}{.}\PYG{n}{iv}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{os} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{i} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{,}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{n}{os} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{r}\PYG{p}{.}\PYG{n}{temp} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{,}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
        \PYG{n}{os} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{r}\PYG{p}{.}\PYG{n}{seeded} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{,}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
        \PYG{n}{os} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{r}\PYG{p}{.}\PYG{n}{lastresult} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{,}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
        \PYG{n}{os} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{r}\PYG{p}{.}\PYG{n}{normflag} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{,}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{r}\PYG{p}{.}\PYG{n}{tau} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{,}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{r}\PYG{p}{.}\PYG{n}{sigma} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{,}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{r}\PYG{p}{.}\PYG{n}{m\PYGZus{}prob} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{,}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{r}\PYG{p}{.}\PYG{n}{cutoff}\PYG{p}{;}
        \PYG{k}{return} \PYG{n}{os}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{k}{friend} \PYG{n}{istream} \PYG{o}{\PYGZam{}}\PYG{k}{operator}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{n}{istream} \PYG{o}{\PYGZam{}}\PYG{n}{is}\PYG{p}{,} \PYG{n}{NRrand} \PYG{o}{\PYGZam{}}\PYG{n}{r}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
\PYG{c+c1}{//      os \PYGZlt{}\PYGZlt{} \PYGZdq{}starting NR read\PYGZdq{} \PYGZlt{}\PYGZlt{} endl;}
        \PYG{k+kt}{char} \PYG{n}{delim}\PYG{p}{;}
        \PYG{c+c1}{//double temp1,temp2;}
        \PYG{c+c1}{//is \PYGZlt{}\PYGZlt{} m.numRows\PYGZlt{}\PYGZlt{}\PYGZdq{} , \PYGZdq{}\PYGZlt{}\PYGZlt{}m.numCols\PYGZlt{}\PYGZlt{}\PYGZdq{} , \PYGZdq{}\PYGZlt{}\PYGZlt{}endl;}
        \PYG{n}{is} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{r}\PYG{p}{.}\PYG{n}{idum}\PYG{p}{;}
\PYG{c+c1}{//      os \PYGZlt{}\PYGZlt{} r.idum \PYGZlt{}\PYGZlt{} endl;}
\PYG{c+c1}{//      string tmp;}
\PYG{c+c1}{//      is \PYGZgt{}\PYGZgt{} delim \PYGZgt{}\PYGZgt{} tmp;}
\PYG{c+c1}{//      os \PYGZlt{}\PYGZlt{} tmp \PYGZlt{}\PYGZlt{} endl;}
\PYG{c+c1}{//      os \PYGZlt{}\PYGZlt{} delim;}
        \PYG{n}{is} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{delim}\PYG{p}{;}
        \PYG{n}{is} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{r}\PYG{p}{.}\PYG{n}{j}\PYG{p}{;}
        \PYG{n}{is} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{delim}\PYG{p}{;}
        \PYG{n}{is} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{r}\PYG{p}{.}\PYG{n}{k}\PYG{p}{;}
        \PYG{n}{is} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{delim}\PYG{p}{;}
        \PYG{n}{is} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{r}\PYG{p}{.}\PYG{n}{idum2}\PYG{p}{;}
        \PYG{n}{is} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{delim}\PYG{p}{;}
        \PYG{n}{is} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{r}\PYG{p}{.}\PYG{n}{iy}\PYG{p}{;}
        \PYG{n}{is} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{delim}\PYG{p}{;}
        \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n+nl}{i} \PYG{p}{:} \PYG{n}{r}\PYG{p}{.}\PYG{n}{iv}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{is} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{i}\PYG{p}{;}
            \PYG{n}{is} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{delim}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{n}{is} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{r}\PYG{p}{.}\PYG{n}{temp}\PYG{p}{;}
        \PYG{n}{is} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{delim}\PYG{p}{;}
        \PYG{n}{is} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{r}\PYG{p}{.}\PYG{n}{seeded}\PYG{p}{;}
        \PYG{n}{is} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{delim}\PYG{p}{;}
        \PYG{n}{is} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{r}\PYG{p}{.}\PYG{n}{lastresult}\PYG{p}{;}
        \PYG{n}{is} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{delim}\PYG{p}{;}
        \PYG{n}{is} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{r}\PYG{p}{.}\PYG{n}{normflag}\PYG{p}{;}
        \PYG{n}{is} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{delim} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{r}\PYG{p}{.}\PYG{n}{tau} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{delim} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{r}\PYG{p}{.}\PYG{n}{sigma} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{delim} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{r}\PYG{p}{.}\PYG{n}{m\PYGZus{}prob} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{delim} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{r}\PYG{p}{.}\PYG{n}{cutoff}\PYG{p}{;}
        \PYG{k}{return} \PYG{n}{is}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}

\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif}
\end{sphinxVerbatim}


\subsubsection{Detailed Description}
\label{\detokenize{api/file_necsim_NRrand.h:detailed-description}}
James Rosindell
The definitions for the constants defined here should not be altered. BSD-3 Licence.


\subsubsection{Includes}
\label{\detokenize{api/file_necsim_NRrand.h:includes}}\begin{itemize}
\item {} 
\sphinxcode{Logging.h} ({\hyperref[\detokenize{api/file_necsim_Logging.h:file-necsim-logging-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File Logging.h}}}})

\item {} 
\sphinxcode{climits}

\item {} 
\sphinxcode{cmath}

\item {} 
\sphinxcode{cstdio}

\item {} 
\sphinxcode{fstream}

\item {} 
\sphinxcode{iomanip}

\item {} 
\sphinxcode{iostream}

\item {} 
\sphinxcode{string}

\item {} 
\sphinxcode{vector}

\end{itemize}


\subsubsection{Included By}
\label{\detokenize{api/file_necsim_NRrand.h:included-by}}\begin{itemize}
\item {} 
{\hyperref[\detokenize{api/file_necsim_DispersalCoordinator.h:file-necsim-dispersalcoordinator-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File DispersalCoordinator.h}}}}

\item {} 
{\hyperref[\detokenize{api/file_necsim_Tree.h:file-necsim-tree-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File Tree.h}}}}

\item {} 
{\hyperref[\detokenize{api/file_necsim_SpatialTree.h:file-necsim-spatialtree-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File SpatialTree.h}}}}

\item {} 
{\hyperref[\detokenize{api/file_necsim_SpeciesList.h:file-necsim-specieslist-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File SpeciesList.h}}}}

\item {} 
{\hyperref[\detokenize{api/file_necsim_ReproductionMap.h:file-necsim-reproductionmap-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File ReproductionMap.h}}}}

\item {} 
{\hyperref[\detokenize{api/file_necsim_Metacommunity.h:file-necsim-metacommunity-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File Metacommunity.h}}}}

\item {} 
{\hyperref[\detokenize{api/file_necsim_SimulateDispersal.h:file-necsim-simulatedispersal-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File SimulateDispersal.h}}}}

\end{itemize}


\subsubsection{Classes}
\label{\detokenize{api/file_necsim_NRrand.h:classes}}\begin{itemize}
\item {} 
{\hyperref[\detokenize{api/class_NRrand:class-nrrand}]{\sphinxcrossref{\DUrole{std,std-ref}{Class NRrand}}}}

\end{itemize}


\subsubsection{Defines}
\label{\detokenize{api/file_necsim_NRrand.h:defines}}\begin{itemize}
\item {} 
{\hyperref[\detokenize{api/define_AM:define-am}]{\sphinxcrossref{\DUrole{std,std-ref}{Define AM}}}}

\item {} 
{\hyperref[\detokenize{api/define_EPS:define-eps}]{\sphinxcrossref{\DUrole{std,std-ref}{Define EPS}}}}

\item {} 
{\hyperref[\detokenize{api/define_IA1:define-ia1}]{\sphinxcrossref{\DUrole{std,std-ref}{Define IA1}}}}

\item {} 
{\hyperref[\detokenize{api/define_IA2:define-ia2}]{\sphinxcrossref{\DUrole{std,std-ref}{Define IA2}}}}

\item {} 
{\hyperref[\detokenize{api/define_IM1:define-im1}]{\sphinxcrossref{\DUrole{std,std-ref}{Define IM1}}}}

\item {} 
{\hyperref[\detokenize{api/define_IM2:define-im2}]{\sphinxcrossref{\DUrole{std,std-ref}{Define IM2}}}}

\item {} 
{\hyperref[\detokenize{api/define_IMM1:define-imm1}]{\sphinxcrossref{\DUrole{std,std-ref}{Define IMM1}}}}

\item {} 
{\hyperref[\detokenize{api/define_IQ1:define-iq1}]{\sphinxcrossref{\DUrole{std,std-ref}{Define IQ1}}}}

\item {} 
{\hyperref[\detokenize{api/define_IQ2:define-iq2}]{\sphinxcrossref{\DUrole{std,std-ref}{Define IQ2}}}}

\item {} 
{\hyperref[\detokenize{api/define_IR1:define-ir1}]{\sphinxcrossref{\DUrole{std,std-ref}{Define IR1}}}}

\item {} 
{\hyperref[\detokenize{api/define_IR2:define-ir2}]{\sphinxcrossref{\DUrole{std,std-ref}{Define IR2}}}}

\item {} 
{\hyperref[\detokenize{api/define_NDIV:define-ndiv}]{\sphinxcrossref{\DUrole{std,std-ref}{Define NDIV}}}}

\item {} 
{\hyperref[\detokenize{api/define_NTAB:define-ntab}]{\sphinxcrossref{\DUrole{std,std-ref}{Define NTAB}}}}

\item {} 
{\hyperref[\detokenize{api/define_RNMX:define-rnmx}]{\sphinxcrossref{\DUrole{std,std-ref}{Define RNMX}}}}

\end{itemize}


\subsection{File ProtractedSpatialTree.h}
\label{\detokenize{api/file_necsim_ProtractedSpatialTree.h:file-protractedspatialtree-h}}\label{\detokenize{api/file_necsim_ProtractedSpatialTree.h:file-necsim-protractedspatialtree-h}}\label{\detokenize{api/file_necsim_ProtractedSpatialTree.h::doc}}
Contains the {\hyperref[\detokenize{api/class_ProtractedSpatialTree:class-protractedspatialtree}]{\sphinxcrossref{\DUrole{std,std-ref}{Class ProtractedSpatialTree}}}} class for running simulations and outputting the phylogenetic trees using protracted speciation.

\begin{sphinxShadowBox}
\sphinxstyletopictitle{Contents}
\begin{itemize}
\item {} 
\phantomsection\label{\detokenize{api/file_necsim_ProtractedSpatialTree.h:id1}}{\hyperref[\detokenize{api/file_necsim_ProtractedSpatialTree.h:definition-necsim-protractedspatialtree-h}]{\sphinxcrossref{Definition (\sphinxcode{necsim/ProtractedSpatialTree.h})}}}

\item {} 
\phantomsection\label{\detokenize{api/file_necsim_ProtractedSpatialTree.h:id2}}{\hyperref[\detokenize{api/file_necsim_ProtractedSpatialTree.h:detailed-description}]{\sphinxcrossref{Detailed Description}}}

\item {} 
\phantomsection\label{\detokenize{api/file_necsim_ProtractedSpatialTree.h:id3}}{\hyperref[\detokenize{api/file_necsim_ProtractedSpatialTree.h:includes}]{\sphinxcrossref{Includes}}}

\item {} 
\phantomsection\label{\detokenize{api/file_necsim_ProtractedSpatialTree.h:id4}}{\hyperref[\detokenize{api/file_necsim_ProtractedSpatialTree.h:classes}]{\sphinxcrossref{Classes}}}

\item {} 
\phantomsection\label{\detokenize{api/file_necsim_ProtractedSpatialTree.h:id5}}{\hyperref[\detokenize{api/file_necsim_ProtractedSpatialTree.h:defines}]{\sphinxcrossref{Defines}}}

\end{itemize}
\end{sphinxShadowBox}


\subsubsection{Definition (\sphinxstyleliteralintitle{necsim/ProtractedSpatialTree.h})}
\label{\detokenize{api/file_necsim_ProtractedSpatialTree.h:definition-necsim-protractedspatialtree-h}}

\paragraph{Program Listing for File ProtractedSpatialTree.h}
\label{\detokenize{api/program_listing_file_necsim_ProtractedSpatialTree.h:program-listing-file-necsim-protractedspatialtree-h}}\label{\detokenize{api/program_listing_file_necsim_ProtractedSpatialTree.h:program-listing-for-file-protractedspatialtree-h}}\label{\detokenize{api/program_listing_file_necsim_ProtractedSpatialTree.h::doc}}\begin{itemize}
\item {} 
Return to documentation for {\hyperref[\detokenize{api/file_necsim_ProtractedSpatialTree.h:file-necsim-protractedspatialtree-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File ProtractedSpatialTree.h}}}}

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{// This file is part of NECSim project which is released under BSD\PYGZhy{}3 license.}
\PYG{c+c1}{// See file **LICENSE.txt** or visit https://opensource.org/licenses/BSD\PYGZhy{}3\PYGZhy{}Clause) for full license details.}
\PYG{c+c1}{//}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZdq{}SpatialTree.h\PYGZdq{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZdq{}ProtractedTree.h\PYGZdq{}}

\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifndef SPECIATIONCOUNTER\PYGZus{}PROTRACTEDSPATIALTREE\PYGZus{}H}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define SPECIATIONCOUNTER\PYGZus{}PROTRACTEDSPATIALTREE\PYGZus{}H}


\PYG{k}{class} \PYG{n+nc}{ProtractedSpatialTree} \PYG{o}{:} \PYG{k}{public} \PYG{n}{SpatialTree}\PYG{p}{,} \PYG{k}{public} \PYG{n}{ProtractedTree}
\PYG{p}{\PYGZob{}}

\PYG{p}{\PYGZcb{}}\PYG{p}{;}


\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif }\PYG{c+c1}{//SPECIATIONCOUNTER\PYGZus{}PROTRACTEDSPATIALTREE\PYGZus{}H}
\end{sphinxVerbatim}


\subsubsection{Detailed Description}
\label{\detokenize{api/file_necsim_ProtractedSpatialTree.h:detailed-description}}
Sam Thompson
Contact: \sphinxhref{mailto:samuel.thompson14@imperial.ac.uk}{samuel.thompson14@imperial.ac.uk} or \sphinxhref{mailto:thompsonsed@gmail.com}{thompsonsed@gmail.com} BSD-3 Licence.


\subsubsection{Includes}
\label{\detokenize{api/file_necsim_ProtractedSpatialTree.h:includes}}\begin{itemize}
\item {} 
\sphinxcode{ProtractedTree.h} ({\hyperref[\detokenize{api/file_necsim_ProtractedTree.h:file-necsim-protractedtree-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File ProtractedTree.h}}}})

\item {} 
\sphinxcode{SpatialTree.h} ({\hyperref[\detokenize{api/file_necsim_ProtractedSpatialTree.h:file-necsim-protractedspatialtree-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File ProtractedSpatialTree.h}}}})

\end{itemize}


\subsubsection{Classes}
\label{\detokenize{api/file_necsim_ProtractedSpatialTree.h:classes}}\begin{itemize}
\item {} 
{\hyperref[\detokenize{api/class_ProtractedSpatialTree:class-protractedspatialtree}]{\sphinxcrossref{\DUrole{std,std-ref}{Class ProtractedSpatialTree}}}}

\end{itemize}


\subsubsection{Defines}
\label{\detokenize{api/file_necsim_ProtractedSpatialTree.h:defines}}\begin{itemize}
\item {} 
{\hyperref[\detokenize{api/define_SPECIATIONCOUNTER_PROTRACTEDSPATIALTREE_H:define-speciationcounter-protractedspatialtree-h}]{\sphinxcrossref{\DUrole{std,std-ref}{Define SPECIATIONCOUNTER\_PROTRACTEDSPATIALTREE\_H}}}}

\end{itemize}


\subsection{File ProtractedTree.cpp}
\label{\detokenize{api/file_necsim_ProtractedTree.cpp:file-necsim-protractedtree-cpp}}\label{\detokenize{api/file_necsim_ProtractedTree.cpp:file-protractedtree-cpp}}\label{\detokenize{api/file_necsim_ProtractedTree.cpp::doc}}
Contains the {\hyperref[\detokenize{api/class_ProtractedTree:class-protractedtree}]{\sphinxcrossref{\DUrole{std,std-ref}{Class ProtractedTree}}}} class for running simulations and outputting the phylogenetic trees using protracted speciation.

\begin{sphinxShadowBox}
\sphinxstyletopictitle{Contents}
\begin{itemize}
\item {} 
\phantomsection\label{\detokenize{api/file_necsim_ProtractedTree.cpp:id1}}{\hyperref[\detokenize{api/file_necsim_ProtractedTree.cpp:definition-necsim-protractedtree-cpp}]{\sphinxcrossref{Definition (\sphinxcode{necsim/ProtractedTree.cpp})}}}

\item {} 
\phantomsection\label{\detokenize{api/file_necsim_ProtractedTree.cpp:id2}}{\hyperref[\detokenize{api/file_necsim_ProtractedTree.cpp:detailed-description}]{\sphinxcrossref{Detailed Description}}}

\item {} 
\phantomsection\label{\detokenize{api/file_necsim_ProtractedTree.cpp:id3}}{\hyperref[\detokenize{api/file_necsim_ProtractedTree.cpp:includes}]{\sphinxcrossref{Includes}}}

\end{itemize}
\end{sphinxShadowBox}


\subsubsection{Definition (\sphinxstyleliteralintitle{necsim/ProtractedTree.cpp})}
\label{\detokenize{api/file_necsim_ProtractedTree.cpp:definition-necsim-protractedtree-cpp}}

\paragraph{Program Listing for File ProtractedTree.cpp}
\label{\detokenize{api/program_listing_file_necsim_ProtractedTree.cpp:program-listing-for-file-protractedtree-cpp}}\label{\detokenize{api/program_listing_file_necsim_ProtractedTree.cpp:program-listing-file-necsim-protractedtree-cpp}}\label{\detokenize{api/program_listing_file_necsim_ProtractedTree.cpp::doc}}\begin{itemize}
\item {} 
Return to documentation for {\hyperref[\detokenize{api/file_necsim_ProtractedTree.cpp:file-necsim-protractedtree-cpp}]{\sphinxcrossref{\DUrole{std,std-ref}{File ProtractedTree.cpp}}}}

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{// This file is part of NECSim project which is released under BSD\PYGZhy{}3 license.}
\PYG{c+c1}{// See file **LICENSE.txt** or visit https://opensource.org/licenses/BSD\PYGZhy{}3\PYGZhy{}Clause) for full license details.}
\PYG{c+c1}{//}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZdq{}ProtractedTree.h\PYGZdq{}}


\PYG{k+kt}{bool} \PYG{n}{ProtractedTree}\PYG{o}{:}\PYG{o}{:}\PYG{n}{calcSpeciation}\PYG{p}{(}\PYG{k}{const} \PYG{k+kt}{long} \PYG{k+kt}{double} \PYG{o}{\PYGZam{}} \PYG{n}{random\PYGZus{}number}\PYG{p}{,}
                                    \PYG{k}{const} \PYG{k+kt}{long} \PYG{k+kt}{double} \PYG{o}{\PYGZam{}} \PYG{n}{speciation\PYGZus{}rate}\PYG{p}{,}
                                    \PYG{k}{const} \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}} \PYG{n}{no\PYGZus{}generations}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k}{if}\PYG{p}{(}\PYG{n}{generation} \PYG{o}{\PYGZlt{}} \PYG{n}{speciation\PYGZus{}generation\PYGZus{}min}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{return} \PYG{n+nb}{false}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{if}\PYG{p}{(}\PYG{n}{generation} \PYG{o}{\PYGZgt{}} \PYG{n}{speciation\PYGZus{}generation\PYGZus{}max}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{return} \PYG{n+nb}{true}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{return} \PYG{n}{checkSpeciation}\PYG{p}{(}\PYG{n}{random\PYGZus{}number}\PYG{p}{,} \PYG{n}{speciation\PYGZus{}rate}\PYG{p}{,} \PYG{n}{no\PYGZus{}generations}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{void} \PYG{n}{ProtractedTree}\PYG{o}{:}\PYG{o}{:}\PYG{n}{speciateLineage}\PYG{p}{(}\PYG{k}{const} \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{data\PYGZus{}position}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{n}{data}\PYG{p}{[}\PYG{n}{data\PYGZus{}position}\PYG{p}{]}\PYG{p}{.}\PYG{n}{setSpec}\PYG{p}{(}\PYG{l+m+mf}{0.0}\PYG{p}{)}\PYG{p}{;}
    \PYG{k}{if}\PYG{p}{(}\PYG{n}{speciation\PYGZus{}generation\PYGZus{}min} \PYG{o}{\PYGZgt{}}\PYG{o}{=} \PYG{n}{data}\PYG{p}{[}\PYG{n}{data\PYGZus{}position}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getGenRate}\PYG{p}{(}\PYG{p}{)} \PYG{o}{+} \PYG{n}{data}\PYG{p}{[}\PYG{n}{data\PYGZus{}position}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getGeneration}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{data}\PYG{p}{[}\PYG{n}{data\PYGZus{}position}\PYG{p}{]}\PYG{p}{.}\PYG{n}{setGenerationRate}\PYG{p}{(}\PYG{k}{static\PYGZus{}cast}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{unsigned} \PYG{k+kt}{long}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{n}{floor}\PYG{p}{(}\PYG{n}{speciation\PYGZus{}generation\PYGZus{}min}\PYG{p}{)}\PYG{p}{)} \PYG{o}{+} \PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifdef DEBUG}
    \PYG{k}{if}\PYG{p}{(}\PYG{n}{generation} \PYG{o}{\PYGZlt{}} \PYG{n}{speciation\PYGZus{}generation\PYGZus{}min}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{data}\PYG{p}{[}\PYG{n}{data\PYGZus{}position}\PYG{p}{]}\PYG{p}{.}\PYG{n}{logLineageInformation}\PYG{p}{(}\PYG{l+m+mi}{50}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{throw} \PYG{n+nf}{FatalException}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Speciation attempted before minimum speciation generation. Please report this bug.}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif }\PYG{c+c1}{// DEBUG}
    \PYG{n}{data}\PYG{p}{[}\PYG{n}{data\PYGZus{}position}\PYG{p}{]}\PYG{p}{.}\PYG{n}{speciate}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{bool} \PYG{n}{ProtractedTree}\PYG{o}{:}\PYG{o}{:}\PYG{n}{getProtracted}\PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k}{return} \PYG{n+nb}{true}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{void} \PYG{n}{ProtractedTree}\PYG{o}{:}\PYG{o}{:}\PYG{n}{setProtractedVariables}\PYG{p}{(}\PYG{k+kt}{double} \PYG{n}{speciation\PYGZus{}gen\PYGZus{}min\PYGZus{}in}\PYG{p}{,} \PYG{k+kt}{double} \PYG{n}{speciation\PYGZus{}gen\PYGZus{}max\PYGZus{}in}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{n}{speciation\PYGZus{}generation\PYGZus{}min} \PYG{o}{=} \PYG{n}{speciation\PYGZus{}gen\PYGZus{}min\PYGZus{}in}\PYG{p}{;}
    \PYG{n}{speciation\PYGZus{}generation\PYGZus{}max} \PYG{o}{=} \PYG{n}{speciation\PYGZus{}gen\PYGZus{}max\PYGZus{}in}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{n}{string} \PYG{n}{ProtractedTree}\PYG{o}{:}\PYG{o}{:}\PYG{n}{getProtractedVariables}\PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{n}{stringstream} \PYG{n}{ss}\PYG{p}{;}
    \PYG{n}{ss} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{speciation\PYGZus{}generation\PYGZus{}min} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{speciation\PYGZus{}generation\PYGZus{}max} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
    \PYG{k}{return} \PYG{n}{ss}\PYG{p}{.}\PYG{n}{str}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{double} \PYG{n}{ProtractedTree}\PYG{o}{:}\PYG{o}{:}\PYG{n}{getProtractedGenerationMin}\PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k}{return} \PYG{n}{speciation\PYGZus{}generation\PYGZus{}min}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{double} \PYG{n}{ProtractedTree}\PYG{o}{:}\PYG{o}{:}\PYG{n}{getProtractedGenerationMax}\PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k}{return} \PYG{n}{speciation\PYGZus{}generation\PYGZus{}max}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{n}{string} \PYG{n}{ProtractedTree}\PYG{o}{:}\PYG{o}{:}\PYG{n}{protractedVarsToString}\PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{n}{string} \PYG{n}{tmp} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{1 , }\PYG{l+s}{\PYGZdq{}} \PYG{o}{+} \PYG{n}{to\PYGZus{}string}\PYG{p}{(}\PYG{n}{speciation\PYGZus{}generation\PYGZus{}min}\PYG{p}{)} \PYG{o}{+} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{, }\PYG{l+s}{\PYGZdq{}} \PYG{o}{+} \PYG{n}{to\PYGZus{}string}\PYG{p}{(}\PYG{n}{speciation\PYGZus{}generation\PYGZus{}max}\PYG{p}{)}\PYG{p}{;}
    \PYG{k}{return} \PYG{n}{tmp}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}


\subsubsection{Detailed Description}
\label{\detokenize{api/file_necsim_ProtractedTree.cpp:detailed-description}}
Sam Thompson
12/07/2017
Contact: \sphinxhref{mailto:samuel.thompson14@imperial.ac.uk}{samuel.thompson14@imperial.ac.uk} or \sphinxhref{mailto:thompsonsed@gmail.com}{thompsonsed@gmail.com} BSD-3 Licence.


\subsubsection{Includes}
\label{\detokenize{api/file_necsim_ProtractedTree.cpp:includes}}\begin{itemize}
\item {} 
\sphinxcode{ProtractedTree.h} ({\hyperref[\detokenize{api/file_necsim_ProtractedTree.h:file-necsim-protractedtree-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File ProtractedTree.h}}}})

\end{itemize}


\subsection{File ProtractedTree.h}
\label{\detokenize{api/file_necsim_ProtractedTree.h:file-necsim-protractedtree-h}}\label{\detokenize{api/file_necsim_ProtractedTree.h:file-protractedtree-h}}\label{\detokenize{api/file_necsim_ProtractedTree.h::doc}}
Contains the protracted tree class, for running simulations with procated speciation.

\begin{sphinxShadowBox}
\sphinxstyletopictitle{Contents}
\begin{itemize}
\item {} 
\phantomsection\label{\detokenize{api/file_necsim_ProtractedTree.h:id1}}{\hyperref[\detokenize{api/file_necsim_ProtractedTree.h:definition-necsim-protractedtree-h}]{\sphinxcrossref{Definition (\sphinxcode{necsim/ProtractedTree.h})}}}

\item {} 
\phantomsection\label{\detokenize{api/file_necsim_ProtractedTree.h:id2}}{\hyperref[\detokenize{api/file_necsim_ProtractedTree.h:detailed-description}]{\sphinxcrossref{Detailed Description}}}

\item {} 
\phantomsection\label{\detokenize{api/file_necsim_ProtractedTree.h:id3}}{\hyperref[\detokenize{api/file_necsim_ProtractedTree.h:includes}]{\sphinxcrossref{Includes}}}

\item {} 
\phantomsection\label{\detokenize{api/file_necsim_ProtractedTree.h:id4}}{\hyperref[\detokenize{api/file_necsim_ProtractedTree.h:included-by}]{\sphinxcrossref{Included By}}}

\item {} 
\phantomsection\label{\detokenize{api/file_necsim_ProtractedTree.h:id5}}{\hyperref[\detokenize{api/file_necsim_ProtractedTree.h:classes}]{\sphinxcrossref{Classes}}}

\end{itemize}
\end{sphinxShadowBox}


\subsubsection{Definition (\sphinxstyleliteralintitle{necsim/ProtractedTree.h})}
\label{\detokenize{api/file_necsim_ProtractedTree.h:definition-necsim-protractedtree-h}}

\paragraph{Program Listing for File ProtractedTree.h}
\label{\detokenize{api/program_listing_file_necsim_ProtractedTree.h:program-listing-file-necsim-protractedtree-h}}\label{\detokenize{api/program_listing_file_necsim_ProtractedTree.h::doc}}\label{\detokenize{api/program_listing_file_necsim_ProtractedTree.h:program-listing-for-file-protractedtree-h}}\begin{itemize}
\item {} 
Return to documentation for {\hyperref[\detokenize{api/file_necsim_ProtractedTree.h:file-necsim-protractedtree-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File ProtractedTree.h}}}}

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{// This file is part of NECSim project which is released under BSD\PYGZhy{}3 license.}
\PYG{c+c1}{// See file **LICENSE.txt** or visit https://opensource.org/licenses/BSD\PYGZhy{}3\PYGZhy{}Clause) for full license details.}
\PYG{c+c1}{//}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}vector\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}string\PYGZgt{}}

\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZdq{}SpatialTree.h\PYGZdq{}}

\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifndef PROTRACTED\PYGZus{}SPATIAL\PYGZus{}TREE\PYGZus{}H}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define PROTRACTED\PYGZus{}SPATIAL\PYGZus{}TREE\PYGZus{}H}

\PYG{k}{class} \PYG{n+nc}{ProtractedTree} \PYG{o}{:} \PYG{k}{public} \PYG{k}{virtual} \PYG{n}{Tree}
\PYG{p}{\PYGZob{}}
\PYG{k}{private}\PYG{o}{:}
    \PYG{c+c1}{// Variables for the protracted speciation variables}
    \PYG{c+c1}{// The number of generations a lineage must exist before speciating.}
    \PYG{c+c1}{// Speciation is therefore not allowed before this time.}
    \PYG{c+c1}{// If this value is 0, it has no effect.}
    \PYG{k+kt}{double} \PYG{n}{speciation\PYGZus{}generation\PYGZus{}min}\PYG{p}{;}
    \PYG{c+c1}{// The number of generations a lineage can exist before speciating.}
    \PYG{c+c1}{// All remaining lineages are speciated at this time.}
    \PYG{c+c1}{// If this value is 0, it has no effect.}
    \PYG{k+kt}{double} \PYG{n}{speciation\PYGZus{}generation\PYGZus{}max}\PYG{p}{;}
\PYG{k}{public}\PYG{o}{:}

    \PYG{n}{ProtractedTree}\PYG{p}{(}\PYG{p}{)} \PYG{o}{:} \PYG{n}{Tree}\PYG{p}{(}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{bIsProtracted} \PYG{o}{=} \PYG{n+nb}{true}\PYG{p}{;}
        \PYG{n}{speciation\PYGZus{}generation\PYGZus{}min} \PYG{o}{=} \PYG{l+m+mf}{0.0}\PYG{p}{;}
        \PYG{n}{speciation\PYGZus{}generation\PYGZus{}max} \PYG{o}{=} \PYG{l+m+mf}{0.0}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{k+kt}{bool} \PYG{n}{calcSpeciation}\PYG{p}{(}\PYG{k}{const} \PYG{k+kt}{long} \PYG{k+kt}{double} \PYG{o}{\PYGZam{}} \PYG{n}{random\PYGZus{}number}\PYG{p}{,}
                        \PYG{k}{const} \PYG{k+kt}{long} \PYG{k+kt}{double} \PYG{o}{\PYGZam{}} \PYG{n}{speciation\PYGZus{}rate}\PYG{p}{,}
                        \PYG{k}{const} \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}} \PYG{n}{no\PYGZus{}generations}\PYG{p}{)} \PYG{k}{override}\PYG{p}{;}

    \PYG{k+kt}{void} \PYG{n+nf}{speciateLineage}\PYG{p}{(}\PYG{k}{const} \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{data\PYGZus{}position}\PYG{p}{)} \PYG{k}{override}\PYG{p}{;}

    \PYG{k+kt}{bool} \PYG{n+nf}{getProtracted}\PYG{p}{(}\PYG{p}{)} \PYG{k}{override}\PYG{p}{;}

    \PYG{k+kt}{void} \PYG{n+nf}{setProtractedVariables}\PYG{p}{(}\PYG{k+kt}{double} \PYG{n}{speciation\PYGZus{}gen\PYGZus{}min}\PYG{p}{,} \PYG{k+kt}{double} \PYG{n}{speciation\PYGZus{}gen\PYGZus{}max}\PYG{p}{)} \PYG{k}{override}\PYG{p}{;}

    \PYG{n}{string} \PYG{n+nf}{getProtractedVariables}\PYG{p}{(}\PYG{p}{)} \PYG{k}{override}\PYG{p}{;}

    \PYG{k+kt}{double} \PYG{n+nf}{getProtractedGenerationMin}\PYG{p}{(}\PYG{p}{)} \PYG{k}{override}\PYG{p}{;}

    \PYG{k+kt}{double} \PYG{n+nf}{getProtractedGenerationMax}\PYG{p}{(}\PYG{p}{)} \PYG{k}{override}\PYG{p}{;}

    \PYG{n}{string} \PYG{n+nf}{protractedVarsToString}\PYG{p}{(}\PYG{p}{)} \PYG{k}{override}\PYG{p}{;}

    \PYG{k+kt}{void} \PYG{n+nf}{applySpecRate}\PYG{p}{(}\PYG{k+kt}{double} \PYG{n}{sr}\PYG{p}{,} \PYG{k+kt}{double} \PYG{n}{t}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}

\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif }\PYG{c+c1}{// PROTRACTED\PYGZus{}SPATIAL\PYGZus{}TREE\PYGZus{}H}
\end{sphinxVerbatim}


\subsubsection{Detailed Description}
\label{\detokenize{api/file_necsim_ProtractedTree.h:detailed-description}}
Contains the {\hyperref[\detokenize{api/class_ProtractedTree:class-protractedtree}]{\sphinxcrossref{\DUrole{std,std-ref}{Class ProtractedTree}}}} class for running simulations and outputting the phylogenetic trees using protracted speciation.
Sam Thompson
Contact: \sphinxhref{mailto:samuel.thompson14@imperial.ac.uk}{samuel.thompson14@imperial.ac.uk} or \sphinxhref{mailto:thompsonsed@gmail.com}{thompsonsed@gmail.com} BSD-3 Licence.


\subsubsection{Includes}
\label{\detokenize{api/file_necsim_ProtractedTree.h:includes}}\begin{itemize}
\item {} 
\sphinxcode{SpatialTree.h} ({\hyperref[\detokenize{api/file_necsim_ProtractedSpatialTree.h:file-necsim-protractedspatialtree-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File ProtractedSpatialTree.h}}}})

\item {} 
\sphinxcode{string}

\item {} 
\sphinxcode{vector}

\end{itemize}


\subsubsection{Included By}
\label{\detokenize{api/file_necsim_ProtractedTree.h:included-by}}\begin{itemize}
\item {} 
{\hyperref[\detokenize{api/file_necsim_ProtractedSpatialTree.h:file-necsim-protractedspatialtree-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File ProtractedSpatialTree.h}}}}

\item {} 
{\hyperref[\detokenize{api/file_necsim_ProtractedTree.cpp:file-necsim-protractedtree-cpp}]{\sphinxcrossref{\DUrole{std,std-ref}{File ProtractedTree.cpp}}}}

\end{itemize}


\subsubsection{Classes}
\label{\detokenize{api/file_necsim_ProtractedTree.h:classes}}\begin{itemize}
\item {} 
{\hyperref[\detokenize{api/class_ProtractedTree:class-protractedtree}]{\sphinxcrossref{\DUrole{std,std-ref}{Class ProtractedTree}}}}

\end{itemize}


\subsection{File PyLogging.cpp}
\label{\detokenize{api/file_PyLogging.cpp:id1}}\label{\detokenize{api/file_PyLogging.cpp::doc}}\label{\detokenize{api/file_PyLogging.cpp:file-pylogging-cpp}}
Routines for writing to python logging module.

\begin{sphinxShadowBox}
\sphinxstyletopictitle{Contents}
\begin{itemize}
\item {} 
\phantomsection\label{\detokenize{api/file_PyLogging.cpp:id2}}{\hyperref[\detokenize{api/file_PyLogging.cpp:definition-pylogging-cpp}]{\sphinxcrossref{Definition (\sphinxcode{PyLogging.cpp})}}}

\item {} 
\phantomsection\label{\detokenize{api/file_PyLogging.cpp:id3}}{\hyperref[\detokenize{api/file_PyLogging.cpp:detailed-description}]{\sphinxcrossref{Detailed Description}}}

\item {} 
\phantomsection\label{\detokenize{api/file_PyLogging.cpp:id4}}{\hyperref[\detokenize{api/file_PyLogging.cpp:includes}]{\sphinxcrossref{Includes}}}

\item {} 
\phantomsection\label{\detokenize{api/file_PyLogging.cpp:id5}}{\hyperref[\detokenize{api/file_PyLogging.cpp:functions}]{\sphinxcrossref{Functions}}}

\item {} 
\phantomsection\label{\detokenize{api/file_PyLogging.cpp:id6}}{\hyperref[\detokenize{api/file_PyLogging.cpp:defines}]{\sphinxcrossref{Defines}}}

\end{itemize}
\end{sphinxShadowBox}


\subsubsection{Definition (\sphinxstyleliteralintitle{PyLogging.cpp})}
\label{\detokenize{api/file_PyLogging.cpp:definition-pylogging-cpp}}

\paragraph{Program Listing for File PyLogging.cpp}
\label{\detokenize{api/program_listing_file_PyLogging.cpp::doc}}\label{\detokenize{api/program_listing_file_PyLogging.cpp:program-listing-for-file-pylogging-cpp}}\label{\detokenize{api/program_listing_file_PyLogging.cpp:program-listing-file-pylogging-cpp}}\begin{itemize}
\item {} 
Return to documentation for {\hyperref[\detokenize{api/file_PyLogging.cpp:file-pylogging-cpp}]{\sphinxcrossref{\DUrole{std,std-ref}{File PyLogging.cpp}}}}

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{//This file is part of NECSim project which is released under BSD\PYGZhy{}3 license.}
\PYG{c+c1}{//See file **LICENSE.txt** or visit https://opensource.org/licenses/BSD\PYGZhy{}3\PYGZhy{}Clause) for full license details.}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifndef PYTHON\PYGZus{}COMPILE}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define PYTHON\PYGZus{}COMPILE}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}Python.h\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}string\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}sstream\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZdq{}necsim/Logging.h\PYGZdq{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZdq{}PyLogging.h\PYGZdq{}}

\PYG{k+kt}{void} \PYG{n+nf}{writeInfo}\PYG{p}{(}\PYG{n}{string} \PYG{n}{message}\PYG{p}{)}
\PYG{p}{\PYGZob{}}

    \PYG{n}{write\PYGZus{}log}\PYG{p}{(}\PYG{l+m+mi}{20}\PYG{p}{,} \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{move}\PYG{p}{(}\PYG{n}{message}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{void} \PYG{n+nf}{writeWarning}\PYG{p}{(}\PYG{n}{string} \PYG{n}{message}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{n}{write\PYGZus{}log}\PYG{p}{(}\PYG{l+m+mi}{30}\PYG{p}{,} \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{move}\PYG{p}{(}\PYG{n}{message}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{void} \PYG{n+nf}{writeError}\PYG{p}{(}\PYG{n}{string} \PYG{n}{message}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{n}{write\PYGZus{}log}\PYG{p}{(}\PYG{l+m+mi}{40}\PYG{p}{,} \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{move}\PYG{p}{(}\PYG{n}{message}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{void} \PYG{n+nf}{writeCritical}\PYG{p}{(}\PYG{n}{string} \PYG{n}{message}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{n}{write\PYGZus{}log}\PYG{p}{(}\PYG{l+m+mi}{50}\PYG{p}{,} \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{move}\PYG{p}{(}\PYG{n}{message}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifdef DEBUG}
\PYG{k+kt}{void} \PYG{n+nf}{writeLog}\PYG{p}{(}\PYG{k}{const} \PYG{k+kt}{int} \PYG{o}{\PYGZam{}}\PYG{n}{level}\PYG{p}{,} \PYG{n}{string} \PYG{n}{message}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k}{static} \PYG{n}{LogFile} \PYG{n}{logfile}\PYG{p}{;}
    \PYG{n}{logfile}\PYG{p}{.}\PYG{n}{write}\PYG{p}{(}\PYG{n}{level}\PYG{p}{,} \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{move}\PYG{p}{(}\PYG{n}{message}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{void} \PYG{n+nf}{writeLog}\PYG{p}{(}\PYG{k}{const} \PYG{k+kt}{int} \PYG{o}{\PYGZam{}}\PYG{n}{level}\PYG{p}{,} \PYG{n}{stringstream} \PYG{o}{\PYGZam{}}\PYG{n}{message}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{n}{writeLog}\PYG{p}{(}\PYG{n}{level}\PYG{p}{,} \PYG{n}{message}\PYG{p}{.}\PYG{n}{str}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif }\PYG{c+c1}{// DEBUG}
\PYG{n}{PyObject} \PYG{o}{*} \PYG{n+nf}{set\PYGZus{}log\PYGZus{}function}\PYG{p}{(}\PYG{n}{PyObject} \PYG{o}{*}\PYG{n}{dummy}\PYG{p}{,} \PYG{n}{PyObject} \PYG{o}{*}\PYG{n}{args}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{n}{PyObject} \PYG{o}{*}\PYG{n}{res} \PYG{o}{=} \PYG{k}{nullptr}\PYG{p}{;}
    \PYG{n}{PyObject} \PYG{o}{*}\PYG{n}{temp}\PYG{p}{;}
    \PYG{k}{if}\PYG{p}{(}\PYG{n}{PyArg\PYGZus{}ParseTuple}\PYG{p}{(}\PYG{n}{args}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{O:set\PYGZus{}callback}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{temp}\PYG{p}{)}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{if} \PYG{p}{(}\PYG{o}{!}\PYG{n}{PyCallable\PYGZus{}Check}\PYG{p}{(}\PYG{n}{temp}\PYG{p}{)}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{PyErr\PYGZus{}SetString}\PYG{p}{(}\PYG{n}{PyExc\PYGZus{}TypeError}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{parameter must be callable}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
            \PYG{k}{return} \PYG{k}{nullptr}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{n}{Py\PYGZus{}XINCREF}\PYG{p}{(}\PYG{n}{temp}\PYG{p}{)}\PYG{p}{;}         \PYG{c+cm}{/* Add a reference to new callback */}

        \PYG{n}{Py\PYGZus{}XDECREF}\PYG{p}{(}\PYG{n}{call\PYGZus{}logging}\PYG{p}{)}\PYG{p}{;}  \PYG{c+cm}{/* Dispose of previous callback */}
        \PYG{n}{call\PYGZus{}logging} \PYG{o}{=} \PYG{n}{temp}\PYG{p}{;}       \PYG{c+cm}{/* Remember new callback */}
        \PYG{c+cm}{/* Boilerplate to return \PYGZdq{}None\PYGZdq{} */}
        \PYG{n}{Py\PYGZus{}INCREF}\PYG{p}{(}\PYG{n}{Py\PYGZus{}None}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{res} \PYG{o}{=} \PYG{n}{Py\PYGZus{}None}\PYG{p}{;}
        \PYG{n}{log\PYGZus{}set} \PYG{o}{=} \PYG{n+nb}{true}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{return} \PYG{n}{res}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{void} \PYG{n+nf}{write\PYGZus{}log}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{level}\PYG{p}{,} \PYG{k+kt}{char} \PYG{o}{*} \PYG{n}{message}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k}{if}\PYG{p}{(}\PYG{n}{PyErr\PYGZus{}CheckSignals}\PYG{p}{(}\PYG{p}{)}\PYG{o}{!}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{throw} \PYG{n}{runtime\PYGZus{}error}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Keyboard interrupt detected.}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{n}{PyObject} \PYG{o}{*}\PYG{n}{arglist}\PYG{p}{,} \PYG{o}{*}\PYG{n}{res}\PYG{p}{;}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifdef DEBUG}
    \PYG{k}{if}\PYG{p}{(}\PYG{o}{!}\PYG{n}{logger\PYGZus{}set}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{throw} \PYG{n}{runtime\PYGZus{}error}\PYG{p}{(}
            \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Logger object has not been set. Check set\PYGZus{}logging\PYGZus{}function() has been called in python}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{if}\PYG{p}{(}\PYG{n}{logger} \PYG{o}{=}\PYG{o}{=} \PYG{n+nb}{NULL}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{throw} \PYG{n}{invalid\PYGZus{}argument}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Logger object has been deferenced, please report this bug!}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif }\PYG{c+c1}{// DEBUG}
    \PYG{n}{arglist} \PYG{o}{=} \PYG{n}{Py\PYGZus{}BuildValue}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{isO}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{level}\PYG{p}{,} \PYG{n}{message}\PYG{p}{,} \PYG{n}{logger}\PYG{p}{)}\PYG{p}{;}
    \PYG{c+c1}{// Throw different errors if logging function has not been set}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifdef DEBUG}
    \PYG{k}{if}\PYG{p}{(}\PYG{o}{!}\PYG{n}{log\PYGZus{}set}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{throw} \PYG{n}{runtime\PYGZus{}error}\PYG{p}{(}
            \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Logging function has not been set. Check set\PYGZus{}logging\PYGZus{}function() has been called in python}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{if}\PYG{p}{(}\PYG{n}{call\PYGZus{}logging} \PYG{o}{=}\PYG{o}{=} \PYG{n+nb}{NULL}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{Py\PYGZus{}DECREF}\PYG{p}{(}\PYG{n}{arglist}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{throw} \PYG{n}{invalid\PYGZus{}argument}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Logging function has been dereferenced, please report this bug!}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif }\PYG{c+c1}{// DEBUG}
    \PYG{n}{res} \PYG{o}{=} \PYG{n}{PyObject\PYGZus{}CallObject}\PYG{p}{(}\PYG{n}{call\PYGZus{}logging}\PYG{p}{,} \PYG{n}{arglist}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{Py\PYGZus{}DECREF}\PYG{p}{(}\PYG{n}{arglist}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{Py\PYGZus{}XDECREF}\PYG{p}{(}\PYG{n}{res}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{void} \PYG{n+nf}{write\PYGZus{}log}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{level}\PYG{p}{,} \PYG{n}{string} \PYG{n}{message}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k+kt}{char} \PYG{o}{*} \PYG{n}{msg}\PYG{p}{;}
    \PYG{n}{msg} \PYG{o}{=} \PYG{p}{(}\PYG{k+kt}{char}\PYG{o}{*} \PYG{p}{)}\PYG{n}{message}\PYG{p}{.}\PYG{n}{c\PYGZus{}str}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{write\PYGZus{}log}\PYG{p}{(}\PYG{n}{level}\PYG{p}{,} \PYG{n}{msg}\PYG{p}{)}\PYG{p}{;}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifdef DEBUG}
    \PYG{c+c1}{// Also write to the log file \PYGZhy{} stored in logfile.log}
    \PYG{n}{writeLog}\PYG{p}{(}\PYG{n}{level}\PYG{p}{,} \PYG{n}{message}\PYG{p}{)}\PYG{p}{;}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif }\PYG{c+c1}{// DEBUG}
\PYG{p}{\PYGZcb{}}

\PYG{n}{PyObject} \PYG{o}{*} \PYG{n+nf}{set\PYGZus{}logger}\PYG{p}{(}\PYG{n}{PyObject} \PYG{o}{*} \PYG{n}{self}\PYG{p}{,} \PYG{n}{PyObject} \PYG{o}{*} \PYG{n}{args}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{n}{PyObject} \PYG{o}{*} \PYG{n}{tmplogger}\PYG{p}{;}
    \PYG{k}{if}\PYG{p}{(}\PYG{o}{!}\PYG{n}{PyArg\PYGZus{}ParseTuple}\PYG{p}{(}\PYG{n}{args}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{O}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{tmplogger}\PYG{p}{)}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{return} \PYG{n+nb}{NULL}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{n}{Py\PYGZus{}XINCREF}\PYG{p}{(}\PYG{n}{tmplogger}\PYG{p}{)}\PYG{p}{;}         \PYG{c+cm}{/* Add a reference to new callback */}
    \PYG{n}{Py\PYGZus{}XDECREF}\PYG{p}{(}\PYG{n}{logger}\PYG{p}{)}\PYG{p}{;}  \PYG{c+cm}{/* Dispose of previous callback */}
    \PYG{n}{logger} \PYG{o}{=} \PYG{n}{tmplogger}\PYG{p}{;}       \PYG{c+cm}{/* Remember new callback */}
    \PYG{c+cm}{/* Boilerplate to return \PYGZdq{}None\PYGZdq{} */}
    \PYG{n}{Py\PYGZus{}INCREF}\PYG{p}{(}\PYG{n}{Py\PYGZus{}None}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{logger\PYGZus{}set} \PYG{o}{=} \PYG{n+nb}{true}\PYG{p}{;}
    \PYG{n}{Py\PYGZus{}RETURN\PYGZus{}NONE}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}


\subsubsection{Detailed Description}
\label{\detokenize{api/file_PyLogging.cpp:detailed-description}}
Sam Thompson
BSD-3 Licence.


\subsubsection{Includes}
\label{\detokenize{api/file_PyLogging.cpp:includes}}\begin{itemize}
\item {} 
\sphinxcode{PyLogging.h} ({\hyperref[\detokenize{api/file_PyLogging.h:file-pylogging-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File PyLogging.h}}}})

\item {} 
\sphinxcode{Python.h}

\item {} 
\sphinxcode{necsim/Logging.h} ({\hyperref[\detokenize{api/file_necsim_Logging.h:file-necsim-logging-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File Logging.h}}}})

\item {} 
\sphinxcode{sstream}

\item {} 
\sphinxcode{string}

\end{itemize}


\subsubsection{Functions}
\label{\detokenize{api/file_PyLogging.cpp:functions}}\begin{itemize}
\item {} 
{\hyperref[\detokenize{api/function_set_log_function:function-set-log-function}]{\sphinxcrossref{\DUrole{std,std-ref}{Function set\_log\_function}}}}

\item {} 
{\hyperref[\detokenize{api/function_set_logger:function-set-logger}]{\sphinxcrossref{\DUrole{std,std-ref}{Function set\_logger}}}}

\item {} 
{\hyperref[\detokenize{api/function_write_log:function-write-log}]{\sphinxcrossref{\DUrole{std,std-ref}{Function write\_log}}}}

\item {} 
{\hyperref[\detokenize{api/function_write_log:function-write-log}]{\sphinxcrossref{\DUrole{std,std-ref}{Function write\_log}}}}

\item {} 
{\hyperref[\detokenize{api/function_writeCritical:function-writecritical}]{\sphinxcrossref{\DUrole{std,std-ref}{Function writeCritical}}}}

\item {} 
{\hyperref[\detokenize{api/function_writeError:function-writeerror}]{\sphinxcrossref{\DUrole{std,std-ref}{Function writeError}}}}

\item {} 
{\hyperref[\detokenize{api/function_writeInfo:function-writeinfo}]{\sphinxcrossref{\DUrole{std,std-ref}{Function writeInfo}}}}

\item {} 
{\hyperref[\detokenize{api/function_writeWarning:function-writewarning}]{\sphinxcrossref{\DUrole{std,std-ref}{Function writeWarning}}}}

\end{itemize}


\subsubsection{Defines}
\label{\detokenize{api/file_PyLogging.cpp:defines}}\begin{itemize}
\item {} 
{\hyperref[\detokenize{api/define_PYTHON_COMPILE:define-python-compile}]{\sphinxcrossref{\DUrole{std,std-ref}{Define PYTHON\_COMPILE}}}}

\end{itemize}


\subsection{File PyLogging.h}
\label{\detokenize{api/file_PyLogging.h::doc}}\label{\detokenize{api/file_PyLogging.h:file-pylogging-h}}\label{\detokenize{api/file_PyLogging.h:id1}}
Routines for writing to python logging module.

\begin{sphinxShadowBox}
\sphinxstyletopictitle{Contents}
\begin{itemize}
\item {} 
\phantomsection\label{\detokenize{api/file_PyLogging.h:id2}}{\hyperref[\detokenize{api/file_PyLogging.h:definition-pylogging-h}]{\sphinxcrossref{Definition (\sphinxcode{PyLogging.h})}}}

\item {} 
\phantomsection\label{\detokenize{api/file_PyLogging.h:id3}}{\hyperref[\detokenize{api/file_PyLogging.h:detailed-description}]{\sphinxcrossref{Detailed Description}}}

\item {} 
\phantomsection\label{\detokenize{api/file_PyLogging.h:id4}}{\hyperref[\detokenize{api/file_PyLogging.h:includes}]{\sphinxcrossref{Includes}}}

\item {} 
\phantomsection\label{\detokenize{api/file_PyLogging.h:id5}}{\hyperref[\detokenize{api/file_PyLogging.h:included-by}]{\sphinxcrossref{Included By}}}

\item {} 
\phantomsection\label{\detokenize{api/file_PyLogging.h:id6}}{\hyperref[\detokenize{api/file_PyLogging.h:functions}]{\sphinxcrossref{Functions}}}

\item {} 
\phantomsection\label{\detokenize{api/file_PyLogging.h:id7}}{\hyperref[\detokenize{api/file_PyLogging.h:variables}]{\sphinxcrossref{Variables}}}

\end{itemize}
\end{sphinxShadowBox}


\subsubsection{Definition (\sphinxstyleliteralintitle{PyLogging.h})}
\label{\detokenize{api/file_PyLogging.h:definition-pylogging-h}}

\paragraph{Program Listing for File PyLogging.h}
\label{\detokenize{api/program_listing_file_PyLogging.h:program-listing-for-file-pylogging-h}}\label{\detokenize{api/program_listing_file_PyLogging.h::doc}}\label{\detokenize{api/program_listing_file_PyLogging.h:program-listing-file-pylogging-h}}\begin{itemize}
\item {} 
Return to documentation for {\hyperref[\detokenize{api/file_PyLogging.h:file-pylogging-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File PyLogging.h}}}}

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{//This file is part of NECSim project which is released under BSD\PYGZhy{}3 license.}
\PYG{c+c1}{//See file **LICENSE.txt** or visit https://opensource.org/licenses/BSD\PYGZhy{}3\PYGZhy{}Clause) for full license details.}

\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifndef PYLOGGING\PYGZus{}H}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define PYLOGGING\PYGZus{}H}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZdq{}Python.h\PYGZdq{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}string\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZdq{}necsim/LogFile.h\PYGZdq{}}

\PYG{k}{extern} \PYG{n}{PyObject} \PYG{o}{*} \PYG{n}{loggingmodule}\PYG{p}{;}
\PYG{k}{extern} \PYG{n}{PyGILState\PYGZus{}STATE} \PYG{n}{gstate}\PYG{p}{;}
\PYG{k}{extern} \PYG{k+kt}{bool} \PYG{n}{log\PYGZus{}set}\PYG{p}{;}
\PYG{k}{extern} \PYG{k+kt}{bool} \PYG{n}{logger\PYGZus{}set}\PYG{p}{;}

\PYG{k}{static} \PYG{n}{PyObject} \PYG{o}{*} \PYG{n}{call\PYGZus{}logging} \PYG{o}{=} \PYG{k}{nullptr}\PYG{p}{;}


\PYG{k}{extern} \PYG{n}{PyObject} \PYG{o}{*}\PYG{n}{logger}\PYG{p}{;}

\PYG{n}{PyObject} \PYG{o}{*} \PYG{n+nf}{set\PYGZus{}log\PYGZus{}function}\PYG{p}{(}\PYG{n}{PyObject} \PYG{o}{*}\PYG{n}{dummy}\PYG{p}{,} \PYG{n}{PyObject} \PYG{o}{*}\PYG{n}{args}\PYG{p}{)}\PYG{p}{;}

\PYG{n}{PyObject} \PYG{o}{*} \PYG{n+nf}{set\PYGZus{}logger}\PYG{p}{(}\PYG{n}{PyObject} \PYG{o}{*} \PYG{n}{self}\PYG{p}{,} \PYG{n}{PyObject} \PYG{o}{*} \PYG{n}{args}\PYG{p}{)}\PYG{p}{;}

\PYG{k+kt}{void} \PYG{n+nf}{write\PYGZus{}log}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{level}\PYG{p}{,} \PYG{k+kt}{char} \PYG{o}{*} \PYG{n}{message}\PYG{p}{)}\PYG{p}{;}

\PYG{k+kt}{void} \PYG{n+nf}{write\PYGZus{}log}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{level}\PYG{p}{,} \PYG{n}{string} \PYG{n}{message}\PYG{p}{)}\PYG{p}{;}

\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif }\PYG{c+c1}{// PYLOGGING\PYGZus{}H}
\end{sphinxVerbatim}


\subsubsection{Detailed Description}
\label{\detokenize{api/file_PyLogging.h:detailed-description}}
Sam Thompson
BSD-3 Licence.


\subsubsection{Includes}
\label{\detokenize{api/file_PyLogging.h:includes}}\begin{itemize}
\item {} 
\sphinxcode{Python.h}

\item {} 
\sphinxcode{necsim/LogFile.h} ({\hyperref[\detokenize{api/file_necsim_LogFile.h:file-necsim-logfile-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File LogFile.h}}}})

\item {} 
\sphinxcode{string}

\end{itemize}


\subsubsection{Included By}
\label{\detokenize{api/file_PyLogging.h:included-by}}\begin{itemize}
\item {} 
{\hyperref[\detokenize{api/file_applyspecmodule.cpp:file-applyspecmodule-cpp}]{\sphinxcrossref{\DUrole{std,std-ref}{File applyspecmodule.cpp}}}}

\item {} 
{\hyperref[\detokenize{api/file_dispersalmodule.cpp:file-dispersalmodule-cpp}]{\sphinxcrossref{\DUrole{std,std-ref}{File dispersalmodule.cpp}}}}

\item {} 
{\hyperref[\detokenize{api/file_necsimmodule.cpp:file-necsimmodule-cpp}]{\sphinxcrossref{\DUrole{std,std-ref}{File necsimmodule.cpp}}}}

\item {} 
{\hyperref[\detokenize{api/file_PyLogging.cpp:file-pylogging-cpp}]{\sphinxcrossref{\DUrole{std,std-ref}{File PyLogging.cpp}}}}

\end{itemize}


\subsubsection{Functions}
\label{\detokenize{api/file_PyLogging.h:functions}}\begin{itemize}
\item {} 
{\hyperref[\detokenize{api/function_set_log_function:function-set-log-function}]{\sphinxcrossref{\DUrole{std,std-ref}{Function set\_log\_function}}}}

\item {} 
{\hyperref[\detokenize{api/function_set_logger:function-set-logger}]{\sphinxcrossref{\DUrole{std,std-ref}{Function set\_logger}}}}

\item {} 
{\hyperref[\detokenize{api/function_write_log:function-write-log}]{\sphinxcrossref{\DUrole{std,std-ref}{Function write\_log}}}}

\item {} 
{\hyperref[\detokenize{api/function_write_log:function-write-log}]{\sphinxcrossref{\DUrole{std,std-ref}{Function write\_log}}}}

\end{itemize}


\subsubsection{Variables}
\label{\detokenize{api/file_PyLogging.h:variables}}\begin{itemize}
\item {} 
{\hyperref[\detokenize{api/variable_call_logging:variable-call-logging}]{\sphinxcrossref{\DUrole{std,std-ref}{Variable call\_logging}}}}

\item {} 
{\hyperref[\detokenize{api/variable_gstate:variable-gstate}]{\sphinxcrossref{\DUrole{std,std-ref}{Variable gstate}}}}

\item {} 
{\hyperref[\detokenize{api/variable_log_set:variable-log-set}]{\sphinxcrossref{\DUrole{std,std-ref}{Variable log\_set}}}}

\item {} 
{\hyperref[\detokenize{api/variable_logger:variable-logger}]{\sphinxcrossref{\DUrole{std,std-ref}{Variable logger}}}}

\item {} 
{\hyperref[\detokenize{api/variable_logger_set:variable-logger-set}]{\sphinxcrossref{\DUrole{std,std-ref}{Variable logger\_set}}}}

\item {} 
{\hyperref[\detokenize{api/variable_loggingmodule:variable-loggingmodule}]{\sphinxcrossref{\DUrole{std,std-ref}{Variable loggingmodule}}}}

\end{itemize}


\subsection{File README.md}
\label{\detokenize{api/file_necsim_README.md::doc}}\label{\detokenize{api/file_necsim_README.md:file-necsim-readme-md}}\label{\detokenize{api/file_necsim_README.md:file-readme-md}}
\begin{sphinxShadowBox}
\sphinxstyletopictitle{Contents}
\begin{itemize}
\item {} 
\phantomsection\label{\detokenize{api/file_necsim_README.md:id1}}{\hyperref[\detokenize{api/file_necsim_README.md:definition-necsim-readme-md}]{\sphinxcrossref{Definition (\sphinxcode{necsim/README.md})}}}

\end{itemize}
\end{sphinxShadowBox}


\subsubsection{Definition (\sphinxstyleliteralintitle{necsim/README.md})}
\label{\detokenize{api/file_necsim_README.md:definition-necsim-readme-md}}

\paragraph{Program Listing for File README.md}
\label{\detokenize{api/program_listing_file_necsim_README.md:program-listing-for-file-readme-md}}\label{\detokenize{api/program_listing_file_necsim_README.md::doc}}\label{\detokenize{api/program_listing_file_necsim_README.md:program-listing-file-necsim-readme-md}}\begin{itemize}
\item {} 
Return to documentation for {\hyperref[\detokenize{api/file_necsim_README.md:file-necsim-readme-md}]{\sphinxcrossref{\DUrole{std,std-ref}{File README.md}}}}

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZsh{} necsim \PYGZsh{}

Version: 1.0
This project is released under BSD\PYGZhy{}3
See file **LICENSE.txt** or go to [here](https://opensource.org/licenses/BSD\PYGZhy{}3\PYGZhy{}Clause) for full license details.

\PYGZsh{}\PYGZsh{} CONTENTS \PYGZsh{}\PYGZsh{}
* **INTRODUCTION**
* **INSTRUCTIONS**
* **REQUIREMENTS**
* **DEGUGGING**
* **CLASS DESCRIPTIONS**
* **KNOWN BUGS**
* **FAQS**
* **CONTACTS**

\PYGZsh{}\PYGZsh{} INTRODUCTION \PYGZsh{}\PYGZsh{}

necsim is a generic spatial coalescence simulator for neutral systems. It applies the model to map objects, which can change over time, for a specific set of supplied parameters, and outputs information for each individual to a SQL database.

necsim includes functionality for applying varying speciation rates after simulations are complete. This enables the main simulation to be run with the *minimum* speciation rate required and afterwards analysis can be completed using different speciation rates.

The recommended method of usage is through the pycoalescence package, using a python interface for installation, simulation setup and running. See [here](http://pycoalescence.readthedocs.io/) for more details.

You are free to modify and distribute the code as per the license specified in **LICENCE.txt** to suit any additional neutral simulation requirements (or any other purpose).

\PYGZsh{}\PYGZsh{} INSTRUCTIONS \PYGZsh{}\PYGZsh{}
\PYGZsh{}\PYGZsh{}\PYGZsh{}Compiling the program\PYGZsh{}\PYGZsh{}\PYGZsh{}
See the Requirements section for a full list of the necessary prerequisites. Once these are installed, compiling the program should be relatively easy. NECSim requires a linker to the boost libraries, as well as the sqlite3 library. It is recommended to run with the maximum optimisation possible.


Additionally, if support is required for tif files (an alternative to importing csv files), the [gdal library](http://www.gdal.org/) is required. See the online documentation for help compiling gdal for your operating system. When compiling using gdal, use the {}`{}`{}`\PYGZhy{}D with\PYGZus{}gdal{}`{}`{}` compilation flag.

For compilation on High Performance Computing (HPC) systems, they will likely use intel compilers. The header files for the sqlite and boost packages may need to be copied in to the working directory to avoid problems with linking to libraries. Check the service providers\PYGZsq{} documentation for whether these libraries are already installed on the HPC.
for the application of different speciation rates.

\PYGZsh{}\PYGZsh{}\PYGZsh{}Running simulations\PYGZsh{}\PYGZsh{}\PYGZsh{}
The routine relies on supplying command line arguments (see below) for all the major simulation variables. Alternatively, supplying a config .txt file and using the command line arguments {}`./necsim \PYGZhy{}c /path/to/config.txt{}` can be used for parsing command line arguments from the text file.

\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}Command Line Arguments \PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}
The following command line arguments are required. This list can be accessed by running {}`./necsim \PYGZhy{}h{}` or {}`./necsim \PYGZhy{}help{}`

The command line options to be specified are:

1. the seed for the simulation.
2. the simulation task (for file reference).
3. the map config file.
4. the output directory.
5. the minimum speciation rate.
6. the dispersal sigma value.
7. the dispersal tau value.
8. the deme size.
9. the deme sample size.
10. the maximum simulation time (in seconds).
11. the lambda value for moving through non\PYGZhy{}habitat.
12. the temporal sampling file containing tab\PYGZhy{}separated generation values for sampling points in time (null for only sampling the present)
13. the minimum number of species known to exist. (Currently has no effect).
14. (and onwards) speciation rates to apply after simulation.

In this set up, the map config file contains a file on each line, with tab separation between the different variables. The \PYGZdq{}ref\PYGZdq{} flag contains the object type, followed by all other parameters. An example is given below.

ref=sample\PYGZus{}grid path=/path/to/file  x=100   y=200   mask=/path/to/mask
ref=fine\PYGZus{}map    path=/path/to/file  x=100   y=200   x\PYGZus{}off=10    y\PYGZus{}off=20
ref=pristine\PYGZus{}fine   path=/path/to/file  number=n    rate=r  time=g

Alternatively, by specifying the \PYGZhy{}f flag, (full mode) as the first argument, the program can read in extended command line arguments, which are as followed.

1. the task\PYGZus{}iter used for setting the seed.
2. the sample grid x dimension
3. the sample grid y dimension
4. the fine map file relative path.
5. the fine map x dimension
6. the fine map y dimension
7. the fine map x offset
8. the fine map y offset
9. the coarse map file relative path.
10. the coarse map x dimension
11. the coarse map y dimension
12. the coarse map x offset
13. the coarse map y offset
14. the scale of the coarse map compared to the fine (10 means resolution of coarse map = 10 x resolution of fine map)
15. the output directory
16. the speciation rate.
17. the dispersal sigma value.
18. the deme size
19. the deme sample size (as a proportion of deme size)
20. the time to run the simulation (in seconds).
21. lambda \PYGZhy{} the relative cost of moving through non\PYGZhy{}forest
22. the\PYGZus{}task \PYGZhy{} for referencing the specific task later on.
23. the minimum number of species the system is known to contain.
24. the pristine fine map file to use
25. the pristine coarse map file to use
26. the rate of forest change from pristine
27. the time (in generations) since the pristine forest was seen.
28. the dispersal tau value (the width of the kernel.
29. the sample mask, with binary 1:0 values for areas that we want to sample from. If this is not provided then this will default to mapping the whole area.
30.  the link to the file containing every generation that the list should be expanded. This should be in the format of a list.
31. (and onwards) \PYGZhy{} speciation rates to apply after the simulation is complete.

\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}Config Files \PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}
The program also accepts a config file, specified by running {}`./necsim \PYGZhy{}c /path/to/config.txt{}`. The format of the config file is
{}`{}`{}`
rand\PYGZus{}seed = i
sample\PYGZus{}x\PYGZus{}dim = i
sample\PYGZus{}y\PYGZus{}dim = i
fine\PYGZus{}source = /path/to/fine.csv
fine\PYGZus{}x\PYGZus{}dim = i
fine\PYGZus{}y\PYGZus{}dim = i
fine\PYGZus{}x\PYGZus{}offset = i
fine\PYGZus{}y\PYGZus{}offset = i
coarse\PYGZus{}source = /path/to/coarse.csv
coarse\PYGZus{}x\PYGZus{}dim = i
coarse\PYGZus{}y\PYGZus{}dim = i
coarse\PYGZus{}x\PYGZus{}offset = i
coarse\PYGZus{}y\PYGZus{}offset = i
coarse\PYGZus{}scale = i
output\PYGZus{}dir = /path/to/outdir
spec\PYGZus{}rate = d
zfat = f
deme\PYGZus{}size = i
deme\PYGZus{}sample = d
wall\PYGZus{}time = i
lambda = 1
job\PYGZus{}num = i
est\PYGZus{}spec = i
pristine\PYGZus{}fine\PYGZus{}source = /path/to/pristine/fine.csv
pristine\PYGZus{}coarse\PYGZus{}source = /path/to/pristine/coarse.csv
forest\PYGZus{}change = d
time\PYGZus{}since = f
dispersal = f
sampledatamask = /path/to/sample/mask.csv
time\PYGZus{}config\PYGZus{}file = /path/to/time/file.txt
speciationrate1 = d
speciationrate2 = d
...
{}`{}`{}`
where {}`i{}` represents a positive integer, {}`d{}` is a decimal value between 0 and 1, and {}`f{}` is any positive number (float). Whilst this does help with readability of the code, the order of the arguments is essential at this stage (i.e. don\PYGZsq{}t switch the order of the lines). Future versions may alter the system of reading such that the parameters are set according to their key. Any number of speciation rates (or 0) can be at the end of the file.

\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}Outputs\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}
Upon successful completion of a simulation, necsim will produce an SQLite database file in the output directory in an SQL\PYGZbs{}\PYGZus{}data folder. This database contains several tables, which can be accessed using a program like [DB Browser for SQLite](http://sqlitebrowser.org/) or Microsoft Access. Alternatively, most programming languages have an SQLite interface ([RSQlite](https://cran.r\PYGZhy{}project.org/web/packages/RSQLite/index.html), [python sqlite3](https://docs.python.org/2/library/sqlite3.html))

* The main table within the database is the SPECIES\PYGZbs{}\PYGZus{}LIST table, which is the location and inheritence of every lineage recorded. Several other important data structures (such as whether it is a \PYGZdq{}tip\PYGZdq{} of the phylogenetic tree of not) which are used  when re\PYGZhy{}constructing the species identity.
* A secondary output from necims is a SIMULATION\PYGZbs{}\PYGZus{}PARAMETERS table for identifying the exact parameters with which the model is run.
* SpeciationCounter also produces a SPECIES\PYGZus{}ABUNDANCES table containing species abundances across the whole sample map, plus (optionally) a table of SPECIES\PYGZbs{}\PYGZus{}LOCATIONS (containing the x,y location of every individual) and FRAGMENT\PYGZbs{}\PYGZus{}ABUNDANCES (species abundances for each habitat fragment separately).

\PYGZsh{}\PYGZsh{} REQUIREMENTS \PYGZsh{}\PYGZsh{}
* The SQLite library available [here](https://www.sqlite.org/download.html).
* The Boost library available [here](http://www.boost.org).
* The fast\PYGZhy{}cpp\PYGZhy{}csv\PYGZhy{}parser by Ben Strasser, available [here](https://github.com/ben\PYGZhy{}strasser/fast\PYGZhy{}cpp\PYGZhy{}csv\PYGZhy{}parser).
* C++ compiler (such as GNU g++) with C++11 support.
* Access to the relevant folders for Default simulations (see FAQS).


\PYGZsh{}\PYGZsh{} CLASS DESCRIPTIONS \PYGZsh{}\PYGZsh{}


A brief description of the important classes is given below. Some classes also contain customised exceptions for better tracing of error handling.

* The {}`Tree{}` class.
    \PYGZhy{} The most important class!
    \PYGZhy{} Contains the main setup, run and data output routines.
    \PYGZhy{} Setup imports the data files from csv (if necessary) and creates the in\PYGZhy{}memory objects for the storing of the coalescence tree and the spatial grid of active lineages. Setup time mostly depends on the size of the csv file being imported.
    \PYGZhy{} Run continually loops over sucessive coalesence, move or speciation events until all individuals have speciated or coalesced. This is where the majority of the simulation time will be, and is mostly dependent on the number of individuals, speciation rate and size of the spatial grid.
    \PYGZhy{} At the end of the simulation, the sqlCreate() routine will generate the in\PYGZhy{}memory SQLite database for storing the coalescent tree. It can run multiple times if multiple speciation rates are required. outputData() will then be called to create a small csv file containing important information, and output the SQLite database to file if required.
* The {}`TreeNode{}` class
    \PYGZhy{} Contains a single record of a node on the phylogenetic tree, to be used in reassembling the tree structure at the end of the simulation.
    \PYGZhy{} Operations are mostly basic getters and setters, with functionality called from higher\PYGZhy{}level functions.
    \PYGZhy{} An array of treenodes makes up the {}`data{}` object in {}`Tree{}`.
* The {}`DataPoint{}` class
    \PYGZhy{} Contains a single record of the location of a lineage.
    \PYGZhy{} An array of datapoints makes up the {}`active{}` object in {}`Tree{}`.
    \PYGZhy{} {}`endactive{}` refers to the number of lineages currently being simulated. After each coalescence or speciation event this will decrease.
* The {}`NRrand{}` class
    \PYGZhy{} Contains the random number generator, as written by James Rosindell (j.rosindell@imperial.ac.uk).
* The {}`Map{}` class
    \PYGZhy{} Contains the routines for importing and calling values from the map objects.
    \PYGZhy{} The {}`getVal(){}` and {}`runDispersal(){}` functions can be modified to produce altered dispersal behaviour, or alterations to the structure of the map.
* The {}`Matrix{}` and {}`Row{}` classes
    \PYGZhy{} Based on code written by James Rosindell (j.rosindell@imperial.ac.uk).
    \PYGZhy{} Handles indexing of the 2D object plus importing values from a csv file.
* The {}`SpeciesList{}` class
    \PYGZhy{} Contains the list of individuals, for application in a matrix, to essentially create a 3D array.
    \PYGZhy{} Handles the positioning of individuals in space within a grid cell.
* The {}`ConfigOption{}` class
    \PYGZhy{} Contains basic functions for importing command line arguments from a config file, providing an alternative way of setting up simulations.
* The {}`TreeList{}` class
     \PYGZhy{} Provides the routines for applying different speciation rates to a phylogenetic tree, to be used either immediately after simulation within necsim, or at a later time using SpeciationCounter.cpp

\PYGZsh{}\PYGZsh{} KNOWN BUGS \PYGZsh{}\PYGZsh{}
* Simulations run until completion, rather than aiming for a desired number of species. This is an intentional change. Functions related to this functionality remain but are deprecated.
* Only continuous rectangular fragments are properly calculated. Other shapes must be calculated by post\PYGZhy{}processing.
* 3 fragments instead of 2 will be calculated for certain adjacent rectangular patches.

\PYGZsh{}\PYGZsh{} FAQS (WIP) \PYGZsh{}\PYGZsh{}
* **How do I get started?**
    \PYGZhy{} It is recommended to use the [pycoalescence](http://pycoalescence.readthedocs.io/) package which simplifies installation of necsim, setting up and running simulations. This provides a much easier way to get started with necsim.

* **Why cant I compile the program?**
    \PYGZhy{} This could be due to a number of reasons, most likely that you havent compiled with access to the lsqlite3 or boost packages. Installation and compilation differs across different systems; for most UNIX systems, compiling with the linker arguments \PYGZhy{}lsqlite3 \PYGZhy{}lboost\PYGZus{}filesystem and \PYGZhy{}lboost\PYGZus{}system will solve problems with the compiler not finding the sqlite or boost header file.
    \PYGZhy{} Another option could be the potential lack of access to the fast\PYGZhy{}cpp\PYGZhy{}csv\PYGZhy{}parser by Ben Strasser, available [here](https://github.com/ben\PYGZhy{}strasser/fast\PYGZhy{}cpp\PYGZhy{}csv\PYGZhy{}parser). If use\PYGZbs{}\PYGZus{}csv has been defined at the head of the file, try without use\PYGZus{}csv or download the csv parser and locate the folder within your working directory at compilation.


* **Every time the program runs I get error code XXX.**
    \PYGZhy{} Check the ERROR\PYGZus{}REF.txt file for descriptions of the files. Try running in debug mode by compiling with {}`{}`{}`\PYGZhy{}DDEBUG{}`{}`{}` to gain more information on the problem. Check the log output in /logs. It is most likely a problem with the set up of the map data (error checking is not yet properly implemented here).

\PYGZsh{}\PYGZsh{} CONTACTS\PYGZsh{}\PYGZsh{}
Author: **Samuel Thompson**

Contact: samuelthompson14@imperial.ac.uk \PYGZhy{} thompsonsed@gmail.com

Institution: Imperial College London and National University of Singapore

Based heavily on code by **James Rosindell**

Contact: j.rosindell@imperial.ac.uk

Institution: Imperial College London
\end{sphinxVerbatim}


\subsection{File ReproductionMap.cpp}
\label{\detokenize{api/file_necsim_ReproductionMap.cpp:file-necsim-reproductionmap-cpp}}\label{\detokenize{api/file_necsim_ReproductionMap.cpp::doc}}\label{\detokenize{api/file_necsim_ReproductionMap.cpp:file-reproductionmap-cpp}}
Contains the {\hyperref[\detokenize{api/class_ReproductionMap:class-reproductionmap}]{\sphinxcrossref{\DUrole{std,std-ref}{Class ReproductionMap}}}}, which inherits from {\hyperref[\detokenize{api/class_Matrix:template-class-matrix}]{\sphinxcrossref{\DUrole{std,std-ref}{Template Class Matrix}}}} and adds a few extra parameters.

\begin{sphinxShadowBox}
\sphinxstyletopictitle{Contents}
\begin{itemize}
\item {} 
\phantomsection\label{\detokenize{api/file_necsim_ReproductionMap.cpp:id1}}{\hyperref[\detokenize{api/file_necsim_ReproductionMap.cpp:definition-necsim-reproductionmap-cpp}]{\sphinxcrossref{Definition (\sphinxcode{necsim/ReproductionMap.cpp})}}}

\item {} 
\phantomsection\label{\detokenize{api/file_necsim_ReproductionMap.cpp:id2}}{\hyperref[\detokenize{api/file_necsim_ReproductionMap.cpp:detailed-description}]{\sphinxcrossref{Detailed Description}}}

\item {} 
\phantomsection\label{\detokenize{api/file_necsim_ReproductionMap.cpp:id3}}{\hyperref[\detokenize{api/file_necsim_ReproductionMap.cpp:includes}]{\sphinxcrossref{Includes}}}

\end{itemize}
\end{sphinxShadowBox}


\subsubsection{Definition (\sphinxstyleliteralintitle{necsim/ReproductionMap.cpp})}
\label{\detokenize{api/file_necsim_ReproductionMap.cpp:definition-necsim-reproductionmap-cpp}}

\paragraph{Program Listing for File ReproductionMap.cpp}
\label{\detokenize{api/program_listing_file_necsim_ReproductionMap.cpp:program-listing-file-necsim-reproductionmap-cpp}}\label{\detokenize{api/program_listing_file_necsim_ReproductionMap.cpp:program-listing-for-file-reproductionmap-cpp}}\label{\detokenize{api/program_listing_file_necsim_ReproductionMap.cpp::doc}}\begin{itemize}
\item {} 
Return to documentation for {\hyperref[\detokenize{api/file_necsim_ReproductionMap.cpp:file-necsim-reproductionmap-cpp}]{\sphinxcrossref{\DUrole{std,std-ref}{File ReproductionMap.cpp}}}}

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{//This file is part of NECSim project which is released under BSD\PYGZhy{}3 license.}
\PYG{c+c1}{//See file **LICENSE.txt** or visit https://opensource.org/licenses/BSD\PYGZhy{}3\PYGZhy{}Clause) for full license details.}

\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZdq{}ReproductionMap.h\PYGZdq{}}

\PYG{k+kt}{void} \PYG{n}{ReproductionMap}\PYG{o}{:}\PYG{o}{:}\PYG{n}{import}\PYG{p}{(}\PYG{n}{string} \PYG{n}{file\PYGZus{}name}\PYG{p}{,} \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{size\PYGZus{}x}\PYG{p}{,} \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{size\PYGZus{}y}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{n}{map\PYGZus{}file} \PYG{o}{=} \PYG{n}{file\PYGZus{}name}\PYG{p}{;}
    \PYG{k}{if}\PYG{p}{(}\PYG{n}{file\PYGZus{}name} \PYG{o}{=}\PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{null}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\textbar{}}\PYG{o}{\textbar{}} \PYG{n}{file\PYGZus{}name} \PYG{o}{=}\PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{none}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{null\PYGZus{}map} \PYG{o}{=} \PYG{n+nb}{true}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{else}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{null\PYGZus{}map} \PYG{o}{=} \PYG{n+nb}{false}\PYG{p}{;}
        \PYG{n}{reproduction\PYGZus{}map}\PYG{p}{.}\PYG{n}{SetSize}\PYG{p}{(}\PYG{n}{size\PYGZus{}y}\PYG{p}{,} \PYG{n}{size\PYGZus{}x}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{reproduction\PYGZus{}map}\PYG{p}{.}\PYG{n}{import}\PYG{p}{(}\PYG{n}{file\PYGZus{}name}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{y} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{y} \PYG{o}{\PYGZlt{}} \PYG{n}{reproduction\PYGZus{}map}\PYG{p}{.}\PYG{n}{GetRows}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{n}{y}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{x} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{x} \PYG{o}{\PYGZlt{}} \PYG{n}{reproduction\PYGZus{}map}\PYG{p}{.}\PYG{n}{GetCols}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{n}{x}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{k}{if}\PYG{p}{(}\PYG{n}{reproduction\PYGZus{}map}\PYG{p}{[}\PYG{n}{y}\PYG{p}{]}\PYG{p}{[}\PYG{n}{x}\PYG{p}{]} \PYG{o}{\PYGZgt{}} \PYG{n}{max\PYGZus{}val}\PYG{p}{)}
                \PYG{p}{\PYGZob{}}
                    \PYG{n}{max\PYGZus{}val} \PYG{o}{=} \PYG{n}{reproduction\PYGZus{}map}\PYG{p}{[}\PYG{n}{y}\PYG{p}{]}\PYG{p}{[}\PYG{n}{x}\PYG{p}{]}\PYG{p}{;}
                \PYG{p}{\PYGZcb{}}
            \PYG{p}{\PYGZcb{}}
        \PYG{p}{\PYGZcb{}}
    \PYG{p}{\PYGZcb{}}
    \PYG{n}{setReproductionFunction}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{void} \PYG{n}{ReproductionMap}\PYG{o}{:}\PYG{o}{:}\PYG{n}{setReproductionFunction}\PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k}{if}\PYG{p}{(}\PYG{n}{null\PYGZus{}map}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{reproductionMapChecker\PYGZus{}fptr} \PYG{o}{=} \PYG{o}{\PYGZam{}}\PYG{n}{ReproductionMap}\PYG{o}{:}\PYG{o}{:}\PYG{n}{rejectionSampleNull}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{else}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{reproductionMapChecker\PYGZus{}fptr} \PYG{o}{=} \PYG{o}{\PYGZam{}}\PYG{n}{ReproductionMap}\PYG{o}{:}\PYG{o}{:}\PYG{n}{rejectionSample}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{void} \PYG{n}{ReproductionMap}\PYG{o}{:}\PYG{o}{:}\PYG{n}{setOffsets}\PYG{p}{(}\PYG{k}{const} \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{x\PYGZus{}offset}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{y\PYGZus{}offset}\PYG{p}{,}
                                 \PYG{k}{const} \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{xdim}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{ydim}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{n}{offset\PYGZus{}x} \PYG{o}{=} \PYG{n}{x\PYGZus{}offset}\PYG{p}{;}
    \PYG{n}{offset\PYGZus{}y} \PYG{o}{=} \PYG{n}{y\PYGZus{}offset}\PYG{p}{;}
    \PYG{n}{x\PYGZus{}dim} \PYG{o}{=} \PYG{n}{xdim}\PYG{p}{;}
    \PYG{n}{y\PYGZus{}dim} \PYG{o}{=} \PYG{n}{ydim}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}


\PYG{k+kt}{bool} \PYG{n}{ReproductionMap}\PYG{o}{:}\PYG{o}{:}\PYG{n}{rejectionSampleNull}\PYG{p}{(}\PYG{n}{NRrand} \PYG{o}{\PYGZam{}}\PYG{n}{random\PYGZus{}number}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{x}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{y}\PYG{p}{,}
                                      \PYG{k}{const} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{xwrap}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{ywrap}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k}{return} \PYG{n+nb}{true}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{bool} \PYG{n}{ReproductionMap}\PYG{o}{:}\PYG{o}{:}\PYG{n}{rejectionSample}\PYG{p}{(}\PYG{n}{NRrand} \PYG{o}{\PYGZam{}}\PYG{n}{random\PYGZus{}number}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{x}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{y}\PYG{p}{,}
                                      \PYG{k}{const} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{xwrap}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{ywrap}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k}{return} \PYG{n}{random\PYGZus{}number}\PYG{p}{.}\PYG{n}{d01}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{n}{getVal}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,} \PYG{n}{y}\PYG{p}{,} \PYG{n}{xwrap}\PYG{p}{,} \PYG{n}{ywrap}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{double} \PYG{n}{ReproductionMap}\PYG{o}{:}\PYG{o}{:}\PYG{n}{getVal}\PYG{p}{(}\PYG{k}{const} \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{x}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{y}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{xwrap}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{ywrap}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{x\PYGZus{}ref} \PYG{o}{=} \PYG{n}{x} \PYG{o}{+} \PYG{p}{(}\PYG{n}{xwrap} \PYG{o}{*} \PYG{n}{x\PYGZus{}dim}\PYG{p}{)} \PYG{o}{+} \PYG{n}{offset\PYGZus{}x}\PYG{p}{;}
    \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{y\PYGZus{}ref} \PYG{o}{=} \PYG{n}{y} \PYG{o}{+} \PYG{p}{(}\PYG{n}{ywrap} \PYG{o}{*} \PYG{n}{y\PYGZus{}dim}\PYG{p}{)} \PYG{o}{+} \PYG{n}{offset\PYGZus{}y}\PYG{p}{;}
    \PYG{k}{return} \PYG{n}{reproduction\PYGZus{}map}\PYG{p}{[}\PYG{n}{y\PYGZus{}ref}\PYG{p}{]}\PYG{p}{[}\PYG{n}{x\PYGZus{}ref}\PYG{p}{]}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{bool} \PYG{n}{ReproductionMap}\PYG{o}{:}\PYG{o}{:}\PYG{n}{hasReproduced}\PYG{p}{(}\PYG{n}{NRrand} \PYG{o}{\PYGZam{}}\PYG{n}{random\PYGZus{}number}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{x}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{y}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{xwrap}\PYG{p}{,}
                               \PYG{k}{const} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{ywrap}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k}{return} \PYG{p}{(}\PYG{k}{this}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{o}{*}\PYG{n}{reproductionMapChecker\PYGZus{}fptr}\PYG{p}{)}\PYG{p}{(}\PYG{n}{random\PYGZus{}number}\PYG{p}{,} \PYG{n}{x}\PYG{p}{,} \PYG{n}{y}\PYG{p}{,} \PYG{n}{xwrap}\PYG{p}{,} \PYG{n}{ywrap}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}


\subsubsection{Detailed Description}
\label{\detokenize{api/file_necsim_ReproductionMap.cpp:detailed-description}}
Samuel Thompson
16/08/2017
BSD-3 Licence.


\subsubsection{Includes}
\label{\detokenize{api/file_necsim_ReproductionMap.cpp:includes}}\begin{itemize}
\item {} 
\sphinxcode{ReproductionMap.h} ({\hyperref[\detokenize{api/file_necsim_ReproductionMap.h:file-necsim-reproductionmap-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File ReproductionMap.h}}}})

\end{itemize}


\subsection{File ReproductionMap.h}
\label{\detokenize{api/file_necsim_ReproductionMap.h:file-reproductionmap-h}}\label{\detokenize{api/file_necsim_ReproductionMap.h:file-necsim-reproductionmap-h}}\label{\detokenize{api/file_necsim_ReproductionMap.h::doc}}
Contains the {\hyperref[\detokenize{api/class_ReproductionMap:class-reproductionmap}]{\sphinxcrossref{\DUrole{std,std-ref}{Class ReproductionMap}}}}, which inherits from {\hyperref[\detokenize{api/class_Matrix:template-class-matrix}]{\sphinxcrossref{\DUrole{std,std-ref}{Template Class Matrix}}}} and adds a few extra parameters.

\begin{sphinxShadowBox}
\sphinxstyletopictitle{Contents}
\begin{itemize}
\item {} 
\phantomsection\label{\detokenize{api/file_necsim_ReproductionMap.h:id1}}{\hyperref[\detokenize{api/file_necsim_ReproductionMap.h:definition-necsim-reproductionmap-h}]{\sphinxcrossref{Definition (\sphinxcode{necsim/ReproductionMap.h})}}}

\item {} 
\phantomsection\label{\detokenize{api/file_necsim_ReproductionMap.h:id2}}{\hyperref[\detokenize{api/file_necsim_ReproductionMap.h:detailed-description}]{\sphinxcrossref{Detailed Description}}}

\item {} 
\phantomsection\label{\detokenize{api/file_necsim_ReproductionMap.h:id3}}{\hyperref[\detokenize{api/file_necsim_ReproductionMap.h:includes}]{\sphinxcrossref{Includes}}}

\item {} 
\phantomsection\label{\detokenize{api/file_necsim_ReproductionMap.h:id4}}{\hyperref[\detokenize{api/file_necsim_ReproductionMap.h:included-by}]{\sphinxcrossref{Included By}}}

\item {} 
\phantomsection\label{\detokenize{api/file_necsim_ReproductionMap.h:id5}}{\hyperref[\detokenize{api/file_necsim_ReproductionMap.h:classes}]{\sphinxcrossref{Classes}}}

\end{itemize}
\end{sphinxShadowBox}


\subsubsection{Definition (\sphinxstyleliteralintitle{necsim/ReproductionMap.h})}
\label{\detokenize{api/file_necsim_ReproductionMap.h:definition-necsim-reproductionmap-h}}

\paragraph{Program Listing for File ReproductionMap.h}
\label{\detokenize{api/program_listing_file_necsim_ReproductionMap.h:program-listing-file-necsim-reproductionmap-h}}\label{\detokenize{api/program_listing_file_necsim_ReproductionMap.h::doc}}\label{\detokenize{api/program_listing_file_necsim_ReproductionMap.h:program-listing-for-file-reproductionmap-h}}\begin{itemize}
\item {} 
Return to documentation for {\hyperref[\detokenize{api/file_necsim_ReproductionMap.h:file-necsim-reproductionmap-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File ReproductionMap.h}}}}

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{//This file is part of NECSim project which is released under BSD\PYGZhy{}3 license.}
\PYG{c+c1}{//See file **LICENSE.txt** or visit https://opensource.org/licenses/BSD\PYGZhy{}3\PYGZhy{}Clause) for full license details.}

\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifndef REPRODUCTIONMAP\PYGZus{}H}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define REPRODUCTIONMAP\PYGZus{}H}

\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}cstring\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}string\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}stdio.h\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}iostream\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}fstream\PYGZgt{}}

\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZdq{}Matrix.h\PYGZdq{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZdq{}NRrand.h\PYGZdq{}}


\PYG{k}{class} \PYG{n+nc}{ReproductionMap}
\PYG{p}{\PYGZob{}}
\PYG{k}{protected}\PYG{o}{:}
    \PYG{c+c1}{// Matrix containing the relative reproduction probabilities}
    \PYG{n}{Matrix}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{double}\PYG{o}{\PYGZgt{}} \PYG{n}{reproduction\PYGZus{}map}\PYG{p}{;}
    \PYG{c+c1}{// Path to the map file}
    \PYG{n}{string} \PYG{n}{map\PYGZus{}file}\PYG{p}{;}
    \PYG{c+c1}{// Maximum value across the map}
    \PYG{k+kt}{double} \PYG{n}{max\PYGZus{}val}\PYG{p}{;}
    \PYG{c+c1}{// If true,}
    \PYG{k+kt}{bool} \PYG{n}{null\PYGZus{}map}\PYG{p}{;}
    \PYG{c+c1}{// The fine map offsets and the sample map dimensions}
    \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{offset\PYGZus{}x}\PYG{p}{,} \PYG{n}{offset\PYGZus{}y}\PYG{p}{,} \PYG{n}{x\PYGZus{}dim}\PYG{p}{,} \PYG{n}{y\PYGZus{}dim}\PYG{p}{;}
    \PYG{c+c1}{// Function pointer for our reproduction map checker}
    \PYG{k}{typedef} \PYG{n+nf}{bool} \PYG{p}{(}\PYG{n}{ReproductionMap}\PYG{o}{:}\PYG{o}{:}\PYG{o}{*}\PYG{n}{rep\PYGZus{}ptr}\PYG{p}{)}\PYG{p}{(}\PYG{n}{NRrand} \PYG{o}{\PYGZam{}}\PYG{n}{random\PYGZus{}no}\PYG{p}{,}
                                             \PYG{k}{const} \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{x}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{y}\PYG{p}{,}
                                             \PYG{k}{const} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{xwrap}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{ywrap}\PYG{p}{)}\PYG{p}{;}
    \PYG{c+c1}{// once setup will contain the end check function to use for this simulation.}
    \PYG{n}{rep\PYGZus{}ptr} \PYG{n}{reproductionMapChecker\PYGZus{}fptr}\PYG{p}{;}
\PYG{k}{public}\PYG{o}{:}
    \PYG{n}{ReproductionMap}\PYG{p}{(}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{map\PYGZus{}file} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{none}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
        \PYG{n}{max\PYGZus{}val} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
        \PYG{n}{null\PYGZus{}map} \PYG{o}{=} \PYG{n+nb}{true}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{k+kt}{void} \PYG{n}{import}\PYG{p}{(}\PYG{n}{string} \PYG{n}{file\PYGZus{}name}\PYG{p}{,} \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{size\PYGZus{}x}\PYG{p}{,} \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{size\PYGZus{}y}\PYG{p}{)}\PYG{p}{;}

    \PYG{k+kt}{void} \PYG{n+nf}{setReproductionFunction}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

    \PYG{k+kt}{void} \PYG{n+nf}{setOffsets}\PYG{p}{(}\PYG{k}{const} \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{x\PYGZus{}offset}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{y\PYGZus{}offset}\PYG{p}{,}
                    \PYG{k}{const} \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{xdim}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{ydim}\PYG{p}{)}\PYG{p}{;}

    \PYG{k+kt}{bool} \PYG{n+nf}{rejectionSampleNull}\PYG{p}{(}\PYG{n}{NRrand} \PYG{o}{\PYGZam{}}\PYG{n}{random\PYGZus{}number}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{x}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{y}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{xwrap}\PYG{p}{,}
                             \PYG{k}{const} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{ywrap}\PYG{p}{)}\PYG{p}{;}

    \PYG{k+kt}{bool} \PYG{n+nf}{rejectionSample}\PYG{p}{(}\PYG{n}{NRrand} \PYG{o}{\PYGZam{}}\PYG{n}{random\PYGZus{}number}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{x}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{y}\PYG{p}{,}
                     \PYG{k}{const} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{xwrap}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{ywrap}\PYG{p}{)}\PYG{p}{;}

    \PYG{k+kt}{double} \PYG{n+nf}{getVal}\PYG{p}{(}\PYG{k}{const} \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{x}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{y}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{xwrap}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{ywrap}\PYG{p}{)}\PYG{p}{;}

    \PYG{k+kt}{bool} \PYG{n+nf}{hasReproduced}\PYG{p}{(}\PYG{n}{NRrand} \PYG{o}{\PYGZam{}}\PYG{n}{random\PYGZus{}number}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{x}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{y}\PYG{p}{,}
                       \PYG{k}{const} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{xwrap}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{ywrap}\PYG{p}{)}\PYG{p}{;}

    \PYG{n}{Row}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{double}\PYG{o}{\PYGZgt{}} \PYG{k}{operator}\PYG{p}{[}\PYG{p}{]}\PYG{p}{(}\PYG{k+kt}{long} \PYG{n}{index}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{return} \PYG{n}{reproduction\PYGZus{}map}\PYG{p}{[}\PYG{n}{index}\PYG{p}{]}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{k}{friend} \PYG{n}{ostream}\PYG{o}{\PYGZam{}} \PYG{k}{operator}\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{p}{(}\PYG{n}{ostream}\PYG{o}{\PYGZam{}} \PYG{n}{os}\PYG{p}{,} \PYG{n}{ReproductionMap}\PYG{o}{\PYGZam{}}\PYG{n}{r}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{os} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{r}\PYG{p}{.}\PYG{n}{map\PYGZus{}file} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
        \PYG{n}{os} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{r}\PYG{p}{.}\PYG{n}{reproduction\PYGZus{}map}\PYG{p}{.}\PYG{n}{GetCols}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
        \PYG{n}{os} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{r}\PYG{p}{.}\PYG{n}{reproduction\PYGZus{}map}\PYG{p}{.}\PYG{n}{GetRows}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
        \PYG{n}{os} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{r}\PYG{p}{.}\PYG{n}{offset\PYGZus{}x} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
        \PYG{n}{os} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{r}\PYG{p}{.}\PYG{n}{offset\PYGZus{}y} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
        \PYG{n}{os} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{r}\PYG{p}{.}\PYG{n}{x\PYGZus{}dim} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
        \PYG{n}{os} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{r}\PYG{p}{.}\PYG{n}{y\PYGZus{}dim} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
        \PYG{k}{return} \PYG{n}{os}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{k}{friend} \PYG{n}{istream}\PYG{o}{\PYGZam{}} \PYG{k}{operator}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{n}{istream} \PYG{o}{\PYGZam{}}\PYG{n}{is}\PYG{p}{,} \PYG{n}{ReproductionMap} \PYG{o}{\PYGZam{}}\PYG{n}{r}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{is}\PYG{p}{.}\PYG{n}{ignore}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{getline}\PYG{p}{(}\PYG{n}{is}\PYG{p}{,} \PYG{n}{r}\PYG{p}{.}\PYG{n}{map\PYGZus{}file}\PYG{p}{)}\PYG{p}{;}
        \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{col}\PYG{p}{,} \PYG{n}{row}\PYG{p}{;}
        \PYG{n}{is} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{col} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{row}\PYG{p}{;}
        \PYG{n}{is} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{r}\PYG{p}{.}\PYG{n}{offset\PYGZus{}x} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{r}\PYG{p}{.}\PYG{n}{offset\PYGZus{}y} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{r}\PYG{p}{.}\PYG{n}{x\PYGZus{}dim} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{r}\PYG{p}{.}\PYG{n}{y\PYGZus{}dim}\PYG{p}{;}
        \PYG{n}{r}\PYG{p}{.}\PYG{n}{import}\PYG{p}{(}\PYG{n}{r}\PYG{p}{.}\PYG{n}{map\PYGZus{}file}\PYG{p}{,} \PYG{n}{col}\PYG{p}{,} \PYG{n}{row}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{return} \PYG{n}{is}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}


\PYG{p}{\PYGZcb{}}\PYG{p}{;}


\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif }\PYG{c+c1}{//REPRODUCTIONMAP\PYGZus{}H}
\end{sphinxVerbatim}


\subsubsection{Detailed Description}
\label{\detokenize{api/file_necsim_ReproductionMap.h:detailed-description}}
Samuel Thompson
16/08/2017
BSD-3 Licence.


\subsubsection{Includes}
\label{\detokenize{api/file_necsim_ReproductionMap.h:includes}}\begin{itemize}
\item {} 
\sphinxcode{Matrix.h} ({\hyperref[\detokenize{api/file_necsim_Matrix.h:file-necsim-matrix-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File Matrix.h}}}})

\item {} 
\sphinxcode{NRrand.h} ({\hyperref[\detokenize{api/file_necsim_NRrand.h:file-necsim-nrrand-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File NRrand.h}}}})

\item {} 
\sphinxcode{cstring}

\item {} 
\sphinxcode{fstream}

\item {} 
\sphinxcode{iostream}

\item {} 
\sphinxcode{stdio.h}

\item {} 
\sphinxcode{string}

\end{itemize}


\subsubsection{Included By}
\label{\detokenize{api/file_necsim_ReproductionMap.h:included-by}}\begin{itemize}
\item {} 
{\hyperref[\detokenize{api/file_necsim_SpatialTree.h:file-necsim-spatialtree-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File SpatialTree.h}}}}

\item {} 
{\hyperref[\detokenize{api/file_necsim_ReproductionMap.cpp:file-necsim-reproductionmap-cpp}]{\sphinxcrossref{\DUrole{std,std-ref}{File ReproductionMap.cpp}}}}

\end{itemize}


\subsubsection{Classes}
\label{\detokenize{api/file_necsim_ReproductionMap.h:classes}}\begin{itemize}
\item {} 
{\hyperref[\detokenize{api/class_ReproductionMap:class-reproductionmap}]{\sphinxcrossref{\DUrole{std,std-ref}{Class ReproductionMap}}}}

\end{itemize}


\subsection{File Setup.cpp}
\label{\detokenize{api/file_necsim_Setup.cpp:file-setup-cpp}}\label{\detokenize{api/file_necsim_Setup.cpp:file-necsim-setup-cpp}}\label{\detokenize{api/file_necsim_Setup.cpp::doc}}
Contains the command line parsing and setup options for NECSim.

\begin{sphinxShadowBox}
\sphinxstyletopictitle{Contents}
\begin{itemize}
\item {} 
\phantomsection\label{\detokenize{api/file_necsim_Setup.cpp:id1}}{\hyperref[\detokenize{api/file_necsim_Setup.cpp:definition-necsim-setup-cpp}]{\sphinxcrossref{Definition (\sphinxcode{necsim/Setup.cpp})}}}

\item {} 
\phantomsection\label{\detokenize{api/file_necsim_Setup.cpp:id2}}{\hyperref[\detokenize{api/file_necsim_Setup.cpp:detailed-description}]{\sphinxcrossref{Detailed Description}}}

\item {} 
\phantomsection\label{\detokenize{api/file_necsim_Setup.cpp:id3}}{\hyperref[\detokenize{api/file_necsim_Setup.cpp:includes}]{\sphinxcrossref{Includes}}}

\item {} 
\phantomsection\label{\detokenize{api/file_necsim_Setup.cpp:id4}}{\hyperref[\detokenize{api/file_necsim_Setup.cpp:functions}]{\sphinxcrossref{Functions}}}

\item {} 
\phantomsection\label{\detokenize{api/file_necsim_Setup.cpp:id5}}{\hyperref[\detokenize{api/file_necsim_Setup.cpp:variables}]{\sphinxcrossref{Variables}}}

\end{itemize}
\end{sphinxShadowBox}


\subsubsection{Definition (\sphinxstyleliteralintitle{necsim/Setup.cpp})}
\label{\detokenize{api/file_necsim_Setup.cpp:definition-necsim-setup-cpp}}

\paragraph{Program Listing for File Setup.cpp}
\label{\detokenize{api/program_listing_file_necsim_Setup.cpp:program-listing-file-necsim-setup-cpp}}\label{\detokenize{api/program_listing_file_necsim_Setup.cpp::doc}}\label{\detokenize{api/program_listing_file_necsim_Setup.cpp:program-listing-for-file-setup-cpp}}\begin{itemize}
\item {} 
Return to documentation for {\hyperref[\detokenize{api/file_necsim_Setup.cpp:file-necsim-setup-cpp}]{\sphinxcrossref{\DUrole{std,std-ref}{File Setup.cpp}}}}

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{//This file is part of NECSim project which is released under BSD\PYGZhy{}3 license.}
\PYG{c+c1}{//See file **LICENSE.txt** or visit https://opensource.org/licenses/BSD\PYGZhy{}3\PYGZhy{}Clause) for full license details.}
\PYG{c+c1}{//}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZdq{}Setup.h\PYGZdq{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZdq{}Logging.h\PYGZdq{}}
\PYG{c+c1}{// Global variables}
\PYG{c+c1}{// store the log file name for access anywhere.}
\PYG{n}{string} \PYG{n}{log\PYGZus{}name} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{null}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
\PYG{c+c1}{// the old stdout}
\PYG{k+kt}{int} \PYG{n}{saved\PYGZus{}stdout}\PYG{p}{;}


\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifndef verbose}

\PYG{k+kt}{void} \PYG{n+nf}{openLogFile}\PYG{p}{(}\PYG{k+kt}{bool} \PYG{n}{append}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{c+c1}{// If verbose mode is not defined, we output to a log file instead of to the terminal}
    \PYG{c+c1}{// Get the current time}
    \PYG{n}{saved\PYGZus{}stdout} \PYG{o}{=} \PYG{n}{dup}\PYG{p}{(}\PYG{n}{fileno}\PYG{p}{(}\PYG{n}{stdout}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
    \PYG{c+c1}{//dup2(stdout, 1);}
    \PYG{k}{auto} \PYG{n}{t} \PYG{o}{=} \PYG{n}{time}\PYG{p}{(}\PYG{k}{nullptr}\PYG{p}{)}\PYG{p}{;}
    \PYG{k}{auto} \PYG{n}{tp} \PYG{o}{=} \PYG{o}{*}\PYG{n}{localtime}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{t}\PYG{p}{)}\PYG{p}{;}
    \PYG{c+c1}{// get the time string}
    \PYG{n}{ostringstream} \PYG{n}{oss}\PYG{p}{;}
    \PYG{n}{oss} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{put\PYGZus{}time}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{tp}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZpc{}d\PYGZhy{}\PYGZpc{}m\PYGZhy{}\PYGZpc{}Y\PYGZhy{}\PYGZpc{}H:\PYGZpc{}M:\PYGZpc{}S}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{k}{if}\PYG{p}{(}\PYG{n}{log\PYGZus{}name} \PYG{o}{=}\PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{null}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{log\PYGZus{}name} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Logs/Log\PYGZus{}}\PYG{l+s}{\PYGZdq{}}\PYG{o}{+}\PYG{n}{oss}\PYG{p}{.}\PYG{n}{str}\PYG{p}{(}\PYG{p}{)} \PYG{o}{+} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{.txt}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{c+c1}{// Check that the Log folder exists, and create if necessary.}
    \PYG{k}{if}\PYG{p}{(}\PYG{o}{!}\PYG{n}{boost}\PYG{o}{:}\PYG{o}{:}\PYG{n}{filesystem}\PYG{o}{:}\PYG{o}{:}\PYG{n}{exists}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Logs}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{if}\PYG{p}{(}\PYG{o}{!}\PYG{n}{boost}\PYG{o}{:}\PYG{o}{:}\PYG{n}{filesystem}\PYG{o}{:}\PYG{o}{:}\PYG{n}{create\PYGZus{}directory}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Logs}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{cerr} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Cannot create log directory (check write access) \PYGZhy{} defaulting to terminal.}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{if}\PYG{p}{(}\PYG{n}{boost}\PYG{o}{:}\PYG{o}{:}\PYG{n}{filesystem}\PYG{o}{:}\PYG{o}{:}\PYG{n}{exists}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Logs}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{c+c1}{// Open the log file for writing to.}
        \PYG{k+kt}{FILE} \PYG{o}{*} \PYG{n}{tmpfileptr}\PYG{p}{;}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{append}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{tmpfileptr} \PYG{o}{=} \PYG{n}{freopen}\PYG{p}{(}\PYG{n}{log\PYGZus{}name}\PYG{p}{.}\PYG{n}{c\PYGZus{}str}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{a}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{stdout}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{else}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{tmpfileptr} \PYG{o}{=} \PYG{n}{freopen}\PYG{p}{(}\PYG{n}{log\PYGZus{}name}\PYG{p}{.}\PYG{n}{c\PYGZus{}str}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{w}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{stdout}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{stdout} \PYG{o}{=}\PYG{o}{=} \PYG{k}{nullptr} \PYG{o}{\textbar{}}\PYG{o}{\textbar{}} \PYG{n}{tmpfileptr} \PYG{o}{=}\PYG{o}{=} \PYG{k}{nullptr}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{cerr} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Cannot create log file (check write access) \PYGZhy{} defaulting to terminal.}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
            \PYG{n}{dup2}\PYG{p}{(}\PYG{n}{saved\PYGZus{}stdout}\PYG{p}{,} \PYG{n}{fileno}\PYG{p}{(}\PYG{n}{stdout}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
            \PYG{n}{close}\PYG{p}{(}\PYG{n}{saved\PYGZus{}stdout}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
    \PYG{p}{\PYGZcb{}}
    \PYG{c+c1}{//cerr\PYGZlt{}\PYGZlt{} \PYGZdq{}logfile2 : \PYGZdq{} \PYGZlt{}\PYGZlt{} log\PYGZus{}name \PYGZlt{}\PYGZlt{} endl;}
\PYG{p}{\PYGZcb{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif }\PYG{c+cm}{/* verbose */}

\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifdef PROFILE}

\PYG{n}{ofstream} \PYG{n}{csv\PYGZus{}output}\PYG{p}{;}

\PYG{k+kt}{void} \PYG{n+nf}{logToCsv}\PYG{p}{(}\PYG{n}{string} \PYG{n}{place}\PYG{p}{,} \PYG{k+kt}{time\PYGZus{}t} \PYG{n}{start}\PYG{p}{,} \PYG{k+kt}{time\PYGZus{}t} \PYG{n}{end}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k}{if}\PYG{p}{(}\PYG{o}{!}\PYG{n}{csv\PYGZus{}output}\PYG{p}{.}\PYG{n}{good}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{try}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{csv\PYGZus{}output}\PYG{p}{.}\PYG{n}{open}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{csvout.csv}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{catch}\PYG{p}{(}\PYG{n}{exception} \PYG{o}{\PYGZam{}}\PYG{n}{e}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{k}{throw} \PYG{n}{Fatal\PYGZus{}Main\PYGZus{}Exception}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Csv logging output not good: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{+} \PYG{n}{e}\PYG{p}{.}\PYG{n}{what}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
    \PYG{p}{\PYGZcb{}}
    \PYG{n}{csv\PYGZus{}output} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{place} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{,}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{start} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{,}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{end} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{void} \PYG{n+nf}{closeCsv}\PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k}{if}\PYG{p}{(}\PYG{n}{csv\PYGZus{}output}\PYG{p}{.}\PYG{n}{good}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{csv\PYGZus{}output}\PYG{p}{.}\PYG{n}{close}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif}

\PYG{k+kt}{void} \PYG{n+nf}{runAsDefault}\PYG{p}{(}\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{n}{string}\PYG{o}{\PYGZgt{}} \PYG{o}{\PYGZam{}}\PYG{n}{comargs}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{n}{writeInfo}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Setting default variables on small grid.}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{comargs}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZhy{}f}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{comargs}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{1}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{comargs}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{10}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{comargs}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{10}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{comargs}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{null}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{comargs}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{150}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{comargs}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{150}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{comargs}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{25}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{comargs}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{25}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{comargs}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{null}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{comargs}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{2000}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{comargs}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{2000}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{comargs}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{500}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{comargs}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{500}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{comargs}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{100}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{comargs}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Default/}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{comargs}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{0.000009}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{comargs}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{2}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{comargs}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{1}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{comargs}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{1}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{comargs}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{4}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{comargs}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{1}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{comargs}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{0}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{comargs}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{100}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{comargs}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{null}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{comargs}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{null}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{comargs}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{0.5}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{comargs}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{20.0}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{comargs}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{2.0}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{comargs}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{null}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{comargs}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{null}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{comargs}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{0.000009}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{void} \PYG{n+nf}{runLarge}\PYG{p}{(}\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{n}{string}\PYG{o}{\PYGZgt{}} \PYG{o}{\PYGZam{}}\PYG{n}{comargs}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{n}{writeInfo}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Setting default variables on large grid.}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{comargs}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZhy{}f}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{comargs}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{1}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{comargs}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{500}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{comargs}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{500}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{comargs}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{null}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{comargs}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{500}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{comargs}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{500}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{comargs}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{0}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{comargs}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{0}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{comargs}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{null}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{comargs}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{100}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{comargs}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{100}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{comargs}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{2500}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{comargs}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{2500}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{comargs}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{100}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{comargs}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Default/}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{comargs}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{0.0001}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{comargs}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{2}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{comargs}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{10}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{comargs}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{1}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{comargs}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{3600}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{comargs}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{1}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{comargs}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{1}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{comargs}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{50000}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{comargs}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{null}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{comargs}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{null}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{comargs}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{0.5}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{comargs}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{20.0}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{comargs}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{2.0}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{comargs}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{null}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{comargs}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{null}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{comargs}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{0.001}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{void} \PYG{n+nf}{runXL}\PYG{p}{(}\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{n}{string}\PYG{o}{\PYGZgt{}} \PYG{o}{\PYGZam{}}\PYG{n}{comargs}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{n}{writeInfo}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Setting default variables on extra large grid.}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{comargs}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZhy{}f}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{comargs}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{1}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{comargs}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{6000}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{comargs}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{6400}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{comargs}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{null}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{comargs}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{34000}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{comargs}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{28000}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{comargs}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{8800}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{comargs}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{14800}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{comargs}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{null}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{comargs}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{24000}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{comargs}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{20000}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{comargs}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{10320}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{comargs}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{8080}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{comargs}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{10}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{comargs}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Default/}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{comargs}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{0.0000001}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{comargs}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{2}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{comargs}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{49}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{comargs}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{0.2}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{comargs}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{21600}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{comargs}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{1}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{comargs}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{3}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{comargs}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{600}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{comargs}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{null}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{comargs}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{null}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{comargs}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{0}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{comargs}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{2.2}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{comargs}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{1.0}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{comargs}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{null}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{comargs}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{null}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{comargs}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{0.000009}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{void} \PYG{n+nf}{removeComOption}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{argc}\PYG{p}{,} \PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{n}{string}\PYG{o}{\PYGZgt{}} \PYG{o}{\PYGZam{}}\PYG{n}{comargs}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{c+c1}{// stupidly long list of possible arguments, but can\PYGZsq{}t think of a better way to check this.}
    \PYG{k}{if}\PYG{p}{(}\PYG{n}{comargs}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{=}\PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZhy{}d}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\textbar{}}\PYG{o}{\textbar{}} \PYG{n}{comargs}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{=}\PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZhy{}D}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\textbar{}}\PYG{o}{\textbar{}}  \PYG{n}{comargs}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{=}\PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZhy{}dl}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\textbar{}}\PYG{o}{\textbar{}}  \PYG{n}{comargs}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{=}\PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZhy{}dL}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\textbar{}}\PYG{o}{\textbar{}}  \PYG{n}{comargs}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{=}\PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ \PYGZhy{}Dl}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\textbar{}}\PYG{o}{\textbar{}}  \PYG{n}{comargs}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{=}\PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZhy{}DL}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\textbar{}}\PYG{o}{\textbar{}}
        \PYG{n}{comargs}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{=}\PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZhy{}dx}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\textbar{}}\PYG{o}{\textbar{}} \PYG{n}{comargs}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{=}\PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZhy{}dX}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\textbar{}}\PYG{o}{\textbar{}}  \PYG{n}{comargs}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{=}\PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZhy{}DX}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\textbar{}}\PYG{o}{\textbar{}}  \PYG{n}{comargs}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{=}\PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ \PYGZhy{}Dx}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\textbar{}}\PYG{o}{\textbar{}}  \PYG{n}{comargs}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{=}\PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZhy{}c}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\textbar{}}\PYG{o}{\textbar{}}  \PYG{n}{comargs}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{=}\PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZhy{}C}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\textbar{}}\PYG{o}{\textbar{}}
        \PYG{n}{comargs}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{=}\PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZhy{}config}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\textbar{}}\PYG{o}{\textbar{}}  \PYG{n}{comargs}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{=}\PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZhy{}Config}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\textbar{}}\PYG{o}{\textbar{}} \PYG{n}{comargs}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{=}\PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZhy{}f}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\textbar{}}\PYG{o}{\textbar{}} \PYG{n}{comargs}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{=}\PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZhy{}h}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\textbar{}}\PYG{o}{\textbar{}} \PYG{n}{comargs}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{=}\PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZhy{}H}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\textbar{}}\PYG{o}{\textbar{}} \PYG{n}{comargs}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{=}\PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZhy{}F)}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{comargs}\PYG{p}{.}\PYG{n}{erase}\PYG{p}{(}\PYG{n}{comargs}\PYG{p}{.}\PYG{n}{begin}\PYG{p}{(}\PYG{p}{)} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{argc} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{return}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}


\subsubsection{Detailed Description}
\label{\detokenize{api/file_necsim_Setup.cpp:detailed-description}}
Sam Thompson
Contact: \sphinxhref{mailto:samuel.thompson14@imperial.ac.uk}{samuel.thompson14@imperial.ac.uk} or \sphinxhref{mailto:thompsonsed@gmail.com}{thompsonsed@gmail.com} BSD-3 Licence.


\subsubsection{Includes}
\label{\detokenize{api/file_necsim_Setup.cpp:includes}}\begin{itemize}
\item {} 
\sphinxcode{Logging.h} ({\hyperref[\detokenize{api/file_necsim_Logging.h:file-necsim-logging-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File Logging.h}}}})

\item {} 
\sphinxcode{Setup.h} ({\hyperref[\detokenize{api/file_necsim_Setup.h:file-necsim-setup-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File Setup.h}}}})

\end{itemize}


\subsubsection{Functions}
\label{\detokenize{api/file_necsim_Setup.cpp:functions}}\begin{itemize}
\item {} 
{\hyperref[\detokenize{api/function_openLogFile:function-openlogfile}]{\sphinxcrossref{\DUrole{std,std-ref}{Function openLogFile}}}}

\item {} 
{\hyperref[\detokenize{api/function_removeComOption:function-removecomoption}]{\sphinxcrossref{\DUrole{std,std-ref}{Function removeComOption}}}}

\item {} 
{\hyperref[\detokenize{api/function_runAsDefault:function-runasdefault}]{\sphinxcrossref{\DUrole{std,std-ref}{Function runAsDefault}}}}

\item {} 
{\hyperref[\detokenize{api/function_runLarge:function-runlarge}]{\sphinxcrossref{\DUrole{std,std-ref}{Function runLarge}}}}

\item {} 
{\hyperref[\detokenize{api/function_runXL:function-runxl}]{\sphinxcrossref{\DUrole{std,std-ref}{Function runXL}}}}

\end{itemize}


\subsubsection{Variables}
\label{\detokenize{api/file_necsim_Setup.cpp:variables}}\begin{itemize}
\item {} 
{\hyperref[\detokenize{api/variable_log_name:variable-log-name}]{\sphinxcrossref{\DUrole{std,std-ref}{Variable log\_name}}}}

\item {} 
{\hyperref[\detokenize{api/variable_saved_stdout:variable-saved-stdout}]{\sphinxcrossref{\DUrole{std,std-ref}{Variable saved\_stdout}}}}

\end{itemize}


\subsection{File Setup.h}
\label{\detokenize{api/file_necsim_Setup.h:file-necsim-setup-h}}\label{\detokenize{api/file_necsim_Setup.h::doc}}\label{\detokenize{api/file_necsim_Setup.h:file-setup-h}}
Contains declarations for the command line parsing and setup options for NECSim.

\begin{sphinxShadowBox}
\sphinxstyletopictitle{Contents}
\begin{itemize}
\item {} 
\phantomsection\label{\detokenize{api/file_necsim_Setup.h:id1}}{\hyperref[\detokenize{api/file_necsim_Setup.h:definition-necsim-setup-h}]{\sphinxcrossref{Definition (\sphinxcode{necsim/Setup.h})}}}

\item {} 
\phantomsection\label{\detokenize{api/file_necsim_Setup.h:id2}}{\hyperref[\detokenize{api/file_necsim_Setup.h:detailed-description}]{\sphinxcrossref{Detailed Description}}}

\item {} 
\phantomsection\label{\detokenize{api/file_necsim_Setup.h:id3}}{\hyperref[\detokenize{api/file_necsim_Setup.h:includes}]{\sphinxcrossref{Includes}}}

\item {} 
\phantomsection\label{\detokenize{api/file_necsim_Setup.h:id4}}{\hyperref[\detokenize{api/file_necsim_Setup.h:included-by}]{\sphinxcrossref{Included By}}}

\item {} 
\phantomsection\label{\detokenize{api/file_necsim_Setup.h:id5}}{\hyperref[\detokenize{api/file_necsim_Setup.h:functions}]{\sphinxcrossref{Functions}}}

\item {} 
\phantomsection\label{\detokenize{api/file_necsim_Setup.h:id6}}{\hyperref[\detokenize{api/file_necsim_Setup.h:variables}]{\sphinxcrossref{Variables}}}

\end{itemize}
\end{sphinxShadowBox}


\subsubsection{Definition (\sphinxstyleliteralintitle{necsim/Setup.h})}
\label{\detokenize{api/file_necsim_Setup.h:definition-necsim-setup-h}}

\paragraph{Program Listing for File Setup.h}
\label{\detokenize{api/program_listing_file_necsim_Setup.h:program-listing-file-necsim-setup-h}}\label{\detokenize{api/program_listing_file_necsim_Setup.h::doc}}\label{\detokenize{api/program_listing_file_necsim_Setup.h:program-listing-for-file-setup-h}}\begin{itemize}
\item {} 
Return to documentation for {\hyperref[\detokenize{api/file_necsim_Setup.h:file-necsim-setup-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File Setup.h}}}}

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{//This file is part of NECSim project which is released under BSD\PYGZhy{}3 license.}
\PYG{c+c1}{//See file **LICENSE.txt** or visit https://opensource.org/licenses/BSD\PYGZhy{}3\PYGZhy{}Clause) for full license details.}
\PYG{c+c1}{//}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifndef SETUP}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define SETUP}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}string\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}vector\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}unistd.h\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}sstream\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}ctime\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}boost/filesystem.hpp\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}cstdio\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}ctime\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}iostream\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}iomanip\PYGZgt{}}

\PYG{c+c1}{// Forward declaring the global variables}
\PYG{c+c1}{// store the log file name for access anywhere.}
\PYG{k}{using} \PYG{k}{namespace} \PYG{n}{std}\PYG{p}{;}

\PYG{k}{extern} \PYG{n}{string} \PYG{n}{log\PYGZus{}name}\PYG{p}{;}
\PYG{c+c1}{// the old stdout}
\PYG{k}{extern} \PYG{k+kt}{int} \PYG{n}{saved\PYGZus{}stdout}\PYG{p}{;}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifdef DEBUG}

\PYG{k+kt}{void} \PYG{n+nf}{openLogFile}\PYG{p}{(}\PYG{k+kt}{bool} \PYG{n}{append}\PYG{p}{)}\PYG{p}{;}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif}

\PYG{k+kt}{void} \PYG{n+nf}{runAsDefault}\PYG{p}{(}\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{n}{string}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZam{}}\PYG{n}{comargs}\PYG{p}{)}\PYG{p}{;}


\PYG{k+kt}{void} \PYG{n+nf}{runLarge}\PYG{p}{(}\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{n}{string}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZam{}}\PYG{n}{comargs}\PYG{p}{)}\PYG{p}{;}

\PYG{k+kt}{void} \PYG{n+nf}{runXL}\PYG{p}{(}\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{n}{string}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZam{}}\PYG{n}{comargs}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{void} \PYG{n+nf}{removeComOption}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{long}\PYG{o}{\PYGZam{}} \PYG{n}{argc}\PYG{p}{,} \PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{n}{string}\PYG{o}{\PYGZgt{}} \PYG{o}{\PYGZam{}} \PYG{n}{comargs}\PYG{p}{)}\PYG{p}{;}




\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif }\PYG{c+c1}{// SETUP}
\end{sphinxVerbatim}


\subsubsection{Detailed Description}
\label{\detokenize{api/file_necsim_Setup.h:detailed-description}}
Sam Thompson
Contact: \sphinxhref{mailto:samuel.thompson14@imperial.ac.uk}{samuel.thompson14@imperial.ac.uk} or \sphinxhref{mailto:thompsonsed@gmail.com}{thompsonsed@gmail.com} BSD-3 Licence.


\subsubsection{Includes}
\label{\detokenize{api/file_necsim_Setup.h:includes}}\begin{itemize}
\item {} 
\sphinxcode{boost/filesystem.hpp}

\item {} 
\sphinxcode{cstdio}

\item {} 
\sphinxcode{ctime}

\item {} 
\sphinxcode{iomanip}

\item {} 
\sphinxcode{iostream}

\item {} 
\sphinxcode{sstream}

\item {} 
\sphinxcode{string}

\item {} 
\sphinxcode{unistd.h}

\item {} 
\sphinxcode{vector}

\end{itemize}


\subsubsection{Included By}
\label{\detokenize{api/file_necsim_Setup.h:included-by}}\begin{itemize}
\item {} 
{\hyperref[\detokenize{api/file_necsim_SpatialTree.h:file-necsim-spatialtree-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File SpatialTree.h}}}}

\item {} 
{\hyperref[\detokenize{api/file_necsim_Setup.cpp:file-necsim-setup-cpp}]{\sphinxcrossref{\DUrole{std,std-ref}{File Setup.cpp}}}}

\end{itemize}


\subsubsection{Functions}
\label{\detokenize{api/file_necsim_Setup.h:functions}}\begin{itemize}
\item {} 
{\hyperref[\detokenize{api/function_removeComOption:function-removecomoption}]{\sphinxcrossref{\DUrole{std,std-ref}{Function removeComOption}}}}

\item {} 
{\hyperref[\detokenize{api/function_runAsDefault:function-runasdefault}]{\sphinxcrossref{\DUrole{std,std-ref}{Function runAsDefault}}}}

\item {} 
{\hyperref[\detokenize{api/function_runLarge:function-runlarge}]{\sphinxcrossref{\DUrole{std,std-ref}{Function runLarge}}}}

\item {} 
{\hyperref[\detokenize{api/function_runXL:function-runxl}]{\sphinxcrossref{\DUrole{std,std-ref}{Function runXL}}}}

\end{itemize}


\subsubsection{Variables}
\label{\detokenize{api/file_necsim_Setup.h:variables}}\begin{itemize}
\item {} 
{\hyperref[\detokenize{api/variable_log_name:variable-log-name}]{\sphinxcrossref{\DUrole{std,std-ref}{Variable log\_name}}}}

\item {} 
{\hyperref[\detokenize{api/variable_saved_stdout:variable-saved-stdout}]{\sphinxcrossref{\DUrole{std,std-ref}{Variable saved\_stdout}}}}

\end{itemize}


\subsection{File SimParameters.h}
\label{\detokenize{api/file_necsim_SimParameters.h:file-necsim-simparameters-h}}\label{\detokenize{api/file_necsim_SimParameters.h::doc}}\label{\detokenize{api/file_necsim_SimParameters.h:file-simparameters-h}}
Stores and parses simulation parameters from the command line or a config file.

\begin{sphinxShadowBox}
\sphinxstyletopictitle{Contents}
\begin{itemize}
\item {} 
\phantomsection\label{\detokenize{api/file_necsim_SimParameters.h:id1}}{\hyperref[\detokenize{api/file_necsim_SimParameters.h:definition-necsim-simparameters-h}]{\sphinxcrossref{Definition (\sphinxcode{necsim/SimParameters.h})}}}

\item {} 
\phantomsection\label{\detokenize{api/file_necsim_SimParameters.h:id2}}{\hyperref[\detokenize{api/file_necsim_SimParameters.h:detailed-description}]{\sphinxcrossref{Detailed Description}}}

\item {} 
\phantomsection\label{\detokenize{api/file_necsim_SimParameters.h:id3}}{\hyperref[\detokenize{api/file_necsim_SimParameters.h:includes}]{\sphinxcrossref{Includes}}}

\item {} 
\phantomsection\label{\detokenize{api/file_necsim_SimParameters.h:id4}}{\hyperref[\detokenize{api/file_necsim_SimParameters.h:included-by}]{\sphinxcrossref{Included By}}}

\item {} 
\phantomsection\label{\detokenize{api/file_necsim_SimParameters.h:id5}}{\hyperref[\detokenize{api/file_necsim_SimParameters.h:classes}]{\sphinxcrossref{Classes}}}

\end{itemize}
\end{sphinxShadowBox}


\subsubsection{Definition (\sphinxstyleliteralintitle{necsim/SimParameters.h})}
\label{\detokenize{api/file_necsim_SimParameters.h:definition-necsim-simparameters-h}}

\paragraph{Program Listing for File SimParameters.h}
\label{\detokenize{api/program_listing_file_necsim_SimParameters.h:program-listing-for-file-simparameters-h}}\label{\detokenize{api/program_listing_file_necsim_SimParameters.h:program-listing-file-necsim-simparameters-h}}\label{\detokenize{api/program_listing_file_necsim_SimParameters.h::doc}}\begin{itemize}
\item {} 
Return to documentation for {\hyperref[\detokenize{api/file_necsim_SimParameters.h:file-necsim-simparameters-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File SimParameters.h}}}}

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{// This file is part of NECSim project which is released under BSD\PYGZhy{}3 license.}
\PYG{c+c1}{// See file **LICENSE.txt** or visit https://opensource.org/licenses/BSD\PYGZhy{}3\PYGZhy{}Clause) for full license details.}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifndef SPECIATIONCOUNTER\PYGZus{}SIMPARAMETERS\PYGZus{}H}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define SPECIATIONCOUNTER\PYGZus{}SIMPARAMETERS\PYGZus{}H}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}string\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}vector\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZdq{}ConfigFileParser.h\PYGZdq{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZdq{}Logging.h\PYGZdq{}}
\PYG{k}{using} \PYG{k}{namespace} \PYG{n}{std}\PYG{p}{;}
\PYG{c+cm}{/************************************************************}
\PYG{c+cm}{                    MAPVARS STRUCTURE}
\PYG{c+cm}{ ************************************************************/}
\PYG{k}{struct} \PYG{n}{SimParameters}
\PYG{p}{\PYGZob{}}
    \PYG{n}{string} \PYG{n}{fine\PYGZus{}map\PYGZus{}file}\PYG{p}{,} \PYG{n}{coarse\PYGZus{}map\PYGZus{}file}\PYG{p}{,} \PYG{n}{output\PYGZus{}directory}\PYG{p}{;}
    \PYG{n}{string} \PYG{n}{pristine\PYGZus{}fine\PYGZus{}map\PYGZus{}file}\PYG{p}{,} \PYG{n}{pristine\PYGZus{}coarse\PYGZus{}map\PYGZus{}file}\PYG{p}{,} \PYG{n}{sample\PYGZus{}mask\PYGZus{}file}\PYG{p}{;}
     \PYG{c+c1}{// for file naming purposes.}
    \PYG{k+kt}{long} \PYG{k+kt}{long} \PYG{n}{the\PYGZus{}task}\PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}\PYG{p}{,} \PYG{n}{the\PYGZus{}seed}\PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
    \PYG{c+c1}{// the variables for the grid containing the initial individuals.}
    \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{grid\PYGZus{}x\PYGZus{}size}\PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}\PYG{p}{,} \PYG{n}{grid\PYGZus{}y\PYGZus{}size}\PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
    \PYG{c+c1}{// The variables for the sample grid, which may or may not be the same as the main simulation grid}
    \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{sample\PYGZus{}x\PYGZus{}size}\PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}\PYG{p}{,} \PYG{n}{sample\PYGZus{}y\PYGZus{}size}\PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
    \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{sample\PYGZus{}x\PYGZus{}offset}\PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}\PYG{p}{,} \PYG{n}{sample\PYGZus{}y\PYGZus{}offset}\PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
    \PYG{c+c1}{// The fine map variables at the same resolution as the grid.}
    \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{fine\PYGZus{}map\PYGZus{}x\PYGZus{}size}\PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}\PYG{p}{,} \PYG{n}{fine\PYGZus{}map\PYGZus{}y\PYGZus{}size}\PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}\PYG{p}{,} \PYG{n}{fine\PYGZus{}map\PYGZus{}x\PYGZus{}offset}\PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}\PYG{p}{,} \PYG{n}{fine\PYGZus{}map\PYGZus{}y\PYGZus{}offset}\PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
    \PYG{c+c1}{// the coarse map variables at a scaled resolution of the fine map.}
    \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{coarse\PYGZus{}map\PYGZus{}x\PYGZus{}size}\PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}\PYG{p}{,} \PYG{n}{coarse\PYGZus{}map\PYGZus{}y\PYGZus{}size}\PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}\PYG{p}{,} \PYG{n}{coarse\PYGZus{}map\PYGZus{}x\PYGZus{}offset}\PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}\PYG{p}{,} \PYG{n}{coarse\PYGZus{}map\PYGZus{}y\PYGZus{}offset}\PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
    \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{coarse\PYGZus{}map\PYGZus{}scale}\PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
    \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{desired\PYGZus{}specnum}\PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
    \PYG{c+c1}{// the relative cost of moving through non\PYGZhy{}forest}
    \PYG{k+kt}{double} \PYG{n}{dispersal\PYGZus{}relative\PYGZus{}cost}\PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
    \PYG{c+c1}{// the size of each square of habitat in numbers of individuals}
    \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{deme}\PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
    \PYG{c+c1}{// the sample proportion,}
     \PYG{k+kt}{double} \PYG{n}{deme\PYGZus{}sample}\PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
    \PYG{c+c1}{// the speciation rate.}
    \PYG{k+kt}{long} \PYG{k+kt}{double}  \PYG{n}{spec}\PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
    \PYG{c+c1}{// the variance of the dispersal kernel.}
    \PYG{k+kt}{double} \PYG{n}{sigma}\PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
    \PYG{c+c1}{// max time to run for}
    \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{max\PYGZus{}time}\PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
    \PYG{c+c1}{// the number of generations since a pristine landscape was encountered.}
    \PYG{k+kt}{double} \PYG{n}{gen\PYGZus{}since\PYGZus{}pristine}\PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
    \PYG{c+c1}{// the transform rate of the forest from pristine to modern forest.}
    \PYG{k+kt}{double} \PYG{n}{habitat\PYGZus{}change\PYGZus{}rate}\PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
    \PYG{c+c1}{// the fatness of the dispersal kernel}
    \PYG{k+kt}{double} \PYG{n}{tau}\PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
    \PYG{c+c1}{// dispersal method \PYGZhy{} should be one of [normal, fat\PYGZhy{}tail, norm\PYGZhy{}uniform]}
    \PYG{n}{string} \PYG{n}{dispersal\PYGZus{}method}\PYG{p}{;}
    \PYG{c+c1}{// the probability of selecting from a uniform dispersal kernel (for uniformally\PYGZhy{}modified dispersals)}
    \PYG{k+kt}{double} \PYG{n}{m\PYGZus{}prob}\PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
    \PYG{c+c1}{// the cutoff for the normal dispersal in cells.}
    \PYG{k+kt}{double} \PYG{n}{cutoff}\PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
    \PYG{c+c1}{// if true, restricts dispersal from the same cell.}
    \PYG{k+kt}{bool} \PYG{n}{restrict\PYGZus{}self}\PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
    \PYG{c+c1}{// file containing the points to record data from}
    \PYG{n}{string} \PYG{n}{times\PYGZus{}file}\PYG{p}{;}
    \PYG{c+c1}{// Stores the full list of configs imported from file}
    \PYG{n}{ConfigOption} \PYG{n}{configs}\PYG{p}{;}
    \PYG{c+c1}{// Set to true if the completely pristine state has been reached.}
    \PYG{k+kt}{bool} \PYG{n}{is\PYGZus{}pristine}\PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
    \PYG{c+c1}{// if the sample file is not null, this variable tells us whether different points in space require different}
    \PYG{c+c1}{// numbers of individuals to be sampled. If this is the case, the actual values are read from the sample mask as a}
    \PYG{c+c1}{// proportion of individuals sampled, from 0\PYGZhy{}1. Otherwise, it is treated as a boolean mask, with values \PYGZgt{} 0.5}
    \PYG{c+c1}{// representing sampling in the cell.}
    \PYG{k+kt}{bool} \PYG{n}{uses\PYGZus{}spatial\PYGZus{}sampling}\PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
    \PYG{c+c1}{// This can be closed, infinite and tiled (which is also infinite)}
    \PYG{n}{string} \PYG{n}{landscape\PYGZus{}type}\PYG{p}{;}
    \PYG{c+c1}{// The protracted speciation parameters \PYGZhy{} these DON\PYGZsq{}T need to be stored upon pausing simulations}
    \PYG{k+kt}{bool} \PYG{n}{is\PYGZus{}protracted}\PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
    \PYG{k+kt}{double} \PYG{n}{min\PYGZus{}speciation\PYGZus{}gen}\PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}\PYG{p}{,} \PYG{n}{max\PYGZus{}speciation\PYGZus{}gen}\PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}\PYG{p}{;}

    \PYG{c+c1}{// a map of dispersal values, where each row corresponds to the probability of moving from one cell}
    \PYG{c+c1}{// to any other.}
    \PYG{n}{string} \PYG{n}{dispersal\PYGZus{}file}\PYG{p}{;}

    \PYG{c+c1}{// a map of relative reproduction probabilities.}
    \PYG{n}{string} \PYG{n}{reproduction\PYGZus{}file}\PYG{p}{;}

    \PYG{n}{SimParameters}\PYG{p}{(}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{fine\PYGZus{}map\PYGZus{}file} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{none}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
        \PYG{n}{coarse\PYGZus{}map\PYGZus{}file} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{none}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
        \PYG{n}{output\PYGZus{}directory} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{none}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
        \PYG{n}{pristine\PYGZus{}fine\PYGZus{}map\PYGZus{}file} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{none}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
        \PYG{n}{pristine\PYGZus{}coarse\PYGZus{}map\PYGZus{}file} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{none}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
        \PYG{n}{sample\PYGZus{}mask\PYGZus{}file} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{none}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
        \PYG{n}{times\PYGZus{}file} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{null}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
        \PYG{n}{dispersal\PYGZus{}method} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{none}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
        \PYG{n}{landscape\PYGZus{}type} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{none}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
        \PYG{n}{reproduction\PYGZus{}file} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{none}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
        \PYG{n}{dispersal\PYGZus{}file} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{none}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
        \PYG{n}{min\PYGZus{}speciation\PYGZus{}gen} \PYG{o}{=} \PYG{l+m+mf}{0.0}\PYG{p}{;}
        \PYG{n}{max\PYGZus{}speciation\PYGZus{}gen} \PYG{o}{=} \PYG{l+m+mf}{0.0}\PYG{p}{;}
        \PYG{n}{is\PYGZus{}protracted} \PYG{o}{=} \PYG{n+nb}{false}\PYG{p}{;}
        \PYG{n}{restrict\PYGZus{}self} \PYG{o}{=} \PYG{n+nb}{false}\PYG{p}{;}
        \PYG{n}{m\PYGZus{}prob} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
        \PYG{n}{cutoff} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
        \PYG{n}{tau} \PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{k+kt}{void} \PYG{n}{importParameters}\PYG{p}{(}\PYG{n}{ConfigOption} \PYG{o}{*}\PYG{n}{configOption}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{configs} \PYG{o}{=} \PYG{o}{*}\PYG{n}{configOption}\PYG{p}{;}
        \PYG{n}{importParameters}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{k+kt}{void} \PYG{n}{importParameters}\PYG{p}{(}\PYG{k}{const} \PYG{n}{string} \PYG{o}{\PYGZam{}}\PYG{n}{conf\PYGZus{}in}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{c+c1}{// do the importSpatialParameters of the values from combination of command\PYGZhy{}line arguments and file.}
        \PYG{n}{configs}\PYG{p}{.}\PYG{n}{setConfig}\PYG{p}{(}\PYG{n}{conf\PYGZus{}in}\PYG{p}{,} \PYG{n+nb}{false}\PYG{p}{,} \PYG{n+nb}{true}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{configs}\PYG{p}{.}\PYG{n}{parseConfig}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{importParameters}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{k+kt}{void} \PYG{n}{importParameters}\PYG{p}{(}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{sample\PYGZus{}x\PYGZus{}size} \PYG{o}{=} \PYG{n}{stoul}\PYG{p}{(}\PYG{n}{configs}\PYG{p}{.}\PYG{n}{getSectionOptions}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{sample\PYGZus{}grid}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{x}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{0}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{sample\PYGZus{}y\PYGZus{}size} \PYG{o}{=} \PYG{n}{stoul}\PYG{p}{(}\PYG{n}{configs}\PYG{p}{.}\PYG{n}{getSectionOptions}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{sample\PYGZus{}grid}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{y}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{0}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{sample\PYGZus{}x\PYGZus{}offset} \PYG{o}{=} \PYG{n}{stoul}\PYG{p}{(}\PYG{n}{configs}\PYG{p}{.}\PYG{n}{getSectionOptions}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{sample\PYGZus{}grid}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{x\PYGZus{}off}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{0}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{sample\PYGZus{}y\PYGZus{}offset} \PYG{o}{=} \PYG{n}{stoul}\PYG{p}{(}\PYG{n}{configs}\PYG{p}{.}\PYG{n}{getSectionOptions}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{sample\PYGZus{}grid}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{y\PYGZus{}off}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{0}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{uses\PYGZus{}spatial\PYGZus{}sampling} \PYG{o}{=} \PYG{k}{static\PYGZus{}cast}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{bool}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{n}{stoi}\PYG{p}{(}\PYG{n}{configs}\PYG{p}{.}\PYG{n}{getSectionOptions}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{sample\PYGZus{}grid}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}
                                                                                 \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{uses\PYGZus{}spatial\PYGZus{}sampling}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{0}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{configs}\PYG{p}{.}\PYG{n}{hasSection}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{grid\PYGZus{}map}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{grid\PYGZus{}x\PYGZus{}size} \PYG{o}{=} \PYG{n}{stoul}\PYG{p}{(}\PYG{n}{configs}\PYG{p}{.}\PYG{n}{getSectionOptions}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{grid\PYGZus{}map}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{x}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
            \PYG{n}{grid\PYGZus{}y\PYGZus{}size} \PYG{o}{=} \PYG{n}{stoul}\PYG{p}{(}\PYG{n}{configs}\PYG{p}{.}\PYG{n}{getSectionOptions}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{grid\PYGZus{}map}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{y}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{else}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{grid\PYGZus{}x\PYGZus{}size} \PYG{o}{=} \PYG{n}{sample\PYGZus{}x\PYGZus{}size}\PYG{p}{;}
            \PYG{n}{grid\PYGZus{}y\PYGZus{}size} \PYG{o}{=} \PYG{n}{sample\PYGZus{}y\PYGZus{}size}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{n}{sample\PYGZus{}mask\PYGZus{}file} \PYG{o}{=} \PYG{n}{configs}\PYG{p}{.}\PYG{n}{getSectionOptions}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{sample\PYGZus{}grid}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{mask}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{null}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{fine\PYGZus{}map\PYGZus{}file} \PYG{o}{=} \PYG{n}{configs}\PYG{p}{.}\PYG{n}{getSectionOptions}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{fine\PYGZus{}map}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{path}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{none}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{fine\PYGZus{}map\PYGZus{}x\PYGZus{}size} \PYG{o}{=} \PYG{n}{stoul}\PYG{p}{(}\PYG{n}{configs}\PYG{p}{.}\PYG{n}{getSectionOptions}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{fine\PYGZus{}map}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{x}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{0}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{fine\PYGZus{}map\PYGZus{}y\PYGZus{}size} \PYG{o}{=} \PYG{n}{stoul}\PYG{p}{(}\PYG{n}{configs}\PYG{p}{.}\PYG{n}{getSectionOptions}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{fine\PYGZus{}map}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{y}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{0}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{fine\PYGZus{}map\PYGZus{}x\PYGZus{}offset} \PYG{o}{=} \PYG{n}{stoul}\PYG{p}{(}\PYG{n}{configs}\PYG{p}{.}\PYG{n}{getSectionOptions}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{fine\PYGZus{}map}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{x\PYGZus{}off}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{0}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{fine\PYGZus{}map\PYGZus{}y\PYGZus{}offset} \PYG{o}{=} \PYG{n}{stoul}\PYG{p}{(}\PYG{n}{configs}\PYG{p}{.}\PYG{n}{getSectionOptions}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{fine\PYGZus{}map}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{y\PYGZus{}off}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{0}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{coarse\PYGZus{}map\PYGZus{}file} \PYG{o}{=} \PYG{n}{configs}\PYG{p}{.}\PYG{n}{getSectionOptions}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{coarse\PYGZus{}map}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{path}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{none}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{coarse\PYGZus{}map\PYGZus{}x\PYGZus{}size} \PYG{o}{=} \PYG{n}{stoul}\PYG{p}{(}\PYG{n}{configs}\PYG{p}{.}\PYG{n}{getSectionOptions}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{coarse\PYGZus{}map}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{x}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{0}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{coarse\PYGZus{}map\PYGZus{}y\PYGZus{}size} \PYG{o}{=} \PYG{n}{stoul}\PYG{p}{(}\PYG{n}{configs}\PYG{p}{.}\PYG{n}{getSectionOptions}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{coarse\PYGZus{}map}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{y}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{0}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{coarse\PYGZus{}map\PYGZus{}x\PYGZus{}offset} \PYG{o}{=} \PYG{n}{stoul}\PYG{p}{(}\PYG{n}{configs}\PYG{p}{.}\PYG{n}{getSectionOptions}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{coarse\PYGZus{}map}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{x\PYGZus{}off}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{0}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{coarse\PYGZus{}map\PYGZus{}y\PYGZus{}offset} \PYG{o}{=} \PYG{n}{stoul}\PYG{p}{(}\PYG{n}{configs}\PYG{p}{.}\PYG{n}{getSectionOptions}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{coarse\PYGZus{}map}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{y\PYGZus{}off}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{0}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{coarse\PYGZus{}map\PYGZus{}scale} \PYG{o}{=} \PYG{n}{stoul}\PYG{p}{(}\PYG{n}{configs}\PYG{p}{.}\PYG{n}{getSectionOptions}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{coarse\PYGZus{}map}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{scale}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{0}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{pristine\PYGZus{}fine\PYGZus{}map\PYGZus{}file} \PYG{o}{=} \PYG{n}{configs}\PYG{p}{.}\PYG{n}{getSectionOptions}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{pristine\PYGZus{}fine0}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{path}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{none}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{pristine\PYGZus{}coarse\PYGZus{}map\PYGZus{}file} \PYG{o}{=} \PYG{n}{configs}\PYG{p}{.}\PYG{n}{getSectionOptions}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{pristine\PYGZus{}coarse0}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{path}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{none}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{dispersal\PYGZus{}method} \PYG{o}{=} \PYG{n}{configs}\PYG{p}{.}\PYG{n}{getSectionOptions}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{dispersal}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{method}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{none}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{m\PYGZus{}prob} \PYG{o}{=} \PYG{n}{stod}\PYG{p}{(}\PYG{n}{configs}\PYG{p}{.}\PYG{n}{getSectionOptions}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{dispersal}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{m\PYGZus{}probability}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{0}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{cutoff} \PYG{o}{=} \PYG{n}{stod}\PYG{p}{(}\PYG{n}{configs}\PYG{p}{.}\PYG{n}{getSectionOptions}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{dispersal}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{cutoff}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{0.0}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
        \PYG{c+c1}{// quick and dirty conversion for string to bool}
        \PYG{n}{restrict\PYGZus{}self} \PYG{o}{=} \PYG{k}{static\PYGZus{}cast}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{bool}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{n}{stoi}\PYG{p}{(}\PYG{n}{configs}\PYG{p}{.}\PYG{n}{getSectionOptions}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{dispersal}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{restrict\PYGZus{}self}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{0}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{landscape\PYGZus{}type} \PYG{o}{=} \PYG{n}{configs}\PYG{p}{.}\PYG{n}{getSectionOptions}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{dispersal}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{infinite\PYGZus{}landscape}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{none}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{dispersal\PYGZus{}file} \PYG{o}{=} \PYG{n}{configs}\PYG{p}{.}\PYG{n}{getSectionOptions}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{dispersal}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{dispersal\PYGZus{}file}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{none}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{reproduction\PYGZus{}file} \PYG{o}{=} \PYG{n}{configs}\PYG{p}{.}\PYG{n}{getSectionOptions}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{reproduction}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{map}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{none}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{output\PYGZus{}directory} \PYG{o}{=} \PYG{n}{configs}\PYG{p}{.}\PYG{n}{getSectionOptions}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{main}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{output\PYGZus{}directory}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Default}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{the\PYGZus{}seed} \PYG{o}{=} \PYG{n}{stol}\PYG{p}{(}\PYG{n}{configs}\PYG{p}{.}\PYG{n}{getSectionOptions}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{main}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{seed}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{0}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{the\PYGZus{}task} \PYG{o}{=} \PYG{n}{stol}\PYG{p}{(}\PYG{n}{configs}\PYG{p}{.}\PYG{n}{getSectionOptions}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{main}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{job\PYGZus{}type}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{0}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{tau} \PYG{o}{=} \PYG{n}{stod}\PYG{p}{(}\PYG{n}{configs}\PYG{p}{.}\PYG{n}{getSectionOptions}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{main}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{tau}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{0.0}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{sigma} \PYG{o}{=} \PYG{n}{stod}\PYG{p}{(}\PYG{n}{configs}\PYG{p}{.}\PYG{n}{getSectionOptions}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{main}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{sigma}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{0.0}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{deme} \PYG{o}{=} \PYG{n}{stoul}\PYG{p}{(}\PYG{n}{configs}\PYG{p}{.}\PYG{n}{getSectionOptions}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{main}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{deme}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{deme\PYGZus{}sample} \PYG{o}{=} \PYG{n}{stod}\PYG{p}{(}\PYG{n}{configs}\PYG{p}{.}\PYG{n}{getSectionOptions}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{main}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{sample\PYGZus{}size}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{max\PYGZus{}time} \PYG{o}{=} \PYG{n}{stoul}\PYG{p}{(}\PYG{n}{configs}\PYG{p}{.}\PYG{n}{getSectionOptions}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{main}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{max\PYGZus{}time}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{dispersal\PYGZus{}relative\PYGZus{}cost} \PYG{o}{=} \PYG{n}{stod}\PYG{p}{(}\PYG{n}{configs}\PYG{p}{.}\PYG{n}{getSectionOptions}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{main}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{dispersal\PYGZus{}relative\PYGZus{}cost}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{0}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{times\PYGZus{}file} \PYG{o}{=} \PYG{n}{configs}\PYG{p}{.}\PYG{n}{getSectionOptions}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{main}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{time\PYGZus{}config}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{spec} \PYG{o}{=} \PYG{n}{stod}\PYG{p}{(}\PYG{n}{configs}\PYG{p}{.}\PYG{n}{getSectionOptions}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{main}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{min\PYGZus{}spec\PYGZus{}rate}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{desired\PYGZus{}specnum} \PYG{o}{=} \PYG{n}{stoul}\PYG{p}{(}\PYG{n}{configs}\PYG{p}{.}\PYG{n}{getSectionOptions}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{main}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{min\PYGZus{}species}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{1}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{configs}\PYG{p}{.}\PYG{n}{hasSection}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{protracted}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{is\PYGZus{}protracted} \PYG{o}{=} \PYG{k}{static\PYGZus{}cast}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{bool}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{n}{stoi}\PYG{p}{(}
                    \PYG{n}{configs}\PYG{p}{.}\PYG{n}{getSectionOptions}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{protracted}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{has\PYGZus{}protracted}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{0}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
            \PYG{n}{min\PYGZus{}speciation\PYGZus{}gen} \PYG{o}{=} \PYG{n}{stod}\PYG{p}{(}\PYG{n}{configs}\PYG{p}{.}\PYG{n}{getSectionOptions}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{protracted}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{min\PYGZus{}speciation\PYGZus{}gen}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{0.0}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
            \PYG{n}{max\PYGZus{}speciation\PYGZus{}gen} \PYG{o}{=} \PYG{n}{stod}\PYG{p}{(}\PYG{n}{configs}\PYG{p}{.}\PYG{n}{getSectionOptions}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{protracted}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{max\PYGZus{}speciation\PYGZus{}gen}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{n}{setPristine}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{k+kt}{void} \PYG{n}{setKeyParameters}\PYG{p}{(}\PYG{k}{const} \PYG{k+kt}{long} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{task\PYGZus{}in}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{long} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{seed\PYGZus{}in}\PYG{p}{,} \PYG{k}{const} \PYG{n}{string} \PYG{o}{\PYGZam{}}\PYG{n}{output\PYGZus{}directory\PYGZus{}in}\PYG{p}{,}
                          \PYG{k}{const} \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{max\PYGZus{}time\PYGZus{}in}\PYG{p}{,} \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{desired\PYGZus{}specnum\PYGZus{}in}\PYG{p}{,} \PYG{k}{const} \PYG{n}{string} \PYG{o}{\PYGZam{}}\PYG{n}{times\PYGZus{}file\PYGZus{}in}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{the\PYGZus{}task} \PYG{o}{=} \PYG{n}{task\PYGZus{}in}\PYG{p}{;}
        \PYG{n}{the\PYGZus{}seed} \PYG{o}{=} \PYG{n}{seed\PYGZus{}in}\PYG{p}{;}
        \PYG{n}{output\PYGZus{}directory} \PYG{o}{=} \PYG{n}{output\PYGZus{}directory\PYGZus{}in}\PYG{p}{;}
        \PYG{n}{max\PYGZus{}time} \PYG{o}{=} \PYG{n}{max\PYGZus{}time\PYGZus{}in}\PYG{p}{;}
        \PYG{n}{desired\PYGZus{}specnum} \PYG{o}{=} \PYG{n}{desired\PYGZus{}specnum\PYGZus{}in}\PYG{p}{;}
        \PYG{n}{times\PYGZus{}file} \PYG{o}{=} \PYG{n}{times\PYGZus{}file\PYGZus{}in}\PYG{p}{;}

    \PYG{p}{\PYGZcb{}}

    \PYG{k+kt}{void} \PYG{n}{setSpeciationParameters}\PYG{p}{(}\PYG{k}{const} \PYG{k+kt}{long} \PYG{k+kt}{double} \PYG{o}{\PYGZam{}}\PYG{n}{spec\PYGZus{}in}\PYG{p}{,} \PYG{k+kt}{bool} \PYG{n}{is\PYGZus{}protracted\PYGZus{}in}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{double} \PYG{o}{\PYGZam{}}\PYG{n}{min\PYGZus{}speciation\PYGZus{}gen\PYGZus{}in}\PYG{p}{,}
                                 \PYG{k}{const} \PYG{k+kt}{double} \PYG{o}{\PYGZam{}}\PYG{n}{max\PYGZus{}speciation\PYGZus{}gen\PYGZus{}in}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{spec} \PYG{o}{=} \PYG{n}{spec\PYGZus{}in}\PYG{p}{;}
        \PYG{n}{is\PYGZus{}protracted} \PYG{o}{=} \PYG{n}{is\PYGZus{}protracted\PYGZus{}in}\PYG{p}{;}
        \PYG{n}{min\PYGZus{}speciation\PYGZus{}gen} \PYG{o}{=} \PYG{n}{min\PYGZus{}speciation\PYGZus{}gen\PYGZus{}in}\PYG{p}{;}
        \PYG{n}{max\PYGZus{}speciation\PYGZus{}gen} \PYG{o}{=} \PYG{n}{max\PYGZus{}speciation\PYGZus{}gen\PYGZus{}in}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{k+kt}{void} \PYG{n}{setDispersalParameters}\PYG{p}{(}\PYG{k}{const} \PYG{n}{string} \PYG{o}{\PYGZam{}}\PYG{n}{dispersal\PYGZus{}method\PYGZus{}in}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{double} \PYG{o}{\PYGZam{}}\PYG{n}{sigma\PYGZus{}in}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{double} \PYG{o}{\PYGZam{}}\PYG{n}{tau\PYGZus{}in}\PYG{p}{,}
                                \PYG{k}{const} \PYG{k+kt}{double} \PYG{o}{\PYGZam{}}\PYG{n}{m\PYGZus{}prob\PYGZus{}in}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{double} \PYG{o}{\PYGZam{}}\PYG{n}{cutoff\PYGZus{}in}\PYG{p}{,}
                                \PYG{k}{const} \PYG{k+kt}{double} \PYG{o}{\PYGZam{}}\PYG{n}{dispersal\PYGZus{}relative\PYGZus{}cost\PYGZus{}in}\PYG{p}{,} \PYG{k+kt}{bool} \PYG{n}{restrict\PYGZus{}self\PYGZus{}in}\PYG{p}{,}
                                \PYG{k}{const} \PYG{n}{string} \PYG{o}{\PYGZam{}}\PYG{n}{landscape\PYGZus{}type\PYGZus{}in}\PYG{p}{,} \PYG{k}{const} \PYG{n}{string} \PYG{o}{\PYGZam{}}\PYG{n}{dispersal\PYGZus{}file\PYGZus{}in}\PYG{p}{,}
                                \PYG{k}{const} \PYG{n}{string} \PYG{o}{\PYGZam{}}\PYG{n}{reproduction\PYGZus{}file\PYGZus{}in}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{dispersal\PYGZus{}method} \PYG{o}{=} \PYG{n}{dispersal\PYGZus{}method\PYGZus{}in}\PYG{p}{;}
        \PYG{n}{sigma} \PYG{o}{=} \PYG{n}{sigma\PYGZus{}in}\PYG{p}{;}
        \PYG{n}{tau} \PYG{o}{=} \PYG{n}{tau\PYGZus{}in}\PYG{p}{;}
        \PYG{n}{m\PYGZus{}prob} \PYG{o}{=} \PYG{n}{m\PYGZus{}prob\PYGZus{}in}\PYG{p}{;}
        \PYG{n}{cutoff} \PYG{o}{=} \PYG{n}{cutoff\PYGZus{}in}\PYG{p}{;}
        \PYG{n}{dispersal\PYGZus{}relative\PYGZus{}cost} \PYG{o}{=} \PYG{n}{dispersal\PYGZus{}relative\PYGZus{}cost\PYGZus{}in}\PYG{p}{;}
        \PYG{n}{restrict\PYGZus{}self} \PYG{o}{=} \PYG{n}{restrict\PYGZus{}self\PYGZus{}in}\PYG{p}{;}
        \PYG{n}{landscape\PYGZus{}type} \PYG{o}{=} \PYG{n}{landscape\PYGZus{}type\PYGZus{}in}\PYG{p}{;}
        \PYG{n}{dispersal\PYGZus{}file} \PYG{o}{=} \PYG{n}{dispersal\PYGZus{}file\PYGZus{}in}\PYG{p}{;}
        \PYG{n}{reproduction\PYGZus{}file} \PYG{o}{=} \PYG{n}{reproduction\PYGZus{}file\PYGZus{}in}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{k+kt}{void} \PYG{n}{setPristineMapParameters}\PYG{p}{(}\PYG{k}{const} \PYG{n}{string} \PYG{o}{\PYGZam{}}\PYG{n}{pristine\PYGZus{}fine\PYGZus{}file\PYGZus{}map\PYGZus{}in}\PYG{p}{,} \PYG{k}{const} \PYG{n}{string} \PYG{o}{\PYGZam{}}\PYG{n}{pristine\PYGZus{}coarse\PYGZus{}map\PYGZus{}file\PYGZus{}in}\PYG{p}{,}
                                  \PYG{k}{const} \PYG{k+kt}{double} \PYG{o}{\PYGZam{}}\PYG{n}{gen\PYGZus{}since\PYGZus{}pristine\PYGZus{}in}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{double} \PYG{o}{\PYGZam{}}\PYG{n}{habitat\PYGZus{}change\PYGZus{}rate\PYGZus{}in}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{pristine\PYGZus{}fine\PYGZus{}map\PYGZus{}file} \PYG{o}{=} \PYG{n}{pristine\PYGZus{}fine\PYGZus{}file\PYGZus{}map\PYGZus{}in}\PYG{p}{;}
        \PYG{n}{pristine\PYGZus{}coarse\PYGZus{}map\PYGZus{}file} \PYG{o}{=} \PYG{n}{pristine\PYGZus{}coarse\PYGZus{}map\PYGZus{}file\PYGZus{}in}\PYG{p}{;}
        \PYG{n}{gen\PYGZus{}since\PYGZus{}pristine} \PYG{o}{=} \PYG{n}{gen\PYGZus{}since\PYGZus{}pristine\PYGZus{}in}\PYG{p}{;}
        \PYG{n}{habitat\PYGZus{}change\PYGZus{}rate} \PYG{o}{=} \PYG{n}{habitat\PYGZus{}change\PYGZus{}rate\PYGZus{}in}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{k+kt}{void} \PYG{n}{setMapParameters}\PYG{p}{(}\PYG{k}{const} \PYG{n}{string} \PYG{o}{\PYGZam{}}\PYG{n}{fine\PYGZus{}map\PYGZus{}file\PYGZus{}in}\PYG{p}{,} \PYG{k}{const} \PYG{n}{string} \PYG{o}{\PYGZam{}}\PYG{n}{coarse\PYGZus{}map\PYGZus{}file\PYGZus{}in}\PYG{p}{,}
                          \PYG{k}{const} \PYG{n}{string} \PYG{o}{\PYGZam{}}\PYG{n}{sample\PYGZus{}mask\PYGZus{}file\PYGZus{}in}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{grid\PYGZus{}x\PYGZus{}size\PYGZus{}in}\PYG{p}{,}
                          \PYG{k}{const} \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{grid\PYGZus{}y\PYGZus{}size\PYGZus{}in}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{sample\PYGZus{}x\PYGZus{}size\PYGZus{}in}\PYG{p}{,}
                          \PYG{k}{const} \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{sample\PYGZus{}y\PYGZus{}size\PYGZus{}in}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{sample\PYGZus{}x\PYGZus{}offset\PYGZus{}in}\PYG{p}{,}
                          \PYG{k}{const} \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{sample\PYGZus{}y\PYGZus{}offset\PYGZus{}in}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{fine\PYGZus{}map\PYGZus{}x\PYGZus{}size\PYGZus{}in}\PYG{p}{,}
                          \PYG{k}{const} \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{fine\PYGZus{}map\PYGZus{}y\PYGZus{}size\PYGZus{}in}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{fine\PYGZus{}map\PYGZus{}x\PYGZus{}offset\PYGZus{}in}\PYG{p}{,}
                          \PYG{k}{const} \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{fine\PYGZus{}map\PYGZus{}y\PYGZus{}offset\PYGZus{}in}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{coarse\PYGZus{}map\PYGZus{}x\PYGZus{}size\PYGZus{}in}\PYG{p}{,}
                          \PYG{k}{const} \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{coarse\PYGZus{}map\PYGZus{}y\PYGZus{}size\PYGZus{}in}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{coarse\PYGZus{}map\PYGZus{}x\PYGZus{}offset\PYGZus{}in}\PYG{p}{,}
                          \PYG{k}{const} \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{coarse\PYGZus{}map\PYGZus{}y\PYGZus{}offset\PYGZus{}in}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{coarse\PYGZus{}map\PYGZus{}scale\PYGZus{}in}\PYG{p}{,}
                          \PYG{k}{const} \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{deme\PYGZus{}in}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{double} \PYG{o}{\PYGZam{}}\PYG{n}{deme\PYGZus{}sample\PYGZus{}in}\PYG{p}{,} \PYG{k+kt}{bool} \PYG{n}{uses\PYGZus{}spatial\PYGZus{}sampling\PYGZus{}in}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{fine\PYGZus{}map\PYGZus{}file} \PYG{o}{=} \PYG{n}{fine\PYGZus{}map\PYGZus{}file\PYGZus{}in}\PYG{p}{;}
        \PYG{n}{coarse\PYGZus{}map\PYGZus{}file} \PYG{o}{=} \PYG{n}{coarse\PYGZus{}map\PYGZus{}file\PYGZus{}in}\PYG{p}{;}
        \PYG{n}{sample\PYGZus{}mask\PYGZus{}file} \PYG{o}{=} \PYG{n}{sample\PYGZus{}mask\PYGZus{}file\PYGZus{}in}\PYG{p}{;}
        \PYG{n}{grid\PYGZus{}x\PYGZus{}size} \PYG{o}{=} \PYG{n}{grid\PYGZus{}x\PYGZus{}size\PYGZus{}in}\PYG{p}{;}
        \PYG{n}{grid\PYGZus{}y\PYGZus{}size} \PYG{o}{=} \PYG{n}{grid\PYGZus{}y\PYGZus{}size\PYGZus{}in}\PYG{p}{;}
        \PYG{n}{sample\PYGZus{}x\PYGZus{}size} \PYG{o}{=} \PYG{n}{sample\PYGZus{}x\PYGZus{}size\PYGZus{}in}\PYG{p}{;}
        \PYG{n}{sample\PYGZus{}y\PYGZus{}size} \PYG{o}{=} \PYG{n}{sample\PYGZus{}y\PYGZus{}size\PYGZus{}in}\PYG{p}{;}
        \PYG{n}{sample\PYGZus{}x\PYGZus{}offset} \PYG{o}{=} \PYG{n}{sample\PYGZus{}x\PYGZus{}offset\PYGZus{}in}\PYG{p}{;}
        \PYG{n}{sample\PYGZus{}y\PYGZus{}offset} \PYG{o}{=} \PYG{n}{sample\PYGZus{}y\PYGZus{}offset\PYGZus{}in}\PYG{p}{;}
        \PYG{n}{fine\PYGZus{}map\PYGZus{}x\PYGZus{}size} \PYG{o}{=} \PYG{n}{fine\PYGZus{}map\PYGZus{}x\PYGZus{}size\PYGZus{}in}\PYG{p}{;}
        \PYG{n}{fine\PYGZus{}map\PYGZus{}y\PYGZus{}size} \PYG{o}{=} \PYG{n}{fine\PYGZus{}map\PYGZus{}y\PYGZus{}size\PYGZus{}in}\PYG{p}{;}
        \PYG{n}{fine\PYGZus{}map\PYGZus{}x\PYGZus{}offset} \PYG{o}{=} \PYG{n}{fine\PYGZus{}map\PYGZus{}x\PYGZus{}offset\PYGZus{}in}\PYG{p}{;}
        \PYG{n}{fine\PYGZus{}map\PYGZus{}y\PYGZus{}offset} \PYG{o}{=} \PYG{n}{fine\PYGZus{}map\PYGZus{}y\PYGZus{}offset\PYGZus{}in}\PYG{p}{;}
        \PYG{n}{coarse\PYGZus{}map\PYGZus{}x\PYGZus{}size} \PYG{o}{=} \PYG{n}{coarse\PYGZus{}map\PYGZus{}x\PYGZus{}size\PYGZus{}in}\PYG{p}{;}
        \PYG{n}{coarse\PYGZus{}map\PYGZus{}y\PYGZus{}size} \PYG{o}{=} \PYG{n}{coarse\PYGZus{}map\PYGZus{}y\PYGZus{}size\PYGZus{}in}\PYG{p}{;}
        \PYG{n}{coarse\PYGZus{}map\PYGZus{}x\PYGZus{}offset} \PYG{o}{=} \PYG{n}{coarse\PYGZus{}map\PYGZus{}x\PYGZus{}offset\PYGZus{}in}\PYG{p}{;}
        \PYG{n}{coarse\PYGZus{}map\PYGZus{}y\PYGZus{}offset} \PYG{o}{=} \PYG{n}{coarse\PYGZus{}map\PYGZus{}y\PYGZus{}offset\PYGZus{}in}\PYG{p}{;}
        \PYG{n}{coarse\PYGZus{}map\PYGZus{}scale} \PYG{o}{=} \PYG{n}{coarse\PYGZus{}map\PYGZus{}scale\PYGZus{}in}\PYG{p}{;}
        \PYG{n}{deme} \PYG{o}{=} \PYG{n}{deme\PYGZus{}in}\PYG{p}{;}
        \PYG{n}{deme\PYGZus{}sample} \PYG{o}{=} \PYG{n}{deme\PYGZus{}sample\PYGZus{}in}\PYG{p}{;}
        \PYG{n}{uses\PYGZus{}spatial\PYGZus{}sampling} \PYG{o}{=} \PYG{n}{uses\PYGZus{}spatial\PYGZus{}sampling\PYGZus{}in}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{k+kt}{bool} \PYG{n}{setPristine}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{int} \PYG{n}{n}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{is\PYGZus{}pristine} \PYG{o}{=} \PYG{n+nb}{true}\PYG{p}{;}
        \PYG{k+kt}{bool} \PYG{n}{finemapcheck} \PYG{o}{=} \PYG{n+nb}{false}\PYG{p}{;}
        \PYG{k+kt}{bool} \PYG{n}{coarsemapcheck} \PYG{o}{=} \PYG{n+nb}{false}\PYG{p}{;}
        \PYG{c+c1}{// Loop over each element in the config file (each line) and check if it is pristine fine or pristine coarse.}
        \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{configs}\PYG{p}{.}\PYG{n}{getSectionOptionsSize}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{n}{i} \PYG{o}{+}\PYG{o}{+} \PYG{p}{)}
        \PYG{p}{\PYGZob{}}

            \PYG{k}{if}\PYG{p}{(}\PYG{n}{configs}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{section}\PYG{p}{.}\PYG{n}{find}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{pristine\PYGZus{}fine}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{c+c1}{// Then loop over each element to find the number, and check if it is equal to our input number.}
                \PYG{n}{is\PYGZus{}pristine} \PYG{o}{=} \PYG{n+nb}{false}\PYG{p}{;}
                \PYG{k}{if}\PYG{p}{(}\PYG{n}{stol}\PYG{p}{(}\PYG{n}{configs}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getOption}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{number}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{)} \PYG{o}{=}\PYG{o}{=} \PYG{n}{n}\PYG{p}{)}
                \PYG{p}{\PYGZob{}}
                    \PYG{n}{string} \PYG{n}{tmpmapfile}\PYG{p}{;}
                    \PYG{n}{tmpmapfile} \PYG{o}{=} \PYG{n}{configs}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getOption}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{path}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
                    \PYG{k}{if}\PYG{p}{(}\PYG{n}{pristine\PYGZus{}fine\PYGZus{}map\PYGZus{}file} \PYG{o}{!}\PYG{o}{=} \PYG{n}{tmpmapfile}\PYG{p}{)}
                    \PYG{p}{\PYGZob{}}
                        \PYG{n}{finemapcheck} \PYG{o}{=} \PYG{n+nb}{true}\PYG{p}{;}
                        \PYG{n}{pristine\PYGZus{}fine\PYGZus{}map\PYGZus{}file} \PYG{o}{=} \PYG{n}{tmpmapfile}\PYG{p}{;}
                    \PYG{p}{\PYGZcb{}}
                    \PYG{n}{habitat\PYGZus{}change\PYGZus{}rate} \PYG{o}{=} \PYG{n}{stod}\PYG{p}{(}\PYG{n}{configs}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getOption}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{rate}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
                    \PYG{n}{gen\PYGZus{}since\PYGZus{}pristine} \PYG{o}{=} \PYG{n}{stod}\PYG{p}{(}\PYG{n}{configs}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getOption}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{time}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
                \PYG{p}{\PYGZcb{}}
            \PYG{p}{\PYGZcb{}}
            \PYG{k}{else} \PYG{k}{if}\PYG{p}{(}\PYG{n}{configs}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{section}\PYG{p}{.}\PYG{n}{find}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{pristine\PYGZus{}coarse}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{k}{if}\PYG{p}{(}\PYG{n}{stol}\PYG{p}{(}\PYG{n}{configs}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getOption}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{number}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{)} \PYG{o}{=}\PYG{o}{=} \PYG{n}{n}\PYG{p}{)}
                \PYG{p}{\PYGZob{}}
                    \PYG{n}{string} \PYG{n}{tmpmapfile}\PYG{p}{;}
                    \PYG{n}{tmpmapfile} \PYG{o}{=} \PYG{n}{configs}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getOption}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{path}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
                    \PYG{n}{is\PYGZus{}pristine} \PYG{o}{=} \PYG{n+nb}{false}\PYG{p}{;}
                    \PYG{k}{if}\PYG{p}{(}\PYG{n}{tmpmapfile} \PYG{o}{!}\PYG{o}{=} \PYG{n}{pristine\PYGZus{}coarse\PYGZus{}map\PYGZus{}file}\PYG{p}{)}
                    \PYG{p}{\PYGZob{}}
                        \PYG{n}{coarsemapcheck}\PYG{o}{=}\PYG{n+nb}{true}\PYG{p}{;}
                        \PYG{n}{pristine\PYGZus{}coarse\PYGZus{}map\PYGZus{}file} \PYG{o}{=} \PYG{n}{tmpmapfile}\PYG{p}{;}
                        \PYG{c+c1}{// check matches}
                        \PYG{k}{if}\PYG{p}{(}\PYG{n}{habitat\PYGZus{}change\PYGZus{}rate} \PYG{o}{!}\PYG{o}{=} \PYG{n}{stod}\PYG{p}{(}\PYG{n}{configs}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getOption}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{rate}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{)} \PYG{o}{\textbar{}}\PYG{o}{\textbar{}} \PYG{n}{gen\PYGZus{}since\PYGZus{}pristine} \PYG{o}{!}\PYG{o}{=} \PYG{n}{stod}\PYG{p}{(}\PYG{n}{configs}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getOption}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{time}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
                        \PYG{p}{\PYGZob{}}
                            \PYG{n}{cerr} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Forest transform values do not match between fine and coarse maps. Using fine values.}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
                        \PYG{p}{\PYGZcb{}}
                    \PYG{p}{\PYGZcb{}}
                \PYG{p}{\PYGZcb{}}
            \PYG{p}{\PYGZcb{}}
        \PYG{p}{\PYGZcb{}}
        \PYG{c+c1}{// if one of the maps has changed, we need to update, so return true.}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{finemapcheck} \PYG{o}{!}\PYG{o}{=} \PYG{n}{coarsemapcheck}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{k}{return} \PYG{n+nb}{true}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{else}
        \PYG{p}{\PYGZob{}}
            \PYG{c+c1}{// finemapcheck should therefore be the same as coarsemapcheck}
            \PYG{k}{return} \PYG{n}{finemapcheck}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
    \PYG{p}{\PYGZcb{}}
    \PYG{k+kt}{void} \PYG{n}{printVars}\PYG{p}{(}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{stringstream} \PYG{n}{os}\PYG{p}{;}
        \PYG{n}{os} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Seed: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{the\PYGZus{}seed} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
        \PYG{n}{os} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Speciation rate: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{spec} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
        \PYG{n}{os} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Dispersal (tau, sigma): }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{tau} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{, }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{sigma} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
        \PYG{n}{os} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Dispersal method: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{dispersal\PYGZus{}method} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{dispersal\PYGZus{}method} \PYG{o}{=}\PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{norm\PYGZhy{}uniform}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{os} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Dispersal (m, cutoff): }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{m\PYGZus{}prob} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{, }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{cutoff} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{is\PYGZus{}protracted}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{os} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Protracted variables: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{min\PYGZus{}speciation\PYGZus{}gen} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{, }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{max\PYGZus{}speciation\PYGZus{}gen} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{n}{os} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Job Type: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{the\PYGZus{}task} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
        \PYG{n}{os} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Max time: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{max\PYGZus{}time} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
        \PYG{n}{os} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Fine input file: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{fine\PYGZus{}map\PYGZus{}file}  \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
        \PYG{n}{os} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZhy{}dimensions: (}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{fine\PYGZus{}map\PYGZus{}x\PYGZus{}size} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{, }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{fine\PYGZus{}map\PYGZus{}y\PYGZus{}size} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{)}\PYG{l+s}{\PYGZdq{}}\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
        \PYG{n}{os} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZhy{}offset: (}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{fine\PYGZus{}map\PYGZus{}x\PYGZus{}offset} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{, }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{fine\PYGZus{}map\PYGZus{}y\PYGZus{}offset} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{)}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
        \PYG{n}{os} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Coarse input file: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{coarse\PYGZus{}map\PYGZus{}file}  \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
        \PYG{n}{os} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZhy{}dimensions: (}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{coarse\PYGZus{}map\PYGZus{}x\PYGZus{}size} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{, }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{coarse\PYGZus{}map\PYGZus{}y\PYGZus{}size} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{)}\PYG{l+s}{\PYGZdq{}}\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
        \PYG{n}{os} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZhy{}offset: (}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{coarse\PYGZus{}map\PYGZus{}x\PYGZus{}offset} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{, }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{coarse\PYGZus{}map\PYGZus{}y\PYGZus{}offset} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{)}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
        \PYG{n}{os} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZhy{}scale: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{coarse\PYGZus{}map\PYGZus{}scale} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
        \PYG{n}{os} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Sample grid}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
        \PYG{n}{os} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZhy{}dimensions: (}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{sample\PYGZus{}x\PYGZus{}size} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{, }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{sample\PYGZus{}y\PYGZus{}size} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{)}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
        \PYG{n}{os} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZhy{}optimised area: (}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{grid\PYGZus{}x\PYGZus{}size} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{, }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{grid\PYGZus{}y\PYGZus{}size} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{)}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
        \PYG{n}{os} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZhy{}optimised offsets: (}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{sample\PYGZus{}x\PYGZus{}offset} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{, }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{sample\PYGZus{}y\PYGZus{}offset} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{)}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
        \PYG{n}{os} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZhy{}deme: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{deme} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
        \PYG{n}{os} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZhy{}deme sample: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{deme\PYGZus{}sample} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
        \PYG{n}{os} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Output directory: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{output\PYGZus{}directory} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
        \PYG{n}{os} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Disp Rel Cost: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{dispersal\PYGZus{}relative\PYGZus{}cost} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
        \PYG{n}{writeInfo}\PYG{p}{(}\PYG{n}{os}\PYG{p}{.}\PYG{n}{str}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{k+kt}{void} \PYG{n}{setMetacommunityParameters}\PYG{p}{(}\PYG{k}{const} \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{metacommunity\PYGZus{}size}\PYG{p}{,}
                                    \PYG{k}{const} \PYG{k+kt}{double} \PYG{o}{\PYGZam{}}\PYG{n}{speciation\PYGZus{}rate}\PYG{p}{,}
                                    \PYG{k}{const} \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{seed}\PYG{p}{,}
                                    \PYG{k}{const} \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{job}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{output\PYGZus{}directory} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Default}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
        \PYG{c+c1}{// randomise the seed slightly so that we get a different starting number to the initial simulation}
        \PYG{n}{the\PYGZus{}seed} \PYG{o}{=} \PYG{k}{static\PYGZus{}cast}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{long} \PYG{k+kt}{long} \PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{n}{seed} \PYG{o}{*} \PYG{n}{job}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{the\PYGZus{}task} \PYG{o}{=} \PYG{p}{(}\PYG{k+kt}{long} \PYG{k+kt}{long} \PYG{k+kt}{int}\PYG{p}{)} \PYG{n}{job}\PYG{p}{;}
        \PYG{n}{deme} \PYG{o}{=} \PYG{n}{metacommunity\PYGZus{}size}\PYG{p}{;}
        \PYG{n}{deme\PYGZus{}sample} \PYG{o}{=} \PYG{l+m+mf}{1.0}\PYG{p}{;}
        \PYG{n}{spec} \PYG{o}{=} \PYG{n}{speciation\PYGZus{}rate}\PYG{p}{;}
        \PYG{c+c1}{// Default to 1000 seconds \PYGZhy{} should be enough for most simulation sizes, but can be changed later if needed.}
        \PYG{n}{max\PYGZus{}time} \PYG{o}{=} \PYG{l+m+mi}{1000}\PYG{p}{;}
        \PYG{n}{times\PYGZus{}file} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{null}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
        \PYG{n}{min\PYGZus{}speciation\PYGZus{}gen} \PYG{o}{=} \PYG{l+m+mf}{0.0}\PYG{p}{;}
        \PYG{n}{max\PYGZus{}speciation\PYGZus{}gen} \PYG{o}{=} \PYG{l+m+mf}{0.0}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{k}{friend} \PYG{n}{ostream}\PYG{o}{\PYGZam{}} \PYG{k}{operator}\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{p}{(}\PYG{n}{ostream}\PYG{o}{\PYGZam{}} \PYG{n}{os}\PYG{p}{,}\PYG{k}{const} \PYG{n}{SimParameters}\PYG{o}{\PYGZam{}} \PYG{n}{m}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{os} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{m}\PYG{p}{.}\PYG{n}{fine\PYGZus{}map\PYGZus{}file} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{m}\PYG{p}{.}\PYG{n}{coarse\PYGZus{}map\PYGZus{}file} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{m}\PYG{p}{.}\PYG{n}{pristine\PYGZus{}fine\PYGZus{}map\PYGZus{}file} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
        \PYG{n}{os} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{m}\PYG{p}{.}\PYG{n}{pristine\PYGZus{}coarse\PYGZus{}map\PYGZus{}file} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{m}\PYG{p}{.}\PYG{n}{sample\PYGZus{}mask\PYGZus{}file} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
        \PYG{n}{os} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{m}\PYG{p}{.}\PYG{n}{the\PYGZus{}seed} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}  \PYG{n}{m}\PYG{p}{.}\PYG{n}{the\PYGZus{}task} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}  \PYG{n}{m}\PYG{p}{.}\PYG{n}{grid\PYGZus{}x\PYGZus{}size} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{m}\PYG{p}{.}\PYG{n}{grid\PYGZus{}y\PYGZus{}size} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
        \PYG{n}{os} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{m}\PYG{p}{.}\PYG{n}{sample\PYGZus{}x\PYGZus{}size} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{m}\PYG{p}{.}\PYG{n}{sample\PYGZus{}y\PYGZus{}size} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{m}\PYG{p}{.}\PYG{n}{sample\PYGZus{}x\PYGZus{}offset} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{m}\PYG{p}{.}\PYG{n}{sample\PYGZus{}y\PYGZus{}offset} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
        \PYG{n}{os} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{m}\PYG{p}{.}\PYG{n}{fine\PYGZus{}map\PYGZus{}x\PYGZus{}size} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{m}\PYG{p}{.}\PYG{n}{fine\PYGZus{}map\PYGZus{}y\PYGZus{}size} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
        \PYG{n}{os} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{m}\PYG{p}{.}\PYG{n}{fine\PYGZus{}map\PYGZus{}x\PYGZus{}offset} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{m}\PYG{p}{.}\PYG{n}{fine\PYGZus{}map\PYGZus{}y\PYGZus{}offset} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{m}\PYG{p}{.}\PYG{n}{coarse\PYGZus{}map\PYGZus{}x\PYGZus{}size} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{m}\PYG{p}{.}\PYG{n}{coarse\PYGZus{}map\PYGZus{}y\PYGZus{}size} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{m}\PYG{p}{.}\PYG{n}{coarse\PYGZus{}map\PYGZus{}x\PYGZus{}offset} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
        \PYG{n}{os} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{m}\PYG{p}{.}\PYG{n}{coarse\PYGZus{}map\PYGZus{}y\PYGZus{}offset} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{m}\PYG{p}{.}\PYG{n}{coarse\PYGZus{}map\PYGZus{}scale} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{m}\PYG{p}{.}\PYG{n}{desired\PYGZus{}specnum} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
        \PYG{n}{os} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{m}\PYG{p}{.}\PYG{n}{dispersal\PYGZus{}relative\PYGZus{}cost} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{m}\PYG{p}{.}\PYG{n}{deme} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{m}\PYG{p}{.}\PYG{n}{deme\PYGZus{}sample}\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
        \PYG{n}{os} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{m}\PYG{p}{.}\PYG{n}{spec} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{m}\PYG{p}{.}\PYG{n}{sigma} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{m}\PYG{p}{.}\PYG{n}{max\PYGZus{}time} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{m}\PYG{p}{.}\PYG{n}{gen\PYGZus{}since\PYGZus{}pristine} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{m}\PYG{p}{.} \PYG{n}{habitat\PYGZus{}change\PYGZus{}rate} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{m}\PYG{p}{.}\PYG{n}{tau}\PYG{p}{;}
        \PYG{n}{os} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{m}\PYG{p}{.}\PYG{n}{dispersal\PYGZus{}method} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
        \PYG{n}{os} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{m}\PYG{p}{.}\PYG{n}{m\PYGZus{}prob} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{m}\PYG{p}{.}\PYG{n}{cutoff} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{m}\PYG{p}{.}\PYG{n}{restrict\PYGZus{}self} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{m}\PYG{p}{.}\PYG{n}{landscape\PYGZus{}type} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{m}\PYG{p}{.}\PYG{n}{times\PYGZus{}file} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
        \PYG{n}{os} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{m}\PYG{p}{.}\PYG{n}{dispersal\PYGZus{}file} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{m}\PYG{p}{.}\PYG{n}{uses\PYGZus{}spatial\PYGZus{}sampling} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
        \PYG{n}{os} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{m}\PYG{p}{.}\PYG{n}{configs}\PYG{p}{;}
        \PYG{k}{return} \PYG{n}{os}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{k}{friend} \PYG{n}{istream}\PYG{o}{\PYGZam{}} \PYG{k}{operator}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{n}{istream}\PYG{o}{\PYGZam{}} \PYG{n}{is}\PYG{p}{,} \PYG{n}{SimParameters}\PYG{o}{\PYGZam{}} \PYG{n}{m}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{getline}\PYG{p}{(}\PYG{n}{is}\PYG{p}{,} \PYG{n}{m}\PYG{p}{.}\PYG{n}{fine\PYGZus{}map\PYGZus{}file}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{getline}\PYG{p}{(}\PYG{n}{is}\PYG{p}{,} \PYG{n}{m}\PYG{p}{.}\PYG{n}{coarse\PYGZus{}map\PYGZus{}file}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{getline}\PYG{p}{(}\PYG{n}{is}\PYG{p}{,} \PYG{n}{m}\PYG{p}{.}\PYG{n}{pristine\PYGZus{}fine\PYGZus{}map\PYGZus{}file}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{getline}\PYG{p}{(}\PYG{n}{is}\PYG{p}{,} \PYG{n}{m}\PYG{p}{.}\PYG{n}{pristine\PYGZus{}coarse\PYGZus{}map\PYGZus{}file}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{getline}\PYG{p}{(}\PYG{n}{is}\PYG{p}{,} \PYG{n}{m}\PYG{p}{.}\PYG{n}{sample\PYGZus{}mask\PYGZus{}file}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{is} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{m}\PYG{p}{.}\PYG{n}{the\PYGZus{}seed} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{m}\PYG{p}{.}\PYG{n}{the\PYGZus{}task} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}}  \PYG{n}{m}\PYG{p}{.}\PYG{n}{grid\PYGZus{}x\PYGZus{}size} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{m}\PYG{p}{.}\PYG{n}{grid\PYGZus{}y\PYGZus{}size}\PYG{p}{;}
        \PYG{n}{is} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{m}\PYG{p}{.}\PYG{n}{sample\PYGZus{}x\PYGZus{}size} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{m}\PYG{p}{.}\PYG{n}{sample\PYGZus{}y\PYGZus{}size} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{m}\PYG{p}{.}\PYG{n}{sample\PYGZus{}x\PYGZus{}offset} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{m}\PYG{p}{.}\PYG{n}{sample\PYGZus{}y\PYGZus{}offset}\PYG{p}{;}
        \PYG{n}{is} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{m}\PYG{p}{.}\PYG{n}{fine\PYGZus{}map\PYGZus{}x\PYGZus{}size} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{m}\PYG{p}{.}\PYG{n}{fine\PYGZus{}map\PYGZus{}y\PYGZus{}size}\PYG{p}{;}
        \PYG{n}{is} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{m}\PYG{p}{.}\PYG{n}{fine\PYGZus{}map\PYGZus{}x\PYGZus{}offset} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{m}\PYG{p}{.}\PYG{n}{fine\PYGZus{}map\PYGZus{}y\PYGZus{}offset} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{m}\PYG{p}{.}\PYG{n}{coarse\PYGZus{}map\PYGZus{}x\PYGZus{}size} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{m}\PYG{p}{.}\PYG{n}{coarse\PYGZus{}map\PYGZus{}y\PYGZus{}size} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{m}\PYG{p}{.}\PYG{n}{coarse\PYGZus{}map\PYGZus{}x\PYGZus{}offset} \PYG{p}{;}
        \PYG{n}{is} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{m}\PYG{p}{.}\PYG{n}{coarse\PYGZus{}map\PYGZus{}y\PYGZus{}offset} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{m}\PYG{p}{.}\PYG{n}{coarse\PYGZus{}map\PYGZus{}scale} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{m}\PYG{p}{.}\PYG{n}{desired\PYGZus{}specnum} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{m}\PYG{p}{.}\PYG{n}{dispersal\PYGZus{}relative\PYGZus{}cost} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{m}\PYG{p}{.}\PYG{n}{deme} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{m}\PYG{p}{.}\PYG{n}{deme\PYGZus{}sample}\PYG{p}{;}
        \PYG{n}{is} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{m}\PYG{p}{.}\PYG{n}{spec} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{m}\PYG{p}{.}\PYG{n}{sigma} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{m}\PYG{p}{.}\PYG{n}{max\PYGZus{}time} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{m}\PYG{p}{.}\PYG{n}{gen\PYGZus{}since\PYGZus{}pristine} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{m}\PYG{p}{.}\PYG{n}{habitat\PYGZus{}change\PYGZus{}rate} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{m}\PYG{p}{.}\PYG{n}{tau}\PYG{p}{;}
        \PYG{n}{is}\PYG{p}{.}\PYG{n}{ignore}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{getline}\PYG{p}{(}\PYG{n}{is}\PYG{p}{,} \PYG{n}{m}\PYG{p}{.}\PYG{n}{dispersal\PYGZus{}method}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{is} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{m}\PYG{p}{.}\PYG{n}{m\PYGZus{}prob} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{m}\PYG{p}{.}\PYG{n}{cutoff} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{m}\PYG{p}{.}\PYG{n}{restrict\PYGZus{}self} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{m}\PYG{p}{.}\PYG{n}{landscape\PYGZus{}type}\PYG{p}{;}
        \PYG{n}{is}\PYG{p}{.}\PYG{n}{ignore}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{getline}\PYG{p}{(}\PYG{n}{is}\PYG{p}{,} \PYG{n}{m}\PYG{p}{.}\PYG{n}{times\PYGZus{}file}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{getline}\PYG{p}{(}\PYG{n}{is}\PYG{p}{,} \PYG{n}{m}\PYG{p}{.}\PYG{n}{dispersal\PYGZus{}file}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{is} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{m}\PYG{p}{.}\PYG{n}{uses\PYGZus{}spatial\PYGZus{}sampling}\PYG{p}{;}
        \PYG{n}{is} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{m}\PYG{p}{.}\PYG{n}{configs}\PYG{p}{;}
        \PYG{k}{return} \PYG{n}{is}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}


\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif }\PYG{c+c1}{//SPECIATIONCOUNTER\PYGZus{}SIMPARAMETERS\PYGZus{}H}
\end{sphinxVerbatim}


\subsubsection{Detailed Description}
\label{\detokenize{api/file_necsim_SimParameters.h:detailed-description}}
Sam Thompson
Contact: \sphinxhref{mailto:samuel.thompson14@imperial.ac.uk}{samuel.thompson14@imperial.ac.uk} or \sphinxhref{mailto:thompsonsed@gmail.com}{thompsonsed@gmail.com} BSD-3 Licence.


\subsubsection{Includes}
\label{\detokenize{api/file_necsim_SimParameters.h:includes}}\begin{itemize}
\item {} 
\sphinxcode{ConfigFileParser.h} ({\hyperref[\detokenize{api/file_necsim_ConfigFileParser.h:file-necsim-configfileparser-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File ConfigFileParser.h}}}})

\item {} 
\sphinxcode{Logging.h} ({\hyperref[\detokenize{api/file_necsim_Logging.h:file-necsim-logging-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File Logging.h}}}})

\item {} 
\sphinxcode{string}

\item {} 
\sphinxcode{vector}

\end{itemize}


\subsubsection{Included By}
\label{\detokenize{api/file_necsim_SimParameters.h:included-by}}\begin{itemize}
\item {} 
{\hyperref[\detokenize{api/file_necsim_DataMask.h:file-necsim-datamask-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File DataMask.h}}}}

\item {} 
{\hyperref[\detokenize{api/file_necsim_Map.h:file-necsim-map-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File Map.h}}}}

\item {} 
{\hyperref[\detokenize{api/file_necsim_Tree.h:file-necsim-tree-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File Tree.h}}}}

\item {} 
{\hyperref[\detokenize{api/file_necsim_SpatialTree.h:file-necsim-spatialtree-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File SpatialTree.h}}}}

\end{itemize}


\subsubsection{Classes}
\label{\detokenize{api/file_necsim_SimParameters.h:classes}}\begin{itemize}
\item {} 
{\hyperref[\detokenize{api/struct_SimParameters:struct-simparameters}]{\sphinxcrossref{\DUrole{std,std-ref}{Struct SimParameters}}}}

\end{itemize}


\subsection{File SimulateDispersal.cpp}
\label{\detokenize{api/file_necsim_SimulateDispersal.cpp::doc}}\label{\detokenize{api/file_necsim_SimulateDispersal.cpp:file-simulatedispersal-cpp}}\label{\detokenize{api/file_necsim_SimulateDispersal.cpp:file-necsim-simulatedispersal-cpp}}
Contains the ability to simulate a given dispersal kernel on a specified density map, outputting the effect dispersal distance distribution to an SQL file after n number of dispersal events (specified by the user).

\begin{sphinxShadowBox}
\sphinxstyletopictitle{Contents}
\begin{itemize}
\item {} 
\phantomsection\label{\detokenize{api/file_necsim_SimulateDispersal.cpp:id1}}{\hyperref[\detokenize{api/file_necsim_SimulateDispersal.cpp:definition-necsim-simulatedispersal-cpp}]{\sphinxcrossref{Definition (\sphinxcode{necsim/SimulateDispersal.cpp})}}}

\item {} 
\phantomsection\label{\detokenize{api/file_necsim_SimulateDispersal.cpp:id2}}{\hyperref[\detokenize{api/file_necsim_SimulateDispersal.cpp:detailed-description}]{\sphinxcrossref{Detailed Description}}}

\item {} 
\phantomsection\label{\detokenize{api/file_necsim_SimulateDispersal.cpp:id3}}{\hyperref[\detokenize{api/file_necsim_SimulateDispersal.cpp:includes}]{\sphinxcrossref{Includes}}}

\item {} 
\phantomsection\label{\detokenize{api/file_necsim_SimulateDispersal.cpp:id4}}{\hyperref[\detokenize{api/file_necsim_SimulateDispersal.cpp:functions}]{\sphinxcrossref{Functions}}}

\end{itemize}
\end{sphinxShadowBox}


\subsubsection{Definition (\sphinxstyleliteralintitle{necsim/SimulateDispersal.cpp})}
\label{\detokenize{api/file_necsim_SimulateDispersal.cpp:definition-necsim-simulatedispersal-cpp}}

\paragraph{Program Listing for File SimulateDispersal.cpp}
\label{\detokenize{api/program_listing_file_necsim_SimulateDispersal.cpp:program-listing-for-file-simulatedispersal-cpp}}\label{\detokenize{api/program_listing_file_necsim_SimulateDispersal.cpp::doc}}\label{\detokenize{api/program_listing_file_necsim_SimulateDispersal.cpp:program-listing-file-necsim-simulatedispersal-cpp}}\begin{itemize}
\item {} 
Return to documentation for {\hyperref[\detokenize{api/file_necsim_SimulateDispersal.cpp:file-necsim-simulatedispersal-cpp}]{\sphinxcrossref{\DUrole{std,std-ref}{File SimulateDispersal.cpp}}}}

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{// This file is part of NECSim project which is released under BSD\PYGZhy{}3 license.}
\PYG{c+c1}{// See file **LICENSE.txt** or visit https://opensource.org/licenses/BSD\PYGZhy{}3\PYGZhy{}Clause) for full license details.}

\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZdq{}SimulateDispersal.h\PYGZdq{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZdq{}CustomExceptions.h\PYGZdq{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZdq{}Filesystem.h\PYGZdq{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZdq{}Community.h\PYGZdq{}}

\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}utility\PYGZgt{}}

\PYG{k+kt}{double} \PYG{n+nf}{distanceBetween}\PYG{p}{(}\PYG{n}{Cell} \PYG{o}{\PYGZam{}}\PYG{n}{c1}\PYG{p}{,} \PYG{n}{Cell} \PYG{o}{\PYGZam{}}\PYG{n}{c2}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k}{return} \PYG{n}{pow}\PYG{p}{(}\PYG{n}{pow}\PYG{p}{(}\PYG{n}{c1}\PYG{p}{.}\PYG{n}{x} \PYG{o}{\PYGZhy{}} \PYG{n}{c2}\PYG{p}{.}\PYG{n}{x}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{)} \PYG{o}{+} \PYG{n}{pow}\PYG{p}{(}\PYG{n}{c1}\PYG{p}{.}\PYG{n}{y} \PYG{o}{\PYGZhy{}} \PYG{n}{c2}\PYG{p}{.}\PYG{n}{y}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{,} \PYG{l+m+mf}{0.5}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{void} \PYG{n}{SimulateDispersal}\PYG{o}{:}\PYG{o}{:}\PYG{n}{setSequential}\PYG{p}{(}\PYG{k+kt}{bool} \PYG{n}{bSequential}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{n}{is\PYGZus{}sequential} \PYG{o}{=} \PYG{n}{bSequential}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{void} \PYG{n}{SimulateDispersal}\PYG{o}{:}\PYG{o}{:}\PYG{n}{setSizes}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{x}\PYG{p}{,} \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{y}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k}{if}\PYG{p}{(}\PYG{o}{!}\PYG{n}{has\PYGZus{}set\PYGZus{}size}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{density\PYGZus{}map}\PYG{p}{.}\PYG{n}{SetSize}\PYG{p}{(}\PYG{n}{y}\PYG{p}{,} \PYG{n}{x}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{has\PYGZus{}set\PYGZus{}size} \PYG{o}{=} \PYG{n+nb}{true}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{else}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{throw} \PYG{n}{FatalException}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Dimensions of the density map already set.}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{void} \PYG{n}{SimulateDispersal}\PYG{o}{:}\PYG{o}{:}\PYG{n}{importMaps}\PYG{p}{(}\PYG{n}{string} \PYG{n}{map\PYGZus{}file}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k}{if}\PYG{p}{(}\PYG{n}{has\PYGZus{}set\PYGZus{}size}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{map\PYGZus{}name} \PYG{o}{=} \PYG{n}{map\PYGZus{}file}\PYG{p}{;}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{map\PYGZus{}file} \PYG{o}{!}\PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{null}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{density\PYGZus{}map}\PYG{p}{.}\PYG{n}{import}\PYG{p}{(}\PYG{n}{map\PYGZus{}file}\PYG{p}{)}\PYG{p}{;}
            \PYG{c+c1}{// Now loop over the density map to find the maximum value}
            \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{density\PYGZus{}map}\PYG{p}{.}\PYG{n}{GetRows}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{n}{i} \PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{j} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{j} \PYG{o}{\PYGZlt{}} \PYG{n}{density\PYGZus{}map}\PYG{p}{.}\PYG{n}{GetCols}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{n}{j} \PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
                \PYG{p}{\PYGZob{}}
                    \PYG{k}{if}\PYG{p}{(}\PYG{n}{density\PYGZus{}map}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]} \PYG{o}{\PYGZgt{}} \PYG{n}{max\PYGZus{}density}\PYG{p}{)}
                    \PYG{p}{\PYGZob{}}
                        \PYG{n}{max\PYGZus{}density} \PYG{o}{=} \PYG{n}{density\PYGZus{}map}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{p}{;}
                    \PYG{p}{\PYGZcb{}}
                \PYG{p}{\PYGZcb{}}
            \PYG{p}{\PYGZcb{}}
            \PYG{k}{if}\PYG{p}{(}\PYG{n}{max\PYGZus{}density} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{1}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{k}{throw} \PYG{n}{FatalException}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Maximum density on density map is less than 1. Please check your maps.}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{else}
        \PYG{p}{\PYGZob{}}
            \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{density\PYGZus{}map}\PYG{p}{.}\PYG{n}{GetRows}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{n}{i} \PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{j} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{j} \PYG{o}{\PYGZlt{}} \PYG{n}{density\PYGZus{}map}\PYG{p}{.}\PYG{n}{GetCols}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{n}{j} \PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
                \PYG{p}{\PYGZob{}}
                    \PYG{n}{density\PYGZus{}map}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;}
                \PYG{p}{\PYGZcb{}}
            \PYG{p}{\PYGZcb{}}
            \PYG{n}{max\PYGZus{}density} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{else}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{throw} \PYG{n}{FatalException}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Dimensions of density map not set before importSpatialParameters}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{void} \PYG{n}{SimulateDispersal}\PYG{o}{:}\PYG{o}{:}\PYG{n}{setDispersalParameters}\PYG{p}{(}
    \PYG{n}{string} \PYG{n}{dispersal\PYGZus{}method\PYGZus{}in}\PYG{p}{,} \PYG{k+kt}{double} \PYG{n}{sigma\PYGZus{}in}\PYG{p}{,} \PYG{k+kt}{double} \PYG{n}{tau\PYGZus{}in}\PYG{p}{,} \PYG{k+kt}{double} \PYG{n}{m\PYGZus{}prob\PYGZus{}in}\PYG{p}{,} \PYG{k+kt}{double} \PYG{n}{cutoff\PYGZus{}in}\PYG{p}{,}
    \PYG{n}{string} \PYG{n}{landscape\PYGZus{}type}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{n}{random}\PYG{p}{.}\PYG{n}{setDispersalMethod}\PYG{p}{(}\PYG{n}{dispersal\PYGZus{}method\PYGZus{}in}\PYG{p}{,} \PYG{n}{m\PYGZus{}prob\PYGZus{}in}\PYG{p}{,} \PYG{n}{cutoff\PYGZus{}in}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{random}\PYG{p}{.}\PYG{n}{setDispersalParams}\PYG{p}{(}\PYG{n}{sigma\PYGZus{}in}\PYG{p}{,} \PYG{n}{tau\PYGZus{}in}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{setLandscapeType}\PYG{p}{(}\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{move}\PYG{p}{(}\PYG{n}{landscape\PYGZus{}type}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{dispersal\PYGZus{}method} \PYG{o}{=} \PYG{n}{dispersal\PYGZus{}method\PYGZus{}in}\PYG{p}{;}
    \PYG{n}{sigma} \PYG{o}{=} \PYG{n}{sigma\PYGZus{}in}\PYG{p}{;}
    \PYG{n}{tau} \PYG{o}{=} \PYG{n}{tau\PYGZus{}in}\PYG{p}{;}
    \PYG{n}{m\PYGZus{}prob} \PYG{o}{=} \PYG{n}{m\PYGZus{}prob\PYGZus{}in}\PYG{p}{;}
    \PYG{n}{cutoff} \PYG{o}{=} \PYG{n}{cutoff\PYGZus{}in}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{void} \PYG{n}{SimulateDispersal}\PYG{o}{:}\PYG{o}{:}\PYG{n}{setLandscapeType}\PYG{p}{(}\PYG{n}{string} \PYG{n}{landscape\PYGZus{}type}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k}{if}\PYG{p}{(}\PYG{n}{landscape\PYGZus{}type} \PYG{o}{=}\PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{infinite}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{getValFptr} \PYG{o}{=} \PYG{o}{\PYGZam{}}\PYG{n}{SimulateDispersal}\PYG{o}{:}\PYG{o}{:}\PYG{n}{getEndPointInfinite}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{else} \PYG{k}{if}\PYG{p}{(}\PYG{n}{landscape\PYGZus{}type} \PYG{o}{=}\PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{closed}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{getValFptr} \PYG{o}{=} \PYG{o}{\PYGZam{}}\PYG{n}{SimulateDispersal}\PYG{o}{:}\PYG{o}{:}\PYG{n}{getEndPointClosed}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{else} \PYG{k}{if}\PYG{p}{(}\PYG{n}{landscape\PYGZus{}type} \PYG{o}{=}\PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{tiled}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{getValFptr} \PYG{o}{=} \PYG{o}{\PYGZam{}}\PYG{n}{SimulateDispersal}\PYG{o}{:}\PYG{o}{:}\PYG{n}{getEndPointTiled}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{else}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{throw} \PYG{n}{FatalException}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Landscape type not compatible: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{+} \PYG{n}{landscape\PYGZus{}type}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{void} \PYG{n}{SimulateDispersal}\PYG{o}{:}\PYG{o}{:}\PYG{n}{setOutputDatabase}\PYG{p}{(}\PYG{n}{string} \PYG{n}{out\PYGZus{}database}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{c+c1}{// Check the file is a database}
    \PYG{k}{if}\PYG{p}{(}\PYG{n}{out\PYGZus{}database}\PYG{p}{.}\PYG{n}{substr}\PYG{p}{(}\PYG{n}{out\PYGZus{}database}\PYG{p}{.}\PYG{n}{length}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{3}\PYG{p}{)} \PYG{o}{!}\PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{.db}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{throw} \PYG{n}{FatalException}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Output database is not a .db file, check file name.}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{c+c1}{// Open our SQL connection to the database}
    \PYG{k+kt}{int} \PYG{n}{o2} \PYG{o}{=} \PYG{n}{sqlite3\PYGZus{}open\PYGZus{}v2}\PYG{p}{(}\PYG{n}{out\PYGZus{}database}\PYG{p}{.}\PYG{n}{c\PYGZus{}str}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{database}\PYG{p}{,} \PYG{n}{SQLITE\PYGZus{}OPEN\PYGZus{}READWRITE} \PYG{o}{\textbar{}} \PYG{n}{SQLITE\PYGZus{}OPEN\PYGZus{}CREATE}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{unix\PYGZhy{}dotfile}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{k}{if}\PYG{p}{(}\PYG{n}{o2} \PYG{o}{!}\PYG{o}{=} \PYG{n}{SQLITE\PYGZus{}OK} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{n}{o2} \PYG{o}{!}\PYG{o}{=} \PYG{n}{SQLITE\PYGZus{}DONE}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{throw} \PYG{n}{FatalException}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Database file cannot be opened or created.}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{void} \PYG{n}{SimulateDispersal}\PYG{o}{:}\PYG{o}{:}\PYG{n}{setNumberRepeats}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{n}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{n}{num\PYGZus{}repeats} \PYG{o}{=} \PYG{n}{n}\PYG{p}{;}
    \PYG{n}{distances}\PYG{p}{.}\PYG{n}{resize}\PYG{p}{(}\PYG{n}{num\PYGZus{}repeats}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{void} \PYG{n}{SimulateDispersal}\PYG{o}{:}\PYG{o}{:}\PYG{n}{setNumberSteps}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{s}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{n}{num\PYGZus{}steps} \PYG{o}{=} \PYG{n}{s}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{void} \PYG{n}{SimulateDispersal}\PYG{o}{:}\PYG{o}{:}\PYG{n}{storeCellList}\PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{total} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
    \PYG{c+c1}{// First count the number of density cells and pick a cell size}
    \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{density\PYGZus{}map}\PYG{p}{.}\PYG{n}{GetRows}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{j} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{j} \PYG{o}{\PYGZlt{}} \PYG{n}{density\PYGZus{}map}\PYG{p}{.}\PYG{n}{GetCols}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{n}{j}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{total} \PYG{o}{+}\PYG{o}{=} \PYG{n}{density\PYGZus{}map}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
    \PYG{p}{\PYGZcb{}}
    \PYG{n}{cells}\PYG{p}{.}\PYG{n}{resize}\PYG{p}{(}\PYG{n}{total}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{ref} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
    \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{density\PYGZus{}map}\PYG{p}{.}\PYG{n}{GetRows}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{j} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{j} \PYG{o}{\PYGZlt{}} \PYG{n}{density\PYGZus{}map}\PYG{p}{.}\PYG{n}{GetCols}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{n}{j}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{k} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{k} \PYG{o}{\PYGZlt{}} \PYG{n}{density\PYGZus{}map}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{p}{;} \PYG{n}{k}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{n}{cells}\PYG{p}{[}\PYG{n}{ref}\PYG{p}{]}\PYG{p}{.}\PYG{n}{x} \PYG{o}{=} \PYG{n}{j}\PYG{p}{;}
                \PYG{n}{cells}\PYG{p}{[}\PYG{n}{ref}\PYG{p}{]}\PYG{p}{.}\PYG{n}{y} \PYG{o}{=} \PYG{n}{i}\PYG{p}{;}
                \PYG{n}{ref} \PYG{o}{+}\PYG{o}{+}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
        \PYG{p}{\PYGZcb{}}
    \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}

\PYG{k}{const} \PYG{n}{Cell}\PYG{o}{\PYGZam{}} \PYG{n}{SimulateDispersal}\PYG{o}{:}\PYG{o}{:}\PYG{n}{getRandomCell}\PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k}{auto} \PYG{n}{index} \PYG{o}{=} \PYG{k}{static\PYGZus{}cast}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{unsigned} \PYG{k+kt}{long}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{n}{floor}\PYG{p}{(}\PYG{n}{random}\PYG{p}{.}\PYG{n}{d01}\PYG{p}{(}\PYG{p}{)} \PYG{o}{*} \PYG{n}{cells}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
    \PYG{k}{return} \PYG{n}{cells}\PYG{p}{[}\PYG{n}{index}\PYG{p}{]}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{void} \PYG{n}{SimulateDispersal}\PYG{o}{:}\PYG{o}{:}\PYG{n}{calculateNewPosition}\PYG{p}{(}\PYG{k}{const} \PYG{k+kt}{double} \PYG{o}{\PYGZam{}}\PYG{n}{dist}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{double} \PYG{o}{\PYGZam{}}\PYG{n}{angle}\PYG{p}{,}
                                             \PYG{k}{const} \PYG{n}{Cell} \PYG{o}{\PYGZam{}}\PYG{n}{start\PYGZus{}cell}\PYG{p}{,} \PYG{n}{Cell} \PYG{o}{\PYGZam{}}\PYG{n}{end\PYGZus{}cell}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{n}{end\PYGZus{}cell}\PYG{p}{.}\PYG{n}{x} \PYG{o}{=} \PYG{p}{(}\PYG{k+kt}{long}\PYG{p}{)} \PYG{n}{floor}\PYG{p}{(}\PYG{n}{start\PYGZus{}cell}\PYG{p}{.}\PYG{n}{x} \PYG{o}{+} \PYG{l+m+mf}{0.5} \PYG{o}{+} \PYG{n}{dist} \PYG{o}{*} \PYG{n}{cos}\PYG{p}{(}\PYG{n}{angle}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{end\PYGZus{}cell}\PYG{p}{.}\PYG{n}{y} \PYG{o}{=} \PYG{p}{(}\PYG{k+kt}{long}\PYG{p}{)} \PYG{n}{floor}\PYG{p}{(}\PYG{n}{start\PYGZus{}cell}\PYG{p}{.}\PYG{n}{y} \PYG{o}{+} \PYG{l+m+mf}{0.5} \PYG{o}{+} \PYG{n}{dist} \PYG{o}{*} \PYG{n}{sin}\PYG{p}{(}\PYG{n}{angle}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{bool} \PYG{n}{SimulateDispersal}\PYG{o}{:}\PYG{o}{:}\PYG{n}{getEndPointInfinite}\PYG{p}{(}\PYG{k}{const} \PYG{k+kt}{double} \PYG{o}{\PYGZam{}}\PYG{n}{dist}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{double} \PYG{o}{\PYGZam{}}\PYG{n}{angle}\PYG{p}{,}
                                            \PYG{k}{const} \PYG{n}{Cell} \PYG{o}{\PYGZam{}}\PYG{n}{this\PYGZus{}cell}\PYG{p}{,} \PYG{n}{Cell}\PYG{o}{\PYGZam{}}\PYG{n}{end\PYGZus{}cell}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k}{if}\PYG{p}{(}\PYG{n}{getEndPointTiled}\PYG{p}{(}\PYG{n}{dist}\PYG{p}{,} \PYG{n}{angle}\PYG{p}{,} \PYG{n}{this\PYGZus{}cell}\PYG{p}{,} \PYG{n}{end\PYGZus{}cell}\PYG{p}{)}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{return} \PYG{n+nb}{true}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{return} \PYG{n}{end\PYGZus{}cell}\PYG{p}{.}\PYG{n}{x} \PYG{o}{\PYGZgt{}}\PYG{o}{=} \PYG{p}{(}\PYG{k+kt}{long}\PYG{p}{)} \PYG{p}{(}\PYG{n}{density\PYGZus{}map}\PYG{p}{.}\PYG{n}{GetCols}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)} \PYG{o}{\textbar{}}\PYG{o}{\textbar{}} \PYG{n}{end\PYGZus{}cell}\PYG{p}{.}\PYG{n}{x} \PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{0} \PYG{o}{\textbar{}}\PYG{o}{\textbar{}}
            \PYG{n}{end\PYGZus{}cell}\PYG{p}{.}\PYG{n}{y} \PYG{o}{\PYGZgt{}}\PYG{o}{=} \PYG{p}{(}\PYG{k+kt}{long}\PYG{p}{)} \PYG{p}{(}\PYG{n}{density\PYGZus{}map}\PYG{p}{.}\PYG{n}{GetRows}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)} \PYG{o}{\textbar{}}\PYG{o}{\textbar{}} \PYG{n}{end\PYGZus{}cell}\PYG{p}{.}\PYG{n}{y} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{bool} \PYG{n}{SimulateDispersal}\PYG{o}{:}\PYG{o}{:}\PYG{n}{getEndPointTiled}\PYG{p}{(}\PYG{k}{const} \PYG{k+kt}{double} \PYG{o}{\PYGZam{}}\PYG{n}{dist}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{double} \PYG{o}{\PYGZam{}}\PYG{n}{angle}\PYG{p}{,}
                                         \PYG{k}{const} \PYG{n}{Cell} \PYG{o}{\PYGZam{}}\PYG{n}{this\PYGZus{}cell}\PYG{p}{,} \PYG{n}{Cell} \PYG{o}{\PYGZam{}}\PYG{n}{end\PYGZus{}cell}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{n}{calculateNewPosition}\PYG{p}{(}\PYG{n}{dist}\PYG{p}{,} \PYG{n}{angle}\PYG{p}{,} \PYG{n}{this\PYGZus{}cell}\PYG{p}{,} \PYG{n}{end\PYGZus{}cell}\PYG{p}{)}\PYG{p}{;}
    \PYG{k}{return} \PYG{n+nf}{double}\PYG{p}{(}\PYG{n}{density\PYGZus{}map}\PYG{p}{[}\PYG{n}{end\PYGZus{}cell}\PYG{p}{.}\PYG{n}{y} \PYG{o}{\PYGZpc{}} \PYG{n}{density\PYGZus{}map}\PYG{p}{.}\PYG{n}{GetCols}\PYG{p}{(}\PYG{p}{)}\PYG{p}{]}\PYG{p}{[}\PYG{n}{end\PYGZus{}cell}\PYG{p}{.}\PYG{n}{x} \PYG{o}{\PYGZpc{}} \PYG{n}{density\PYGZus{}map}\PYG{p}{.}\PYG{n}{GetRows}\PYG{p}{(}\PYG{p}{)}\PYG{p}{]}\PYG{p}{)} \PYG{o}{\PYGZgt{}}
            \PYG{p}{(}\PYG{n}{random}\PYG{p}{.}\PYG{n}{d01}\PYG{p}{(}\PYG{p}{)} \PYG{o}{*} \PYG{k+kt}{double}\PYG{p}{(}\PYG{n}{max\PYGZus{}density}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{bool} \PYG{n}{SimulateDispersal}\PYG{o}{:}\PYG{o}{:}\PYG{n}{getEndPointClosed}\PYG{p}{(}\PYG{k}{const} \PYG{k+kt}{double} \PYG{o}{\PYGZam{}}\PYG{n}{dist}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{double} \PYG{o}{\PYGZam{}}\PYG{n}{angle}\PYG{p}{,}
                                          \PYG{k}{const} \PYG{n}{Cell} \PYG{o}{\PYGZam{}}\PYG{n}{this\PYGZus{}cell}\PYG{p}{,} \PYG{n}{Cell} \PYG{o}{\PYGZam{}}\PYG{n}{end\PYGZus{}cell}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{n}{calculateNewPosition}\PYG{p}{(}\PYG{n}{dist}\PYG{p}{,} \PYG{n}{angle}\PYG{p}{,} \PYG{n}{this\PYGZus{}cell}\PYG{p}{,} \PYG{n}{end\PYGZus{}cell}\PYG{p}{)}\PYG{p}{;}
    \PYG{k}{return} \PYG{o}{!}\PYG{p}{(}\PYG{n}{end\PYGZus{}cell}\PYG{p}{.}\PYG{n}{x} \PYG{o}{\PYGZgt{}}\PYG{o}{=} \PYG{p}{(}\PYG{k+kt}{long}\PYG{p}{)} \PYG{n}{density\PYGZus{}map}\PYG{p}{.}\PYG{n}{GetCols}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\textbar{}}\PYG{o}{\textbar{}} \PYG{n}{end\PYGZus{}cell}\PYG{p}{.}\PYG{n}{x} \PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{0} \PYG{o}{\textbar{}}\PYG{o}{\textbar{}}
            \PYG{n}{end\PYGZus{}cell}\PYG{p}{.}\PYG{n}{y} \PYG{o}{\PYGZgt{}}\PYG{o}{=} \PYG{p}{(}\PYG{k+kt}{long}\PYG{p}{)} \PYG{n}{density\PYGZus{}map}\PYG{p}{.}\PYG{n}{GetRows}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\textbar{}}\PYG{o}{\textbar{}} \PYG{n}{end\PYGZus{}cell}\PYG{p}{.}\PYG{n}{y} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{0}\PYG{p}{)} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}}
           \PYG{n}{getEndPointTiled}\PYG{p}{(}\PYG{n}{dist}\PYG{p}{,} \PYG{n}{angle}\PYG{p}{,} \PYG{n}{this\PYGZus{}cell}\PYG{p}{,} \PYG{n}{end\PYGZus{}cell}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{bool} \PYG{n}{SimulateDispersal}\PYG{o}{:}\PYG{o}{:}\PYG{n}{getEndPoint}\PYG{p}{(}\PYG{k}{const} \PYG{k+kt}{double} \PYG{o}{\PYGZam{}}\PYG{n}{dist}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{double} \PYG{o}{\PYGZam{}}\PYG{n}{angle}\PYG{p}{,} \PYG{k}{const} \PYG{n}{Cell} \PYG{o}{\PYGZam{}}\PYG{n}{this\PYGZus{}cell}\PYG{p}{,} \PYG{n}{Cell} \PYG{o}{\PYGZam{}}\PYG{n}{end\PYGZus{}cell}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k}{return} \PYG{p}{(}\PYG{k}{this}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{o}{*}\PYG{n}{getValFptr}\PYG{p}{)}\PYG{p}{(}\PYG{n}{dist}\PYG{p}{,} \PYG{n}{angle}\PYG{p}{,} \PYG{n}{this\PYGZus{}cell}\PYG{p}{,} \PYG{n}{end\PYGZus{}cell}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{void} \PYG{n}{SimulateDispersal}\PYG{o}{:}\PYG{o}{:}\PYG{n}{runMeanDispersalDistance}\PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{n}{storeCellList}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{Cell} \PYG{n}{this\PYGZus{}cell}\PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
    \PYG{n}{this\PYGZus{}cell} \PYG{o}{=} \PYG{n}{getRandomCell}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
    \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{num\PYGZus{}repeats}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{if}\PYG{p}{(}\PYG{o}{!}\PYG{n}{is\PYGZus{}sequential}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{c+c1}{// This takes into account rejection sampling based on density due to}
            \PYG{c+c1}{// setup process for the cell list}
            \PYG{n}{this\PYGZus{}cell} \PYG{o}{=} \PYG{n}{getRandomCell}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{n}{Cell} \PYG{n}{end\PYGZus{}cell}\PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
        \PYG{k+kt}{bool} \PYG{n}{fail}\PYG{p}{;}
        \PYG{k+kt}{double} \PYG{n}{dist}\PYG{p}{,} \PYG{n}{angle}\PYG{p}{;}
        \PYG{c+c1}{// Keep looping until we get a valid end point}
        \PYG{k}{do}
        \PYG{p}{\PYGZob{}}
            \PYG{c+c1}{// Get a random dispersal distance}
            \PYG{n}{dist} \PYG{o}{=} \PYG{n}{random}\PYG{p}{.}\PYG{n}{dispersal}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
            \PYG{n}{angle} \PYG{o}{=} \PYG{n}{random}\PYG{p}{.}\PYG{n}{direction}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
            \PYG{c+c1}{// Check the end point}
            \PYG{n}{fail} \PYG{o}{=} \PYG{o}{!}\PYG{n}{getEndPoint}\PYG{p}{(}\PYG{n}{dist}\PYG{p}{,} \PYG{n}{angle}\PYG{p}{,} \PYG{n}{this\PYGZus{}cell}\PYG{p}{,} \PYG{n}{end\PYGZus{}cell}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}} \PYG{k}{while}\PYG{p}{(}\PYG{n}{fail}\PYG{p}{)}\PYG{p}{;}
        \PYG{c+c1}{// Copy the end location into this cell}
        \PYG{n}{this\PYGZus{}cell} \PYG{o}{=} \PYG{n}{end\PYGZus{}cell}\PYG{p}{;}
        \PYG{c+c1}{// Now store the output location}
        \PYG{n}{distances}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{=} \PYG{n}{dist}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{void} \PYG{n}{SimulateDispersal}\PYG{o}{:}\PYG{o}{:}\PYG{n}{runMeanDistanceTravelled}\PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{n}{storeCellList}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{Cell} \PYG{n}{this\PYGZus{}cell}\PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}\PYG{p}{,} \PYG{n}{start\PYGZus{}cell}\PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}\PYG{p}{,} \PYG{n}{end\PYGZus{}cell}\PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
    \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{num\PYGZus{}repeats}\PYG{p}{;} \PYG{n}{i} \PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{this\PYGZus{}cell} \PYG{o}{=} \PYG{n}{getRandomCell}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{start\PYGZus{}cell} \PYG{o}{=} \PYG{n}{this\PYGZus{}cell}\PYG{p}{;}
        \PYG{k+kt}{bool} \PYG{n}{fail}\PYG{p}{;}
        \PYG{k+kt}{double} \PYG{n}{dist}\PYG{p}{,} \PYG{n}{angle}\PYG{p}{;}
        \PYG{c+c1}{// Keep looping until we get a valid end point}
        \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{j} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{j} \PYG{o}{\PYGZlt{}} \PYG{n}{num\PYGZus{}steps}\PYG{p}{;} \PYG{n}{j} \PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{k}{do}
            \PYG{p}{\PYGZob{}}
                \PYG{n}{dist} \PYG{o}{=} \PYG{n}{random}\PYG{p}{.}\PYG{n}{dispersal}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
                \PYG{n}{angle} \PYG{o}{=} \PYG{n}{random}\PYG{p}{.}\PYG{n}{direction}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
                \PYG{n}{fail} \PYG{o}{=} \PYG{o}{!}\PYG{n}{getEndPoint}\PYG{p}{(}\PYG{n}{dist}\PYG{p}{,} \PYG{n}{angle}\PYG{p}{,} \PYG{n}{this\PYGZus{}cell}\PYG{p}{,} \PYG{n}{end\PYGZus{}cell}\PYG{p}{)}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
            \PYG{k}{while}\PYG{p}{(}\PYG{n}{fail}\PYG{p}{)}\PYG{p}{;}
            \PYG{n}{this\PYGZus{}cell} \PYG{o}{=} \PYG{n}{end\PYGZus{}cell}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{c+c1}{// Now stores the distance travelled}
        \PYG{n}{distances}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{=} \PYG{n}{distanceBetween}\PYG{p}{(}\PYG{n}{start\PYGZus{}cell}\PYG{p}{,} \PYG{n}{this\PYGZus{}cell}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{void} \PYG{n}{SimulateDispersal}\PYG{o}{:}\PYG{o}{:}\PYG{n}{writeDatabase}\PYG{p}{(}\PYG{n}{string} \PYG{n}{table\PYGZus{}name}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k}{if}\PYG{p}{(}\PYG{n}{database}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{table\PYGZus{}name} \PYG{o}{!}\PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{DISTANCES\PYGZus{}TRAVELLED}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{n}{table\PYGZus{}name} \PYG{o}{!}\PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{DISPERSAL\PYGZus{}DISTANCES}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{string} \PYG{n}{message} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Table name }\PYG{l+s}{\PYGZdq{}} \PYG{o}{+} \PYG{n}{table\PYGZus{}name}\PYG{p}{;}
            \PYG{n}{message} \PYG{o}{+}\PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{  is not one of \PYGZsq{}DISTANCES\PYGZus{}TRAVELLED\PYGZsq{} or \PYGZsq{}DISPERSAL\PYGZus{}DISTANCES\PYGZsq{}.}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
            \PYG{k}{throw} \PYG{n+nf}{FatalException}\PYG{p}{(}\PYG{n}{message}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{c+c1}{// Write out the parameters}
        \PYG{n}{checkMaxParameterReference}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{writeParameters}\PYG{p}{(}\PYG{n}{table\PYGZus{}name}\PYG{p}{)}\PYG{p}{;}
        \PYG{c+c1}{// Do the sql output}
        \PYG{c+c1}{// First create the table}
        \PYG{k+kt}{char}\PYG{o}{*} \PYG{n}{sErrMsg}\PYG{p}{;}
        \PYG{n}{sqlite3\PYGZus{}stmt}\PYG{o}{*} \PYG{n}{stmt}\PYG{p}{;}
        \PYG{n}{string} \PYG{n}{create\PYGZus{}table} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{CREATE TABLE IF NOT EXISTS }\PYG{l+s}{\PYGZdq{}} \PYG{o}{+} \PYG{n}{table\PYGZus{}name} \PYG{o}{+} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ (id INT PRIMARY KEY not null, }\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
        \PYG{n}{create\PYGZus{}table} \PYG{o}{+}\PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ distance DOUBLE not null, parameter\PYGZus{}reference INT NOT NULL);}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
        \PYG{k+kt}{int} \PYG{n}{rc} \PYG{o}{=} \PYG{n}{sqlite3\PYGZus{}exec}\PYG{p}{(}\PYG{n}{database}\PYG{p}{,} \PYG{n}{create\PYGZus{}table}\PYG{p}{.}\PYG{n}{c\PYGZus{}str}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{k}{nullptr}\PYG{p}{,} \PYG{k}{nullptr}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{sErrMsg}\PYG{p}{)}\PYG{p}{;}
        \PYG{k+kt}{int} \PYG{n}{step}\PYG{p}{;}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{rc} \PYG{o}{!}\PYG{o}{=} \PYG{n}{SQLITE\PYGZus{}OK}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{string} \PYG{n}{message} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Could not create }\PYG{l+s}{\PYGZdq{}} \PYG{o}{+} \PYG{n}{table\PYGZus{}name} \PYG{o}{+} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ table in database: }\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
            \PYG{k}{throw} \PYG{n+nf}{FatalException}\PYG{p}{(}\PYG{n}{message}\PYG{p}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{sErrMsg}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{c+c1}{// Now add the objects to the database}
        \PYG{n}{string} \PYG{n}{insert\PYGZus{}table} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{INSERT INTO }\PYG{l+s}{\PYGZdq{}} \PYG{o}{+} \PYG{n}{table\PYGZus{}name} \PYG{o}{+} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ (id, distance, parameter\PYGZus{}reference) VALUES (?, ?, ?);}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
        \PYG{n}{sqlite3\PYGZus{}prepare\PYGZus{}v2}\PYG{p}{(}\PYG{n}{database}\PYG{p}{,} \PYG{n}{insert\PYGZus{}table}\PYG{p}{.}\PYG{n}{c\PYGZus{}str}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,}
                           \PYG{k}{static\PYGZus{}cast}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{n}{strlen}\PYG{p}{(}\PYG{n}{insert\PYGZus{}table}\PYG{p}{.}\PYG{n}{c\PYGZus{}str}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{stmt}\PYG{p}{,} \PYG{k}{nullptr}\PYG{p}{)}\PYG{p}{;}
        \PYG{c+c1}{// Start the transaction}
        \PYG{n}{rc} \PYG{o}{=} \PYG{n}{sqlite3\PYGZus{}exec}\PYG{p}{(}\PYG{n}{database}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{BEGIN TRANSACTION;}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{k}{nullptr}\PYG{p}{,} \PYG{k}{nullptr}\PYG{p}{,} \PYG{k}{nullptr}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{rc} \PYG{o}{!}\PYG{o}{=} \PYG{n}{SQLITE\PYGZus{}OK}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{k}{throw} \PYG{n}{FatalException}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Cannot start SQL transaction.}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{max\PYGZus{}id} \PYG{o}{=} \PYG{n}{checkMaxIdNumber}\PYG{p}{(}\PYG{n}{table\PYGZus{}name}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{distances}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{sqlite3\PYGZus{}bind\PYGZus{}int}\PYG{p}{(}\PYG{n}{stmt}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{k}{static\PYGZus{}cast}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{n}{max\PYGZus{}id} \PYG{o}{+} \PYG{n}{i}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
            \PYG{n}{sqlite3\PYGZus{}bind\PYGZus{}double}\PYG{p}{(}\PYG{n}{stmt}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{distances}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
            \PYG{n}{sqlite3\PYGZus{}bind\PYGZus{}int}\PYG{p}{(}\PYG{n}{stmt}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{k}{static\PYGZus{}cast}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{n}{parameter\PYGZus{}reference}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
            \PYG{n}{step} \PYG{o}{=} \PYG{n}{sqlite3\PYGZus{}step}\PYG{p}{(}\PYG{n}{stmt}\PYG{p}{)}\PYG{p}{;}
            \PYG{k+kt}{time\PYGZus{}t} \PYG{n}{start\PYGZus{}check}\PYG{p}{,} \PYG{n}{end\PYGZus{}check}\PYG{p}{;}
            \PYG{n}{time}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{start\PYGZus{}check}\PYG{p}{)}\PYG{p}{;}
            \PYG{n}{time}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{end\PYGZus{}check}\PYG{p}{)}\PYG{p}{;}
            \PYG{k}{while}\PYG{p}{(}\PYG{n}{step} \PYG{o}{!}\PYG{o}{=} \PYG{n}{SQLITE\PYGZus{}DONE} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{p}{(}\PYG{n}{end\PYGZus{}check} \PYG{o}{\PYGZhy{}} \PYG{n}{start\PYGZus{}check}\PYG{p}{)} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{10}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{n}{step} \PYG{o}{=} \PYG{n}{sqlite3\PYGZus{}step}\PYG{p}{(}\PYG{n}{stmt}\PYG{p}{)}\PYG{p}{;}
                \PYG{n}{time}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{end\PYGZus{}check}\PYG{p}{)}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
            \PYG{k}{if}\PYG{p}{(}\PYG{n}{step} \PYG{o}{!}\PYG{o}{=} \PYG{n}{SQLITE\PYGZus{}DONE}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{n}{stringstream} \PYG{n}{ss}\PYG{p}{;}
                \PYG{n}{ss} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{SQLITE error code: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{step} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
                \PYG{n}{ss} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{sqlite3\PYGZus{}errmsg}\PYG{p}{(}\PYG{n}{database}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
                \PYG{n}{ss} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Could not insert into database.}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
                \PYG{k}{throw}  \PYG{n+nf}{FatalException}\PYG{p}{(}\PYG{n}{ss}\PYG{p}{.}\PYG{n}{str}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
            \PYG{n}{sqlite3\PYGZus{}clear\PYGZus{}bindings}\PYG{p}{(}\PYG{n}{stmt}\PYG{p}{)}\PYG{p}{;}
            \PYG{n}{sqlite3\PYGZus{}reset}\PYG{p}{(}\PYG{n}{stmt}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{n}{rc} \PYG{o}{=} \PYG{n}{sqlite3\PYGZus{}exec}\PYG{p}{(}\PYG{n}{database}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{END TRANSACTION;}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{k}{nullptr}\PYG{p}{,} \PYG{k}{nullptr}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{sErrMsg}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{rc} \PYG{o}{!}\PYG{o}{=} \PYG{n}{SQLITE\PYGZus{}OK}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{string} \PYG{n}{message} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Cannot end the SQL transaction: }\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
            \PYG{k}{throw} \PYG{n+nf}{FatalException}\PYG{p}{(}\PYG{n}{message}\PYG{p}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{sErrMsg}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{c+c1}{// Need to finalise the statement}
        \PYG{n}{rc} \PYG{o}{=} \PYG{n}{sqlite3\PYGZus{}finalize}\PYG{p}{(}\PYG{n}{stmt}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{rc} \PYG{o}{!}\PYG{o}{=} \PYG{n}{SQLITE\PYGZus{}OK}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{string} \PYG{n}{message} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Cannot finalise the SQL transaction: }\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
            \PYG{k}{throw} \PYG{n+nf}{FatalException}\PYG{p}{(}\PYG{n}{message}\PYG{p}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{sErrMsg}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}

    \PYG{p}{\PYGZcb{}}
    \PYG{k}{else}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{throw} \PYG{n}{FatalException}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Database connection has not been opened, check programming.}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{void} \PYG{n}{SimulateDispersal}\PYG{o}{:}\PYG{o}{:}\PYG{n}{writeParameters}\PYG{p}{(}\PYG{n}{string} \PYG{n}{table\PYGZus{}name}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{c+c1}{// Now add the parameters}
    \PYG{n}{string} \PYG{n}{create\PYGZus{}table} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{CREATE TABLE IF NOT EXISTS PARAMETERS (ref INT PRIMARY KEY not null,}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
    \PYG{n}{create\PYGZus{}table} \PYG{o}{+}\PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{simulation\PYGZus{}type TEXT not null, }\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
    \PYG{n}{create\PYGZus{}table} \PYG{o}{+}\PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ sigma DOUBLE not null, tau DOUBLE not null, m\PYGZus{}prob DOUBLE not null, cutoff DOUBLE NOT NULL,}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
    \PYG{n}{create\PYGZus{}table} \PYG{o}{+}\PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{dispersal\PYGZus{}method TEXT not null, map\PYGZus{}file TEXT not null, seed INT NOT NULL, number\PYGZus{}steps }\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
    \PYG{n}{create\PYGZus{}table} \PYG{o}{+}\PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{INT NOT NULL, number\PYGZus{}repeats INT NOT NULL);}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
    \PYG{k+kt}{char} \PYG{o}{*} \PYG{n}{sErrMsg}\PYG{p}{;}
    \PYG{k+kt}{int} \PYG{n}{rc} \PYG{o}{=} \PYG{n}{sqlite3\PYGZus{}exec}\PYG{p}{(}\PYG{n}{database}\PYG{p}{,} \PYG{n}{create\PYGZus{}table}\PYG{p}{.}\PYG{n}{c\PYGZus{}str}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{k}{nullptr}\PYG{p}{,} \PYG{k}{nullptr}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{sErrMsg}\PYG{p}{)}\PYG{p}{;}
    \PYG{k}{if}\PYG{p}{(}\PYG{n}{rc} \PYG{o}{!}\PYG{o}{=} \PYG{n}{SQLITE\PYGZus{}OK}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{string} \PYG{n}{message} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Could not create PARAMETERS table in database: }\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
        \PYG{k}{throw} \PYG{n+nf}{FatalException}\PYG{p}{(}\PYG{n}{message}\PYG{p}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{sErrMsg}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{n}{string} \PYG{n}{insert\PYGZus{}table} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{INSERT INTO PARAMETERS VALUES(}\PYG{l+s}{\PYGZdq{}} \PYG{o}{+} \PYG{n}{to\PYGZus{}string}\PYG{p}{(}\PYG{n}{parameter\PYGZus{}reference}\PYG{p}{)} \PYG{o}{+} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{, \PYGZsq{}}\PYG{l+s}{\PYGZdq{}} \PYG{o}{+} \PYG{n}{table\PYGZus{}name} \PYG{o}{+} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZsq{},}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
    \PYG{n}{insert\PYGZus{}table} \PYG{o}{+}\PYG{o}{=} \PYG{n}{to\PYGZus{}string}\PYG{p}{(}\PYG{p}{(}\PYG{k+kt}{long} \PYG{k+kt}{double}\PYG{p}{)}\PYG{n}{sigma}\PYG{p}{)} \PYG{o}{+} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{,}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
    \PYG{n}{insert\PYGZus{}table} \PYG{o}{+}\PYG{o}{=} \PYG{n}{to\PYGZus{}string}\PYG{p}{(}\PYG{p}{(}\PYG{k+kt}{long} \PYG{k+kt}{double}\PYG{p}{)}\PYG{n}{tau}\PYG{p}{)} \PYG{o}{+} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{, }\PYG{l+s}{\PYGZdq{}} \PYG{o}{+}  \PYG{n}{to\PYGZus{}string}\PYG{p}{(}\PYG{p}{(}\PYG{k+kt}{long} \PYG{k+kt}{double}\PYG{p}{)}\PYG{n}{m\PYGZus{}prob}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{insert\PYGZus{}table} \PYG{o}{+}\PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{, }\PYG{l+s}{\PYGZdq{}} \PYG{o}{+} \PYG{n}{to\PYGZus{}string}\PYG{p}{(}\PYG{p}{(}\PYG{k+kt}{long} \PYG{k+kt}{double}\PYG{p}{)}\PYG{n}{cutoff}\PYG{p}{)} \PYG{o}{+} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{, \PYGZsq{}}\PYG{l+s}{\PYGZdq{}} \PYG{o}{+} \PYG{n}{dispersal\PYGZus{}method} \PYG{o}{+} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZsq{},\PYGZsq{}}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
    \PYG{n}{insert\PYGZus{}table} \PYG{o}{+}\PYG{o}{=} \PYG{n}{map\PYGZus{}name} \PYG{o}{+} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZsq{}, }\PYG{l+s}{\PYGZdq{}} \PYG{o}{+} \PYG{n}{to\PYGZus{}string}\PYG{p}{(}\PYG{n}{seed}\PYG{p}{)} \PYG{o}{+} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{, }\PYG{l+s}{\PYGZdq{}} \PYG{o}{+} \PYG{n}{to\PYGZus{}string}\PYG{p}{(}\PYG{n}{num\PYGZus{}steps}\PYG{p}{)} \PYG{o}{+} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{, }\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
    \PYG{n}{insert\PYGZus{}table} \PYG{o}{+}\PYG{o}{=} \PYG{n}{to\PYGZus{}string}\PYG{p}{(}\PYG{n}{num\PYGZus{}repeats}\PYG{p}{)} \PYG{o}{+} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{);}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
    \PYG{n}{rc} \PYG{o}{=} \PYG{n}{sqlite3\PYGZus{}exec}\PYG{p}{(}\PYG{n}{database}\PYG{p}{,} \PYG{n}{insert\PYGZus{}table}\PYG{p}{.}\PYG{n}{c\PYGZus{}str}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{k}{nullptr}\PYG{p}{,} \PYG{k}{nullptr}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{sErrMsg}\PYG{p}{)}\PYG{p}{;}
    \PYG{k}{if}\PYG{p}{(}\PYG{n}{rc} \PYG{o}{!}\PYG{o}{=} \PYG{n}{SQLITE\PYGZus{}OK}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{string} \PYG{n}{message} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Could not insert into PARAMETERS table in database. }\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
        \PYG{n}{message} \PYG{o}{+}\PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Error: }\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
        \PYG{k}{throw} \PYG{n+nf}{FatalException}\PYG{p}{(}\PYG{n}{message}\PYG{p}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{sErrMsg}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{void} \PYG{n}{SimulateDispersal}\PYG{o}{:}\PYG{o}{:}\PYG{n}{checkMaxParameterReference}\PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{n}{string} \PYG{n}{to\PYGZus{}exec} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{SELECT CASE WHEN COUNT(1) \PYGZgt{} 0 THEN MAX(ref) ELSE 0 END AS [Value] FROM PARAMETERS;}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
    \PYG{n}{sqlite3\PYGZus{}stmt} \PYG{o}{*}\PYG{n}{stmt}\PYG{p}{;}
    \PYG{n}{sqlite3\PYGZus{}prepare\PYGZus{}v2}\PYG{p}{(}\PYG{n}{database}\PYG{p}{,} \PYG{n}{to\PYGZus{}exec}\PYG{p}{.}\PYG{n}{c\PYGZus{}str}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{k}{static\PYGZus{}cast}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{n}{strlen}\PYG{p}{(}\PYG{n}{to\PYGZus{}exec}\PYG{p}{.}\PYG{n}{c\PYGZus{}str}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{stmt}\PYG{p}{,} \PYG{k}{nullptr}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kt}{int} \PYG{n}{rc} \PYG{o}{=} \PYG{n}{sqlite3\PYGZus{}step}\PYG{p}{(}\PYG{n}{stmt}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{parameter\PYGZus{}reference} \PYG{o}{=} \PYG{k}{static\PYGZus{}cast}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{unsigned} \PYG{k+kt}{long}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{n}{sqlite3\PYGZus{}column\PYGZus{}int}\PYG{p}{(}\PYG{n}{stmt}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
    \PYG{c+c1}{// close the old statement}
    \PYG{n}{rc} \PYG{o}{=} \PYG{n}{sqlite3\PYGZus{}finalize}\PYG{p}{(}\PYG{n}{stmt}\PYG{p}{)}\PYG{p}{;}
    \PYG{k}{if}\PYG{p}{(}\PYG{n}{rc} \PYG{o}{!}\PYG{o}{=} \PYG{n}{SQLITE\PYGZus{}OK} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{n}{rc} \PYG{o}{!}\PYG{o}{=} \PYG{n}{SQLITE\PYGZus{}DONE}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{cerr} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{rc: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{rc} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
        \PYG{k}{throw} \PYG{n+nf}{SpeciesException}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Could not detect dimensions}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{SimulateDispersal}\PYG{o}{:}\PYG{o}{:}\PYG{n}{checkMaxIdNumber}\PYG{p}{(}\PYG{n}{string} \PYG{n}{table\PYGZus{}name}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{n}{string} \PYG{n}{to\PYGZus{}exec} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{SELECT CASE WHEN COUNT(1) \PYGZgt{} 0 THEN MAX(id) ELSE 0 END AS [Value] FROM }\PYG{l+s}{\PYGZdq{}} \PYG{o}{+} \PYG{n}{table\PYGZus{}name} \PYG{o}{+}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{;}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
    \PYG{n}{sqlite3\PYGZus{}stmt} \PYG{o}{*}\PYG{n}{stmt}\PYG{p}{;}
    \PYG{n}{sqlite3\PYGZus{}prepare\PYGZus{}v2}\PYG{p}{(}\PYG{n}{database}\PYG{p}{,} \PYG{n}{to\PYGZus{}exec}\PYG{p}{.}\PYG{n}{c\PYGZus{}str}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{k}{static\PYGZus{}cast}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{n}{strlen}\PYG{p}{(}\PYG{n}{to\PYGZus{}exec}\PYG{p}{.}\PYG{n}{c\PYGZus{}str}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{stmt}\PYG{p}{,} \PYG{k}{nullptr}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kt}{int} \PYG{n}{rc} \PYG{o}{=} \PYG{n}{sqlite3\PYGZus{}step}\PYG{p}{(}\PYG{n}{stmt}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{max\PYGZus{}id} \PYG{o}{=} \PYG{k}{static\PYGZus{}cast}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{unsigned} \PYG{k+kt}{long}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{n}{sqlite3\PYGZus{}column\PYGZus{}int}\PYG{p}{(}\PYG{n}{stmt}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
    \PYG{c+c1}{// close the old statement}
    \PYG{n}{rc} \PYG{o}{=} \PYG{n}{sqlite3\PYGZus{}finalize}\PYG{p}{(}\PYG{n}{stmt}\PYG{p}{)}\PYG{p}{;}
    \PYG{k}{if}\PYG{p}{(}\PYG{n}{rc} \PYG{o}{!}\PYG{o}{=} \PYG{n}{SQLITE\PYGZus{}OK} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{n}{rc} \PYG{o}{!}\PYG{o}{=} \PYG{n}{SQLITE\PYGZus{}DONE}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{cerr} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{rc: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{rc} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
        \PYG{k}{throw} \PYG{n+nf}{SpeciesException}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Could not detect dimensions}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{return} \PYG{n}{max\PYGZus{}id}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}


\subsubsection{Detailed Description}
\label{\detokenize{api/file_necsim_SimulateDispersal.cpp:detailed-description}}
Samuel Thompson
BSD-3 Licence.


\subsubsection{Includes}
\label{\detokenize{api/file_necsim_SimulateDispersal.cpp:includes}}\begin{itemize}
\item {} 
\sphinxcode{Community.h} ({\hyperref[\detokenize{api/file_necsim_Community.h:file-necsim-community-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File Community.h}}}})

\item {} 
\sphinxcode{CustomExceptions.h} ({\hyperref[\detokenize{api/file_necsim_CustomExceptions.h:file-necsim-customexceptions-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File CustomExceptions.h}}}})

\item {} 
\sphinxcode{Filesystem.h} ({\hyperref[\detokenize{api/file_necsim_Filesystem.h:file-necsim-filesystem-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File Filesystem.h}}}})

\item {} 
\sphinxcode{SimulateDispersal.h} ({\hyperref[\detokenize{api/file_necsim_SimulateDispersal.h:file-necsim-simulatedispersal-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File SimulateDispersal.h}}}})

\item {} 
\sphinxcode{utility}

\end{itemize}


\subsubsection{Functions}
\label{\detokenize{api/file_necsim_SimulateDispersal.cpp:functions}}\begin{itemize}
\item {} 
{\hyperref[\detokenize{api/function_distanceBetween:function-distancebetween}]{\sphinxcrossref{\DUrole{std,std-ref}{Function distanceBetween}}}}

\end{itemize}


\subsection{File SimulateDispersal.h}
\label{\detokenize{api/file_necsim_SimulateDispersal.h:file-necsim-simulatedispersal-h}}\label{\detokenize{api/file_necsim_SimulateDispersal.h::doc}}\label{\detokenize{api/file_necsim_SimulateDispersal.h:file-simulatedispersal-h}}
Contains the ability to simulate a given dispersal kernel on a specified density map, outputting the effect dispersal distance distribution to an SQL file after n number of dispersal events (specified by the user).

\begin{sphinxShadowBox}
\sphinxstyletopictitle{Contents}
\begin{itemize}
\item {} 
\phantomsection\label{\detokenize{api/file_necsim_SimulateDispersal.h:id1}}{\hyperref[\detokenize{api/file_necsim_SimulateDispersal.h:definition-necsim-simulatedispersal-h}]{\sphinxcrossref{Definition (\sphinxcode{necsim/SimulateDispersal.h})}}}

\item {} 
\phantomsection\label{\detokenize{api/file_necsim_SimulateDispersal.h:id2}}{\hyperref[\detokenize{api/file_necsim_SimulateDispersal.h:detailed-description}]{\sphinxcrossref{Detailed Description}}}

\item {} 
\phantomsection\label{\detokenize{api/file_necsim_SimulateDispersal.h:id3}}{\hyperref[\detokenize{api/file_necsim_SimulateDispersal.h:includes}]{\sphinxcrossref{Includes}}}

\item {} 
\phantomsection\label{\detokenize{api/file_necsim_SimulateDispersal.h:id4}}{\hyperref[\detokenize{api/file_necsim_SimulateDispersal.h:included-by}]{\sphinxcrossref{Included By}}}

\item {} 
\phantomsection\label{\detokenize{api/file_necsim_SimulateDispersal.h:id5}}{\hyperref[\detokenize{api/file_necsim_SimulateDispersal.h:classes}]{\sphinxcrossref{Classes}}}

\item {} 
\phantomsection\label{\detokenize{api/file_necsim_SimulateDispersal.h:id6}}{\hyperref[\detokenize{api/file_necsim_SimulateDispersal.h:functions}]{\sphinxcrossref{Functions}}}

\item {} 
\phantomsection\label{\detokenize{api/file_necsim_SimulateDispersal.h:id7}}{\hyperref[\detokenize{api/file_necsim_SimulateDispersal.h:defines}]{\sphinxcrossref{Defines}}}

\end{itemize}
\end{sphinxShadowBox}


\subsubsection{Definition (\sphinxstyleliteralintitle{necsim/SimulateDispersal.h})}
\label{\detokenize{api/file_necsim_SimulateDispersal.h:definition-necsim-simulatedispersal-h}}

\paragraph{Program Listing for File SimulateDispersal.h}
\label{\detokenize{api/program_listing_file_necsim_SimulateDispersal.h:program-listing-for-file-simulatedispersal-h}}\label{\detokenize{api/program_listing_file_necsim_SimulateDispersal.h:program-listing-file-necsim-simulatedispersal-h}}\label{\detokenize{api/program_listing_file_necsim_SimulateDispersal.h::doc}}\begin{itemize}
\item {} 
Return to documentation for {\hyperref[\detokenize{api/file_necsim_SimulateDispersal.h:file-necsim-simulatedispersal-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File SimulateDispersal.h}}}}

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{// This file is part of NECSim project which is released under BSD\PYGZhy{}3 license.}
\PYG{c+c1}{// See file **LICENSE.txt** or visit https://opensource.org/licenses/BSD\PYGZhy{}3\PYGZhy{}Clause) for full license details.}

\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifndef DISPERSAL\PYGZus{}TEST}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define DISPERSAL\PYGZus{}TEST}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifndef PYTHON\PYGZus{}COMPILE}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define PYTHON\PYGZus{}COMPILE}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}string\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}stdio.h\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}vector\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}iostream\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}fstream\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}cmath\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}stdexcept\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}sqlite3.h\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZdq{}Matrix.h\PYGZdq{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZdq{}NRrand.h\PYGZdq{}}
\PYG{k}{struct} \PYG{n}{Cell}
\PYG{p}{\PYGZob{}}
    \PYG{k+kt}{long} \PYG{n}{x}\PYG{p}{;}
    \PYG{k+kt}{long} \PYG{n}{y}\PYG{p}{;}
    \PYG{n}{Cell} \PYG{o}{\PYGZam{}}\PYG{k}{operator}\PYG{o}{=}\PYG{p}{(}\PYG{n}{Cell} \PYG{k}{const}\PYG{o}{\PYGZam{}} \PYG{n}{c}\PYG{p}{)}
    \PYG{o}{=} \PYG{k}{default}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}

\PYG{k+kt}{double} \PYG{n+nf}{distanceBetween}\PYG{p}{(}\PYG{n}{Cell} \PYG{o}{\PYGZam{}}\PYG{n}{c1}\PYG{p}{,} \PYG{n}{Cell} \PYG{o}{\PYGZam{}}\PYG{n}{c2}\PYG{p}{)}\PYG{p}{;}

\PYG{k}{class} \PYG{n+nc}{SimulateDispersal}
\PYG{p}{\PYGZob{}}
\PYG{k}{protected}\PYG{o}{:}
    \PYG{c+c1}{// The density map object}
    \PYG{n}{Matrix}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{uint32\PYGZus{}t}\PYG{o}{\PYGZgt{}} \PYG{n}{density\PYGZus{}map}\PYG{p}{;}
    \PYG{c+c1}{// Set to true when the size of the density map has been set}
    \PYG{k+kt}{bool} \PYG{n}{has\PYGZus{}set\PYGZus{}size}\PYG{p}{;}
    \PYG{c+c1}{// The random number generator object}
    \PYG{n}{NRrand} \PYG{n}{random}\PYG{p}{;}
    \PYG{c+c1}{// The map file path}
    \PYG{n}{string} \PYG{n}{map\PYGZus{}name}\PYG{p}{;}
    \PYG{c+c1}{// The random number seed}
    \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{seed}\PYG{p}{;}
    \PYG{c+c1}{// The dispersal method}
    \PYG{n}{string} \PYG{n}{dispersal\PYGZus{}method}\PYG{p}{;}
    \PYG{c+c1}{// The dispersal sigma value}
    \PYG{k+kt}{double} \PYG{n}{sigma}\PYG{p}{;}
    \PYG{c+c1}{// The dispersal nu value (for fat\PYGZhy{}tailed dispersal kernels)}
    \PYG{k+kt}{double} \PYG{n}{tau}\PYG{p}{;}
    \PYG{c+c1}{// The dispersal m\PYGZus{}probability \PYGZhy{} chance of picking from a uniform distribution (for norm\PYGZhy{}uniform dispersal kernels)}
    \PYG{k+kt}{double} \PYG{n}{m\PYGZus{}prob}\PYG{p}{;}
    \PYG{c+c1}{// The maximum dispersal distance for the norm\PYGZhy{}uniform dispersal distance}
    \PYG{k+kt}{double} \PYG{n}{cutoff}\PYG{p}{;}
    \PYG{c+c1}{// The sqlite3 database object for storing outputs}
    \PYG{n}{sqlite3} \PYG{o}{*} \PYG{n}{database}\PYG{p}{;}
    \PYG{c+c1}{// Vector for storing successful dispersal distances}
    \PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{double}\PYG{o}{\PYGZgt{}} \PYG{n}{distances}\PYG{p}{;}
    \PYG{c+c1}{// Vector for storing the cells (for randomly choosing from)}
    \PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{n}{Cell}\PYG{o}{\PYGZgt{}} \PYG{n}{cells}\PYG{p}{;}
    \PYG{c+c1}{// The number of repeats to run the dispersal loop for}
    \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{num\PYGZus{}repeats}\PYG{p}{;}
    \PYG{c+c1}{// The number of num\PYGZus{}steps within each dispersal loop for the average distance travelled/}
    \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{num\PYGZus{}steps}\PYG{p}{;}
    \PYG{c+c1}{// The maximal density value}
    \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{max\PYGZus{}density}\PYG{p}{;}
    \PYG{c+c1}{// If true, sequentially selects dispersal probabilities, default is true}
    \PYG{k+kt}{bool} \PYG{n}{is\PYGZus{}sequential}\PYG{p}{;}
    \PYG{c+c1}{// Reference number for this set of parameters in the database output}
    \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{parameter\PYGZus{}reference}\PYG{p}{;}
    \PYG{c+c1}{// Function pointer for the landscape function}
    \PYG{k}{typedef} \PYG{n+nf}{bool} \PYG{p}{(}\PYG{n}{SimulateDispersal}\PYG{o}{:}\PYG{o}{:}\PYG{o}{*}\PYG{n}{landscape\PYGZus{}fptr}\PYG{p}{)}\PYG{p}{(}\PYG{k}{const} \PYG{k+kt}{double} \PYG{o}{\PYGZam{}}\PYG{n}{dist}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{double} \PYG{o}{\PYGZam{}}\PYG{n}{angle}\PYG{p}{,}
                                                      \PYG{k}{const} \PYG{n}{Cell} \PYG{o}{\PYGZam{}}\PYG{n}{this\PYGZus{}cell}\PYG{p}{,} \PYG{n}{Cell} \PYG{o}{\PYGZam{}}\PYG{n}{end\PYGZus{}cell}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{landscape\PYGZus{}fptr} \PYG{n}{getValFptr}\PYG{p}{;}
\PYG{k}{public}\PYG{o}{:}
    \PYG{n}{SimulateDispersal}\PYG{p}{(}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{has\PYGZus{}set\PYGZus{}size} \PYG{o}{=} \PYG{n+nb}{false}\PYG{p}{;}
        \PYG{n}{sigma} \PYG{o}{=} \PYG{l+m+mf}{0.0}\PYG{p}{;}
        \PYG{n}{tau} \PYG{o}{=} \PYG{l+m+mf}{0.0}\PYG{p}{;}
        \PYG{n}{m\PYGZus{}prob} \PYG{o}{=} \PYG{l+m+mf}{0.0}\PYG{p}{;}
        \PYG{n}{cutoff} \PYG{o}{=} \PYG{l+m+mf}{0.0}\PYG{p}{;}
        \PYG{n}{num\PYGZus{}repeats} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
        \PYG{n}{num\PYGZus{}steps} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
        \PYG{n}{database} \PYG{o}{=} \PYG{k}{nullptr}\PYG{p}{;}
        \PYG{n}{max\PYGZus{}density} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
        \PYG{n}{seed} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
        \PYG{n}{is\PYGZus{}sequential} \PYG{o}{=} \PYG{n+nb}{false}\PYG{p}{;}
        \PYG{n}{parameter\PYGZus{}reference} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{o}{\PYGZti{}}\PYG{n}{SimulateDispersal}\PYG{p}{(}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{sqlite3\PYGZus{}close}\PYG{p}{(}\PYG{n}{database}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{k+kt}{void} \PYG{n}{setSequential}\PYG{p}{(}\PYG{k+kt}{bool} \PYG{n}{bSequential}\PYG{p}{)}\PYG{p}{;}

    \PYG{k+kt}{void} \PYG{n+nf}{setSizes}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{x}\PYG{p}{,} \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{y}\PYG{p}{)}\PYG{p}{;}

    \PYG{k+kt}{void} \PYG{n+nf}{importMaps}\PYG{p}{(}\PYG{n}{string} \PYG{n}{map\PYGZus{}file}\PYG{p}{)}\PYG{p}{;}

    \PYG{k+kt}{void} \PYG{n+nf}{setSeed}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{s}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{seed} \PYG{o}{=} \PYG{n}{s}\PYG{p}{;}
        \PYG{n}{random}\PYG{p}{.}\PYG{n}{setSeed}\PYG{p}{(}\PYG{n}{s}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{k+kt}{void} \PYG{n+nf}{setDispersalParameters}\PYG{p}{(}\PYG{n}{string} \PYG{n}{dispersal\PYGZus{}method\PYGZus{}in}\PYG{p}{,} \PYG{k+kt}{double} \PYG{n}{sigma\PYGZus{}in}\PYG{p}{,} \PYG{k+kt}{double} \PYG{n}{tau\PYGZus{}in}\PYG{p}{,} \PYG{k+kt}{double} \PYG{n}{m\PYGZus{}prob\PYGZus{}in}\PYG{p}{,}
                                 \PYG{k+kt}{double} \PYG{n}{cutoff\PYGZus{}in}\PYG{p}{,} \PYG{n}{string} \PYG{n}{landscape\PYGZus{}type}\PYG{p}{)}\PYG{p}{;}

    \PYG{k+kt}{void} \PYG{n+nf}{setLandscapeType}\PYG{p}{(}\PYG{n}{string} \PYG{n}{landscape\PYGZus{}type}\PYG{p}{)}\PYG{p}{;}

    \PYG{k+kt}{void} \PYG{n+nf}{setOutputDatabase}\PYG{p}{(}\PYG{n}{string} \PYG{n}{out\PYGZus{}database}\PYG{p}{)}\PYG{p}{;}

    \PYG{k+kt}{void} \PYG{n+nf}{setNumberRepeats}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{n}\PYG{p}{)}\PYG{p}{;}

    \PYG{k+kt}{void} \PYG{n+nf}{setNumberSteps}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{s}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kt}{void} \PYG{n+nf}{storeCellList}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

    \PYG{k}{const} \PYG{n}{Cell}\PYG{o}{\PYGZam{}} \PYG{n}{getRandomCell}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

    \PYG{k+kt}{void} \PYG{n+nf}{calculateNewPosition}\PYG{p}{(}\PYG{k}{const} \PYG{k+kt}{double} \PYG{o}{\PYGZam{}}\PYG{n}{dist}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{double} \PYG{o}{\PYGZam{}}\PYG{n}{angle}\PYG{p}{,} \PYG{k}{const} \PYG{n}{Cell} \PYG{o}{\PYGZam{}}\PYG{n}{start\PYGZus{}cell}\PYG{p}{,} \PYG{n}{Cell} \PYG{o}{\PYGZam{}}\PYG{n}{end\PYGZus{}cell}\PYG{p}{)}\PYG{p}{;}

    \PYG{k+kt}{bool} \PYG{n+nf}{getEndPointInfinite}\PYG{p}{(}\PYG{k}{const} \PYG{k+kt}{double} \PYG{o}{\PYGZam{}}\PYG{n}{dist}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{double} \PYG{o}{\PYGZam{}}\PYG{n}{angle}\PYG{p}{,} \PYG{k}{const} \PYG{n}{Cell} \PYG{o}{\PYGZam{}}\PYG{n}{this\PYGZus{}cell}\PYG{p}{,} \PYG{n}{Cell} \PYG{o}{\PYGZam{}}\PYG{n}{end\PYGZus{}cell}\PYG{p}{)}\PYG{p}{;}

    \PYG{k+kt}{bool} \PYG{n+nf}{getEndPointTiled}\PYG{p}{(}\PYG{k}{const} \PYG{k+kt}{double} \PYG{o}{\PYGZam{}}\PYG{n}{dist}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{double} \PYG{o}{\PYGZam{}}\PYG{n}{angle}\PYG{p}{,} \PYG{k}{const} \PYG{n}{Cell} \PYG{o}{\PYGZam{}}\PYG{n}{this\PYGZus{}cell}\PYG{p}{,} \PYG{n}{Cell} \PYG{o}{\PYGZam{}}\PYG{n}{end\PYGZus{}cell}\PYG{p}{)}\PYG{p}{;}

    \PYG{k+kt}{bool} \PYG{n+nf}{getEndPointClosed}\PYG{p}{(}\PYG{k}{const} \PYG{k+kt}{double} \PYG{o}{\PYGZam{}}\PYG{n}{dist}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{double} \PYG{o}{\PYGZam{}}\PYG{n}{angle}\PYG{p}{,} \PYG{k}{const} \PYG{n}{Cell} \PYG{o}{\PYGZam{}}\PYG{n}{this\PYGZus{}cell}\PYG{p}{,} \PYG{n}{Cell} \PYG{o}{\PYGZam{}}\PYG{n}{end\PYGZus{}cell}\PYG{p}{)}\PYG{p}{;}

    \PYG{k+kt}{bool} \PYG{n+nf}{getEndPoint}\PYG{p}{(}\PYG{k}{const} \PYG{k+kt}{double} \PYG{o}{\PYGZam{}}\PYG{n}{dist}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{double} \PYG{o}{\PYGZam{}}\PYG{n}{angle}\PYG{p}{,} \PYG{k}{const} \PYG{n}{Cell} \PYG{o}{\PYGZam{}}\PYG{n}{this\PYGZus{}cell}\PYG{p}{,} \PYG{n}{Cell} \PYG{o}{\PYGZam{}}\PYG{n}{end\PYGZus{}cell}\PYG{p}{)}\PYG{p}{;}

    \PYG{k+kt}{void} \PYG{n+nf}{runMeanDispersalDistance}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

    \PYG{k+kt}{void} \PYG{n+nf}{runMeanDistanceTravelled}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

    \PYG{k+kt}{void} \PYG{n+nf}{writeDatabase}\PYG{p}{(}\PYG{n}{string} \PYG{n}{table\PYGZus{}name}\PYG{p}{)}\PYG{p}{;}

    \PYG{k+kt}{void} \PYG{n+nf}{writeParameters}\PYG{p}{(}\PYG{n}{string} \PYG{n}{table\PYGZus{}name}\PYG{p}{)}\PYG{p}{;}

    \PYG{k+kt}{void} \PYG{n+nf}{checkMaxParameterReference}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

    \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n+nf}{checkMaxIdNumber}\PYG{p}{(}\PYG{n}{string} \PYG{n}{table\PYGZus{}name}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}

\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif}
\end{sphinxVerbatim}


\subsubsection{Detailed Description}
\label{\detokenize{api/file_necsim_SimulateDispersal.h:detailed-description}}
Samuel Thompson
BSD-3 Licence.


\subsubsection{Includes}
\label{\detokenize{api/file_necsim_SimulateDispersal.h:includes}}\begin{itemize}
\item {} 
\sphinxcode{Matrix.h} ({\hyperref[\detokenize{api/file_necsim_Matrix.h:file-necsim-matrix-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File Matrix.h}}}})

\item {} 
\sphinxcode{NRrand.h} ({\hyperref[\detokenize{api/file_necsim_NRrand.h:file-necsim-nrrand-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File NRrand.h}}}})

\item {} 
\sphinxcode{cmath}

\item {} 
\sphinxcode{fstream}

\item {} 
\sphinxcode{iostream}

\item {} 
\sphinxcode{sqlite3.h}

\item {} 
\sphinxcode{stdexcept}

\item {} 
\sphinxcode{stdio.h}

\item {} 
\sphinxcode{string}

\item {} 
\sphinxcode{vector}

\end{itemize}


\subsubsection{Included By}
\label{\detokenize{api/file_necsim_SimulateDispersal.h:included-by}}\begin{itemize}
\item {} 
{\hyperref[\detokenize{api/file_necsim_SimulateDispersal.cpp:file-necsim-simulatedispersal-cpp}]{\sphinxcrossref{\DUrole{std,std-ref}{File SimulateDispersal.cpp}}}}

\end{itemize}


\subsubsection{Classes}
\label{\detokenize{api/file_necsim_SimulateDispersal.h:classes}}\begin{itemize}
\item {} 
{\hyperref[\detokenize{api/class_Cell:class-cell}]{\sphinxcrossref{\DUrole{std,std-ref}{Class Cell}}}}

\item {} 
{\hyperref[\detokenize{api/class_SimulateDispersal:class-simulatedispersal}]{\sphinxcrossref{\DUrole{std,std-ref}{Class SimulateDispersal}}}}

\end{itemize}


\subsubsection{Functions}
\label{\detokenize{api/file_necsim_SimulateDispersal.h:functions}}\begin{itemize}
\item {} 
{\hyperref[\detokenize{api/function_distanceBetween:function-distancebetween}]{\sphinxcrossref{\DUrole{std,std-ref}{Function distanceBetween}}}}

\end{itemize}


\subsubsection{Defines}
\label{\detokenize{api/file_necsim_SimulateDispersal.h:defines}}\begin{itemize}
\item {} 
{\hyperref[\detokenize{api/define_PYTHON_COMPILE:define-python-compile}]{\sphinxcrossref{\DUrole{std,std-ref}{Define PYTHON\_COMPILE}}}}

\end{itemize}


\subsection{File SimulationTemplates.h}
\label{\detokenize{api/file_necsim_SimulationTemplates.h:file-simulationtemplates-h}}\label{\detokenize{api/file_necsim_SimulationTemplates.h::doc}}\label{\detokenize{api/file_necsim_SimulationTemplates.h:file-necsim-simulationtemplates-h}}
Contains template function for running any class of simulation (including protracted simulations, spatial and non-spatial simulations.

\begin{sphinxShadowBox}
\sphinxstyletopictitle{Contents}
\begin{itemize}
\item {} 
\phantomsection\label{\detokenize{api/file_necsim_SimulationTemplates.h:id1}}{\hyperref[\detokenize{api/file_necsim_SimulationTemplates.h:definition-necsim-simulationtemplates-h}]{\sphinxcrossref{Definition (\sphinxcode{necsim/SimulationTemplates.h})}}}

\item {} 
\phantomsection\label{\detokenize{api/file_necsim_SimulationTemplates.h:id2}}{\hyperref[\detokenize{api/file_necsim_SimulationTemplates.h:detailed-description}]{\sphinxcrossref{Detailed Description}}}

\item {} 
\phantomsection\label{\detokenize{api/file_necsim_SimulationTemplates.h:id3}}{\hyperref[\detokenize{api/file_necsim_SimulationTemplates.h:includes}]{\sphinxcrossref{Includes}}}

\item {} 
\phantomsection\label{\detokenize{api/file_necsim_SimulationTemplates.h:id4}}{\hyperref[\detokenize{api/file_necsim_SimulationTemplates.h:included-by}]{\sphinxcrossref{Included By}}}

\item {} 
\phantomsection\label{\detokenize{api/file_necsim_SimulationTemplates.h:id5}}{\hyperref[\detokenize{api/file_necsim_SimulationTemplates.h:functions}]{\sphinxcrossref{Functions}}}

\end{itemize}
\end{sphinxShadowBox}


\subsubsection{Definition (\sphinxstyleliteralintitle{necsim/SimulationTemplates.h})}
\label{\detokenize{api/file_necsim_SimulationTemplates.h:definition-necsim-simulationtemplates-h}}

\paragraph{Program Listing for File SimulationTemplates.h}
\label{\detokenize{api/program_listing_file_necsim_SimulationTemplates.h:program-listing-for-file-simulationtemplates-h}}\label{\detokenize{api/program_listing_file_necsim_SimulationTemplates.h::doc}}\label{\detokenize{api/program_listing_file_necsim_SimulationTemplates.h:program-listing-file-necsim-simulationtemplates-h}}\begin{itemize}
\item {} 
Return to documentation for {\hyperref[\detokenize{api/file_necsim_SimulationTemplates.h:file-necsim-simulationtemplates-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File SimulationTemplates.h}}}}

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{// This file is part of NECSim project which is released under BSD\PYGZhy{}3 license.}
\PYG{c+c1}{// See file **LICENSE.txt** or visit https://opensource.org/licenses/BSD\PYGZhy{}3\PYGZhy{}Clause) for full license details.}
\PYG{c+c1}{//}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifndef SIMULATIONTEMPLATES\PYGZus{}H}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define SIMULATIONTEMPLATES\PYGZus{}H}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}string\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}sstream\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZdq{}Logging.h\PYGZdq{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZdq{}CustomExceptions.h\PYGZdq{}}

\PYG{k}{const} \PYG{n}{string} \PYG{o}{\PYGZam{}} \PYG{n}{getConfigFileFromCmdArgs}\PYG{p}{(}\PYG{k}{const} \PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{n}{string}\PYG{o}{\PYGZgt{}} \PYG{o}{\PYGZam{}} \PYG{n}{com\PYGZus{}args}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k}{if}\PYG{p}{(}\PYG{n}{com\PYGZus{}args}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)} \PYG{o}{!}\PYG{o}{=} \PYG{l+m+mi}{3}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{stringstream} \PYG{n}{ss}\PYG{p}{;}
        \PYG{n}{ss} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Incorrect number of command\PYGZhy{}line arguments supplied. Should be 3, got }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{com\PYGZus{}args}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
        \PYG{k}{throw} \PYG{n+nf}{FatalException}\PYG{p}{(}\PYG{n}{ss}\PYG{p}{.}\PYG{n}{str}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{else}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{return} \PYG{n}{com\PYGZus{}args}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}

\PYG{k}{template} \PYG{o}{\PYGZlt{}}\PYG{k}{class} \PYG{n+nc}{T}\PYG{o}{\PYGZgt{}} \PYG{k+kt}{void} \PYG{n}{runMain}\PYG{p}{(}\PYG{k}{const} \PYG{n}{string} \PYG{o}{\PYGZam{}}\PYG{n}{config\PYGZus{}file}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{c+c1}{// Create our tree object that contains the simulation}
    \PYG{n}{T} \PYG{n}{tree}\PYG{p}{;}
    \PYG{n}{tree}\PYG{p}{.}\PYG{n}{importSimulationVariables}\PYG{p}{(}\PYG{n}{config\PYGZus{}file}\PYG{p}{)}\PYG{p}{;}
    \PYG{c+c1}{// Setup the sim}
    \PYG{n}{tree}\PYG{p}{.}\PYG{n}{setup}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
    \PYG{c+c1}{// Detect speciation rates to apply}
    \PYG{k+kt}{bool} \PYG{n}{isComplete} \PYG{o}{=} \PYG{n}{tree}\PYG{p}{.}\PYG{n}{runSimulation}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
    \PYG{k}{if}\PYG{p}{(}\PYG{n}{isComplete}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{tree}\PYG{p}{.}\PYG{n}{applyMultipleRates}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{n}{writeInfo}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{*************************************************}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif }\PYG{c+c1}{//SIMULATIONTEMPLATES\PYGZus{}H}
\end{sphinxVerbatim}


\subsubsection{Detailed Description}
\label{\detokenize{api/file_necsim_SimulationTemplates.h:detailed-description}}
Sam Thompson
02/01/2018
Contact: \sphinxhref{mailto:samuel.thompson14@imperial.ac.uk}{samuel.thompson14@imperial.ac.uk} or \sphinxhref{mailto:thompsonsed@gmail.com}{thompsonsed@gmail.com} BSD-3 Licence.


\subsubsection{Includes}
\label{\detokenize{api/file_necsim_SimulationTemplates.h:includes}}\begin{itemize}
\item {} 
\sphinxcode{CustomExceptions.h} ({\hyperref[\detokenize{api/file_necsim_CustomExceptions.h:file-necsim-customexceptions-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File CustomExceptions.h}}}})

\item {} 
\sphinxcode{Logging.h} ({\hyperref[\detokenize{api/file_necsim_Logging.h:file-necsim-logging-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File Logging.h}}}})

\item {} 
\sphinxcode{sstream}

\item {} 
\sphinxcode{string}

\end{itemize}


\subsubsection{Included By}
\label{\detokenize{api/file_necsim_SimulationTemplates.h:included-by}}\begin{itemize}
\item {} 
{\hyperref[\detokenize{api/file_necsim_main.cpp:file-necsim-main-cpp}]{\sphinxcrossref{\DUrole{std,std-ref}{File main.cpp}}}}

\end{itemize}


\subsubsection{Functions}
\label{\detokenize{api/file_necsim_SimulationTemplates.h:functions}}\begin{itemize}
\item {} 
{\hyperref[\detokenize{api/function_getConfigFileFromCmdArgs:function-getconfigfilefromcmdargs}]{\sphinxcrossref{\DUrole{std,std-ref}{Function getConfigFileFromCmdArgs}}}}

\item {} 
{\hyperref[\detokenize{api/function_runMain:function-runmain}]{\sphinxcrossref{\DUrole{std,std-ref}{Function runMain}}}}

\end{itemize}


\subsection{File SpatialTree.cpp}
\label{\detokenize{api/file_necsim_SpatialTree.cpp:file-necsim-spatialtree-cpp}}\label{\detokenize{api/file_necsim_SpatialTree.cpp::doc}}\label{\detokenize{api/file_necsim_SpatialTree.cpp:file-spatialtree-cpp}}
Contains the {\hyperref[\detokenize{api/class_SpatialTree:class-spatialtree}]{\sphinxcrossref{\DUrole{std,std-ref}{Class SpatialTree}}}} class implementation as the main simulation object for spatially-explicit coalescence simulations.

\begin{sphinxShadowBox}
\sphinxstyletopictitle{Contents}
\begin{itemize}
\item {} 
\phantomsection\label{\detokenize{api/file_necsim_SpatialTree.cpp:id1}}{\hyperref[\detokenize{api/file_necsim_SpatialTree.cpp:definition-necsim-spatialtree-cpp}]{\sphinxcrossref{Definition (\sphinxcode{necsim/SpatialTree.cpp})}}}

\item {} 
\phantomsection\label{\detokenize{api/file_necsim_SpatialTree.cpp:id2}}{\hyperref[\detokenize{api/file_necsim_SpatialTree.cpp:detailed-description}]{\sphinxcrossref{Detailed Description}}}

\item {} 
\phantomsection\label{\detokenize{api/file_necsim_SpatialTree.cpp:id3}}{\hyperref[\detokenize{api/file_necsim_SpatialTree.cpp:includes}]{\sphinxcrossref{Includes}}}

\end{itemize}
\end{sphinxShadowBox}


\subsubsection{Definition (\sphinxstyleliteralintitle{necsim/SpatialTree.cpp})}
\label{\detokenize{api/file_necsim_SpatialTree.cpp:definition-necsim-spatialtree-cpp}}

\paragraph{Program Listing for File SpatialTree.cpp}
\label{\detokenize{api/program_listing_file_necsim_SpatialTree.cpp:program-listing-file-necsim-spatialtree-cpp}}\label{\detokenize{api/program_listing_file_necsim_SpatialTree.cpp:program-listing-for-file-spatialtree-cpp}}\label{\detokenize{api/program_listing_file_necsim_SpatialTree.cpp::doc}}\begin{itemize}
\item {} 
Return to documentation for {\hyperref[\detokenize{api/file_necsim_SpatialTree.cpp:file-necsim-spatialtree-cpp}]{\sphinxcrossref{\DUrole{std,std-ref}{File SpatialTree.cpp}}}}

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{// This file is part of NECSim project which is released under BSD\PYGZhy{}3 license.}
\PYG{c+c1}{// See file **LICENSE.txt** or visit https://opensource.org/licenses/BSD\PYGZhy{}3\PYGZhy{}Clause) for full license details.}

\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}algorithm\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZdq{}SpatialTree.h\PYGZdq{}}

\PYG{k+kt}{void} \PYG{n}{SpatialTree}\PYG{o}{:}\PYG{o}{:}\PYG{n}{importSimulationVariables}\PYG{p}{(}\PYG{k}{const} \PYG{n}{string} \PYG{o}{\PYGZam{}}\PYG{n}{configfile}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{n}{sim\PYGZus{}parameters}\PYG{p}{.}\PYG{n}{importParameters}\PYG{p}{(}\PYG{n}{configfile}\PYG{p}{)}\PYG{p}{;}
    \PYG{c+c1}{// Now check that our folders exist}
    \PYG{n}{checkFolders}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
    \PYG{c+c1}{// Now check for paused simulations}
    \PYG{n}{checkSims}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{void} \PYG{n}{SpatialTree}\PYG{o}{:}\PYG{o}{:}\PYG{n}{parseArgs}\PYG{p}{(}\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{n}{string}\PYG{o}{\PYGZgt{}} \PYG{o}{\PYGZam{}} \PYG{n}{comargs}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{c+c1}{// First parse the command line arguments}
    \PYG{k+kt}{bool} \PYG{n}{bCheckUser}\PYG{o}{=}\PYG{n+nb}{false}\PYG{p}{;}
    \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{argc} \PYG{o}{=} \PYG{n}{comargs}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
    \PYG{k}{if}\PYG{p}{(}\PYG{n}{argc}\PYG{o}{=}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{comargs}\PYG{p}{.}\PYG{n}{emplace\PYGZus{}back}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZhy{}e}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{comargs}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{o}{!}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{stringstream} \PYG{n}{ss}\PYG{p}{;}
            \PYG{n}{ss} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ERROR\PYGZus{}MAIN\PYGZus{}010: Incorrect command line parsing.}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
            \PYG{k}{throw} \PYG{n+nf}{FatalException}\PYG{p}{(}\PYG{n}{ss}\PYG{p}{.}\PYG{n}{str}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{if}\PYG{p}{(}\PYG{n}{comargs}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{=}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZhy{}h}\PYG{l+s}{\PYGZdq{}}\PYG{o}{\textbar{}}\PYG{o}{\textbar{}}\PYG{n}{comargs}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{=}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZhy{}H}\PYG{l+s}{\PYGZdq{}}\PYG{o}{\textbar{}}\PYG{o}{\textbar{}}\PYG{n}{argc}\PYG{o}{=}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{o}{\textbar{}}\PYG{o}{\textbar{}}\PYG{n}{comargs}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{=}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZhy{}help}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\textbar{}}\PYG{o}{\textbar{}} \PYG{n}{comargs}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{=}\PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZhy{}e}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{stringstream} \PYG{n}{os}\PYG{p}{;}
        \PYG{c+c1}{// Sort out piping to terminal if verbose has not been defined.}
        \PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifndef verbose}
        \PYG{n}{dup2}\PYG{p}{(}\PYG{n}{saved\PYGZus{}stdout}\PYG{p}{,} \PYG{n}{fileno}\PYG{p}{(}\PYG{n}{stdout}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
        \PYG{c+c1}{//close(saved\PYGZus{}stdout);}
        \PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{argc}\PYG{o}{=}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{os} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{No arguments supplied: expected 30. These are: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{else}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{os} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{30 command line arguments are required. These are: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{n}{os} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{1: the seed for the simulation.}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
        \PYG{n}{os} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{2: the simulation task (for file reference).}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
        \PYG{n}{os} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{3: the map config file.}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
        \PYG{n}{os} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{4: the output directory.}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
        \PYG{n}{os} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{5: the minimum speciation rate.}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
        \PYG{n}{os} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{6: the dispersal tau value.}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
        \PYG{n}{os} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{7: the dispersal sigma value.}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
        \PYG{n}{os} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{8: the deme size.}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
        \PYG{n}{os} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{9: the deme sample size.}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
        \PYG{n}{os} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{10: the maximum simulation time (in seconds).}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
        \PYG{n}{os} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{11: the dispersal\PYGZus{}relative\PYGZus{}cost value for moving through non\PYGZhy{}habitat.}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
        \PYG{n}{os} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{12: the temporal sampling file containing tab\PYGZhy{}separated generation values for sampling points in time (null for only sampling the present).}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
        \PYG{n}{os} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{13: the minimum number of species known to exist. (Currently has no effect).}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
        \PYG{n}{os} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{14 onwards: speciation rates to apply after simulation.}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
        \PYG{n}{os} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{There is also a full\PYGZhy{}command line mode, (flag \PYGZhy{}f), which allows for more options to be specified via the command line.}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
        \PYG{n}{os} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Would you like to see these options? Y/N: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{flush}\PYG{p}{;}
        \PYG{n}{writeWarning}\PYG{p}{(}\PYG{n}{os}\PYG{p}{.}\PYG{n}{str}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{os}\PYG{p}{.}\PYG{n}{str}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{string} \PYG{n}{fullopts}\PYG{p}{;}
        \PYG{n}{cin} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{fullopts}\PYG{p}{;}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{fullopts} \PYG{o}{=}\PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Y}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\textbar{}}\PYG{o}{\textbar{}} \PYG{n}{fullopts} \PYG{o}{=}\PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{y}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{os} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{1: the task\PYGZus{}iter used for setting the seed.}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
            \PYG{n}{os} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{2: the sample grid x dimension.}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
            \PYG{n}{os} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{3: the sample grid y dimension.}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
            \PYG{n}{os} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{4: the fine map file relative path.}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
            \PYG{n}{os} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{5: the fine map x dimension.}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
            \PYG{n}{os} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{6: the fine map y dimension.}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
            \PYG{n}{os} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{7: the fine map x offset.}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
            \PYG{n}{os} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{8 the fine map y offset.}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
            \PYG{n}{os} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{9: the coarse map file relative path.}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
            \PYG{n}{os} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{10: the coarse map x dimension.}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
            \PYG{n}{os} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{11: the coarse map y dimension.}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
            \PYG{n}{os} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{12: the coarse map x offset.}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
            \PYG{n}{os} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{13: the coarse map y offset.}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
            \PYG{n}{os} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{14: the scale of the coarse map compared to the fine (10 means resolution of coarse map = 10 x resolution of fine map).}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
            \PYG{n}{os} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{15: the output directory.}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
            \PYG{n}{os} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{16: the speciation rate.}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
            \PYG{n}{os} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{17: the dispersal distance (tau).}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
            \PYG{n}{os} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{18: the deme size.}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
            \PYG{n}{os} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{19: the deme sample size (as a proportion of deme size).}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
            \PYG{n}{os} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{20: the time to run the simulation (in seconds).}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
            \PYG{n}{os} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{21: dispersal\PYGZus{}relative\PYGZus{}cost \PYGZhy{} the relative cost of moving through non\PYGZhy{}forest.}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
            \PYG{n}{os} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{22: the\PYGZus{}task \PYGZhy{} for referencing the specific task later on.}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
            \PYG{n}{os} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{23: the minimum number of species the system is known to contain.}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
            \PYG{n}{os} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{24: the pristine fine map file to use.}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
            \PYG{n}{os} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{25: the pristine coarse map file to use.}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
            \PYG{n}{os} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{26: the rate of forest change from pristine.}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
            \PYG{n}{os} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{27: the time (in generations) since the pristine forest was seen.}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
            \PYG{n}{os} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{28: the dispersal sigma value.}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
            \PYG{n}{os} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{29: the sample mask, with binary 1:0 values for areas that we want to sample from. If this is not provided then this will default to mapping the entire grid.}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
            \PYG{n}{os} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{30: a file containing a tab\PYGZhy{}separated list of sample points in time (in generations). If this is null then only the present day will be sampled.}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
            \PYG{n}{os} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{31\PYGZhy{}onwards: speciation rates to be applied at the end of the simulation}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
            \PYG{n}{os} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Note that using the \PYGZhy{}f flag prohibits more than one two historic maps being used.}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{n}{os} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Would you like to run with the default settings? (Y/N)}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{flush}\PYG{p}{;}
        \PYG{n}{writeWarning}\PYG{p}{(}\PYG{n}{os}\PYG{p}{.}\PYG{n}{str}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{os}\PYG{p}{.}\PYG{n}{str}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{string} \PYG{n}{cDef}\PYG{p}{;}
        \PYG{n}{cin} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{cDef}\PYG{p}{;}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{cDef} \PYG{o}{=}\PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Y}\PYG{l+s}{\PYGZdq{}}\PYG{o}{\textbar{}}\PYG{o}{\textbar{}}\PYG{n}{cDef}\PYG{o}{=}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{y}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{bCheckUser} \PYG{o}{=} \PYG{n+nb}{true}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{else}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{bCheckUser} \PYG{o}{=} \PYG{n+nb}{false}\PYG{p}{;}
            \PYG{n}{os} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Possible command line arguments: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
            \PYG{n}{os} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZhy{}h/\PYGZhy{}help: Show the help file.}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
            \PYG{n}{os} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZhy{}d/\PYGZhy{}D: Run with default small parameters.}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
            \PYG{n}{os} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZhy{}dl/\PYGZhy{}DL: Run with default large parameters.}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
            \PYG{n}{os} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZhy{}dx/\PYGZhy{}DX: Run with the default very large parameters.}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
            \PYG{n}{os} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZhy{}c/\PYGZhy{}config: Run with the supplied config file.}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
            \PYG{k}{throw} \PYG{n+nf}{FatalException}\PYG{p}{(}\PYG{n}{os}\PYG{p}{.}\PYG{n}{str}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{// exit the program right away as there is no need to continue if there is no simulation to run!}
        \PYG{p}{\PYGZcb{}}
    \PYG{p}{\PYGZcb{}}

    \PYG{k}{if}\PYG{p}{(}\PYG{n}{comargs}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{=}\PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZhy{}r}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\textbar{}}\PYG{o}{\textbar{}} \PYG{n}{comargs}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{=}\PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZhy{}R}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\textbar{}}\PYG{o}{\textbar{}} \PYG{n}{comargs}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{=}\PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZhy{}resume}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{comargs}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{resuming}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{argc} \PYG{o}{!}\PYG{o}{=} \PYG{l+m+mi}{6}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{stringstream} \PYG{n}{ss}\PYG{p}{;}
            \PYG{n}{ss} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Incorrect number of parameters provided for resuming simulation. Expecting:}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
            \PYG{n}{ss} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{1: \PYGZhy{}r flag}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
            \PYG{n}{ss} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{2: the folder containing the paused simulation (should hold a \PYGZsq{}Pause\PYGZsq{} folder)}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
            \PYG{n}{ss} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{3: the simulation seed}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
            \PYG{n}{ss} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{4: the simulation task}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
            \PYG{n}{ss} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{5: the time to run the simulation for}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
            \PYG{k}{throw} \PYG{n+nf}{FatalException}\PYG{p}{(}\PYG{n}{ss}\PYG{p}{.}\PYG{n}{str}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{n}{bResume} \PYG{o}{=} \PYG{n+nb}{true}\PYG{p}{;}
        \PYG{n}{has\PYGZus{}paused} \PYG{o}{=} \PYG{n+nb}{true}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{c+c1}{// Import the default parameters if required.}
    \PYG{k}{if}\PYG{p}{(}\PYG{n}{comargs}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{=}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZhy{}d}\PYG{l+s}{\PYGZdq{}}\PYG{o}{\textbar{}}\PYG{o}{\textbar{}}\PYG{n}{comargs}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{=}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZhy{}D}\PYG{l+s}{\PYGZdq{}}\PYG{o}{\textbar{}}\PYG{o}{\textbar{}}\PYG{n}{bCheckUser}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{runAsDefault}\PYG{p}{(}\PYG{n}{comargs}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{bCheckUser}\PYG{o}{=}\PYG{n+nb}{true}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{if}\PYG{p}{(}\PYG{n}{comargs}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{=}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZhy{}dl}\PYG{l+s}{\PYGZdq{}}\PYG{o}{\textbar{}}\PYG{o}{\textbar{}}\PYG{n}{comargs}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{=}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZhy{}DL}\PYG{l+s}{\PYGZdq{}}\PYG{o}{\textbar{}}\PYG{o}{\textbar{}}\PYG{n}{comargs}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{=}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZhy{}dL}\PYG{l+s}{\PYGZdq{}}\PYG{o}{\textbar{}}\PYG{o}{\textbar{}}\PYG{n}{comargs}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{=}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZhy{}Dl}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{runLarge}\PYG{p}{(}\PYG{n}{comargs}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{bCheckUser} \PYG{o}{=} \PYG{n+nb}{true}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{if}\PYG{p}{(}\PYG{n}{comargs}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{=}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZhy{}dx}\PYG{l+s}{\PYGZdq{}}\PYG{o}{\textbar{}}\PYG{o}{\textbar{}}\PYG{n}{comargs}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{=}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZhy{}dX}\PYG{l+s}{\PYGZdq{}}\PYG{o}{\textbar{}}\PYG{o}{\textbar{}}\PYG{n}{comargs}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{=}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZhy{}DX}\PYG{l+s}{\PYGZdq{}}\PYG{o}{\textbar{}}\PYG{o}{\textbar{}}\PYG{n}{comargs}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{=}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZhy{}Dx}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{runXL}\PYG{p}{(}\PYG{n}{comargs}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{bCheckUser} \PYG{o}{=} \PYG{n+nb}{true}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{if}\PYG{p}{(}\PYG{n}{comargs}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{=}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZhy{}c}\PYG{l+s}{\PYGZdq{}}\PYG{o}{\textbar{}}\PYG{o}{\textbar{}}\PYG{n}{comargs}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{=}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZhy{}C}\PYG{l+s}{\PYGZdq{}}\PYG{o}{\textbar{}}\PYG{o}{\textbar{}}\PYG{n}{comargs}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{=}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZhy{}config}\PYG{l+s}{\PYGZdq{}}\PYG{o}{\textbar{}}\PYG{o}{\textbar{}} \PYG{n}{comargs}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{=}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZhy{}Config}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{c+c1}{// Check that the config file is supplied.}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{argc}\PYG{o}{!}\PYG{o}{=}\PYG{l+m+mi}{3} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{n}{argc}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{k}{throw} \PYG{n}{FatalException}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ERROR\PYGZus{}MAIN\PYGZus{}011: FATAL. \PYGZhy{}c or \PYGZhy{}config used to attempt importSpatialParameters from }\PYG{l+s}{\PYGZdq{}}
                                         \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{config file, but no config file provided.}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{n}{bConfig} \PYG{o}{=} \PYG{n+nb}{true}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{n}{bFullmode} \PYG{o}{=} \PYG{n+nb}{false}\PYG{p}{;}
    \PYG{k}{if}\PYG{p}{(}\PYG{n}{comargs}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{=}\PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZhy{}f}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\textbar{}}\PYG{o}{\textbar{}} \PYG{n}{comargs}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]} \PYG{o}{=}\PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZhy{}f}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{writeInfo}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Full command\PYGZhy{}line mode enabled.}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{bFullmode} \PYG{o}{=} \PYG{n+nb}{true}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{n}{removeComOption}\PYG{p}{(}\PYG{n}{argc}\PYG{p}{,} \PYG{n}{comargs}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{removeComOption}\PYG{p}{(}\PYG{n}{argc}\PYG{p}{,} \PYG{n}{comargs}\PYG{p}{)}\PYG{p}{;}
    \PYG{k}{if}\PYG{p}{(}\PYG{n}{argc} \PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{12} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{o}{!}\PYG{n}{bFullmode}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{return}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{if}\PYG{p}{(}\PYG{n}{argc}\PYG{o}{\PYGZlt{}}\PYG{l+m+mi}{31}\PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}}\PYG{o}{!}\PYG{n}{bCheckUser} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}}\PYG{o}{!}\PYG{n}{bConfig}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{string} \PYG{n}{err} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ERROR\PYGZus{}MAIN\PYGZus{}000: FATAL.  Incorrect arguments supplied (}\PYG{l+s}{\PYGZdq{}} \PYG{o}{+} \PYG{n}{to\PYGZus{}string}\PYG{p}{(}\PYG{p}{(}\PYG{k+kt}{long} \PYG{k+kt}{long}\PYG{p}{)}\PYG{n}{argc}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)} \PYG{o}{+} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ supplied; expected 30).}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
        \PYG{k}{throw} \PYG{n+nf}{FatalException}\PYG{p}{(}\PYG{n}{err}\PYG{p}{)}\PYG{p}{;}
        \PYG{c+c1}{// note argc\PYGZhy{}1 which takes in to account the automatic generation of one command line argument which is the number of arguments.}
    \PYG{p}{\PYGZcb{}}
    \PYG{n}{argc} \PYG{o}{=} \PYG{n}{comargs}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}


\PYG{k+kt}{void} \PYG{n}{SpatialTree}\PYG{o}{:}\PYG{o}{:}\PYG{n}{checkFolders}\PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}

    \PYG{n}{stringstream} \PYG{n}{os}\PYG{p}{;}
    \PYG{n}{os} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Checking folder existance...}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{flush}\PYG{p}{;}
    \PYG{k+kt}{bool} \PYG{n}{bFineMap}\PYG{p}{,} \PYG{n}{bCoarseMap}\PYG{p}{,} \PYG{n}{bFineMapPristine}\PYG{p}{,} \PYG{n}{bCoarseMapPristine}\PYG{p}{,} \PYG{n}{bSampleMask}\PYG{p}{,} \PYG{n}{bOutputFolder}\PYG{p}{;}
    \PYG{k}{try}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{bFineMap} \PYG{o}{=} \PYG{n}{doesExistNull}\PYG{p}{(}\PYG{n}{sim\PYGZus{}parameters}\PYG{p}{.}\PYG{n}{fine\PYGZus{}map\PYGZus{}file}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{catch}\PYG{p}{(}\PYG{n}{FatalException}\PYG{o}{\PYGZam{}} \PYG{n}{fe}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{writeError}\PYG{p}{(}\PYG{n}{fe}\PYG{p}{.}\PYG{n}{what}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{bFineMap} \PYG{o}{=} \PYG{n+nb}{false}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{try}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{bCoarseMap} \PYG{o}{=} \PYG{n}{doesExistNull}\PYG{p}{(}\PYG{n}{sim\PYGZus{}parameters}\PYG{p}{.}\PYG{n}{coarse\PYGZus{}map\PYGZus{}file}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{catch}\PYG{p}{(}\PYG{n}{FatalException}\PYG{o}{\PYGZam{}} \PYG{n}{fe}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{writeError}\PYG{p}{(}\PYG{n}{fe}\PYG{p}{.}\PYG{n}{what}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{bCoarseMap} \PYG{o}{=} \PYG{n+nb}{false}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{try}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{bFineMapPristine} \PYG{o}{=} \PYG{n}{doesExistNull}\PYG{p}{(}\PYG{n}{sim\PYGZus{}parameters}\PYG{p}{.}\PYG{n}{pristine\PYGZus{}fine\PYGZus{}map\PYGZus{}file}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{catch}\PYG{p}{(}\PYG{n}{FatalException}\PYG{o}{\PYGZam{}} \PYG{n}{fe}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{writeError}\PYG{p}{(}\PYG{n}{fe}\PYG{p}{.}\PYG{n}{what}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{bFineMapPristine} \PYG{o}{=} \PYG{n+nb}{false}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{try}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{bCoarseMapPristine} \PYG{o}{=} \PYG{n}{doesExistNull}\PYG{p}{(}\PYG{n}{sim\PYGZus{}parameters}\PYG{p}{.}\PYG{n}{pristine\PYGZus{}coarse\PYGZus{}map\PYGZus{}file}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{catch}\PYG{p}{(}\PYG{n}{FatalException}\PYG{o}{\PYGZam{}} \PYG{n}{fe}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{writeError}\PYG{p}{(}\PYG{n}{fe}\PYG{p}{.}\PYG{n}{what}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{bCoarseMapPristine} \PYG{o}{=} \PYG{n+nb}{false}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{n}{bOutputFolder} \PYG{o}{=} \PYG{n}{checkOutputDirectory}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
    \PYG{k}{try}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{bSampleMask} \PYG{o}{=} \PYG{n}{doesExistNull}\PYG{p}{(}\PYG{n}{sim\PYGZus{}parameters}\PYG{p}{.}\PYG{n}{sample\PYGZus{}mask\PYGZus{}file}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{catch}\PYG{p}{(}\PYG{n}{FatalException}\PYG{o}{\PYGZam{}} \PYG{n}{fe}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{writeError}\PYG{p}{(}\PYG{n}{fe}\PYG{p}{.}\PYG{n}{what}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{bSampleMask} \PYG{o}{=} \PYG{n+nb}{false}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{if}\PYG{p}{(}\PYG{n}{bFineMap} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{n}{bCoarseMap} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{n}{bFineMapPristine} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{n}{bCoarseMapPristine} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{n}{bOutputFolder} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{n}{bSampleMask}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{os} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}r}\PYG{l+s}{Checking folder existance...done!                                                                }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
        \PYG{n}{writeInfo}\PYG{p}{(}\PYG{n}{os}\PYG{p}{.}\PYG{n}{str}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{return}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{else}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{throw} \PYG{n}{FatalException}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Required files do not all exist. Check program inputs.}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}


\PYG{k+kt}{void} \PYG{n}{SpatialTree}\PYG{o}{:}\PYG{o}{:}\PYG{n}{setParameters}\PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k}{if}\PYG{p}{(}\PYG{o}{!}\PYG{n}{has\PYGZus{}imported\PYGZus{}vars}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{Tree}\PYG{o}{:}\PYG{o}{:}\PYG{n}{setParameters}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
        \PYG{c+c1}{// Set the variables equal to the value from the Mapvars object.}
        \PYG{n}{fine\PYGZus{}map\PYGZus{}input} \PYG{o}{=} \PYG{n}{sim\PYGZus{}parameters}\PYG{p}{.}\PYG{n}{fine\PYGZus{}map\PYGZus{}file}\PYG{p}{;}
        \PYG{n}{coarse\PYGZus{}map\PYGZus{}input} \PYG{o}{=} \PYG{n}{sim\PYGZus{}parameters}\PYG{p}{.}\PYG{n}{coarse\PYGZus{}map\PYGZus{}file}\PYG{p}{;}
        \PYG{n}{grid\PYGZus{}x\PYGZus{}size} \PYG{o}{=} \PYG{n}{sim\PYGZus{}parameters}\PYG{p}{.}\PYG{n}{grid\PYGZus{}x\PYGZus{}size}\PYG{p}{;}
        \PYG{n}{grid\PYGZus{}y\PYGZus{}size} \PYG{o}{=} \PYG{n}{sim\PYGZus{}parameters}\PYG{p}{.}\PYG{n}{grid\PYGZus{}y\PYGZus{}size}\PYG{p}{;}

        \PYG{n}{fine\PYGZus{}map\PYGZus{}x\PYGZus{}size} \PYG{o}{=} \PYG{n}{sim\PYGZus{}parameters}\PYG{p}{.}\PYG{n}{fine\PYGZus{}map\PYGZus{}x\PYGZus{}size}\PYG{p}{;}
        \PYG{n}{fine\PYGZus{}map\PYGZus{}y\PYGZus{}size} \PYG{o}{=} \PYG{n}{sim\PYGZus{}parameters}\PYG{p}{.}\PYG{n}{fine\PYGZus{}map\PYGZus{}y\PYGZus{}size}\PYG{p}{;}
        \PYG{n}{fine\PYGZus{}map\PYGZus{}x\PYGZus{}offset} \PYG{o}{=} \PYG{n}{sim\PYGZus{}parameters}\PYG{p}{.}\PYG{n}{fine\PYGZus{}map\PYGZus{}x\PYGZus{}offset}\PYG{p}{;}
        \PYG{n}{fine\PYGZus{}map\PYGZus{}y\PYGZus{}offset} \PYG{o}{=} \PYG{n}{sim\PYGZus{}parameters}\PYG{p}{.}\PYG{n}{fine\PYGZus{}map\PYGZus{}y\PYGZus{}offset}\PYG{p}{;}

        \PYG{n}{coarse\PYGZus{}map\PYGZus{}x\PYGZus{}size} \PYG{o}{=} \PYG{n}{sim\PYGZus{}parameters}\PYG{p}{.}\PYG{n}{coarse\PYGZus{}map\PYGZus{}x\PYGZus{}size}\PYG{p}{;}
        \PYG{n}{coarse\PYGZus{}map\PYGZus{}y\PYGZus{}size} \PYG{o}{=} \PYG{n}{sim\PYGZus{}parameters}\PYG{p}{.}\PYG{n}{coarse\PYGZus{}map\PYGZus{}y\PYGZus{}size}\PYG{p}{;}
        \PYG{n}{coarse\PYGZus{}map\PYGZus{}x\PYGZus{}offset} \PYG{o}{=} \PYG{n}{sim\PYGZus{}parameters}\PYG{p}{.}\PYG{n}{coarse\PYGZus{}map\PYGZus{}x\PYGZus{}offset}\PYG{p}{;}
        \PYG{n}{coarse\PYGZus{}map\PYGZus{}y\PYGZus{}offset} \PYG{o}{=} \PYG{n}{sim\PYGZus{}parameters}\PYG{p}{.}\PYG{n}{coarse\PYGZus{}map\PYGZus{}y\PYGZus{}offset}\PYG{p}{;}
        \PYG{n}{coarse\PYGZus{}map\PYGZus{}scale} \PYG{o}{=} \PYG{n}{sim\PYGZus{}parameters}\PYG{p}{.}\PYG{n}{coarse\PYGZus{}map\PYGZus{}scale}\PYG{p}{;}
        \PYG{n}{dispersal\PYGZus{}relative\PYGZus{}cost} \PYG{o}{=} \PYG{n}{sim\PYGZus{}parameters}\PYG{p}{.}\PYG{n}{dispersal\PYGZus{}relative\PYGZus{}cost}\PYG{p}{;}


        \PYG{c+c1}{// pristine map information}
        \PYG{n}{pristine\PYGZus{}fine\PYGZus{}map\PYGZus{}input} \PYG{o}{=} \PYG{n}{sim\PYGZus{}parameters}\PYG{p}{.}\PYG{n}{pristine\PYGZus{}fine\PYGZus{}map\PYGZus{}file}\PYG{p}{;}
        \PYG{n}{pristine\PYGZus{}coarse\PYGZus{}map\PYGZus{}input} \PYG{o}{=} \PYG{n}{sim\PYGZus{}parameters}\PYG{p}{.}\PYG{n}{pristine\PYGZus{}coarse\PYGZus{}map\PYGZus{}file}\PYG{p}{;}
        \PYG{n}{gen\PYGZus{}since\PYGZus{}pristine} \PYG{o}{=} \PYG{n}{sim\PYGZus{}parameters}\PYG{p}{.}\PYG{n}{gen\PYGZus{}since\PYGZus{}pristine}\PYG{p}{;}
        \PYG{n}{habitat\PYGZus{}change\PYGZus{}rate} \PYG{o}{=} \PYG{n}{sim\PYGZus{}parameters}\PYG{p}{.}\PYG{n}{habitat\PYGZus{}change\PYGZus{}rate}\PYG{p}{;}
        \PYG{n}{desired\PYGZus{}specnum} \PYG{o}{=} \PYG{n}{sim\PYGZus{}parameters}\PYG{p}{.}\PYG{n}{desired\PYGZus{}specnum}\PYG{p}{;}
        \PYG{n}{sigma} \PYG{o}{=} \PYG{n}{sim\PYGZus{}parameters}\PYG{p}{.}\PYG{n}{sigma}\PYG{p}{;}
        \PYG{n}{tau} \PYG{o}{=} \PYG{n}{sim\PYGZus{}parameters}\PYG{p}{.}\PYG{n}{tau}\PYG{p}{;}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{sim\PYGZus{}parameters}\PYG{p}{.}\PYG{n}{landscape\PYGZus{}type} \PYG{o}{=}\PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{none}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{sim\PYGZus{}parameters}\PYG{p}{.}\PYG{n}{landscape\PYGZus{}type} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{closed}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{sim\PYGZus{}parameters}\PYG{p}{.}\PYG{n}{dispersal\PYGZus{}method} \PYG{o}{=}\PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{none}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{sim\PYGZus{}parameters}\PYG{p}{.}\PYG{n}{dispersal\PYGZus{}method} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{normal}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{else}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{throw} \PYG{n}{FatalException}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ERROR\PYGZus{}MAIN\PYGZus{}001: Variables already imported.}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}



\PYG{k+kt}{void} \PYG{n}{SpatialTree}\PYG{o}{:}\PYG{o}{:}\PYG{n}{importMaps}\PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k}{if}\PYG{p}{(}\PYG{n}{has\PYGZus{}imported\PYGZus{}vars}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{c+c1}{// Set the dimensions}
        \PYG{n}{habitat\PYGZus{}map}\PYG{p}{.}\PYG{n}{setDims}\PYG{p}{(}\PYG{n}{sim\PYGZus{}parameters}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{try}
        \PYG{p}{\PYGZob{}}
            \PYG{c+c1}{// Set the time variables}
            \PYG{n}{habitat\PYGZus{}map}\PYG{p}{.}\PYG{n}{checkMapExists}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
            \PYG{c+c1}{// habitat\PYGZus{}map.setTimeVars(gen\PYGZus{}since\PYGZus{}pristine,habitat\PYGZus{}change\PYGZus{}rate);}
            \PYG{c+c1}{// Import the fine map}
            \PYG{n}{habitat\PYGZus{}map}\PYG{p}{.}\PYG{n}{calcFineMap}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
            \PYG{c+c1}{// Import the coarse map}
            \PYG{n}{habitat\PYGZus{}map}\PYG{p}{.}\PYG{n}{calcCoarseMap}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
            \PYG{c+c1}{// Calculate the offset for the extremeties of each map}
            \PYG{n}{habitat\PYGZus{}map}\PYG{p}{.}\PYG{n}{calcOffset}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
            \PYG{c+c1}{// Import the pristine maps;}
            \PYG{n}{habitat\PYGZus{}map}\PYG{p}{.}\PYG{n}{calcPristineFineMap}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
            \PYG{n}{habitat\PYGZus{}map}\PYG{p}{.}\PYG{n}{calcPristineCoarseMap}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
            \PYG{c+c1}{// Calculate the maximum values}
            \PYG{n}{habitat\PYGZus{}map}\PYG{p}{.}\PYG{n}{recalculateHabitatMax}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
            \PYG{n}{importReproductionMap}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
            \PYG{n}{samplegrid}\PYG{p}{.}\PYG{n}{importSampleMask}\PYG{p}{(}\PYG{n}{sim\PYGZus{}parameters}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{catch}\PYG{p}{(}\PYG{n}{FatalException}\PYG{o}{\PYGZam{}} \PYG{n}{fe}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{stringstream} \PYG{n}{ss}\PYG{p}{;}
            \PYG{n}{ss} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Problem setting up map files: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{fe}\PYG{p}{.}\PYG{n}{what}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
            \PYG{k}{throw} \PYG{n+nf}{FatalException}\PYG{p}{(}\PYG{n}{ss}\PYG{p}{.}\PYG{n}{str}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{else}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{throw} \PYG{n}{FatalException}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ERROR\PYGZus{}MAIN\PYGZus{}002: Variables not imported.}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{void} \PYG{n}{SpatialTree}\PYG{o}{:}\PYG{o}{:}\PYG{n}{importReproductionMap}\PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{n}{rep\PYGZus{}map}\PYG{p}{.}\PYG{n}{import}\PYG{p}{(}\PYG{n}{sim\PYGZus{}parameters}\PYG{p}{.}\PYG{n}{reproduction\PYGZus{}file}\PYG{p}{,}
                   \PYG{n}{sim\PYGZus{}parameters}\PYG{p}{.}\PYG{n}{fine\PYGZus{}map\PYGZus{}x\PYGZus{}size}\PYG{p}{,} \PYG{n}{sim\PYGZus{}parameters}\PYG{p}{.}\PYG{n}{fine\PYGZus{}map\PYGZus{}y\PYGZus{}size}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{rep\PYGZus{}map}\PYG{p}{.}\PYG{n}{setOffsets}\PYG{p}{(}\PYG{n}{sim\PYGZus{}parameters}\PYG{p}{.}\PYG{n}{coarse\PYGZus{}map\PYGZus{}x\PYGZus{}offset}\PYG{p}{,} \PYG{n}{sim\PYGZus{}parameters}\PYG{p}{.}\PYG{n}{fine\PYGZus{}map\PYGZus{}y\PYGZus{}offset}\PYG{p}{,}
                       \PYG{n}{sim\PYGZus{}parameters}\PYG{p}{.}\PYG{n}{grid\PYGZus{}x\PYGZus{}size}\PYG{p}{,} \PYG{n}{sim\PYGZus{}parameters}\PYG{p}{.}\PYG{n}{grid\PYGZus{}y\PYGZus{}size}\PYG{p}{)}\PYG{p}{;}
    \PYG{c+c1}{// Now verify that the reproduction map is always non\PYGZhy{}zero when the density is non\PYGZhy{}zero.}
    \PYG{n}{verifyReproductionMap}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}


\PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{SpatialTree}\PYG{o}{:}\PYG{o}{:}\PYG{n}{getInitialCount}\PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{initcount} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
    \PYG{c+c1}{// Get a count of the number of individuals on the grid.}
    \PYG{k}{try}
    \PYG{p}{\PYGZob{}}
        \PYG{k+kt}{long} \PYG{n}{max\PYGZus{}x}\PYG{p}{,} \PYG{n}{max\PYGZus{}y}\PYG{p}{;}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{samplegrid}\PYG{p}{.}\PYG{n}{getDefault}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{max\PYGZus{}x} \PYG{o}{=} \PYG{n}{sim\PYGZus{}parameters}\PYG{p}{.}\PYG{n}{fine\PYGZus{}map\PYGZus{}x\PYGZus{}size}\PYG{p}{;}
            \PYG{n}{max\PYGZus{}y} \PYG{o}{=} \PYG{n}{sim\PYGZus{}parameters}\PYG{p}{.}\PYG{n}{fine\PYGZus{}map\PYGZus{}y\PYGZus{}size}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{else}
        \PYG{p}{\PYGZob{}}
            \PYG{k}{if}\PYG{p}{(}\PYG{n}{sim\PYGZus{}parameters}\PYG{p}{.}\PYG{n}{uses\PYGZus{}spatial\PYGZus{}sampling}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{n}{max\PYGZus{}x} \PYG{o}{=} \PYG{n}{samplegrid}\PYG{p}{.}\PYG{n}{sample\PYGZus{}mask\PYGZus{}exact}\PYG{p}{.}\PYG{n}{GetCols}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
                \PYG{n}{max\PYGZus{}y} \PYG{o}{=} \PYG{n}{samplegrid}\PYG{p}{.}\PYG{n}{sample\PYGZus{}mask\PYGZus{}exact}\PYG{p}{.}\PYG{n}{GetRows}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
            \PYG{k}{else}
            \PYG{p}{\PYGZob{}}
                \PYG{n}{max\PYGZus{}x} \PYG{o}{=} \PYG{n}{samplegrid}\PYG{p}{.}\PYG{n}{sample\PYGZus{}mask}\PYG{p}{.}\PYG{n}{GetCols}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
                \PYG{n}{max\PYGZus{}y} \PYG{o}{=} \PYG{n}{samplegrid}\PYG{p}{.}\PYG{n}{sample\PYGZus{}mask}\PYG{p}{.}\PYG{n}{GetRows}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
        \PYG{p}{\PYGZcb{}}
        \PYG{k+kt}{long} \PYG{n}{x}\PYG{p}{,} \PYG{n}{y}\PYG{p}{,} \PYG{n}{xwrap}\PYG{p}{,} \PYG{n}{ywrap}\PYG{p}{;}
        \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{long} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{max\PYGZus{}y}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{long} \PYG{n}{j} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{j} \PYG{o}{\PYGZlt{}} \PYG{n}{max\PYGZus{}x}\PYG{p}{;} \PYG{n}{j}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{n}{x} \PYG{o}{=} \PYG{n}{j}\PYG{p}{;}
                \PYG{n}{y} \PYG{o}{=} \PYG{n}{i}\PYG{p}{;}
                \PYG{n}{xwrap} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
                \PYG{n}{ywrap} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
                \PYG{n}{samplegrid}\PYG{p}{.}\PYG{n}{recalculate\PYGZus{}coordinates}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,} \PYG{n}{y}\PYG{p}{,} \PYG{n}{xwrap}\PYG{p}{,} \PYG{n}{ywrap}\PYG{p}{)}\PYG{p}{;}
                \PYG{n}{initcount} \PYG{o}{+}\PYG{o}{=} \PYG{n}{getIndividualsSampled}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,} \PYG{n}{y}\PYG{p}{,} \PYG{n}{xwrap}\PYG{p}{,} \PYG{n}{ywrap}\PYG{p}{,} \PYG{l+m+mf}{0.0}\PYG{p}{)}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
        \PYG{p}{\PYGZcb{}}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{catch}\PYG{p}{(}\PYG{n}{exception}\PYG{o}{\PYGZam{}} \PYG{n}{e}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{throw} \PYG{n}{FatalException}\PYG{p}{(}\PYG{n}{e}\PYG{p}{.}\PYG{n}{what}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{c+c1}{// Set active and data at the correct sizes.}
    \PYG{k}{if}\PYG{p}{(}\PYG{n}{initcount} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{throw} \PYG{n}{runtime\PYGZus{}error}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Initial count is 0. No individuals to simulate. Exiting program.}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{else}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{writeInfo}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Initial count is }\PYG{l+s}{\PYGZdq{}} \PYG{o}{+} \PYG{n}{to\PYGZus{}string}\PYG{p}{(}\PYG{n}{initcount}\PYG{p}{)} \PYG{o}{+} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{if}\PYG{p}{(}\PYG{n}{initcount} \PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{10000000000}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{writeWarning}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Initial count extremely large, RAM issues likely: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{+} \PYG{n}{to\PYGZus{}string}\PYG{p}{(}\PYG{n}{initcount}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{return} \PYG{n}{initcount}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}


\PYG{k+kt}{void} \PYG{n}{SpatialTree}\PYG{o}{:}\PYG{o}{:}\PYG{n}{setupDispersalCoordinator}\PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{n}{dispersal\PYGZus{}coordinator}\PYG{p}{.}\PYG{n}{setHabitatMap}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{habitat\PYGZus{}map}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{dispersal\PYGZus{}coordinator}\PYG{p}{.}\PYG{n}{setRandomNumber}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{NR}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{dispersal\PYGZus{}coordinator}\PYG{p}{.}\PYG{n}{setGenerationPtr}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{generation}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{dispersal\PYGZus{}coordinator}\PYG{p}{.}\PYG{n}{setDispersal}\PYG{p}{(}\PYG{n}{sim\PYGZus{}parameters}\PYG{p}{.}\PYG{n}{dispersal\PYGZus{}method}\PYG{p}{,} \PYG{n}{sim\PYGZus{}parameters}\PYG{p}{.}\PYG{n}{dispersal\PYGZus{}file}\PYG{p}{,}
                                        \PYG{n}{sim\PYGZus{}parameters}\PYG{p}{.}\PYG{n}{fine\PYGZus{}map\PYGZus{}x\PYGZus{}size}\PYG{p}{,} \PYG{n}{sim\PYGZus{}parameters}\PYG{p}{.}\PYG{n}{fine\PYGZus{}map\PYGZus{}y\PYGZus{}size}\PYG{p}{,}
                                        \PYG{n}{sim\PYGZus{}parameters}\PYG{p}{.}\PYG{n}{m\PYGZus{}prob}\PYG{p}{,} \PYG{n}{sim\PYGZus{}parameters}\PYG{p}{.}\PYG{n}{cutoff}\PYG{p}{,} \PYG{n}{sim\PYGZus{}parameters}\PYG{p}{.}\PYG{n}{sigma}\PYG{p}{,}
                                        \PYG{n}{sim\PYGZus{}parameters}\PYG{p}{.}\PYG{n}{tau}\PYG{p}{,} \PYG{n}{sim\PYGZus{}parameters}\PYG{p}{.}\PYG{n}{restrict\PYGZus{}self}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{void} \PYG{n}{SpatialTree}\PYG{o}{:}\PYG{o}{:}\PYG{n}{setup}\PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{n}{printSetup}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
    \PYG{k}{if}\PYG{p}{(}\PYG{n}{has\PYGZus{}paused}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{if}\PYG{p}{(}\PYG{o}{!}\PYG{n}{has\PYGZus{}imported\PYGZus{}pause}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{setResumeParameters}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{n}{simResume}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{setupDispersalCoordinator}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{else}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{setParameters}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{setInitialValues}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{importMaps}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{setupDispersalCoordinator}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{habitat\PYGZus{}map}\PYG{p}{.}\PYG{n}{setLandscape}\PYG{p}{(}\PYG{n}{sim\PYGZus{}parameters}\PYG{p}{.}\PYG{n}{landscape\PYGZus{}type}\PYG{p}{)}\PYG{p}{;}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifdef DEBUG}
        \PYG{n}{habitat\PYGZus{}map}\PYG{p}{.}\PYG{n}{validateMaps}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif}
        \PYG{n}{generateObjects}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{SpatialTree}\PYG{o}{:}\PYG{o}{:}\PYG{n}{fillObjects}\PYG{p}{(}\PYG{k}{const} \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{initial\PYGZus{}count}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{n}{active}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{.}\PYG{n}{setup}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{grid}\PYG{p}{.}\PYG{n}{SetSize}\PYG{p}{(}\PYG{n}{grid\PYGZus{}y\PYGZus{}size}\PYG{p}{,} \PYG{n}{grid\PYGZus{}x\PYGZus{}size}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{number\PYGZus{}start} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
    \PYG{n}{stringstream} \PYG{n}{os}\PYG{p}{;}
    \PYG{n}{os} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}r}\PYG{l+s}{Setting up simulation...filling grid                           }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{flush}\PYG{p}{;}
    \PYG{n}{writeInfo}\PYG{p}{(}\PYG{n}{os}\PYG{p}{.}\PYG{n}{str}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
    \PYG{c+c1}{// Add the individuals to the grid, and add wrapped individuals to their correct locations.}
    \PYG{c+c1}{// This loop adds individuals to data and active (for storing the coalescence tree and active lineage tracking)}
    \PYG{k}{try}
    \PYG{p}{\PYGZob{}}
        \PYG{k+kt}{long} \PYG{n}{x}\PYG{p}{,} \PYG{n}{y}\PYG{p}{;}
        \PYG{k+kt}{long} \PYG{n}{x\PYGZus{}wrap}\PYG{p}{,} \PYG{n}{y\PYGZus{}wrap}\PYG{p}{;}
        \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{sim\PYGZus{}parameters}\PYG{p}{.}\PYG{n}{sample\PYGZus{}x\PYGZus{}size}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{j} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{j} \PYG{o}{\PYGZlt{}} \PYG{n}{sim\PYGZus{}parameters}\PYG{p}{.}\PYG{n}{sample\PYGZus{}y\PYGZus{}size}\PYG{p}{;} \PYG{n}{j}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}

                \PYG{n}{x} \PYG{o}{=} \PYG{n}{i}\PYG{p}{;}
                \PYG{n}{y} \PYG{o}{=} \PYG{n}{j}\PYG{p}{;}

                \PYG{n}{x\PYGZus{}wrap} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
                \PYG{n}{y\PYGZus{}wrap} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
                \PYG{n}{samplegrid}\PYG{p}{.}\PYG{n}{recalculate\PYGZus{}coordinates}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,} \PYG{n}{y}\PYG{p}{,} \PYG{n}{x\PYGZus{}wrap}\PYG{p}{,} \PYG{n}{y\PYGZus{}wrap}\PYG{p}{)}\PYG{p}{;}
                \PYG{k}{if}\PYG{p}{(}\PYG{n}{x\PYGZus{}wrap} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{0} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{n}{y\PYGZus{}wrap} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)}
                \PYG{p}{\PYGZob{}}
                    \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{stored\PYGZus{}next} \PYG{o}{=} \PYG{n}{grid}\PYG{p}{[}\PYG{n}{y}\PYG{p}{]}\PYG{p}{[}\PYG{n}{x}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getNext}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
                    \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{stored\PYGZus{}nwrap} \PYG{o}{=} \PYG{n}{grid}\PYG{p}{[}\PYG{n}{y}\PYG{p}{]}\PYG{p}{[}\PYG{n}{x}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getNwrap}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
                    \PYG{n}{grid}\PYG{p}{[}\PYG{n}{y}\PYG{p}{]}\PYG{p}{[}\PYG{n}{x}\PYG{p}{]}\PYG{p}{.}\PYG{n}{initialise}\PYG{p}{(}\PYG{n}{habitat\PYGZus{}map}\PYG{p}{.}\PYG{n}{getVal}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,} \PYG{n}{y}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
                    \PYG{n}{grid}\PYG{p}{[}\PYG{n}{y}\PYG{p}{]}\PYG{p}{[}\PYG{n}{x}\PYG{p}{]}\PYG{p}{.}\PYG{n}{fillList}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
                    \PYG{n}{grid}\PYG{p}{[}\PYG{n}{y}\PYG{p}{]}\PYG{p}{[}\PYG{n}{x}\PYG{p}{]}\PYG{p}{.}\PYG{n}{setNwrap}\PYG{p}{(}\PYG{n}{stored\PYGZus{}nwrap}\PYG{p}{)}\PYG{p}{;}
                    \PYG{n}{grid}\PYG{p}{[}\PYG{n}{y}\PYG{p}{]}\PYG{p}{[}\PYG{n}{x}\PYG{p}{]}\PYG{p}{.}\PYG{n}{setNext}\PYG{p}{(}\PYG{n}{stored\PYGZus{}next}\PYG{p}{)}\PYG{p}{;}
                    \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{sample\PYGZus{}amount} \PYG{o}{=} \PYG{n}{getIndividualsSampled}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,} \PYG{n}{y}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mf}{0.0}\PYG{p}{)}\PYG{p}{;}
                    \PYG{k}{if}\PYG{p}{(}\PYG{n}{sample\PYGZus{}amount} \PYG{o}{\PYGZgt{}}\PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{)}
                    \PYG{p}{\PYGZob{}}
                        \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{k} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{k} \PYG{o}{\PYGZlt{}} \PYG{n}{sample\PYGZus{}amount}\PYG{p}{;} \PYG{n}{k}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
                        \PYG{p}{\PYGZob{}}
                            \PYG{k}{if}\PYG{p}{(}\PYG{n}{k} \PYG{o}{\PYGZgt{}}\PYG{o}{=} \PYG{n}{grid}\PYG{p}{[}\PYG{n}{y}\PYG{p}{]}\PYG{p}{[}\PYG{n}{x}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getMaxsize}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
                            \PYG{p}{\PYGZob{}}
                                \PYG{k}{break}\PYG{p}{;}
                            \PYG{p}{\PYGZcb{}}
                            \PYG{k}{if}\PYG{p}{(}\PYG{n}{number\PYGZus{}start} \PYG{o}{+} \PYG{l+m+mi}{1} \PYG{o}{\PYGZgt{}} \PYG{n}{initial\PYGZus{}count}\PYG{p}{)}
                            \PYG{p}{\PYGZob{}}
                                \PYG{n}{stringstream} \PYG{n}{msg}\PYG{p}{;}
                                \PYG{n}{msg} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Number start greater than initial count. Please report this error!}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
                                \PYG{n}{msg} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Number start: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{number\PYGZus{}start} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{. Initial count: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{initial\PYGZus{}count}
                                    \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
                                \PYG{k}{throw} \PYG{n+nf}{out\PYGZus{}of\PYGZus{}range}\PYG{p}{(}\PYG{n}{msg}\PYG{p}{.}\PYG{n}{str}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
                            \PYG{p}{\PYGZcb{}}
                            \PYG{k}{else}
                            \PYG{p}{\PYGZob{}}
                                \PYG{n}{number\PYGZus{}start}\PYG{o}{+}\PYG{o}{+}\PYG{p}{;}
                                \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{list\PYGZus{}position\PYGZus{}in} \PYG{o}{=} \PYG{n}{grid}\PYG{p}{[}\PYG{n}{y}\PYG{p}{]}\PYG{p}{[}\PYG{n}{x}\PYG{p}{]}\PYG{p}{.}\PYG{n}{addSpecies}\PYG{p}{(}\PYG{n}{number\PYGZus{}start}\PYG{p}{)}\PYG{p}{;}
                                \PYG{c+c1}{// Add the species to active}
                                \PYG{n}{active}\PYG{p}{[}\PYG{n}{number\PYGZus{}start}\PYG{p}{]}\PYG{p}{.}\PYG{n}{setup}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,} \PYG{n}{y}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{number\PYGZus{}start}\PYG{p}{,} \PYG{n}{list\PYGZus{}position\PYGZus{}in}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
                                \PYG{c+c1}{// Add a tip in the TreeNode for calculation of the coalescence tree at the}
                                \PYG{c+c1}{// end of the simulation.}
                                \PYG{c+c1}{// This also contains the start x and y position of the species.}
                                \PYG{n}{data}\PYG{p}{[}\PYG{n}{number\PYGZus{}start}\PYG{p}{]}\PYG{p}{.}\PYG{n}{setup}\PYG{p}{(}\PYG{n+nb}{true}\PYG{p}{,} \PYG{n}{x}\PYG{p}{,} \PYG{n}{y}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}
                                \PYG{n}{data}\PYG{p}{[}\PYG{n}{number\PYGZus{}start}\PYG{p}{]}\PYG{p}{.}\PYG{n}{setSpec}\PYG{p}{(}\PYG{n}{NR}\PYG{p}{.}\PYG{n}{d01}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
                                \PYG{n}{endactive}\PYG{o}{+}\PYG{o}{+}\PYG{p}{;}
                                \PYG{n}{enddata}\PYG{o}{+}\PYG{o}{+}\PYG{p}{;}
                            \PYG{p}{\PYGZcb{}}
                        \PYG{p}{\PYGZcb{}}
                    \PYG{p}{\PYGZcb{}}
                \PYG{p}{\PYGZcb{}}
                \PYG{k}{else}
                \PYG{p}{\PYGZob{}}
                    \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{sample\PYGZus{}amount} \PYG{o}{=} \PYG{n}{getIndividualsSampled}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,} \PYG{n}{y}\PYG{p}{,} \PYG{n}{x\PYGZus{}wrap}\PYG{p}{,} \PYG{n}{y\PYGZus{}wrap}\PYG{p}{,} \PYG{l+m+mf}{0.0}\PYG{p}{)}\PYG{p}{;}
                    \PYG{k}{if}\PYG{p}{(}\PYG{n}{sample\PYGZus{}amount} \PYG{o}{\PYGZgt{}}\PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{)}
                    \PYG{p}{\PYGZob{}}
                        \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{k} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{k} \PYG{o}{\PYGZlt{}} \PYG{n}{sample\PYGZus{}amount}\PYG{p}{;} \PYG{n}{k}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
                        \PYG{p}{\PYGZob{}}
                            \PYG{k}{if}\PYG{p}{(}\PYG{n}{number\PYGZus{}start} \PYG{o}{+} \PYG{l+m+mi}{1} \PYG{o}{\PYGZgt{}} \PYG{n}{initial\PYGZus{}count}\PYG{p}{)}
                            \PYG{p}{\PYGZob{}}
                                \PYG{n}{stringstream} \PYG{n}{msg}\PYG{p}{;}
                                \PYG{n}{msg} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Number start greater than initial count. Please report this error!}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
                                \PYG{n}{msg} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Number start: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{number\PYGZus{}start} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{. Initial count: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{initial\PYGZus{}count}
                                    \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
                                \PYG{k}{throw} \PYG{n+nf}{out\PYGZus{}of\PYGZus{}range}\PYG{p}{(}\PYG{n}{msg}\PYG{p}{.}\PYG{n}{str}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
                            \PYG{p}{\PYGZcb{}}
                            \PYG{k}{else}
                            \PYG{p}{\PYGZob{}}
                                \PYG{n}{number\PYGZus{}start}\PYG{o}{+}\PYG{o}{+}\PYG{p}{;}
                                \PYG{c+c1}{// Add the lineage to the wrapped lineages}
                                \PYG{n}{active}\PYG{p}{[}\PYG{n}{number\PYGZus{}start}\PYG{p}{]}\PYG{p}{.}\PYG{n}{setup}\PYG{p}{(}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{long}\PYG{p}{)} \PYG{n}{x}\PYG{p}{,}
                                                           \PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{long}\PYG{p}{)} \PYG{n}{y}\PYG{p}{,}
                                                           \PYG{n}{x\PYGZus{}wrap}\PYG{p}{,} \PYG{n}{y\PYGZus{}wrap}\PYG{p}{,} \PYG{n}{number\PYGZus{}start}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
                                \PYG{n}{addWrappedLineage}\PYG{p}{(}\PYG{n}{number\PYGZus{}start}\PYG{p}{,} \PYG{n}{x}\PYG{p}{,} \PYG{n}{y}\PYG{p}{)}\PYG{p}{;}
                                \PYG{c+c1}{// Add a tip in the TreeNode for calculation of the coalescence tree at the}
                                \PYG{c+c1}{// end of the simulation.}
                                \PYG{c+c1}{// This also contains the start x and y position of the species.}
                                \PYG{n}{data}\PYG{p}{[}\PYG{n}{number\PYGZus{}start}\PYG{p}{]}\PYG{p}{.}\PYG{n}{setup}\PYG{p}{(}\PYG{n+nb}{true}\PYG{p}{,} \PYG{n}{x}\PYG{p}{,} \PYG{n}{y}\PYG{p}{,} \PYG{n}{x\PYGZus{}wrap}\PYG{p}{,} \PYG{n}{y\PYGZus{}wrap}\PYG{p}{)}\PYG{p}{;}
                                \PYG{n}{data}\PYG{p}{[}\PYG{n}{number\PYGZus{}start}\PYG{p}{]}\PYG{p}{.}\PYG{n}{setSpec}\PYG{p}{(}\PYG{n}{NR}\PYG{p}{.}\PYG{n}{d01}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
                                \PYG{n}{endactive}\PYG{o}{+}\PYG{o}{+}\PYG{p}{;}
                                \PYG{n}{enddata}\PYG{o}{+}\PYG{o}{+}\PYG{p}{;}
                            \PYG{p}{\PYGZcb{}}
                        \PYG{p}{\PYGZcb{}}
                    \PYG{p}{\PYGZcb{}}
                \PYG{p}{\PYGZcb{}}
            \PYG{p}{\PYGZcb{}}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{sim\PYGZus{}parameters}\PYG{p}{.}\PYG{n}{uses\PYGZus{}spatial\PYGZus{}sampling}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}

            \PYG{n}{samplegrid}\PYG{p}{.}\PYG{n}{convertBoolean}\PYG{p}{(}\PYG{n}{habitat\PYGZus{}map}\PYG{p}{,} \PYG{n}{deme\PYGZus{}sample}\PYG{p}{,} \PYG{n}{generation}\PYG{p}{)}\PYG{p}{;}
            \PYG{c+c1}{// if there are no additional time points to sample at, we can remove the sample mask from memory.}
            \PYG{k}{if}\PYG{p}{(}\PYG{o}{!}\PYG{p}{(}\PYG{n}{has\PYGZus{}times\PYGZus{}file} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{n}{this\PYGZus{}step}\PYG{p}{.}\PYG{n}{time\PYGZus{}reference} \PYG{o}{\PYGZlt{}} \PYG{n}{reference\PYGZus{}times}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{n}{samplegrid}\PYG{p}{.}\PYG{n}{clearSpatialMask}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
        \PYG{p}{\PYGZcb{}}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{catch}\PYG{p}{(}\PYG{n}{out\PYGZus{}of\PYGZus{}range} \PYG{o}{\PYGZam{}}\PYG{n}{out\PYGZus{}of\PYGZus{}range1}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{stringstream} \PYG{n}{ss}\PYG{p}{;}
        \PYG{n}{ss} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Fatal exception thrown when filling grid (out\PYGZus{}of\PYGZus{}range): }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{out\PYGZus{}of\PYGZus{}range1}\PYG{p}{.}\PYG{n}{what}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
        \PYG{k}{throw} \PYG{n+nf}{FatalException}\PYG{p}{(}\PYG{n}{ss}\PYG{p}{.}\PYG{n}{str}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{catch}\PYG{p}{(}\PYG{n}{exception} \PYG{o}{\PYGZam{}}\PYG{n}{fe}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{throw} \PYG{n}{FatalException}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Fatal exception thrown when filling grid (other) }\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{k}{if}\PYG{p}{(}\PYG{n}{number\PYGZus{}start} \PYG{o}{=}\PYG{o}{=} \PYG{n}{initial\PYGZus{}count}\PYG{p}{)}  \PYG{c+c1}{// Check that the two counting methods match up.}
    \PYG{p}{\PYGZob{}}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{else}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{initial\PYGZus{}count} \PYG{o}{\PYGZgt{}} \PYG{l+m+mf}{1.1} \PYG{o}{*} \PYG{n}{number\PYGZus{}start}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{writeWarning}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Data usage higher than neccessary \PYGZhy{} check allocation of individuals to the grid.}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
            \PYG{n}{stringstream} \PYG{n}{ss}\PYG{p}{;}
            \PYG{n}{ss} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Initial count: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{initial\PYGZus{}count} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{  Number counted: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{number\PYGZus{}start} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
            \PYG{n}{writeWarning}\PYG{p}{(}\PYG{n}{ss}\PYG{p}{.}\PYG{n}{str}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
    \PYG{p}{\PYGZcb{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifdef DEBUG}
    \PYG{n}{validateLineages}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif}
    \PYG{k}{return} \PYG{n}{number\PYGZus{}start}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{SpatialTree}\PYG{o}{:}\PYG{o}{:}\PYG{n}{getIndividualsSampled}\PYG{p}{(}\PYG{k}{const} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{x}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{y}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{x\PYGZus{}wrap}\PYG{p}{,}
                                          \PYG{k}{const} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{y\PYGZus{}wrap}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{double} \PYG{o}{\PYGZam{}}\PYG{n}{current\PYGZus{}gen}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
\PYG{c+c1}{//  if(sim\PYGZus{}parameters.uses\PYGZus{}spatial\PYGZus{}sampling)}
\PYG{c+c1}{//  \PYGZob{}}
        \PYG{k}{return} \PYG{k}{static\PYGZus{}cast}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{unsigned} \PYG{k+kt}{long}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{n}{max}\PYG{p}{(}\PYG{n}{floor}\PYG{p}{(}\PYG{n}{deme\PYGZus{}sample} \PYG{o}{*} \PYG{n}{habitat\PYGZus{}map}\PYG{p}{.}\PYG{n}{getVal}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,} \PYG{n}{y}\PYG{p}{,} \PYG{n}{x\PYGZus{}wrap}\PYG{p}{,} \PYG{n}{y\PYGZus{}wrap}\PYG{p}{,} \PYG{l+m+mf}{0.0}\PYG{p}{)}
                         \PYG{o}{*} \PYG{n}{samplegrid}\PYG{p}{.}\PYG{n}{getExactValue}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,} \PYG{n}{y}\PYG{p}{,} \PYG{n}{x\PYGZus{}wrap}\PYG{p}{,} \PYG{n}{y\PYGZus{}wrap}\PYG{p}{)}\PYG{p}{)}\PYG{p}{,} \PYG{l+m+mf}{0.0}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{c+c1}{//  \PYGZcb{}}
\PYG{c+c1}{//  else}
\PYG{c+c1}{//  \PYGZob{}}
\PYG{c+c1}{//      return static\PYGZus{}cast\PYGZlt{}unsigned long\PYGZgt{}(max(floor(deme\PYGZus{}sample * habitat\PYGZus{}map.getVal(x, y, x\PYGZus{}wrap, y\PYGZus{}wrap, 0.0)), 0.0));}
\PYG{c+c1}{//  \PYGZcb{}}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{void} \PYG{n}{SpatialTree}\PYG{o}{:}\PYG{o}{:}\PYG{n}{removeOldPosition}\PYG{p}{(}\PYG{k}{const} \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{chosen}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k+kt}{long} \PYG{n}{nwrap} \PYG{o}{=} \PYG{n}{active}\PYG{p}{[}\PYG{n}{chosen}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getNwrap}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kt}{long} \PYG{n}{oldx} \PYG{o}{=} \PYG{n}{active}\PYG{p}{[}\PYG{n}{chosen}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getXpos}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kt}{long} \PYG{n}{oldy} \PYG{o}{=} \PYG{n}{active}\PYG{p}{[}\PYG{n}{chosen}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getYpos}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
    \PYG{k}{if}\PYG{p}{(}\PYG{n}{nwrap} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifdef DEBUG}

        \PYG{k}{if}\PYG{p}{(}\PYG{n}{active}\PYG{p}{[}\PYG{n}{chosen}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getXwrap}\PYG{p}{(}\PYG{p}{)} \PYG{o}{!}\PYG{o}{=} \PYG{l+m+mi}{0} \PYG{o}{\textbar{}}\PYG{o}{\textbar{}} \PYG{n}{active}\PYG{p}{[}\PYG{n}{chosen}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getYwrap}\PYG{p}{(}\PYG{p}{)} \PYG{o}{!}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{active}\PYG{p}{[}\PYG{n}{chosen}\PYG{p}{]}\PYG{p}{.}\PYG{n}{logActive}\PYG{p}{(}\PYG{l+m+mi}{50}\PYG{p}{)}\PYG{p}{;}
            \PYG{k}{throw} \PYG{n+nf}{FatalException}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ERROR\PYGZus{}MOVE\PYGZus{}015: Nwrap not set correctly. Nwrap 0, but x and y wrap not 0. }\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif }\PYG{c+c1}{// DEBUG}
\PYG{c+c1}{// Then the lineage exists in the main list;}
\PYG{c+c1}{// debug (can be removed later)}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifdef pristine\PYGZus{}mode}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{grid}\PYG{p}{[}\PYG{n}{oldy}\PYG{p}{]}\PYG{p}{[}\PYG{n}{oldx}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getMaxsize}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZlt{}} \PYG{n}{active}\PYG{p}{[}\PYG{n}{chosen}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getListpos}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{stringstream} \PYG{n}{ss}\PYG{p}{;}
            \PYG{n}{ss} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{grid maxsize: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{grid}\PYG{p}{[}\PYG{n}{oldy}\PYG{p}{]}\PYG{p}{[}\PYG{n}{oldx}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getMaxsize}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
            \PYG{n}{writeCritical}\PYG{p}{(}\PYG{n}{ss}\PYG{p}{.}\PYG{n}{str}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
            \PYG{k}{throw} \PYG{n+nf}{FatalException}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ERROR\PYGZus{}MOVE\PYGZus{}001: Listpos outside maxsize. Check move programming function.}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif}
        \PYG{c+c1}{// delete the species from the list}
        \PYG{n}{grid}\PYG{p}{[}\PYG{n}{oldy}\PYG{p}{]}\PYG{p}{[}\PYG{n}{oldx}\PYG{p}{]}\PYG{p}{.}\PYG{n}{deleteSpecies}\PYG{p}{(}\PYG{n}{active}\PYG{p}{[}\PYG{n}{chosen}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getListpos}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
        \PYG{c+c1}{// clear out the variables.}
        \PYG{n}{active}\PYG{p}{[}\PYG{n}{chosen}\PYG{p}{]}\PYG{p}{.}\PYG{n}{setNext}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{active}\PYG{p}{[}\PYG{n}{chosen}\PYG{p}{]}\PYG{p}{.}\PYG{n}{setNwrap}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{active}\PYG{p}{[}\PYG{n}{chosen}\PYG{p}{]}\PYG{p}{.}\PYG{n}{setListPosition}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{else}  \PYG{c+c1}{// need to loop over the nwrap to check nexts}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{nwrap} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{grid}\PYG{p}{[}\PYG{n}{oldy}\PYG{p}{]}\PYG{p}{[}\PYG{n}{oldx}\PYG{p}{]}\PYG{p}{.}\PYG{n}{setNext}\PYG{p}{(}\PYG{n}{active}\PYG{p}{[}\PYG{n}{chosen}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getNext}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
            \PYG{c+c1}{// Now reduce the nwrap of the lineages that have been effected.}
            \PYG{k+kt}{long} \PYG{n}{nextpos} \PYG{o}{=} \PYG{n}{active}\PYG{p}{[}\PYG{n}{chosen}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getNext}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
            \PYG{c+c1}{// loop over the rest of the list, reducing the nwrap}
            \PYG{k}{while}\PYG{p}{(}\PYG{n}{nextpos} \PYG{o}{!}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{n}{active}\PYG{p}{[}\PYG{n}{nextpos}\PYG{p}{]}\PYG{p}{.}\PYG{n}{decreaseNwrap}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
                \PYG{n}{nextpos} \PYG{o}{=} \PYG{n}{active}\PYG{p}{[}\PYG{n}{nextpos}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getNext}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
            \PYG{c+c1}{// decrease the nwrap}
            \PYG{n}{grid}\PYG{p}{[}\PYG{n}{oldy}\PYG{p}{]}\PYG{p}{[}\PYG{n}{oldx}\PYG{p}{]}\PYG{p}{.}\PYG{n}{decreaseNwrap}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
            \PYG{n}{active}\PYG{p}{[}\PYG{n}{chosen}\PYG{p}{]}\PYG{p}{.}\PYG{n}{setNwrap}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}
            \PYG{n}{active}\PYG{p}{[}\PYG{n}{chosen}\PYG{p}{]}\PYG{p}{.}\PYG{n}{setNext}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}
            \PYG{n}{active}\PYG{p}{[}\PYG{n}{chosen}\PYG{p}{]}\PYG{p}{.}\PYG{n}{setListPosition}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}
            \PYG{n}{nwrap} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{else}
        \PYG{p}{\PYGZob{}}
            \PYG{k+kt}{long} \PYG{n}{lastpos} \PYG{o}{=} \PYG{n}{grid}\PYG{p}{[}\PYG{n}{oldy}\PYG{p}{]}\PYG{p}{[}\PYG{n}{oldx}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getNext}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
            \PYG{k}{while}\PYG{p}{(}\PYG{n}{active}\PYG{p}{[}\PYG{n}{lastpos}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getNext}\PYG{p}{(}\PYG{p}{)} \PYG{o}{!}\PYG{o}{=}
                  \PYG{n}{chosen}\PYG{p}{)}  \PYG{c+c1}{// loop until we reach the next, then set the next correctly.}
            \PYG{p}{\PYGZob{}}
                \PYG{n}{lastpos} \PYG{o}{=} \PYG{n}{active}\PYG{p}{[}\PYG{n}{lastpos}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getNext}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
            \PYG{k}{if}\PYG{p}{(}\PYG{n}{lastpos} \PYG{o}{!}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{n}{active}\PYG{p}{[}\PYG{n}{lastpos}\PYG{p}{]}\PYG{p}{.}\PYG{n}{setNext}\PYG{p}{(}\PYG{n}{active}\PYG{p}{[}\PYG{n}{chosen}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getNext}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifdef DEBUG}
                \PYG{k}{if}\PYG{p}{(}\PYG{n}{active}\PYG{p}{[}\PYG{n}{lastpos}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getNwrap}\PYG{p}{(}\PYG{p}{)} \PYG{o}{!}\PYG{o}{=} \PYG{p}{(}\PYG{n}{active}\PYG{p}{[}\PYG{n}{chosen}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getNwrap}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{)}
                \PYG{p}{\PYGZob{}}
                    \PYG{n}{writeLog}\PYG{p}{(}\PYG{l+m+mi}{50}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Logging last position: }\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
                    \PYG{n}{active}\PYG{p}{[}\PYG{n}{lastpos}\PYG{p}{]}\PYG{p}{.}\PYG{n}{logActive}\PYG{p}{(}\PYG{l+m+mi}{50}\PYG{p}{)}\PYG{p}{;}
                    \PYG{n}{writeLog}\PYG{p}{(}\PYG{l+m+mi}{50}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Logging chosen position: }\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
                    \PYG{n}{active}\PYG{p}{[}\PYG{n}{chosen}\PYG{p}{]}\PYG{p}{.}\PYG{n}{logActive}\PYG{p}{(}\PYG{l+m+mi}{50}\PYG{p}{)}\PYG{p}{;}
                    \PYG{k}{throw} \PYG{n+nf}{FatalException}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ERROR\PYGZus{}MOVE\PYGZus{}022: nwrap setting of either chosen or the }\PYG{l+s}{\PYGZdq{}}
                                          \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{lineage wrapped before chosen. Check move function.}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
                \PYG{p}{\PYGZcb{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif }\PYG{c+c1}{// DEBUG}
                \PYG{n}{lastpos} \PYG{o}{=} \PYG{n}{active}\PYG{p}{[}\PYG{n}{lastpos}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getNext}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
                \PYG{k}{while}\PYG{p}{(}\PYG{n}{lastpos} \PYG{o}{!}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)}
                \PYG{p}{\PYGZob{}}
                    \PYG{n}{active}\PYG{p}{[}\PYG{n}{lastpos}\PYG{p}{]}\PYG{p}{.}\PYG{n}{decreaseNwrap}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
                    \PYG{n}{lastpos} \PYG{o}{=} \PYG{n}{active}\PYG{p}{[}\PYG{n}{lastpos}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getNext}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
                \PYG{p}{\PYGZcb{}}

            \PYG{p}{\PYGZcb{}}
            \PYG{k}{else}
            \PYG{p}{\PYGZob{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifdef DEBUG}
                \PYG{n}{writeLog}\PYG{p}{(}\PYG{l+m+mi}{50}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Logging chosen}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
                \PYG{n}{active}\PYG{p}{[}\PYG{n}{chosen}\PYG{p}{]}\PYG{p}{.}\PYG{n}{logActive}\PYG{p}{(}\PYG{l+m+mi}{50}\PYG{p}{)}\PYG{p}{;}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif }\PYG{c+c1}{// DEBUG}
                \PYG{k}{throw} \PYG{n+nf}{FatalException}\PYG{p}{(}
                    \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ERROR\PYGZus{}MOVE\PYGZus{}024: Last position before chosen is 0 \PYGZhy{} this is impossible.}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
            \PYG{n}{grid}\PYG{p}{[}\PYG{n}{oldy}\PYG{p}{]}\PYG{p}{[}\PYG{n}{oldx}\PYG{p}{]}\PYG{p}{.}\PYG{n}{decreaseNwrap}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
            \PYG{n}{active}\PYG{p}{[}\PYG{n}{chosen}\PYG{p}{]}\PYG{p}{.}\PYG{n}{setNwrap}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}
            \PYG{n}{active}\PYG{p}{[}\PYG{n}{chosen}\PYG{p}{]}\PYG{p}{.}\PYG{n}{setNext}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}
            \PYG{n}{active}\PYG{p}{[}\PYG{n}{chosen}\PYG{p}{]}\PYG{p}{.}\PYG{n}{setListPosition}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}
            \PYG{n}{nwrap} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}

        \PYG{p}{\PYGZcb{}}
        \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{iCount} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;}
        \PYG{k+kt}{long} \PYG{n}{pos} \PYG{o}{=} \PYG{n}{grid}\PYG{p}{[}\PYG{n}{oldy}\PYG{p}{]}\PYG{p}{[}\PYG{n}{oldx}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getNext}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{pos} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{iCount} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{else}
        \PYG{p}{\PYGZob{}}
            \PYG{k+kt}{int} \PYG{n}{c} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
            \PYG{k}{while}\PYG{p}{(}\PYG{n}{active}\PYG{p}{[}\PYG{n}{pos}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getNext}\PYG{p}{(}\PYG{p}{)} \PYG{o}{!}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{n}{c}\PYG{o}{+}\PYG{o}{+}\PYG{p}{;}
                \PYG{n}{iCount}\PYG{o}{+}\PYG{o}{+}\PYG{p}{;}
                \PYG{n}{pos} \PYG{o}{=} \PYG{n}{active}\PYG{p}{[}\PYG{n}{pos}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getNext}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
                \PYG{k}{if}\PYG{p}{(}\PYG{n}{c} \PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{10000}\PYG{p}{)}
                \PYG{p}{\PYGZob{}}
                    \PYG{c+c1}{//                  os \PYGZlt{}\PYGZlt{} pos \PYGZlt{}\PYGZlt{} endl;}
                    \PYG{c+c1}{//                  os \PYGZlt{}\PYGZlt{} active[pos].getNext() \PYGZlt{}\PYGZlt{} endl;}
                    \PYG{k}{break}\PYG{p}{;}
                \PYG{p}{\PYGZcb{}}
            \PYG{p}{\PYGZcb{}}
        \PYG{p}{\PYGZcb{}}

        \PYG{k}{if}\PYG{p}{(}\PYG{n}{iCount} \PYG{o}{!}\PYG{o}{=} \PYG{n}{grid}\PYG{p}{[}\PYG{n}{oldy}\PYG{p}{]}\PYG{p}{[}\PYG{n}{oldx}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getNwrap}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifdef DEBUG}
            \PYG{n}{stringstream} \PYG{n}{ss}\PYG{p}{;}
            \PYG{n}{ss} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Nwrap: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{grid}\PYG{p}{[}\PYG{n}{oldy}\PYG{p}{]}\PYG{p}{[}\PYG{n}{oldx}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getNwrap}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ Counted lineages: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{iCount} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
            \PYG{n}{writeLog}\PYG{p}{(}\PYG{l+m+mi}{50}\PYG{p}{,} \PYG{n}{ss}\PYG{p}{)}\PYG{p}{;}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif }\PYG{c+c1}{// DEBUG}
            \PYG{k}{throw} \PYG{n+nf}{FatalException}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ERROR\PYGZus{}MOVE\PYGZus{}014: Nwrap not set correctly after move for grid cell}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
    \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{void} \PYG{n}{SpatialTree}\PYG{o}{:}\PYG{o}{:}\PYG{n}{calcMove}\PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{n}{dispersal\PYGZus{}coordinator}\PYG{p}{.}\PYG{n}{disperse}\PYG{p}{(}\PYG{n}{this\PYGZus{}step}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}


\PYG{k+kt}{long} \PYG{k+kt}{double} \PYG{n}{SpatialTree}\PYG{o}{:}\PYG{o}{:}\PYG{n}{calcMinMax}\PYG{p}{(}\PYG{k}{const} \PYG{k+kt}{unsigned} \PYG{k+kt}{long}\PYG{o}{\PYGZam{}} \PYG{n}{current}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{c+c1}{// this formula calculates the speciation rate required for speciation to have occured on this branch.}
    \PYG{c+c1}{// need to allow for the case that the number of gens was 0}
    \PYG{k+kt}{long} \PYG{k+kt}{double} \PYG{n}{newminmax} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;}
    \PYG{k+kt}{long} \PYG{k+kt}{double} \PYG{n}{oldminmax} \PYG{o}{=} \PYG{n}{active}\PYG{p}{[}\PYG{n}{current}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getMinmax}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
    \PYG{k}{if}\PYG{p}{(}\PYG{n}{data}\PYG{p}{[}\PYG{n}{active}\PYG{p}{[}\PYG{n}{current}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getReference}\PYG{p}{(}\PYG{p}{)}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getGenRate}\PYG{p}{(}\PYG{p}{)} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{newminmax} \PYG{o}{=} \PYG{n}{data}\PYG{p}{[}\PYG{n}{active}\PYG{p}{[}\PYG{n}{current}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getReference}\PYG{p}{(}\PYG{p}{)}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getSpecRate}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{else}
    \PYG{p}{\PYGZob{}}
        \PYG{c+c1}{// variables need to be defined separately for the decimal division to function properly.}
        \PYG{k+kt}{long} \PYG{k+kt}{double} \PYG{n}{tmpdSpec} \PYG{o}{=} \PYG{n}{data}\PYG{p}{[}\PYG{n}{active}\PYG{p}{[}\PYG{n}{current}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getReference}\PYG{p}{(}\PYG{p}{)}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getSpecRate}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
        \PYG{k+kt}{long} \PYG{k+kt}{double} \PYG{n}{tmpiGen} \PYG{o}{=} \PYG{n}{data}\PYG{p}{[}\PYG{n}{active}\PYG{p}{[}\PYG{n}{current}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getReference}\PYG{p}{(}\PYG{p}{)}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getGenRate}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{newminmax} \PYG{o}{=} \PYG{l+m+mi}{1} \PYG{o}{\PYGZhy{}} \PYG{p}{(}\PYG{n}{pow}\PYG{p}{(}\PYG{l+m+mi}{1} \PYG{o}{\PYGZhy{}} \PYG{n}{tmpdSpec}\PYG{p}{,} \PYG{p}{(}\PYG{l+m+mi}{1} \PYG{o}{/} \PYG{n}{tmpiGen}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{k+kt}{long} \PYG{k+kt}{double} \PYG{n}{toret} \PYG{o}{=} \PYG{n}{min}\PYG{p}{(}\PYG{n}{newminmax}\PYG{p}{,} \PYG{n}{oldminmax}\PYG{p}{)}\PYG{p}{;}
    \PYG{k}{return} \PYG{n}{toret}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}



\PYG{k+kt}{void} \PYG{n}{SpatialTree}\PYG{o}{:}\PYG{o}{:}\PYG{n}{calcNewPos}\PYG{p}{(}\PYG{k+kt}{bool}\PYG{o}{\PYGZam{}} \PYG{n}{coal}\PYG{p}{,}
                      \PYG{k}{const} \PYG{k+kt}{unsigned} \PYG{k+kt}{long}\PYG{o}{\PYGZam{}} \PYG{n}{chosen}\PYG{p}{,}
                      \PYG{k+kt}{unsigned} \PYG{k+kt}{long}\PYG{o}{\PYGZam{}} \PYG{n}{coalchosen}\PYG{p}{,}
                      \PYG{k}{const} \PYG{k+kt}{long}\PYG{o}{\PYGZam{}} \PYG{n}{oldx}\PYG{p}{,}
                      \PYG{k}{const} \PYG{k+kt}{long}\PYG{o}{\PYGZam{}} \PYG{n}{oldy}\PYG{p}{,}
                      \PYG{k}{const} \PYG{k+kt}{long}\PYG{o}{\PYGZam{}} \PYG{n}{oldxwrap}\PYG{p}{,}
                      \PYG{k}{const} \PYG{k+kt}{long}\PYG{o}{\PYGZam{}} \PYG{n}{oldywrap}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{c+c1}{// Calculate the new position of the move, whilst also calculating the probability of coalescence.}
    \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{nwrap} \PYG{o}{=} \PYG{n}{active}\PYG{p}{[}\PYG{n}{chosen}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getNwrap}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
    \PYG{k}{if}\PYG{p}{(}\PYG{n}{oldxwrap} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{0} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{n}{oldywrap} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{c+c1}{// Debug check (to remove later)}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{nwrap} \PYG{o}{!}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{k}{throw} \PYG{n}{FatalException}\PYG{p}{(}
                \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ERROR\PYGZus{}MOVE\PYGZus{}006: NON FATAL. Nwrap not set correctly. Check move programming function.}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{c+c1}{// then the procedure is relatively simple.}
        \PYG{c+c1}{// check for coalescence}
        \PYG{c+c1}{// check if the grid needs to be updated.}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{grid}\PYG{p}{[}\PYG{n}{oldy}\PYG{p}{]}\PYG{p}{[}\PYG{n}{oldx}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getMaxsize}\PYG{p}{(}\PYG{p}{)} \PYG{o}{!}\PYG{o}{=} \PYG{n}{habitat\PYGZus{}map}\PYG{p}{.}\PYG{n}{getVal}\PYG{p}{(}\PYG{n}{oldx}\PYG{p}{,} \PYG{n}{oldy}\PYG{p}{,} \PYG{n}{oldxwrap}\PYG{p}{,} \PYG{n}{oldywrap}\PYG{p}{,} \PYG{n}{generation}\PYG{p}{)}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{grid}\PYG{p}{[}\PYG{n}{oldy}\PYG{p}{]}\PYG{p}{[}\PYG{n}{oldx}\PYG{p}{]}\PYG{p}{.}\PYG{n}{setMaxsize}\PYG{p}{(}\PYG{n}{habitat\PYGZus{}map}\PYG{p}{.}\PYG{n}{getVal}\PYG{p}{(}\PYG{n}{oldx}\PYG{p}{,} \PYG{n}{oldy}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{generation}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{n}{coalchosen} \PYG{o}{=} \PYG{n}{grid}\PYG{p}{[}\PYG{n}{oldy}\PYG{p}{]}\PYG{p}{[}\PYG{n}{oldx}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getRandLineage}\PYG{p}{(}\PYG{n}{NR}\PYG{p}{)}\PYG{p}{;}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifdef DEBUG}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{coalchosen} \PYG{o}{!}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{k}{if}\PYG{p}{(}\PYG{n}{active}\PYG{p}{[}\PYG{n}{coalchosen}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getXpos}\PYG{p}{(}\PYG{p}{)} \PYG{o}{!}\PYG{o}{=} \PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{long}\PYG{p}{)}\PYG{n}{oldx} \PYG{o}{\textbar{}}\PYG{o}{\textbar{}}
               \PYG{n}{active}\PYG{p}{[}\PYG{n}{coalchosen}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getYpos}\PYG{p}{(}\PYG{p}{)} \PYG{o}{!}\PYG{o}{=} \PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{long}\PYG{p}{)}\PYG{n}{oldy} \PYG{o}{\textbar{}}\PYG{o}{\textbar{}}
               \PYG{n}{active}\PYG{p}{[}\PYG{n}{coalchosen}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getXwrap}\PYG{p}{(}\PYG{p}{)} \PYG{o}{!}\PYG{o}{=} \PYG{n}{oldxwrap} \PYG{o}{\textbar{}}\PYG{o}{\textbar{}} \PYG{n}{active}\PYG{p}{[}\PYG{n}{coalchosen}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getYwrap}\PYG{p}{(}\PYG{p}{)} \PYG{o}{!}\PYG{o}{=} \PYG{n}{oldywrap}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{n}{writeLog}\PYG{p}{(}\PYG{l+m+mi}{50}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Logging chosen:}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
                \PYG{n}{active}\PYG{p}{[}\PYG{n}{chosen}\PYG{p}{]}\PYG{p}{.}\PYG{n}{logActive}\PYG{p}{(}\PYG{l+m+mi}{50}\PYG{p}{)}\PYG{p}{;}
                \PYG{n}{writeLog}\PYG{p}{(}\PYG{l+m+mi}{50}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Logging coalchosen: }\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
                \PYG{n}{active}\PYG{p}{[}\PYG{n}{coalchosen}\PYG{p}{]}\PYG{p}{.}\PYG{n}{logActive}\PYG{p}{(}\PYG{l+m+mi}{50}\PYG{p}{)}\PYG{p}{;}
                \PYG{k}{throw} \PYG{n+nf}{FatalException}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ERROR\PYGZus{}MOVE\PYGZus{}006: NON FATAL. Nwrap not set correctly. Please report this bug.}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
        \PYG{p}{\PYGZcb{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{coalchosen} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)}  \PYG{c+c1}{// then the lineage can be placed in the empty space.}
        \PYG{p}{\PYGZob{}}
            \PYG{k+kt}{long} \PYG{n}{tmplistindex} \PYG{o}{=} \PYG{n}{grid}\PYG{p}{[}\PYG{n}{oldy}\PYG{p}{]}\PYG{p}{[}\PYG{n}{oldx}\PYG{p}{]}\PYG{p}{.}\PYG{n}{addSpecies}\PYG{p}{(}\PYG{n}{chosen}\PYG{p}{)}\PYG{p}{;}
            \PYG{c+c1}{// check}
            \PYG{k}{if}\PYG{p}{(}\PYG{n}{grid}\PYG{p}{[}\PYG{n}{oldy}\PYG{p}{]}\PYG{p}{[}\PYG{n}{oldx}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getSpecies}\PYG{p}{(}\PYG{n}{tmplistindex}\PYG{p}{)} \PYG{o}{!}\PYG{o}{=} \PYG{n}{chosen}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{k}{throw} \PYG{n}{FatalException}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ERROR\PYGZus{}MOVE\PYGZus{}005: Grid index not set correctly for species. Check }\PYG{l+s}{\PYGZdq{}}
                                      \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{move programming function.}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifdef pristine\PYGZus{}mode}
            \PYG{k}{if}\PYG{p}{(}\PYG{n}{grid}\PYG{p}{[}\PYG{n}{oldy}\PYG{p}{]}\PYG{p}{[}\PYG{n}{oldx}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getListsize}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZgt{}} \PYG{n}{grid}\PYG{p}{[}\PYG{n}{oldy}\PYG{p}{]}\PYG{p}{[}\PYG{n}{oldx}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getMaxsize}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{k}{throw} \PYG{n}{FatalException}\PYG{p}{(}
                    \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ERROR\PYGZus{}MOVE\PYGZus{}001: Listpos outside maxsize. Check move programming function.}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif}
            \PYG{n}{active}\PYG{p}{[}\PYG{n}{chosen}\PYG{p}{]}\PYG{p}{.}\PYG{n}{setNwrap}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}
            \PYG{n}{active}\PYG{p}{[}\PYG{n}{chosen}\PYG{p}{]}\PYG{p}{.}\PYG{n}{setListPosition}\PYG{p}{(}\PYG{n}{tmplistindex}\PYG{p}{)}\PYG{p}{;}
            \PYG{n}{coal} \PYG{o}{=} \PYG{n+nb}{false}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{else}  \PYG{c+c1}{// then coalescence has occured}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{active}\PYG{p}{[}\PYG{n}{chosen}\PYG{p}{]}\PYG{p}{.}\PYG{n}{setNwrap}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}
            \PYG{n}{active}\PYG{p}{[}\PYG{n}{chosen}\PYG{p}{]}\PYG{p}{.}\PYG{n}{setListPosition}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}
            \PYG{c+c1}{// DO THE COALESCENCE STUFF}
            \PYG{n}{coal} \PYG{o}{=} \PYG{n+nb}{true}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{else}  \PYG{c+c1}{// need to check all the possible places the lineage could be.}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{nwrap} \PYG{o}{!}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{k}{throw} \PYG{n}{FatalException}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ERROR\PYGZus{}MOVE\PYGZus{}022: Nwrap not set correctly in move.}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{n}{nwrap} \PYG{o}{=} \PYG{n}{grid}\PYG{p}{[}\PYG{n}{oldy}\PYG{p}{]}\PYG{p}{[}\PYG{n}{oldx}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getNwrap}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{nwrap} \PYG{o}{!}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)}  \PYG{c+c1}{// then coalescence is possible and we need to loop over the nexts to check those that are}
        \PYG{c+c1}{// in the same position}
        \PYG{p}{\PYGZob{}}
            \PYG{c+c1}{// Count the possible matches of the position.}
            \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{matches} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
            \PYG{c+c1}{// Create an array containing the list of active references for those that match as}
            \PYG{c+c1}{// this stops us having to loop twice over the same list.}
            \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{matchlist}\PYG{p}{[}\PYG{n}{nwrap}\PYG{p}{]}\PYG{p}{;}
            \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{next\PYGZus{}active}\PYG{p}{;}
            \PYG{n}{next\PYGZus{}active} \PYG{o}{=} \PYG{n}{grid}\PYG{p}{[}\PYG{n}{oldy}\PYG{p}{]}\PYG{p}{[}\PYG{n}{oldx}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getNext}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
            \PYG{c+c1}{// Count if the first \PYGZdq{}next\PYGZdq{} matches}
            \PYG{k}{if}\PYG{p}{(}\PYG{n}{active}\PYG{p}{[}\PYG{n}{next\PYGZus{}active}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getXwrap}\PYG{p}{(}\PYG{p}{)} \PYG{o}{=}\PYG{o}{=} \PYG{n}{oldxwrap} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{n}{active}\PYG{p}{[}\PYG{n}{next\PYGZus{}active}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getYwrap}\PYG{p}{(}\PYG{p}{)} \PYG{o}{=}\PYG{o}{=} \PYG{n}{oldywrap}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifdef DEBUG}
                \PYG{k}{if}\PYG{p}{(}\PYG{n}{active}\PYG{p}{[}\PYG{n}{next\PYGZus{}active}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getNwrap}\PYG{p}{(}\PYG{p}{)} \PYG{o}{!}\PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{)}
                \PYG{p}{\PYGZob{}}
                    \PYG{k}{throw} \PYG{n}{FatalException}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ERROR\PYGZus{}MOVE\PYGZus{}022a: Nwrap not set correctly in move.}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
                \PYG{p}{\PYGZcb{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif}
                \PYG{n}{matchlist}\PYG{p}{[}\PYG{n}{matches}\PYG{p}{]} \PYG{o}{=} \PYG{n}{next\PYGZus{}active}\PYG{p}{;}  \PYG{c+c1}{// add the match to the list of matches.}
                \PYG{n}{matches}\PYG{o}{+}\PYG{o}{+}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
            \PYG{c+c1}{// Now loop over the remaining nexts counting matches}
            \PYG{c+c1}{//\PYGZsh{}ifdef DEBUG}
            \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{ncount} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;}
            \PYG{c+c1}{//\PYGZsh{}endif}
            \PYG{k}{while}\PYG{p}{(}\PYG{n}{active}\PYG{p}{[}\PYG{n}{next\PYGZus{}active}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getNext}\PYG{p}{(}\PYG{p}{)} \PYG{o}{!}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{n}{next\PYGZus{}active} \PYG{o}{=} \PYG{n}{active}\PYG{p}{[}\PYG{n}{next\PYGZus{}active}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getNext}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
                \PYG{k}{if}\PYG{p}{(}\PYG{n}{active}\PYG{p}{[}\PYG{n}{next\PYGZus{}active}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getXwrap}\PYG{p}{(}\PYG{p}{)} \PYG{o}{=}\PYG{o}{=} \PYG{n}{oldxwrap} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{n}{active}\PYG{p}{[}\PYG{n}{next\PYGZus{}active}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getYwrap}\PYG{p}{(}\PYG{p}{)} \PYG{o}{=}\PYG{o}{=} \PYG{n}{oldywrap}\PYG{p}{)}
                \PYG{p}{\PYGZob{}}
                    \PYG{n}{matchlist}\PYG{p}{[}\PYG{n}{matches}\PYG{p}{]} \PYG{o}{=} \PYG{n}{next\PYGZus{}active}\PYG{p}{;}
                    \PYG{n}{matches}\PYG{o}{+}\PYG{o}{+}\PYG{p}{;}
                \PYG{p}{\PYGZcb{}}
                \PYG{c+c1}{// check}
                \PYG{c+c1}{//\PYGZsh{}ifdef DEBUG}
                \PYG{n}{ncount}\PYG{o}{+}\PYG{o}{+}\PYG{p}{;}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifdef DEBUG}
                \PYG{k}{if}\PYG{p}{(}\PYG{n}{active}\PYG{p}{[}\PYG{n}{next\PYGZus{}active}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getNwrap}\PYG{p}{(}\PYG{p}{)} \PYG{o}{!}\PYG{o}{=} \PYG{n}{ncount}\PYG{p}{)}
                \PYG{p}{\PYGZob{}}
                    \PYG{k}{throw} \PYG{n}{FatalException}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ERROR\PYGZus{}MOVE\PYGZus{}022d: Nwrap not set correctly in move.}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
                \PYG{p}{\PYGZcb{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif}
            \PYG{p}{\PYGZcb{}}
            \PYG{k}{if}\PYG{p}{(}\PYG{n}{nwrap} \PYG{o}{!}\PYG{o}{=} \PYG{n}{ncount}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{k}{throw} \PYG{n}{FatalException}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ERROR\PYGZus{}MOVE\PYGZus{}022c: Nwrap not set correctly in move.}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
            \PYG{c+c1}{// Matches now contains the number of lineages at the exact x,y, xwrap and ywrap position.}
            \PYG{c+c1}{// Check if there were no matches at all}
            \PYG{k}{if}\PYG{p}{(}\PYG{n}{matches} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{n}{coalchosen} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
                \PYG{n}{coal} \PYG{o}{=} \PYG{n+nb}{false}\PYG{p}{;}
                \PYG{n}{active}\PYG{p}{[}\PYG{n}{next\PYGZus{}active}\PYG{p}{]}\PYG{p}{.}\PYG{n}{setNext}\PYG{p}{(}\PYG{n}{chosen}\PYG{p}{)}\PYG{p}{;}
                \PYG{n}{grid}\PYG{p}{[}\PYG{n}{oldy}\PYG{p}{]}\PYG{p}{[}\PYG{n}{oldx}\PYG{p}{]}\PYG{p}{.}\PYG{n}{increaseNwrap}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
                \PYG{n}{active}\PYG{p}{[}\PYG{n}{chosen}\PYG{p}{]}\PYG{p}{.}\PYG{n}{setNwrap}\PYG{p}{(}\PYG{n}{grid}\PYG{p}{[}\PYG{n}{oldy}\PYG{p}{]}\PYG{p}{[}\PYG{n}{oldx}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getNwrap}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
                \PYG{n}{active}\PYG{p}{[}\PYG{n}{chosen}\PYG{p}{]}\PYG{p}{.}\PYG{n}{setListPosition}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
            \PYG{k}{else}  \PYG{c+c1}{// if there were matches, generate a random number to see if coalescence occured or not}
            \PYG{p}{\PYGZob{}}
                \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{randwrap} \PYG{o}{=}
                    \PYG{n}{floor}\PYG{p}{(}\PYG{n}{NR}\PYG{p}{.}\PYG{n}{d01}\PYG{p}{(}\PYG{p}{)} \PYG{o}{*} \PYG{p}{(}\PYG{n}{habitat\PYGZus{}map}\PYG{p}{.}\PYG{n}{getVal}\PYG{p}{(}\PYG{n}{oldx}\PYG{p}{,} \PYG{n}{oldy}\PYG{p}{,} \PYG{n}{oldxwrap}\PYG{p}{,} \PYG{n}{oldywrap}\PYG{p}{,} \PYG{n}{generation}\PYG{p}{)}\PYG{p}{)} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
\PYG{c+c1}{// Get the random reference from the match list.}
\PYG{c+c1}{// If the movement is to an empty space, then we can update the chain to include the new}
\PYG{c+c1}{// lineage.}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifdef pristine\PYGZus{}mode}
                \PYG{k}{if}\PYG{p}{(}\PYG{n}{randwrap} \PYG{o}{\PYGZgt{}} \PYG{n}{habitat\PYGZus{}map}\PYG{p}{.}\PYG{n}{getVal}\PYG{p}{(}\PYG{n}{oldx}\PYG{p}{,} \PYG{n}{oldy}\PYG{p}{,} \PYG{n}{oldxwrap}\PYG{p}{,} \PYG{n}{oldywrap}\PYG{p}{,} \PYG{n}{generation}\PYG{p}{)}\PYG{p}{)}
                \PYG{p}{\PYGZob{}}
                    \PYG{k}{throw} \PYG{n}{FatalException}\PYG{p}{(}
                        \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ERROR\PYGZus{}MOVE\PYGZus{}004: Randpos outside maxsize. Check move programming function}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
                \PYG{p}{\PYGZcb{}}
                \PYG{k}{if}\PYG{p}{(}\PYG{n}{matches} \PYG{o}{\PYGZgt{}} \PYG{n}{habitat\PYGZus{}map}\PYG{p}{.}\PYG{n}{getVal}\PYG{p}{(}\PYG{n}{oldx}\PYG{p}{,} \PYG{n}{oldy}\PYG{p}{,} \PYG{n}{oldxwrap}\PYG{p}{,} \PYG{n}{oldywrap}\PYG{p}{,} \PYG{n}{generation}\PYG{p}{)}\PYG{p}{)}
                \PYG{p}{\PYGZob{}}
                    \PYG{n}{cerr} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{matches: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{matches} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}
                         \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{habitat\PYGZus{}map value: }\PYG{l+s}{\PYGZdq{}}
                         \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{habitat\PYGZus{}map}\PYG{p}{.}\PYG{n}{getVal}\PYG{p}{(}\PYG{n}{oldx}\PYG{p}{,} \PYG{n}{oldy}\PYG{p}{,} \PYG{n}{oldxwrap}\PYG{p}{,} \PYG{n}{oldywrap}\PYG{p}{,} \PYG{n}{generation}\PYG{p}{)}\PYG{p}{;}
                    \PYG{k}{throw} \PYG{n+nf}{FatalException}\PYG{p}{(}
                        \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ERROR\PYGZus{}MOVE\PYGZus{}004: matches outside maxsize. Check move programming function}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
                \PYG{p}{\PYGZcb{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif}
                \PYG{k}{if}\PYG{p}{(}\PYG{n}{randwrap} \PYG{o}{\PYGZgt{}} \PYG{n}{matches}\PYG{p}{)}  \PYG{c+c1}{// coalescence has not occured}
                \PYG{p}{\PYGZob{}}
                    \PYG{c+c1}{// os \PYGZlt{}\PYGZlt{} \PYGZdq{}This shouldn\PYGZsq{}t happen\PYGZdq{} \PYGZlt{}\PYGZlt{} endl;}
                    \PYG{n}{coalchosen} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
                    \PYG{n}{coal} \PYG{o}{=} \PYG{n+nb}{false}\PYG{p}{;}
                    \PYG{n}{active}\PYG{p}{[}\PYG{n}{next\PYGZus{}active}\PYG{p}{]}\PYG{p}{.}\PYG{n}{setNext}\PYG{p}{(}\PYG{n}{chosen}\PYG{p}{)}\PYG{p}{;}
                    \PYG{n}{grid}\PYG{p}{[}\PYG{n}{oldy}\PYG{p}{]}\PYG{p}{[}\PYG{n}{oldx}\PYG{p}{]}\PYG{p}{.}\PYG{n}{increaseNwrap}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
                    \PYG{n}{active}\PYG{p}{[}\PYG{n}{chosen}\PYG{p}{]}\PYG{p}{.}\PYG{n}{setNwrap}\PYG{p}{(}\PYG{n}{grid}\PYG{p}{[}\PYG{n}{oldy}\PYG{p}{]}\PYG{p}{[}\PYG{n}{oldx}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getNwrap}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
                    \PYG{n}{active}\PYG{p}{[}\PYG{n}{chosen}\PYG{p}{]}\PYG{p}{.}\PYG{n}{setListPosition}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}
                \PYG{p}{\PYGZcb{}}
                \PYG{k}{else}  \PYG{c+c1}{// coalescence has occured}
                \PYG{p}{\PYGZob{}}
                    \PYG{n}{coal} \PYG{o}{=} \PYG{n+nb}{true}\PYG{p}{;}
                    \PYG{n}{coalchosen} \PYG{o}{=} \PYG{n}{matchlist}\PYG{p}{[}\PYG{n}{randwrap} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{;}
                    \PYG{n}{active}\PYG{p}{[}\PYG{n}{chosen}\PYG{p}{]}\PYG{p}{.}\PYG{n}{setEndpoint}\PYG{p}{(}\PYG{n}{oldx}\PYG{p}{,} \PYG{n}{oldy}\PYG{p}{,} \PYG{n}{oldxwrap}\PYG{p}{,} \PYG{n}{oldywrap}\PYG{p}{)}\PYG{p}{;}
                    \PYG{k}{if}\PYG{p}{(}\PYG{n}{coalchosen} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)}
                    \PYG{p}{\PYGZob{}}
                        \PYG{k}{throw} \PYG{n}{FatalException}\PYG{p}{(}
                            \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ERROR\PYGZus{}MOVE\PYGZus{}025: Coalescence attempted with lineage of 0.}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
                    \PYG{p}{\PYGZcb{}}
                \PYG{p}{\PYGZcb{}}
            \PYG{p}{\PYGZcb{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifdef pristine\PYGZus{}mode}
            \PYG{k}{if}\PYG{p}{(}\PYG{n}{grid}\PYG{p}{[}\PYG{n}{oldy}\PYG{p}{]}\PYG{p}{[}\PYG{n}{oldx}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getMaxsize}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZlt{}} \PYG{n}{active}\PYG{p}{[}\PYG{n}{chosen}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getListpos}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{k}{throw} \PYG{n}{FatalException}\PYG{p}{(}
                    \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ERROR\PYGZus{}MOVE\PYGZus{}001: Listpos outside maxsize. Check move programming function.}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{else}  \PYG{c+c1}{// just add the lineage to next.}
        \PYG{p}{\PYGZob{}}
            \PYG{k}{if}\PYG{p}{(}\PYG{n}{grid}\PYG{p}{[}\PYG{n}{oldy}\PYG{p}{]}\PYG{p}{[}\PYG{n}{oldx}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getNext}\PYG{p}{(}\PYG{p}{)} \PYG{o}{!}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{k}{throw} \PYG{n}{FatalException}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ERROR\PYGZus{}MOVE\PYGZus{}026: No nwrap recorded, but next is non\PYGZhy{}zero.}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
            \PYG{n}{coalchosen} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
            \PYG{n}{coal} \PYG{o}{=} \PYG{n+nb}{false}\PYG{p}{;}
            \PYG{n}{grid}\PYG{p}{[}\PYG{n}{oldy}\PYG{p}{]}\PYG{p}{[}\PYG{n}{oldx}\PYG{p}{]}\PYG{p}{.}\PYG{n}{setNext}\PYG{p}{(}\PYG{n}{chosen}\PYG{p}{)}\PYG{p}{;}
            \PYG{n}{active}\PYG{p}{[}\PYG{n}{chosen}\PYG{p}{]}\PYG{p}{.}\PYG{n}{setNwrap}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
            \PYG{n}{active}\PYG{p}{[}\PYG{n}{chosen}\PYG{p}{]}\PYG{p}{.}\PYG{n}{setNext}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}
            \PYG{n}{grid}\PYG{p}{[}\PYG{n}{oldy}\PYG{p}{]}\PYG{p}{[}\PYG{n}{oldx}\PYG{p}{]}\PYG{p}{.}\PYG{n}{increaseNwrap}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{c+c1}{// check}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifdef DEBUG}
            \PYG{k}{if}\PYG{p}{(}\PYG{n}{grid}\PYG{p}{[}\PYG{n}{oldy}\PYG{p}{]}\PYG{p}{[}\PYG{n}{oldx}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getNwrap}\PYG{p}{(}\PYG{p}{)} \PYG{o}{!}\PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{k}{throw} \PYG{n}{FatalException}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ERROR\PYGZus{}MOVE\PYGZus{}022b: Nwrap not set correctly in move.}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{coalchosen} \PYG{o}{!}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{k}{if}\PYG{p}{(}\PYG{n}{active}\PYG{p}{[}\PYG{n}{coalchosen}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getXpos}\PYG{p}{(}\PYG{p}{)} \PYG{o}{!}\PYG{o}{=} \PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{long}\PYG{p}{)}\PYG{n}{oldx} \PYG{o}{\textbar{}}\PYG{o}{\textbar{}}
               \PYG{n}{active}\PYG{p}{[}\PYG{n}{coalchosen}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getYpos}\PYG{p}{(}\PYG{p}{)} \PYG{o}{!}\PYG{o}{=} \PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{long}\PYG{p}{)}\PYG{n}{oldy} \PYG{o}{\textbar{}}\PYG{o}{\textbar{}}
               \PYG{n}{active}\PYG{p}{[}\PYG{n}{coalchosen}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getXwrap}\PYG{p}{(}\PYG{p}{)} \PYG{o}{!}\PYG{o}{=} \PYG{n}{oldxwrap} \PYG{o}{\textbar{}}\PYG{o}{\textbar{}} \PYG{n}{active}\PYG{p}{[}\PYG{n}{coalchosen}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getYwrap}\PYG{p}{(}\PYG{p}{)} \PYG{o}{!}\PYG{o}{=} \PYG{n}{oldywrap}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifdef DEBUG}
                \PYG{n}{writeLog}\PYG{p}{(}\PYG{l+m+mi}{50}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Logging chosen:}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
                \PYG{n}{active}\PYG{p}{[}\PYG{n}{chosen}\PYG{p}{]}\PYG{p}{.}\PYG{n}{logActive}\PYG{p}{(}\PYG{l+m+mi}{50}\PYG{p}{)}\PYG{p}{;}
                \PYG{n}{writeLog}\PYG{p}{(}\PYG{l+m+mi}{50}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Logging coalchosen: }\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
                \PYG{n}{active}\PYG{p}{[}\PYG{n}{coalchosen}\PYG{p}{]}\PYG{p}{.}\PYG{n}{logActive}\PYG{p}{(}\PYG{l+m+mi}{50}\PYG{p}{)}\PYG{p}{;}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif }\PYG{c+c1}{// DEBUG}
                \PYG{k}{throw} \PYG{n+nf}{FatalException}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ERROR\PYGZus{}MOVE\PYGZus{}006b: NON FATAL. Nwrap not set correctly. Check move }\PYG{l+s}{\PYGZdq{}}
                                      \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{programming function.}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
        \PYG{p}{\PYGZcb{}}
        \PYG{c+c1}{//\PYGZsh{}endif}
    \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{void} \PYG{n}{SpatialTree}\PYG{o}{:}\PYG{o}{:}\PYG{n}{switchPositions}\PYG{p}{(}\PYG{k}{const} \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{chosen}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifdef DEBUG}
    \PYG{k}{if}\PYG{p}{(}\PYG{n}{chosen} \PYG{o}{\PYGZgt{}} \PYG{n}{endactive}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{stringstream} \PYG{n}{ss}\PYG{p}{;}
        \PYG{n}{ss} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{chosen: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{chosen} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ endactive: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endactive} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
        \PYG{n}{writeLog}\PYG{p}{(}\PYG{l+m+mi}{50}\PYG{p}{,} \PYG{n}{ss}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{throw} \PYG{n+nf}{FatalException}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ERROR\PYGZus{}MOVE\PYGZus{}023: Chosen is greater than endactive. Check move function.}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif }\PYG{c+c1}{// DEBUG}
    \PYG{k}{if}\PYG{p}{(}\PYG{n}{chosen} \PYG{o}{!}\PYG{o}{=} \PYG{n}{endactive}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{c+c1}{// This routine assumes that the previous chosen position has already been deleted.}
        \PYG{n}{DataPoint} \PYG{n}{tmpdatactive}\PYG{p}{;}
        \PYG{n}{tmpdatactive}\PYG{p}{.}\PYG{n}{setup}\PYG{p}{(}\PYG{n}{active}\PYG{p}{[}\PYG{n}{chosen}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
        \PYG{c+c1}{// now need to remove the chosen lineage from memory, by replacing it with the lineage that lies in the last}
        \PYG{c+c1}{// place.}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{active}\PYG{p}{[}\PYG{n}{endactive}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getXwrap}\PYG{p}{(}\PYG{p}{)} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{0} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}}
           \PYG{n}{active}\PYG{p}{[}\PYG{n}{endactive}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getYwrap}\PYG{p}{(}\PYG{p}{)} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)}  \PYG{c+c1}{// if the end lineage is simple, we can just copy it across.}
        \PYG{p}{\PYGZob{}}
            \PYG{c+c1}{// check endactive}
            \PYG{k}{if}\PYG{p}{(}\PYG{n}{active}\PYG{p}{[}\PYG{n}{endactive}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getNwrap}\PYG{p}{(}\PYG{p}{)} \PYG{o}{!}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{n}{cerr} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ERROR\PYGZus{}MOVE\PYGZus{}020: NON FATAL. Nwrap is not set correctly for endactive (nwrap should }\PYG{l+s}{\PYGZdq{}}
                        \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{be 0, but is }\PYG{l+s}{\PYGZdq{}}
                     \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{active}\PYG{p}{[}\PYG{n}{endactive}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getNwrap}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ ). Identified during switch of positions.}\PYG{l+s}{\PYGZdq{}}
                     \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
            \PYG{n}{grid}\PYG{p}{[}\PYG{n}{active}\PYG{p}{[}\PYG{n}{endactive}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getYpos}\PYG{p}{(}\PYG{p}{)}\PYG{p}{]}\PYG{p}{[}\PYG{n}{active}\PYG{p}{[}\PYG{n}{endactive}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getXpos}\PYG{p}{(}\PYG{p}{)}\PYG{p}{]}\PYG{p}{.}\PYG{n}{setSpecies}\PYG{p}{(}
                \PYG{n}{active}\PYG{p}{[}\PYG{n}{endactive}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getListpos}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{n}{chosen}\PYG{p}{)}\PYG{p}{;}
            \PYG{n}{active}\PYG{p}{[}\PYG{n}{chosen}\PYG{p}{]}\PYG{p}{.}\PYG{n}{setup}\PYG{p}{(}\PYG{n}{active}\PYG{p}{[}\PYG{n}{endactive}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
            \PYG{n}{active}\PYG{p}{[}\PYG{n}{endactive}\PYG{p}{]}\PYG{p}{.}\PYG{n}{setup}\PYG{p}{(}\PYG{n}{tmpdatactive}\PYG{p}{)}\PYG{p}{;}
            \PYG{n}{active}\PYG{p}{[}\PYG{n}{endactive}\PYG{p}{]}\PYG{p}{.}\PYG{n}{setNwrap}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}
            \PYG{n}{active}\PYG{p}{[}\PYG{n}{endactive}\PYG{p}{]}\PYG{p}{.}\PYG{n}{setNext}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{else}  \PYG{c+c1}{// else the end lineage is wrapped, and needs to be processed including the wrapping routines.}
        \PYG{p}{\PYGZob{}}
            \PYG{k}{if}\PYG{p}{(}\PYG{n}{active}\PYG{p}{[}\PYG{n}{endactive}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getNwrap}\PYG{p}{(}\PYG{p}{)} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{n}{cerr} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ERROR\PYGZus{}MOVE\PYGZus{}021: NON FATAL. Nwrap is not set correctly for endactive (nwrap }\PYG{l+s}{\PYGZdq{}}
                        \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{incorrectly 0). Identified during switch of positions.}\PYG{l+s}{\PYGZdq{}}
                     \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
            \PYG{c+c1}{//              os \PYGZlt{}\PYGZlt{} \PYGZdq{}wrap\PYGZdq{}\PYGZlt{}\PYGZlt{}endl;}
            \PYG{k+kt}{long} \PYG{n}{tmpactive} \PYG{o}{=} \PYG{n}{grid}\PYG{p}{[}\PYG{n}{active}\PYG{p}{[}\PYG{n}{endactive}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getYpos}\PYG{p}{(}\PYG{p}{)}\PYG{p}{]}\PYG{p}{[}\PYG{n}{active}\PYG{p}{[}\PYG{n}{endactive}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getXpos}\PYG{p}{(}\PYG{p}{)}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getNext}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
            \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{tmpnwrap} \PYG{o}{=} \PYG{n}{active}\PYG{p}{[}\PYG{n}{endactive}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getNwrap}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

            \PYG{c+c1}{// if the wrapping is just once, we need to set the grid next to the chosen variable.}
            \PYG{k}{if}\PYG{p}{(}\PYG{n}{tmpnwrap} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{c+c1}{// check}
                \PYG{k}{if}\PYG{p}{(}\PYG{n}{grid}\PYG{p}{[}\PYG{n}{active}\PYG{p}{[}\PYG{n}{endactive}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getYpos}\PYG{p}{(}\PYG{p}{)}\PYG{p}{]}\PYG{p}{[}\PYG{n}{active}\PYG{p}{[}\PYG{n}{endactive}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getXpos}\PYG{p}{(}\PYG{p}{)}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getNext}\PYG{p}{(}\PYG{p}{)} \PYG{o}{!}\PYG{o}{=} \PYG{n}{endactive}\PYG{p}{)}
                \PYG{p}{\PYGZob{}}
                    \PYG{k}{throw} \PYG{n}{FatalException}\PYG{p}{(}\PYG{n}{string}\PYG{p}{(}
                        \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ERROR\PYGZus{}MOVE\PYGZus{}019: FATAL. Nwrap for endactive not set correctly. Nwrap is 1, but }\PYG{l+s}{\PYGZdq{}}
                        \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{lineage at 1st position is }\PYG{l+s}{\PYGZdq{}} \PYG{o}{+}
                        \PYG{n}{to\PYGZus{}string}\PYG{p}{(}
                            \PYG{p}{(}\PYG{k+kt}{long} \PYG{k+kt}{long}\PYG{p}{)}\PYG{n}{grid}\PYG{p}{[}\PYG{n}{active}\PYG{p}{[}\PYG{n}{endactive}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getYpos}\PYG{p}{(}\PYG{p}{)}\PYG{p}{]}\PYG{p}{[}\PYG{n}{active}\PYG{p}{[}\PYG{n}{endactive}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getXpos}\PYG{p}{(}\PYG{p}{)}\PYG{p}{]}
                                \PYG{p}{.}\PYG{n}{getNext}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)} \PYG{o}{+}
                        \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{. Identified during the move.}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
                \PYG{p}{\PYGZcb{}}
                \PYG{n}{grid}\PYG{p}{[}\PYG{n}{active}\PYG{p}{[}\PYG{n}{endactive}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getYpos}\PYG{p}{(}\PYG{p}{)}\PYG{p}{]}\PYG{p}{[}\PYG{n}{active}\PYG{p}{[}\PYG{n}{endactive}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getXpos}\PYG{p}{(}\PYG{p}{)}\PYG{p}{]}\PYG{p}{.}\PYG{n}{setNext}\PYG{p}{(}\PYG{n}{chosen}\PYG{p}{)}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
            \PYG{k}{else}  \PYG{c+c1}{// otherwise, we just set the next to chosen instead of endactive.}
            \PYG{p}{\PYGZob{}}
                \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{tmpcount} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
                \PYG{c+c1}{// loop over nexts until we reach the right lineage.}
                \PYG{k}{while}\PYG{p}{(}\PYG{n}{active}\PYG{p}{[}\PYG{n}{tmpactive}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getNext}\PYG{p}{(}\PYG{p}{)} \PYG{o}{!}\PYG{o}{=} \PYG{n}{endactive}\PYG{p}{)}
                \PYG{p}{\PYGZob{}}
                    \PYG{n}{tmpactive} \PYG{o}{=} \PYG{n}{active}\PYG{p}{[}\PYG{n}{tmpactive}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getNext}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
                    \PYG{n}{tmpcount}\PYG{o}{+}\PYG{o}{+}\PYG{p}{;}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifdef DEBUG}
                    \PYG{k}{if}\PYG{p}{(}\PYG{n}{tmpcount} \PYG{o}{\PYGZgt{}} \PYG{n}{tmpnwrap}\PYG{p}{)}
                    \PYG{p}{\PYGZob{}}
                        \PYG{n}{writeLog}\PYG{p}{(}\PYG{l+m+mi}{30}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ERROR\PYGZus{}MOVE\PYGZus{}013: NON FATAL. Looping has not encountered a match, }\PYG{l+s}{\PYGZdq{}}
                                \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{despite going further than required. Check nwrap counting.}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
                        \PYG{k}{if}\PYG{p}{(}\PYG{n}{tmpactive} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)}
                        \PYG{p}{\PYGZob{}}
                            \PYG{n}{stringstream} \PYG{n}{ss}\PYG{p}{;}
                            \PYG{n}{ss} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{gridnext: }\PYG{l+s}{\PYGZdq{}}
                                 \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{grid}\PYG{p}{[}\PYG{n}{active}\PYG{p}{[}\PYG{n}{endactive}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getYpos}\PYG{p}{(}\PYG{p}{)}\PYG{p}{]}\PYG{p}{[}\PYG{n}{active}\PYG{p}{[}\PYG{n}{endactive}\PYG{p}{]}
                                                                          \PYG{p}{.}\PYG{n}{getXpos}\PYG{p}{(}\PYG{p}{)}\PYG{p}{]}
                                        \PYG{p}{.}\PYG{n}{getNext}\PYG{p}{(}\PYG{p}{)}
                                 \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
                            \PYG{n}{ss} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{endactive: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endactive} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
                            \PYG{n}{ss} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{tmpactive: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{tmpactive} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
                            \PYG{n}{ss} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{tmpnwrap: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{tmpnwrap} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ tmpcount: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{tmpcount}
                                 \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
                            \PYG{n}{writeLog}\PYG{p}{(}\PYG{l+m+mi}{50}\PYG{p}{,} \PYG{n}{ss}\PYG{p}{)}\PYG{p}{;}
                            \PYG{n}{writeLog}\PYG{p}{(}\PYG{l+m+mi}{50}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Logging chosen:}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
                            \PYG{n}{active}\PYG{p}{[}\PYG{n}{chosen}\PYG{p}{]}\PYG{p}{.}\PYG{n}{logActive}\PYG{p}{(}\PYG{l+m+mi}{50}\PYG{p}{)}\PYG{p}{;}
                            \PYG{k}{throw} \PYG{n+nf}{FatalException}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{No match found, please report this bug.}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
                        \PYG{p}{\PYGZcb{}}
                    \PYG{p}{\PYGZcb{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif }\PYG{c+c1}{// DEBUG}
                \PYG{p}{\PYGZcb{}}
                \PYG{n}{active}\PYG{p}{[}\PYG{n}{tmpactive}\PYG{p}{]}\PYG{p}{.}\PYG{n}{setNext}\PYG{p}{(}\PYG{n}{chosen}\PYG{p}{)}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
            \PYG{n}{active}\PYG{p}{[}\PYG{n}{chosen}\PYG{p}{]}\PYG{p}{.}\PYG{n}{setup}\PYG{p}{(}\PYG{n}{active}\PYG{p}{[}\PYG{n}{endactive}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
            \PYG{n}{active}\PYG{p}{[}\PYG{n}{endactive}\PYG{p}{]}\PYG{p}{.}\PYG{n}{setup}\PYG{p}{(}\PYG{n}{tmpdatactive}\PYG{p}{)}\PYG{p}{;}

            \PYG{c+c1}{// check \PYGZhy{} debugging}
            \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{testwrap} \PYG{o}{=} \PYG{n}{active}\PYG{p}{[}\PYG{n}{chosen}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getNwrap}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
            \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{testnext} \PYG{o}{=} \PYG{n}{grid}\PYG{p}{[}\PYG{n}{active}\PYG{p}{[}\PYG{n}{chosen}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getYpos}\PYG{p}{(}\PYG{p}{)}\PYG{p}{]}\PYG{p}{[}\PYG{n}{active}\PYG{p}{[}\PYG{n}{chosen}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getXpos}\PYG{p}{(}\PYG{p}{)}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getNext}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
            \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{testwrap}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{n}{testnext} \PYG{o}{=} \PYG{n}{active}\PYG{p}{[}\PYG{n}{testnext}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getNext}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}

            \PYG{k}{if}\PYG{p}{(}\PYG{n}{testnext} \PYG{o}{!}\PYG{o}{=} \PYG{n}{chosen}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{k}{throw} \PYG{n}{FatalException}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ERROR\PYGZus{}MOVE\PYGZus{}009: Nwrap position not set correctly after coalescence. }\PYG{l+s}{\PYGZdq{}}
                                      \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Check move process.}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
        \PYG{p}{\PYGZcb{}}
    \PYG{p}{\PYGZcb{}}
    \PYG{n}{endactive}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{void} \PYG{n}{SpatialTree}\PYG{o}{:}\PYG{o}{:}\PYG{n}{calcNextStep}\PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{n}{calcMove}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
    \PYG{c+c1}{// Calculate the new position, perform the move if coalescence doesn\PYGZsq{}t occur or}
    \PYG{c+c1}{// return the variables for the coalescence event if coalescence does occur.}
    \PYG{n}{active}\PYG{p}{[}\PYG{n}{this\PYGZus{}step}\PYG{p}{.}\PYG{n}{chosen}\PYG{p}{]}\PYG{p}{.}\PYG{n}{setEndpoint}\PYG{p}{(}\PYG{n}{this\PYGZus{}step}\PYG{p}{.}\PYG{n}{oldx}\PYG{p}{,} \PYG{n}{this\PYGZus{}step}\PYG{p}{.}\PYG{n}{oldy}\PYG{p}{,}
                                         \PYG{n}{this\PYGZus{}step}\PYG{p}{.}\PYG{n}{oldxwrap}\PYG{p}{,}
                                         \PYG{n}{this\PYGZus{}step}\PYG{p}{.}\PYG{n}{oldywrap}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{calcNewPos}\PYG{p}{(}\PYG{n}{this\PYGZus{}step}\PYG{p}{.}\PYG{n}{coal}\PYG{p}{,} \PYG{n}{this\PYGZus{}step}\PYG{p}{.}\PYG{n}{chosen}\PYG{p}{,} \PYG{n}{this\PYGZus{}step}\PYG{p}{.}\PYG{n}{coalchosen}\PYG{p}{,} \PYG{n}{this\PYGZus{}step}\PYG{p}{.}\PYG{n}{oldx}\PYG{p}{,}
               \PYG{n}{this\PYGZus{}step}\PYG{p}{.}\PYG{n}{oldy}\PYG{p}{,} \PYG{n}{this\PYGZus{}step}\PYG{p}{.}\PYG{n}{oldxwrap}\PYG{p}{,} \PYG{n}{this\PYGZus{}step}\PYG{p}{.}\PYG{n}{oldywrap}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{SpatialTree}\PYG{o}{:}\PYG{o}{:}\PYG{n}{estSpecnum}\PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{c+c1}{// This bit has been removed as it has a very significant performance hit and is not required for most simulations.}
    \PYG{c+c1}{// As of version 3.2 it was fully compatible with the rest of the simulation, however. See estSpecnum for commented}
    \PYG{c+c1}{// code}
    \PYG{c+c1}{// (removed from here to make things tidier).}
    \PYG{c+c1}{// This bit was moved from runSimulation() to make things tidier there.}
    \PYG{c+cm}{/*}
\PYG{c+cm}{    if(steps\PYGZpc{}1000000==0)}
\PYG{c+cm}{\PYGZob{}}
\PYG{c+cm}{            time(\PYGZam{}now);}
\PYG{c+cm}{            if(now \PYGZhy{} time\PYGZus{}taken\PYGZgt{}200\PYGZam{}\PYGZam{}dPercentComplete\PYGZgt{}95)}
\PYG{c+cm}{            \PYGZob{}}
\PYG{c+cm}{                            time(\PYGZam{}time\PYGZus{}taken);}
\PYG{c+cm}{                            unsigned long specnum = est\PYGZus{}specnum();}
\PYG{c+cm}{                            os \PYGZlt{}\PYGZlt{} \PYGZdq{}Estimated number of species: \PYGZdq{} \PYGZlt{}\PYGZlt{} specnum \PYGZlt{}\PYGZlt{}}
\PYG{c+cm}{                            flush;}
\PYG{c+cm}{                            if(specnum\PYGZlt{}desired\PYGZus{}specnum)}
\PYG{c+cm}{                            \PYGZob{}}
\PYG{c+cm}{                                            os \PYGZlt{}\PYGZlt{} \PYGZdq{} \PYGZhy{} desired}
\PYG{c+cm}{                                            number of species reached.\PYGZdq{} \PYGZlt{}\PYGZlt{} endl \PYGZlt{}\PYGZlt{} \PYGZdq{}Halting}
\PYG{c+cm}{                                            simulations...\PYGZdq{} \PYGZlt{}\PYGZlt{} endl;}
\PYG{c+cm}{                                            bContinueSim = false;}
\PYG{c+cm}{                            \PYGZcb{}}
\PYG{c+cm}{                            else}
\PYG{c+cm}{                            \PYGZob{}}
\PYG{c+cm}{                                            os \PYGZlt{}\PYGZlt{} endl;}
\PYG{c+cm}{                            \PYGZcb{}}
\PYG{c+cm}{            \PYGZcb{}}
\PYG{c+cm}{\PYGZcb{}}
\PYG{c+cm}{//*/}
    \PYG{k+kt}{long} \PYG{k+kt}{double} \PYG{n}{dMinmax} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
    \PYG{c+c1}{// first loop to find the maximum speciation rate required}
    \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{n}{endactive}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k+kt}{long} \PYG{k+kt}{double} \PYG{n}{tmpminmax} \PYG{o}{=} \PYG{n}{calcMinMax}\PYG{p}{(}\PYG{n}{i}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{active}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{setMinmax}\PYG{p}{(}\PYG{n}{tmpminmax}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{dMinmax} \PYG{o}{=} \PYG{p}{(}\PYG{k+kt}{long} \PYG{k+kt}{double}\PYG{p}{)}\PYG{n}{max}\PYG{p}{(}\PYG{n}{dMinmax}\PYG{p}{,} \PYG{n}{tmpminmax}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{n}{enddata}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{data}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{isTip}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{data}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{setExistence}\PYG{p}{(}\PYG{n+nb}{true}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{k+kt}{double} \PYG{n}{maxret} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{data}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getGenRate}\PYG{p}{(}\PYG{p}{)} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{maxret} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{else}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{maxret} \PYG{o}{=} \PYG{n}{data}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getGenRate}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{c+c1}{// This is the line that compares the individual random numbers against the speciation rate.}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{data}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getSpecRate}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZlt{}} \PYG{p}{(}\PYG{l+m+mi}{1} \PYG{o}{\PYGZhy{}} \PYG{n}{pow}\PYG{p}{(}\PYG{k+kt}{double}\PYG{p}{(}\PYG{l+m+mi}{1} \PYG{o}{\PYGZhy{}} \PYG{n}{dMinmax}\PYG{p}{)}\PYG{p}{,} \PYG{n}{maxret}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{data}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{speciate}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
    \PYG{p}{\PYGZcb{}}
    \PYG{k+kt}{bool} \PYG{n}{loop} \PYG{o}{=} \PYG{n+nb}{true}\PYG{p}{;}
    \PYG{k}{while}\PYG{p}{(}\PYG{n}{loop}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{loop} \PYG{o}{=} \PYG{n+nb}{false}\PYG{p}{;}
        \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{n}{enddata}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{k}{if}\PYG{p}{(}\PYG{n}{data}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getExistence}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{o}{!}\PYG{n}{data}\PYG{p}{[}\PYG{n}{data}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getParent}\PYG{p}{(}\PYG{p}{)}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getExistence}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{o}{!}\PYG{n}{data}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{hasSpeciated}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{n}{loop} \PYG{o}{=} \PYG{n+nb}{true}\PYG{p}{;}
                \PYG{n}{data}\PYG{p}{[}\PYG{n}{data}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getParent}\PYG{p}{(}\PYG{p}{)}\PYG{p}{]}\PYG{p}{.}\PYG{n}{setExistence}\PYG{p}{(}\PYG{n+nb}{true}\PYG{p}{)}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
        \PYG{p}{\PYGZcb{}}
    \PYG{p}{\PYGZcb{}}
    \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{iSpecies} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
    \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{n}{enddata}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{data}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getExistence}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{n}{data}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{hasSpeciated}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{iSpecies}\PYG{o}{+}\PYG{o}{+}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{n}{enddata}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{data}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{qReset}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{c+c1}{//      os \PYGZlt{}\PYGZlt{} \PYGZdq{}Estimated species number is: \PYGZdq{} \PYGZlt{}\PYGZlt{} iSpecies \PYGZlt{}\PYGZlt{} endl;}
    \PYG{k}{return} \PYG{n}{iSpecies}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifdef pristine\PYGZus{}mode}
\PYG{k+kt}{void} \PYG{n}{SpatialTree}\PYG{o}{:}\PYG{o}{:}\PYG{n}{pristineStepChecks}\PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k}{if}\PYG{p}{(}\PYG{n}{habitat\PYGZus{}map}\PYG{p}{.}\PYG{n}{getVal}\PYG{p}{(}\PYG{n}{this\PYGZus{}step}\PYG{p}{.}\PYG{n}{oldx}\PYG{p}{,} \PYG{n}{this\PYGZus{}step}\PYG{p}{.}\PYG{n}{oldy}\PYG{p}{,} \PYG{n}{this\PYGZus{}step}\PYG{p}{.}\PYG{n}{oldxwrap}\PYG{p}{,} \PYG{n}{this\PYGZus{}step}\PYG{p}{.}\PYG{n}{oldywrap}\PYG{p}{,} \PYG{n}{generation}\PYG{p}{)} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{cerr} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{x,y: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{this\PYGZus{}step}\PYG{p}{.}\PYG{n}{oldx} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{,}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{this\PYGZus{}step}\PYG{p}{.}\PYG{n}{oldy} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ xwrap, ywrap: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{this\PYGZus{}step}\PYG{p}{.}\PYG{n}{oldxwrap}\PYG{p}{;}
        \PYG{n}{cerr} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{,}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{this\PYGZus{}step}\PYG{p}{.}\PYG{n}{oldywrap} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
        \PYG{n}{cerr} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{listsize: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{grid}\PYG{p}{[}\PYG{n}{this\PYGZus{}step}\PYG{p}{.}\PYG{n}{oldy}\PYG{p}{]}\PYG{p}{[}\PYG{n}{this\PYGZus{}step}\PYG{p}{.}\PYG{n}{oldx}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getListsize}\PYG{p}{(}\PYG{p}{)}
             \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{maxsize: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{grid}\PYG{p}{[}\PYG{n}{this\PYGZus{}step}\PYG{p}{.}\PYG{n}{oldy}\PYG{p}{]}\PYG{p}{[}\PYG{n}{this\PYGZus{}step}\PYG{p}{.}\PYG{n}{oldx}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getMaxsize}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
        \PYG{k}{throw} \PYG{n+nf}{FatalException}\PYG{p}{(}
            \PYG{n}{string}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ERROR\PYGZus{}MOVE\PYGZus{}008: Dispersal attempted from non\PYGZhy{}forest. Check dispersal function. Forest }\PYG{l+s}{\PYGZdq{}}
                   \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{cover: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{+}
                   \PYG{n}{to\PYGZus{}string}\PYG{p}{(}\PYG{p}{(}\PYG{k+kt}{long} \PYG{k+kt}{long}\PYG{p}{)}\PYG{n}{habitat\PYGZus{}map}\PYG{p}{.}\PYG{n}{getVal}\PYG{p}{(}\PYG{n}{this\PYGZus{}step}\PYG{p}{.}\PYG{n}{oldx}\PYG{p}{,} \PYG{n}{this\PYGZus{}step}\PYG{p}{.}\PYG{n}{oldy}\PYG{p}{,} \PYG{n}{this\PYGZus{}step}\PYG{p}{.}\PYG{n}{oldxwrap}\PYG{p}{,}
                                                         \PYG{n}{this\PYGZus{}step}\PYG{p}{.}\PYG{n}{oldywrap}\PYG{p}{,} \PYG{n}{generation}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif}


\PYG{k+kt}{void} \PYG{n}{SpatialTree}\PYG{o}{:}\PYG{o}{:}\PYG{n}{incrementGeneration}\PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{n}{Tree}\PYG{o}{:}\PYG{o}{:}\PYG{n}{incrementGeneration}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{habitat\PYGZus{}map}\PYG{p}{.}\PYG{n}{updateMap}\PYG{p}{(}\PYG{n}{generation}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{checkTimeUpdate}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
    \PYG{c+c1}{// check if the map is pristine yet}
    \PYG{n}{habitat\PYGZus{}map}\PYG{p}{.}\PYG{n}{checkPristine}\PYG{p}{(}\PYG{n}{generation}\PYG{p}{)}\PYG{p}{;}

\PYG{p}{\PYGZcb{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifdef DEBUG}
\PYG{k+kt}{void} \PYG{n}{SpatialTree}\PYG{o}{:}\PYG{o}{:}\PYG{n}{debugDispersal}\PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k}{if}\PYG{p}{(}\PYG{n}{habitat\PYGZus{}map}\PYG{p}{.}\PYG{n}{getVal}\PYG{p}{(}\PYG{n}{this\PYGZus{}step}\PYG{p}{.}\PYG{n}{oldx}\PYG{p}{,} \PYG{n}{this\PYGZus{}step}\PYG{p}{.}\PYG{n}{oldy}\PYG{p}{,} \PYG{n}{this\PYGZus{}step}\PYG{p}{.}\PYG{n}{oldxwrap}\PYG{p}{,} \PYG{n}{this\PYGZus{}step}\PYG{p}{.}\PYG{n}{oldywrap}\PYG{p}{,} \PYG{n}{generation}\PYG{p}{)} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{throw} \PYG{n}{FatalException}\PYG{p}{(}
            \PYG{n}{string}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ERROR\PYGZus{}MOVE\PYGZus{}007: Dispersal attempted to non\PYGZhy{}forest. }\PYG{l+s}{\PYGZdq{}}
                   \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Check dispersal function. Forest cover: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{+}
                   \PYG{n}{to\PYGZus{}string}\PYG{p}{(}\PYG{p}{(}\PYG{k+kt}{long} \PYG{k+kt}{long}\PYG{p}{)}\PYG{n}{habitat\PYGZus{}map}\PYG{p}{.}\PYG{n}{getVal}\PYG{p}{(}\PYG{n}{this\PYGZus{}step}\PYG{p}{.}\PYG{n}{oldx}\PYG{p}{,} \PYG{n}{this\PYGZus{}step}\PYG{p}{.}\PYG{n}{oldy}\PYG{p}{,} \PYG{n}{this\PYGZus{}step}\PYG{p}{.}\PYG{n}{oldxwrap}\PYG{p}{,}
                                                         \PYG{n}{this\PYGZus{}step}\PYG{p}{.}\PYG{n}{oldywrap}\PYG{p}{,} \PYG{n}{generation}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}

\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif}

\PYG{k+kt}{void} \PYG{n}{SpatialTree}\PYG{o}{:}\PYG{o}{:}\PYG{n}{updateStepCoalescenceVariables}\PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{n}{Tree}\PYG{o}{:}\PYG{o}{:}\PYG{n}{updateStepCoalescenceVariables}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
    \PYG{k}{while}\PYG{p}{(}\PYG{o}{!}\PYG{n}{rep\PYGZus{}map}\PYG{p}{.}\PYG{n}{hasReproduced}\PYG{p}{(}\PYG{n}{NR}\PYG{p}{,} \PYG{n}{active}\PYG{p}{[}\PYG{n}{this\PYGZus{}step}\PYG{p}{.}\PYG{n}{chosen}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getXpos}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{n}{active}\PYG{p}{[}\PYG{n}{this\PYGZus{}step}\PYG{p}{.}\PYG{n}{chosen}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getYpos}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,}
                                 \PYG{n}{active}\PYG{p}{[}\PYG{n}{this\PYGZus{}step}\PYG{p}{.}\PYG{n}{chosen}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getXwrap}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{n}{active}\PYG{p}{[}\PYG{n}{this\PYGZus{}step}\PYG{p}{.}\PYG{n}{chosen}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getYwrap}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{this\PYGZus{}step}\PYG{p}{.}\PYG{n}{chosen} \PYG{o}{=} \PYG{n}{NR}\PYG{p}{.}\PYG{n}{i0}\PYG{p}{(}\PYG{n}{endactive} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{1}\PYG{p}{)} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{p}{;}  \PYG{c+c1}{// cannot be 0}
    \PYG{p}{\PYGZcb{}}
    \PYG{c+c1}{// record old position of lineage}
    \PYG{n}{this\PYGZus{}step}\PYG{p}{.}\PYG{n}{oldx} \PYG{o}{=} \PYG{n}{active}\PYG{p}{[}\PYG{n}{this\PYGZus{}step}\PYG{p}{.}\PYG{n}{chosen}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getXpos}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{this\PYGZus{}step}\PYG{p}{.}\PYG{n}{oldy} \PYG{o}{=} \PYG{n}{active}\PYG{p}{[}\PYG{n}{this\PYGZus{}step}\PYG{p}{.}\PYG{n}{chosen}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getYpos}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{this\PYGZus{}step}\PYG{p}{.}\PYG{n}{oldxwrap} \PYG{o}{=} \PYG{n}{active}\PYG{p}{[}\PYG{n}{this\PYGZus{}step}\PYG{p}{.}\PYG{n}{chosen}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getXwrap}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{this\PYGZus{}step}\PYG{p}{.}\PYG{n}{oldywrap} \PYG{o}{=} \PYG{n}{active}\PYG{p}{[}\PYG{n}{this\PYGZus{}step}\PYG{p}{.}\PYG{n}{chosen}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getYwrap}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifdef pristine\PYGZus{}mode}
    \PYG{n}{pristineStepChecks}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{void} \PYG{n}{SpatialTree}\PYG{o}{:}\PYG{o}{:}\PYG{n}{addLineages}\PYG{p}{(}\PYG{k+kt}{double} \PYG{n}{generation\PYGZus{}in}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{c+c1}{// First loop over the grid to check for the number that needs to be added to active}
    \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{added\PYGZus{}active} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
    \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{added\PYGZus{}data} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
    \PYG{c+c1}{// Update the sample grid boolean mask, if required.}
    \PYG{k}{if}\PYG{p}{(}\PYG{n}{sim\PYGZus{}parameters}\PYG{p}{.}\PYG{n}{uses\PYGZus{}spatial\PYGZus{}sampling}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{samplegrid}\PYG{p}{.}\PYG{n}{convertBoolean}\PYG{p}{(}\PYG{n}{habitat\PYGZus{}map}\PYG{p}{,} \PYG{n}{deme\PYGZus{}sample}\PYG{p}{,} \PYG{n}{generation\PYGZus{}in}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{sim\PYGZus{}parameters}\PYG{p}{.}\PYG{n}{sample\PYGZus{}x\PYGZus{}size}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{j} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{j} \PYG{o}{\PYGZlt{}} \PYG{n}{sim\PYGZus{}parameters}\PYG{p}{.}\PYG{n}{sample\PYGZus{}y\PYGZus{}size}\PYG{p}{;} \PYG{n}{j}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{k+kt}{long} \PYG{n}{x}\PYG{p}{,} \PYG{n}{y}\PYG{p}{;}
            \PYG{n}{x} \PYG{o}{=} \PYG{n}{i}\PYG{p}{;}
            \PYG{n}{y} \PYG{o}{=} \PYG{n}{j}\PYG{p}{;}
            \PYG{k+kt}{long} \PYG{n}{xwrap}\PYG{p}{,} \PYG{n}{ywrap}\PYG{p}{;}
            \PYG{n}{xwrap} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
            \PYG{n}{ywrap} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
            \PYG{n}{samplegrid}\PYG{p}{.}\PYG{n}{recalculate\PYGZus{}coordinates}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,} \PYG{n}{y}\PYG{p}{,} \PYG{n}{xwrap}\PYG{p}{,} \PYG{n}{ywrap}\PYG{p}{)}\PYG{p}{;}
            \PYG{k}{if}\PYG{p}{(}\PYG{n}{samplegrid}\PYG{p}{.}\PYG{n}{getVal}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,} \PYG{n}{y}\PYG{p}{,} \PYG{n}{xwrap}\PYG{p}{,} \PYG{n}{ywrap}\PYG{p}{)}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{num\PYGZus{}to\PYGZus{}add} \PYG{o}{=} \PYG{n}{countCellExpansion}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,} \PYG{n}{y}\PYG{p}{,} \PYG{n}{xwrap}\PYG{p}{,} \PYG{n}{ywrap}\PYG{p}{,} \PYG{n}{generation\PYGZus{}in}\PYG{p}{,} \PYG{n+nb}{false}\PYG{p}{)}\PYG{p}{;}
                \PYG{n}{added\PYGZus{}data} \PYG{o}{+}\PYG{o}{=} \PYG{n}{getIndividualsSampled}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,} \PYG{n}{y}\PYG{p}{,} \PYG{n}{xwrap}\PYG{p}{,} \PYG{n}{ywrap}\PYG{p}{,} \PYG{n}{generation\PYGZus{}in}\PYG{p}{)} \PYG{o}{\PYGZhy{}} \PYG{n}{num\PYGZus{}to\PYGZus{}add}\PYG{p}{;}
                \PYG{n}{added\PYGZus{}active} \PYG{o}{+}\PYG{o}{=} \PYG{n}{num\PYGZus{}to\PYGZus{}add}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
        \PYG{p}{\PYGZcb{}}
    \PYG{p}{\PYGZcb{}}
    \PYG{n}{added\PYGZus{}data} \PYG{o}{+}\PYG{o}{=} \PYG{n}{added\PYGZus{}active}\PYG{p}{;}
    \PYG{c+c1}{// now resize data and active if necessary}
    \PYG{n}{checkSimSize}\PYG{p}{(}\PYG{n}{added\PYGZus{}data}\PYG{p}{,} \PYG{n}{added\PYGZus{}active}\PYG{p}{)}\PYG{p}{;}
    \PYG{c+c1}{// Add the new lineages and modify the existing lineages within our sample area}
    \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{sim\PYGZus{}parameters}\PYG{p}{.}\PYG{n}{sample\PYGZus{}x\PYGZus{}size}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{j} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{j} \PYG{o}{\PYGZlt{}} \PYG{n}{sim\PYGZus{}parameters}\PYG{p}{.}\PYG{n}{sample\PYGZus{}y\PYGZus{}size}\PYG{p}{;} \PYG{n}{j}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{k+kt}{long} \PYG{n}{x}\PYG{p}{,} \PYG{n}{y}\PYG{p}{;}
            \PYG{n}{x} \PYG{o}{=} \PYG{n}{i}\PYG{p}{;}
            \PYG{n}{y} \PYG{o}{=} \PYG{n}{j}\PYG{p}{;}
            \PYG{k+kt}{long} \PYG{n}{xwrap}\PYG{p}{,} \PYG{n}{ywrap}\PYG{p}{;}
            \PYG{n}{xwrap} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
            \PYG{n}{ywrap} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
            \PYG{n}{samplegrid}\PYG{p}{.}\PYG{n}{recalculate\PYGZus{}coordinates}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,} \PYG{n}{y}\PYG{p}{,} \PYG{n}{xwrap}\PYG{p}{,} \PYG{n}{ywrap}\PYG{p}{)}\PYG{p}{;}
            \PYG{k}{if}\PYG{p}{(}\PYG{n}{samplegrid}\PYG{p}{.}\PYG{n}{getVal}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,} \PYG{n}{y}\PYG{p}{,} \PYG{n}{xwrap}\PYG{p}{,} \PYG{n}{ywrap}\PYG{p}{)}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{c+c1}{// Count the number of new cells that we need to add (after making those that already exist into tips)}
                \PYG{c+c1}{// Note that this function won\PYGZsq{}t make more tips than the proportion we are sampling}
                \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{num\PYGZus{}to\PYGZus{}add} \PYG{o}{=} \PYG{n}{countCellExpansion}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,} \PYG{n}{y}\PYG{p}{,} \PYG{n}{xwrap}\PYG{p}{,} \PYG{n}{ywrap}\PYG{p}{,} \PYG{n}{generation\PYGZus{}in}\PYG{p}{,} \PYG{n+nb}{true}\PYG{p}{)}\PYG{p}{;}
                \PYG{n}{expandCell}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,} \PYG{n}{y}\PYG{p}{,} \PYG{n}{xwrap}\PYG{p}{,} \PYG{n}{ywrap}\PYG{p}{,} \PYG{n}{generation\PYGZus{}in}\PYG{p}{,} \PYG{n}{num\PYGZus{}to\PYGZus{}add}\PYG{p}{)}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
        \PYG{p}{\PYGZcb{}}
    \PYG{p}{\PYGZcb{}}
    \PYG{c+c1}{// double check sizes}
    \PYG{k}{if}\PYG{p}{(}\PYG{n}{enddata} \PYG{o}{\PYGZgt{}}\PYG{o}{=} \PYG{n}{data}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\textbar{}}\PYG{o}{\textbar{}} \PYG{n}{endactive} \PYG{o}{\PYGZgt{}}\PYG{o}{=} \PYG{n}{active}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{throw} \PYG{n}{FatalException}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ERROR\PYGZus{}MAIN\PYGZus{}012: FATAL. Enddata or endactive is greater than the size of the }\PYG{l+s}{\PYGZdq{}}
                              \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{relevant object. Programming error likely.}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{if}\PYG{p}{(}\PYG{n}{endactive} \PYG{o}{\PYGZgt{}} \PYG{n}{startendactive}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{startendactive} \PYG{o}{=} \PYG{n}{endactive}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifdef DEBUG}
    \PYG{n}{validateLineages}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif}
\PYG{p}{\PYGZcb{}}

\PYG{n}{string} \PYG{n}{SpatialTree}\PYG{o}{:}\PYG{o}{:}\PYG{n}{simulationParametersSqlInsertion}\PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{n}{string} \PYG{n}{to\PYGZus{}execute}\PYG{p}{;}
    \PYG{n}{to\PYGZus{}execute} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{INSERT INTO SIMULATION\PYGZus{}PARAMETERS VALUES(}\PYG{l+s}{\PYGZdq{}} \PYG{o}{+} \PYG{n}{to\PYGZus{}string}\PYG{p}{(}\PYG{p}{(}\PYG{k+kt}{long} \PYG{k+kt}{long}\PYG{p}{)}\PYG{n}{the\PYGZus{}seed}\PYG{p}{)} \PYG{o}{+} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{,}\PYG{l+s}{\PYGZdq{}} \PYG{o}{+}
                 \PYG{n}{to\PYGZus{}string}\PYG{p}{(}\PYG{p}{(}\PYG{k+kt}{long} \PYG{k+kt}{long}\PYG{p}{)}\PYG{n}{the\PYGZus{}task}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{to\PYGZus{}execute} \PYG{o}{+}\PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{,\PYGZsq{}}\PYG{l+s}{\PYGZdq{}} \PYG{o}{+} \PYG{n}{out\PYGZus{}directory} \PYG{o}{+} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZsq{},}\PYG{l+s}{\PYGZdq{}} \PYG{o}{+} \PYG{n}{boost}\PYG{o}{:}\PYG{o}{:}\PYG{n}{lexical\PYGZus{}cast}\PYG{o}{\PYGZlt{}}\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{string}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{p}{(}\PYG{k+kt}{long} \PYG{k+kt}{double}\PYG{p}{)}\PYG{n}{spec}\PYG{p}{)} \PYG{o}{+} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{,}\PYG{l+s}{\PYGZdq{}} \PYG{o}{+}
                  \PYG{n}{to\PYGZus{}string}\PYG{p}{(}\PYG{p}{(}\PYG{k+kt}{long} \PYG{k+kt}{double}\PYG{p}{)}\PYG{n}{sigma}\PYG{p}{)} \PYG{o}{+} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{,}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
    \PYG{n}{to\PYGZus{}execute} \PYG{o}{+}\PYG{o}{=} \PYG{n}{to\PYGZus{}string}\PYG{p}{(}\PYG{p}{(}\PYG{k+kt}{long} \PYG{k+kt}{double}\PYG{p}{)}\PYG{n}{tau}\PYG{p}{)} \PYG{o}{+} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{,}\PYG{l+s}{\PYGZdq{}} \PYG{o}{+} \PYG{n}{to\PYGZus{}string}\PYG{p}{(}\PYG{p}{(}\PYG{k+kt}{long} \PYG{k+kt}{long}\PYG{p}{)}\PYG{n}{deme}\PYG{p}{)} \PYG{o}{+} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{,}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
    \PYG{n}{to\PYGZus{}execute} \PYG{o}{+}\PYG{o}{=} \PYG{n}{to\PYGZus{}string}\PYG{p}{(}\PYG{p}{(}\PYG{k+kt}{long} \PYG{k+kt}{double}\PYG{p}{)}\PYG{n}{deme\PYGZus{}sample}\PYG{p}{)} \PYG{o}{+} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{,}\PYG{l+s}{\PYGZdq{}} \PYG{o}{+} \PYG{n}{to\PYGZus{}string}\PYG{p}{(}\PYG{p}{(}\PYG{k+kt}{long} \PYG{k+kt}{long}\PYG{p}{)}\PYG{n}{maxtime}\PYG{p}{)} \PYG{o}{+} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{,}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
    \PYG{n}{to\PYGZus{}execute} \PYG{o}{+}\PYG{o}{=} \PYG{n}{to\PYGZus{}string}\PYG{p}{(}\PYG{p}{(}\PYG{k+kt}{long} \PYG{k+kt}{double}\PYG{p}{)}\PYG{n}{dispersal\PYGZus{}relative\PYGZus{}cost}\PYG{p}{)} \PYG{o}{+} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{,}\PYG{l+s}{\PYGZdq{}} \PYG{o}{+} \PYG{n}{to\PYGZus{}string}\PYG{p}{(}\PYG{p}{(}\PYG{k+kt}{long} \PYG{k+kt}{long}\PYG{p}{)}\PYG{n}{desired\PYGZus{}specnum}\PYG{p}{)} \PYG{o}{+} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{,}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
    \PYG{n}{to\PYGZus{}execute} \PYG{o}{+}\PYG{o}{=} \PYG{n}{to\PYGZus{}string}\PYG{p}{(}\PYG{p}{(}\PYG{k+kt}{long} \PYG{k+kt}{double}\PYG{p}{)}\PYG{n}{sim\PYGZus{}parameters}\PYG{p}{.}\PYG{n}{habitat\PYGZus{}change\PYGZus{}rate}\PYG{p}{)} \PYG{o}{+} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{,}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
    \PYG{n}{to\PYGZus{}execute} \PYG{o}{+}\PYG{o}{=} \PYG{n}{to\PYGZus{}string}\PYG{p}{(}\PYG{p}{(}\PYG{k+kt}{long} \PYG{k+kt}{double}\PYG{p}{)}\PYG{n}{sim\PYGZus{}parameters}\PYG{p}{.}\PYG{n}{gen\PYGZus{}since\PYGZus{}pristine}\PYG{p}{)} \PYG{o}{+} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{,\PYGZsq{}}\PYG{l+s}{\PYGZdq{}} \PYG{o}{+} \PYG{n}{sim\PYGZus{}parameters}\PYG{p}{.}\PYG{n}{times\PYGZus{}file} \PYG{o}{+} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZsq{},\PYGZsq{}}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
    \PYG{n}{to\PYGZus{}execute} \PYG{o}{+}\PYG{o}{=} \PYG{n}{coarse\PYGZus{}map\PYGZus{}input} \PYG{o}{+} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZsq{},}\PYG{l+s}{\PYGZdq{}} \PYG{o}{+} \PYG{n}{to\PYGZus{}string}\PYG{p}{(}\PYG{p}{(}\PYG{k+kt}{long} \PYG{k+kt}{long}\PYG{p}{)}\PYG{n}{coarse\PYGZus{}map\PYGZus{}x\PYGZus{}size}\PYG{p}{)} \PYG{o}{+} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{,}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
    \PYG{n}{to\PYGZus{}execute} \PYG{o}{+}\PYG{o}{=} \PYG{n}{to\PYGZus{}string}\PYG{p}{(}\PYG{p}{(}\PYG{k+kt}{long} \PYG{k+kt}{long}\PYG{p}{)}\PYG{n}{coarse\PYGZus{}map\PYGZus{}y\PYGZus{}size}\PYG{p}{)} \PYG{o}{+} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{,}\PYG{l+s}{\PYGZdq{}} \PYG{o}{+} \PYG{n}{to\PYGZus{}string}\PYG{p}{(}\PYG{p}{(}\PYG{k+kt}{long} \PYG{k+kt}{long}\PYG{p}{)}\PYG{n}{coarse\PYGZus{}map\PYGZus{}x\PYGZus{}offset}\PYG{p}{)} \PYG{o}{+} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{,}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
    \PYG{n}{to\PYGZus{}execute} \PYG{o}{+}\PYG{o}{=} \PYG{n}{to\PYGZus{}string}\PYG{p}{(}\PYG{p}{(}\PYG{k+kt}{long} \PYG{k+kt}{long}\PYG{p}{)}\PYG{n}{coarse\PYGZus{}map\PYGZus{}y\PYGZus{}offset}\PYG{p}{)} \PYG{o}{+} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{,}\PYG{l+s}{\PYGZdq{}} \PYG{o}{+} \PYG{n}{to\PYGZus{}string}\PYG{p}{(}\PYG{p}{(}\PYG{k+kt}{long} \PYG{k+kt}{long}\PYG{p}{)}\PYG{n}{coarse\PYGZus{}map\PYGZus{}scale}\PYG{p}{)} \PYG{o}{+} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{,\PYGZsq{}}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
    \PYG{n}{to\PYGZus{}execute} \PYG{o}{+}\PYG{o}{=} \PYG{n}{fine\PYGZus{}map\PYGZus{}input} \PYG{o}{+} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZsq{},}\PYG{l+s}{\PYGZdq{}} \PYG{o}{+} \PYG{n}{to\PYGZus{}string}\PYG{p}{(}\PYG{p}{(}\PYG{k+kt}{long} \PYG{k+kt}{long}\PYG{p}{)}\PYG{n}{fine\PYGZus{}map\PYGZus{}x\PYGZus{}size}\PYG{p}{)} \PYG{o}{+} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{,}\PYG{l+s}{\PYGZdq{}} \PYG{o}{+} \PYG{n}{to\PYGZus{}string}\PYG{p}{(}\PYG{p}{(}\PYG{k+kt}{long} \PYG{k+kt}{long}\PYG{p}{)}\PYG{n}{fine\PYGZus{}map\PYGZus{}y\PYGZus{}size}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{to\PYGZus{}execute} \PYG{o}{+}\PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{,}\PYG{l+s}{\PYGZdq{}} \PYG{o}{+} \PYG{n}{to\PYGZus{}string}\PYG{p}{(}\PYG{p}{(}\PYG{k+kt}{long} \PYG{k+kt}{long}\PYG{p}{)}\PYG{n}{fine\PYGZus{}map\PYGZus{}x\PYGZus{}offset}\PYG{p}{)} \PYG{o}{+} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{,}\PYG{l+s}{\PYGZdq{}} \PYG{o}{+} \PYG{n}{to\PYGZus{}string}\PYG{p}{(}\PYG{p}{(}\PYG{k+kt}{long} \PYG{k+kt}{long}\PYG{p}{)}\PYG{n}{fine\PYGZus{}map\PYGZus{}y\PYGZus{}offset}\PYG{p}{)} \PYG{o}{+} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{,\PYGZsq{}}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
    \PYG{n}{to\PYGZus{}execute} \PYG{o}{+}\PYG{o}{=} \PYG{n}{sim\PYGZus{}parameters}\PYG{p}{.}\PYG{n}{sample\PYGZus{}mask\PYGZus{}file} \PYG{o}{+} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZsq{},}\PYG{l+s}{\PYGZdq{}} \PYG{o}{+} \PYG{n}{to\PYGZus{}string}\PYG{p}{(}\PYG{p}{(}\PYG{k+kt}{long} \PYG{k+kt}{long}\PYG{p}{)}\PYG{n}{grid\PYGZus{}x\PYGZus{}size}\PYG{p}{)} \PYG{o}{+} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{,}\PYG{l+s}{\PYGZdq{}} \PYG{o}{+}
                  \PYG{n}{to\PYGZus{}string}\PYG{p}{(}\PYG{p}{(}\PYG{k+kt}{long} \PYG{k+kt}{long}\PYG{p}{)} \PYG{n}{grid\PYGZus{}y\PYGZus{}size}\PYG{p}{)} \PYG{o}{+} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{,}\PYG{l+s}{\PYGZdq{}} \PYG{o}{+} \PYG{n}{to\PYGZus{}string}\PYG{p}{(}\PYG{p}{(}\PYG{k+kt}{long} \PYG{k+kt}{long}\PYG{p}{)} \PYG{n}{sim\PYGZus{}parameters}\PYG{p}{.}\PYG{n}{sample\PYGZus{}x\PYGZus{}size}\PYG{p}{)} \PYG{o}{+} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{, }\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
    \PYG{n}{to\PYGZus{}execute} \PYG{o}{+}\PYG{o}{=} \PYG{n}{to\PYGZus{}string}\PYG{p}{(}\PYG{p}{(}\PYG{k+kt}{long} \PYG{k+kt}{long}\PYG{p}{)} \PYG{n}{sim\PYGZus{}parameters}\PYG{p}{.}\PYG{n}{sample\PYGZus{}y\PYGZus{}size}\PYG{p}{)} \PYG{o}{+} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{, }\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
    \PYG{n}{to\PYGZus{}execute} \PYG{o}{+}\PYG{o}{=} \PYG{n}{to\PYGZus{}string}\PYG{p}{(}\PYG{p}{(}\PYG{k+kt}{long} \PYG{k+kt}{long}\PYG{p}{)} \PYG{n}{sim\PYGZus{}parameters}\PYG{p}{.}\PYG{n}{sample\PYGZus{}x\PYGZus{}offset}\PYG{p}{)} \PYG{o}{+} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{, }\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
    \PYG{n}{to\PYGZus{}execute} \PYG{o}{+}\PYG{o}{=} \PYG{n}{to\PYGZus{}string}\PYG{p}{(}\PYG{p}{(}\PYG{k+kt}{long} \PYG{k+kt}{long}\PYG{p}{)} \PYG{n}{sim\PYGZus{}parameters}\PYG{p}{.}\PYG{n}{sample\PYGZus{}y\PYGZus{}offset}\PYG{p}{)} \PYG{o}{+} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{, \PYGZsq{}}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
    \PYG{n}{to\PYGZus{}execute} \PYG{o}{+}\PYG{o}{=} \PYG{n}{pristine\PYGZus{}coarse\PYGZus{}map\PYGZus{}input} \PYG{o}{+} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZsq{},\PYGZsq{}}\PYG{l+s}{\PYGZdq{}} \PYG{o}{+} \PYG{n}{pristine\PYGZus{}fine\PYGZus{}map\PYGZus{}input} \PYG{o}{+} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZsq{},}\PYG{l+s}{\PYGZdq{}} \PYG{o}{+} \PYG{n}{to\PYGZus{}string}\PYG{p}{(}\PYG{n}{sim\PYGZus{}complete}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{to\PYGZus{}execute} \PYG{o}{+}\PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{, \PYGZsq{}}\PYG{l+s}{\PYGZdq{}} \PYG{o}{+} \PYG{n}{sim\PYGZus{}parameters}\PYG{p}{.}\PYG{n}{dispersal\PYGZus{}method} \PYG{o}{+} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZsq{}, }\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
    \PYG{n}{to\PYGZus{}execute} \PYG{o}{+}\PYG{o}{=} \PYG{n}{boost}\PYG{o}{:}\PYG{o}{:}\PYG{n}{lexical\PYGZus{}cast}\PYG{o}{\PYGZlt{}}\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{string}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{n}{sim\PYGZus{}parameters}\PYG{p}{.}\PYG{n}{m\PYGZus{}prob}\PYG{p}{)} \PYG{o}{+} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{, }\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
    \PYG{n}{to\PYGZus{}execute} \PYG{o}{+}\PYG{o}{=} \PYG{n}{to\PYGZus{}string}\PYG{p}{(}\PYG{p}{(}\PYG{k+kt}{long} \PYG{k+kt}{double}\PYG{p}{)}\PYG{n}{sim\PYGZus{}parameters}\PYG{p}{.}\PYG{n}{cutoff}\PYG{p}{)} \PYG{o}{+} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{, }\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
    \PYG{n}{to\PYGZus{}execute} \PYG{o}{+}\PYG{o}{=} \PYG{n}{to\PYGZus{}string}\PYG{p}{(}\PYG{n}{sim\PYGZus{}parameters}\PYG{p}{.}\PYG{n}{restrict\PYGZus{}self}\PYG{p}{)} \PYG{o}{+} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{, \PYGZsq{}}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
    \PYG{n}{to\PYGZus{}execute} \PYG{o}{+}\PYG{o}{=} \PYG{n}{sim\PYGZus{}parameters}\PYG{p}{.}\PYG{n}{landscape\PYGZus{}type} \PYG{o}{+} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZsq{}, }\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
    \PYG{c+c1}{// Now save the protracted speciation variables (not relevant in this simulation scenario)}
    \PYG{n}{to\PYGZus{}execute} \PYG{o}{+}\PYG{o}{=} \PYG{n}{protractedVarsToString}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{to\PYGZus{}execute} \PYG{o}{+}\PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{, \PYGZsq{}}\PYG{l+s}{\PYGZdq{}} \PYG{o}{+} \PYG{n}{sim\PYGZus{}parameters}\PYG{p}{.}\PYG{n}{dispersal\PYGZus{}file} \PYG{o}{+} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
    \PYG{n}{to\PYGZus{}execute} \PYG{o}{+}\PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{);}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
    \PYG{k}{return} \PYG{n}{to\PYGZus{}execute}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{void} \PYG{n}{SpatialTree}\PYG{o}{:}\PYG{o}{:}\PYG{n}{simPause}\PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{c+c1}{// Completely changed how this sections works \PYGZhy{} it won\PYGZsq{}t currently allow restarting of the simulations, but will}
    \PYG{c+c1}{// dump the data file to memory. \PYGZhy{} simply calls sqlCreate and sqlOutput.}
    \PYG{c+c1}{// sqlCreate();}
    \PYG{c+c1}{// sqlOutput();}

    \PYG{c+c1}{// This function saves the data to 4 files. One contains the main simulation parameters, the other 3 contain the}
    \PYG{c+c1}{// simulation results thus far}
    \PYG{c+c1}{// including the grid object, data object and active object.}
    \PYG{n}{string} \PYG{n}{pause\PYGZus{}folder} \PYG{o}{=} \PYG{n}{initiatePause}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{dumpMain}\PYG{p}{(}\PYG{n}{pause\PYGZus{}folder}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{dumpActive}\PYG{p}{(}\PYG{n}{pause\PYGZus{}folder}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{dumpData}\PYG{p}{(}\PYG{n}{pause\PYGZus{}folder}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{dumpMap}\PYG{p}{(}\PYG{n}{pause\PYGZus{}folder}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{completePause}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{void} \PYG{n}{SpatialTree}\PYG{o}{:}\PYG{o}{:}\PYG{n}{dumpMap}\PYG{p}{(}\PYG{n}{string} \PYG{n}{pause\PYGZus{}folder}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k}{try}
    \PYG{p}{\PYGZob{}}
        \PYG{c+c1}{// Output the data object}
        \PYG{n}{ofstream} \PYG{n}{out4}\PYG{p}{;}
        \PYG{n}{string} \PYG{n}{file\PYGZus{}to\PYGZus{}open} \PYG{o}{=} \PYG{n}{pause\PYGZus{}folder} \PYG{o}{+} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Dump\PYGZus{}map\PYGZus{}}\PYG{l+s}{\PYGZdq{}} \PYG{o}{+} \PYG{n}{to\PYGZus{}string}\PYG{p}{(}\PYG{n}{the\PYGZus{}task}\PYG{p}{)} \PYG{o}{+} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZus{}}\PYG{l+s}{\PYGZdq{}} \PYG{o}{+} \PYG{n}{to\PYGZus{}string}\PYG{p}{(}\PYG{n}{the\PYGZus{}seed}\PYG{p}{)} \PYG{o}{+} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{.csv}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
        \PYG{n}{out4} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{setprecision}\PYG{p}{(}\PYG{l+m+mi}{64}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{out4}\PYG{p}{.}\PYG{n}{open}\PYG{p}{(}\PYG{n}{file\PYGZus{}to\PYGZus{}open}\PYG{p}{.}\PYG{n}{c\PYGZus{}str}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{out4} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{habitat\PYGZus{}map}\PYG{p}{;}
        \PYG{n}{out4}\PYG{p}{.}\PYG{n}{close}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{catch}\PYG{p}{(}\PYG{n}{exception}\PYG{o}{\PYGZam{}} \PYG{n}{e}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{cerr} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{e}\PYG{p}{.}\PYG{n}{what}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
        \PYG{n}{cerr} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Failed to perform map dump to }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{pause\PYGZus{}folder} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{void} \PYG{n}{SpatialTree}\PYG{o}{:}\PYG{o}{:}\PYG{n}{simResume}\PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{n}{initiateResume}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
    \PYG{c+c1}{// now load the objects}
    \PYG{n}{loadMainSave}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{loadMapSave}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{setObjectSizes}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{loadActiveSave}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{loadDataSave}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{loadGridSave}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{time}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{sim\PYGZus{}start}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{writeInfo}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}r}\PYG{l+s}{Loading data from temp file...done!}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{sim\PYGZus{}parameters}\PYG{p}{.}\PYG{n}{printVars}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}



\PYG{k+kt}{void} \PYG{n}{SpatialTree}\PYG{o}{:}\PYG{o}{:}\PYG{n}{loadGridSave}\PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{n}{grid}\PYG{p}{.}\PYG{n}{SetSize}\PYG{p}{(}\PYG{n}{grid\PYGZus{}x\PYGZus{}size}\PYG{p}{,} \PYG{n}{grid\PYGZus{}y\PYGZus{}size}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{string} \PYG{n}{file\PYGZus{}to\PYGZus{}open}\PYG{p}{;}
    \PYG{k}{try}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{stringstream} \PYG{n}{os}\PYG{p}{;}
        \PYG{n}{os} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}r}\PYG{l+s}{Loading data from temp file...grid...}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{flush}\PYG{p}{;}
        \PYG{c+c1}{// New method for re\PYGZhy{}creating grid data from active lineages}
        \PYG{c+c1}{// First initialise the empty grid object}
        \PYG{n}{writeInfo}\PYG{p}{(}\PYG{n}{os}\PYG{p}{.}\PYG{n}{str}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{grid\PYGZus{}y\PYGZus{}size}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{j} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{j} \PYG{o}{\PYGZlt{}} \PYG{n}{grid\PYGZus{}x\PYGZus{}size}\PYG{p}{;} \PYG{n}{j}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{n}{grid}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{p}{.}\PYG{n}{initialise}\PYG{p}{(}\PYG{n}{habitat\PYGZus{}map}\PYG{p}{.}\PYG{n}{getVal}\PYG{p}{(}\PYG{n}{j}\PYG{p}{,} \PYG{n}{i}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{generation}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
                \PYG{n}{grid}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{p}{.}\PYG{n}{fillList}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
        \PYG{p}{\PYGZcb{}}
        \PYG{c+c1}{// Now fill the grid object with lineages from active. Only need to loop once.}
        \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{n}{endactive}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{k}{if}\PYG{p}{(}\PYG{n}{active}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getXwrap}\PYG{p}{(}\PYG{p}{)} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{0} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{n}{active}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getYwrap}\PYG{p}{(}\PYG{p}{)} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{n}{grid}\PYG{p}{[}\PYG{n}{active}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getYpos}\PYG{p}{(}\PYG{p}{)}\PYG{p}{]}\PYG{p}{[}\PYG{n}{active}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getXpos}\PYG{p}{(}\PYG{p}{)}\PYG{p}{]}\PYG{p}{.}\PYG{n}{setSpeciesEmpty}\PYG{p}{(}\PYG{n}{active}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getListpos}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{n}{i}\PYG{p}{)}\PYG{p}{;}
                \PYG{n}{grid}\PYG{p}{[}\PYG{n}{active}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getYpos}\PYG{p}{(}\PYG{p}{)}\PYG{p}{]}\PYG{p}{[}\PYG{n}{active}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getXpos}\PYG{p}{(}\PYG{p}{)}\PYG{p}{]}\PYG{p}{.}\PYG{n}{increaseListSize}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
            \PYG{k}{else}
            \PYG{p}{\PYGZob{}}
                \PYG{k}{if}\PYG{p}{(}\PYG{n}{active}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getNwrap}\PYG{p}{(}\PYG{p}{)} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)}
                \PYG{p}{\PYGZob{}}
                    \PYG{k}{throw} \PYG{n}{runtime\PYGZus{}error}\PYG{p}{(}
                            \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Nwrap should not be 0 if x and y wrap are not 0. Programming error likely.}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
                \PYG{p}{\PYGZcb{}}
                \PYG{k}{if}\PYG{p}{(}\PYG{n}{active}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getNwrap}\PYG{p}{(}\PYG{p}{)} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{)}
                \PYG{p}{\PYGZob{}}
                    \PYG{n}{grid}\PYG{p}{[}\PYG{n}{active}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getYpos}\PYG{p}{(}\PYG{p}{)}\PYG{p}{]}\PYG{p}{[}\PYG{n}{active}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getXpos}\PYG{p}{(}\PYG{p}{)}\PYG{p}{]}\PYG{p}{.}\PYG{n}{setNext}\PYG{p}{(}\PYG{n}{i}\PYG{p}{)}\PYG{p}{;}
                \PYG{p}{\PYGZcb{}}
                \PYG{n}{grid}\PYG{p}{[}\PYG{n}{active}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getYpos}\PYG{p}{(}\PYG{p}{)}\PYG{p}{]}\PYG{p}{[}\PYG{n}{active}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getXpos}\PYG{p}{(}\PYG{p}{)}\PYG{p}{]}\PYG{p}{.}\PYG{n}{increaseNwrap}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
        \PYG{p}{\PYGZcb{}}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{catch}\PYG{p}{(}\PYG{n}{exception}\PYG{o}{\PYGZam{}} \PYG{n}{e}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{string} \PYG{n}{msg}\PYG{p}{;}
        \PYG{n}{msg} \PYG{o}{=} \PYG{n}{string}\PYG{p}{(}\PYG{n}{e}\PYG{p}{.}\PYG{n}{what}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)} \PYG{o}{+} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Failure to import grid from }\PYG{l+s}{\PYGZdq{}} \PYG{o}{+} \PYG{n}{file\PYGZus{}to\PYGZus{}open}\PYG{p}{;}
        \PYG{k}{throw} \PYG{n+nf}{FatalException}\PYG{p}{(}\PYG{n}{msg}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{void} \PYG{n}{SpatialTree}\PYG{o}{:}\PYG{o}{:}\PYG{n}{loadMapSave}\PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{n}{string} \PYG{n}{file\PYGZus{}to\PYGZus{}open}\PYG{p}{;}
    \PYG{c+c1}{// Input the map object}
    \PYG{k}{try}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{stringstream} \PYG{n}{os}\PYG{p}{;}
        \PYG{n}{os} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}r}\PYG{l+s}{Loading data from temp file...map...}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{flush}\PYG{p}{;}
        \PYG{n}{writeInfo}\PYG{p}{(}\PYG{n}{os}\PYG{p}{.}\PYG{n}{str}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{ifstream} \PYG{n}{in5}\PYG{p}{;}
        \PYG{n}{file\PYGZus{}to\PYGZus{}open} \PYG{o}{=} \PYG{n}{pause\PYGZus{}sim\PYGZus{}directory} \PYG{o}{+} \PYG{n}{string}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{/Pause/Dump\PYGZus{}map\PYGZus{}}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)} \PYG{o}{+} \PYG{n}{to\PYGZus{}string}\PYG{p}{(}\PYG{n}{the\PYGZus{}task}\PYG{p}{)} \PYG{o}{+} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZus{}}\PYG{l+s}{\PYGZdq{}} \PYG{o}{+}
                       \PYG{n}{to\PYGZus{}string}\PYG{p}{(}\PYG{n}{the\PYGZus{}seed}\PYG{p}{)} \PYG{o}{+} \PYG{n}{string}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{.csv}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{in5}\PYG{p}{.}\PYG{n}{open}\PYG{p}{(}\PYG{n}{file\PYGZus{}to\PYGZus{}open}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{in5} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{habitat\PYGZus{}map}\PYG{p}{;}
        \PYG{n}{in5}\PYG{p}{.}\PYG{n}{close}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{importReproductionMap}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{catch}\PYG{p}{(}\PYG{n}{exception}\PYG{o}{\PYGZam{}} \PYG{n}{e}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{string} \PYG{n}{msg}\PYG{p}{;}
        \PYG{n}{msg} \PYG{o}{=} \PYG{n}{string}\PYG{p}{(}\PYG{n}{e}\PYG{p}{.}\PYG{n}{what}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)} \PYG{o}{+} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Failure to import map from }\PYG{l+s}{\PYGZdq{}} \PYG{o}{+} \PYG{n}{file\PYGZus{}to\PYGZus{}open}\PYG{p}{;}
        \PYG{k}{throw} \PYG{n+nf}{FatalException}\PYG{p}{(}\PYG{n}{msg}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{void} \PYG{n}{SpatialTree}\PYG{o}{:}\PYG{o}{:}\PYG{n}{verifyReproductionMap}\PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k}{if}\PYG{p}{(}\PYG{o}{!}\PYG{p}{(}\PYG{n}{sim\PYGZus{}parameters}\PYG{p}{.}\PYG{n}{reproduction\PYGZus{}file} \PYG{o}{=}\PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{none}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\textbar{}}\PYG{o}{\textbar{}} \PYG{n}{sim\PYGZus{}parameters}\PYG{p}{.}\PYG{n}{reproduction\PYGZus{}file} \PYG{o}{=}\PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{null}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{sim\PYGZus{}parameters}\PYG{p}{.}\PYG{n}{fine\PYGZus{}map\PYGZus{}y\PYGZus{}size}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{j} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{j} \PYG{o}{\PYGZlt{}} \PYG{n}{sim\PYGZus{}parameters}\PYG{p}{.}\PYG{n}{fine\PYGZus{}map\PYGZus{}x\PYGZus{}size}\PYG{p}{;} \PYG{n}{j} \PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{k}{if}\PYG{p}{(}\PYG{n}{rep\PYGZus{}map}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mf}{0.0} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{n}{habitat\PYGZus{}map}\PYG{p}{.}\PYG{n}{getValFine}\PYG{p}{(}\PYG{n}{j}\PYG{p}{,} \PYG{n}{i}\PYG{p}{,} \PYG{l+m+mf}{0.0}\PYG{p}{)} \PYG{o}{!}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)}
                \PYG{p}{\PYGZob{}}
                    \PYG{k}{throw} \PYG{n}{FatalException}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Reproduction map is zero where density is non\PYGZhy{}zero. }\PYG{l+s}{\PYGZdq{}}
                                                 \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{This will cause an infinite loop.}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
                \PYG{p}{\PYGZcb{}}
                \PYG{k}{if}\PYG{p}{(}\PYG{n}{habitat\PYGZus{}map}\PYG{p}{.}\PYG{n}{getValFine}\PYG{p}{(}\PYG{n}{j}\PYG{p}{,} \PYG{n}{i}\PYG{p}{,} \PYG{l+m+mf}{0.0}\PYG{p}{)} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{0} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{n}{rep\PYGZus{}map}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]} \PYG{o}{!}\PYG{o}{=} \PYG{l+m+mf}{0.0}\PYG{p}{)}
                \PYG{p}{\PYGZob{}}
                    \PYG{n}{writeCritical}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Density is zero where reproduction map is non\PYGZhy{}zero. This is likely incorrect.}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
                \PYG{p}{\PYGZcb{}}
            \PYG{p}{\PYGZcb{}}
        \PYG{p}{\PYGZcb{}}
    \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{void} \PYG{n}{SpatialTree}\PYG{o}{:}\PYG{o}{:}\PYG{n}{addWrappedLineage}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{numstart}\PYG{p}{,} \PYG{k+kt}{long} \PYG{n}{x}\PYG{p}{,} \PYG{k+kt}{long} \PYG{n}{y}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k}{if}\PYG{p}{(}\PYG{n}{grid}\PYG{p}{[}\PYG{n}{y}\PYG{p}{]}\PYG{p}{[}\PYG{n}{x}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getNwrap}\PYG{p}{(}\PYG{p}{)} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{grid}\PYG{p}{[}\PYG{n}{y}\PYG{p}{]}\PYG{p}{[}\PYG{n}{x}\PYG{p}{]}\PYG{p}{.}\PYG{n}{setNext}\PYG{p}{(}\PYG{n}{numstart}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{grid}\PYG{p}{[}\PYG{n}{y}\PYG{p}{]}\PYG{p}{[}\PYG{n}{x}\PYG{p}{]}\PYG{p}{.}\PYG{n}{setNwrap}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{active}\PYG{p}{[}\PYG{n}{numstart}\PYG{p}{]}\PYG{p}{.}\PYG{n}{setNwrap}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{else}
    \PYG{p}{\PYGZob{}}
        \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{tmp\PYGZus{}next} \PYG{o}{=} \PYG{n}{grid}\PYG{p}{[}\PYG{n}{y}\PYG{p}{]}\PYG{p}{[}\PYG{n}{x}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getNext}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
        \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{tmp\PYGZus{}last} \PYG{o}{=} \PYG{n}{tmp\PYGZus{}next}\PYG{p}{;}
        \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{tmp\PYGZus{}nwrap} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
        \PYG{k}{while}\PYG{p}{(}\PYG{n}{tmp\PYGZus{}next} \PYG{o}{!}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{tmp\PYGZus{}nwrap} \PYG{o}{+}\PYG{o}{+}\PYG{p}{;}
            \PYG{n}{tmp\PYGZus{}last} \PYG{o}{=} \PYG{n}{tmp\PYGZus{}next}\PYG{p}{;}
            \PYG{n}{tmp\PYGZus{}next} \PYG{o}{=} \PYG{n}{active}\PYG{p}{[}\PYG{n}{tmp\PYGZus{}next}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getNext}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{n}{grid}\PYG{p}{[}\PYG{n}{y}\PYG{p}{]}\PYG{p}{[}\PYG{n}{x}\PYG{p}{]}\PYG{p}{.}\PYG{n}{increaseNwrap}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{active}\PYG{p}{[}\PYG{n}{tmp\PYGZus{}last}\PYG{p}{]}\PYG{p}{.}\PYG{n}{setNext}\PYG{p}{(}\PYG{n}{numstart}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{active}\PYG{p}{[}\PYG{n}{numstart}\PYG{p}{]}\PYG{p}{.}\PYG{n}{setNwrap}\PYG{p}{(}\PYG{n}{tmp\PYGZus{}nwrap} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifdef DEBUG}
    \PYG{n}{debugAddingLineage}\PYG{p}{(}\PYG{n}{numstart}\PYG{p}{,} \PYG{n}{x}\PYG{p}{,} \PYG{n}{y}\PYG{p}{)}\PYG{p}{;}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif}
\PYG{p}{\PYGZcb{}}


\PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{SpatialTree}\PYG{o}{:}\PYG{o}{:}\PYG{n}{countCellExpansion}\PYG{p}{(}\PYG{k}{const} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{x}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{y}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{xwrap}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{ywrap}\PYG{p}{,}
                                       \PYG{k}{const} \PYG{k+kt}{double} \PYG{o}{\PYGZam{}}\PYG{n}{generation\PYGZus{}in}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{bool}\PYG{o}{\PYGZam{}} \PYG{n}{make\PYGZus{}tips}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{map\PYGZus{}cover} \PYG{o}{=} \PYG{n}{habitat\PYGZus{}map}\PYG{p}{.}\PYG{n}{getVal}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,} \PYG{n}{y}\PYG{p}{,} \PYG{n}{xwrap}\PYG{p}{,} \PYG{n}{ywrap}\PYG{p}{,} \PYG{n}{generation\PYGZus{}in}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{// think I fixed a bug here...}
    \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{num\PYGZus{}to\PYGZus{}add} \PYG{o}{=} \PYG{k}{static\PYGZus{}cast}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{unsigned} \PYG{k+kt}{long}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{n}{max}\PYG{p}{(}\PYG{n}{floor}\PYG{p}{(}\PYG{n}{map\PYGZus{}cover} \PYG{o}{*} \PYG{n}{deme\PYGZus{}sample} \PYG{o}{*}
                                                                            \PYG{n}{samplegrid}\PYG{p}{.}\PYG{n}{getExactValue}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,} \PYG{n}{y}\PYG{p}{,}
                                                                                                     \PYG{n}{xwrap}\PYG{p}{,} \PYG{n}{ywrap}\PYG{p}{)}\PYG{p}{)}\PYG{p}{,}
                                                              \PYG{l+m+mf}{0.0}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
    \PYG{k}{if}\PYG{p}{(}\PYG{n}{xwrap} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{0} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{n}{ywrap} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{ref} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{map\PYGZus{}cover} \PYG{o}{\PYGZgt{}}\PYG{o}{=} \PYG{n}{grid}\PYG{p}{[}\PYG{n}{y}\PYG{p}{]}\PYG{p}{[}\PYG{n}{x}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getMaxsize}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{grid}\PYG{p}{[}\PYG{n}{y}\PYG{p}{]}\PYG{p}{[}\PYG{n}{x}\PYG{p}{]}\PYG{p}{.}\PYG{n}{changePercentCover}\PYG{p}{(}\PYG{n}{map\PYGZus{}cover}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{while}\PYG{p}{(}\PYG{n}{ref} \PYG{o}{\PYGZlt{}} \PYG{n}{grid}\PYG{p}{[}\PYG{n}{y}\PYG{p}{]}\PYG{p}{[}\PYG{n}{x}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getMaxsize}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{n}{num\PYGZus{}to\PYGZus{}add} \PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{0}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{tmp\PYGZus{}active} \PYG{o}{=} \PYG{n}{grid}\PYG{p}{[}\PYG{n}{y}\PYG{p}{]}\PYG{p}{[}\PYG{n}{x}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getSpecies}\PYG{p}{(}\PYG{n}{ref}\PYG{p}{)}\PYG{p}{;}
            \PYG{k}{if}\PYG{p}{(}\PYG{n}{tmp\PYGZus{}active} \PYG{o}{!}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{k}{if}\PYG{p}{(}\PYG{n}{make\PYGZus{}tips}\PYG{p}{)}
                \PYG{p}{\PYGZob{}}
                    \PYG{n}{makeTip}\PYG{p}{(}\PYG{n}{tmp\PYGZus{}active}\PYG{p}{,} \PYG{n}{generation\PYGZus{}in}\PYG{p}{)}\PYG{p}{;}
                \PYG{p}{\PYGZcb{}}
                \PYG{n}{num\PYGZus{}to\PYGZus{}add} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
            \PYG{n}{ref} \PYG{o}{+}\PYG{o}{+}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{else}
    \PYG{p}{\PYGZob{}}
        \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{next} \PYG{o}{=} \PYG{n}{grid}\PYG{p}{[}\PYG{n}{y}\PYG{p}{]}\PYG{p}{[}\PYG{n}{x}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getNext}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{while}\PYG{p}{(}\PYG{n}{next} \PYG{o}{!}\PYG{o}{=} \PYG{l+m+mi}{0} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{n}{num\PYGZus{}to\PYGZus{}add} \PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{0}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{k}{if}\PYG{p}{(}\PYG{n}{active}\PYG{p}{[}\PYG{n}{next}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getXwrap}\PYG{p}{(}\PYG{p}{)} \PYG{o}{=}\PYG{o}{=} \PYG{n}{xwrap} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{n}{active}\PYG{p}{[}\PYG{n}{next}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getYwrap}\PYG{p}{(}\PYG{p}{)} \PYG{o}{=}\PYG{o}{=} \PYG{n}{ywrap}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{n}{num\PYGZus{}to\PYGZus{}add}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{p}{;}
                \PYG{k}{if}\PYG{p}{(}\PYG{n}{make\PYGZus{}tips}\PYG{p}{)}
                \PYG{p}{\PYGZob{}}
                    \PYG{n}{makeTip}\PYG{p}{(}\PYG{n}{next}\PYG{p}{,} \PYG{n}{generation\PYGZus{}in}\PYG{p}{)}\PYG{p}{;}
                \PYG{p}{\PYGZcb{}}
            \PYG{p}{\PYGZcb{}}
            \PYG{n}{next} \PYG{o}{=} \PYG{n}{active}\PYG{p}{[}\PYG{n}{next}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getNext}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{return} \PYG{n}{num\PYGZus{}to\PYGZus{}add}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{void} \PYG{n}{SpatialTree}\PYG{o}{:}\PYG{o}{:}\PYG{n}{expandCell}\PYG{p}{(}\PYG{k+kt}{long} \PYG{n}{x}\PYG{p}{,} \PYG{k+kt}{long} \PYG{n}{y}\PYG{p}{,} \PYG{k+kt}{long} \PYG{n}{x\PYGZus{}wrap}\PYG{p}{,} \PYG{k+kt}{long} \PYG{n}{y\PYGZus{}wrap}\PYG{p}{,} \PYG{k+kt}{double} \PYG{n}{generation\PYGZus{}in}\PYG{p}{,} \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{num\PYGZus{}to\PYGZus{}add}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k}{if}\PYG{p}{(}\PYG{n}{num\PYGZus{}to\PYGZus{}add} \PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{0}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{k} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{k} \PYG{o}{\PYGZlt{}} \PYG{n}{num\PYGZus{}to\PYGZus{}add}\PYG{p}{;} \PYG{n}{k} \PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{endactive} \PYG{o}{+}\PYG{o}{+}\PYG{p}{;}
            \PYG{n}{enddata} \PYG{o}{+}\PYG{o}{+}\PYG{p}{;}
            \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{listpos} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
            \PYG{c+c1}{// Add the species to active}
            \PYG{k}{if}\PYG{p}{(}\PYG{n}{x\PYGZus{}wrap} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{0} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{n}{y\PYGZus{}wrap} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{n}{listpos} \PYG{o}{=} \PYG{n}{grid}\PYG{p}{[}\PYG{n}{y}\PYG{p}{]}\PYG{p}{[}\PYG{n}{x}\PYG{p}{]}\PYG{p}{.}\PYG{n}{addSpecies}\PYG{p}{(}\PYG{n}{endactive}\PYG{p}{)}\PYG{p}{;}
                \PYG{n}{active}\PYG{p}{[}\PYG{n}{endactive}\PYG{p}{]}\PYG{p}{.}\PYG{n}{setup}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,} \PYG{n}{y}\PYG{p}{,} \PYG{n}{x\PYGZus{}wrap}\PYG{p}{,} \PYG{n}{y\PYGZus{}wrap}\PYG{p}{,} \PYG{n}{enddata}\PYG{p}{,} \PYG{n}{listpos}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
            \PYG{k}{else}
            \PYG{p}{\PYGZob{}}
                \PYG{n}{active}\PYG{p}{[}\PYG{n}{endactive}\PYG{p}{]}\PYG{p}{.}\PYG{n}{setup}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,} \PYG{n}{y}\PYG{p}{,} \PYG{n}{x\PYGZus{}wrap}\PYG{p}{,} \PYG{n}{y\PYGZus{}wrap}\PYG{p}{,} \PYG{n}{enddata}\PYG{p}{,} \PYG{n}{listpos}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
                \PYG{n}{addWrappedLineage}\PYG{p}{(}\PYG{n}{endactive}\PYG{p}{,} \PYG{n}{x}\PYG{p}{,} \PYG{n}{y}\PYG{p}{)}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
            \PYG{k}{if}\PYG{p}{(}\PYG{n}{enddata} \PYG{o}{\PYGZgt{}}\PYG{o}{=} \PYG{n}{data}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{k}{throw} \PYG{n}{FatalException}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Cannot add lineage \PYGZhy{} no space in data. }\PYG{l+s}{\PYGZdq{}}
                                              \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Check size calculations.}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
            \PYG{k}{if}\PYG{p}{(}\PYG{n}{endactive} \PYG{o}{\PYGZgt{}}\PYG{o}{=} \PYG{n}{active}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{k}{throw} \PYG{n}{FatalException}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Cannot add lineage \PYGZhy{} no space in active. }\PYG{l+s}{\PYGZdq{}}
                                              \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Check size calculations.}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}

            \PYG{c+c1}{// Add a tip in the TreeNode for calculation of the coalescence tree at the}
            \PYG{c+c1}{// end of the simulation.}
            \PYG{c+c1}{// This also contains the start x and y position of the species.}
            \PYG{n}{data}\PYG{p}{[}\PYG{n}{enddata}\PYG{p}{]}\PYG{p}{.}\PYG{n}{setup}\PYG{p}{(}\PYG{n+nb}{true}\PYG{p}{,} \PYG{n}{x}\PYG{p}{,} \PYG{n}{y}\PYG{p}{,} \PYG{n}{x\PYGZus{}wrap}\PYG{p}{,} \PYG{n}{y\PYGZus{}wrap}\PYG{p}{,} \PYG{n}{generation\PYGZus{}in}\PYG{p}{)}\PYG{p}{;}
            \PYG{n}{data}\PYG{p}{[}\PYG{n}{enddata}\PYG{p}{]}\PYG{p}{.}\PYG{n}{setSpec}\PYG{p}{(}\PYG{n}{NR}\PYG{p}{.}\PYG{n}{d01}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
    \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}

\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifdef DEBUG}
\PYG{k+kt}{void} \PYG{n}{SpatialTree}\PYG{o}{:}\PYG{o}{:}\PYG{n}{validateLineages}\PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k+kt}{bool} \PYG{n}{fail} \PYG{o}{=} \PYG{n+nb}{false}\PYG{p}{;}
    \PYG{n}{writeInfo}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{Starting lineage validation...}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{printed} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
    \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{endactive}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{stringstream} \PYG{n}{ss}\PYG{p}{;}
        \PYG{n}{DataPoint} \PYG{n}{tmp\PYGZus{}datapoint} \PYG{o}{=} \PYG{n}{active}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{;}
        \PYG{c+c1}{// Validate the location exists}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{habitat\PYGZus{}map}\PYG{p}{.}\PYG{n}{getVal}\PYG{p}{(}\PYG{n}{tmp\PYGZus{}datapoint}\PYG{p}{.}\PYG{n}{getXpos}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{n}{tmp\PYGZus{}datapoint}\PYG{p}{.}\PYG{n}{getYpos}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,}
                            \PYG{n}{tmp\PYGZus{}datapoint}\PYG{p}{.}\PYG{n}{getXwrap}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{n}{tmp\PYGZus{}datapoint}\PYG{p}{.}\PYG{n}{getYwrap}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{l+m+mf}{0.0}\PYG{p}{)} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{k}{if}\PYG{p}{(}\PYG{n}{printed} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{100}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{n}{printed} \PYG{o}{+}\PYG{o}{+}\PYG{p}{;}
                \PYG{n}{ss} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Map value: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{habitat\PYGZus{}map}\PYG{p}{.}\PYG{n}{getVal}\PYG{p}{(}\PYG{n}{tmp\PYGZus{}datapoint}\PYG{p}{.}\PYG{n}{getXpos}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{n}{tmp\PYGZus{}datapoint}\PYG{p}{.}\PYG{n}{getYpos}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,}
                                                           \PYG{n}{tmp\PYGZus{}datapoint}\PYG{p}{.}\PYG{n}{getXwrap}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{n}{tmp\PYGZus{}datapoint}\PYG{p}{.}\PYG{n}{getYwrap}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,}
                                                           \PYG{l+m+mf}{0.0}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
            \PYG{n}{fail} \PYG{o}{=} \PYG{n+nb}{true}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{tmp\PYGZus{}datapoint}\PYG{p}{.}\PYG{n}{getXwrap}\PYG{p}{(}\PYG{p}{)} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{0} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{n}{tmp\PYGZus{}datapoint}\PYG{p}{.}\PYG{n}{getYwrap}\PYG{p}{(}\PYG{p}{)} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{k}{if}\PYG{p}{(}\PYG{n}{tmp\PYGZus{}datapoint}\PYG{p}{.}\PYG{n}{getNwrap}\PYG{p}{(}\PYG{p}{)} \PYG{o}{!}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{n}{fail} \PYG{o}{=} \PYG{n+nb}{true}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
            \PYG{k}{else}
            \PYG{p}{\PYGZob{}}
                \PYG{k}{if}\PYG{p}{(}\PYG{n}{i} \PYG{o}{!}\PYG{o}{=}
                   \PYG{n}{grid}\PYG{p}{[}\PYG{n}{tmp\PYGZus{}datapoint}\PYG{p}{.}\PYG{n}{getYpos}\PYG{p}{(}\PYG{p}{)}\PYG{p}{]}\PYG{p}{[}\PYG{n}{tmp\PYGZus{}datapoint}\PYG{p}{.}\PYG{n}{getXpos}\PYG{p}{(}\PYG{p}{)}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getSpecies}\PYG{p}{(}\PYG{n}{tmp\PYGZus{}datapoint}\PYG{p}{.}\PYG{n}{getListpos}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
                \PYG{p}{\PYGZob{}}
                    \PYG{n}{fail} \PYG{o}{=} \PYG{n+nb}{true}\PYG{p}{;}
                \PYG{p}{\PYGZcb{}}
            \PYG{p}{\PYGZcb{}}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{else}
        \PYG{p}{\PYGZob{}}
            \PYG{k}{if}\PYG{p}{(}\PYG{n}{tmp\PYGZus{}datapoint}\PYG{p}{.}\PYG{n}{getNwrap}\PYG{p}{(}\PYG{p}{)} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{n}{fail} \PYG{o}{=} \PYG{n+nb}{true}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
            \PYG{k}{else}
            \PYG{p}{\PYGZob{}}
                \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{tmp\PYGZus{}next} \PYG{o}{=} \PYG{n}{grid}\PYG{p}{[}\PYG{n}{tmp\PYGZus{}datapoint}\PYG{p}{.}\PYG{n}{getYpos}\PYG{p}{(}\PYG{p}{)}\PYG{p}{]}\PYG{p}{[}\PYG{n}{tmp\PYGZus{}datapoint}\PYG{p}{.}\PYG{n}{getXpos}\PYG{p}{(}\PYG{p}{)}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getNext}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
                \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{count} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
                \PYG{k}{while}\PYG{p}{(}\PYG{n}{tmp\PYGZus{}next} \PYG{o}{!}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)}
                \PYG{p}{\PYGZob{}}
                    \PYG{n}{count}\PYG{o}{+}\PYG{o}{+}\PYG{p}{;}
                    \PYG{k}{if}\PYG{p}{(}\PYG{n}{count} \PYG{o}{!}\PYG{o}{=} \PYG{n}{active}\PYG{p}{[}\PYG{n}{tmp\PYGZus{}next}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getNwrap}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
                    \PYG{p}{\PYGZob{}}
                        \PYG{n}{ss} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{problem in wrap: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{count} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ != }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{active}\PYG{p}{[}\PYG{n}{tmp\PYGZus{}next}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getNwrap}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
                        \PYG{n}{fail} \PYG{o}{=} \PYG{n+nb}{true}\PYG{p}{;}
                    \PYG{p}{\PYGZcb{}}
                    \PYG{n}{tmp\PYGZus{}next} \PYG{o}{=} \PYG{n}{active}\PYG{p}{[}\PYG{n}{tmp\PYGZus{}next}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getNext}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
                \PYG{p}{\PYGZcb{}}
                \PYG{k}{if}\PYG{p}{(}\PYG{n}{count} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{0} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{n}{count} \PYG{o}{!}\PYG{o}{=} \PYG{n}{grid}\PYG{p}{[}\PYG{n}{tmp\PYGZus{}datapoint}\PYG{p}{.}\PYG{n}{getYpos}\PYG{p}{(}\PYG{p}{)}\PYG{p}{]}\PYG{p}{[}\PYG{n}{tmp\PYGZus{}datapoint}\PYG{p}{.}\PYG{n}{getXpos}\PYG{p}{(}\PYG{p}{)}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getNwrap}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
                \PYG{p}{\PYGZob{}}
                    \PYG{n}{fail} \PYG{o}{=} \PYG{n+nb}{true}\PYG{p}{;}
                \PYG{p}{\PYGZcb{}}
                \PYG{k}{if}\PYG{p}{(}\PYG{n}{count} \PYG{o}{!}\PYG{o}{=} \PYG{n}{grid}\PYG{p}{[}\PYG{n}{tmp\PYGZus{}datapoint}\PYG{p}{.}\PYG{n}{getYpos}\PYG{p}{(}\PYG{p}{)}\PYG{p}{]}\PYG{p}{[}\PYG{n}{tmp\PYGZus{}datapoint}\PYG{p}{.}\PYG{n}{getXpos}\PYG{p}{(}\PYG{p}{)}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getNwrap}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
                \PYG{p}{\PYGZob{}}
                    \PYG{n}{fail} \PYG{o}{=} \PYG{n+nb}{true}\PYG{p}{;}
                \PYG{p}{\PYGZcb{}}
            \PYG{p}{\PYGZcb{}}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{fail}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{stringstream} \PYG{n}{ss}\PYG{p}{;}
            \PYG{n}{ss} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{active reference: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{i} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
            \PYG{n}{ss} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Grid wrapping: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{grid}\PYG{p}{[}\PYG{n}{tmp\PYGZus{}datapoint}\PYG{p}{.}\PYG{n}{getYpos}\PYG{p}{(}\PYG{p}{)}\PYG{p}{]}\PYG{p}{[}\PYG{n}{tmp\PYGZus{}datapoint}\PYG{p}{.}\PYG{n}{getXpos}\PYG{p}{(}\PYG{p}{)}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getNwrap}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
            \PYG{n}{writeLog}\PYG{p}{(}\PYG{l+m+mi}{50}\PYG{p}{,} \PYG{n}{ss}\PYG{p}{)}\PYG{p}{;}
            \PYG{n}{tmp\PYGZus{}datapoint}\PYG{p}{.}\PYG{n}{logActive}\PYG{p}{(}\PYG{l+m+mi}{50}\PYG{p}{)}\PYG{p}{;}
            \PYG{k}{throw} \PYG{n+nf}{FatalException}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Failure in lineage validation. Please report this bug.}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
    \PYG{p}{\PYGZcb{}}
    \PYG{n}{writeInfo}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{done}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{void} \PYG{n}{SpatialTree}\PYG{o}{:}\PYG{o}{:}\PYG{n}{debugAddingLineage}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{numstart}\PYG{p}{,} \PYG{k+kt}{long} \PYG{n}{x}\PYG{p}{,} \PYG{k+kt}{long} \PYG{n}{y}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{tmp\PYGZus{}next} \PYG{o}{=} \PYG{n}{grid}\PYG{p}{[}\PYG{n}{y}\PYG{p}{]}\PYG{p}{[}\PYG{n}{x}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getNext}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{tmp\PYGZus{}nwrap} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
    \PYG{k}{while}\PYG{p}{(}\PYG{n}{tmp\PYGZus{}next} \PYG{o}{!}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{tmp\PYGZus{}nwrap} \PYG{o}{+}\PYG{o}{+}\PYG{p}{;}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{active}\PYG{p}{[}\PYG{n}{tmp\PYGZus{}next}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getNwrap}\PYG{p}{(}\PYG{p}{)} \PYG{o}{!}\PYG{o}{=} \PYG{n}{tmp\PYGZus{}nwrap}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{stringstream} \PYG{n}{ss}\PYG{p}{;}
            \PYG{n}{ss} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{tmp\PYGZus{}nwrap: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{tmp\PYGZus{}nwrap} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
            \PYG{n}{ss} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{next = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{tmp\PYGZus{}next} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
            \PYG{n}{ss} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{numstart: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{numstart} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
            \PYG{n}{writeLog}\PYG{p}{(}\PYG{l+m+mi}{50}\PYG{p}{,} \PYG{n}{ss}\PYG{p}{)}\PYG{p}{;}
            \PYG{n}{active}\PYG{p}{[}\PYG{n}{tmp\PYGZus{}nwrap}\PYG{p}{]}\PYG{p}{.}\PYG{n}{logActive}\PYG{p}{(}\PYG{l+m+mi}{50}\PYG{p}{)}\PYG{p}{;}
            \PYG{k}{throw} \PYG{n+nf}{FatalException}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Incorrect setting of nwrap in wrapped lineage, please report this bug.}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{n}{tmp\PYGZus{}next} \PYG{o}{=} \PYG{n}{active}\PYG{p}{[}\PYG{n}{tmp\PYGZus{}next}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getNext}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{if}\PYG{p}{(}\PYG{n}{tmp\PYGZus{}nwrap} \PYG{o}{!}\PYG{o}{=} \PYG{n}{grid}\PYG{p}{[}\PYG{n}{y}\PYG{p}{]}\PYG{p}{[}\PYG{n}{x}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getNwrap}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{stringstream} \PYG{n}{ss}\PYG{p}{;}
        \PYG{n}{ss} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Grid nwrap: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{grid}\PYG{p}{[}\PYG{n}{y}\PYG{p}{]}\PYG{p}{[}\PYG{n}{x}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getNwrap}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
        \PYG{n}{ss} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Counted wrapping: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{tmp\PYGZus{}nwrap} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
        \PYG{n}{ss} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{active: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{numstart} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
        \PYG{n}{tmp\PYGZus{}next} \PYG{o}{=} \PYG{n}{grid}\PYG{p}{[}\PYG{n}{y}\PYG{p}{]}\PYG{p}{[}\PYG{n}{x}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getNext}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{tmp\PYGZus{}nwrap} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
        \PYG{k}{while}\PYG{p}{(}\PYG{n}{tmp\PYGZus{}next} \PYG{o}{!}\PYG{o}{=} \PYG{l+m+mi}{0} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{n}{tmp\PYGZus{}nwrap} \PYG{o}{\PYGZlt{}} \PYG{n}{grid}\PYG{p}{[}\PYG{n}{y}\PYG{p}{]}\PYG{p}{[}\PYG{n}{x}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getNwrap}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{tmp\PYGZus{}nwrap} \PYG{o}{+}\PYG{o}{+}\PYG{p}{;}
            \PYG{n}{ss} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{tmp\PYGZus{}next: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{tmp\PYGZus{}next} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
            \PYG{n}{ss} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{tmp\PYGZus{}nwrap: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{tmp\PYGZus{}nwrap} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
            \PYG{n}{tmp\PYGZus{}next} \PYG{o}{=} \PYG{n}{active}\PYG{p}{[}\PYG{n}{tmp\PYGZus{}next}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getNext}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{n}{writeLog}\PYG{p}{(}\PYG{l+m+mi}{50}\PYG{p}{,} \PYG{n}{ss}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{throw} \PYG{n+nf}{FatalException}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Grid wrapping value not set correctly}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{void} \PYG{n}{SpatialTree}\PYG{o}{:}\PYG{o}{:}\PYG{n}{runChecks}\PYG{p}{(}\PYG{k}{const} \PYG{k+kt}{unsigned} \PYG{k+kt}{long}\PYG{o}{\PYGZam{}} \PYG{n}{chosen}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{unsigned} \PYG{k+kt}{long}\PYG{o}{\PYGZam{}} \PYG{n}{coalchosen}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
\PYG{c+c1}{// final checks}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifdef pristine\PYGZus{}mode}
    \PYG{k}{if}\PYG{p}{(}\PYG{n}{active}\PYG{p}{[}\PYG{n}{chosen}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getListpos}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZgt{}} \PYG{n}{grid}\PYG{p}{[}\PYG{n}{active}\PYG{p}{[}\PYG{n}{chosen}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getYpos}\PYG{p}{(}\PYG{p}{)}\PYG{p}{]}\PYG{p}{[}\PYG{n}{active}\PYG{p}{[}\PYG{n}{chosen}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getXpos}\PYG{p}{(}\PYG{p}{)}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getMaxsize}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}}
       \PYG{n}{active}\PYG{p}{[}\PYG{n}{chosen}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getNwrap}\PYG{p}{(}\PYG{p}{)} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{c+c1}{//              usleep(1);}
        \PYG{n}{cerr} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{list\PYGZus{}position: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{active}\PYG{p}{[}\PYG{n}{chosen}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getListpos}\PYG{p}{(}\PYG{p}{)}
             \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ maxsize: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{grid}\PYG{p}{[}\PYG{n}{active}\PYG{p}{[}\PYG{n}{chosen}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getYpos}\PYG{p}{(}\PYG{p}{)}\PYG{p}{]}\PYG{p}{[}\PYG{n}{active}\PYG{p}{[}\PYG{n}{chosen}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getXpos}\PYG{p}{(}\PYG{p}{)}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getMaxsize}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
        \PYG{k}{throw} \PYG{n+nf}{FatalException}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ERROR\PYGZus{}MOVE\PYGZus{}001: Listpos outside maxsize.}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{k}{if}\PYG{p}{(}\PYG{n}{active}\PYG{p}{[}\PYG{n}{coalchosen}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getListpos}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZgt{}}
           \PYG{n}{grid}\PYG{p}{[}\PYG{n}{active}\PYG{p}{[}\PYG{n}{coalchosen}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getYpos}\PYG{p}{(}\PYG{p}{)}\PYG{p}{]}\PYG{p}{[}\PYG{n}{active}\PYG{p}{[}\PYG{n}{coalchosen}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getXpos}\PYG{p}{(}\PYG{p}{)}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getMaxsize}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}}
       \PYG{n}{active}\PYG{p}{[}\PYG{n}{coalchosen}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getNwrap}\PYG{p}{(}\PYG{p}{)} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{0} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{n}{coalchosen} \PYG{o}{!}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{c+c1}{//              usleep(1);}
        \PYG{k}{throw} \PYG{n}{FatalException}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ERROR\PYGZus{}MOVE\PYGZus{}002: Coalchosen list\PYGZus{}position outside maxsize.}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif}
    \PYG{n}{Tree}\PYG{o}{:}\PYG{o}{:}\PYG{n}{runChecks}\PYG{p}{(}\PYG{n}{chosen}\PYG{p}{,} \PYG{n}{coalchosen}\PYG{p}{)}\PYG{p}{;}
    \PYG{k}{if}\PYG{p}{(}\PYG{n}{active}\PYG{p}{[}\PYG{n}{chosen}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getNwrap}\PYG{p}{(}\PYG{p}{)} \PYG{o}{!}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{tmpactive} \PYG{o}{=} \PYG{n}{grid}\PYG{p}{[}\PYG{n}{active}\PYG{p}{[}\PYG{n}{chosen}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getYpos}\PYG{p}{(}\PYG{p}{)}\PYG{p}{]}\PYG{p}{[}\PYG{n}{active}\PYG{p}{[}\PYG{n}{chosen}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getXpos}\PYG{p}{(}\PYG{p}{)}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getNext}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{active}\PYG{p}{[}\PYG{n}{chosen}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getNwrap}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{tmpactive} \PYG{o}{=} \PYG{n}{active}\PYG{p}{[}\PYG{n}{tmpactive}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getNext}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}

        \PYG{k}{if}\PYG{p}{(}\PYG{n}{tmpactive} \PYG{o}{!}\PYG{o}{=} \PYG{n}{chosen}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{active}\PYG{p}{[}\PYG{n}{chosen}\PYG{p}{]}\PYG{p}{.}\PYG{n}{logActive}\PYG{p}{(}\PYG{l+m+mi}{50}\PYG{p}{)}\PYG{p}{;}
            \PYG{k}{throw} \PYG{n+nf}{FatalException}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ERROR\PYGZus{}MOVE\PYGZus{}003: Nwrap not set correctly.}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
    \PYG{p}{\PYGZcb{}}

    \PYG{k}{if}\PYG{p}{(}\PYG{n}{active}\PYG{p}{[}\PYG{n}{chosen}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getNwrap}\PYG{p}{(}\PYG{p}{)} \PYG{o}{!}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{active}\PYG{p}{[}\PYG{n}{chosen}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getXwrap}\PYG{p}{(}\PYG{p}{)} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{0} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{n}{active}\PYG{p}{[}\PYG{n}{chosen}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getYwrap}\PYG{p}{(}\PYG{p}{)} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{k}{throw} \PYG{n}{FatalException}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ERROR\PYGZus{}MOVE\PYGZus{}10: Nwrap set to non\PYGZhy{}zero, but x and y wrap 0.}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{if}\PYG{p}{(}\PYG{n}{active}\PYG{p}{[}\PYG{n}{endactive}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getNwrap}\PYG{p}{(}\PYG{p}{)} \PYG{o}{!}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{nwrap} \PYG{o}{=} \PYG{n}{active}\PYG{p}{[}\PYG{n}{endactive}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getNwrap}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{nwrap} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{k}{if}\PYG{p}{(}\PYG{n}{grid}\PYG{p}{[}\PYG{n}{active}\PYG{p}{[}\PYG{n}{endactive}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getYpos}\PYG{p}{(}\PYG{p}{)}\PYG{p}{]}\PYG{p}{[}\PYG{n}{active}\PYG{p}{[}\PYG{n}{endactive}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getXpos}\PYG{p}{(}\PYG{p}{)}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getNext}\PYG{p}{(}\PYG{p}{)} \PYG{o}{!}\PYG{o}{=} \PYG{n}{endactive}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{n}{stringstream} \PYG{n}{ss}\PYG{p}{;}
                \PYG{n}{ss} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Lineage at 1st position: }\PYG{l+s}{\PYGZdq{}}
                   \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{grid}\PYG{p}{[}\PYG{n}{active}\PYG{p}{[}\PYG{n}{endactive}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getYpos}\PYG{p}{(}\PYG{p}{)}\PYG{p}{]}\PYG{p}{[}\PYG{n}{active}\PYG{p}{[}\PYG{n}{endactive}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getXpos}\PYG{p}{(}\PYG{p}{)}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getNext}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
                \PYG{n}{ss} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{endactive: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endactive} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}
                   \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{nwrap: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{nwrap} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
                \PYG{n}{ss} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{chosen: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{chosen} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
                \PYG{n}{writeLog}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{,} \PYG{n}{ss}\PYG{p}{)}\PYG{p}{;}
                \PYG{k}{throw} \PYG{n+nf}{FatalException}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ERROR\PYGZus{}MOVE\PYGZus{}016: Nwrap for endactive not set correctly. Nwrap is 1, }\PYG{l+s}{\PYGZdq{}}
                                              \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{but the lineage at 1st position is not endactive.}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{else}
        \PYG{p}{\PYGZob{}}
            \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{tmpcheck} \PYG{o}{=} \PYG{n}{grid}\PYG{p}{[}\PYG{n}{active}\PYG{p}{[}\PYG{n}{endactive}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getYpos}\PYG{p}{(}\PYG{p}{)}\PYG{p}{]}\PYG{p}{[}\PYG{n}{active}\PYG{p}{[}\PYG{n}{endactive}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getXpos}\PYG{p}{(}\PYG{p}{)}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getNext}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
            \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{tmpnwrap} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;}
            \PYG{k}{while}\PYG{p}{(}\PYG{n}{tmpcheck} \PYG{o}{!}\PYG{o}{=} \PYG{n}{endactive}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{n}{tmpnwrap}\PYG{o}{+}\PYG{o}{+}\PYG{p}{;}
                \PYG{n}{tmpcheck} \PYG{o}{=} \PYG{n}{active}\PYG{p}{[}\PYG{n}{tmpcheck}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getNext}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
                \PYG{k}{if}\PYG{p}{(}\PYG{n}{tmpnwrap} \PYG{o}{\PYGZgt{}} \PYG{n}{nwrap} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{p}{)}
                \PYG{p}{\PYGZob{}}
                    \PYG{n}{stringstream} \PYG{n}{ss}\PYG{p}{;}
                    \PYG{n}{ss} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ERROR\PYGZus{}MOVE\PYGZus{}017: NON FATAL. Nrap for endactive not set correctly; looped }\PYG{l+s}{\PYGZdq{}}
                            \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{beyond nwrap and not yet found enactive.}\PYG{l+s}{\PYGZdq{}}
                       \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
                    \PYG{n}{ss} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{endactive: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endactive} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}
                       \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{nwrap: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{nwrap} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}
                       \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{x,y: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{active}\PYG{p}{[}\PYG{n}{endactive}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getXpos}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{,}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{active}\PYG{p}{[}\PYG{n}{endactive}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getYpos}\PYG{p}{(}\PYG{p}{)}
                       \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
                    \PYG{n}{ss} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{chosen: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{chosen} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
                    \PYG{n}{writeLog}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{,} \PYG{n}{ss}\PYG{p}{)}\PYG{p}{;}
                \PYG{p}{\PYGZcb{}}
            \PYG{p}{\PYGZcb{}}
            \PYG{k}{if}\PYG{p}{(}\PYG{n}{tmpnwrap} \PYG{o}{!}\PYG{o}{=} \PYG{n}{nwrap}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{n}{stringstream} \PYG{n}{ss}\PYG{p}{;}
                \PYG{n}{ss} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ERROR\PYGZus{}MOVE\PYGZus{}018: NON FATAL. Nwrap for endactive not set correctly. Nwrap is }\PYG{l+s}{\PYGZdq{}}
                   \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{nwrap} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ but endactive is at position }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{tmpnwrap} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
                \PYG{n}{ss} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{endactive: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endactive} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}
                   \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{nwrap: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{nwrap} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}
                   \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{x,y: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{active}\PYG{p}{[}\PYG{n}{endactive}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getXpos}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{,}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{active}\PYG{p}{[}\PYG{n}{endactive}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getYpos}\PYG{p}{(}\PYG{p}{)}
                   \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
                \PYG{n}{ss} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{chosen: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{chosen} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
                \PYG{n}{writeLog}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{,} \PYG{n}{ss}\PYG{p}{)}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
        \PYG{p}{\PYGZcb{}}
    \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}

\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif}
\end{sphinxVerbatim}


\subsubsection{Detailed Description}
\label{\detokenize{api/file_necsim_SpatialTree.cpp:detailed-description}}
Samuel Thompson
24/03/17
BSD-3 Licence.


\subsubsection{Includes}
\label{\detokenize{api/file_necsim_SpatialTree.cpp:includes}}\begin{itemize}
\item {} 
\sphinxcode{SpatialTree.h} ({\hyperref[\detokenize{api/file_necsim_ProtractedSpatialTree.h:file-necsim-protractedspatialtree-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File ProtractedSpatialTree.h}}}})

\item {} 
\sphinxcode{algorithm}

\end{itemize}


\subsection{File SpatialTree.h}
\label{\detokenize{api/file_necsim_SpatialTree.h:file-spatialtree-h}}\label{\detokenize{api/file_necsim_SpatialTree.h:file-necsim-spatialtree-h}}\label{\detokenize{api/file_necsim_SpatialTree.h::doc}}
Contains the {\hyperref[\detokenize{api/class_SpatialTree:class-spatialtree}]{\sphinxcrossref{\DUrole{std,std-ref}{Class SpatialTree}}}} class for running simulations and outputting the phylogenetic tree.

\begin{sphinxShadowBox}
\sphinxstyletopictitle{Contents}
\begin{itemize}
\item {} 
\phantomsection\label{\detokenize{api/file_necsim_SpatialTree.h:id1}}{\hyperref[\detokenize{api/file_necsim_SpatialTree.h:definition-necsim-spatialtree-h}]{\sphinxcrossref{Definition (\sphinxcode{necsim/SpatialTree.h})}}}

\item {} 
\phantomsection\label{\detokenize{api/file_necsim_SpatialTree.h:id2}}{\hyperref[\detokenize{api/file_necsim_SpatialTree.h:detailed-description}]{\sphinxcrossref{Detailed Description}}}

\item {} 
\phantomsection\label{\detokenize{api/file_necsim_SpatialTree.h:id3}}{\hyperref[\detokenize{api/file_necsim_SpatialTree.h:includes}]{\sphinxcrossref{Includes}}}

\item {} 
\phantomsection\label{\detokenize{api/file_necsim_SpatialTree.h:id4}}{\hyperref[\detokenize{api/file_necsim_SpatialTree.h:included-by}]{\sphinxcrossref{Included By}}}

\item {} 
\phantomsection\label{\detokenize{api/file_necsim_SpatialTree.h:id5}}{\hyperref[\detokenize{api/file_necsim_SpatialTree.h:classes}]{\sphinxcrossref{Classes}}}

\item {} 
\phantomsection\label{\detokenize{api/file_necsim_SpatialTree.h:id6}}{\hyperref[\detokenize{api/file_necsim_SpatialTree.h:defines}]{\sphinxcrossref{Defines}}}

\end{itemize}
\end{sphinxShadowBox}


\subsubsection{Definition (\sphinxstyleliteralintitle{necsim/SpatialTree.h})}
\label{\detokenize{api/file_necsim_SpatialTree.h:definition-necsim-spatialtree-h}}

\paragraph{Program Listing for File SpatialTree.h}
\label{\detokenize{api/program_listing_file_necsim_SpatialTree.h:program-listing-file-necsim-spatialtree-h}}\label{\detokenize{api/program_listing_file_necsim_SpatialTree.h::doc}}\label{\detokenize{api/program_listing_file_necsim_SpatialTree.h:program-listing-for-file-spatialtree-h}}\begin{itemize}
\item {} 
Return to documentation for {\hyperref[\detokenize{api/file_necsim_SpatialTree.h:file-necsim-spatialtree-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File SpatialTree.h}}}}

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{// This file is part of NECSim project which is released under BSD\PYGZhy{}3 license.}
\PYG{c+c1}{// See file **LICENSE.txt** or visit https://opensource.org/licenses/BSD\PYGZhy{}3\PYGZhy{}Clause) for full license details.}
\PYG{c+c1}{//}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifndef SPATIALTREE\PYGZus{}H}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define SPATIALTREE\PYGZus{}H}

\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}cstdio\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}fstream\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}vector\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}iostream\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}string\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}cstring\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}cmath\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}iomanip\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}cmath\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}ctime\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}ctime\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}sqlite3.h\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}unistd.h\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}algorithm\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}stdexcept\PYGZgt{}}
\PYG{c+c1}{//\PYGZsh{}define with\PYGZus{}gdal}
\PYG{c+c1}{// extra boost include \PYGZhy{} this requires the installation of boost on the system}
\PYG{c+c1}{// note that this requires compilation with the \PYGZhy{}lboost\PYGZus{}filesystem and \PYGZhy{}lboost\PYGZus{}system linkers.}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}boost/filesystem.hpp\PYGZgt{}}

\PYG{c+c1}{// include fast\PYGZhy{}csv\PYGZhy{}parser by Ben Strasser (available from https://github.com/ben\PYGZhy{}strasser/fast\PYGZhy{}cpp\PYGZhy{}csv\PYGZhy{}parser)}
\PYG{c+c1}{// for fast file reading}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifdef use\PYGZus{}csv}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZdq{}fast\PYGZhy{}cpp\PYGZhy{}csv\PYGZhy{}parser/csv.h\PYGZdq{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif}

\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifndef sql\PYGZus{}ram}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define sql\PYGZus{}ram}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif}

\PYG{c+c1}{// other includes for required files}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZdq{}Tree.h\PYGZdq{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZdq{}Matrix.h\PYGZdq{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZdq{}NRrand.h\PYGZdq{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZdq{}SimParameters.h\PYGZdq{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZdq{}DataPoint.h\PYGZdq{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZdq{}TreeNode.h\PYGZdq{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZdq{}SpeciesList.h\PYGZdq{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZdq{}Map.h\PYGZdq{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZdq{}Community.h\PYGZdq{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZdq{}Setup.h\PYGZdq{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZdq{}DispersalCoordinator.h\PYGZdq{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZdq{}ReproductionMap.h\PYGZdq{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZdq{}Logging.h\PYGZdq{}}

\PYG{k}{using} \PYG{k}{namespace} \PYG{n}{std}\PYG{p}{;}

\PYG{k}{class} \PYG{n+nc}{SpatialTree} \PYG{o}{:} \PYG{k}{public} \PYG{k}{virtual} \PYG{n}{Tree}
\PYG{p}{\PYGZob{}}
\PYG{k}{protected}\PYG{o}{:}
    \PYG{c+c1}{// Our dispersal coordinator for getting dispersal distances and managing calls from the habitat\PYGZus{}map}
    \PYG{n}{DispersalCoordinator} \PYG{n}{dispersal\PYGZus{}coordinator}\PYG{p}{;}
    \PYG{c+c1}{// The reproduction map object}
    \PYG{n}{ReproductionMap} \PYG{n}{rep\PYGZus{}map}\PYG{p}{;}
    \PYG{c+c1}{// A list of new variables which will contain the relevant information for maps and grids.}
    \PYG{c+c1}{//  strings containing the file names to be imported.}
    \PYG{n}{string} \PYG{n}{fine\PYGZus{}map\PYGZus{}input}\PYG{p}{,} \PYG{n}{coarse\PYGZus{}map\PYGZus{}input}\PYG{p}{;}
    \PYG{n}{string} \PYG{n}{pristine\PYGZus{}fine\PYGZus{}map\PYGZus{}input}\PYG{p}{,} \PYG{n}{pristine\PYGZus{}coarse\PYGZus{}map\PYGZus{}input}\PYG{p}{;}
    \PYG{c+c1}{// the time since pristine forest and the rate of change of the rainforest.}
    \PYG{k+kt}{double} \PYG{n}{gen\PYGZus{}since\PYGZus{}pristine}\PYG{p}{,} \PYG{n}{habitat\PYGZus{}change\PYGZus{}rate}\PYG{p}{;}
    \PYG{c+c1}{// the variables for the grid containing the initial individuals.}
    \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{grid\PYGZus{}x\PYGZus{}size}\PYG{p}{,} \PYG{n}{grid\PYGZus{}y\PYGZus{}size}\PYG{p}{;}
    \PYG{c+c1}{// The fine map variables at the same resolution as the grid.}
    \PYG{c+c1}{// the coarse map variables at a scaled resolution of the fine map.}
    \PYG{k+kt}{long} \PYG{n}{fine\PYGZus{}map\PYGZus{}x\PYGZus{}size}\PYG{p}{,} \PYG{n}{fine\PYGZus{}map\PYGZus{}y\PYGZus{}size}\PYG{p}{,} \PYG{n}{fine\PYGZus{}map\PYGZus{}x\PYGZus{}offset}\PYG{p}{,} \PYG{n}{fine\PYGZus{}map\PYGZus{}y\PYGZus{}offset}\PYG{p}{;}
    \PYG{k+kt}{long} \PYG{n}{coarse\PYGZus{}map\PYGZus{}x\PYGZus{}size}\PYG{p}{,} \PYG{n}{coarse\PYGZus{}map\PYGZus{}y\PYGZus{}size}\PYG{p}{,} \PYG{n}{coarse\PYGZus{}map\PYGZus{}x\PYGZus{}offset}\PYG{p}{,} \PYG{n}{coarse\PYGZus{}map\PYGZus{}y\PYGZus{}offset}\PYG{p}{,} \PYG{n}{coarse\PYGZus{}map\PYGZus{}scale}\PYG{p}{;}
    \PYG{c+c1}{// Map object containing both the coarse and fine maps for checking whether or not there is forest at a particular}
    \PYG{c+c1}{// location.}
    \PYG{n}{Map} \PYG{n}{habitat\PYGZus{}map}\PYG{p}{;}
    \PYG{c+c1}{// An indexing spatial positioning of the lineages}
    \PYG{n}{Matrix}\PYG{o}{\PYGZlt{}}\PYG{n}{SpeciesList}\PYG{o}{\PYGZgt{}} \PYG{n}{grid}\PYG{p}{;}
    \PYG{c+c1}{// dispersal and sigma references}
    \PYG{k+kt}{double} \PYG{n}{sigma}\PYG{p}{,} \PYG{n}{tau}\PYG{p}{;}
    \PYG{c+c1}{// the cost for moving through non\PYGZhy{}forest. 1.0 means there is no cost. 10 means that movement is 10x}
    \PYG{c+c1}{// slower through forest.}
    \PYG{k+kt}{double} \PYG{n}{dispersal\PYGZus{}relative\PYGZus{}cost}\PYG{p}{;}
    \PYG{c+c1}{// the desired number of species we are aiming for. If it is 0, we will carry on forever.}
    \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{desired\PYGZus{}specnum}\PYG{p}{;}
    \PYG{c+c1}{// contains the DataMask for where we should start lineages from.}
    \PYG{n}{DataMask} \PYG{n}{samplegrid}\PYG{p}{;}
\PYG{k}{public}\PYG{o}{:}
    \PYG{n}{SpatialTree}\PYG{p}{(}\PYG{p}{)} \PYG{o}{:} \PYG{n}{Tree}\PYG{p}{(}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{sigma} \PYG{o}{=} \PYG{l+m+mf}{0.0}\PYG{p}{;}
        \PYG{n}{tau} \PYG{o}{=} \PYG{l+m+mf}{0.0}\PYG{p}{;}
        \PYG{n}{outdatabase} \PYG{o}{=} \PYG{k}{nullptr}\PYG{p}{;}
        \PYG{n}{gen\PYGZus{}since\PYGZus{}pristine} \PYG{o}{=} \PYG{l+m+mf}{0.0}\PYG{p}{;}
        \PYG{n}{habitat\PYGZus{}change\PYGZus{}rate} \PYG{o}{=} \PYG{l+m+mf}{0.0}\PYG{p}{;}
        \PYG{n}{grid\PYGZus{}x\PYGZus{}size} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
        \PYG{n}{grid\PYGZus{}y\PYGZus{}size} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
        \PYG{n}{fine\PYGZus{}map\PYGZus{}x\PYGZus{}size} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
        \PYG{n}{fine\PYGZus{}map\PYGZus{}y\PYGZus{}size} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
        \PYG{n}{fine\PYGZus{}map\PYGZus{}x\PYGZus{}offset} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
        \PYG{n}{fine\PYGZus{}map\PYGZus{}y\PYGZus{}offset} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
        \PYG{n}{coarse\PYGZus{}map\PYGZus{}x\PYGZus{}size} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
        \PYG{n}{coarse\PYGZus{}map\PYGZus{}y\PYGZus{}size} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
        \PYG{n}{coarse\PYGZus{}map\PYGZus{}x\PYGZus{}offset} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
        \PYG{n}{coarse\PYGZus{}map\PYGZus{}y\PYGZus{}offset} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
        \PYG{n}{coarse\PYGZus{}map\PYGZus{}scale} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;}
        \PYG{n}{dispersal\PYGZus{}relative\PYGZus{}cost} \PYG{o}{=} \PYG{l+m+mf}{1.0}\PYG{p}{;}
        \PYG{n}{desired\PYGZus{}specnum} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{o}{\PYGZti{}}\PYG{n}{SpatialTree}\PYG{p}{(}\PYG{p}{)} \PYG{o}{=} \PYG{k}{default}\PYG{p}{;}
    \PYG{k+kt}{void} \PYG{n+nf}{importSimulationVariables}\PYG{p}{(}\PYG{k}{const} \PYG{n}{string} \PYG{o}{\PYGZam{}}\PYG{n}{configfile}\PYG{p}{)} \PYG{k}{override}\PYG{p}{;}

    \PYG{k+kt}{void} \PYG{n+nf}{parseArgs}\PYG{p}{(}\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{n}{string}\PYG{o}{\PYGZgt{}} \PYG{o}{\PYGZam{}}\PYG{n}{comargs}\PYG{p}{)}\PYG{p}{;}

    \PYG{k+kt}{void} \PYG{n+nf}{checkFolders}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

    \PYG{k+kt}{void} \PYG{n+nf}{setParameters}\PYG{p}{(}\PYG{p}{)} \PYG{k}{override}\PYG{p}{;}


    \PYG{c+c1}{// Imports the maps using the variables stored in the class. This function must be run after the set\PYGZus{}mapvars() in}
    \PYG{c+c1}{// order to function correctly.}
    \PYG{k+kt}{void} \PYG{n+nf}{importMaps}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

    \PYG{k+kt}{void} \PYG{n+nf}{importReproductionMap}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

    \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n+nf}{getInitialCount}\PYG{p}{(}\PYG{p}{)} \PYG{k}{override}\PYG{p}{;}

    \PYG{k+kt}{void} \PYG{n+nf}{setupDispersalCoordinator}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

    \PYG{k+kt}{void} \PYG{n+nf}{setup}\PYG{p}{(}\PYG{p}{)} \PYG{k}{override}\PYG{p}{;}

    \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n+nf}{fillObjects}\PYG{p}{(}\PYG{k}{const} \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{initial\PYGZus{}count}\PYG{p}{)} \PYG{k}{override}\PYG{p}{;}

    \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n+nf}{getIndividualsSampled}\PYG{p}{(}\PYG{k}{const} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{x}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{y}\PYG{p}{,}
                                 \PYG{k}{const} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{x\PYGZus{}wrap}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{y\PYGZus{}wrap}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{double} \PYG{o}{\PYGZam{}}\PYG{n}{current\PYGZus{}gen}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kt}{void} \PYG{n+nf}{removeOldPosition}\PYG{p}{(}\PYG{k}{const} \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{chosen}\PYG{p}{)} \PYG{k}{override}\PYG{p}{;}

    \PYG{k+kt}{void} \PYG{n+nf}{calcMove}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

    \PYG{k+kt}{long} \PYG{k+kt}{double} \PYG{n+nf}{calcMinMax}\PYG{p}{(}\PYG{k}{const} \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{current}\PYG{p}{)}\PYG{p}{;}

    \PYG{k+kt}{void} \PYG{n+nf}{calcNewPos}\PYG{p}{(}\PYG{k+kt}{bool} \PYG{o}{\PYGZam{}}\PYG{n}{coal}\PYG{p}{,}
                    \PYG{k}{const} \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{chosen}\PYG{p}{,}
                    \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{coalchosen}\PYG{p}{,}
                    \PYG{k}{const} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{oldx}\PYG{p}{,}
                    \PYG{k}{const} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{oldy}\PYG{p}{,}
                    \PYG{k}{const} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{oldxwrap}\PYG{p}{,}
                    \PYG{k}{const} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{oldywrap}\PYG{p}{)}\PYG{p}{;}

    \PYG{k+kt}{void} \PYG{n+nf}{switchPositions}\PYG{p}{(}\PYG{k}{const} \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{chosen}\PYG{p}{)} \PYG{k}{override}\PYG{p}{;}

    \PYG{k+kt}{void} \PYG{n+nf}{calcNextStep}\PYG{p}{(}\PYG{p}{)} \PYG{k}{override}\PYG{p}{;}

    \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n+nf}{estSpecnum}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifdef pristine\PYGZus{}mode}

    \PYG{k+kt}{void} \PYG{n+nf}{pristineStepChecks}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif}


    \PYG{k+kt}{void} \PYG{n+nf}{incrementGeneration}\PYG{p}{(}\PYG{p}{)} \PYG{k}{override} \PYG{p}{;}

    \PYG{k+kt}{void} \PYG{n+nf}{updateStepCoalescenceVariables}\PYG{p}{(}\PYG{p}{)} \PYG{k}{override}\PYG{p}{;}

    \PYG{k+kt}{void} \PYG{n+nf}{addLineages}\PYG{p}{(}\PYG{k+kt}{double} \PYG{n}{generation\PYGZus{}in}\PYG{p}{)} \PYG{k}{override}\PYG{p}{;}

    \PYG{n}{string} \PYG{n+nf}{simulationParametersSqlInsertion}\PYG{p}{(}\PYG{p}{)} \PYG{k}{override}\PYG{p}{;}


    \PYG{k+kt}{void} \PYG{n+nf}{simPause}\PYG{p}{(}\PYG{p}{)} \PYG{k}{override}\PYG{p}{;}

    \PYG{k+kt}{void} \PYG{n+nf}{dumpMap}\PYG{p}{(}\PYG{n}{string} \PYG{n}{pause\PYGZus{}folder}\PYG{p}{)}\PYG{p}{;}

    \PYG{k+kt}{void} \PYG{n+nf}{simResume}\PYG{p}{(}\PYG{p}{)} \PYG{k}{override}\PYG{p}{;}

    \PYG{k+kt}{void} \PYG{n+nf}{loadGridSave}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

    \PYG{k+kt}{void} \PYG{n+nf}{loadMapSave}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

    \PYG{k+kt}{void} \PYG{n+nf}{verifyReproductionMap}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

    \PYG{k+kt}{void} \PYG{n+nf}{addWrappedLineage}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{numstart}\PYG{p}{,} \PYG{k+kt}{long} \PYG{n}{x}\PYG{p}{,} \PYG{k+kt}{long} \PYG{n}{y}\PYG{p}{)}\PYG{p}{;}

    \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n+nf}{countCellExpansion}\PYG{p}{(}\PYG{k}{const} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{x}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{y}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{xwrap}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{ywrap}\PYG{p}{,}
                                     \PYG{k}{const} \PYG{k+kt}{double} \PYG{o}{\PYGZam{}}\PYG{n}{generationin}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{bool} \PYG{o}{\PYGZam{}}\PYG{n}{make\PYGZus{}tips}\PYG{p}{)}\PYG{p}{;}

    \PYG{k+kt}{void} \PYG{n+nf}{expandCell}\PYG{p}{(}\PYG{k+kt}{long} \PYG{n}{x}\PYG{p}{,} \PYG{k+kt}{long} \PYG{n}{y}\PYG{p}{,} \PYG{k+kt}{long} \PYG{n}{x\PYGZus{}wrap}\PYG{p}{,} \PYG{k+kt}{long} \PYG{n}{y\PYGZus{}wrap}\PYG{p}{,} \PYG{k+kt}{double} \PYG{n}{generation\PYGZus{}in}\PYG{p}{,} \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{add}\PYG{p}{)}\PYG{p}{;}




\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifdef DEBUG}

    \PYG{k+kt}{void} \PYG{n+nf}{validateLineages}\PYG{p}{(}\PYG{p}{)} \PYG{k}{override}\PYG{p}{;}

    \PYG{k+kt}{void} \PYG{n+nf}{debugDispersal}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kt}{void} \PYG{n+nf}{debugAddingLineage}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{numstart}\PYG{p}{,} \PYG{k+kt}{long} \PYG{n}{x}\PYG{p}{,} \PYG{k+kt}{long} \PYG{n}{y}\PYG{p}{)}\PYG{p}{;}

    \PYG{k+kt}{void} \PYG{n+nf}{runChecks}\PYG{p}{(}\PYG{k}{const} \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{chosen}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{coalchosen}\PYG{p}{)} \PYG{k}{override}\PYG{p}{;}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}

\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif  }\PYG{c+c1}{// SPATIALTREE\PYGZus{}H}
\end{sphinxVerbatim}


\subsubsection{Detailed Description}
\label{\detokenize{api/file_necsim_SpatialTree.h:detailed-description}}
Sam Thompson
31/08/2016
Contact: \sphinxhref{mailto:samuel.thompson14@imperial.ac.uk}{samuel.thompson14@imperial.ac.uk} or \sphinxhref{mailto:thompsonsed@gmail.com}{thompsonsed@gmail.com} BSD-3 Licence.


\subsubsection{Includes}
\label{\detokenize{api/file_necsim_SpatialTree.h:includes}}\begin{itemize}
\item {} 
\sphinxcode{Community.h} ({\hyperref[\detokenize{api/file_necsim_Community.h:file-necsim-community-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File Community.h}}}})

\item {} 
\sphinxcode{DataPoint.h} ({\hyperref[\detokenize{api/file_necsim_DataPoint.h:file-necsim-datapoint-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File DataPoint.h}}}})

\item {} 
\sphinxcode{DispersalCoordinator.h} ({\hyperref[\detokenize{api/file_necsim_DispersalCoordinator.h:file-necsim-dispersalcoordinator-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File DispersalCoordinator.h}}}})

\item {} 
\sphinxcode{Logging.h} ({\hyperref[\detokenize{api/file_necsim_Logging.h:file-necsim-logging-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File Logging.h}}}})

\item {} 
\sphinxcode{Map.h} ({\hyperref[\detokenize{api/file_necsim_Map.h:file-necsim-map-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File Map.h}}}})

\item {} 
\sphinxcode{Matrix.h} ({\hyperref[\detokenize{api/file_necsim_Matrix.h:file-necsim-matrix-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File Matrix.h}}}})

\item {} 
\sphinxcode{NRrand.h} ({\hyperref[\detokenize{api/file_necsim_NRrand.h:file-necsim-nrrand-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File NRrand.h}}}})

\item {} 
\sphinxcode{ReproductionMap.h} ({\hyperref[\detokenize{api/file_necsim_ReproductionMap.h:file-necsim-reproductionmap-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File ReproductionMap.h}}}})

\item {} 
\sphinxcode{Setup.h} ({\hyperref[\detokenize{api/file_necsim_Setup.h:file-necsim-setup-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File Setup.h}}}})

\item {} 
\sphinxcode{SimParameters.h} ({\hyperref[\detokenize{api/file_necsim_SimParameters.h:file-necsim-simparameters-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File SimParameters.h}}}})

\item {} 
\sphinxcode{SpeciesList.h} ({\hyperref[\detokenize{api/file_necsim_SpeciesList.h:file-necsim-specieslist-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File SpeciesList.h}}}})

\item {} 
\sphinxcode{Tree.h} ({\hyperref[\detokenize{api/file_necsim_ProtractedSpatialTree.h:file-necsim-protractedspatialtree-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File ProtractedSpatialTree.h}}}})

\item {} 
\sphinxcode{TreeNode.h} ({\hyperref[\detokenize{api/file_necsim_TreeNode.h:file-necsim-treenode-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File TreeNode.h}}}})

\item {} 
\sphinxcode{algorithm}

\item {} 
\sphinxcode{boost/filesystem.hpp}

\item {} 
\sphinxcode{cmath}

\item {} 
\sphinxcode{cstdio}

\item {} 
\sphinxcode{cstring}

\item {} 
\sphinxcode{ctime}

\item {} 
\sphinxcode{fstream}

\item {} 
\sphinxcode{iomanip}

\item {} 
\sphinxcode{iostream}

\item {} 
\sphinxcode{sqlite3.h}

\item {} 
\sphinxcode{stdexcept}

\item {} 
\sphinxcode{string}

\item {} 
\sphinxcode{unistd.h}

\item {} 
\sphinxcode{vector}

\end{itemize}


\subsubsection{Included By}
\label{\detokenize{api/file_necsim_SpatialTree.h:included-by}}\begin{itemize}
\item {} 
{\hyperref[\detokenize{api/file_necsim_main.cpp:file-necsim-main-cpp}]{\sphinxcrossref{\DUrole{std,std-ref}{File main.cpp}}}}

\item {} 
{\hyperref[\detokenize{api/file_necsim_ProtractedSpatialTree.h:file-necsim-protractedspatialtree-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File ProtractedSpatialTree.h}}}}

\item {} 
{\hyperref[\detokenize{api/file_necsim_ProtractedTree.h:file-necsim-protractedtree-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File ProtractedTree.h}}}}

\item {} 
{\hyperref[\detokenize{api/file_necsim_SpatialTree.cpp:file-necsim-spatialtree-cpp}]{\sphinxcrossref{\DUrole{std,std-ref}{File SpatialTree.cpp}}}}

\end{itemize}


\subsubsection{Classes}
\label{\detokenize{api/file_necsim_SpatialTree.h:classes}}\begin{itemize}
\item {} 
{\hyperref[\detokenize{api/class_SpatialTree:class-spatialtree}]{\sphinxcrossref{\DUrole{std,std-ref}{Class SpatialTree}}}}

\end{itemize}


\subsubsection{Defines}
\label{\detokenize{api/file_necsim_SpatialTree.h:defines}}\begin{itemize}
\item {} 
{\hyperref[\detokenize{api/define_sql_ram:define-sql-ram}]{\sphinxcrossref{\DUrole{std,std-ref}{Define sql\_ram}}}}

\end{itemize}


\subsection{File SpeciationCommands.cpp}
\label{\detokenize{api/file_necsim_SpeciationCommands.cpp:file-necsim-speciationcommands-cpp}}\label{\detokenize{api/file_necsim_SpeciationCommands.cpp::doc}}\label{\detokenize{api/file_necsim_SpeciationCommands.cpp:file-speciationcommands-cpp}}
Contains the ApplySpec class for performing calculations of the coalescence tree structure and generating the SQL database objects from the command-line.

\begin{sphinxShadowBox}
\sphinxstyletopictitle{Contents}
\begin{itemize}
\item {} 
\phantomsection\label{\detokenize{api/file_necsim_SpeciationCommands.cpp:id1}}{\hyperref[\detokenize{api/file_necsim_SpeciationCommands.cpp:definition-necsim-speciationcommands-cpp}]{\sphinxcrossref{Definition (\sphinxcode{necsim/SpeciationCommands.cpp})}}}

\item {} 
\phantomsection\label{\detokenize{api/file_necsim_SpeciationCommands.cpp:id2}}{\hyperref[\detokenize{api/file_necsim_SpeciationCommands.cpp:detailed-description}]{\sphinxcrossref{Detailed Description}}}

\item {} 
\phantomsection\label{\detokenize{api/file_necsim_SpeciationCommands.cpp:id3}}{\hyperref[\detokenize{api/file_necsim_SpeciationCommands.cpp:includes}]{\sphinxcrossref{Includes}}}

\end{itemize}
\end{sphinxShadowBox}


\subsubsection{Definition (\sphinxstyleliteralintitle{necsim/SpeciationCommands.cpp})}
\label{\detokenize{api/file_necsim_SpeciationCommands.cpp:definition-necsim-speciationcommands-cpp}}

\paragraph{Program Listing for File SpeciationCommands.cpp}
\label{\detokenize{api/program_listing_file_necsim_SpeciationCommands.cpp:program-listing-file-necsim-speciationcommands-cpp}}\label{\detokenize{api/program_listing_file_necsim_SpeciationCommands.cpp::doc}}\label{\detokenize{api/program_listing_file_necsim_SpeciationCommands.cpp:program-listing-for-file-speciationcommands-cpp}}\begin{itemize}
\item {} 
Return to documentation for {\hyperref[\detokenize{api/file_necsim_SpeciationCommands.cpp:file-necsim-speciationcommands-cpp}]{\sphinxcrossref{\DUrole{std,std-ref}{File SpeciationCommands.cpp}}}}

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{// This file is part of NECSim project which is released under BSD\PYGZhy{}3 license.}
\PYG{c+c1}{// See file **LICENSE.txt** or visit https://opensource.org/licenses/BSD\PYGZhy{}3\PYGZhy{}Clause) for full license details.}

\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZdq{}SpeciationCommands.h\PYGZdq{}}


\PYG{k+kt}{void} \PYG{n}{SpeciationCommands}\PYG{o}{:}\PYG{o}{:}\PYG{n}{parseArgs}\PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k+kt}{bool} \PYG{n}{bRunDefault} \PYG{o}{=} \PYG{n+nb}{false}\PYG{p}{;}
    \PYG{k+kt}{bool} \PYG{n}{bInvalidArguments} \PYG{o}{=} \PYG{n+nb}{false}\PYG{p}{;}
    \PYG{k+kt}{bool} \PYG{n}{bAskHelp} \PYG{o}{=} \PYG{n+nb}{false}\PYG{p}{;}
    \PYG{k}{if}\PYG{p}{(}\PYG{n}{argc} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{7}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{argc} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{bInvalidArguments} \PYG{o}{=} \PYG{n+nb}{true}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{n}{bInvalidArguments} \PYG{o}{=} \PYG{n+nb}{true}\PYG{p}{;}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{argc} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{2}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{k}{if}\PYG{p}{(}\PYG{p}{(}\PYG{n}{comargs}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)} \PYG{o}{=}\PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZhy{}d}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{n}{bInvalidArguments} \PYG{o}{=} \PYG{n+nb}{false}\PYG{p}{;}
                \PYG{n}{bRunDefault} \PYG{o}{=} \PYG{n+nb}{true}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
            \PYG{k}{if}\PYG{p}{(}\PYG{n}{comargs}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{=}\PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZhy{}h}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\textbar{}}\PYG{o}{\textbar{}} \PYG{n}{comargs}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{=}\PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZhy{}help}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{n}{bInvalidArguments} \PYG{o}{=} \PYG{n+nb}{false}\PYG{p}{;}
                \PYG{n}{bAskHelp} \PYG{o}{=} \PYG{n+nb}{true}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{bInvalidArguments}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{writeInfo}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Incorrect number of arguments.}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
            \PYG{n}{bInvalidArguments} \PYG{o}{=} \PYG{n+nb}{true}\PYG{p}{;}
            \PYG{k}{if}\PYG{p}{(}\PYG{n}{argc} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{n}{comargs}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZhy{}e}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
            \PYG{k}{else}
            \PYG{p}{\PYGZob{}}
                \PYG{n}{comargs}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZhy{}e}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
        \PYG{p}{\PYGZcb{}}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{else}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{sp}\PYG{p}{.}\PYG{n}{samplemask} \PYG{o}{=} \PYG{n}{comargs}\PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{;}
        \PYG{n}{sp}\PYG{p}{.}\PYG{n}{filename} \PYG{o}{=} \PYG{n}{comargs}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{;}
        \PYG{n}{sp}\PYG{p}{.}\PYG{n}{times\PYGZus{}file} \PYG{o}{=} \PYG{n}{comargs}\PYG{p}{[}\PYG{l+m+mi}{4}\PYG{p}{]}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{if}\PYG{p}{(}\PYG{n}{argc} \PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{7}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{sp}\PYG{p}{.}\PYG{n}{bMultiRun} \PYG{o}{=} \PYG{n+nb}{true}\PYG{p}{;}
        \PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{6}\PYG{p}{;}
        \PYG{k}{while}\PYG{p}{(}\PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{argc}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{sp}\PYG{p}{.}\PYG{n}{all\PYGZus{}speciation\PYGZus{}rates}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{n}{stof}\PYG{p}{(}\PYG{n}{comargs}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
            \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{else} \PYG{k}{if}\PYG{p}{(}\PYG{n}{argc} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{7} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{o}{!}\PYG{n}{bInvalidArguments} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{o}{!}\PYG{n}{bAskHelp}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{sp}\PYG{p}{.}\PYG{n}{bMultiRun} \PYG{o}{=} \PYG{n+nb}{false}\PYG{p}{;}
        \PYG{n}{sp}\PYG{p}{.}\PYG{n}{all\PYGZus{}speciation\PYGZus{}rates}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{n}{stod}\PYG{p}{(}\PYG{n}{comargs}\PYG{p}{[}\PYG{l+m+mi}{6}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{if}\PYG{p}{(}\PYG{o}{!}\PYG{n}{bInvalidArguments} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{o}{!}\PYG{n}{bAskHelp} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{o}{!}\PYG{n}{bRunDefault}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{comargs}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]} \PYG{o}{=}\PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{true}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\textbar{}}\PYG{o}{\textbar{}} \PYG{n}{comargs}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]} \PYG{o}{=}\PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{True}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\textbar{}}\PYG{o}{\textbar{}} \PYG{n}{comargs}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]} \PYG{o}{=}\PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{T}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\textbar{}}\PYG{o}{\textbar{}} \PYG{n}{comargs}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]} \PYG{o}{=}\PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{TRUE}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\textbar{}}\PYG{o}{\textbar{}}
           \PYG{n}{comargs}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]} \PYG{o}{=}\PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{t}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{sp}\PYG{p}{.}\PYG{n}{use\PYGZus{}spatial} \PYG{o}{=} \PYG{n+nb}{true}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{else}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{sp}\PYG{p}{.}\PYG{n}{use\PYGZus{}spatial} \PYG{o}{=} \PYG{n+nb}{false}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{comargs}\PYG{p}{[}\PYG{l+m+mi}{5}\PYG{p}{]} \PYG{o}{=}\PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{false}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\textbar{}}\PYG{o}{\textbar{}} \PYG{n}{comargs}\PYG{p}{[}\PYG{l+m+mi}{5}\PYG{p}{]} \PYG{o}{=}\PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{False}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\textbar{}}\PYG{o}{\textbar{}} \PYG{n}{comargs}\PYG{p}{[}\PYG{l+m+mi}{5}\PYG{p}{]} \PYG{o}{=}\PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{F}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\textbar{}}\PYG{o}{\textbar{}} \PYG{n}{comargs}\PYG{p}{[}\PYG{l+m+mi}{5}\PYG{p}{]} \PYG{o}{=}\PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{FALSE}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\textbar{}}\PYG{o}{\textbar{}}
           \PYG{n}{comargs}\PYG{p}{[}\PYG{l+m+mi}{5}\PYG{p}{]} \PYG{o}{=}\PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{f}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{sp}\PYG{p}{.}\PYG{n}{use\PYGZus{}fragments} \PYG{o}{=} \PYG{n+nb}{false}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{else}
        \PYG{p}{\PYGZob{}}
            \PYG{k}{if}\PYG{p}{(}\PYG{n}{comargs}\PYG{p}{[}\PYG{l+m+mi}{5}\PYG{p}{]} \PYG{o}{=}\PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{true}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\textbar{}}\PYG{o}{\textbar{}} \PYG{n}{comargs}\PYG{p}{[}\PYG{l+m+mi}{5}\PYG{p}{]} \PYG{o}{=}\PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{True}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\textbar{}}\PYG{o}{\textbar{}} \PYG{n}{comargs}\PYG{p}{[}\PYG{l+m+mi}{5}\PYG{p}{]} \PYG{o}{=}\PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{T}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\textbar{}}\PYG{o}{\textbar{}} \PYG{n}{comargs}\PYG{p}{[}\PYG{l+m+mi}{5}\PYG{p}{]} \PYG{o}{=}\PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{TRUE}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\textbar{}}\PYG{o}{\textbar{}}
               \PYG{n}{comargs}\PYG{p}{[}\PYG{l+m+mi}{5}\PYG{p}{]} \PYG{o}{=}\PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{t}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{n}{sp}\PYG{p}{.}\PYG{n}{fragment\PYGZus{}config\PYGZus{}file} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{null}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
            \PYG{k}{else}
            \PYG{p}{\PYGZob{}}
                \PYG{n}{sp}\PYG{p}{.}\PYG{n}{fragment\PYGZus{}config\PYGZus{}file} \PYG{o}{=} \PYG{n}{comargs}\PYG{p}{[}\PYG{l+m+mi}{5}\PYG{p}{]}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
            \PYG{n}{sp}\PYG{p}{.}\PYG{n}{use\PYGZus{}fragments} \PYG{o}{=} \PYG{n+nb}{true}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{if}\PYG{p}{(}\PYG{n}{bInvalidArguments} \PYG{o}{\textbar{}}\PYG{o}{\textbar{}} \PYG{n}{bAskHelp}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{stringstream} \PYG{n}{os}\PYG{p}{;}
        \PYG{n}{os} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{At least six command\PYGZhy{}line arguments are expected.}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
        \PYG{n}{os} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{1 \PYGZhy{} Path to SQL database file.}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
        \PYG{n}{os} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{2 \PYGZhy{} T/F of whether to record full spatial data.}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
        \PYG{n}{os} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{3 \PYGZhy{} the sample mask to use (use null if no mask is to be used)}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
        \PYG{n}{os} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{4 \PYGZhy{} the file containing tempororal points of interest. If null, the present is used for all }\PYG{l+s}{\PYGZdq{}}
              \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{calculations.}\PYG{l+s}{\PYGZdq{}}
           \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
        \PYG{n}{os} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{5 \PYGZhy{} T/F of whether to calculate abundances for each rectangular fragment. Alternatively, provide a }\PYG{l+s}{\PYGZdq{}}
              \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{csv file with fragment data to be read.}\PYG{l+s}{\PYGZdq{}}
           \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
        \PYG{n}{os} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{6 \PYGZhy{} Speciation rate.}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
        \PYG{n}{os} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{7 \PYGZhy{} onwards \PYGZhy{} Further speciation rates. [OPTIONAL]}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
        \PYG{n}{os} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Would you like to run with the default paramenters?}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
        \PYG{n}{os} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{       (This requires a SQL database file at ../../Data/Coal\PYGZus{}sim/Test\PYGZus{}output/SQL\PYGZus{}data/data\PYGZus{}0\PYGZus{}1.db)}\PYG{l+s}{\PYGZdq{}}
           \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
        \PYG{n}{os} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Enter Y/N: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{flush}\PYG{p}{;}
        \PYG{n}{writeInfo}\PYG{p}{(}\PYG{n}{os}\PYG{p}{.}\PYG{n}{str}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{string} \PYG{n}{sDef}\PYG{p}{;}
        \PYG{n}{cin} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{sDef}\PYG{p}{;}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{sDef} \PYG{o}{=}\PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Y}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\textbar{}}\PYG{o}{\textbar{}} \PYG{n}{sDef} \PYG{o}{=}\PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{y}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{bRunDefault} \PYG{o}{=} \PYG{n+nb}{true}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{else}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{bRunDefault} \PYG{o}{=} \PYG{n+nb}{false}\PYG{p}{;}
            \PYG{k}{throw} \PYG{n+nf}{FatalException}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Nothing to do!}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{if}\PYG{p}{(}\PYG{n}{comargs}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{=}\PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZhy{}d}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\textbar{}}\PYG{o}{\textbar{}} \PYG{n}{bRunDefault}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{sp}\PYG{p}{.}\PYG{n}{filename} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{../../Data/Coal\PYGZus{}sim/Test\PYGZus{}output/SQL\PYGZus{}data/data\PYGZus{}0\PYGZus{}1.db}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
        \PYG{n}{sp}\PYG{p}{.}\PYG{n}{all\PYGZus{}speciation\PYGZus{}rates}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{l+m+mf}{0.001}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{sp}\PYG{p}{.}\PYG{n}{samplemask} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{null}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
        \PYG{n}{sp}\PYG{p}{.}\PYG{n}{times\PYGZus{}file} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{null}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
        \PYG{n}{sp}\PYG{p}{.}\PYG{n}{fragment\PYGZus{}config\PYGZus{}file} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{null}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
        \PYG{n}{sp}\PYG{p}{.}\PYG{n}{use\PYGZus{}fragments} \PYG{o}{=} \PYG{n+nb}{false}\PYG{p}{;}
        \PYG{n}{sp}\PYG{p}{.}\PYG{n}{use\PYGZus{}spatial} \PYG{o}{=} \PYG{n+nb}{true}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}


\PYG{k+kt}{int} \PYG{n}{SpeciationCommands}\PYG{o}{:}\PYG{o}{:}\PYG{n}{applyFromComargs}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{argc\PYGZus{}in}\PYG{p}{,} \PYG{k+kt}{char}\PYG{o}{*}\PYG{o}{*} \PYG{n}{argv}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{n}{argc} \PYG{o}{=} \PYG{n}{argc\PYGZus{}in}\PYG{p}{;}
    \PYG{n}{importArgs}\PYG{p}{(}\PYG{k}{static\PYGZus{}cast}\PYG{o}{\PYGZlt{}}\PYG{k}{const} \PYG{k+kt}{unsigned} \PYG{k+kt}{int} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{n}{argc}\PYG{p}{)}\PYG{p}{,} \PYG{n}{argv}\PYG{p}{,} \PYG{n}{comargs}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{parseArgs}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{Community} \PYG{n}{tree\PYGZus{}list}\PYG{p}{;}
    \PYG{n}{tree\PYGZus{}list}\PYG{p}{.}\PYG{n}{apply}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{sp}\PYG{p}{)}\PYG{p}{;}
    \PYG{k}{return} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}


\subsubsection{Detailed Description}
\label{\detokenize{api/file_necsim_SpeciationCommands.cpp:detailed-description}}
Samuel Thompson
19/07/2017
BSD-3 Licence. For use on the SQL database outputs of NECSim v3.1+. It requires command line parameters and generates a data object from them. Contact: \sphinxhref{mailto:samuel.thompson14@imperial.ac.uk}{samuel.thompson14@imperial.ac.uk} or \sphinxhref{mailto:thompsonsed@gmail.com}{thompsonsed@gmail.com}


\subsubsection{Includes}
\label{\detokenize{api/file_necsim_SpeciationCommands.cpp:includes}}\begin{itemize}
\item {} 
\sphinxcode{SpeciationCommands.h} ({\hyperref[\detokenize{api/file_necsim_SpeciationCommands.h:file-necsim-speciationcommands-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File SpeciationCommands.h}}}})

\end{itemize}


\subsection{File SpeciationCommands.h}
\label{\detokenize{api/file_necsim_SpeciationCommands.h:file-necsim-speciationcommands-h}}\label{\detokenize{api/file_necsim_SpeciationCommands.h::doc}}\label{\detokenize{api/file_necsim_SpeciationCommands.h:file-speciationcommands-h}}
Contains the {\hyperref[\detokenize{api/class_SpeciationCommands:class-speciationcommands}]{\sphinxcrossref{\DUrole{std,std-ref}{Class SpeciationCommands}}}} class for performing calculations of the coalescence tree structure and generating the SQL database objects.

\begin{sphinxShadowBox}
\sphinxstyletopictitle{Contents}
\begin{itemize}
\item {} 
\phantomsection\label{\detokenize{api/file_necsim_SpeciationCommands.h:id1}}{\hyperref[\detokenize{api/file_necsim_SpeciationCommands.h:definition-necsim-speciationcommands-h}]{\sphinxcrossref{Definition (\sphinxcode{necsim/SpeciationCommands.h})}}}

\item {} 
\phantomsection\label{\detokenize{api/file_necsim_SpeciationCommands.h:id2}}{\hyperref[\detokenize{api/file_necsim_SpeciationCommands.h:detailed-description}]{\sphinxcrossref{Detailed Description}}}

\item {} 
\phantomsection\label{\detokenize{api/file_necsim_SpeciationCommands.h:id3}}{\hyperref[\detokenize{api/file_necsim_SpeciationCommands.h:includes}]{\sphinxcrossref{Includes}}}

\item {} 
\phantomsection\label{\detokenize{api/file_necsim_SpeciationCommands.h:id4}}{\hyperref[\detokenize{api/file_necsim_SpeciationCommands.h:included-by}]{\sphinxcrossref{Included By}}}

\item {} 
\phantomsection\label{\detokenize{api/file_necsim_SpeciationCommands.h:id5}}{\hyperref[\detokenize{api/file_necsim_SpeciationCommands.h:classes}]{\sphinxcrossref{Classes}}}

\end{itemize}
\end{sphinxShadowBox}


\subsubsection{Definition (\sphinxstyleliteralintitle{necsim/SpeciationCommands.h})}
\label{\detokenize{api/file_necsim_SpeciationCommands.h:definition-necsim-speciationcommands-h}}

\paragraph{Program Listing for File SpeciationCommands.h}
\label{\detokenize{api/program_listing_file_necsim_SpeciationCommands.h:program-listing-file-necsim-speciationcommands-h}}\label{\detokenize{api/program_listing_file_necsim_SpeciationCommands.h::doc}}\label{\detokenize{api/program_listing_file_necsim_SpeciationCommands.h:program-listing-for-file-speciationcommands-h}}\begin{itemize}
\item {} 
Return to documentation for {\hyperref[\detokenize{api/file_necsim_SpeciationCommands.h:file-necsim-speciationcommands-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File SpeciationCommands.h}}}}

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{//This file is part of NECSim project which is released under BSD\PYGZhy{}3 license.}
\PYG{c+c1}{//See file **LICENSE.txt** or visit https://opensource.org/licenses/BSD\PYGZhy{}3\PYGZhy{}Clause) for full license details.}

\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}cstdio\PYGZgt{}}

\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZdq{}Community.h\PYGZdq{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZdq{}TreeNode.h\PYGZdq{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZdq{}SpecSimParameters.h\PYGZdq{}}

\PYG{k}{class} \PYG{n+nc}{SpeciationCommands}
\PYG{p}{\PYGZob{}}
\PYG{k}{private}\PYG{o}{:}
    \PYG{c+c1}{// Contains all speciation parameters}
    \PYG{n}{SpecSimParameters} \PYG{n}{sp}\PYG{p}{;}
    \PYG{c+c1}{// Set up for the output coalescence tree}
    \PYG{n}{Row}\PYG{o}{\PYGZlt{}}\PYG{n}{TreeNode}\PYG{o}{\PYGZgt{}} \PYG{n}{data}\PYG{p}{;}
    \PYG{c+c1}{// Command\PYGZhy{}line arguments for parsing}
    \PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{n}{string}\PYG{o}{\PYGZgt{}} \PYG{n}{comargs}\PYG{p}{;}
    \PYG{c+c1}{// number of command\PYGZhy{}line arguments}
    \PYG{k+kt}{int} \PYG{n}{argc}\PYG{p}{;}


\PYG{k}{public}\PYG{o}{:}

    \PYG{n}{SpeciationCommands}\PYG{p}{(}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}

    \PYG{p}{\PYGZcb{}}

    \PYG{k+kt}{void} \PYG{n}{parseArgs}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

    \PYG{k+kt}{int} \PYG{n+nf}{applyFromComargs}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{argc\PYGZus{}in}\PYG{p}{,} \PYG{k+kt}{char} \PYG{o}{*}\PYG{o}{*} \PYG{n}{argv}\PYG{p}{)}\PYG{p}{;}

\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\end{sphinxVerbatim}


\subsubsection{Detailed Description}
\label{\detokenize{api/file_necsim_SpeciationCommands.h:detailed-description}}
Samuel Thompson
19/07/2017
BSD-3 Licence. For use on the SQL database outputs of NECSim v3.1+. It requires command line parameters and generates a data object from them. Contact: \sphinxhref{mailto:samuel.thompson14@imperial.ac.uk}{samuel.thompson14@imperial.ac.uk} or \sphinxhref{mailto:thompsonsed@gmail.com}{thompsonsed@gmail.com}


\subsubsection{Includes}
\label{\detokenize{api/file_necsim_SpeciationCommands.h:includes}}\begin{itemize}
\item {} 
\sphinxcode{Community.h} ({\hyperref[\detokenize{api/file_necsim_Community.h:file-necsim-community-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File Community.h}}}})

\item {} 
\sphinxcode{SpecSimParameters.h} ({\hyperref[\detokenize{api/file_necsim_SpecSimParameters.h:file-necsim-specsimparameters-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File SpecSimParameters.h}}}})

\item {} 
\sphinxcode{TreeNode.h} ({\hyperref[\detokenize{api/file_necsim_TreeNode.h:file-necsim-treenode-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File TreeNode.h}}}})

\item {} 
\sphinxcode{cstdio}

\end{itemize}


\subsubsection{Included By}
\label{\detokenize{api/file_necsim_SpeciationCommands.h:included-by}}\begin{itemize}
\item {} 
{\hyperref[\detokenize{api/file_necsim_SpeciationCommands.cpp:file-necsim-speciationcommands-cpp}]{\sphinxcrossref{\DUrole{std,std-ref}{File SpeciationCommands.cpp}}}}

\end{itemize}


\subsubsection{Classes}
\label{\detokenize{api/file_necsim_SpeciationCommands.h:classes}}\begin{itemize}
\item {} 
{\hyperref[\detokenize{api/class_SpeciationCommands:class-speciationcommands}]{\sphinxcrossref{\DUrole{std,std-ref}{Class SpeciationCommands}}}}

\end{itemize}


\subsection{File SpeciationCounter.cpp}
\label{\detokenize{api/file_SpeciationCounter.cpp:file-speciationcounter-cpp}}\label{\detokenize{api/file_SpeciationCounter.cpp::doc}}\label{\detokenize{api/file_SpeciationCounter.cpp:id1}}
Performs calculations of the coalescence tree structure and generates the SQL database objects.

\begin{sphinxShadowBox}
\sphinxstyletopictitle{Contents}
\begin{itemize}
\item {} 
\phantomsection\label{\detokenize{api/file_SpeciationCounter.cpp:id2}}{\hyperref[\detokenize{api/file_SpeciationCounter.cpp:definition-speciationcounter-cpp}]{\sphinxcrossref{Definition (\sphinxcode{SpeciationCounter.cpp})}}}

\item {} 
\phantomsection\label{\detokenize{api/file_SpeciationCounter.cpp:id3}}{\hyperref[\detokenize{api/file_SpeciationCounter.cpp:detailed-description}]{\sphinxcrossref{Detailed Description}}}

\item {} 
\phantomsection\label{\detokenize{api/file_SpeciationCounter.cpp:id4}}{\hyperref[\detokenize{api/file_SpeciationCounter.cpp:includes}]{\sphinxcrossref{Includes}}}

\item {} 
\phantomsection\label{\detokenize{api/file_SpeciationCounter.cpp:id5}}{\hyperref[\detokenize{api/file_SpeciationCounter.cpp:functions}]{\sphinxcrossref{Functions}}}

\end{itemize}
\end{sphinxShadowBox}


\subsubsection{Definition (\sphinxstyleliteralintitle{SpeciationCounter.cpp})}
\label{\detokenize{api/file_SpeciationCounter.cpp:definition-speciationcounter-cpp}}

\paragraph{Program Listing for File SpeciationCounter.cpp}
\label{\detokenize{api/program_listing_file_SpeciationCounter.cpp:program-listing-file-speciationcounter-cpp}}\label{\detokenize{api/program_listing_file_SpeciationCounter.cpp::doc}}\label{\detokenize{api/program_listing_file_SpeciationCounter.cpp:program-listing-for-file-speciationcounter-cpp}}\begin{itemize}
\item {} 
Return to documentation for {\hyperref[\detokenize{api/file_SpeciationCounter.cpp:file-speciationcounter-cpp}]{\sphinxcrossref{\DUrole{std,std-ref}{File SpeciationCounter.cpp}}}}

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{//This file is part of NECSim project which is released under BSD\PYGZhy{}3 license.}
\PYG{c+c1}{//See file **LICENSE.txt** or visit https://opensource.org/licenses/BSD\PYGZhy{}3\PYGZhy{}Clause) for full license details.}

\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZdq{}necsim/SpeciationCommands.h\PYGZdq{}}

\PYG{k}{using} \PYG{k}{namespace} \PYG{n}{std}\PYG{p}{;}
\PYG{c+c1}{// INPUTS}
\PYG{c+c1}{// requires a SQL database file containing the the TreeNode objects from a coalescence simulations.}
\PYG{c+c1}{// the required speciation rate.}

\PYG{c+c1}{// OUTPUTS}
\PYG{c+c1}{// An updated database file that contains the species richness and species abundances of the intended lineage.}





\PYG{k+kt}{int} \PYG{n+nf}{main}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{argc}\PYG{p}{,} \PYG{k+kt}{char} \PYG{o}{*}\PYG{o}{*}\PYG{n}{argv}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{n}{SpeciationCommands} \PYG{n}{app\PYGZus{}s}\PYG{p}{;}
    \PYG{n}{app\PYGZus{}s}\PYG{p}{.}\PYG{n}{applyFromComargs}\PYG{p}{(}\PYG{n}{argc}\PYG{p}{,} \PYG{n}{argv}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}


\subsubsection{Detailed Description}
\label{\detokenize{api/file_SpeciationCounter.cpp:detailed-description}}
Samuel Thompson
31/08/16
BSD-3 Licence. Requires command line parameters and generates a data object from them. Contact: \sphinxhref{mailto:samuel.thompson14@imperial.ac.uk}{samuel.thompson14@imperial.ac.uk} or \sphinxhref{mailto:thompsonsed@gmail.com}{thompsonsed@gmail.com}


\subsubsection{Includes}
\label{\detokenize{api/file_SpeciationCounter.cpp:includes}}\begin{itemize}
\item {} 
\sphinxcode{/Users/samthompson/Documents/PhD/Code/pycoalescence/pycoalescence/lib/necsim/Community.h}

\item {} 
\sphinxcode{/Users/samthompson/Documents/PhD/Code/pycoalescence/pycoalescence/lib/necsim/SpecSimParameters.h}

\item {} 
\sphinxcode{/Users/samthompson/Documents/PhD/Code/pycoalescence/pycoalescence/lib/necsim/TreeNode.h}

\item {} 
\sphinxcode{cstdio}

\item {} 
\sphinxcode{necsim/SpeciationCommands.h} ({\hyperref[\detokenize{api/file_necsim_SpeciationCommands.h:file-necsim-speciationcommands-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File SpeciationCommands.h}}}})

\end{itemize}


\subsubsection{Functions}
\label{\detokenize{api/file_SpeciationCounter.cpp:functions}}\begin{itemize}
\item {} 
{\hyperref[\detokenize{api/function_main:function-main}]{\sphinxcrossref{\DUrole{std,std-ref}{Function main}}}}

\end{itemize}


\subsection{File SpeciesList.cpp}
\label{\detokenize{api/file_necsim_SpeciesList.cpp:file-necsim-specieslist-cpp}}\label{\detokenize{api/file_necsim_SpeciesList.cpp:file-specieslist-cpp}}\label{\detokenize{api/file_necsim_SpeciesList.cpp::doc}}
\begin{sphinxShadowBox}
\sphinxstyletopictitle{Contents}
\begin{itemize}
\item {} 
\phantomsection\label{\detokenize{api/file_necsim_SpeciesList.cpp:id1}}{\hyperref[\detokenize{api/file_necsim_SpeciesList.cpp:definition-necsim-specieslist-cpp}]{\sphinxcrossref{Definition (\sphinxcode{necsim/SpeciesList.cpp})}}}

\item {} 
\phantomsection\label{\detokenize{api/file_necsim_SpeciesList.cpp:id2}}{\hyperref[\detokenize{api/file_necsim_SpeciesList.cpp:includes}]{\sphinxcrossref{Includes}}}

\item {} 
\phantomsection\label{\detokenize{api/file_necsim_SpeciesList.cpp:id3}}{\hyperref[\detokenize{api/file_necsim_SpeciesList.cpp:functions}]{\sphinxcrossref{Functions}}}

\end{itemize}
\end{sphinxShadowBox}


\subsubsection{Definition (\sphinxstyleliteralintitle{necsim/SpeciesList.cpp})}
\label{\detokenize{api/file_necsim_SpeciesList.cpp:definition-necsim-specieslist-cpp}}

\paragraph{Program Listing for File SpeciesList.cpp}
\label{\detokenize{api/program_listing_file_necsim_SpeciesList.cpp:program-listing-for-file-specieslist-cpp}}\label{\detokenize{api/program_listing_file_necsim_SpeciesList.cpp:program-listing-file-necsim-specieslist-cpp}}\label{\detokenize{api/program_listing_file_necsim_SpeciesList.cpp::doc}}\begin{itemize}
\item {} 
Return to documentation for {\hyperref[\detokenize{api/file_necsim_SpeciesList.cpp:file-necsim-specieslist-cpp}]{\sphinxcrossref{\DUrole{std,std-ref}{File SpeciesList.cpp}}}}

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{//This file is part of NECSim project which is released under BSD\PYGZhy{}3 license.}
\PYG{c+c1}{//See file **LICENSE.txt** or visit https://opensource.org/licenses/BSD\PYGZhy{}3\PYGZhy{}Clause) for full license details.}

\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}iostream\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZdq{}SpeciesList.h\PYGZdq{}}


\PYG{n}{SpeciesList}\PYG{o}{:}\PYG{o}{:}\PYG{n}{SpeciesList}\PYG{p}{(}\PYG{p}{)} \PYG{o}{:} \PYG{n}{list\PYGZus{}size}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{,} \PYG{n}{maxsize}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{,} \PYG{n}{next\PYGZus{}active}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{,} \PYG{n}{nwrap}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{n}{list}\PYG{p}{.}\PYG{n}{setSize}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{void} \PYG{n}{SpeciesList}\PYG{o}{:}\PYG{o}{:}\PYG{n}{fillList}\PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k}{if}\PYG{p}{(}\PYG{n}{maxsize}\PYG{o}{!}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{maxsize}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{list}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
    \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{void} \PYG{n}{SpeciesList}\PYG{o}{:}\PYG{o}{:}\PYG{n}{initialise}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{maxsizein}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{n}{maxsize} \PYG{o}{=} \PYG{n}{maxsizein}\PYG{p}{;}
    \PYG{n}{nwrap} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
    \PYG{n}{list\PYGZus{}size} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
    \PYG{n}{list}\PYG{p}{.}\PYG{n}{setSize}\PYG{p}{(}\PYG{n}{maxsize}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{void} \PYG{n}{SpeciesList}\PYG{o}{:}\PYG{o}{:}\PYG{n}{setMaxsize}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{maxsizein}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{n}{maxsize} \PYG{o}{=} \PYG{n}{maxsizein}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{void} \PYG{n}{SpeciesList}\PYG{o}{:}\PYG{o}{:}\PYG{n}{setSpecies}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{index}\PYG{p}{,} \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{new\PYGZus{}val}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k}{if}\PYG{p}{(}\PYG{n}{list}\PYG{p}{[}\PYG{n}{index}\PYG{p}{]} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{cerr} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{index: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{index} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
        \PYG{n}{cerr} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{list[index]: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{n}{list}\PYG{p}{[}\PYG{n}{index}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
        \PYG{n}{cerr} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{list.maxsize(): }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{maxsize} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
        \PYG{k}{throw} \PYG{n+nf}{runtime\PYGZus{}error}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ERROR\PYGZus{}MOVE\PYGZus{}027: List position to be replaced is zero. Check list assignment.}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{n}{list}\PYG{p}{[}\PYG{n}{index}\PYG{p}{]} \PYG{o}{=} \PYG{n}{new\PYGZus{}val}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{void} \PYG{n}{SpeciesList}\PYG{o}{:}\PYG{o}{:}\PYG{n}{setSpeciesEmpty}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{index}\PYG{p}{,} \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{new\PYGZus{}val}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k}{if}\PYG{p}{(}\PYG{n}{list}\PYG{p}{[}\PYG{n}{index}\PYG{p}{]} \PYG{o}{!}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{cerr} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{index: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{index} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
        \PYG{n}{cerr} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{list[index]: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{n}{list}\PYG{p}{[}\PYG{n}{index}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
        \PYG{n}{cerr} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{list.maxsize(): }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{maxsize} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
        \PYG{k}{throw} \PYG{n+nf}{runtime\PYGZus{}error}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ERROR\PYGZus{}MOVE\PYGZus{}027b: List position to be replaced is not zero. Check list assignment.}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{n}{list}\PYG{p}{[}\PYG{n}{index}\PYG{p}{]} \PYG{o}{=} \PYG{n}{new\PYGZus{}val}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{void} \PYG{n}{SpeciesList}\PYG{o}{:}\PYG{o}{:}\PYG{n}{setNext}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{n}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{n}{next\PYGZus{}active} \PYG{o}{=} \PYG{n}{n}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{void} \PYG{n}{SpeciesList}\PYG{o}{:}\PYG{o}{:}\PYG{n}{setNwrap}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{nr}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{n}{nwrap} \PYG{o}{=} \PYG{n}{nr}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{SpeciesList}\PYG{o}{:}\PYG{o}{:}\PYG{n}{addSpecies}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{new\PYGZus{}spec}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifdef DEBUG}
    \PYG{k}{if}\PYG{p}{(}\PYG{n}{list\PYGZus{}size} \PYG{o}{+} \PYG{l+m+mi}{1} \PYG{o}{\PYGZgt{}} \PYG{n}{maxsize}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{cerr} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{maxsize: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{maxsize} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
        \PYG{k}{throw} \PYG{n+nf}{out\PYGZus{}of\PYGZus{}range}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Could not add species \PYGZhy{} no empty space}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif}
    \PYG{c+c1}{// First loop from the list size value}
    \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{i} \PYG{o}{=} \PYG{n}{list\PYGZus{}size}\PYG{p}{;} \PYG{n}{i}\PYG{o}{\PYGZlt{}}\PYG{n}{list}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{list}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{list\PYGZus{}size}\PYG{o}{+}\PYG{o}{+}\PYG{p}{;}
            \PYG{n}{list}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{=} \PYG{n}{new\PYGZus{}spec}\PYG{p}{;}
            \PYG{k}{return} \PYG{n}{i}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
    \PYG{p}{\PYGZcb{}}
    \PYG{c+c1}{// Now loop over the rest of the lineages}
    \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{list\PYGZus{}size}\PYG{p}{;} \PYG{n}{i} \PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{list}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{list\PYGZus{}size}\PYG{o}{+}\PYG{o}{+}\PYG{p}{;}
            \PYG{n}{list}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{=} \PYG{n}{new\PYGZus{}spec}\PYG{p}{;}
            \PYG{k}{return} \PYG{n}{i}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
    \PYG{p}{\PYGZcb{}}
    \PYG{n}{cerr} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{maxsize: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{maxsize} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
    \PYG{k}{throw} \PYG{n+nf}{out\PYGZus{}of\PYGZus{}range}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Could not add species \PYGZhy{} no empty space}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{void} \PYG{n}{SpeciesList}\PYG{o}{:}\PYG{o}{:}\PYG{n}{addSpeciesSilent}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{new\PYGZus{}spec}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{i} \PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;}\PYG{n}{i}\PYG{o}{\PYGZlt{}}\PYG{n}{maxsize}\PYG{p}{;}\PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{list}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{list\PYGZus{}size}\PYG{o}{+}\PYG{o}{+}\PYG{p}{;}
            \PYG{n}{list}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{=} \PYG{n}{new\PYGZus{}spec}\PYG{p}{;}
            \PYG{k}{return}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}

    \PYG{p}{\PYGZcb{}}
    \PYG{k}{throw} \PYG{n}{out\PYGZus{}of\PYGZus{}range}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Could not add species \PYGZhy{} no empty space}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{void} \PYG{n}{SpeciesList}\PYG{o}{:}\PYG{o}{:}\PYG{n}{deleteSpecies}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{index}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{n}{list}\PYG{p}{[}\PYG{n}{index}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
    \PYG{n}{list\PYGZus{}size} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{void} \PYG{n}{SpeciesList}\PYG{o}{:}\PYG{o}{:}\PYG{n}{decreaseNwrap}\PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k}{if}\PYG{p}{(}\PYG{n}{nwrap} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{throw} \PYG{n}{runtime\PYGZus{}error}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Nwrap should never be decreased less than 0}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{else} \PYG{k}{if}\PYG{p}{(}\PYG{n}{nwrap} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{if}\PYG{p}{(} \PYG{n}{next\PYGZus{}active} \PYG{o}{!}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{k}{throw} \PYG{n}{runtime\PYGZus{}error}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Nwrap is being set at 0 when an wrapped lineage is still present}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
    \PYG{p}{\PYGZcb{}}
    \PYG{n}{nwrap} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{void} \PYG{n}{SpeciesList}\PYG{o}{:}\PYG{o}{:}\PYG{n}{increaseListSize}\PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{n}{list\PYGZus{}size} \PYG{o}{+}\PYG{o}{+}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{void} \PYG{n}{SpeciesList}\PYG{o}{:}\PYG{o}{:}\PYG{n}{increaseNwrap}\PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{n}{nwrap} \PYG{o}{+}\PYG{o}{+}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{void} \PYG{n}{SpeciesList}\PYG{o}{:}\PYG{o}{:}\PYG{n}{changePercentCover}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{newmaxsize}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{n}{Row}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{unsigned} \PYG{k+kt}{long}\PYG{o}{\PYGZgt{}} \PYG{n}{templist}\PYG{p}{(}\PYG{n}{list}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{maxsize} \PYG{o}{=} \PYG{n}{newmaxsize}\PYG{p}{;}
    \PYG{n}{list}\PYG{p}{.}\PYG{n}{setSize}\PYG{p}{(}\PYG{n}{newmaxsize}\PYG{p}{)}\PYG{p}{;}
    \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{int} \PYG{n}{i}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;}\PYG{n}{i}\PYG{o}{\PYGZlt{}}\PYG{n}{newmaxsize}\PYG{p}{;}\PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{i}\PYG{o}{\PYGZlt{}}\PYG{n}{templist}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{list}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{=} \PYG{n}{templist}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{else}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{list}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
    \PYG{p}{\PYGZcb{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifdef DEBUG}
    \PYG{k}{if}\PYG{p}{(}\PYG{n}{list}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZgt{}} \PYG{n}{maxsize}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{cerr} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{list.size(): }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{list}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
            \PYG{n}{cerr} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{maxsize: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{maxsize} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
            \PYG{k}{throw} \PYG{n+nf}{out\PYGZus{}of\PYGZus{}range}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{List size not equal to maxsize}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{SpeciesList}\PYG{o}{:}\PYG{o}{:}\PYG{n}{getRandLineage}\PYG{p}{(}\PYG{n}{NRrand} \PYG{o}{\PYGZam{}}\PYG{n}{rand\PYGZus{}no}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k+kt}{double} \PYG{n}{rand\PYGZus{}index}\PYG{p}{;}
    \PYG{k}{if}\PYG{p}{(}\PYG{n}{maxsize} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{n}{list\PYGZus{}size}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{c+c1}{// Then the list size is larger than the actual size. This means we must return a lineage.}
        \PYG{k}{try}
        \PYG{p}{\PYGZob{}}
            \PYG{k}{do}
            \PYG{p}{\PYGZob{}}
                \PYG{n}{rand\PYGZus{}index} \PYG{o}{=} \PYG{n}{rand\PYGZus{}no}\PYG{p}{.}\PYG{n}{d01}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
                \PYG{n}{rand\PYGZus{}index} \PYG{o}{*}\PYG{o}{=} \PYG{n}{list}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
                \PYG{c+c1}{//os \PYGZlt{}\PYGZlt{} \PYGZdq{}ref: \PYGZdq{} \PYGZlt{}\PYGZlt{} rand\PYGZus{}index \PYGZlt{}\PYGZlt{} \PYGZdq{}, \PYGZdq{} \PYGZlt{}\PYGZlt{} list[round(rand\PYGZus{}index)] \PYGZlt{}\PYGZlt{} endl;}
            \PYG{p}{\PYGZcb{}} \PYG{k}{while}\PYG{p}{(}\PYG{n}{list}\PYG{p}{[}\PYG{n}{floor}\PYG{p}{(}\PYG{n}{rand\PYGZus{}index}\PYG{p}{)}\PYG{p}{]} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}
            \PYG{c+c1}{//os \PYGZlt{}\PYGZlt{} \PYGZdq{}RETURNING!\PYGZdq{} \PYGZlt{}\PYGZlt{} endl;}
            \PYG{k}{return}\PYG{p}{(}\PYG{n}{list}\PYG{p}{[}\PYG{n}{floor}\PYG{p}{(}\PYG{n}{rand\PYGZus{}index}\PYG{p}{)}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{catch}\PYG{p}{(}\PYG{n}{out\PYGZus{}of\PYGZus{}range} \PYG{o}{\PYGZam{}}\PYG{n}{oor}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{cerr} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{oor}\PYG{p}{.}\PYG{n}{what}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
            \PYG{k}{throw} \PYG{n+nf}{runtime\PYGZus{}error}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ERROR\PYGZus{}MOVE\PYGZus{}001b: Listpos outside maxsize.}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{else}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{rand\PYGZus{}index} \PYG{o}{=}  \PYG{n}{rand\PYGZus{}no}\PYG{p}{.}\PYG{n}{d01}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{c+c1}{//      os \PYGZlt{}\PYGZlt{} \PYGZdq{}rand\PYGZus{}index: \PYGZdq{} \PYGZlt{}\PYGZlt{} rand\PYGZus{}index \PYGZlt{}\PYGZlt{} endl;}
        \PYG{n}{rand\PYGZus{}index}  \PYG{o}{*}\PYG{o}{=} \PYG{n}{maxsize}\PYG{p}{;}
        \PYG{c+c1}{// Dynamically resize the list if required. Otherwise, to save memory, the list will not be resized;}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{rand\PYGZus{}index}\PYG{o}{\PYGZgt{}}\PYG{o}{=}\PYG{n}{list}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{changePercentCover}\PYG{p}{(}\PYG{n}{maxsize}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}

        \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{i} \PYG{o}{=} \PYG{k}{static\PYGZus{}cast}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{unsigned} \PYG{k+kt}{long}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{n}{floor}\PYG{p}{(}\PYG{n}{rand\PYGZus{}index}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}

\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifdef DEBUG}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{rand\PYGZus{}index}\PYG{o}{\PYGZgt{}}\PYG{n}{maxsize}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{n}{stringstream} \PYG{n}{ss}\PYG{p}{;}
                \PYG{n}{ss} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Random index is greater than the max size. Fatal error, please report this bug.}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
                \PYG{k}{throw} \PYG{n+nf}{runtime\PYGZus{}error}\PYG{p}{(}\PYG{n}{ss}\PYG{p}{.}\PYG{n}{str}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif }\PYG{c+c1}{// DEBUG}
        \PYG{k}{return} \PYG{n}{list}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{SpeciesList}\PYG{o}{:}\PYG{o}{:}\PYG{n}{getSpecies}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{index}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k}{return} \PYG{n}{list}\PYG{p}{[}\PYG{n}{index}\PYG{p}{]}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{SpeciesList}\PYG{o}{:}\PYG{o}{:}\PYG{n}{getNext}\PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k}{return} \PYG{n}{next\PYGZus{}active}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{SpeciesList}\PYG{o}{:}\PYG{o}{:}\PYG{n}{getNwrap}\PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k}{return} \PYG{n}{nwrap}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{SpeciesList}\PYG{o}{:}\PYG{o}{:}\PYG{n}{getListsize}\PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k}{return} \PYG{n}{list\PYGZus{}size}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{SpeciesList}\PYG{o}{:}\PYG{o}{:}\PYG{n}{getMaxsize}\PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k}{return} \PYG{n}{maxsize}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{void} \PYG{n}{SpeciesList}\PYG{o}{:}\PYG{o}{:}\PYG{n}{wipeList}\PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{n}{fillList}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{next\PYGZus{}active}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;}
    \PYG{n}{nwrap} \PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;}
    \PYG{n}{list\PYGZus{}size}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{n}{ostream} \PYG{o}{\PYGZam{}}\PYG{k}{operator}\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{p}{(}\PYG{n}{ostream} \PYG{o}{\PYGZam{}}\PYG{n}{os}\PYG{p}{,} \PYG{k}{const} \PYG{n}{SpeciesList} \PYG{o}{\PYGZam{}}\PYG{n}{r}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{c+c1}{//os \PYGZlt{}\PYGZlt{} m.numRows\PYGZlt{}\PYGZlt{}\PYGZdq{} , \PYGZdq{}\PYGZlt{}\PYGZlt{}m.numCols\PYGZlt{}\PYGZlt{}\PYGZdq{} , \PYGZdq{}\PYGZlt{}\PYGZlt{}endl;}
    \PYG{n}{os} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{r}\PYG{p}{.}\PYG{n}{list} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{,}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
    \PYG{n}{os} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{r}\PYG{p}{.}\PYG{n}{list\PYGZus{}size} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{,}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
    \PYG{n}{os} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{r}\PYG{p}{.}\PYG{n}{maxsize} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{,}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
    \PYG{n}{os} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{r}\PYG{p}{.}\PYG{n}{next\PYGZus{}active} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{,}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
    \PYG{n}{os} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{r}\PYG{p}{.}\PYG{n}{nwrap} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{,}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
    \PYG{k}{return} \PYG{n}{os}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{n}{istream} \PYG{o}{\PYGZam{}}\PYG{k}{operator}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{n}{istream} \PYG{o}{\PYGZam{}}\PYG{n}{is}\PYG{p}{,} \PYG{n}{SpeciesList} \PYG{o}{\PYGZam{}}\PYG{n}{r}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k+kt}{char} \PYG{n}{delim}\PYG{p}{;}
    \PYG{c+c1}{//double temp1,temp2;}
    \PYG{c+c1}{//is \PYGZlt{}\PYGZlt{} m.numRows\PYGZlt{}\PYGZlt{}\PYGZdq{} , \PYGZdq{}\PYGZlt{}\PYGZlt{}m.numCols\PYGZlt{}\PYGZlt{}\PYGZdq{} , \PYGZdq{}\PYGZlt{}\PYGZlt{}endl;}
    \PYG{n}{is} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{r}\PYG{p}{.}\PYG{n}{list}\PYG{p}{;}
    \PYG{n}{is} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{delim}\PYG{p}{;}
    \PYG{n}{is} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{r}\PYG{p}{.}\PYG{n}{list\PYGZus{}size}\PYG{p}{;}
    \PYG{n}{is} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{delim}\PYG{p}{;}
    \PYG{n}{is} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{r}\PYG{p}{.}\PYG{n}{maxsize}\PYG{p}{;}
    \PYG{n}{is} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{delim}\PYG{p}{;}
    \PYG{n}{is} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{r}\PYG{p}{.}\PYG{n}{next\PYGZus{}active}\PYG{p}{;}
    \PYG{n}{is} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{delim}\PYG{p}{;}
    \PYG{n}{is} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{r}\PYG{p}{.}\PYG{n}{nwrap}\PYG{p}{;}
    \PYG{n}{is} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{delim}\PYG{p}{;}
    \PYG{k}{return} \PYG{n}{is}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}


\subsubsection{Includes}
\label{\detokenize{api/file_necsim_SpeciesList.cpp:includes}}\begin{itemize}
\item {} 
\sphinxcode{SpeciesList.h} ({\hyperref[\detokenize{api/file_necsim_SpeciesList.h:file-necsim-specieslist-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File SpeciesList.h}}}})

\item {} 
\sphinxcode{iostream}

\end{itemize}


\subsubsection{Functions}
\label{\detokenize{api/file_necsim_SpeciesList.cpp:functions}}\begin{itemize}
\item {} 
{\hyperref[\detokenize{api/function_operator_LT__LT:function-operator-lt-lt}]{\sphinxcrossref{\DUrole{std,std-ref}{Function operator\textless{}\textless{}}}}}

\item {} 
{\hyperref[\detokenize{api/function_operator_GT__GT:function-operator-gt-gt}]{\sphinxcrossref{\DUrole{std,std-ref}{Function operator\textgreater{}\textgreater{}}}}}

\end{itemize}


\subsection{File SpeciesList.h}
\label{\detokenize{api/file_necsim_SpeciesList.h:file-necsim-specieslist-h}}\label{\detokenize{api/file_necsim_SpeciesList.h::doc}}\label{\detokenize{api/file_necsim_SpeciesList.h:file-specieslist-h}}
Contains the {\hyperref[\detokenize{api/class_SpeciesList:class-specieslist}]{\sphinxcrossref{\DUrole{std,std-ref}{Class SpeciesList}}}} class for usage in coalescence simulations.

\begin{sphinxShadowBox}
\sphinxstyletopictitle{Contents}
\begin{itemize}
\item {} 
\phantomsection\label{\detokenize{api/file_necsim_SpeciesList.h:id1}}{\hyperref[\detokenize{api/file_necsim_SpeciesList.h:definition-necsim-specieslist-h}]{\sphinxcrossref{Definition (\sphinxcode{necsim/SpeciesList.h})}}}

\item {} 
\phantomsection\label{\detokenize{api/file_necsim_SpeciesList.h:id2}}{\hyperref[\detokenize{api/file_necsim_SpeciesList.h:detailed-description}]{\sphinxcrossref{Detailed Description}}}

\item {} 
\phantomsection\label{\detokenize{api/file_necsim_SpeciesList.h:id3}}{\hyperref[\detokenize{api/file_necsim_SpeciesList.h:includes}]{\sphinxcrossref{Includes}}}

\item {} 
\phantomsection\label{\detokenize{api/file_necsim_SpeciesList.h:id4}}{\hyperref[\detokenize{api/file_necsim_SpeciesList.h:included-by}]{\sphinxcrossref{Included By}}}

\item {} 
\phantomsection\label{\detokenize{api/file_necsim_SpeciesList.h:id5}}{\hyperref[\detokenize{api/file_necsim_SpeciesList.h:classes}]{\sphinxcrossref{Classes}}}

\end{itemize}
\end{sphinxShadowBox}


\subsubsection{Definition (\sphinxstyleliteralintitle{necsim/SpeciesList.h})}
\label{\detokenize{api/file_necsim_SpeciesList.h:definition-necsim-specieslist-h}}

\paragraph{Program Listing for File SpeciesList.h}
\label{\detokenize{api/program_listing_file_necsim_SpeciesList.h:program-listing-for-file-specieslist-h}}\label{\detokenize{api/program_listing_file_necsim_SpeciesList.h:program-listing-file-necsim-specieslist-h}}\label{\detokenize{api/program_listing_file_necsim_SpeciesList.h::doc}}\begin{itemize}
\item {} 
Return to documentation for {\hyperref[\detokenize{api/file_necsim_SpeciesList.h:file-necsim-specieslist-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File SpeciesList.h}}}}

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{//This file is part of NECSim project which is released under BSD\PYGZhy{}3 license.}
\PYG{c+c1}{//See file **LICENSE.txt** or visit https://opensource.org/licenses/BSD\PYGZhy{}3\PYGZhy{}Clause) for full license details.}

 \PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifndef SPECIESLIST}
 \PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define SPECIESLIST}


\PYG{k}{using} \PYG{k}{namespace} \PYG{n}{std}\PYG{p}{;}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZdq{}Matrix.h\PYGZdq{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZdq{}NRrand.h\PYGZdq{}}

\PYG{k}{class} \PYG{n+nc}{SpeciesList}
\PYG{p}{\PYGZob{}}
\PYG{k}{private}\PYG{o}{:}
    \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{list\PYGZus{}size}\PYG{p}{,}\PYG{n}{maxsize}\PYG{p}{;} \PYG{c+c1}{// List size and maximum size of the cell (based on percentage cover).}
    \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{next\PYGZus{}active}\PYG{p}{;} \PYG{c+c1}{// For calculating the wrapping, using the next and last system.}
    \PYG{n}{Row}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{unsigned} \PYG{k+kt}{long}\PYG{o}{\PYGZgt{}} \PYG{n}{list}\PYG{p}{;} \PYG{c+c1}{// list of the active reference number, with zeros for empty cells.}
    \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{nwrap}\PYG{p}{;} \PYG{c+c1}{// The number of wrapping (next and last possibilities) that there are.}
\PYG{k}{public}\PYG{o}{:}
    \PYG{n}{SpeciesList}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

    \PYG{o}{\PYGZti{}}\PYG{n}{SpeciesList}\PYG{p}{(}\PYG{p}{)} \PYG{o}{=} \PYG{k}{default}\PYG{p}{;}
    \PYG{c+c1}{// Sets the list size to the required length.}
    \PYG{c+c1}{// Note this will delete any species currently stored in the list}

    \PYG{c+c1}{// Fill the list with empty 0s.}
    \PYG{k+kt}{void} \PYG{n+nf}{fillList}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

    \PYG{c+c1}{// Standard setters}
    \PYG{k+kt}{void} \PYG{n+nf}{initialise}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{maxsizein}\PYG{p}{)}\PYG{p}{;}

    \PYG{c+c1}{// special case if just the maxsize wants to be change, but want to maintain the list variables.}
    \PYG{k+kt}{void} \PYG{n+nf}{setMaxsize}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{maxsizein}\PYG{p}{)}\PYG{p}{;}

    \PYG{k+kt}{void} \PYG{n+nf}{setSpecies}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{index}\PYG{p}{,} \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{new\PYGZus{}val}\PYG{p}{)}\PYG{p}{;}

    \PYG{k+kt}{void} \PYG{n+nf}{setSpeciesEmpty}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{index}\PYG{p}{,} \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{new\PYGZus{}val}\PYG{p}{)}\PYG{p}{;}

    \PYG{k+kt}{void} \PYG{n+nf}{setNext}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{n}\PYG{p}{)}\PYG{p}{;}


    \PYG{k+kt}{void} \PYG{n+nf}{setNwrap}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{nr}\PYG{p}{)}\PYG{p}{;}

    \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n+nf}{addSpecies}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{new\PYGZus{}spec}\PYG{p}{)}\PYG{p}{;}

    \PYG{k+kt}{void} \PYG{n+nf}{addSpeciesSilent}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{new\PYGZus{}spec}\PYG{p}{)}\PYG{p}{;}

    \PYG{k+kt}{void} \PYG{n+nf}{deleteSpecies}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{index}\PYG{p}{)}\PYG{p}{;}

    \PYG{k+kt}{void} \PYG{n+nf}{decreaseNwrap}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kt}{void} \PYG{n+nf}{increaseListSize}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

    \PYG{k+kt}{void} \PYG{n+nf}{increaseNwrap}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

    \PYG{k+kt}{void} \PYG{n+nf}{changePercentCover}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{newmaxsize}\PYG{p}{)}\PYG{p}{;}

    \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n+nf}{getRandLineage}\PYG{p}{(}\PYG{n}{NRrand} \PYG{o}{\PYGZam{}}\PYG{n}{rand\PYGZus{}no}\PYG{p}{)}\PYG{p}{;}

    \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n+nf}{getSpecies}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{index}\PYG{p}{)}\PYG{p}{;}

    \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n+nf}{getNext}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

    \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n+nf}{getNwrap}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

    \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n+nf}{getListsize}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

    \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n+nf}{getMaxsize}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

    \PYG{k+kt}{void} \PYG{n+nf}{wipeList}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

    \PYG{k}{friend} \PYG{n}{ostream}\PYG{o}{\PYGZam{}} \PYG{k}{operator}\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{p}{(}\PYG{n}{ostream}\PYG{o}{\PYGZam{}} \PYG{n}{os}\PYG{p}{,}\PYG{k}{const} \PYG{n}{SpeciesList}\PYG{o}{\PYGZam{}} \PYG{n}{r}\PYG{p}{)}\PYG{p}{;}

    \PYG{k}{friend} \PYG{n}{istream}\PYG{o}{\PYGZam{}} \PYG{k}{operator}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{n}{istream}\PYG{o}{\PYGZam{}} \PYG{n}{is}\PYG{p}{,} \PYG{n}{SpeciesList}\PYG{o}{\PYGZam{}} \PYG{n}{r}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}

\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif}
\end{sphinxVerbatim}


\subsubsection{Detailed Description}
\label{\detokenize{api/file_necsim_SpeciesList.h:detailed-description}}
Samuel Thompson
BSD-3 Licence.


\subsubsection{Includes}
\label{\detokenize{api/file_necsim_SpeciesList.h:includes}}\begin{itemize}
\item {} 
\sphinxcode{Matrix.h} ({\hyperref[\detokenize{api/file_necsim_Matrix.h:file-necsim-matrix-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File Matrix.h}}}})

\item {} 
\sphinxcode{NRrand.h} ({\hyperref[\detokenize{api/file_necsim_NRrand.h:file-necsim-nrrand-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File NRrand.h}}}})

\end{itemize}


\subsubsection{Included By}
\label{\detokenize{api/file_necsim_SpeciesList.h:included-by}}\begin{itemize}
\item {} 
{\hyperref[\detokenize{api/file_necsim_SpatialTree.h:file-necsim-spatialtree-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File SpatialTree.h}}}}

\item {} 
{\hyperref[\detokenize{api/file_necsim_SpeciesList.cpp:file-necsim-specieslist-cpp}]{\sphinxcrossref{\DUrole{std,std-ref}{File SpeciesList.cpp}}}}

\end{itemize}


\subsubsection{Classes}
\label{\detokenize{api/file_necsim_SpeciesList.h:classes}}\begin{itemize}
\item {} 
{\hyperref[\detokenize{api/class_SpeciesList:class-specieslist}]{\sphinxcrossref{\DUrole{std,std-ref}{Class SpeciesList}}}}

\end{itemize}


\subsection{File SpecSimParameters.h}
\label{\detokenize{api/file_necsim_SpecSimParameters.h:file-specsimparameters-h}}\label{\detokenize{api/file_necsim_SpecSimParameters.h:file-necsim-specsimparameters-h}}\label{\detokenize{api/file_necsim_SpecSimParameters.h::doc}}
Contains parameters for applying speciation rates post-simulation.

\begin{sphinxShadowBox}
\sphinxstyletopictitle{Contents}
\begin{itemize}
\item {} 
\phantomsection\label{\detokenize{api/file_necsim_SpecSimParameters.h:id1}}{\hyperref[\detokenize{api/file_necsim_SpecSimParameters.h:definition-necsim-specsimparameters-h}]{\sphinxcrossref{Definition (\sphinxcode{necsim/SpecSimParameters.h})}}}

\item {} 
\phantomsection\label{\detokenize{api/file_necsim_SpecSimParameters.h:id2}}{\hyperref[\detokenize{api/file_necsim_SpecSimParameters.h:detailed-description}]{\sphinxcrossref{Detailed Description}}}

\item {} 
\phantomsection\label{\detokenize{api/file_necsim_SpecSimParameters.h:id3}}{\hyperref[\detokenize{api/file_necsim_SpecSimParameters.h:included-by}]{\sphinxcrossref{Included By}}}

\item {} 
\phantomsection\label{\detokenize{api/file_necsim_SpecSimParameters.h:id4}}{\hyperref[\detokenize{api/file_necsim_SpecSimParameters.h:classes}]{\sphinxcrossref{Classes}}}

\end{itemize}
\end{sphinxShadowBox}


\subsubsection{Definition (\sphinxstyleliteralintitle{necsim/SpecSimParameters.h})}
\label{\detokenize{api/file_necsim_SpecSimParameters.h:definition-necsim-specsimparameters-h}}

\paragraph{Program Listing for File SpecSimParameters.h}
\label{\detokenize{api/program_listing_file_necsim_SpecSimParameters.h:program-listing-file-necsim-specsimparameters-h}}\label{\detokenize{api/program_listing_file_necsim_SpecSimParameters.h:program-listing-for-file-specsimparameters-h}}\label{\detokenize{api/program_listing_file_necsim_SpecSimParameters.h::doc}}\begin{itemize}
\item {} 
Return to documentation for {\hyperref[\detokenize{api/file_necsim_SpecSimParameters.h:file-necsim-specsimparameters-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File SpecSimParameters.h}}}}

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{//This file is part of NECSim project which is released under BSD\PYGZhy{}3 license.}
\PYG{c+c1}{//See file **LICENSE.txt** or visit https://opensource.org/licenses/BSD\PYGZhy{}3\PYGZhy{}Clause) for full license details.}

\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifndef SPECIATIONCOUNTER\PYGZus{}SPECSIMPARAMETERS\PYGZus{}H}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define SPECIATIONCOUNTER\PYGZus{}SPECSIMPARAMETERS\PYGZus{}H}


\PYG{k}{struct} \PYG{n}{SpecSimParameters}
\PYG{p}{\PYGZob{}}
    \PYG{k+kt}{bool} \PYG{n}{use\PYGZus{}spatial}\PYG{p}{;}
    \PYG{k+kt}{bool} \PYG{n}{bMultiRun}\PYG{p}{;}
    \PYG{k+kt}{bool} \PYG{n}{use\PYGZus{}fragments}\PYG{p}{;}
    \PYG{n}{string} \PYG{n}{filename}\PYG{p}{;}
    \PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{double}\PYG{o}{\PYGZgt{}} \PYG{n}{all\PYGZus{}speciation\PYGZus{}rates}\PYG{p}{;}
    \PYG{n}{string} \PYG{n}{samplemask}\PYG{p}{;}
    \PYG{n}{string} \PYG{n}{times\PYGZus{}file}\PYG{p}{;}
    \PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{double}\PYG{o}{\PYGZgt{}} \PYG{n}{all\PYGZus{}times}\PYG{p}{;}
    \PYG{n}{string} \PYG{n}{fragment\PYGZus{}config\PYGZus{}file}\PYG{p}{;}
    \PYG{k+kt}{double} \PYG{n}{min\PYGZus{}speciation\PYGZus{}gen}\PYG{p}{,} \PYG{n}{max\PYGZus{}speciation\PYGZus{}gen}\PYG{p}{;}
    \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{metacommunity\PYGZus{}size}\PYG{p}{;}
    \PYG{k+kt}{double} \PYG{n}{metacommunity\PYGZus{}speciation\PYGZus{}rate}\PYG{p}{;}

    \PYG{k+kt}{void} \PYG{n+nf}{setup}\PYG{p}{(}\PYG{n}{string} \PYG{n}{file\PYGZus{}in}\PYG{p}{,} \PYG{k+kt}{bool} \PYG{n}{use\PYGZus{}spatial\PYGZus{}in}\PYG{p}{,} \PYG{n}{string} \PYG{n}{sample\PYGZus{}file}\PYG{p}{,} \PYG{n}{string} \PYG{n}{time\PYGZus{}config}\PYG{p}{,} \PYG{n}{string} \PYG{n}{use\PYGZus{}fragments\PYGZus{}in}\PYG{p}{,}
               \PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{double}\PYG{o}{\PYGZgt{}} \PYG{n}{speciation\PYGZus{}rates}\PYG{p}{,} \PYG{k+kt}{double} \PYG{n}{min\PYGZus{}speciation\PYGZus{}gen\PYGZus{}in}\PYG{p}{,} \PYG{k+kt}{double} \PYG{n}{max\PYGZus{}speciation\PYGZus{}gen\PYGZus{}in}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{setup}\PYG{p}{(}\PYG{n}{file\PYGZus{}in}\PYG{p}{,} \PYG{n}{use\PYGZus{}spatial\PYGZus{}in}\PYG{p}{,} \PYG{n}{sample\PYGZus{}file}\PYG{p}{,} \PYG{n}{time\PYGZus{}config}\PYG{p}{,} \PYG{n}{use\PYGZus{}fragments\PYGZus{}in}\PYG{p}{,} \PYG{n}{speciation\PYGZus{}rates}\PYG{p}{,}
              \PYG{n}{min\PYGZus{}speciation\PYGZus{}gen\PYGZus{}in}\PYG{p}{,} \PYG{n}{max\PYGZus{}speciation\PYGZus{}gen\PYGZus{}in}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mf}{0.0}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{k+kt}{void} \PYG{n+nf}{setup}\PYG{p}{(}\PYG{n}{string} \PYG{n}{file\PYGZus{}in}\PYG{p}{,} \PYG{k+kt}{bool} \PYG{n}{use\PYGZus{}spatial\PYGZus{}in}\PYG{p}{,} \PYG{n}{string} \PYG{n}{sample\PYGZus{}file}\PYG{p}{,} \PYG{n}{string} \PYG{n}{time\PYGZus{}config}\PYG{p}{,} \PYG{n}{string} \PYG{n}{use\PYGZus{}fragments\PYGZus{}in}\PYG{p}{,}
               \PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{double}\PYG{o}{\PYGZgt{}} \PYG{n}{speciation\PYGZus{}rates}\PYG{p}{,} \PYG{k+kt}{double} \PYG{n}{min\PYGZus{}speciation\PYGZus{}gen\PYGZus{}in}\PYG{p}{,} \PYG{k+kt}{double} \PYG{n}{max\PYGZus{}speciation\PYGZus{}gen\PYGZus{}in}\PYG{p}{,}
               \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{metacommunity\PYGZus{}size\PYGZus{}in}\PYG{p}{,} \PYG{k+kt}{double} \PYG{n}{metacommunity\PYGZus{}speciation\PYGZus{}rate\PYGZus{}in}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{filename} \PYG{o}{=} \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{move}\PYG{p}{(}\PYG{n}{file\PYGZus{}in}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{use\PYGZus{}spatial} \PYG{o}{=} \PYG{n}{use\PYGZus{}spatial\PYGZus{}in}\PYG{p}{;}
        \PYG{n}{samplemask} \PYG{o}{=} \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{move}\PYG{p}{(}\PYG{n}{sample\PYGZus{}file}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{times\PYGZus{}file} \PYG{o}{=} \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{move}\PYG{p}{(}\PYG{n}{time\PYGZus{}config}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{min\PYGZus{}speciation\PYGZus{}gen} \PYG{o}{=} \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{move}\PYG{p}{(}\PYG{n}{min\PYGZus{}speciation\PYGZus{}gen\PYGZus{}in}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{max\PYGZus{}speciation\PYGZus{}gen} \PYG{o}{=} \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{move}\PYG{p}{(}\PYG{n}{max\PYGZus{}speciation\PYGZus{}gen\PYGZus{}in}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{importTimeConfig}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{use\PYGZus{}fragments} \PYG{o}{=} \PYG{o}{!}\PYG{p}{(}\PYG{n}{use\PYGZus{}fragments\PYGZus{}in} \PYG{o}{=}\PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{F}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{fragment\PYGZus{}config\PYGZus{}file} \PYG{o}{=} \PYG{n}{use\PYGZus{}fragments\PYGZus{}in}\PYG{p}{;}
        \PYG{n}{bMultiRun} \PYG{o}{=} \PYG{n}{speciation\PYGZus{}rates}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{1}\PYG{p}{;}
        \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{double} \PYG{n+nl}{speciation\PYGZus{}rate} \PYG{p}{:} \PYG{n}{speciation\PYGZus{}rates}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{all\PYGZus{}speciation\PYGZus{}rates}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{n}{speciation\PYGZus{}rate}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{n}{metacommunity\PYGZus{}size} \PYG{o}{=} \PYG{n}{metacommunity\PYGZus{}size\PYGZus{}in}\PYG{p}{;}
        \PYG{n}{metacommunity\PYGZus{}speciation\PYGZus{}rate} \PYG{o}{=} \PYG{n}{metacommunity\PYGZus{}speciation\PYGZus{}rate\PYGZus{}in}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{k+kt}{void} \PYG{n+nf}{importTimeConfig}\PYG{p}{(}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{times\PYGZus{}file} \PYG{o}{=}\PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{null}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{all\PYGZus{}times}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{l+m+mf}{0.0}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{else}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{n}{string}\PYG{o}{\PYGZgt{}} \PYG{n}{tmpimport}\PYG{p}{;}
            \PYG{n}{ConfigOption} \PYG{n}{tmpconfig}\PYG{p}{;}
            \PYG{n}{tmpconfig}\PYG{p}{.}\PYG{n}{setConfig}\PYG{p}{(}\PYG{n}{times\PYGZus{}file}\PYG{p}{,} \PYG{n+nb}{false}\PYG{p}{)}\PYG{p}{;}
            \PYG{n}{tmpconfig}\PYG{p}{.}\PYG{n}{importConfig}\PYG{p}{(}\PYG{n}{tmpimport}\PYG{p}{)}\PYG{p}{;}
            \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{tmpimport}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{n}{all\PYGZus{}times}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{n}{stod}\PYG{p}{(}\PYG{n}{tmpimport}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
                \PYG{c+c1}{//                  os \PYGZlt{}\PYGZlt{} \PYGZdq{}t\PYGZus{}i: \PYGZdq{} \PYGZlt{}\PYGZlt{} sp.reference\PYGZus{}times[i] \PYGZlt{}\PYGZlt{} endl;}
            \PYG{p}{\PYGZcb{}}
        \PYG{p}{\PYGZcb{}}
    \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}


\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif }\PYG{c+c1}{//SPECIATIONCOUNTER\PYGZus{}SPECSIMPARAMETERS\PYGZus{}H}
\end{sphinxVerbatim}


\subsubsection{Detailed Description}
\label{\detokenize{api/file_necsim_SpecSimParameters.h:detailed-description}}
Sam Thompson
Contact: \sphinxhref{mailto:samuel.thompson14@imperial.ac.uk}{samuel.thompson14@imperial.ac.uk} or \sphinxhref{mailto:thompsonsed@gmail.com}{thompsonsed@gmail.com} BSD-3 Licence.


\subsubsection{Included By}
\label{\detokenize{api/file_necsim_SpecSimParameters.h:included-by}}\begin{itemize}
\item {} 
{\hyperref[\detokenize{api/file_necsim_Community.h:file-necsim-community-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File Community.h}}}}

\item {} 
{\hyperref[\detokenize{api/file_necsim_Metacommunity.h:file-necsim-metacommunity-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File Metacommunity.h}}}}

\item {} 
{\hyperref[\detokenize{api/file_necsim_SpeciationCommands.h:file-necsim-speciationcommands-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File SpeciationCommands.h}}}}

\end{itemize}


\subsubsection{Classes}
\label{\detokenize{api/file_necsim_SpecSimParameters.h:classes}}\begin{itemize}
\item {} 
{\hyperref[\detokenize{api/class_SpecSimParameters:class-specsimparameters}]{\sphinxcrossref{\DUrole{std,std-ref}{Class SpecSimParameters}}}}

\end{itemize}


\subsection{File Step.h}
\label{\detokenize{api/file_necsim_Step.h:file-step-h}}\label{\detokenize{api/file_necsim_Step.h:file-necsim-step-h}}\label{\detokenize{api/file_necsim_Step.h::doc}}
Contains the {\hyperref[\detokenize{api/class_Step:class-step}]{\sphinxcrossref{\DUrole{std,std-ref}{Class Step}}}} class for storing required data during a single step of a coalescence simulation.

\begin{sphinxShadowBox}
\sphinxstyletopictitle{Contents}
\begin{itemize}
\item {} 
\phantomsection\label{\detokenize{api/file_necsim_Step.h:id1}}{\hyperref[\detokenize{api/file_necsim_Step.h:definition-necsim-step-h}]{\sphinxcrossref{Definition (\sphinxcode{necsim/Step.h})}}}

\item {} 
\phantomsection\label{\detokenize{api/file_necsim_Step.h:id2}}{\hyperref[\detokenize{api/file_necsim_Step.h:detailed-description}]{\sphinxcrossref{Detailed Description}}}

\item {} 
\phantomsection\label{\detokenize{api/file_necsim_Step.h:id3}}{\hyperref[\detokenize{api/file_necsim_Step.h:included-by}]{\sphinxcrossref{Included By}}}

\item {} 
\phantomsection\label{\detokenize{api/file_necsim_Step.h:id4}}{\hyperref[\detokenize{api/file_necsim_Step.h:classes}]{\sphinxcrossref{Classes}}}

\end{itemize}
\end{sphinxShadowBox}


\subsubsection{Definition (\sphinxstyleliteralintitle{necsim/Step.h})}
\label{\detokenize{api/file_necsim_Step.h:definition-necsim-step-h}}

\paragraph{Program Listing for File Step.h}
\label{\detokenize{api/program_listing_file_necsim_Step.h:program-listing-file-necsim-step-h}}\label{\detokenize{api/program_listing_file_necsim_Step.h::doc}}\label{\detokenize{api/program_listing_file_necsim_Step.h:program-listing-for-file-step-h}}\begin{itemize}
\item {} 
Return to documentation for {\hyperref[\detokenize{api/file_necsim_Step.h:file-necsim-step-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File Step.h}}}}

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{//This file is part of NECSim project which is released under BSD\PYGZhy{}3 license.}
\PYG{c+c1}{//See file **LICENSE.txt** or visit https://opensource.org/licenses/BSD\PYGZhy{}3\PYGZhy{}Clause) for full license details.}

\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifndef STEP\PYGZus{}H}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define STEP\PYGZus{}H}

\PYG{k}{struct} \PYG{n}{Step}
\PYG{p}{\PYGZob{}}
    \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{chosen}\PYG{p}{,} \PYG{n}{coalchosen}\PYG{p}{;}
    \PYG{k+kt}{long} \PYG{n}{oldx}\PYG{p}{,} \PYG{n}{oldy}\PYG{p}{,} \PYG{n}{oldxwrap}\PYG{p}{,} \PYG{n}{oldywrap}\PYG{p}{;}
    \PYG{k+kt}{bool} \PYG{n}{coal}\PYG{p}{,} \PYG{n}{bContinueSim}\PYG{p}{;}
    \PYG{k+kt}{unsigned} \PYG{k+kt}{int} \PYG{n}{time\PYGZus{}reference}\PYG{p}{;}
    \PYG{k+kt}{double} \PYG{n}{distance}\PYG{p}{;}
    \PYG{k+kt}{double} \PYG{n}{angle}\PYG{p}{;}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifdef verbose}
    \PYG{k+kt}{long} \PYG{n}{number\PYGZus{}printed}\PYG{p}{;}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif}

    \PYG{n}{Step}\PYG{p}{(}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{chosen} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
        \PYG{n}{coalchosen} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
        \PYG{n}{oldx} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
        \PYG{n}{oldy} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
        \PYG{n}{oldxwrap} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
        \PYG{n}{oldywrap} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
        \PYG{n}{coal} \PYG{o}{=} \PYG{n+nb}{false}\PYG{p}{;}
        \PYG{n}{bContinueSim} \PYG{o}{=} \PYG{n+nb}{true}\PYG{p}{;}
        \PYG{n}{time\PYGZus{}reference} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
        \PYG{n}{distance} \PYG{o}{=} \PYG{l+m+mf}{0.0}\PYG{p}{;}
        \PYG{n}{angle} \PYG{o}{=} \PYG{l+m+mf}{0.0}\PYG{p}{;}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifdef verbose}
        \PYG{n}{number\PYGZus{}printed} \PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif}
    \PYG{p}{\PYGZcb{}}


    \PYG{k+kt}{void} \PYG{n}{wipeData}\PYG{p}{(}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{chosen} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
        \PYG{n}{coalchosen} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
        \PYG{n}{oldx} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
        \PYG{n}{oldy} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
        \PYG{n}{oldxwrap} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
        \PYG{n}{oldywrap} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
        \PYG{n}{coal} \PYG{o}{=} \PYG{n+nb}{false}\PYG{p}{;}
        \PYG{n}{distance} \PYG{o}{=} \PYG{l+m+mf}{0.0}\PYG{p}{;}
        \PYG{n}{angle} \PYG{o}{=} \PYG{l+m+mf}{0.0}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}


\PYG{p}{\PYGZcb{}}\PYG{p}{;}

\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif}
\end{sphinxVerbatim}


\subsubsection{Detailed Description}
\label{\detokenize{api/file_necsim_Step.h:detailed-description}}
Sam Thompson
09/08/2017
BSD-3 Licence.


\subsubsection{Included By}
\label{\detokenize{api/file_necsim_Step.h:included-by}}\begin{itemize}
\item {} 
{\hyperref[\detokenize{api/file_necsim_DispersalCoordinator.h:file-necsim-dispersalcoordinator-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File DispersalCoordinator.h}}}}

\item {} 
{\hyperref[\detokenize{api/file_necsim_Tree.h:file-necsim-tree-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File Tree.h}}}}

\end{itemize}


\subsubsection{Classes}
\label{\detokenize{api/file_necsim_Step.h:classes}}\begin{itemize}
\item {} 
{\hyperref[\detokenize{api/class_Step:class-step}]{\sphinxcrossref{\DUrole{std,std-ref}{Class Step}}}}

\end{itemize}


\subsection{File Tree.cpp}
\label{\detokenize{api/file_necsim_Tree.cpp:file-tree-cpp}}\label{\detokenize{api/file_necsim_Tree.cpp::doc}}\label{\detokenize{api/file_necsim_Tree.cpp:file-necsim-tree-cpp}}
Contains the {\hyperref[\detokenize{api/class_Tree:class-tree}]{\sphinxcrossref{\DUrole{std,std-ref}{Class Tree}}}} class implementation as the main simulation object for spatially-implicit coalescence simulations. Provides the basis for spatially-explicit versions in {\hyperref[\detokenize{api/class_SpatialTree:class-spatialtree}]{\sphinxcrossref{\DUrole{std,std-ref}{Class SpatialTree}}}}, and protracted speciation versions in {\hyperref[\detokenize{api/class_ProtractedTree:class-protractedtree}]{\sphinxcrossref{\DUrole{std,std-ref}{Class ProtractedTree}}}} and {\hyperref[\detokenize{api/class_ProtractedSpatialTree:class-protractedspatialtree}]{\sphinxcrossref{\DUrole{std,std-ref}{Class ProtractedSpatialTree}}}}.

\begin{sphinxShadowBox}
\sphinxstyletopictitle{Contents}
\begin{itemize}
\item {} 
\phantomsection\label{\detokenize{api/file_necsim_Tree.cpp:id1}}{\hyperref[\detokenize{api/file_necsim_Tree.cpp:definition-necsim-tree-cpp}]{\sphinxcrossref{Definition (\sphinxcode{necsim/Tree.cpp})}}}

\item {} 
\phantomsection\label{\detokenize{api/file_necsim_Tree.cpp:id2}}{\hyperref[\detokenize{api/file_necsim_Tree.cpp:detailed-description}]{\sphinxcrossref{Detailed Description}}}

\item {} 
\phantomsection\label{\detokenize{api/file_necsim_Tree.cpp:id3}}{\hyperref[\detokenize{api/file_necsim_Tree.cpp:includes}]{\sphinxcrossref{Includes}}}

\end{itemize}
\end{sphinxShadowBox}


\subsubsection{Definition (\sphinxstyleliteralintitle{necsim/Tree.cpp})}
\label{\detokenize{api/file_necsim_Tree.cpp:definition-necsim-tree-cpp}}

\paragraph{Program Listing for File Tree.cpp}
\label{\detokenize{api/program_listing_file_necsim_Tree.cpp:program-listing-for-file-tree-cpp}}\label{\detokenize{api/program_listing_file_necsim_Tree.cpp::doc}}\label{\detokenize{api/program_listing_file_necsim_Tree.cpp:program-listing-file-necsim-tree-cpp}}\begin{itemize}
\item {} 
Return to documentation for {\hyperref[\detokenize{api/file_necsim_Tree.cpp:file-necsim-tree-cpp}]{\sphinxcrossref{\DUrole{std,std-ref}{File Tree.cpp}}}}

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{// This file is part of NECSim project which is released under BSD\PYGZhy{}3 license.}
\PYG{c+c1}{// See file **LICENSE.txt** or visit https://opensource.org/licenses/BSD\PYGZhy{}3\PYGZhy{}Clause) for full license details.}

\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZdq{}Tree.h\PYGZdq{}}
\PYG{k+kt}{void} \PYG{n}{Tree}\PYG{o}{:}\PYG{o}{:}\PYG{n}{importSimulationVariables}\PYG{p}{(}\PYG{k}{const} \PYG{n}{string} \PYG{o}{\PYGZam{}}\PYG{n}{configfile}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{n}{sim\PYGZus{}parameters}\PYG{p}{.}\PYG{n}{importParameters}\PYG{p}{(}\PYG{n}{configfile}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{checkOutputDirectory}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
    \PYG{c+c1}{// Now check for paused simulations}
    \PYG{n}{checkSims}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{void} \PYG{n}{Tree}\PYG{o}{:}\PYG{o}{:}\PYG{n}{internalSetup}\PYG{p}{(}\PYG{k}{const} \PYG{n}{SimParameters} \PYG{o}{\PYGZam{}}\PYG{n}{sim\PYGZus{}parameters\PYGZus{}in}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{n}{sim\PYGZus{}parameters} \PYG{o}{=} \PYG{n}{sim\PYGZus{}parameters\PYGZus{}in}\PYG{p}{;}
    \PYG{n}{setup}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{bool} \PYG{n}{Tree}\PYG{o}{:}\PYG{o}{:}\PYG{n}{checkOutputDirectory}\PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k}{if}\PYG{p}{(}\PYG{n}{sim\PYGZus{}parameters}\PYG{p}{.}\PYG{n}{output\PYGZus{}directory} \PYG{o}{!}\PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{null}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{try}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{doesExist}\PYG{p}{(}\PYG{n}{sim\PYGZus{}parameters}\PYG{p}{.}\PYG{n}{output\PYGZus{}directory}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{catch}\PYG{p}{(}\PYG{n}{runtime\PYGZus{}error} \PYG{o}{\PYGZam{}}\PYG{n}{re}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{cerr} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Output folder does not exist... creating...}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{flush}\PYG{p}{;}
            \PYG{k+kt}{bool} \PYG{n}{bOutputFolder} \PYG{o}{=} \PYG{n}{boost}\PYG{o}{:}\PYG{o}{:}\PYG{n}{filesystem}\PYG{o}{:}\PYG{o}{:}\PYG{n}{create\PYGZus{}directory}\PYG{p}{(}\PYG{n}{sim\PYGZus{}parameters}\PYG{p}{.}\PYG{n}{output\PYGZus{}directory}\PYG{p}{)}\PYG{p}{;}
            \PYG{k}{if}\PYG{p}{(} \PYG{n}{bOutputFolder}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{n}{cerr} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{done!}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
            \PYG{k}{else}
            \PYG{p}{\PYGZob{}}
                \PYG{n}{cerr} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{re}\PYG{p}{.}\PYG{n}{what}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
        \PYG{p}{\PYGZcb{}}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{else}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{throw} \PYG{n}{FatalException}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ERROR\PYGZus{}MAIN\PYGZus{}009: FATAL. Output folder cannot be null.}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{return} \PYG{n+nb}{true}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}


\PYG{k+kt}{void} \PYG{n}{Tree}\PYG{o}{:}\PYG{o}{:}\PYG{n}{checkSims}\PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{n}{checkSims}\PYG{p}{(}\PYG{n}{sim\PYGZus{}parameters}\PYG{p}{.}\PYG{n}{output\PYGZus{}directory}\PYG{p}{,} \PYG{n}{sim\PYGZus{}parameters}\PYG{p}{.}\PYG{n}{the\PYGZus{}seed}\PYG{p}{,} \PYG{n}{sim\PYGZus{}parameters}\PYG{p}{.}\PYG{n}{the\PYGZus{}task}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{void} \PYG{n}{Tree}\PYG{o}{:}\PYG{o}{:}\PYG{n}{checkSims}\PYG{p}{(}\PYG{n}{string} \PYG{n}{output\PYGZus{}dir}\PYG{p}{,} \PYG{k+kt}{long} \PYG{n}{seed\PYGZus{}in}\PYG{p}{,} \PYG{k+kt}{long} \PYG{n}{task\PYGZus{}in}\PYG{p}{)}
\PYG{p}{\PYGZob{}}

    \PYG{n}{stringstream} \PYG{n}{os}\PYG{p}{;}
    \PYG{n}{os} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Checking for unfinished simulations...}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{flush}\PYG{p}{;}
    \PYG{n}{ifstream} \PYG{n}{out}\PYG{p}{;}
    \PYG{n}{string} \PYG{n}{file\PYGZus{}to\PYGZus{}open}\PYG{p}{;}
\PYG{c+c1}{//  char file\PYGZus{}to\PYGZus{}open[100];}
\PYG{c+c1}{//  sprintf (file\PYGZus{}to\PYGZus{}open, \PYGZdq{}\PYGZpc{}s/Pause/Data\PYGZus{}\PYGZpc{}i.csv\PYGZdq{},outdirect,int(the\PYGZus{}task));}
    \PYG{n}{file\PYGZus{}to\PYGZus{}open} \PYG{o}{=} \PYG{n}{output\PYGZus{}dir} \PYG{o}{+} \PYG{n}{string}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{/Pause/Dump\PYGZus{}active\PYGZus{}}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)} \PYG{o}{+} \PYG{n}{to\PYGZus{}string}\PYG{p}{(}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{k+kt}{long}\PYG{p}{)}\PYG{n}{task\PYGZus{}in}\PYG{p}{)}\PYG{o}{+}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZus{}}\PYG{l+s}{\PYGZdq{}}\PYG{o}{+}\PYG{n}{to\PYGZus{}string}\PYG{p}{(}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{k+kt}{long}\PYG{p}{)}\PYG{n}{seed\PYGZus{}in}\PYG{p}{)} \PYG{o}{+} \PYG{n}{string}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{.csv}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{out}\PYG{p}{.}\PYG{n}{open}\PYG{p}{(}\PYG{n}{file\PYGZus{}to\PYGZus{}open}\PYG{p}{)}\PYG{p}{;}
    \PYG{k}{if}\PYG{p}{(}\PYG{n}{out}\PYG{p}{.}\PYG{n}{good}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{os} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{done!}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{File found containing unfinished simulations.}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
        \PYG{n}{writeInfo}\PYG{p}{(}\PYG{n}{os}\PYG{p}{.}\PYG{n}{str}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{if}\PYG{p}{(}\PYG{o}{!}\PYG{n}{has\PYGZus{}imported\PYGZus{}pause}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{setResumeParameters}\PYG{p}{(}\PYG{n}{sim\PYGZus{}parameters}\PYG{p}{.}\PYG{n}{output\PYGZus{}directory}\PYG{p}{,} \PYG{n}{sim\PYGZus{}parameters}\PYG{p}{.}\PYG{n}{output\PYGZus{}directory}\PYG{p}{,} \PYG{n}{sim\PYGZus{}parameters}\PYG{p}{.}\PYG{n}{the\PYGZus{}seed}\PYG{p}{,}
                                \PYG{n}{sim\PYGZus{}parameters}\PYG{p}{.}\PYG{n}{the\PYGZus{}task}\PYG{p}{,} \PYG{n}{sim\PYGZus{}parameters}\PYG{p}{.}\PYG{n}{max\PYGZus{}time}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{n}{has\PYGZus{}paused} \PYG{o}{=} \PYG{n+nb}{true}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{else}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{os} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{done!}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{No files found containing unfinished simulations.}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
        \PYG{n}{writeInfo}\PYG{p}{(}\PYG{n}{os}\PYG{p}{.}\PYG{n}{str}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{has\PYGZus{}paused} \PYG{o}{=} \PYG{n+nb}{false}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{void} \PYG{n}{Tree}\PYG{o}{:}\PYG{o}{:}\PYG{n}{setParameters}\PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k}{if}\PYG{p}{(}\PYG{o}{!}\PYG{n}{has\PYGZus{}imported\PYGZus{}vars}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{out\PYGZus{}directory} \PYG{o}{=} \PYG{n}{sim\PYGZus{}parameters}\PYG{p}{.}\PYG{n}{output\PYGZus{}directory}\PYG{p}{;}

        \PYG{n}{the\PYGZus{}task} \PYG{o}{=} \PYG{n}{sim\PYGZus{}parameters}\PYG{p}{.}\PYG{n}{the\PYGZus{}task}\PYG{p}{;}
        \PYG{n}{the\PYGZus{}seed} \PYG{o}{=} \PYG{n}{sim\PYGZus{}parameters}\PYG{p}{.}\PYG{n}{the\PYGZus{}seed}\PYG{p}{;}

        \PYG{n}{deme} \PYG{o}{=} \PYG{n}{sim\PYGZus{}parameters}\PYG{p}{.}\PYG{n}{deme}\PYG{p}{;}
        \PYG{n}{deme\PYGZus{}sample} \PYG{o}{=} \PYG{n}{sim\PYGZus{}parameters}\PYG{p}{.}\PYG{n}{deme\PYGZus{}sample}\PYG{p}{;}
        \PYG{n}{spec} \PYG{o}{=} \PYG{n}{sim\PYGZus{}parameters}\PYG{p}{.}\PYG{n}{spec}\PYG{p}{;}
        \PYG{n}{maxtime} \PYG{o}{=} \PYG{n}{sim\PYGZus{}parameters}\PYG{p}{.}\PYG{n}{max\PYGZus{}time}\PYG{p}{;}
        \PYG{n}{times\PYGZus{}file} \PYG{o}{=} \PYG{n}{sim\PYGZus{}parameters}\PYG{p}{.}\PYG{n}{times\PYGZus{}file}\PYG{p}{;}
        \PYG{n}{setProtractedVariables}\PYG{p}{(}\PYG{n}{sim\PYGZus{}parameters}\PYG{p}{.}\PYG{n}{min\PYGZus{}speciation\PYGZus{}gen}\PYG{p}{,} \PYG{n}{sim\PYGZus{}parameters}\PYG{p}{.}\PYG{n}{max\PYGZus{}speciation\PYGZus{}gen}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{has\PYGZus{}imported\PYGZus{}vars} \PYG{o}{=} \PYG{n+nb}{true}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{else}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{throw} \PYG{n}{FatalException}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ERROR\PYGZus{}MAIN\PYGZus{}001: Variables already imported.}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{void} \PYG{n}{Tree}\PYG{o}{:}\PYG{o}{:}\PYG{n}{setProtractedVariables}\PYG{p}{(}\PYG{k+kt}{double} \PYG{n}{speciation\PYGZus{}gen\PYGZus{}min}\PYG{p}{,} \PYG{k+kt}{double} \PYG{n}{speciation\PYGZus{}gen\PYGZus{}max}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
\PYG{p}{\PYGZcb{}}


\PYG{k+kt}{bool} \PYG{n}{Tree}\PYG{o}{:}\PYG{o}{:}\PYG{n}{hasPaused}\PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k}{return} \PYG{n}{has\PYGZus{}paused}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{double}\PYG{o}{\PYGZgt{}} \PYG{n}{Tree}\PYG{o}{:}\PYG{o}{:}\PYG{n}{getTemporalSampling}\PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k}{if}\PYG{p}{(}\PYG{n}{has\PYGZus{}times\PYGZus{}file}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{return} \PYG{n}{reference\PYGZus{}times}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{else}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{double}\PYG{o}{\PYGZgt{}} \PYG{n}{tmp}\PYG{p}{;}
        \PYG{n}{tmp}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{l+m+mf}{0.0}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{return} \PYG{n}{tmp}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{long} \PYG{k+kt}{long} \PYG{n}{Tree}\PYG{o}{:}\PYG{o}{:}\PYG{n}{getSeed}\PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k}{return} \PYG{n}{the\PYGZus{}seed}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{void} \PYG{n}{Tree}\PYG{o}{:}\PYG{o}{:}\PYG{n}{setSeed}\PYG{p}{(}\PYG{k+kt}{long} \PYG{k+kt}{long} \PYG{n}{seed\PYGZus{}in}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k}{if}\PYG{p}{(}\PYG{o}{!}\PYG{n}{seeded}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{NR}\PYG{p}{.}\PYG{n}{setSeed}\PYG{p}{(}\PYG{n}{seed\PYGZus{}in}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{the\PYGZus{}seed} \PYG{o}{=} \PYG{n}{seed\PYGZus{}in}\PYG{p}{;}
        \PYG{n}{seeded} \PYG{o}{=} \PYG{n+nb}{true}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{Tree}\PYG{o}{:}\PYG{o}{:}\PYG{n}{getInitialCount}\PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k}{return} \PYG{k}{static\PYGZus{}cast}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{unsigned} \PYG{k+kt}{long}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{n}{floor}\PYG{p}{(}\PYG{n}{deme} \PYG{o}{*} \PYG{n}{deme\PYGZus{}sample}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}


\PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{Tree}\PYG{o}{:}\PYG{o}{:}\PYG{n}{setObjectSizes}\PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{initial\PYGZus{}count} \PYG{o}{=} \PYG{n}{getInitialCount}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{active}\PYG{p}{.}\PYG{n}{setSize}\PYG{p}{(}\PYG{n}{initial\PYGZus{}count} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{data}\PYG{p}{.}\PYG{n}{setSize}\PYG{p}{(}\PYG{l+m+mi}{2} \PYG{o}{*} \PYG{n}{initial\PYGZus{}count} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
    \PYG{k}{return} \PYG{n}{initial\PYGZus{}count}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{void} \PYG{n}{Tree}\PYG{o}{:}\PYG{o}{:}\PYG{n}{setup}\PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{n}{printSetup}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
    \PYG{k}{if}\PYG{p}{(}\PYG{n}{has\PYGZus{}imported\PYGZus{}pause}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{setResumeParameters}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{simResume}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{else}
    \PYG{p}{\PYGZob{}}
        \PYG{c+c1}{// Start the timer}
        \PYG{n}{time}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{start}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{setParameters}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{setInitialValues}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{generateObjects}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{void} \PYG{n}{Tree}\PYG{o}{:}\PYG{o}{:}\PYG{n}{setInitialValues}\PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{c+c1}{// other variables}
    \PYG{n}{steps} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
    \PYG{n}{generation} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
    \PYG{c+c1}{// Set the seed}
    \PYG{n}{setSeed}\PYG{p}{(}\PYG{n}{the\PYGZus{}seed}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{sim\PYGZus{}parameters}\PYG{p}{.}\PYG{n}{printVars}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
    \PYG{c+c1}{// Determine the speciation rates which will be applied after the simulation completes.}
    \PYG{n}{determineSpeciationRates}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{setTimes}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{void} \PYG{n}{Tree}\PYG{o}{:}\PYG{o}{:}\PYG{n}{setSimStartVariables}\PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{n}{this\PYGZus{}step}\PYG{p}{.}\PYG{n}{bContinueSim} \PYG{o}{=} \PYG{n+nb}{true}\PYG{p}{;}
    \PYG{n}{this\PYGZus{}step}\PYG{p}{.}\PYG{n}{time\PYGZus{}reference} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
    \PYG{k}{if}\PYG{p}{(}\PYG{n}{has\PYGZus{}times\PYGZus{}file} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{n}{generation} \PYG{o}{\PYGZgt{}} \PYG{l+m+mf}{0.0}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{reference\PYGZus{}times}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{k}{if}\PYG{p}{(}\PYG{n}{reference\PYGZus{}times}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{\PYGZgt{}} \PYG{n}{generation}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{n}{this\PYGZus{}step}\PYG{p}{.}\PYG{n}{time\PYGZus{}reference} \PYG{o}{=} \PYG{n}{i} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{p}{;}
                \PYG{k}{break}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
        \PYG{p}{\PYGZcb{}}
    \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{void} \PYG{n}{Tree}\PYG{o}{:}\PYG{o}{:}\PYG{n}{printSetup}\PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{n}{stringstream} \PYG{n}{os}\PYG{p}{;}
    \PYG{n}{os} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{*************************************************}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
    \PYG{n}{os} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Setting up simulation...}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
    \PYG{n}{writeInfo}\PYG{p}{(}\PYG{n}{os}\PYG{p}{.}\PYG{n}{str}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{os}\PYG{p}{.}\PYG{n}{str}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{time}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{start}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{void} \PYG{n}{Tree}\PYG{o}{:}\PYG{o}{:}\PYG{n}{setTimes}\PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k}{if}\PYG{p}{(}\PYG{n}{times\PYGZus{}file} \PYG{o}{!}\PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{null}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{o}{!}\PYG{n}{has\PYGZus{}times\PYGZus{}file}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{c+c1}{// Import the time sample points}
        \PYG{n}{has\PYGZus{}times\PYGZus{}file} \PYG{o}{=} \PYG{n+nb}{true}\PYG{p}{;}
        \PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{n}{string}\PYG{o}{\PYGZgt{}} \PYG{n}{tmpimport}\PYG{p}{;}
        \PYG{n}{ConfigOption} \PYG{n}{tmpconfig}\PYG{p}{;}
        \PYG{n}{tmpconfig}\PYG{p}{.}\PYG{n}{setConfig}\PYG{p}{(}\PYG{n}{times\PYGZus{}file}\PYG{p}{,} \PYG{n+nb}{false}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{tmpconfig}\PYG{p}{.}\PYG{n}{importConfig}\PYG{p}{(}\PYG{n}{tmpimport}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{for}\PYG{p}{(}\PYG{k}{const} \PYG{k}{auto} \PYG{o}{\PYGZam{}}\PYG{n+nl}{i} \PYG{p}{:} \PYG{n}{tmpimport}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{reference\PYGZus{}times}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{n}{stod}\PYG{p}{(}\PYG{n}{i}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
    \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{void} \PYG{n}{Tree}\PYG{o}{:}\PYG{o}{:}\PYG{n}{determineSpeciationRates}\PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k}{if}\PYG{p}{(}\PYG{n}{bConfig}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{sim\PYGZus{}parameters}\PYG{p}{.}\PYG{n}{configs}\PYG{p}{.}\PYG{n}{hasSection}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{spec\PYGZus{}rates}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{n}{string}\PYG{o}{\PYGZgt{}} \PYG{n}{spec\PYGZus{}rates} \PYG{o}{=} \PYG{n}{sim\PYGZus{}parameters}\PYG{p}{.}\PYG{n}{configs}\PYG{p}{.}\PYG{n}{getSectionValues}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{spec\PYGZus{}rates}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
            \PYG{k}{for}\PYG{p}{(}\PYG{k}{const} \PYG{k}{auto} \PYG{o}{\PYGZam{}}\PYG{n+nl}{spec\PYGZus{}rate} \PYG{p}{:} \PYG{n}{spec\PYGZus{}rates}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{n}{speciation\PYGZus{}rates}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{n}{stod}\PYG{p}{(}\PYG{n}{spec\PYGZus{}rate}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
        \PYG{p}{\PYGZcb{}}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{else}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{speciation\PYGZus{}rates}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{n}{spec}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{n}{sort}\PYG{p}{(}\PYG{n}{speciation\PYGZus{}rates}\PYG{p}{.}\PYG{n}{begin}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{n}{speciation\PYGZus{}rates}\PYG{p}{.}\PYG{n}{end}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{void} \PYG{n}{Tree}\PYG{o}{:}\PYG{o}{:}\PYG{n}{generateObjects}\PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{initial\PYGZus{}count} \PYG{o}{=} \PYG{n}{setObjectSizes}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{endactive} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
    \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{number\PYGZus{}start} \PYG{o}{=} \PYG{n}{fillObjects}\PYG{p}{(}\PYG{n}{initial\PYGZus{}count}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{stringstream} \PYG{n}{os}\PYG{p}{;}
    \PYG{n}{os} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}r}\PYG{l+s}{Setting up simulation...done!                           }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
    \PYG{n}{os} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Number of individuals simulating: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endactive} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
    \PYG{n}{writeInfo}\PYG{p}{(}\PYG{n}{os}\PYG{p}{.}\PYG{n}{str}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{maxsimsize} \PYG{o}{=} \PYG{n}{enddata}\PYG{p}{;}
    \PYG{k}{if}\PYG{p}{(}\PYG{n}{active}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZlt{}} \PYG{n}{endactive} \PYG{o}{\textbar{}}\PYG{o}{\textbar{}} \PYG{n}{endactive} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{cerr} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{endactive: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endactive} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
        \PYG{n}{cerr} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{active.size: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{active}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
        \PYG{n}{cerr} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{initial\PYGZus{}count: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{initial\PYGZus{}count} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
        \PYG{n}{cerr} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{number\PYGZus{}start: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{number\PYGZus{}start} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{endactive} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{k}{throw} \PYG{n}{runtime\PYGZus{}error}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{No individuals to simulate! Check set up. Exiting...}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{else}
        \PYG{p}{\PYGZob{}}
            \PYG{k}{throw} \PYG{n}{FatalException}\PYG{p}{(}
                    \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ERROR\PYGZus{}MAIN\PYGZus{}007: FATAL. Sizing error \PYGZhy{} endactive is greater than the size of active. }\PYG{l+s}{\PYGZdq{}}
                            \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Please report this bug}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
    \PYG{p}{\PYGZcb{}}
    \PYG{n}{startendactive} \PYG{o}{=} \PYG{n}{endactive}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{Tree}\PYG{o}{:}\PYG{o}{:}\PYG{n}{fillObjects}\PYG{p}{(}\PYG{k}{const} \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{initial\PYGZus{}count}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{n}{active}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{.}\PYG{n}{setup}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{number\PYGZus{}start} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
    \PYG{n}{stringstream} \PYG{n}{os}\PYG{p}{;}
    \PYG{n}{os} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}r}\PYG{l+s}{Setting up simulation...filling grid                           }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{flush}\PYG{p}{;}
    \PYG{n}{writeInfo}\PYG{p}{(}\PYG{n}{os}\PYG{p}{.}\PYG{n}{str}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
    \PYG{c+c1}{// This loop adds individuals to data and active (for storing the coalescence tree and active lineage tracking)}
    \PYG{k+kt}{double} \PYG{n}{sample\PYGZus{}number} \PYG{o}{=} \PYG{n}{floor}\PYG{p}{(}\PYG{n}{deme\PYGZus{}sample} \PYG{o}{*} \PYG{n}{deme}\PYG{p}{)}\PYG{p}{;}
    \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{sample\PYGZus{}number}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{number\PYGZus{}start}\PYG{o}{+}\PYG{o}{+}\PYG{p}{;}
        \PYG{c+c1}{// Add the species to active}
        \PYG{n}{active}\PYG{p}{[}\PYG{n}{number\PYGZus{}start}\PYG{p}{]}\PYG{p}{.}\PYG{n}{setup}\PYG{p}{(}\PYG{n}{number\PYGZus{}start}\PYG{p}{,} \PYG{n}{i}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
        \PYG{c+c1}{// Add a tip in the TreeNode for calculation of the coalescence tree at the}
        \PYG{c+c1}{// end of the simulation.}
        \PYG{c+c1}{// This also contains the start x and y position of the species.}
        \PYG{n}{data}\PYG{p}{[}\PYG{n}{number\PYGZus{}start}\PYG{p}{]}\PYG{p}{.}\PYG{n}{setup}\PYG{p}{(}\PYG{n+nb}{true}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{data}\PYG{p}{[}\PYG{n}{number\PYGZus{}start}\PYG{p}{]}\PYG{p}{.}\PYG{n}{setSpec}\PYG{p}{(}\PYG{n}{NR}\PYG{p}{.}\PYG{n}{d01}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{endactive}\PYG{o}{+}\PYG{o}{+}\PYG{p}{;}
        \PYG{n}{enddata}\PYG{o}{+}\PYG{o}{+}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{if}\PYG{p}{(}\PYG{n}{number\PYGZus{}start} \PYG{o}{=}\PYG{o}{=} \PYG{n}{initial\PYGZus{}count}\PYG{p}{)}  \PYG{c+c1}{// Check that the two counting methods match up.}
    \PYG{p}{\PYGZob{}}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{else}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{initial\PYGZus{}count} \PYG{o}{\PYGZgt{}} \PYG{l+m+mf}{1.1} \PYG{o}{*} \PYG{n}{number\PYGZus{}start}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{writeWarning}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Data usage higher than neccessary \PYGZhy{} check allocation of individuals to the grid.}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
            \PYG{n}{stringstream} \PYG{n}{ss}\PYG{p}{;}
            \PYG{n}{ss} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Initial count: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{initial\PYGZus{}count} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{  Number counted: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{number\PYGZus{}start} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
            \PYG{n}{writeWarning}\PYG{p}{(}\PYG{n}{ss}\PYG{p}{.}\PYG{n}{str}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
    \PYG{p}{\PYGZcb{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifdef DEBUG}
    \PYG{n}{validateLineages}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif}
    \PYG{k}{return} \PYG{n}{number\PYGZus{}start}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}


\PYG{k+kt}{bool} \PYG{n}{Tree}\PYG{o}{:}\PYG{o}{:}\PYG{n}{runSimulation}\PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}

    \PYG{n}{writeSimStartToConsole}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
    \PYG{c+c1}{// Main while loop to process while there is still time left and the simulation is not complete.}
    \PYG{c+c1}{// Ensure that the step object contains no data.}
    \PYG{n}{this\PYGZus{}step}\PYG{p}{.}\PYG{n}{wipeData}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{setSimStartVariables}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
    \PYG{k}{if}\PYG{p}{(}\PYG{n}{endactive} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{2}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{return} \PYG{n}{stopSimulation}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{c+c1}{// Create the move object}
    \PYG{k}{do}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{chooseRandomLineage}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{writeStepToConsole}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
        \PYG{c+c1}{// See estSpecnum for removed code.}
        \PYG{c+c1}{// Check that we still want to continue the simulation.}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{this\PYGZus{}step}\PYG{p}{.}\PYG{n}{bContinueSim}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{c+c1}{// increase the counter of the number of moves (or generations) the lineage has undergone.}
            \PYG{n}{data}\PYG{p}{[}\PYG{n}{active}\PYG{p}{[}\PYG{n}{this\PYGZus{}step}\PYG{p}{.}\PYG{n}{chosen}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getReference}\PYG{p}{(}\PYG{p}{)}\PYG{p}{]}\PYG{p}{.}\PYG{n}{increaseGen}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
            \PYG{c+c1}{// Check if speciation happens}
            \PYG{k}{if}\PYG{p}{(}\PYG{n}{calcSpeciation}\PYG{p}{(}\PYG{n}{data}\PYG{p}{[}\PYG{n}{active}\PYG{p}{[}\PYG{n}{this\PYGZus{}step}\PYG{p}{.}\PYG{n}{chosen}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getReference}\PYG{p}{(}\PYG{p}{)}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getSpecRate}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{l+m+mf}{0.99999}\PYG{o}{*}\PYG{n}{spec}\PYG{p}{,}
                               \PYG{n}{data}\PYG{p}{[}\PYG{n}{active}\PYG{p}{[}\PYG{n}{this\PYGZus{}step}\PYG{p}{.}\PYG{n}{chosen}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getReference}\PYG{p}{(}\PYG{p}{)}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getGenRate}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{n}{speciation}\PYG{p}{(}\PYG{n}{this\PYGZus{}step}\PYG{p}{.}\PYG{n}{chosen}\PYG{p}{)}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
            \PYG{k}{else}
            \PYG{p}{\PYGZob{}}
                \PYG{c+c1}{// remove the species data from the species list to be placed somewhere new.}
                \PYG{n}{removeOldPosition}\PYG{p}{(}\PYG{n}{this\PYGZus{}step}\PYG{p}{.}\PYG{n}{chosen}\PYG{p}{)}\PYG{p}{;}
                \PYG{n}{calcNextStep}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifdef DEBUG}
                \PYG{n}{debugCoalescence}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif}
                \PYG{k}{if}\PYG{p}{(}\PYG{n}{this\PYGZus{}step}\PYG{p}{.}\PYG{n}{coal}\PYG{p}{)}
                \PYG{p}{\PYGZob{}}
                    \PYG{n}{coalescenceEvent}\PYG{p}{(}\PYG{n}{this\PYGZus{}step}\PYG{p}{.}\PYG{n}{chosen}\PYG{p}{,} \PYG{n}{this\PYGZus{}step}\PYG{p}{.}\PYG{n}{coalchosen}\PYG{p}{)}\PYG{p}{;}
                \PYG{p}{\PYGZcb{}}
            \PYG{p}{\PYGZcb{}}
        \PYG{p}{\PYGZcb{}}

\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifdef DEBUG}
        \PYG{n}{debugEndStep}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{has\PYGZus{}times\PYGZus{}file} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{n}{endactive} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{c+c1}{// Check whether we need to continue simulating at a later time.}
            \PYG{k}{if}\PYG{p}{(}\PYG{n}{reference\PYGZus{}times}\PYG{p}{[}\PYG{n}{this\PYGZus{}step}\PYG{p}{.}\PYG{n}{time\PYGZus{}reference}\PYG{p}{]} \PYG{o}{\PYGZgt{}} \PYG{n}{generation}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{c+c1}{// Then we need to expand the map}
                \PYG{c+c1}{// This is a hack, I know it\PYGZsq{}s a hack and is wrong, and I aint gonna change it :)}
                \PYG{n}{data}\PYG{p}{[}\PYG{n}{active}\PYG{p}{[}\PYG{n}{endactive}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getReference}\PYG{p}{(}\PYG{p}{)}\PYG{p}{]}\PYG{p}{.}\PYG{n}{setSpec}\PYG{p}{(}\PYG{l+m+mf}{0.0}\PYG{p}{)}\PYG{p}{;}
                \PYG{c+c1}{// First speciate the remaining lineage}
                \PYG{n}{speciation}\PYG{p}{(}\PYG{n}{endactive}\PYG{p}{)}\PYG{p}{;}
                \PYG{n}{generation} \PYG{o}{=} \PYG{n}{reference\PYGZus{}times}\PYG{p}{[}\PYG{n}{this\PYGZus{}step}\PYG{p}{.}\PYG{n}{time\PYGZus{}reference}\PYG{p}{]} \PYG{o}{+} \PYG{l+m+mf}{0.000000000001}\PYG{p}{;}
                \PYG{n}{checkTimeUpdate}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
                \PYG{k}{if}\PYG{p}{(}\PYG{n}{endactive} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{2}\PYG{p}{)}
                \PYG{p}{\PYGZob{}}
                    \PYG{k}{break}\PYG{p}{;}
                \PYG{p}{\PYGZcb{}}
            \PYG{p}{\PYGZcb{}}
            \PYG{c+c1}{// TODO fix this to account for potential speciation of the remaining lineage!}
        \PYG{p}{\PYGZcb{}}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{while}\PYG{p}{(}\PYG{p}{(}\PYG{n}{endactive} \PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{1}\PYG{p}{)} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{p}{(}\PYG{n}{steps} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{100} \PYG{o}{\textbar{}}\PYG{o}{\textbar{}} \PYG{n}{difftime}\PYG{p}{(}\PYG{n}{sim\PYGZus{}end}\PYG{p}{,} \PYG{n}{start}\PYG{p}{)} \PYG{o}{\PYGZlt{}} \PYG{n}{maxtime}\PYG{p}{)} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{n}{this\PYGZus{}step}\PYG{p}{.}\PYG{n}{bContinueSim}\PYG{p}{)}\PYG{p}{;}
\PYG{c+c1}{// If the simulations finish correctly, output the completed data.}
\PYG{c+c1}{// Otherwise, pause the simulation and save objects to file.}
    \PYG{k}{return} \PYG{n+nf}{stopSimulation}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{bool} \PYG{n}{Tree}\PYG{o}{:}\PYG{o}{:}\PYG{n}{stopSimulation}\PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k}{if}\PYG{p}{(}\PYG{n}{endactive} \PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{1}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{stringstream} \PYG{n}{os}\PYG{p}{;}
        \PYG{n}{time}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{sim\PYGZus{}finish}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{time\PYGZus{}taken} \PYG{o}{+}\PYG{o}{=} \PYG{n}{sim\PYGZus{}finish} \PYG{o}{\PYGZhy{}} \PYG{n}{start}\PYG{p}{;}
        \PYG{n}{os}\PYG{p}{.}\PYG{n}{str}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{os} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{........out of time!}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
        \PYG{n}{os} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Pausing simulation: add extra time or re\PYGZhy{}run to ensure simulation completion.}\PYG{l+s}{\PYGZdq{}}
           \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
        \PYG{n}{os} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Lineages remaining: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endactive} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
        \PYG{n}{writeInfo}\PYG{p}{(}\PYG{n}{os}\PYG{p}{.}\PYG{n}{str}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{simPause}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{return} \PYG{n+nb}{false}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{else}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{n}{endactive}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{speciateLineage}\PYG{p}{(}\PYG{n}{active}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getReference}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
            \PYG{n}{data}\PYG{p}{[}\PYG{n}{active}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getReference}\PYG{p}{(}\PYG{p}{)}\PYG{p}{]}\PYG{p}{.}\PYG{n}{setSpec}\PYG{p}{(}\PYG{l+m+mf}{0.0}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{n}{sim\PYGZus{}complete} \PYG{o}{=} \PYG{n+nb}{true}\PYG{p}{;}
        \PYG{n}{time}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{sim\PYGZus{}finish}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{time\PYGZus{}taken} \PYG{o}{+}\PYG{o}{=} \PYG{n}{sim\PYGZus{}finish} \PYG{o}{\PYGZhy{}} \PYG{n}{start}\PYG{p}{;}
        \PYG{k}{if}\PYG{p}{(}\PYG{o}{!}\PYG{n}{this\PYGZus{}step}\PYG{p}{.}\PYG{n}{bContinueSim}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{writeInfo}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{done \PYGZhy{} desired number of species achieved!}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
            \PYG{k}{return} \PYG{n+nb}{true}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{else}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{writeInfo}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{done!}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
            \PYG{k}{return} \PYG{n+nb}{true}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
    \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{void} \PYG{n}{Tree}\PYG{o}{:}\PYG{o}{:}\PYG{n}{writeSimStartToConsole}\PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{c+c1}{// now do the calculations required to build the tree}
    \PYG{n}{stringstream} \PYG{n}{os}\PYG{p}{;}
    \PYG{n}{os} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{*************************************************}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
    \PYG{n}{os} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Beginning simulations...}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{flush}\PYG{p}{;}
    \PYG{n}{writeInfo}\PYG{p}{(}\PYG{n}{os}\PYG{p}{.}\PYG{n}{str}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{os}\PYG{p}{.}\PYG{n}{str}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}

    \PYG{c+c1}{//      double current\PYGZus{}gen =0;}
    \PYG{c+c1}{// check time}
    \PYG{n}{time}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{sim\PYGZus{}start}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{time}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{sim\PYGZus{}end}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{time}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{now}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{void} \PYG{n}{Tree}\PYG{o}{:}\PYG{o}{:}\PYG{n}{writeStepToConsole}\PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k}{if}\PYG{p}{(}\PYG{n}{steps} \PYG{o}{\PYGZpc{}} \PYG{l+m+mi}{10000} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{time}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{sim\PYGZus{}end}\PYG{p}{)}\PYG{p}{;}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifdef verbose}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{sim\PYGZus{}end} \PYG{o}{\PYGZhy{}} \PYG{n}{now} \PYG{o}{\PYGZgt{}} \PYG{l+m+mf}{0.2}\PYG{p}{)}  \PYG{c+c1}{// output every 0.2 seconds}
        \PYG{p}{\PYGZob{}}
            \PYG{k+kt}{double} \PYG{n}{dPercentComplete} \PYG{o}{=} \PYG{l+m+mi}{20} \PYG{o}{*} \PYG{p}{(}\PYG{l+m+mi}{1} \PYG{o}{\PYGZhy{}} \PYG{p}{(}\PYG{k+kt}{double}\PYG{p}{(}\PYG{n}{endactive}\PYG{p}{)} \PYG{o}{/} \PYG{k+kt}{double}\PYG{p}{(}\PYG{n}{startendactive}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
            \PYG{n}{time}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{now}\PYG{p}{)}\PYG{p}{;}
            \PYG{k}{if}\PYG{p}{(}\PYG{n}{this\PYGZus{}step}\PYG{p}{.}\PYG{n}{number\PYGZus{}printed} \PYG{o}{\PYGZlt{}} \PYG{n}{dPercentComplete}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{n}{stringstream} \PYG{n}{os}\PYG{p}{;}
                \PYG{n}{os} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}r}\PYG{l+s}{Beginning simulations...}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
                \PYG{n}{this\PYGZus{}step}\PYG{p}{.}\PYG{n}{number\PYGZus{}printed} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
                \PYG{k}{while}\PYG{p}{(}\PYG{n}{this\PYGZus{}step}\PYG{p}{.}\PYG{n}{number\PYGZus{}printed} \PYG{o}{\PYGZlt{}} \PYG{n}{dPercentComplete}\PYG{p}{)}
                \PYG{p}{\PYGZob{}}
                    \PYG{n}{os} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{.}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}

                    \PYG{n}{this\PYGZus{}step}\PYG{p}{.}\PYG{n}{number\PYGZus{}printed}\PYG{o}{+}\PYG{o}{+}\PYG{p}{;}
                \PYG{p}{\PYGZcb{}}
                \PYG{n}{os} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{flush}\PYG{p}{;}
                \PYG{n}{writeInfo}\PYG{p}{(}\PYG{n}{os}\PYG{p}{.}\PYG{n}{str}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
        \PYG{p}{\PYGZcb{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif }\PYG{c+c1}{// verbose}
    \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{void} \PYG{n}{Tree}\PYG{o}{:}\PYG{o}{:}\PYG{n}{incrementGeneration}\PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{n}{steps}\PYG{o}{+}\PYG{o}{+}\PYG{p}{;}
    \PYG{c+c1}{// increment generation counter}
    \PYG{n}{generation} \PYG{o}{+}\PYG{o}{=} \PYG{l+m+mf}{2.0} \PYG{o}{/} \PYG{p}{(}\PYG{k+kt}{double}\PYG{p}{(}\PYG{n}{endactive}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{void} \PYG{n}{Tree}\PYG{o}{:}\PYG{o}{:}\PYG{n}{chooseRandomLineage}\PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{n}{incrementGeneration}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
    \PYG{c+c1}{// choose a random lineage to die and be reborn out of those currently active}
    \PYG{n}{this\PYGZus{}step}\PYG{p}{.}\PYG{n}{chosen} \PYG{o}{=} \PYG{n}{NR}\PYG{p}{.}\PYG{n}{i0}\PYG{p}{(}\PYG{n}{endactive} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{1}\PYG{p}{)} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{p}{;}  \PYG{c+c1}{// cannot be 0}
    \PYG{c+c1}{// Rejection sample based on reproductive potential}
    \PYG{n}{updateStepCoalescenceVariables}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{void} \PYG{n}{Tree}\PYG{o}{:}\PYG{o}{:}\PYG{n}{updateStepCoalescenceVariables}\PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{n}{this\PYGZus{}step}\PYG{p}{.}\PYG{n}{coalchosen} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
    \PYG{n}{this\PYGZus{}step}\PYG{p}{.}\PYG{n}{coal} \PYG{o}{=} \PYG{n+nb}{false}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{void} \PYG{n}{Tree}\PYG{o}{:}\PYG{o}{:}\PYG{n}{speciation}\PYG{p}{(}\PYG{k}{const} \PYG{k+kt}{unsigned} \PYG{k+kt}{long}\PYG{o}{\PYGZam{}} \PYG{n}{chosen}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{c+c1}{// alter the data such that it reflects the speciation event.}
    \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{data\PYGZus{}position} \PYG{o}{=} \PYG{n}{active}\PYG{p}{[}\PYG{n}{chosen}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getReference}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifdef DEBUG}
    \PYG{c+c1}{// Store debug information in DEBUG mode}
    \PYG{k}{if}\PYG{p}{(}\PYG{n}{data}\PYG{p}{[}\PYG{n}{data\PYGZus{}position}\PYG{p}{]}\PYG{p}{.}\PYG{n}{hasSpeciated}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{stringstream} \PYG{n}{ss}\PYG{p}{;}
        \PYG{n}{ss} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Chosen: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{chosen} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
        \PYG{n}{writeLog}\PYG{p}{(}\PYG{l+m+mi}{50}\PYG{p}{,} \PYG{n}{ss}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{ss}\PYG{p}{.}\PYG{n}{str}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{ss} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Endactive: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endactive} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
        \PYG{n}{writeLog}\PYG{p}{(}\PYG{l+m+mi}{50}\PYG{p}{,} \PYG{n}{ss}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{data}\PYG{p}{[}\PYG{n}{data\PYGZus{}position}\PYG{p}{]}\PYG{p}{.}\PYG{n}{logLineageInformation}\PYG{p}{(}\PYG{l+m+mi}{50}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{active}\PYG{p}{[}\PYG{n}{chosen}\PYG{p}{]}\PYG{p}{.}\PYG{n}{logActive}\PYG{p}{(}\PYG{l+m+mi}{50}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{throw} \PYG{n+nf}{FatalException}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ERROR\PYGZus{}MOVE\PYGZus{}028: Attempting to speciate a speciated species.}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif}
    \PYG{n}{speciateLineage}\PYG{p}{(}\PYG{n}{data\PYGZus{}position}\PYG{p}{)}\PYG{p}{;}
    \PYG{c+c1}{// Now remove the old chosen lineage from the active directory.}
    \PYG{n}{removeOldPosition}\PYG{p}{(}\PYG{n}{chosen}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{switchPositions}\PYG{p}{(}\PYG{n}{chosen}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{void} \PYG{n}{Tree}\PYG{o}{:}\PYG{o}{:}\PYG{n}{speciateLineage}\PYG{p}{(}\PYG{k}{const} \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{data\PYGZus{}position}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{n}{data}\PYG{p}{[}\PYG{n}{data\PYGZus{}position}\PYG{p}{]}\PYG{p}{.}\PYG{n}{speciate}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{void} \PYG{n}{Tree}\PYG{o}{:}\PYG{o}{:}\PYG{n}{removeOldPosition}\PYG{p}{(}\PYG{k}{const} \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{chosen}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{c+c1}{// This may seem a bit stupid, but this function is overwridden with more complex routines in child classes.}
    \PYG{n}{active}\PYG{p}{[}\PYG{n}{chosen}\PYG{p}{]}\PYG{p}{.}\PYG{n}{setListPosition}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{void} \PYG{n}{Tree}\PYG{o}{:}\PYG{o}{:}\PYG{n}{switchPositions}\PYG{p}{(}\PYG{k}{const} \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{chosen}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifdef DEBUG}

    \PYG{k}{if}\PYG{p}{(}\PYG{n}{chosen} \PYG{o}{\PYGZgt{}} \PYG{n}{endactive}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{stringstream} \PYG{n}{ss}\PYG{p}{;}
        \PYG{n}{ss} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{chosen: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{chosen} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ endactive: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endactive} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
        \PYG{n}{writeLog}\PYG{p}{(}\PYG{l+m+mi}{50}\PYG{p}{,} \PYG{n}{ss}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{throw} \PYG{n+nf}{FatalException}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ERROR\PYGZus{}MOVE\PYGZus{}023: Chosen is greater than endactive. Check move function.}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif }\PYG{c+c1}{// DEBUG}
    \PYG{k}{if}\PYG{p}{(}\PYG{n}{chosen} \PYG{o}{!}\PYG{o}{=} \PYG{n}{endactive}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{c+c1}{// This routine assumes that the previous chosen position has already been deleted.}
        \PYG{n}{DataPoint} \PYG{n}{tmpdatactive}\PYG{p}{;}
        \PYG{n}{tmpdatactive}\PYG{p}{.}\PYG{n}{setup}\PYG{p}{(}\PYG{n}{active}\PYG{p}{[}\PYG{n}{chosen}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
        \PYG{c+c1}{// now need to remove the chosen lineage from memory, by replacing it with the lineage that lies in the last}
        \PYG{c+c1}{// place.}
        \PYG{n}{active}\PYG{p}{[}\PYG{n}{chosen}\PYG{p}{]}\PYG{p}{.}\PYG{n}{setup}\PYG{p}{(}\PYG{n}{active}\PYG{p}{[}\PYG{n}{endactive}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{active}\PYG{p}{[}\PYG{n}{endactive}\PYG{p}{]}\PYG{p}{.}\PYG{n}{setup}\PYG{p}{(}\PYG{n}{tmpdatactive}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{n}{endactive}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{p}{;}

\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{void} \PYG{n}{Tree}\PYG{o}{:}\PYG{o}{:}\PYG{n}{calcNextStep}\PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{random\PYGZus{}lineage} \PYG{o}{=} \PYG{n}{NR}\PYG{p}{.}\PYG{n}{i0}\PYG{p}{(}\PYG{k}{static\PYGZus{}cast}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{unsigned} \PYG{k+kt}{long}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{n}{deme}\PYG{p}{)}\PYG{p}{)} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{p}{;}
    \PYG{k}{if}\PYG{p}{(}\PYG{n}{random\PYGZus{}lineage} \PYG{o}{!}\PYG{o}{=} \PYG{n}{this\PYGZus{}step}\PYG{p}{.}\PYG{n}{chosen} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{n}{random\PYGZus{}lineage} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{n}{endactive}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{c+c1}{// then we have a coalescence event}
        \PYG{n}{this\PYGZus{}step}\PYG{p}{.}\PYG{n}{coal} \PYG{o}{=} \PYG{n+nb}{true}\PYG{p}{;}
        \PYG{n}{this\PYGZus{}step}\PYG{p}{.}\PYG{n}{coalchosen} \PYG{o}{=} \PYG{n}{random\PYGZus{}lineage}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{bool} \PYG{n}{Tree}\PYG{o}{:}\PYG{o}{:}\PYG{n}{calcSpeciation}\PYG{p}{(}\PYG{k}{const} \PYG{k+kt}{long} \PYG{k+kt}{double} \PYG{o}{\PYGZam{}}\PYG{n}{random\PYGZus{}number}\PYG{p}{,}
                          \PYG{k}{const} \PYG{k+kt}{long} \PYG{k+kt}{double} \PYG{o}{\PYGZam{}}\PYG{n}{speciation\PYGZus{}rate}\PYG{p}{,}
                          \PYG{k}{const} \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{no\PYGZus{}generations}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k}{return} \PYG{n}{checkSpeciation}\PYG{p}{(}\PYG{n}{random\PYGZus{}number}\PYG{p}{,} \PYG{n}{speciation\PYGZus{}rate}\PYG{p}{,} \PYG{n}{no\PYGZus{}generations}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{void} \PYG{n}{Tree}\PYG{o}{:}\PYG{o}{:}\PYG{n}{coalescenceEvent}\PYG{p}{(}\PYG{k}{const} \PYG{k+kt}{unsigned} \PYG{k+kt}{long}\PYG{o}{\PYGZam{}} \PYG{n}{chosen}\PYG{p}{,} \PYG{k+kt}{unsigned} \PYG{k+kt}{long}\PYG{o}{\PYGZam{}} \PYG{n}{coalchosen}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{c+c1}{// coalescence occured, so we need to adjust the data appropriatedly}
    \PYG{c+c1}{// our chosen lineage has merged with the coalchosen lineage, so we need to sync up the data.}
    \PYG{n}{enddata}\PYG{o}{+}\PYG{o}{+}\PYG{p}{;}
    \PYG{n}{data}\PYG{p}{[}\PYG{n}{enddata}\PYG{p}{]}\PYG{p}{.}\PYG{n}{setup}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{active}\PYG{p}{[}\PYG{n}{chosen}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getXpos}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{n}{active}\PYG{p}{[}\PYG{n}{chosen}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getYpos}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{n}{active}\PYG{p}{[}\PYG{n}{chosen}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getXwrap}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,}
                        \PYG{n}{active}\PYG{p}{[}\PYG{n}{chosen}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getYwrap}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{n}{generation}\PYG{p}{)}\PYG{p}{;}

    \PYG{c+c1}{// First perform the move}
    \PYG{n}{data}\PYG{p}{[}\PYG{n}{active}\PYG{p}{[}\PYG{n}{chosen}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getReference}\PYG{p}{(}\PYG{p}{)}\PYG{p}{]}\PYG{p}{.}\PYG{n}{setParent}\PYG{p}{(}\PYG{n}{enddata}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{data}\PYG{p}{[}\PYG{n}{active}\PYG{p}{[}\PYG{n}{coalchosen}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getReference}\PYG{p}{(}\PYG{p}{)}\PYG{p}{]}\PYG{p}{.}\PYG{n}{setParent}\PYG{p}{(}\PYG{n}{enddata}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{active}\PYG{p}{[}\PYG{n}{coalchosen}\PYG{p}{]}\PYG{p}{.}\PYG{n}{setMinmax}\PYG{p}{(}
            \PYG{n}{max}\PYG{p}{(}\PYG{n}{active}\PYG{p}{[}\PYG{n}{coalchosen}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getMinmax}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,}
                \PYG{n}{active}\PYG{p}{[}\PYG{n}{chosen}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getMinmax}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}  \PYG{c+c1}{// set the new minmax to the maximum of the two minimums.}
    \PYG{n}{active}\PYG{p}{[}\PYG{n}{chosen}\PYG{p}{]}\PYG{p}{.}\PYG{n}{setMinmax}\PYG{p}{(}\PYG{n}{active}\PYG{p}{[}\PYG{n}{coalchosen}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getMinmax}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{data}\PYG{p}{[}\PYG{n}{enddata}\PYG{p}{]}\PYG{p}{.}\PYG{n}{setGenerationRate}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{data}\PYG{p}{[}\PYG{n}{enddata}\PYG{p}{]}\PYG{p}{.}\PYG{n}{setSpec}\PYG{p}{(}\PYG{n}{NR}\PYG{p}{.}\PYG{n}{d01}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{active}\PYG{p}{[}\PYG{n}{chosen}\PYG{p}{]}\PYG{p}{.}\PYG{n}{setReference}\PYG{p}{(}\PYG{n}{enddata}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{active}\PYG{p}{[}\PYG{n}{coalchosen}\PYG{p}{]}\PYG{p}{.}\PYG{n}{setReference}\PYG{p}{(}\PYG{n}{enddata}\PYG{p}{)}\PYG{p}{;}
    \PYG{c+c1}{//      removeOldPosition(chosen);}
    \PYG{n}{switchPositions}\PYG{p}{(}\PYG{n}{chosen}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}


\PYG{k+kt}{void} \PYG{n}{Tree}\PYG{o}{:}\PYG{o}{:}\PYG{n}{checkTimeUpdate}\PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k}{if}\PYG{p}{(}\PYG{n}{has\PYGZus{}times\PYGZus{}file} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{n}{this\PYGZus{}step}\PYG{p}{.}\PYG{n}{time\PYGZus{}reference} \PYG{o}{\PYGZlt{}} \PYG{n}{reference\PYGZus{}times}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{c+c1}{// check if we need to update}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{reference\PYGZus{}times}\PYG{p}{[}\PYG{n}{this\PYGZus{}step}\PYG{p}{.}\PYG{n}{time\PYGZus{}reference}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{n}{generation}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{c+c1}{//                  os \PYGZlt{}\PYGZlt{} \PYGZdq{}check2\PYGZdq{} \PYGZlt{}\PYGZlt{} endl;}
            \PYG{k}{if}\PYG{p}{(}\PYG{n}{reference\PYGZus{}times}\PYG{p}{[}\PYG{n}{this\PYGZus{}step}\PYG{p}{.}\PYG{n}{time\PYGZus{}reference}\PYG{p}{]} \PYG{o}{\PYGZgt{}} \PYG{l+m+mf}{0.0}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{n}{stringstream} \PYG{n}{os}\PYG{p}{;}
                \PYG{n}{os} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{expanding map at generation }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{generation} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
                \PYG{n}{addLineages}\PYG{p}{(}\PYG{n}{reference\PYGZus{}times}\PYG{p}{[}\PYG{n}{this\PYGZus{}step}\PYG{p}{.}\PYG{n}{time\PYGZus{}reference}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
                \PYG{n}{writeInfo}\PYG{p}{(}\PYG{n}{os}\PYG{p}{.}\PYG{n}{str}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
            \PYG{n}{this\PYGZus{}step}\PYG{p}{.}\PYG{n}{time\PYGZus{}reference}\PYG{o}{+}\PYG{o}{+}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
    \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{void} \PYG{n}{Tree}\PYG{o}{:}\PYG{o}{:}\PYG{n}{addLineages}\PYG{p}{(}\PYG{k+kt}{double} \PYG{n}{generation\PYGZus{}in}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k}{auto} \PYG{n}{added\PYGZus{}data} \PYG{o}{=} \PYG{k}{static\PYGZus{}cast}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{unsigned} \PYG{k+kt}{long}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{n}{floor}\PYG{p}{(}\PYG{n}{deme\PYGZus{}sample} \PYG{o}{*} \PYG{n}{deme}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{added\PYGZus{}active} \PYG{o}{=} \PYG{n}{added\PYGZus{}data} \PYG{o}{\PYGZhy{}} \PYG{n}{endactive}\PYG{p}{;}
    \PYG{n}{checkSimSize}\PYG{p}{(}\PYG{n}{added\PYGZus{}data}\PYG{p}{,} \PYG{n}{added\PYGZus{}active}\PYG{p}{)}\PYG{p}{;}
    \PYG{c+c1}{// change those that already exist to tips}
    \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{endactive}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{makeTip}\PYG{p}{(}\PYG{n}{endactive}\PYG{p}{,} \PYG{n}{generation\PYGZus{}in}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{added\PYGZus{}active}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{enddata} \PYG{o}{+}\PYG{o}{+}\PYG{p}{;}
        \PYG{n}{endactive} \PYG{o}{+}\PYG{o}{+}\PYG{p}{;}
        \PYG{n}{active}\PYG{p}{[}\PYG{n}{endactive}\PYG{p}{]}\PYG{p}{.}\PYG{n}{setup}\PYG{p}{(}\PYG{n}{enddata}\PYG{p}{,} \PYG{n}{endactive}\PYG{p}{,} \PYG{l+m+mf}{1.0}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{data}\PYG{p}{[}\PYG{n}{enddata}\PYG{p}{]}\PYG{p}{.}\PYG{n}{setup}\PYG{p}{(}\PYG{n+nb}{true}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{generation\PYGZus{}in}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{data}\PYG{p}{[}\PYG{n}{enddata}\PYG{p}{]}\PYG{p}{.}\PYG{n}{setSpec}\PYG{p}{(}\PYG{n}{NR}\PYG{p}{.}\PYG{n}{d01}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{if}\PYG{p}{(}\PYG{n}{endactive} \PYG{o}{!}\PYG{o}{=} \PYG{n}{added\PYGZus{}data}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{throw} \PYG{n}{FatalException}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Error whilst adding lineages. Please report this bug.}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}


\PYG{k+kt}{void} \PYG{n}{Tree}\PYG{o}{:}\PYG{o}{:}\PYG{n}{checkSimSize}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{req\PYGZus{}data}\PYG{p}{,} \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{req\PYGZus{}active}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{c+c1}{// need to be triple the size of the maximum number of individuals plus enddata}
    \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{min\PYGZus{}data} \PYG{o}{=} \PYG{p}{(}\PYG{l+m+mi}{3} \PYG{o}{*} \PYG{n}{req\PYGZus{}data}\PYG{p}{)} \PYG{o}{+} \PYG{n}{enddata} \PYG{o}{+} \PYG{l+m+mi}{2}\PYG{p}{;}
    \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{min\PYGZus{}active} \PYG{o}{=} \PYG{n}{endactive} \PYG{o}{+} \PYG{n}{req\PYGZus{}active} \PYG{o}{+} \PYG{l+m+mi}{2}\PYG{p}{;}
    \PYG{k}{if}\PYG{p}{(}\PYG{n}{data}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{n}{min\PYGZus{}data}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{c+c1}{// change the size of data}
        \PYG{n}{data}\PYG{p}{.}\PYG{n}{resize}\PYG{p}{(}\PYG{n}{min\PYGZus{}data}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{k}{if}\PYG{p}{(}\PYG{n}{active}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{n}{min\PYGZus{}active}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{c+c1}{// change the size of active.}
        \PYG{n}{active}\PYG{p}{.}\PYG{n}{resize}\PYG{p}{(}\PYG{n}{min\PYGZus{}active}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{void} \PYG{n}{Tree}\PYG{o}{:}\PYG{o}{:}\PYG{n}{makeTip}\PYG{p}{(}\PYG{k}{const} \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{tmp\PYGZus{}active}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{double} \PYG{o}{\PYGZam{}}\PYG{n}{generationin}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{reference} \PYG{o}{=} \PYG{n}{active}\PYG{p}{[}\PYG{n}{tmp\PYGZus{}active}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getReference}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
    \PYG{k}{if}\PYG{p}{(}\PYG{n}{data}\PYG{p}{[}\PYG{n}{reference}\PYG{p}{]}\PYG{p}{.}\PYG{n}{isTip}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{convertTip}\PYG{p}{(}\PYG{n}{tmp\PYGZus{}active}\PYG{p}{,} \PYG{n}{generationin}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{else}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{data}\PYG{p}{[}\PYG{n}{active}\PYG{p}{[}\PYG{n}{tmp\PYGZus{}active}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getReference}\PYG{p}{(}\PYG{p}{)}\PYG{p}{]}\PYG{p}{.}\PYG{n}{setGeneration}\PYG{p}{(}\PYG{n}{generationin}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{data}\PYG{p}{[}\PYG{n}{active}\PYG{p}{[}\PYG{n}{tmp\PYGZus{}active}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getReference}\PYG{p}{(}\PYG{p}{)}\PYG{p}{]}\PYG{p}{.}\PYG{n}{setTip}\PYG{p}{(}\PYG{n+nb}{true}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{void} \PYG{n}{Tree}\PYG{o}{:}\PYG{o}{:}\PYG{n}{convertTip}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{i}\PYG{p}{,} \PYG{k+kt}{double} \PYG{n}{generationin}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{n}{enddata}\PYG{o}{+}\PYG{o}{+}\PYG{p}{;}
    \PYG{k}{if}\PYG{p}{(}\PYG{n}{enddata} \PYG{o}{\PYGZgt{}}\PYG{o}{=} \PYG{n}{data}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{throw} \PYG{n}{FatalException}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Cannot add tip \PYGZhy{} no space in data. Check size calculations.}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{n}{data}\PYG{p}{[}\PYG{n}{enddata}\PYG{p}{]}\PYG{p}{.}\PYG{n}{setup}\PYG{p}{(}\PYG{n+nb}{true}\PYG{p}{,} \PYG{n}{active}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getXpos}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{n}{active}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getYpos}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,}
                        \PYG{n}{active}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getXwrap}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,}
                        \PYG{n}{active}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getYwrap}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{n}{generationin}\PYG{p}{)}\PYG{p}{;}
    \PYG{c+c1}{// Now link the old tip to the new tip}
    \PYG{n}{data}\PYG{p}{[}\PYG{n}{active}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getReference}\PYG{p}{(}\PYG{p}{)}\PYG{p}{]}\PYG{p}{.}\PYG{n}{setParent}\PYG{p}{(}\PYG{n}{enddata}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{data}\PYG{p}{[}\PYG{n}{enddata}\PYG{p}{]}\PYG{p}{.}\PYG{n}{setGenerationRate}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{data}\PYG{p}{[}\PYG{n}{enddata}\PYG{p}{]}\PYG{p}{.}\PYG{n}{setSpec}\PYG{p}{(}\PYG{n}{NR}\PYG{p}{.}\PYG{n}{d01}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{active}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{setReference}\PYG{p}{(}\PYG{n}{enddata}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}


\PYG{k+kt}{void} \PYG{n}{Tree}\PYG{o}{:}\PYG{o}{:}\PYG{n}{applySpecRate}\PYG{p}{(}\PYG{k+kt}{long} \PYG{k+kt}{double} \PYG{n}{sr}\PYG{p}{,} \PYG{k+kt}{double} \PYG{n}{t}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{n}{setupTreeGeneration}\PYG{p}{(}\PYG{n}{sr}\PYG{p}{,} \PYG{n}{t}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{community}\PYG{p}{.}\PYG{n}{createDatabase}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifdef record\PYGZus{}space}
    \PYG{n}{community}\PYG{p}{.}\PYG{n}{recordSpatial}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{void} \PYG{n}{Tree}\PYG{o}{:}\PYG{o}{:}\PYG{n}{applySpecRateInternal}\PYG{p}{(}\PYG{k+kt}{long} \PYG{k+kt}{double} \PYG{n}{sr}\PYG{p}{,} \PYG{k+kt}{double} \PYG{n}{t}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{n}{setupTreeGeneration}\PYG{p}{(}\PYG{n}{sr}\PYG{p}{,} \PYG{n}{t}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{community}\PYG{p}{.}\PYG{n}{calcSpecies}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{community}\PYG{p}{.}\PYG{n}{calcSpeciesAbundance}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{n}{Row}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{unsigned} \PYG{k+kt}{long}\PYG{o}{\PYGZgt{}} \PYG{o}{*} \PYG{n}{Tree}\PYG{o}{:}\PYG{o}{:}\PYG{n}{getCumulativeAbundances}\PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k}{return} \PYG{n}{community}\PYG{p}{.}\PYG{n}{getCumulativeAbundances}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{void} \PYG{n}{Tree}\PYG{o}{:}\PYG{o}{:}\PYG{n}{setupTreeGeneration}\PYG{p}{(}\PYG{k+kt}{long} \PYG{k+kt}{double} \PYG{n}{sr}\PYG{p}{,} \PYG{k+kt}{double} \PYG{n}{t}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k}{if}\PYG{p}{(}\PYG{o}{!}\PYG{n}{community}\PYG{p}{.}\PYG{n}{hasImportedData}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{community}\PYG{p}{.}\PYG{n}{setDatabase}\PYG{p}{(}\PYG{n}{database}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{n}{community}\PYG{p}{.}\PYG{n}{resetTree}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{community}\PYG{p}{.}\PYG{n}{internalOption}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{community}\PYG{p}{.}\PYG{n}{overrideProtractedParameters}\PYG{p}{(}\PYG{n}{getProtractedGenerationMin}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{n}{getProtractedGenerationMax}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{community}\PYG{p}{.}\PYG{n}{setProtracted}\PYG{p}{(}\PYG{n}{getProtracted}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{community}\PYG{p}{.}\PYG{n}{addCalculationPerformed}\PYG{p}{(}\PYG{n}{sr}\PYG{p}{,} \PYG{n}{t}\PYG{p}{,} \PYG{n+nb}{false}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mf}{0.0}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{void} \PYG{n}{Tree}\PYG{o}{:}\PYG{o}{:}\PYG{n}{applySpecRate}\PYG{p}{(}\PYG{k+kt}{long} \PYG{k+kt}{double} \PYG{n}{sr}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{n}{applySpecRate}\PYG{p}{(}\PYG{n}{sr}\PYG{p}{,} \PYG{l+m+mf}{0.0}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{void} \PYG{n}{Tree}\PYG{o}{:}\PYG{o}{:}\PYG{n}{applyMultipleRates}\PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{n}{stringstream} \PYG{n}{os}\PYG{p}{;}
    \PYG{k}{if}\PYG{p}{(}\PYG{n}{speciation\PYGZus{}rates}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{os} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{No additional speciation rates to apply.}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{n}{speciation\PYGZus{}rates}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{n}{spec}\PYG{p}{)}\PYG{p}{;}
    \PYG{c+c1}{// Get only unique speciation rates}
    \PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{long} \PYG{k+kt}{double}\PYG{o}{\PYGZgt{}} \PYG{n}{unique\PYGZus{}speciation\PYGZus{}rates}\PYG{p}{;}
    \PYG{k}{for}\PYG{p}{(}\PYG{k}{const} \PYG{k+kt}{double} \PYG{o}{\PYGZam{}}\PYG{n+nl}{s} \PYG{p}{:} \PYG{n}{speciation\PYGZus{}rates}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k+kt}{bool} \PYG{n}{add} \PYG{o}{=} \PYG{n+nb}{true}\PYG{p}{;}
        \PYG{k}{for}\PYG{p}{(}\PYG{k}{const} \PYG{k+kt}{double} \PYG{o}{\PYGZam{}} \PYG{n+nl}{u} \PYG{p}{:} \PYG{n}{unique\PYGZus{}speciation\PYGZus{}rates}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{k}{if}\PYG{p}{(}\PYG{n}{doubleCompare}\PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{n}{s}\PYG{p}{,} \PYG{n}{s}\PYG{o}{*}\PYG{l+m+mf}{0.00001}\PYG{p}{)}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{n}{add} \PYG{o}{=} \PYG{n+nb}{false}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{add}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{unique\PYGZus{}speciation\PYGZus{}rates}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{n}{s}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
    \PYG{p}{\PYGZcb{}}
    \PYG{n}{speciation\PYGZus{}rates} \PYG{o}{=} \PYG{n}{unique\PYGZus{}speciation\PYGZus{}rates}\PYG{p}{;}
    \PYG{n}{os} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Speciation rate}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{flush}\PYG{p}{;}
    \PYG{k}{if}\PYG{p}{(}\PYG{n}{speciation\PYGZus{}rates}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{1}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{os} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{s are: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{flush}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{else}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{os} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ is: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{flush}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{speciation\PYGZus{}rates}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{os} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{speciation\PYGZus{}rates}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{flush}\PYG{p}{;}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{i} \PYG{o}{+} \PYG{l+m+mi}{1} \PYG{o}{=}\PYG{o}{=} \PYG{n}{speciation\PYGZus{}rates}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{os} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{.}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{else}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{os} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{, }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{flush}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
    \PYG{p}{\PYGZcb{}}
    \PYG{n}{writeInfo}\PYG{p}{(}\PYG{n}{os}\PYG{p}{.}\PYG{n}{str}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
    \PYG{c+c1}{// Now check to make sure repeat speciation rates aren\PYGZsq{}t done twice (this is done to avoid the huge number of errors}
    \PYG{c+c1}{// SQL throws if you try to add identical data}
    \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{spec\PYGZus{}upto} \PYG{o}{=} \PYG{n}{sortData}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{sqlCreate}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
    \PYG{k}{for}\PYG{p}{(}\PYG{k}{const} \PYG{k+kt}{long} \PYG{k+kt}{double} \PYG{o}{\PYGZam{}}\PYG{n+nl}{i}\PYG{p}{:} \PYG{n}{speciation\PYGZus{}rates}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{double}\PYG{o}{\PYGZgt{}} \PYG{n}{temp\PYGZus{}sampling} \PYG{o}{=} \PYG{n}{getTemporalSampling}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{double} \PYG{n+nl}{k} \PYG{p}{:} \PYG{n}{temp\PYGZus{}sampling}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{writeInfo}\PYG{p}{(}\PYG{n}{to\PYGZus{}string}\PYG{p}{(}\PYG{n}{k}\PYG{p}{)} \PYG{o}{+} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{,}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{double} \PYG{n+nl}{k} \PYG{p}{:} \PYG{n}{temp\PYGZus{}sampling}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{writeInfo}\PYG{p}{(}\PYG{n}{string}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Calculating generation }\PYG{l+s}{\PYGZdq{}} \PYG{o}{+} \PYG{n}{to\PYGZus{}string}\PYG{p}{(}\PYG{n}{k}\PYG{p}{)} \PYG{o}{+} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
            \PYG{k}{if}\PYG{p}{(}\PYG{n}{i} \PYG{o}{\PYGZgt{}} \PYG{n}{spec}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{n}{applySpecRate}\PYG{p}{(}\PYG{n}{i}\PYG{p}{,} \PYG{n}{k}\PYG{p}{)}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
            \PYG{k}{else} \PYG{k}{if}\PYG{p}{(}\PYG{n}{i} \PYG{o}{=}\PYG{o}{=} \PYG{n}{spec}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{c+c1}{// Use the run spec if the rates are very close to equal}
                \PYG{n}{applySpecRate}\PYG{p}{(}\PYG{n}{spec}\PYG{p}{,} \PYG{n}{k}\PYG{p}{)}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
            \PYG{k}{else}
            \PYG{p}{\PYGZob{}}
                \PYG{n}{writeWarning}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Speciation rate }\PYG{l+s}{\PYGZdq{}} \PYG{o}{+} \PYG{n}{to\PYGZus{}string}\PYG{p}{(}\PYG{n}{i}\PYG{p}{)} \PYG{o}{+}
                                     \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ less than simulation minimum (}\PYG{l+s}{\PYGZdq{}} \PYG{o}{+} \PYG{n}{to\PYGZus{}string}\PYG{p}{(}\PYG{n}{spec}\PYG{p}{)} \PYG{o}{+} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{)}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
        \PYG{p}{\PYGZcb{}}
    \PYG{p}{\PYGZcb{}}
    \PYG{n}{community}\PYG{p}{.}\PYG{n}{writeNewCommunityParameters}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{outputData}\PYG{p}{(}\PYG{n}{spec\PYGZus{}upto}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{bool} \PYG{n}{Tree}\PYG{o}{:}\PYG{o}{:}\PYG{n}{getProtracted}\PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k}{return} \PYG{n+nb}{false}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{n}{string} \PYG{n}{Tree}\PYG{o}{:}\PYG{o}{:}\PYG{n}{getProtractedVariables}\PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{n}{stringstream} \PYG{n}{ss}\PYG{p}{;}
    \PYG{n}{ss} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{0.0}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{0.0}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
    \PYG{k}{return} \PYG{n}{ss}\PYG{p}{.}\PYG{n}{str}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{double} \PYG{n}{Tree}\PYG{o}{:}\PYG{o}{:}\PYG{n}{getProtractedGenerationMin}\PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k}{return} \PYG{l+m+mf}{0.0}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{double} \PYG{n}{Tree}\PYG{o}{:}\PYG{o}{:}\PYG{n}{getProtractedGenerationMax}\PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k}{return} \PYG{l+m+mf}{0.0}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{void} \PYG{n}{Tree}\PYG{o}{:}\PYG{o}{:}\PYG{n}{sqlOutput}\PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifdef sql\PYGZus{}ram}
    \PYG{c+c1}{// open connection to the database file}
    \PYG{n}{remove}\PYG{p}{(}\PYG{n}{sqloutname}\PYG{p}{.}\PYG{n}{c\PYGZus{}str}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{stringstream} \PYG{n}{os}\PYG{p}{;}
    \PYG{n}{os} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}r}\PYG{l+s}{    Writing to }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{sqloutname} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ ....     }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{flush}\PYG{p}{;}
    \PYG{n}{writeInfo}\PYG{p}{(}\PYG{n}{os}\PYG{p}{.}\PYG{n}{str}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{openSQLiteDatabase}\PYG{p}{(}\PYG{n}{sqloutname}\PYG{p}{,} \PYG{n}{outdatabase}\PYG{p}{)}\PYG{p}{;}
    \PYG{c+c1}{// create the backup object to write data to the file from memory.}
    \PYG{n}{sqlite3\PYGZus{}backup}\PYG{o}{*} \PYG{n}{backupdb}\PYG{p}{;}
    \PYG{n}{backupdb} \PYG{o}{=} \PYG{n}{sqlite3\PYGZus{}backup\PYGZus{}init}\PYG{p}{(}\PYG{n}{outdatabase}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{main}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{database}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{main}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{k}{if}\PYG{p}{(}\PYG{o}{!}\PYG{n}{backupdb}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{cerr} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ERROR\PYGZus{}SQL\PYGZus{}011: Could not write to the backup database. Check the file exists.}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{c+c1}{// Perform the backup}
    \PYG{k+kt}{int} \PYG{n}{rc} \PYG{o}{=} \PYG{n}{sqlite3\PYGZus{}backup\PYGZus{}step}\PYG{p}{(}\PYG{n}{backupdb}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
    \PYG{k}{if}\PYG{p}{(}\PYG{n}{rc} \PYG{o}{!}\PYG{o}{=} \PYG{n}{SQLITE\PYGZus{}OK} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{n}{rc} \PYG{o}{!}\PYG{o}{=} \PYG{n}{SQLITE\PYGZus{}DONE}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
        \PYG{k}{while}\PYG{p}{(}\PYG{p}{(}\PYG{n}{rc} \PYG{o}{!}\PYG{o}{=} \PYG{n}{SQLITE\PYGZus{}OK} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{n}{rc} \PYG{o}{!}\PYG{o}{=} \PYG{n}{SQLITE\PYGZus{}DONE}\PYG{p}{)} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{10}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{;}
            \PYG{n}{sleep}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
            \PYG{n}{rc} \PYG{o}{=} \PYG{n}{sqlite3\PYGZus{}backup\PYGZus{}step}\PYG{p}{(}\PYG{n}{backupdb}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
            \PYG{c+c1}{//              cerr \PYGZlt{}\PYGZlt{} \PYGZdq{}Attempt \PYGZdq{} \PYGZlt{}\PYGZlt{} i \PYGZlt{}\PYGZlt{} \PYGZdq{} failed...\PYGZdq{} \PYGZlt{}\PYGZlt{} endl;}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{rc} \PYG{o}{!}\PYG{o}{=} \PYG{n}{SQLITE\PYGZus{}OK} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{n}{rc} \PYG{o}{!}\PYG{o}{=} \PYG{n}{SQLITE\PYGZus{}DONE}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{stringstream} \PYG{n}{ss}\PYG{p}{;}
            \PYG{n}{ss} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ERROR\PYGZus{}SQL\PYGZus{}010: SQLite database file could not be opened. Check the folder exists and you }\PYG{l+s}{\PYGZdq{}}
                    \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{have write permissions. (REF3) Error code: }\PYG{l+s}{\PYGZdq{}}
                 \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{rc} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
            \PYG{n}{ss} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Attempted call }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{i} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ times}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
            \PYG{n}{writeWarning}\PYG{p}{(}\PYG{n}{ss}\PYG{p}{.}\PYG{n}{str}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
    \PYG{p}{\PYGZcb{}}
    \PYG{n}{sqlite3\PYGZus{}backup\PYGZus{}finish}\PYG{p}{(}\PYG{n}{backupdb}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{os}\PYG{p}{.}\PYG{n}{str}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{os} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}r}\PYG{l+s}{    Writing to }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{sqloutname} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ ....  done!              }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
    \PYG{n}{writeInfo}\PYG{p}{(}\PYG{n}{os}\PYG{p}{.}\PYG{n}{str}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{void} \PYG{n}{Tree}\PYG{o}{:}\PYG{o}{:}\PYG{n}{outputData}\PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{species\PYGZus{}richness} \PYG{o}{=} \PYG{n}{sortData}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{sqlCreate}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{outputData}\PYG{p}{(}\PYG{n}{species\PYGZus{}richness}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{void} \PYG{n}{Tree}\PYG{o}{:}\PYG{o}{:}\PYG{n}{outputData}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{species\PYGZus{}richness}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{c+c1}{// Run the data sorting functions and output the data into the correct format.}

    \PYG{n}{time}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{out\PYGZus{}finish}\PYG{p}{)}\PYG{p}{;}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifdef sql\PYGZus{}ram}
    \PYG{n}{sqlOutput}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif}
    \PYG{n}{time}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{sim\PYGZus{}end}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{writeTimes}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{Tree}\PYG{o}{:}\PYG{o}{:}\PYG{n}{sortData}\PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{c+c1}{// Sort and process the species list so that the useful information can be extracted from it.}
    \PYG{n}{stringstream} \PYG{n}{os}\PYG{p}{;}
    \PYG{n}{os} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Finalising data...}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{flush}\PYG{p}{;}
    \PYG{n}{writeInfo}\PYG{p}{(}\PYG{n}{os}\PYG{p}{.}\PYG{n}{str}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{os}\PYG{p}{.}\PYG{n}{str}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{c+c1}{// coalescence finished \PYGZhy{} process speciation}
    \PYG{c+c1}{// check the data structure}
    \PYG{k}{if}\PYG{p}{(}\PYG{n}{enddata} \PYG{o}{\PYGZgt{}} \PYG{n}{data}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifdef DEBUG}
        \PYG{n}{stringstream} \PYG{n}{ss}\PYG{p}{;}
        \PYG{n}{ss} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{enddata: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{enddata} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
        \PYG{n}{ss} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{data.size(): }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{data}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
        \PYG{n}{writeLog}\PYG{p}{(}\PYG{l+m+mi}{50}\PYG{p}{,} \PYG{n}{ss}\PYG{p}{)}\PYG{p}{;}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif }\PYG{c+c1}{// DEBUG}
        \PYG{k}{throw} \PYG{n+nf}{FatalException}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Enddata greater than data size. Programming error likely.}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{c+c1}{// Now make sure those left in endactive will definitely speciate.}
    \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{n}{endactive}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{data}\PYG{p}{[}\PYG{n}{active}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getReference}\PYG{p}{(}\PYG{p}{)}\PYG{p}{]}\PYG{p}{.}\PYG{n}{setSpec}\PYG{p}{(}\PYG{l+m+mf}{0.0}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{c+c1}{// Double check speciation events have been counted.}
    \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{spec\PYGZus{}up\PYGZus{}to} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
    \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{n}{enddata}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{calcSpeciation}\PYG{p}{(}\PYG{n}{data}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getSpecRate}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{n}{spec}\PYG{p}{,} \PYG{n}{data}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getGenRate}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{spec\PYGZus{}up\PYGZus{}to}\PYG{o}{+}\PYG{o}{+}\PYG{p}{;}
            \PYG{n}{data}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{speciate}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{try}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{n}{enddata}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{k}{if}\PYG{p}{(}\PYG{p}{(}\PYG{o}{!}\PYG{p}{(}\PYG{n}{data}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{hasSpeciated}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{p}{(}\PYG{n}{data}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getParent}\PYG{p}{(}\PYG{p}{)} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{0} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{n}{data}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getExistence}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{k}{throw} \PYG{n}{FatalException}\PYG{p}{(}\PYG{n}{string}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ERROR\PYGZus{}MAIN\PYGZus{}004: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{+} \PYG{n}{to\PYGZus{}string}\PYG{p}{(}\PYG{p}{(}\PYG{k+kt}{long} \PYG{k+kt}{long}\PYG{p}{)}\PYG{n}{i}\PYG{p}{)} \PYG{o}{+}
                                            \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ has not speciated and parent is 0.}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
        \PYG{p}{\PYGZcb{}}
        \PYG{c+c1}{// here we check the data is valid \PYGZhy{} alternative validity check.}
        \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{n}{enddata}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{k}{if}\PYG{p}{(}\PYG{o}{!}\PYG{p}{(}\PYG{n}{data}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{hasSpeciated}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{n}{data}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getExistence}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{k+kt}{long} \PYG{n}{j} \PYG{o}{=} \PYG{n}{i}\PYG{p}{;}
                \PYG{k}{while}\PYG{p}{(}\PYG{o}{!}\PYG{p}{(}\PYG{n}{data}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{p}{.}\PYG{n}{hasSpeciated}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
                \PYG{p}{\PYGZob{}}
                    \PYG{n}{j} \PYG{o}{=} \PYG{n}{data}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getParent}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
                    \PYG{k}{if}\PYG{p}{(}\PYG{n}{j} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)}
                    \PYG{p}{\PYGZob{}}
                        \PYG{k}{throw} \PYG{n}{FatalException}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ERROR\PYGZus{}MAIN\PYGZus{}005: 0 found in parent while following speciation trail.}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
                    \PYG{p}{\PYGZcb{}}
                \PYG{p}{\PYGZcb{}}
            \PYG{p}{\PYGZcb{}}
        \PYG{p}{\PYGZcb{}}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{catch}\PYG{p}{(}\PYG{n}{FatalException}\PYG{o}{\PYGZam{}} \PYG{n}{me}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifdef DEBUG}
        \PYG{n}{writeLog}\PYG{p}{(}\PYG{l+m+mi}{30}\PYG{p}{,} \PYG{n}{me}\PYG{p}{.}\PYG{n}{what}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{writeLog}\PYG{p}{(}\PYG{l+m+mi}{30}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Returning max possible size (may cause RAM issues).}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif }\PYG{c+c1}{// DEBUG}
        \PYG{k}{return} \PYG{n}{data}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{n}{writeInfo}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{done!}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{k}{return} \PYG{n}{spec\PYGZus{}up\PYGZus{}to}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{void} \PYG{n}{Tree}\PYG{o}{:}\PYG{o}{:}\PYG{n}{writeTimes}\PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{n}{stringstream} \PYG{n}{os}\PYG{p}{;}
    \PYG{n}{os} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Total generations simulated (steps): }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{generation} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ (}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{steps} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{)}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifdef DEBUG}
    \PYG{n}{stringstream} \PYG{n}{ss}\PYG{p}{;}
    \PYG{n}{ss} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Count dispersal, density fails: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{count\PYGZus{}dispersal\PYGZus{}fails} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{, }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{count\PYGZus{}density\PYGZus{}fails} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
    \PYG{n}{writeLog}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{,} \PYG{n}{ss}\PYG{p}{)}\PYG{p}{;}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif}
    \PYG{n}{os} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Setup time was }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{floor}\PYG{p}{(}\PYG{p}{(}\PYG{n}{sim\PYGZus{}start} \PYG{o}{\PYGZhy{}} \PYG{n}{start}\PYG{p}{)} \PYG{o}{/} \PYG{l+m+mi}{60}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ minutes }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{p}{(}\PYG{n}{sim\PYGZus{}start} \PYG{o}{\PYGZhy{}} \PYG{n}{start}\PYG{p}{)} \PYG{o}{\PYGZpc{}} \PYG{l+m+mi}{60} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ seconds}\PYG{l+s}{\PYGZdq{}}
       \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
    \PYG{n}{os} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Simulation time was }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{floor}\PYG{p}{(}\PYG{p}{(}\PYG{n}{sim\PYGZus{}finish} \PYG{o}{\PYGZhy{}} \PYG{n}{sim\PYGZus{}start}\PYG{p}{)} \PYG{o}{/} \PYG{l+m+mi}{3600}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ hours }\PYG{l+s}{\PYGZdq{}}
       \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{p}{(}\PYG{n}{floor}\PYG{p}{(}\PYG{p}{(}\PYG{n}{sim\PYGZus{}finish} \PYG{o}{\PYGZhy{}} \PYG{n}{sim\PYGZus{}start}\PYG{p}{)} \PYG{o}{/} \PYG{l+m+mi}{60}\PYG{p}{)} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{60} \PYG{o}{*} \PYG{n}{floor}\PYG{p}{(}\PYG{p}{(}\PYG{n}{sim\PYGZus{}finish} \PYG{o}{\PYGZhy{}} \PYG{n}{sim\PYGZus{}start}\PYG{p}{)} \PYG{o}{/} \PYG{l+m+mi}{3600}\PYG{p}{)}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ minutes }\PYG{l+s}{\PYGZdq{}}
       \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{p}{(}\PYG{n}{sim\PYGZus{}finish} \PYG{o}{\PYGZhy{}} \PYG{n}{sim\PYGZus{}start}\PYG{p}{)} \PYG{o}{\PYGZpc{}} \PYG{l+m+mi}{60} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ seconds}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
    \PYG{n}{os} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{File output and species calculation time was }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{floor}\PYG{p}{(}\PYG{p}{(}\PYG{n}{out\PYGZus{}finish} \PYG{o}{\PYGZhy{}} \PYG{n}{sim\PYGZus{}finish}\PYG{p}{)} \PYG{o}{/} \PYG{l+m+mi}{60}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ minutes }\PYG{l+s}{\PYGZdq{}}
       \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{p}{(}\PYG{n}{out\PYGZus{}finish} \PYG{o}{\PYGZhy{}} \PYG{n}{sim\PYGZus{}finish}\PYG{p}{)} \PYG{o}{\PYGZpc{}} \PYG{l+m+mi}{60} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ seconds}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
    \PYG{n}{os} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{SQL output time was }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{floor}\PYG{p}{(}\PYG{p}{(}\PYG{n}{sim\PYGZus{}end} \PYG{o}{\PYGZhy{}} \PYG{n}{out\PYGZus{}finish}\PYG{p}{)} \PYG{o}{/} \PYG{l+m+mi}{60}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ minutes }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{p}{(}\PYG{n}{sim\PYGZus{}end} \PYG{o}{\PYGZhy{}} \PYG{n}{out\PYGZus{}finish}\PYG{p}{)} \PYG{o}{\PYGZpc{}} \PYG{l+m+mi}{60}
       \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ seconds}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
    \PYG{n}{time\PYGZus{}taken} \PYG{o}{+}\PYG{o}{=} \PYG{p}{(}\PYG{n}{sim\PYGZus{}end} \PYG{o}{\PYGZhy{}} \PYG{n}{out\PYGZus{}finish}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{os} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Total time taken was }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{floor}\PYG{p}{(}\PYG{p}{(}\PYG{n}{time\PYGZus{}taken}\PYG{p}{)} \PYG{o}{/} \PYG{l+m+mi}{3600}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ hours }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{flush}\PYG{p}{;}
    \PYG{n}{os} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{p}{(}\PYG{n}{floor}\PYG{p}{(}\PYG{p}{(}\PYG{n}{time\PYGZus{}taken}\PYG{p}{)} \PYG{o}{/} \PYG{l+m+mi}{60}\PYG{p}{)} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{60} \PYG{o}{*} \PYG{n}{floor}\PYG{p}{(}\PYG{p}{(}\PYG{n}{time\PYGZus{}taken}\PYG{p}{)} \PYG{o}{/} \PYG{l+m+mi}{3600}\PYG{p}{)}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{flush}\PYG{p}{;}
    \PYG{n}{os} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ minutes }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{p}{(}\PYG{n}{time\PYGZus{}taken}\PYG{p}{)} \PYG{o}{\PYGZpc{}} \PYG{l+m+mi}{60} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ seconds}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
    \PYG{n}{writeInfo}\PYG{p}{(}\PYG{n}{os}\PYG{p}{.}\PYG{n}{str}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}


\PYG{k+kt}{void} \PYG{n}{Tree}\PYG{o}{:}\PYG{o}{:}\PYG{n}{sqlCreate}\PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{n}{time}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{out\PYGZus{}finish}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{stringstream} \PYG{n}{os}\PYG{p}{;}
    \PYG{n}{os} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Creating SQL database file...}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
    \PYG{n}{os} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{    Checking for existing folders....}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{flush}\PYG{p}{;}
    \PYG{n}{writeInfo}\PYG{p}{(}\PYG{n}{os}\PYG{p}{.}\PYG{n}{str}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{os}\PYG{p}{.}\PYG{n}{str}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{c+c1}{// Create the folder if it doesn\PYGZsq{}t exist}
    \PYG{n}{sqloutname} \PYG{o}{=} \PYG{n}{out\PYGZus{}directory}\PYG{p}{;}
    \PYG{n}{string} \PYG{n}{sqlfolder} \PYG{o}{=} \PYG{n}{out\PYGZus{}directory} \PYG{o}{+} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{/SQL\PYGZus{}data/}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
    \PYG{k}{try}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{createParent}\PYG{p}{(}\PYG{n}{sqlfolder}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{sqloutname} \PYG{o}{+}\PYG{o}{=} \PYG{n}{string}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{/SQL\PYGZus{}data/data\PYGZus{}}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)} \PYG{o}{+} \PYG{n}{to\PYGZus{}string}\PYG{p}{(}\PYG{n}{the\PYGZus{}task}\PYG{p}{)} \PYG{o}{+} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZus{}}\PYG{l+s}{\PYGZdq{}} \PYG{o}{+} \PYG{n}{to\PYGZus{}string}\PYG{p}{(}\PYG{n}{the\PYGZus{}seed}\PYG{p}{)} \PYG{o}{+} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{.db}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{catch}\PYG{p}{(}\PYG{n}{FatalException} \PYG{o}{\PYGZam{}}\PYG{n}{fe}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{writeWarning}\PYG{p}{(}\PYG{n}{fe}\PYG{p}{.}\PYG{n}{what}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{sqloutname} \PYG{o}{=} \PYG{n}{string}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{data\PYGZus{}}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)} \PYG{o}{+} \PYG{n}{to\PYGZus{}string}\PYG{p}{(}\PYG{n}{the\PYGZus{}task}\PYG{p}{)} \PYG{o}{+} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZus{}}\PYG{l+s}{\PYGZdq{}} \PYG{o}{+} \PYG{n}{to\PYGZus{}string}\PYG{p}{(}\PYG{n}{the\PYGZus{}seed}\PYG{p}{)} \PYG{o}{+} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{.db}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{n}{remove}\PYG{p}{(}\PYG{n}{sqloutname}\PYG{p}{.}\PYG{n}{c\PYGZus{}str}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{os}\PYG{p}{.}\PYG{n}{str}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{os} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}r}\PYG{l+s}{    Generating species list....              }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{flush}\PYG{p}{;}
    \PYG{n}{writeInfo}\PYG{p}{(}\PYG{n}{os}\PYG{p}{.}\PYG{n}{str}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
    \PYG{c+c1}{// for outputting the full data from the simulation in to a SQL file.}
    \PYG{n}{sqlite3\PYGZus{}stmt}\PYG{o}{*} \PYG{n}{stmt}\PYG{p}{;}
    \PYG{k+kt}{char}\PYG{o}{*} \PYG{n}{sErrMsg}\PYG{p}{;}
    \PYG{k+kt}{int} \PYG{n}{rc} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{c+c1}{// Open a SQL database in memory. This will be written to disk later.}
\PYG{c+c1}{// A check here can be done to write to disc directly instead to massively reduce RAM consumption}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifdef sql\PYGZus{}ram}
    \PYG{n}{sqlite3\PYGZus{}open}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{:memory:}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{database}\PYG{p}{)}\PYG{p}{;}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifndef sql\PYGZus{}ram}
    \PYG{n}{openSQLiteDatabase}\PYG{p}{(}\PYG{n}{sqloutname}\PYG{p}{,} \PYG{n}{database}\PYG{p}{)}\PYG{p}{;}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif}
    \PYG{c+c1}{// Create the command to be executed by adding to the string.}
    \PYG{n}{string} \PYG{n}{all\PYGZus{}commands}\PYG{p}{;}
    \PYG{n}{all\PYGZus{}commands} \PYG{o}{=}
            \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{CREATE TABLE SPECIES\PYGZus{}LIST (ID int PRIMARY KEY NOT NULL, unique\PYGZus{}spec INT NOT NULL, xval INT NOT NULL,}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
    \PYG{n}{all\PYGZus{}commands} \PYG{o}{+}\PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{yval INT NOT NULL, xwrap INT NOT NULL, ywrap INT NOT NULL, tip INT NOT NULL, speciated INT NOT }\PYG{l+s}{\PYGZdq{}}
            \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{NULL, parent INT NOT NULL, existence INT NOT NULL, randnum DOUBLE NOT NULL, gen\PYGZus{}alive INT NOT }\PYG{l+s}{\PYGZdq{}}
            \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{NULL, gen\PYGZus{}added DOUBLE NOT NULL);}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}

    \PYG{c+c1}{// Create the table within the SQL database}
    \PYG{n}{rc} \PYG{o}{=} \PYG{n}{sqlite3\PYGZus{}exec}\PYG{p}{(}\PYG{n}{database}\PYG{p}{,} \PYG{n}{all\PYGZus{}commands}\PYG{p}{.}\PYG{n}{c\PYGZus{}str}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{k}{nullptr}\PYG{p}{,} \PYG{k}{nullptr}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{sErrMsg}\PYG{p}{)}\PYG{p}{;}
    \PYG{k}{if}\PYG{p}{(}\PYG{n}{rc} \PYG{o}{!}\PYG{o}{=} \PYG{n}{SQLITE\PYGZus{}OK}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifndef sql\PYGZus{}ram}
        \PYG{n}{sqlite3\PYGZus{}close}\PYG{p}{(}\PYG{n}{database}\PYG{p}{)}\PYG{p}{;}
        \PYG{c+c1}{// delete any old database files \PYGZhy{} this is risky, but there isn\PYGZsq{}t a better way of ensuring that the file}
        \PYG{c+c1}{// actually gets created.}
        \PYG{n}{remove}\PYG{p}{(}\PYG{n}{sqloutname}\PYG{p}{.}\PYG{n}{c\PYGZus{}str}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{rc} \PYG{o}{=} \PYG{n}{sqlite3\PYGZus{}open}\PYG{p}{(}\PYG{n}{sqloutname}\PYG{p}{.}\PYG{n}{c\PYGZus{}str}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{database}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{rc} \PYG{o}{=} \PYG{n}{sqlite3\PYGZus{}exec}\PYG{p}{(}\PYG{n}{database}\PYG{p}{,} \PYG{n}{all\PYGZus{}commands}\PYG{p}{.}\PYG{n}{c\PYGZus{}str}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{k}{nullptr}\PYG{p}{,} \PYG{k}{nullptr}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{sErrMsg}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{rc} \PYG{o}{!}\PYG{o}{=} \PYG{n}{SQLITE\PYGZus{}OK}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{stringstream} \PYG{n}{ss}\PYG{p}{;}
            \PYG{n}{ss} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Database file creation failed. Check file system.}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
            \PYG{n}{ss} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Error code: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{rc} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
            \PYG{k}{throw} \PYG{n+nf}{FatalException}\PYG{p}{(}\PYG{n}{ss}\PYG{p}{.}\PYG{n}{str}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif}
    \PYG{p}{\PYGZcb{}}
    \PYG{c+c1}{// Now create the prepared statement into which we shall insert the values from the table}
    \PYG{n}{all\PYGZus{}commands} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{INSERT INTO SPECIES\PYGZus{}LIST }\PYG{l+s}{\PYGZdq{}}
            \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{(ID,unique\PYGZus{}spec,xval,yval,xwrap,ywrap,tip,speciated,parent,existence,randnum,gen\PYGZus{}alive,gen\PYGZus{}added) }\PYG{l+s}{\PYGZdq{}}
            \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?)}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
    \PYG{n}{sqlite3\PYGZus{}prepare\PYGZus{}v2}\PYG{p}{(}\PYG{n}{database}\PYG{p}{,} \PYG{n}{all\PYGZus{}commands}\PYG{p}{.}\PYG{n}{c\PYGZus{}str}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{k}{static\PYGZus{}cast}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{n}{strlen}\PYG{p}{(}\PYG{n}{all\PYGZus{}commands}\PYG{p}{.}\PYG{n}{c\PYGZus{}str}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{stmt}\PYG{p}{,} \PYG{k}{nullptr}\PYG{p}{)}\PYG{p}{;}

    \PYG{c+c1}{// Start the transaction}
    \PYG{n}{rc} \PYG{o}{=} \PYG{n}{sqlite3\PYGZus{}exec}\PYG{p}{(}\PYG{n}{database}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{BEGIN TRANSACTION;}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{k}{nullptr}\PYG{p}{,} \PYG{k}{nullptr}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{sErrMsg}\PYG{p}{)}\PYG{p}{;}
    \PYG{k}{if}\PYG{p}{(}\PYG{n}{rc} \PYG{o}{!}\PYG{o}{=} \PYG{n}{SQLITE\PYGZus{}OK}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{cerr} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ERROR\PYGZus{}SQL\PYGZus{}008: Cannot start SQL transaction. Check memory database assignment and SQL commands.}\PYG{l+s}{\PYGZdq{}}
             \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{n}{enddata}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{sqlite3\PYGZus{}bind\PYGZus{}int}\PYG{p}{(}\PYG{n}{stmt}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{i}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{sqlite3\PYGZus{}bind\PYGZus{}int}\PYG{p}{(}\PYG{n}{stmt}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{k}{static\PYGZus{}cast}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{n}{data}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getSpeciesID}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{sqlite3\PYGZus{}bind\PYGZus{}int}\PYG{p}{(}\PYG{n}{stmt}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{k}{static\PYGZus{}cast}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{n}{data}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getXpos}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{sqlite3\PYGZus{}bind\PYGZus{}int}\PYG{p}{(}\PYG{n}{stmt}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{k}{static\PYGZus{}cast}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{n}{data}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getYpos}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{sqlite3\PYGZus{}bind\PYGZus{}int}\PYG{p}{(}\PYG{n}{stmt}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{,} \PYG{k}{static\PYGZus{}cast}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{n}{data}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getXwrap}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{sqlite3\PYGZus{}bind\PYGZus{}int}\PYG{p}{(}\PYG{n}{stmt}\PYG{p}{,} \PYG{l+m+mi}{6}\PYG{p}{,} \PYG{k}{static\PYGZus{}cast}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{n}{data}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getYwrap}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{sqlite3\PYGZus{}bind\PYGZus{}int}\PYG{p}{(}\PYG{n}{stmt}\PYG{p}{,} \PYG{l+m+mi}{7}\PYG{p}{,} \PYG{n}{data}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{isTip}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{sqlite3\PYGZus{}bind\PYGZus{}int}\PYG{p}{(}\PYG{n}{stmt}\PYG{p}{,} \PYG{l+m+mi}{8}\PYG{p}{,} \PYG{n}{data}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{hasSpeciated}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{sqlite3\PYGZus{}bind\PYGZus{}int}\PYG{p}{(}\PYG{n}{stmt}\PYG{p}{,} \PYG{l+m+mi}{9}\PYG{p}{,} \PYG{k}{static\PYGZus{}cast}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{n}{data}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getParent}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{sqlite3\PYGZus{}bind\PYGZus{}int}\PYG{p}{(}\PYG{n}{stmt}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{,} \PYG{n}{data}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getExistence}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{sqlite3\PYGZus{}bind\PYGZus{}double}\PYG{p}{(}\PYG{n}{stmt}\PYG{p}{,} \PYG{l+m+mi}{11}\PYG{p}{,} \PYG{k}{static\PYGZus{}cast}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{double}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{n}{data}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getSpecRate}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{sqlite3\PYGZus{}bind\PYGZus{}int}\PYG{p}{(}\PYG{n}{stmt}\PYG{p}{,} \PYG{l+m+mi}{12}\PYG{p}{,} \PYG{k}{static\PYGZus{}cast}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{n}{data}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getGenRate}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{sqlite3\PYGZus{}bind\PYGZus{}double}\PYG{p}{(}\PYG{n}{stmt}\PYG{p}{,} \PYG{l+m+mi}{13}\PYG{p}{,} \PYG{k}{static\PYGZus{}cast}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{double}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{n}{data}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getGeneration}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{sqlite3\PYGZus{}step}\PYG{p}{(}\PYG{n}{stmt}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{sqlite3\PYGZus{}clear\PYGZus{}bindings}\PYG{p}{(}\PYG{n}{stmt}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{sqlite3\PYGZus{}reset}\PYG{p}{(}\PYG{n}{stmt}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{n}{os}\PYG{p}{.}\PYG{n}{str}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{os} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}r}\PYG{l+s}{    Executing SQL commands....}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{flush}\PYG{p}{;}
    \PYG{n}{writeInfo}\PYG{p}{(}\PYG{n}{os}\PYG{p}{.}\PYG{n}{str}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
    \PYG{c+c1}{// execute the command and close the connection to the database}
    \PYG{n}{rc} \PYG{o}{=} \PYG{n}{sqlite3\PYGZus{}exec}\PYG{p}{(}\PYG{n}{database}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{END TRANSACTION;}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{k}{nullptr}\PYG{p}{,} \PYG{k}{nullptr}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{sErrMsg}\PYG{p}{)}\PYG{p}{;}
    \PYG{k}{if}\PYG{p}{(}\PYG{n}{rc} \PYG{o}{!}\PYG{o}{=} \PYG{n}{SQLITE\PYGZus{}OK}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{cerr} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ERROR\PYGZus{}SQL\PYGZus{}008: Cannot complete SQL transaction. Check memory database assignment and SQL }\PYG{l+s}{\PYGZdq{}}
                \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{commands. Ensure SQL statements are properly cleared.}\PYG{l+s}{\PYGZdq{}}
             \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
        \PYG{n}{cerr} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Error code: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{rc} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
        \PYG{c+c1}{// try again}
        \PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
        \PYG{k}{while}\PYG{p}{(}\PYG{p}{(}\PYG{n}{rc} \PYG{o}{!}\PYG{o}{=} \PYG{n}{SQLITE\PYGZus{}OK} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{n}{rc} \PYG{o}{!}\PYG{o}{=} \PYG{n}{SQLITE\PYGZus{}DONE}\PYG{p}{)} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{10}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{sleep}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
            \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{;}
            \PYG{n}{rc} \PYG{o}{=} \PYG{n}{sqlite3\PYGZus{}exec}\PYG{p}{(}\PYG{n}{database}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{END TRANSACTION;}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{k}{nullptr}\PYG{p}{,} \PYG{k}{nullptr}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{sErrMsg}\PYG{p}{)}\PYG{p}{;}
            \PYG{n}{cerr} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Attempt }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{i} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ failed...}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
            \PYG{n}{cerr} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ERROR\PYGZus{}SQL\PYGZus{}008: Cannot complete SQL transaction. Check memory database assignment and SQL }\PYG{l+s}{\PYGZdq{}}
                    \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{commands. Ensure SQL statements are properly cleared.}\PYG{l+s}{\PYGZdq{}}
                 \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
    \PYG{p}{\PYGZcb{}}
    \PYG{c+c1}{// Need to finalise the statement}
    \PYG{n}{rc} \PYG{o}{=} \PYG{n}{sqlite3\PYGZus{}finalize}\PYG{p}{(}\PYG{n}{stmt}\PYG{p}{)}\PYG{p}{;}
    \PYG{k}{if}\PYG{p}{(}\PYG{n}{rc} \PYG{o}{!}\PYG{o}{=} \PYG{n}{SQLITE\PYGZus{}OK}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{cerr} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ERROR\PYGZus{}SQL\PYGZus{}008: Cannot complete SQL transaction. Check memory database assignment and SQL }\PYG{l+s}{\PYGZdq{}}
                \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{commands. Ensure SQL statements are properly cleared.}\PYG{l+s}{\PYGZdq{}}
             \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
        \PYG{n}{cerr} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Error code: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{rc} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{c+c1}{// Vacuum the file so that the file size is reduced (reduces by around 3\PYGZpc{})}
    \PYG{n}{rc} \PYG{o}{=} \PYG{n}{sqlite3\PYGZus{}exec}\PYG{p}{(}\PYG{n}{database}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{VACUUM;}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{k}{nullptr}\PYG{p}{,} \PYG{k}{nullptr}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{sErrMsg}\PYG{p}{)}\PYG{p}{;}
    \PYG{k}{if}\PYG{p}{(}\PYG{n}{rc} \PYG{o}{!}\PYG{o}{=} \PYG{n}{SQLITE\PYGZus{}OK}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{cerr} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ERROR\PYGZus{}SQL\PYGZus{}014: Cannot vacuum the database. Error message: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{sErrMsg} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{n}{sqlCreateSimulationParameters}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{writeInfo}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{done!}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{void} \PYG{n}{Tree}\PYG{o}{:}\PYG{o}{:}\PYG{n}{sqlCreateSimulationParameters}\PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k+kt}{char}\PYG{o}{*} \PYG{n}{sErrMsg}\PYG{p}{;}
\PYG{c+c1}{// Now additionally store the simulation parameters (extremely useful data)}
    \PYG{n}{string} \PYG{n}{to\PYGZus{}execute} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{CREATE TABLE SIMULATION\PYGZus{}PARAMETERS (seed INT PRIMARY KEY not null, job\PYGZus{}type INT NOT NULL,}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
    \PYG{n}{to\PYGZus{}execute} \PYG{o}{+}\PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{output\PYGZus{}dir TEXT NOT NULL, speciation\PYGZus{}rate DOUBLE NOT NULL, sigma DOUBLE NOT NULL,tau DOUBLE NOT }\PYG{l+s}{\PYGZdq{}}
            \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{NULL, deme INT NOT NULL, }\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
    \PYG{n}{to\PYGZus{}execute} \PYG{o}{+}\PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{sample\PYGZus{}size DOUBLE NOT NULL, max\PYGZus{}time INT NOT NULL, dispersal\PYGZus{}relative\PYGZus{}cost DOUBLE NOT NULL, }\PYG{l+s}{\PYGZdq{}}
            \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{min\PYGZus{}num\PYGZus{}species }\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
    \PYG{n}{to\PYGZus{}execute} \PYG{o}{+}\PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{INT NOT NULL, habitat\PYGZus{}change\PYGZus{}rate DOUBLE NOT NULL, gen\PYGZus{}since\PYGZus{}pristine DOUBLE NOT NULL, }\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
    \PYG{n}{to\PYGZus{}execute} \PYG{o}{+}\PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{time\PYGZus{}config\PYGZus{}file TEXT NOT NULL, coarse\PYGZus{}map\PYGZus{}file TEXT NOT NULL, coarse\PYGZus{}map\PYGZus{}x INT NOT NULL, }\PYG{l+s}{\PYGZdq{}}
            \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{coarse\PYGZus{}map\PYGZus{}y INT NOT NULL,}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
    \PYG{n}{to\PYGZus{}execute} \PYG{o}{+}\PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{coarse\PYGZus{}map\PYGZus{}x\PYGZus{}offset INT NOT NULL, coarse\PYGZus{}map\PYGZus{}y\PYGZus{}offset INT NOT NULL, coarse\PYGZus{}map\PYGZus{}scale DOUBLE NOT }\PYG{l+s}{\PYGZdq{}}
            \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{NULL, fine\PYGZus{}map\PYGZus{}file TEXT NOT NULL, fine\PYGZus{}map\PYGZus{}x INT NOT NULL,}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
    \PYG{n}{to\PYGZus{}execute} \PYG{o}{+}\PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{fine\PYGZus{}map\PYGZus{}y INT NOT NULL, fine\PYGZus{}map\PYGZus{}x\PYGZus{}offset INT NOT NULL, fine\PYGZus{}map\PYGZus{}y\PYGZus{}offset INT NOT NULL, }\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
    \PYG{n}{to\PYGZus{}execute} \PYG{o}{+}\PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{sample\PYGZus{}file TEXT NOT NULL, grid\PYGZus{}x INT NOT NULL, grid\PYGZus{}y INT NOT NULL, sample\PYGZus{}x INT NOT NULL, }\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
    \PYG{n}{to\PYGZus{}execute} \PYG{o}{+}\PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{sample\PYGZus{}y INT NOT NULL, sample\PYGZus{}x\PYGZus{}offset INT NOT NULL, sample\PYGZus{}y\PYGZus{}offset INT NOT NULL, }\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
    \PYG{n}{to\PYGZus{}execute} \PYG{o}{+}\PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{pristine\PYGZus{}coarse\PYGZus{}map TEXT NOT NULL, pristine\PYGZus{}fine\PYGZus{}map TEXT NOT NULL, sim\PYGZus{}complete INT NOT NULL, }\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
    \PYG{n}{to\PYGZus{}execute} \PYG{o}{+}\PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{dispersal\PYGZus{}method TEXT NOT NULL, m\PYGZus{}probability DOUBLE NOT NULL, cutoff DOUBLE NOT NULL, }\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
    \PYG{n}{to\PYGZus{}execute} \PYG{o}{+}\PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{restrict\PYGZus{}self INT NOT NULL, infinite\PYGZus{}landscape TEXT NOT NULL, protracted INT NOT NULL, }\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
    \PYG{n}{to\PYGZus{}execute} \PYG{o}{+}\PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{min\PYGZus{}speciation\PYGZus{}gen DOUBLE NOT NULL, max\PYGZus{}speciation\PYGZus{}gen DOUBLE NOT NULL, dispersal\PYGZus{}map TEXT NOT NULL);}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
    \PYG{k+kt}{int} \PYG{n}{rc} \PYG{o}{=} \PYG{n}{sqlite3\PYGZus{}exec}\PYG{p}{(}\PYG{n}{database}\PYG{p}{,} \PYG{n}{to\PYGZus{}execute}\PYG{p}{.}\PYG{n}{c\PYGZus{}str}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{k}{nullptr}\PYG{p}{,} \PYG{k}{nullptr}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{sErrMsg}\PYG{p}{)}\PYG{p}{;}
    \PYG{k}{if}\PYG{p}{(}\PYG{n}{rc} \PYG{o}{!}\PYG{o}{=} \PYG{n}{SQLITE\PYGZus{}OK}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{cerr} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ERROR\PYGZus{}SQL\PYGZus{}008: Cannot start SQL transaction. Check memory database assignment and SQL commands.}\PYG{l+s}{\PYGZdq{}}
             \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
        \PYG{n}{cerr} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Error code: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{rc} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{n}{to\PYGZus{}execute} \PYG{o}{=} \PYG{n}{simulationParametersSqlInsertion}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{rc} \PYG{o}{=} \PYG{n}{sqlite3\PYGZus{}exec}\PYG{p}{(}\PYG{n}{database}\PYG{p}{,} \PYG{n}{to\PYGZus{}execute}\PYG{p}{.}\PYG{n}{c\PYGZus{}str}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{k}{nullptr}\PYG{p}{,} \PYG{k}{nullptr}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{sErrMsg}\PYG{p}{)}\PYG{p}{;}
    \PYG{k}{if}\PYG{p}{(}\PYG{n}{rc} \PYG{o}{!}\PYG{o}{=} \PYG{n}{SQLITE\PYGZus{}OK}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{stringstream} \PYG{n}{os}\PYG{p}{;}
        \PYG{n}{os} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ERROR\PYGZus{}SQL\PYGZus{}008: Cannot start SQL transaction. Check memory database assignment and SQL commands.}\PYG{l+s}{\PYGZdq{}}
           \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
        \PYG{n}{os} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Error code: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{rc} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
        \PYG{n}{writeWarning}\PYG{p}{(}\PYG{n}{os}\PYG{p}{.}\PYG{n}{str}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}

\PYG{n}{string} \PYG{n}{Tree}\PYG{o}{:}\PYG{o}{:}\PYG{n}{simulationParametersSqlInsertion}\PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{n}{string} \PYG{n}{to\PYGZus{}execute}\PYG{p}{;}
    \PYG{n}{to\PYGZus{}execute} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{INSERT INTO SIMULATION\PYGZus{}PARAMETERS VALUES(}\PYG{l+s}{\PYGZdq{}} \PYG{o}{+} \PYG{n}{to\PYGZus{}string}\PYG{p}{(}\PYG{p}{(}\PYG{k+kt}{long} \PYG{k+kt}{long}\PYG{p}{)}\PYG{n}{the\PYGZus{}seed}\PYG{p}{)} \PYG{o}{+} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{,}\PYG{l+s}{\PYGZdq{}} \PYG{o}{+}
                 \PYG{n}{to\PYGZus{}string}\PYG{p}{(}\PYG{p}{(}\PYG{k+kt}{long} \PYG{k+kt}{long}\PYG{p}{)}\PYG{n}{the\PYGZus{}task}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{to\PYGZus{}execute} \PYG{o}{+}\PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{,\PYGZsq{}}\PYG{l+s}{\PYGZdq{}} \PYG{o}{+} \PYG{n}{out\PYGZus{}directory} \PYG{o}{+} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZsq{},}\PYG{l+s}{\PYGZdq{}} \PYG{o}{+} \PYG{n}{boost}\PYG{o}{:}\PYG{o}{:}\PYG{n}{lexical\PYGZus{}cast}\PYG{o}{\PYGZlt{}}\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{string}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{p}{(}\PYG{k+kt}{long} \PYG{k+kt}{double}\PYG{p}{)}\PYG{n}{spec}\PYG{p}{)} \PYG{o}{+} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{,}\PYG{l+s}{\PYGZdq{}} \PYG{o}{+}
                  \PYG{n}{to\PYGZus{}string}\PYG{p}{(}\PYG{l+m+mf}{0.0}\PYG{p}{)} \PYG{o}{+} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{,}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
    \PYG{n}{to\PYGZus{}execute} \PYG{o}{+}\PYG{o}{=} \PYG{n}{to\PYGZus{}string}\PYG{p}{(}\PYG{l+m+mf}{0.0}\PYG{p}{)} \PYG{o}{+} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{,}\PYG{l+s}{\PYGZdq{}} \PYG{o}{+} \PYG{n}{to\PYGZus{}string}\PYG{p}{(}\PYG{p}{(}\PYG{k+kt}{long} \PYG{k+kt}{long}\PYG{p}{)}\PYG{n}{deme}\PYG{p}{)} \PYG{o}{+} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{,}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
    \PYG{n}{to\PYGZus{}execute} \PYG{o}{+}\PYG{o}{=} \PYG{n}{to\PYGZus{}string}\PYG{p}{(}\PYG{p}{(}\PYG{k+kt}{long} \PYG{k+kt}{double}\PYG{p}{)}\PYG{n}{deme\PYGZus{}sample}\PYG{p}{)} \PYG{o}{+} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{,}\PYG{l+s}{\PYGZdq{}} \PYG{o}{+} \PYG{n}{to\PYGZus{}string}\PYG{p}{(}\PYG{p}{(}\PYG{k+kt}{long} \PYG{k+kt}{long}\PYG{p}{)}\PYG{n}{maxtime}\PYG{p}{)} \PYG{o}{+} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{,}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
    \PYG{n}{to\PYGZus{}execute} \PYG{o}{+}\PYG{o}{=} \PYG{n}{to\PYGZus{}string}\PYG{p}{(}\PYG{l+m+mf}{0.0}\PYG{p}{)} \PYG{o}{+} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{,}\PYG{l+s}{\PYGZdq{}} \PYG{o}{+} \PYG{n}{to\PYGZus{}string}\PYG{p}{(}\PYG{l+m+mf}{0.0}\PYG{p}{)} \PYG{o}{+} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{,}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
    \PYG{n}{to\PYGZus{}execute} \PYG{o}{+}\PYG{o}{=} \PYG{n}{to\PYGZus{}string}\PYG{p}{(}\PYG{p}{(}\PYG{k+kt}{long} \PYG{k+kt}{double}\PYG{p}{)}\PYG{n}{sim\PYGZus{}parameters}\PYG{p}{.}\PYG{n}{habitat\PYGZus{}change\PYGZus{}rate}\PYG{p}{)} \PYG{o}{+} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{,}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
    \PYG{n}{to\PYGZus{}execute} \PYG{o}{+}\PYG{o}{=} \PYG{n}{to\PYGZus{}string}\PYG{p}{(}\PYG{p}{(}\PYG{k+kt}{long} \PYG{k+kt}{double}\PYG{p}{)}\PYG{n}{sim\PYGZus{}parameters}\PYG{p}{.}\PYG{n}{gen\PYGZus{}since\PYGZus{}pristine}\PYG{p}{)} \PYG{o}{+} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{,\PYGZsq{}}\PYG{l+s}{\PYGZdq{}} \PYG{o}{+} \PYG{n}{sim\PYGZus{}parameters}\PYG{p}{.}\PYG{n}{times\PYGZus{}file} \PYG{o}{+} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZsq{},\PYGZsq{}}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
    \PYG{n}{to\PYGZus{}execute} \PYG{o}{+}\PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{none\PYGZsq{}, 0, 0, 0, 0, 0, \PYGZsq{}null\PYGZsq{}, 0, 0, 0, 0, \PYGZsq{}none\PYGZsq{}, 1, 1, 1, 1, 0, 0, \PYGZsq{}none\PYGZsq{}, \PYGZsq{}none\PYGZsq{},}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
    \PYG{n}{to\PYGZus{}execute} \PYG{o}{+}\PYG{o}{=} \PYG{n}{to\PYGZus{}string}\PYG{p}{(}\PYG{n}{sim\PYGZus{}complete}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{to\PYGZus{}execute} \PYG{o}{+}\PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{, \PYGZsq{}none\PYGZsq{}, 0.0, 0, 0, \PYGZsq{}none\PYGZsq{}, }\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
    \PYG{c+c1}{// Now save the protracted speciation variables (not relevant in this simulation scenario)}
    \PYG{n}{to\PYGZus{}execute} \PYG{o}{+}\PYG{o}{=} \PYG{n}{protractedVarsToString}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{to\PYGZus{}execute} \PYG{o}{+}\PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{, \PYGZsq{}none\PYGZsq{});}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
    \PYG{k}{return} \PYG{n}{to\PYGZus{}execute}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{n}{string} \PYG{n}{Tree}\PYG{o}{:}\PYG{o}{:}\PYG{n}{protractedVarsToString}\PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{n}{string} \PYG{n}{tmp} \PYG{o}{=} \PYG{n}{to\PYGZus{}string}\PYG{p}{(}\PYG{n+nb}{false}\PYG{p}{)} \PYG{o}{+} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{, }\PYG{l+s}{\PYGZdq{}} \PYG{o}{+} \PYG{n}{to\PYGZus{}string}\PYG{p}{(}\PYG{l+m+mf}{0.0}\PYG{p}{)} \PYG{o}{+} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{, }\PYG{l+s}{\PYGZdq{}} \PYG{o}{+} \PYG{n}{to\PYGZus{}string}\PYG{p}{(}\PYG{l+m+mf}{0.0}\PYG{p}{)}\PYG{p}{;}
    \PYG{k}{return} \PYG{n}{tmp}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{void} \PYG{n}{Tree}\PYG{o}{:}\PYG{o}{:}\PYG{n}{simPause}\PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{c+c1}{// Completely changed how this sections works \PYGZhy{} it won\PYGZsq{}t currently allow restarting of the simulations, but will}
    \PYG{c+c1}{// dump the data file to memory. \PYGZhy{} simply calls sqlCreate and sqlOutput.}
    \PYG{c+c1}{// sqlCreate();}
    \PYG{c+c1}{// sqlOutput();}

    \PYG{c+c1}{// This function saves the data to 4 files. One contains the main simulation parameters, the other 3 contain the}
    \PYG{c+c1}{// simulation results thus far}
    \PYG{c+c1}{// including the grid object, data object and active object.}
    \PYG{n}{string} \PYG{n}{pause\PYGZus{}folder} \PYG{o}{=} \PYG{n}{initiatePause}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{dumpMain}\PYG{p}{(}\PYG{n}{pause\PYGZus{}folder}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{dumpActive}\PYG{p}{(}\PYG{n}{pause\PYGZus{}folder}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{dumpData}\PYG{p}{(}\PYG{n}{pause\PYGZus{}folder}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{completePause}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{n}{string} \PYG{n}{Tree}\PYG{o}{:}\PYG{o}{:}\PYG{n}{initiatePause}\PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{n}{stringstream} \PYG{n}{os}\PYG{p}{;}
    \PYG{n}{os} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Pausing simulation...}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Saving data to temp file in }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{out\PYGZus{}directory} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{/Pause/ ...}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{flush}\PYG{p}{;}
    \PYG{n}{writeInfo}\PYG{p}{(}\PYG{n}{os}\PYG{p}{.}\PYG{n}{str}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{os}\PYG{p}{.}\PYG{n}{str}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{ofstream} \PYG{n}{out}\PYG{p}{;}
    \PYG{n}{out}\PYG{p}{.}\PYG{n}{precision}\PYG{p}{(}\PYG{l+m+mi}{64}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{string} \PYG{n}{file\PYGZus{}to\PYGZus{}open}\PYG{p}{;}
    \PYG{c+c1}{// Create the pause directory}
    \PYG{n}{string} \PYG{n}{pause\PYGZus{}folder} \PYG{o}{=} \PYG{n}{out\PYGZus{}directory} \PYG{o}{+} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{/Pause/}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
    \PYG{n}{boost}\PYG{o}{:}\PYG{o}{:}\PYG{n}{filesystem}\PYG{o}{:}\PYG{o}{:}\PYG{n}{path} \PYG{n}{pause\PYGZus{}dir}\PYG{p}{(}\PYG{n}{pause\PYGZus{}folder}\PYG{p}{)}\PYG{p}{;}
    \PYG{k}{if}\PYG{p}{(}\PYG{o}{!}\PYG{n}{boost}\PYG{o}{:}\PYG{o}{:}\PYG{n}{filesystem}\PYG{o}{:}\PYG{o}{:}\PYG{n}{exists}\PYG{p}{(}\PYG{n}{pause\PYGZus{}dir}\PYG{p}{)}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{try}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{boost}\PYG{o}{:}\PYG{o}{:}\PYG{n}{filesystem}\PYG{o}{:}\PYG{o}{:}\PYG{n}{create\PYGZus{}directory}\PYG{p}{(}\PYG{n}{pause\PYGZus{}dir}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{catch}\PYG{p}{(}\PYG{n}{exception}\PYG{o}{\PYGZam{}} \PYG{n}{e}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{cerr} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Failure to create }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{out\PYGZus{}directory} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{/Pause/}\PYG{l+s}{\PYGZdq{}}
                 \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{.}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
            \PYG{n}{cerr} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{e}\PYG{p}{.}\PYG{n}{what}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
            \PYG{n}{cerr} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Writing directly to output directory.}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
            \PYG{n}{pause\PYGZus{}folder} \PYG{o}{=} \PYG{n}{out\PYGZus{}directory}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{return} \PYG{n}{pause\PYGZus{}folder}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{void} \PYG{n}{Tree}\PYG{o}{:}\PYG{o}{:}\PYG{n}{completePause}\PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{n}{stringstream} \PYG{n}{os}\PYG{p}{;}
    \PYG{n}{os} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{done!}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
    \PYG{n}{os} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{SQL dump started}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
    \PYG{n}{writeInfo}\PYG{p}{(}\PYG{n}{os}\PYG{p}{.}\PYG{n}{str}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{os}\PYG{p}{.}\PYG{n}{str}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{time}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{out\PYGZus{}finish}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{sqlCreate}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{sqlOutput}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{os} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Data dump complete}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
    \PYG{n}{writeInfo}\PYG{p}{(}\PYG{n}{os}\PYG{p}{.}\PYG{n}{str}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{time}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{sim\PYGZus{}end}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{writeTimes}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{void} \PYG{n}{Tree}\PYG{o}{:}\PYG{o}{:}\PYG{n}{dumpMain}\PYG{p}{(}\PYG{n}{string} \PYG{n}{pause\PYGZus{}folder}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k}{try}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{string} \PYG{n}{file\PYGZus{}to\PYGZus{}open} \PYG{o}{=} \PYG{n}{pause\PYGZus{}folder} \PYG{o}{+} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Dump\PYGZus{}main\PYGZus{}}\PYG{l+s}{\PYGZdq{}} \PYG{o}{+} \PYG{n}{to\PYGZus{}string}\PYG{p}{(}\PYG{n}{the\PYGZus{}task}\PYG{p}{)} \PYG{o}{+} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZus{}}\PYG{l+s}{\PYGZdq{}} \PYG{o}{+} \PYG{n}{to\PYGZus{}string}\PYG{p}{(}\PYG{n}{the\PYGZus{}seed}\PYG{p}{)} \PYG{o}{+} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{.csv}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
        \PYG{n}{ofstream} \PYG{n}{out}\PYG{p}{;}
        \PYG{n}{out}\PYG{p}{.}\PYG{n}{open}\PYG{p}{(}\PYG{n}{file\PYGZus{}to\PYGZus{}open}\PYG{p}{.}\PYG{n}{c\PYGZus{}str}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{out} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{setprecision}\PYG{p}{(}\PYG{l+m+mi}{64}\PYG{p}{)}\PYG{p}{;}
        \PYG{c+c1}{// Save that this simulation was not a protracted speciation sim}
        \PYG{n}{out} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{bIsProtracted} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
        \PYG{c+c1}{// Saving the initial data to one file.}
        \PYG{n}{out} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{enddata} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{seeded} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{the\PYGZus{}seed} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{the\PYGZus{}task} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{times\PYGZus{}file} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}
            \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{has\PYGZus{}times\PYGZus{}file} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
        \PYG{n}{out} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{sim\PYGZus{}parameters}\PYG{p}{.}\PYG{n}{fine\PYGZus{}map\PYGZus{}file} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{sim\PYGZus{}parameters}\PYG{p}{.}\PYG{n}{coarse\PYGZus{}map\PYGZus{}file} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{out\PYGZus{}directory} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
        \PYG{n}{out} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{sim\PYGZus{}parameters}\PYG{p}{.}\PYG{n}{pristine\PYGZus{}fine\PYGZus{}map\PYGZus{}file} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{sim\PYGZus{}parameters}\PYG{p}{.}\PYG{n}{pristine\PYGZus{}coarse\PYGZus{}map\PYGZus{}file} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
        \PYG{n}{out} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{sim\PYGZus{}parameters}\PYG{p}{.}\PYG{n}{gen\PYGZus{}since\PYGZus{}pristine} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{sim\PYGZus{}parameters}\PYG{p}{.}\PYG{n}{habitat\PYGZus{}change\PYGZus{}rate} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
        \PYG{n}{out} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{sim\PYGZus{}parameters}\PYG{p}{.}\PYG{n}{grid\PYGZus{}x\PYGZus{}size} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{sim\PYGZus{}parameters}\PYG{p}{.}\PYG{n}{grid\PYGZus{}y\PYGZus{}size} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
        \PYG{n}{out} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{sim\PYGZus{}parameters}\PYG{p}{.}\PYG{n}{fine\PYGZus{}map\PYGZus{}x\PYGZus{}size} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{sim\PYGZus{}parameters}\PYG{p}{.}\PYG{n}{fine\PYGZus{}map\PYGZus{}y\PYGZus{}size} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
        \PYG{n}{out} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{sim\PYGZus{}parameters}\PYG{p}{.}\PYG{n}{fine\PYGZus{}map\PYGZus{}x\PYGZus{}offset} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{sim\PYGZus{}parameters}\PYG{p}{.}\PYG{n}{fine\PYGZus{}map\PYGZus{}y\PYGZus{}offset} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
        \PYG{n}{out} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{sim\PYGZus{}parameters}\PYG{p}{.}\PYG{n}{coarse\PYGZus{}map\PYGZus{}x\PYGZus{}size} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{sim\PYGZus{}parameters}\PYG{p}{.}\PYG{n}{coarse\PYGZus{}map\PYGZus{}y\PYGZus{}size} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
        \PYG{n}{out} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{sim\PYGZus{}parameters}\PYG{p}{.}\PYG{n}{coarse\PYGZus{}map\PYGZus{}x\PYGZus{}offset} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{sim\PYGZus{}parameters}\PYG{p}{.}\PYG{n}{coarse\PYGZus{}map\PYGZus{}y\PYGZus{}offset} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
        \PYG{n}{out} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{sim\PYGZus{}parameters}\PYG{p}{.}\PYG{n}{coarse\PYGZus{}map\PYGZus{}scale} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{has\PYGZus{}imported\PYGZus{}vars} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{start} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{sim\PYGZus{}start}\PYG{p}{;}
        \PYG{n}{out} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{sim\PYGZus{}end} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{now} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{time\PYGZus{}taken} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{sim\PYGZus{}finish} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{out\PYGZus{}finish} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
        \PYG{n}{out} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endactive} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{startendactive} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{maxsimsize} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{steps} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
        \PYG{n}{out} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{generation} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{sim\PYGZus{}parameters}\PYG{p}{.}\PYG{n}{sigma} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{sim\PYGZus{}parameters}\PYG{p}{.}\PYG{n}{tau} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{maxtime} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
        \PYG{n}{out} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{deme\PYGZus{}sample} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{spec} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{sim\PYGZus{}parameters}\PYG{p}{.}\PYG{n}{dispersal\PYGZus{}relative\PYGZus{}cost} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{deme} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
        \PYG{n}{out} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{sim\PYGZus{}parameters}\PYG{p}{.}\PYG{n}{desired\PYGZus{}specnum} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{sqloutname} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{NR} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{sim\PYGZus{}parameters} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
        \PYG{c+c1}{// now output the protracted speciation variables (there should be two of these).}
        \PYG{n}{out} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{getProtractedVariables}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{out}\PYG{p}{.}\PYG{n}{close}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{catch}\PYG{p}{(}\PYG{n}{exception}\PYG{o}{\PYGZam{}} \PYG{n}{e}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{cerr} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{e}\PYG{p}{.}\PYG{n}{what}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
        \PYG{n}{cerr} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Failed to perform main dump to }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{pause\PYGZus{}folder} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{void} \PYG{n}{Tree}\PYG{o}{:}\PYG{o}{:}\PYG{n}{dumpActive}\PYG{p}{(}\PYG{n}{string} \PYG{n}{pause\PYGZus{}folder}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k}{try}
    \PYG{p}{\PYGZob{}}
        \PYG{c+c1}{// Output the active object}
        \PYG{n}{ofstream} \PYG{n}{out3}\PYG{p}{;}
        \PYG{n}{string} \PYG{n}{file\PYGZus{}to\PYGZus{}open} \PYG{o}{=} \PYG{n}{pause\PYGZus{}folder} \PYG{o}{+} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Dump\PYGZus{}active\PYGZus{}}\PYG{l+s}{\PYGZdq{}} \PYG{o}{+} \PYG{n}{to\PYGZus{}string}\PYG{p}{(}\PYG{n}{the\PYGZus{}task}\PYG{p}{)} \PYG{o}{+} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZus{}}\PYG{l+s}{\PYGZdq{}} \PYG{o}{+} \PYG{n}{to\PYGZus{}string}\PYG{p}{(}\PYG{n}{the\PYGZus{}seed}\PYG{p}{)} \PYG{o}{+} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{.csv}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
        \PYG{n}{out3} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{setprecision}\PYG{p}{(}\PYG{l+m+mi}{64}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{out3}\PYG{p}{.}\PYG{n}{open}\PYG{p}{(}\PYG{n}{file\PYGZus{}to\PYGZus{}open}\PYG{p}{.}\PYG{n}{c\PYGZus{}str}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{out3} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{active}\PYG{p}{;}
        \PYG{n}{out3}\PYG{p}{.}\PYG{n}{close}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{catch}\PYG{p}{(}\PYG{n}{exception}\PYG{o}{\PYGZam{}} \PYG{n}{e}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{cerr} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{e}\PYG{p}{.}\PYG{n}{what}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
        \PYG{n}{cerr} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Failed to perform active dump to }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{pause\PYGZus{}folder} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{void} \PYG{n}{Tree}\PYG{o}{:}\PYG{o}{:}\PYG{n}{dumpData}\PYG{p}{(}\PYG{n}{string} \PYG{n}{pause\PYGZus{}folder}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k}{try}
    \PYG{p}{\PYGZob{}}
        \PYG{c+c1}{// Output the data object}
        \PYG{n}{ofstream} \PYG{n}{out4}\PYG{p}{;}
        \PYG{n}{string} \PYG{n}{file\PYGZus{}to\PYGZus{}open} \PYG{o}{=} \PYG{n}{pause\PYGZus{}folder} \PYG{o}{+} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Dump\PYGZus{}data\PYGZus{}}\PYG{l+s}{\PYGZdq{}} \PYG{o}{+} \PYG{n}{to\PYGZus{}string}\PYG{p}{(}\PYG{n}{the\PYGZus{}task}\PYG{p}{)} \PYG{o}{+} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZus{}}\PYG{l+s}{\PYGZdq{}} \PYG{o}{+} \PYG{n}{to\PYGZus{}string}\PYG{p}{(}\PYG{n}{the\PYGZus{}seed}\PYG{p}{)} \PYG{o}{+} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{.csv}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
        \PYG{n}{out4} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{setprecision}\PYG{p}{(}\PYG{l+m+mi}{64}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{out4}\PYG{p}{.}\PYG{n}{open}\PYG{p}{(}\PYG{n}{file\PYGZus{}to\PYGZus{}open}\PYG{p}{.}\PYG{n}{c\PYGZus{}str}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{out4} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{data}\PYG{p}{;}
        \PYG{n}{out4}\PYG{p}{.}\PYG{n}{close}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{catch}\PYG{p}{(}\PYG{n}{exception}\PYG{o}{\PYGZam{}} \PYG{n}{e}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{cerr} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{e}\PYG{p}{.}\PYG{n}{what}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
        \PYG{n}{cerr} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Failed to perform data dump to }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{pause\PYGZus{}folder} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{void} \PYG{n}{Tree}\PYG{o}{:}\PYG{o}{:}\PYG{n}{setResumeParameters}\PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k}{if}\PYG{p}{(}\PYG{o}{!}\PYG{n}{has\PYGZus{}imported\PYGZus{}pause}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{pause\PYGZus{}sim\PYGZus{}directory} \PYG{o}{=} \PYG{n}{out\PYGZus{}directory}\PYG{p}{;}
        \PYG{n}{has\PYGZus{}imported\PYGZus{}pause} \PYG{o}{=} \PYG{n+nb}{true}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{void} \PYG{n}{Tree}\PYG{o}{:}\PYG{o}{:}\PYG{n}{setResumeParameters}\PYG{p}{(}
        \PYG{n}{string} \PYG{n}{pausedir}\PYG{p}{,} \PYG{n}{string} \PYG{n}{outdir}\PYG{p}{,} \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{seed}\PYG{p}{,} \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{task}\PYG{p}{,} \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{new\PYGZus{}max\PYGZus{}time}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k}{if}\PYG{p}{(}\PYG{o}{!}\PYG{n}{has\PYGZus{}imported\PYGZus{}pause}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{pause\PYGZus{}sim\PYGZus{}directory} \PYG{o}{=} \PYG{n}{move}\PYG{p}{(}\PYG{n}{pausedir}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{out\PYGZus{}directory} \PYG{o}{=} \PYG{n}{move}\PYG{p}{(}\PYG{n}{outdir}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{the\PYGZus{}seed} \PYG{o}{=} \PYG{k}{static\PYGZus{}cast}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{long} \PYG{k+kt}{long} \PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{n}{seed}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{the\PYGZus{}task} \PYG{o}{=} \PYG{k}{static\PYGZus{}cast}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{long} \PYG{k+kt}{long} \PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{n}{task}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{maxtime} \PYG{o}{=} \PYG{n}{new\PYGZus{}max\PYGZus{}time}\PYG{p}{;}
        \PYG{n}{has\PYGZus{}imported\PYGZus{}pause} \PYG{o}{=} \PYG{n+nb}{true}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{void} \PYG{n}{Tree}\PYG{o}{:}\PYG{o}{:}\PYG{n}{loadMainSave}\PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{n}{string} \PYG{n}{file\PYGZus{}to\PYGZus{}open}\PYG{p}{;}
    \PYG{k}{try}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{stringstream} \PYG{n}{os}\PYG{p}{;}
        \PYG{n}{os} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}r}\PYG{l+s}{Loading data from temp file...main...}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{flush}\PYG{p}{;}
        \PYG{n}{writeInfo}\PYG{p}{(}\PYG{n}{os}\PYG{p}{.}\PYG{n}{str}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{os}\PYG{p}{.}\PYG{n}{str}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{ifstream} \PYG{n}{in1}\PYG{p}{;}
        \PYG{n}{file\PYGZus{}to\PYGZus{}open} \PYG{o}{=} \PYG{n}{pause\PYGZus{}sim\PYGZus{}directory} \PYG{o}{+} \PYG{n}{string}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{/Pause/Dump\PYGZus{}main\PYGZus{}}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)} \PYG{o}{+} \PYG{n}{to\PYGZus{}string}\PYG{p}{(}\PYG{n}{the\PYGZus{}task}\PYG{p}{)} \PYG{o}{+} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZus{}}\PYG{l+s}{\PYGZdq{}} \PYG{o}{+}
                       \PYG{n}{to\PYGZus{}string}\PYG{p}{(}\PYG{n}{the\PYGZus{}seed}\PYG{p}{)} \PYG{o}{+} \PYG{n}{string}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{.csv}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{in1}\PYG{p}{.}\PYG{n}{open}\PYG{p}{(}\PYG{n}{file\PYGZus{}to\PYGZus{}open}\PYG{p}{)}\PYG{p}{;}
        \PYG{c+c1}{// Reading the initial data}
        \PYG{n}{string} \PYG{n}{string1}\PYG{p}{;}
        \PYG{c+c1}{// First read our boolean which just determines whether the simulation is a protracted simulation or not.}
        \PYG{c+c1}{// For these simulations, it should not be.}
        \PYG{k+kt}{bool} \PYG{n}{tmp}\PYG{p}{;}
        \PYG{n}{in1} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{tmp}\PYG{p}{;}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{tmp} \PYG{o}{!}\PYG{o}{=} \PYG{n}{getProtracted}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{k}{if}\PYG{p}{(}\PYG{n}{getProtracted}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{k}{throw} \PYG{n}{FatalException}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Paused simulation is not a protracted speciation simulation. }\PYG{l+s}{\PYGZdq{}}
                                              \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Cannot be resumed by this program. Please report this bug}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
            \PYG{k}{else}
            \PYG{p}{\PYGZob{}}
                \PYG{k}{throw} \PYG{n}{FatalException}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Paused simulation is a protracted speciation simulation. }\PYG{l+s}{\PYGZdq{}}
                                              \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Cannot be resumed by this program. Please report this bug}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
        \PYG{p}{\PYGZcb{}}
        \PYG{n}{in1} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{enddata} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{seeded} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{the\PYGZus{}seed} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{the\PYGZus{}task}\PYG{p}{;}
        \PYG{n}{in1}\PYG{p}{.}\PYG{n}{ignore}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{// Ignore the endline character}
        \PYG{n}{getline}\PYG{p}{(}\PYG{n}{in1}\PYG{p}{,} \PYG{n}{times\PYGZus{}file}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{in1} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{has\PYGZus{}times\PYGZus{}file}\PYG{p}{;}
        \PYG{n}{in1}\PYG{p}{.}\PYG{n}{ignore}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{getline}\PYG{p}{(}\PYG{n}{in1}\PYG{p}{,} \PYG{n}{sim\PYGZus{}parameters}\PYG{p}{.}\PYG{n}{fine\PYGZus{}map\PYGZus{}file}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{getline}\PYG{p}{(}\PYG{n}{in1}\PYG{p}{,} \PYG{n}{sim\PYGZus{}parameters}\PYG{p}{.}\PYG{n}{coarse\PYGZus{}map\PYGZus{}file}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{getline}\PYG{p}{(}\PYG{n}{in1}\PYG{p}{,} \PYG{n}{string1}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{getline}\PYG{p}{(}\PYG{n}{in1}\PYG{p}{,} \PYG{n}{sim\PYGZus{}parameters}\PYG{p}{.}\PYG{n}{pristine\PYGZus{}fine\PYGZus{}map\PYGZus{}file}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{getline}\PYG{p}{(}\PYG{n}{in1}\PYG{p}{,} \PYG{n}{sim\PYGZus{}parameters}\PYG{p}{.}\PYG{n}{pristine\PYGZus{}coarse\PYGZus{}map\PYGZus{}file}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{in1} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{sim\PYGZus{}parameters}\PYG{p}{.}\PYG{n}{gen\PYGZus{}since\PYGZus{}pristine} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{sim\PYGZus{}parameters}\PYG{p}{.}\PYG{n}{habitat\PYGZus{}change\PYGZus{}rate} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{sim\PYGZus{}parameters}\PYG{p}{.}\PYG{n}{grid\PYGZus{}x\PYGZus{}size}\PYG{p}{;}
        \PYG{n}{in1} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{sim\PYGZus{}parameters}\PYG{p}{.}\PYG{n}{grid\PYGZus{}y\PYGZus{}size} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{sim\PYGZus{}parameters}\PYG{p}{.}\PYG{n}{fine\PYGZus{}map\PYGZus{}x\PYGZus{}size} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{sim\PYGZus{}parameters}\PYG{p}{.}\PYG{n}{fine\PYGZus{}map\PYGZus{}y\PYGZus{}size}\PYG{p}{;}
        \PYG{n}{in1} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{sim\PYGZus{}parameters}\PYG{p}{.}\PYG{n}{fine\PYGZus{}map\PYGZus{}x\PYGZus{}offset} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{sim\PYGZus{}parameters}\PYG{p}{.}\PYG{n}{fine\PYGZus{}map\PYGZus{}y\PYGZus{}offset} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{sim\PYGZus{}parameters}\PYG{p}{.}\PYG{n}{coarse\PYGZus{}map\PYGZus{}x\PYGZus{}size}\PYG{p}{;}
        \PYG{n}{in1} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{sim\PYGZus{}parameters}\PYG{p}{.}\PYG{n}{coarse\PYGZus{}map\PYGZus{}y\PYGZus{}size} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{sim\PYGZus{}parameters}\PYG{p}{.}\PYG{n}{coarse\PYGZus{}map\PYGZus{}x\PYGZus{}offset}\PYG{p}{;}
        \PYG{k+kt}{time\PYGZus{}t} \PYG{n}{tmp\PYGZus{}time}\PYG{p}{;}
        \PYG{n}{in1} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{sim\PYGZus{}parameters}\PYG{p}{.}\PYG{n}{coarse\PYGZus{}map\PYGZus{}y\PYGZus{}offset} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{sim\PYGZus{}parameters}\PYG{p}{.}\PYG{n}{coarse\PYGZus{}map\PYGZus{}scale} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{has\PYGZus{}imported\PYGZus{}vars} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{tmp\PYGZus{}time}\PYG{p}{;}
        \PYG{n}{in1} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{sim\PYGZus{}start} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{sim\PYGZus{}end} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{now}\PYG{p}{;}
        \PYG{n}{in1} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{time\PYGZus{}taken} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{sim\PYGZus{}finish} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{out\PYGZus{}finish} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{endactive} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{startendactive} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{maxsimsize} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{steps}\PYG{p}{;}
        \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{tempmaxtime} \PYG{o}{=} \PYG{n}{maxtime}\PYG{p}{;}
        \PYG{n}{in1} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{generation} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{sim\PYGZus{}parameters}\PYG{p}{.}\PYG{n}{sigma} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{sim\PYGZus{}parameters}\PYG{p}{.}\PYG{n}{tau} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{maxtime}\PYG{p}{;}
        \PYG{n}{has\PYGZus{}imported\PYGZus{}vars} \PYG{o}{=} \PYG{n+nb}{false}\PYG{p}{;}
        \PYG{n}{in1} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{deme\PYGZus{}sample} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{spec} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{sim\PYGZus{}parameters}\PYG{p}{.}\PYG{n}{dispersal\PYGZus{}relative\PYGZus{}cost} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{deme}\PYG{p}{;}
        \PYG{n}{in1} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{sim\PYGZus{}parameters}\PYG{p}{.}\PYG{n}{desired\PYGZus{}specnum}\PYG{p}{;}
        \PYG{n}{in1}\PYG{p}{.}\PYG{n}{ignore}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{getline}\PYG{p}{(}\PYG{n}{in1}\PYG{p}{,} \PYG{n}{sqloutname}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{in1} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{NR}\PYG{p}{;}
        \PYG{n}{in1}\PYG{p}{.}\PYG{n}{ignore}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{in1} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{sim\PYGZus{}parameters}\PYG{p}{;}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{maxtime} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{sim\PYGZus{}parameters}\PYG{p}{.}\PYG{n}{max\PYGZus{}time} \PYG{o}{=} \PYG{n}{tempmaxtime}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifdef DEBUG}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{max\PYGZus{}time} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{0} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{n}{tempmaxtime} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{k}{throw} \PYG{n}{FatalException}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Time set to 0 on resume!}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif}
        \PYG{n}{NR}\PYG{p}{.}\PYG{n}{setDispersalMethod}\PYG{p}{(}\PYG{n}{sim\PYGZus{}parameters}\PYG{p}{.}\PYG{n}{dispersal\PYGZus{}method}\PYG{p}{,} \PYG{n}{sim\PYGZus{}parameters}\PYG{p}{.}\PYG{n}{m\PYGZus{}prob}\PYG{p}{,} \PYG{n}{sim\PYGZus{}parameters}\PYG{p}{.}\PYG{n}{cutoff}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{has\PYGZus{}imported\PYGZus{}pause}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{sim\PYGZus{}parameters}\PYG{p}{.}\PYG{n}{output\PYGZus{}directory} \PYG{o}{=} \PYG{n}{out\PYGZus{}directory}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{n}{setParameters}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
        \PYG{k+kt}{double} \PYG{n}{tmp1}\PYG{p}{,} \PYG{n}{tmp2}\PYG{p}{;}
        \PYG{n}{in1} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{tmp1} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{tmp2}\PYG{p}{;}
        \PYG{n}{setProtractedVariables}\PYG{p}{(}\PYG{n}{tmp1}\PYG{p}{,} \PYG{n}{tmp2}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{in1}\PYG{p}{.}\PYG{n}{close}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{try}
        \PYG{p}{\PYGZob{}}
            \PYG{k}{if}\PYG{p}{(}\PYG{n}{times\PYGZus{}file} \PYG{o}{=}\PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{null}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{k}{if}\PYG{p}{(}\PYG{n}{has\PYGZus{}times\PYGZus{}file}\PYG{p}{)}
                \PYG{p}{\PYGZob{}}
                    \PYG{k}{throw} \PYG{n}{runtime\PYGZus{}error}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{has\PYGZus{}times\PYGZus{}file should not be true}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
                \PYG{p}{\PYGZcb{}}
            \PYG{p}{\PYGZcb{}}
            \PYG{k}{else}
            \PYG{p}{\PYGZob{}}
                \PYG{k}{if}\PYG{p}{(}\PYG{o}{!}\PYG{n}{has\PYGZus{}times\PYGZus{}file}\PYG{p}{)}
                \PYG{p}{\PYGZob{}}
                    \PYG{k}{throw} \PYG{n}{runtime\PYGZus{}error}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{has\PYGZus{}times\PYGZus{}file should not be false}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
                \PYG{p}{\PYGZcb{}}
                \PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{n}{string}\PYG{o}{\PYGZgt{}} \PYG{n}{tmpimport}\PYG{p}{;}
                \PYG{n}{ConfigOption} \PYG{n}{tmpconfig}\PYG{p}{;}
                \PYG{n}{tmpconfig}\PYG{p}{.}\PYG{n}{setConfig}\PYG{p}{(}\PYG{n}{times\PYGZus{}file}\PYG{p}{,} \PYG{n+nb}{false}\PYG{p}{)}\PYG{p}{;}
                \PYG{n}{tmpconfig}\PYG{p}{.}\PYG{n}{importConfig}\PYG{p}{(}\PYG{n}{tmpimport}\PYG{p}{)}\PYG{p}{;}
                \PYG{k}{for}\PYG{p}{(}\PYG{k}{const} \PYG{k}{auto} \PYG{o}{\PYGZam{}}\PYG{n+nl}{i} \PYG{p}{:} \PYG{n}{tmpimport}\PYG{p}{)}
                \PYG{p}{\PYGZob{}}
                    \PYG{n}{reference\PYGZus{}times}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{n}{stod}\PYG{p}{(}\PYG{n}{i}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
                    \PYG{c+c1}{//                  os \PYGZlt{}\PYGZlt{} \PYGZdq{}t\PYGZus{}i: \PYGZdq{} \PYGZlt{}\PYGZlt{} reference\PYGZus{}times[i] \PYGZlt{}\PYGZlt{} endl;}
                \PYG{p}{\PYGZcb{}}
            \PYG{p}{\PYGZcb{}}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{catch}\PYG{p}{(}\PYG{n}{ConfigException}\PYG{o}{\PYGZam{}} \PYG{n}{ce}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{cerr} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{ce}\PYG{p}{.}\PYG{n}{what}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{catch}\PYG{p}{(}\PYG{n}{exception}\PYG{o}{\PYGZam{}} \PYG{n}{e}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{string} \PYG{n}{msg}\PYG{p}{;}
        \PYG{n}{msg} \PYG{o}{=} \PYG{n}{string}\PYG{p}{(}\PYG{n}{e}\PYG{p}{.}\PYG{n}{what}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)} \PYG{o}{+} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Failure to import parameters from }\PYG{l+s}{\PYGZdq{}} \PYG{o}{+} \PYG{n}{file\PYGZus{}to\PYGZus{}open}\PYG{p}{;}
        \PYG{k}{throw} \PYG{n+nf}{FatalException}\PYG{p}{(}\PYG{n}{msg}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{void} \PYG{n}{Tree}\PYG{o}{:}\PYG{o}{:}\PYG{n}{loadDataSave}\PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{n}{string} \PYG{n}{file\PYGZus{}to\PYGZus{}open}\PYG{p}{;}
    \PYG{c+c1}{// Input the data object}
    \PYG{k}{try}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{stringstream} \PYG{n}{os}\PYG{p}{;}
        \PYG{n}{os} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}r}\PYG{l+s}{Loading data from temp file...data...}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{flush}\PYG{p}{;}
        \PYG{n}{writeInfo}\PYG{p}{(}\PYG{n}{os}\PYG{p}{.}\PYG{n}{str}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{ifstream} \PYG{n}{in4}\PYG{p}{;}
        \PYG{c+c1}{//      sprintf(file\PYGZus{}to\PYGZus{}open,\PYGZdq{}\PYGZpc{}s/Pause/Data\PYGZus{}\PYGZpc{}i\PYGZus{}data.csv\PYGZdq{},out\PYGZus{}directory,int(the\PYGZus{}task));}
        \PYG{n}{file\PYGZus{}to\PYGZus{}open} \PYG{o}{=} \PYG{n}{pause\PYGZus{}sim\PYGZus{}directory} \PYG{o}{+} \PYG{n}{string}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{/Pause/Dump\PYGZus{}data\PYGZus{}}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)} \PYG{o}{+} \PYG{n}{to\PYGZus{}string}\PYG{p}{(}\PYG{n}{the\PYGZus{}task}\PYG{p}{)} \PYG{o}{+} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZus{}}\PYG{l+s}{\PYGZdq{}} \PYG{o}{+}
                       \PYG{n}{to\PYGZus{}string}\PYG{p}{(}\PYG{n}{the\PYGZus{}seed}\PYG{p}{)} \PYG{o}{+} \PYG{n}{string}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{.csv}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{in4}\PYG{p}{.}\PYG{n}{open}\PYG{p}{(}\PYG{n}{file\PYGZus{}to\PYGZus{}open}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{in4} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{data}\PYG{p}{;}
        \PYG{c+c1}{//          os \PYGZlt{}\PYGZlt{} data[0] \PYGZlt{}\PYGZlt{} endl;}
        \PYG{c+c1}{//          os \PYGZlt{}\PYGZlt{} data[1] \PYGZlt{}\PYGZlt{} endl;}
        \PYG{n}{in4}\PYG{p}{.}\PYG{n}{close}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{catch}\PYG{p}{(}\PYG{n}{exception}\PYG{o}{\PYGZam{}} \PYG{n}{e}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{string} \PYG{n}{msg}\PYG{p}{;}
        \PYG{n}{msg} \PYG{o}{=} \PYG{n}{string}\PYG{p}{(}\PYG{n}{e}\PYG{p}{.}\PYG{n}{what}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)} \PYG{o}{+} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Failure to import data from }\PYG{l+s}{\PYGZdq{}} \PYG{o}{+} \PYG{n}{file\PYGZus{}to\PYGZus{}open}\PYG{p}{;}
        \PYG{k}{throw} \PYG{n+nf}{FatalException}\PYG{p}{(}\PYG{n}{msg}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{void} \PYG{n}{Tree}\PYG{o}{:}\PYG{o}{:}\PYG{n}{loadActiveSave}\PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{n}{string} \PYG{n}{file\PYGZus{}to\PYGZus{}open}\PYG{p}{;}
    \PYG{k}{try}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{stringstream} \PYG{n}{os}\PYG{p}{;}
        \PYG{n}{os} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}r}\PYG{l+s}{Loading data from temp file...active...}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{flush}\PYG{p}{;}
        \PYG{n}{writeInfo}\PYG{p}{(}\PYG{n}{os}\PYG{p}{.}\PYG{n}{str}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
        \PYG{c+c1}{// Input the active object}
        \PYG{n}{ifstream} \PYG{n}{in3}\PYG{p}{;}
        \PYG{n}{file\PYGZus{}to\PYGZus{}open} \PYG{o}{=} \PYG{n}{pause\PYGZus{}sim\PYGZus{}directory} \PYG{o}{+} \PYG{n}{string}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{/Pause/Dump\PYGZus{}active\PYGZus{}}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)} \PYG{o}{+} \PYG{n}{to\PYGZus{}string}\PYG{p}{(}\PYG{n}{the\PYGZus{}task}\PYG{p}{)} \PYG{o}{+} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZus{}}\PYG{l+s}{\PYGZdq{}} \PYG{o}{+}
                       \PYG{n}{to\PYGZus{}string}\PYG{p}{(}\PYG{n}{the\PYGZus{}seed}\PYG{p}{)} \PYG{o}{+} \PYG{n}{string}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{.csv}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{in3}\PYG{p}{.}\PYG{n}{open}\PYG{p}{(}\PYG{n}{file\PYGZus{}to\PYGZus{}open}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{in3} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{active}\PYG{p}{;}
        \PYG{n}{in3}\PYG{p}{.}\PYG{n}{close}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{catch}\PYG{p}{(}\PYG{n}{exception}\PYG{o}{\PYGZam{}} \PYG{n}{e}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{string} \PYG{n}{msg}\PYG{p}{;}
        \PYG{n}{msg} \PYG{o}{=} \PYG{n}{string}\PYG{p}{(}\PYG{n}{e}\PYG{p}{.}\PYG{n}{what}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)} \PYG{o}{+} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Failure to import active from }\PYG{l+s}{\PYGZdq{}} \PYG{o}{+} \PYG{n}{file\PYGZus{}to\PYGZus{}open}\PYG{p}{;}
        \PYG{k}{throw} \PYG{n+nf}{FatalException}\PYG{p}{(}\PYG{n}{msg}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{void} \PYG{n}{Tree}\PYG{o}{:}\PYG{o}{:}\PYG{n}{initiateResume}\PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{c+c1}{// Start the timer}
    \PYG{c+c1}{// Only resume the simulation if there is a simulation to resume from.}
    \PYG{k}{if}\PYG{p}{(}\PYG{o}{!}\PYG{n}{has\PYGZus{}paused}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{return}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{n}{time}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{start}\PYG{p}{)}\PYG{p}{;}
    \PYG{c+c1}{// Loads the data from the files into the relevant objects.}
    \PYG{n}{stringstream} \PYG{n}{os}\PYG{p}{;}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifdef DEBUG}
    \PYG{n}{writeLog}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Paused directory: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{+} \PYG{n}{pause\PYGZus{}sim\PYGZus{}directory}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{writeLog}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Output directory: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{+} \PYG{n}{out\PYGZus{}directory}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{writeLog}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Seed: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{+} \PYG{n}{to\PYGZus{}string}\PYG{p}{(}\PYG{n}{the\PYGZus{}seed}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{writeLog}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Task: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{+} \PYG{n}{to\PYGZus{}string}\PYG{p}{(}\PYG{n}{the\PYGZus{}task}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{writeLog}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Max time: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{+} \PYG{n}{to\PYGZus{}string}\PYG{p}{(}\PYG{n}{max\PYGZus{}time}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif }\PYG{c+c1}{// DEBUG}
    \PYG{n}{os} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Resuming simulation...}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Loading data from temp file...}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{flush}\PYG{p}{;}
    \PYG{n}{writeInfo}\PYG{p}{(}\PYG{n}{os}\PYG{p}{.}\PYG{n}{str}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{os}\PYG{p}{.}\PYG{n}{str}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}

\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{void} \PYG{n}{Tree}\PYG{o}{:}\PYG{o}{:}\PYG{n}{simResume}\PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{n}{initiateResume}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
    \PYG{c+c1}{// now load the objects}
    \PYG{n}{loadMainSave}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{setObjectSizes}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{loadActiveSave}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{loadDataSave}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{time}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{sim\PYGZus{}start}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{writeInfo}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}r}\PYG{l+s}{Loading data from temp file...done!}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifdef DEBUG}

\PYG{k+kt}{void} \PYG{n}{Tree}\PYG{o}{:}\PYG{o}{:}\PYG{n}{validateLineages}\PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k+kt}{bool} \PYG{n}{fail} \PYG{o}{=} \PYG{n+nb}{false}\PYG{p}{;}
    \PYG{n}{writeInfo}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{Starting lineage validation...}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{printed} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
    \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{endactive}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{stringstream} \PYG{n}{ss}\PYG{p}{;}
        \PYG{n}{DataPoint} \PYG{n}{tmp\PYGZus{}datapoint} \PYG{o}{=} \PYG{n}{active}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{;}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{tmp\PYGZus{}datapoint}\PYG{p}{.}\PYG{n}{getXwrap}\PYG{p}{(}\PYG{p}{)} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{0} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{n}{tmp\PYGZus{}datapoint}\PYG{p}{.}\PYG{n}{getYwrap}\PYG{p}{(}\PYG{p}{)} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{k}{if}\PYG{p}{(}\PYG{n}{tmp\PYGZus{}datapoint}\PYG{p}{.}\PYG{n}{getNwrap}\PYG{p}{(}\PYG{p}{)} \PYG{o}{!}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{n}{fail} \PYG{o}{=} \PYG{n+nb}{true}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{else}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{fail} \PYG{o}{=} \PYG{n+nb}{true}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{fail}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{ss} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{Failure in map expansion. Please report this bug.}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
            \PYG{n}{ss} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{active reference: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{i} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
            \PYG{n}{data}\PYG{p}{[}\PYG{n}{active}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getReference}\PYG{p}{(}\PYG{p}{)}\PYG{p}{]}\PYG{p}{.}\PYG{n}{logLineageInformation}\PYG{p}{(}\PYG{l+m+mi}{50}\PYG{p}{)}\PYG{p}{;}
            \PYG{k}{throw} \PYG{n+nf}{FatalException}\PYG{p}{(}\PYG{n}{ss}\PYG{p}{.}\PYG{n}{str}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
    \PYG{p}{\PYGZcb{}}
    \PYG{n}{writeInfo}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{done}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}


\PYG{k+kt}{void} \PYG{n}{Tree}\PYG{o}{:}\PYG{o}{:}\PYG{n}{debugEndStep}\PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k}{try}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{runChecks}\PYG{p}{(}\PYG{n}{this\PYGZus{}step}\PYG{p}{.}\PYG{n}{chosen}\PYG{p}{,} \PYG{n}{this\PYGZus{}step}\PYG{p}{.}\PYG{n}{coalchosen}\PYG{p}{)}\PYG{p}{;}
        \PYG{c+c1}{// runs the debug every 10,000 time steps}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{steps} \PYG{o}{\PYGZpc{}} \PYG{l+m+mi}{10000} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{n}{endactive}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{n}{runChecks}\PYG{p}{(}\PYG{n}{i}\PYG{p}{,} \PYG{n}{i}\PYG{p}{)}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
        \PYG{p}{\PYGZcb{}}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{catch}\PYG{p}{(}\PYG{n}{FatalException}\PYG{o}{\PYGZam{}} \PYG{n}{fe}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{writeLog}\PYG{p}{(}\PYG{l+m+mi}{50}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Logging chosen:}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{active}\PYG{p}{[}\PYG{n}{this\PYGZus{}step}\PYG{p}{.}\PYG{n}{chosen}\PYG{p}{]}\PYG{p}{.}\PYG{n}{logActive}\PYG{p}{(}\PYG{l+m+mi}{50}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{writeLog}\PYG{p}{(}\PYG{l+m+mi}{50}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Logging coalchosen}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{active}\PYG{p}{[}\PYG{n}{this\PYGZus{}step}\PYG{p}{.}\PYG{n}{coalchosen}\PYG{p}{]}\PYG{p}{.}\PYG{n}{logActive}\PYG{p}{(}\PYG{l+m+mi}{50}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{stringstream} \PYG{n}{ss}\PYG{p}{;}
        \PYG{n}{ss} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{dumping data file...}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
        \PYG{n}{sqlCreate}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifdef sql\PYGZus{}ram}
        \PYG{n}{sqlOutput}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif}
        \PYG{n}{ss} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{done!}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
        \PYG{n}{writeWarning}\PYG{p}{(}\PYG{n}{ss}\PYG{p}{.}\PYG{n}{str}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{throw} \PYG{n}{fe}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{void} \PYG{n}{Tree}\PYG{o}{:}\PYG{o}{:}\PYG{n}{debugCoalescence}\PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k}{if}\PYG{p}{(}\PYG{n}{this\PYGZus{}step}\PYG{p}{.}\PYG{n}{coalchosen} \PYG{o}{=}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{return}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{n}{stringstream} \PYG{n}{ss}\PYG{p}{;}
    \PYG{k}{if}\PYG{p}{(}\PYG{n}{active}\PYG{p}{[}\PYG{n}{this\PYGZus{}step}\PYG{p}{.}\PYG{n}{coalchosen}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getXpos}\PYG{p}{(}\PYG{p}{)} \PYG{o}{!}\PYG{o}{=} \PYG{n}{active}\PYG{p}{[}\PYG{n}{this\PYGZus{}step}\PYG{p}{.}\PYG{n}{chosen}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getXpos}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\textbar{}}\PYG{o}{\textbar{}}
       \PYG{n}{active}\PYG{p}{[}\PYG{n}{this\PYGZus{}step}\PYG{p}{.}\PYG{n}{coalchosen}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getYpos}\PYG{p}{(}\PYG{p}{)} \PYG{o}{!}\PYG{o}{=} \PYG{n}{active}\PYG{p}{[}\PYG{n}{this\PYGZus{}step}\PYG{p}{.}\PYG{n}{chosen}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getYpos}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\textbar{}}\PYG{o}{\textbar{}}
       \PYG{n}{active}\PYG{p}{[}\PYG{n}{this\PYGZus{}step}\PYG{p}{.}\PYG{n}{coalchosen}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getXwrap}\PYG{p}{(}\PYG{p}{)} \PYG{o}{!}\PYG{o}{=} \PYG{n}{active}\PYG{p}{[}\PYG{n}{this\PYGZus{}step}\PYG{p}{.}\PYG{n}{chosen}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getXwrap}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\textbar{}}\PYG{o}{\textbar{}}
       \PYG{n}{active}\PYG{p}{[}\PYG{n}{this\PYGZus{}step}\PYG{p}{.}\PYG{n}{coalchosen}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getYwrap}\PYG{p}{(}\PYG{p}{)} \PYG{o}{!}\PYG{o}{=} \PYG{n}{active}\PYG{p}{[}\PYG{n}{this\PYGZus{}step}\PYG{p}{.}\PYG{n}{chosen}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getYwrap}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{writeLog}\PYG{p}{(}\PYG{l+m+mi}{50}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Logging chosen: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{+} \PYG{n}{to\PYGZus{}string}\PYG{p}{(}\PYG{n}{this\PYGZus{}step}\PYG{p}{.}\PYG{n}{chosen}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{data}\PYG{p}{[}\PYG{n}{active}\PYG{p}{[}\PYG{n}{this\PYGZus{}step}\PYG{p}{.}\PYG{n}{chosen}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getReference}\PYG{p}{(}\PYG{p}{)}\PYG{p}{]}\PYG{p}{.}\PYG{n}{logLineageInformation}\PYG{p}{(}\PYG{l+m+mi}{50}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{writeLog}\PYG{p}{(}\PYG{l+m+mi}{50}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Logging coalchosen: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{+} \PYG{n}{to\PYGZus{}string}\PYG{p}{(}\PYG{n}{this\PYGZus{}step}\PYG{p}{.}\PYG{n}{coalchosen}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{data}\PYG{p}{[}\PYG{n}{active}\PYG{p}{[}\PYG{n}{this\PYGZus{}step}\PYG{p}{.}\PYG{n}{coalchosen}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getReference}\PYG{p}{(}\PYG{p}{)}\PYG{p}{]}\PYG{p}{.}\PYG{n}{logLineageInformation}\PYG{p}{(}\PYG{l+m+mi}{50}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{ss} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ERROR\PYGZus{}MOVE\PYGZus{}006: NON FATAL. Nwrap not set correctly. Check move programming function.}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
        \PYG{k}{throw} \PYG{n+nf}{FatalException}\PYG{p}{(}\PYG{n}{ss}\PYG{p}{.}\PYG{n}{str}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{if}\PYG{p}{(}\PYG{n}{active}\PYG{p}{[}\PYG{n}{this\PYGZus{}step}\PYG{p}{.}\PYG{n}{coalchosen}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getXpos}\PYG{p}{(}\PYG{p}{)} \PYG{o}{!}\PYG{o}{=} \PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{long}\PYG{p}{)}\PYG{n}{this\PYGZus{}step}\PYG{p}{.}\PYG{n}{oldx} \PYG{o}{\textbar{}}\PYG{o}{\textbar{}}
       \PYG{n}{active}\PYG{p}{[}\PYG{n}{this\PYGZus{}step}\PYG{p}{.}\PYG{n}{coalchosen}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getYpos}\PYG{p}{(}\PYG{p}{)} \PYG{o}{!}\PYG{o}{=} \PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{long}\PYG{p}{)}\PYG{n}{this\PYGZus{}step}\PYG{p}{.}\PYG{n}{oldy} \PYG{o}{\textbar{}}\PYG{o}{\textbar{}}
       \PYG{n}{active}\PYG{p}{[}\PYG{n}{this\PYGZus{}step}\PYG{p}{.}\PYG{n}{coalchosen}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getXwrap}\PYG{p}{(}\PYG{p}{)} \PYG{o}{!}\PYG{o}{=} \PYG{n}{this\PYGZus{}step}\PYG{p}{.}\PYG{n}{oldxwrap} \PYG{o}{\textbar{}}\PYG{o}{\textbar{}}
       \PYG{n}{active}\PYG{p}{[}\PYG{n}{this\PYGZus{}step}\PYG{p}{.}\PYG{n}{coalchosen}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getYwrap}\PYG{p}{(}\PYG{p}{)} \PYG{o}{!}\PYG{o}{=} \PYG{n}{this\PYGZus{}step}\PYG{p}{.}\PYG{n}{oldywrap}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{writeLog}\PYG{p}{(}\PYG{l+m+mi}{50}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Logging chosen: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{+} \PYG{n}{to\PYGZus{}string}\PYG{p}{(}\PYG{n}{this\PYGZus{}step}\PYG{p}{.}\PYG{n}{chosen}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{data}\PYG{p}{[}\PYG{n}{active}\PYG{p}{[}\PYG{n}{this\PYGZus{}step}\PYG{p}{.}\PYG{n}{chosen}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getReference}\PYG{p}{(}\PYG{p}{)}\PYG{p}{]}\PYG{p}{.}\PYG{n}{logLineageInformation}\PYG{p}{(}\PYG{l+m+mi}{50}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{writeLog}\PYG{p}{(}\PYG{l+m+mi}{50}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Logging coalchosen: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{+} \PYG{n}{to\PYGZus{}string}\PYG{p}{(}\PYG{n}{this\PYGZus{}step}\PYG{p}{.}\PYG{n}{coalchosen}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{data}\PYG{p}{[}\PYG{n}{active}\PYG{p}{[}\PYG{n}{this\PYGZus{}step}\PYG{p}{.}\PYG{n}{coalchosen}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getReference}\PYG{p}{(}\PYG{p}{)}\PYG{p}{]}\PYG{p}{.}\PYG{n}{logLineageInformation}\PYG{p}{(}\PYG{l+m+mi}{50}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{ss} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ERROR\PYGZus{}MOVE\PYGZus{}006: NON FATAL. Nwrap not set correctly. Check move programming function.}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
        \PYG{k}{throw} \PYG{n+nf}{FatalException}\PYG{p}{(}\PYG{n}{ss}\PYG{p}{.}\PYG{n}{str}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{void} \PYG{n}{Tree}\PYG{o}{:}\PYG{o}{:}\PYG{n}{runChecks}\PYG{p}{(}\PYG{k}{const} \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{chosen}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{coalchosen}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{n}{miniCheck}\PYG{p}{(}\PYG{n}{chosen}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{miniCheck}\PYG{p}{(}\PYG{n}{coalchosen}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{void} \PYG{n}{Tree}\PYG{o}{:}\PYG{o}{:}\PYG{n}{miniCheck}\PYG{p}{(}\PYG{k}{const} \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{chosen}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k}{if}\PYG{p}{(}\PYG{n}{chosen} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{return}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{if}\PYG{p}{(}\PYG{n}{active}\PYG{p}{[}\PYG{n}{chosen}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getReference}\PYG{p}{(}\PYG{p}{)} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{throw} \PYG{n}{FatalException}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Active reference should not be 0.}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{if}\PYG{p}{(}\PYG{n}{data}\PYG{p}{[}\PYG{n}{active}\PYG{p}{[}\PYG{n}{chosen}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getReference}\PYG{p}{(}\PYG{p}{)}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getParent}\PYG{p}{(}\PYG{p}{)} \PYG{o}{!}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{writeLog}\PYG{p}{(}\PYG{l+m+mi}{50}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Active: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{+} \PYG{n}{to\PYGZus{}string}\PYG{p}{(}\PYG{n}{chosen}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{data}\PYG{p}{[}\PYG{n}{active}\PYG{p}{[}\PYG{n}{chosen}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getReference}\PYG{p}{(}\PYG{p}{)}\PYG{p}{]}\PYG{p}{.}\PYG{n}{logLineageInformation}\PYG{p}{(}\PYG{l+m+mi}{50}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{throw} \PYG{n+nf}{FatalException}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Parent not set to 0 for active lineage.}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}


\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif }\PYG{c+c1}{// DEBUG}
\end{sphinxVerbatim}


\subsubsection{Detailed Description}
\label{\detokenize{api/file_necsim_Tree.cpp:detailed-description}}
Samuel Thompson
24/03/17
BSD-3 Licence.


\subsubsection{Includes}
\label{\detokenize{api/file_necsim_Tree.cpp:includes}}\begin{itemize}
\item {} 
\sphinxcode{Tree.h} ({\hyperref[\detokenize{api/file_necsim_ProtractedSpatialTree.h:file-necsim-protractedspatialtree-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File ProtractedSpatialTree.h}}}})

\end{itemize}


\subsection{File Tree.h}
\label{\detokenize{api/file_necsim_Tree.h:file-necsim-tree-h}}\label{\detokenize{api/file_necsim_Tree.h::doc}}\label{\detokenize{api/file_necsim_Tree.h:file-tree-h}}
Contains the {\hyperref[\detokenize{api/class_Tree:class-tree}]{\sphinxcrossref{\DUrole{std,std-ref}{Class Tree}}}} class implementation as the main simulation object for spatially-implicit coalescence simulations. Provides the basis for spatially-explicit versions in {\hyperref[\detokenize{api/class_SpatialTree:class-spatialtree}]{\sphinxcrossref{\DUrole{std,std-ref}{Class SpatialTree}}}}, and protracted speciation versions in {\hyperref[\detokenize{api/class_ProtractedTree:class-protractedtree}]{\sphinxcrossref{\DUrole{std,std-ref}{Class ProtractedTree}}}} and {\hyperref[\detokenize{api/class_ProtractedSpatialTree:class-protractedspatialtree}]{\sphinxcrossref{\DUrole{std,std-ref}{Class ProtractedSpatialTree}}}}.

\begin{sphinxShadowBox}
\sphinxstyletopictitle{Contents}
\begin{itemize}
\item {} 
\phantomsection\label{\detokenize{api/file_necsim_Tree.h:id1}}{\hyperref[\detokenize{api/file_necsim_Tree.h:definition-necsim-tree-h}]{\sphinxcrossref{Definition (\sphinxcode{necsim/Tree.h})}}}

\item {} 
\phantomsection\label{\detokenize{api/file_necsim_Tree.h:id2}}{\hyperref[\detokenize{api/file_necsim_Tree.h:detailed-description}]{\sphinxcrossref{Detailed Description}}}

\item {} 
\phantomsection\label{\detokenize{api/file_necsim_Tree.h:id3}}{\hyperref[\detokenize{api/file_necsim_Tree.h:includes}]{\sphinxcrossref{Includes}}}

\item {} 
\phantomsection\label{\detokenize{api/file_necsim_Tree.h:id4}}{\hyperref[\detokenize{api/file_necsim_Tree.h:included-by}]{\sphinxcrossref{Included By}}}

\item {} 
\phantomsection\label{\detokenize{api/file_necsim_Tree.h:id5}}{\hyperref[\detokenize{api/file_necsim_Tree.h:classes}]{\sphinxcrossref{Classes}}}

\item {} 
\phantomsection\label{\detokenize{api/file_necsim_Tree.h:id6}}{\hyperref[\detokenize{api/file_necsim_Tree.h:defines}]{\sphinxcrossref{Defines}}}

\end{itemize}
\end{sphinxShadowBox}


\subsubsection{Definition (\sphinxstyleliteralintitle{necsim/Tree.h})}
\label{\detokenize{api/file_necsim_Tree.h:definition-necsim-tree-h}}

\paragraph{Program Listing for File Tree.h}
\label{\detokenize{api/program_listing_file_necsim_Tree.h:program-listing-file-necsim-tree-h}}\label{\detokenize{api/program_listing_file_necsim_Tree.h::doc}}\label{\detokenize{api/program_listing_file_necsim_Tree.h:program-listing-for-file-tree-h}}\begin{itemize}
\item {} 
Return to documentation for {\hyperref[\detokenize{api/file_necsim_Tree.h:file-necsim-tree-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File Tree.h}}}}

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{// This file is part of NECSim project which is released under BSD\PYGZhy{}3 license.}
\PYG{c+c1}{// See file **LICENSE.txt** or visit https://opensource.org/licenses/BSD\PYGZhy{}3\PYGZhy{}Clause) for full license details.}

\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifndef TREE\PYGZus{}H}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define TREE\PYGZus{}H}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifndef sql\PYGZus{}ram}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define sql\PYGZus{}ram}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif}

\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}sqlite3.h\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZdq{}TreeNode.h\PYGZdq{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZdq{}Matrix.h\PYGZdq{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZdq{}SimParameters.h\PYGZdq{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZdq{}NRrand.h\PYGZdq{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZdq{}DataPoint.h\PYGZdq{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZdq{}Community.h\PYGZdq{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZdq{}Filesystem.h\PYGZdq{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZdq{}CustomExceptions.h\PYGZdq{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZdq{}Step.h\PYGZdq{}}

\PYG{k}{class} \PYG{n+nc}{Tree}
\PYG{p}{\PYGZob{}}
\PYG{k}{protected}\PYG{o}{:}
    \PYG{c+c1}{// storing the coalescence tree itself}
    \PYG{n}{Row}\PYG{o}{\PYGZlt{}}\PYG{n}{TreeNode}\PYG{o}{\PYGZgt{}} \PYG{n}{data}\PYG{p}{;}
    \PYG{c+c1}{// a reference for the last written point in data.}
    \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{enddata}\PYG{p}{;}
    \PYG{c+c1}{// Stores the command line parameters and parses the required information.}
    \PYG{n}{SimParameters} \PYG{n}{sim\PYGZus{}parameters}\PYG{p}{;}
    \PYG{c+c1}{// random number generator}
    \PYG{n}{NRrand} \PYG{n}{NR}\PYG{p}{;}
    \PYG{c+c1}{// Storing the speciation rates for later reference.}
    \PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{long} \PYG{k+kt}{double}\PYG{o}{\PYGZgt{}} \PYG{n}{speciation\PYGZus{}rates}\PYG{p}{;}
    \PYG{c+c1}{// flag for having set the simulation seed.}
    \PYG{k+kt}{bool} \PYG{n}{seeded}\PYG{p}{;}
    \PYG{c+c1}{// random seed}
    \PYG{k+kt}{long} \PYG{k+kt}{long} \PYG{n}{the\PYGZus{}seed}\PYG{p}{;}
    \PYG{c+c1}{// for file naming \PYGZhy{} good to know which task in a series is being executed here}
    \PYG{k+kt}{long} \PYG{k+kt}{long} \PYG{n}{the\PYGZus{}task}\PYG{p}{;}
    \PYG{c+c1}{// The map file containing the times that we want to expand the model and record all lineages again.}
    \PYG{c+c1}{// If this is null, has\PYGZus{}times\PYGZus{}file will be false and the vector will be empty.}
    \PYG{n}{string} \PYG{n}{times\PYGZus{}file}\PYG{p}{;}
    \PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{double}\PYG{o}{\PYGZgt{}} \PYG{n}{reference\PYGZus{}times}\PYG{p}{;}
    \PYG{c+c1}{// Set to true if we are recording at times other than the present day.}
    \PYG{k+kt}{bool} \PYG{n}{has\PYGZus{}times\PYGZus{}file}\PYG{p}{;}
    \PYG{c+c1}{// The time variables (for timing the simulation in real time)}
    \PYG{k+kt}{time\PYGZus{}t} \PYG{n}{start}\PYG{p}{,} \PYG{n}{sim\PYGZus{}start}\PYG{p}{,} \PYG{n}{sim\PYGZus{}end}\PYG{p}{,} \PYG{n}{now}\PYG{p}{,} \PYG{n}{sim\PYGZus{}finish}\PYG{p}{,} \PYG{n}{out\PYGZus{}finish}\PYG{p}{;}
    \PYG{k+kt}{time\PYGZus{}t} \PYG{n}{time\PYGZus{}taken}\PYG{p}{;}
    \PYG{c+c1}{// Active lineages stored as a row of datapoints}
    \PYG{n}{Row}\PYG{o}{\PYGZlt{}}\PYG{n}{DataPoint}\PYG{o}{\PYGZgt{}} \PYG{n}{active}\PYG{p}{;}
    \PYG{c+c1}{// Stores the point of the end of the active vector. 0 is reserved as null}
    \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{endactive}\PYG{p}{;}
    \PYG{c+c1}{// the maximum size of endactive}
    \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{startendactive}\PYG{p}{;}
    \PYG{c+c1}{// the maximum simulated number of individuals in the present day.}
    \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{maxsimsize}\PYG{p}{;}
    \PYG{c+c1}{// for create the link to the speciationcounter object which handles everything.}
    \PYG{n}{Community} \PYG{n}{community}\PYG{p}{;}
    \PYG{c+c1}{// This might need to be updated for simulations that have large changes in maximum population size over time.}
    \PYG{c+c1}{// number of simulation num\PYGZus{}steps}
    \PYG{k+kt}{long} \PYG{n}{steps}\PYG{p}{;}
    \PYG{c+c1}{// Maximum time to run for (in seconds)}
    \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{maxtime}\PYG{p}{;}
    \PYG{c+c1}{// number of generations passed,}
    \PYG{k+kt}{double} \PYG{n}{generation}\PYG{p}{;}
    \PYG{c+c1}{// The number of individuals per cell}
    \PYG{k+kt}{long} \PYG{n}{deme}\PYG{p}{;}
    \PYG{c+c1}{// The proportion of individuals to sample}
    \PYG{k+kt}{double} \PYG{n}{deme\PYGZus{}sample}\PYG{p}{;}
    \PYG{c+c1}{// the speciation rate}
    \PYG{k+kt}{long} \PYG{k+kt}{double} \PYG{n}{spec}\PYG{p}{;}
    \PYG{c+c1}{// Path to output directory}
    \PYG{n}{string} \PYG{n}{out\PYGZus{}directory}\PYG{p}{;}
    \PYG{c+c1}{// sqlite3 object that stores all the data}
    \PYG{n}{sqlite3} \PYG{o}{*}\PYG{n}{database}\PYG{p}{;}
    \PYG{c+c1}{// only set to true if the simulation has finished, otherwise will be false.}
    \PYG{k+kt}{bool} \PYG{n}{sim\PYGZus{}complete}\PYG{p}{;}
    \PYG{c+c1}{// set to true when variables are imported}
    \PYG{k+kt}{bool} \PYG{n}{has\PYGZus{}imported\PYGZus{}vars}\PYG{p}{;}
\PYG{c+c1}{// If sql database is written first to memory, then need another object to contain the in\PYGZhy{}memory database.}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifdef sql\PYGZus{}ram}
    \PYG{n}{sqlite3} \PYG{o}{*}\PYG{n}{outdatabase}\PYG{p}{;}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif}
    \PYG{c+c1}{// Create the step object that will be retained for the whole simulation.}
    \PYG{c+c1}{// Does not need saving on simulation pause.}
    \PYG{n}{Step} \PYG{n}{this\PYGZus{}step}\PYG{p}{;}
    \PYG{n}{string} \PYG{n}{sqloutname}\PYG{p}{;}
    \PYG{c+c1}{// If true, means the command\PYGZhy{}line imports were under the (deprecated) fullmode.}
    \PYG{k+kt}{bool} \PYG{n}{bFullmode}\PYG{p}{;}
    \PYG{c+c1}{// If true, the simulation is to be resumed.}
    \PYG{k+kt}{bool} \PYG{n}{bResume}\PYG{p}{;}
    \PYG{c+c1}{// If true, a config file contains the simulation variables.}
    \PYG{k+kt}{bool} \PYG{n}{bConfig}\PYG{p}{;}
    \PYG{c+c1}{// If true, simulation can be resumed.}
    \PYG{k+kt}{bool} \PYG{n}{has\PYGZus{}paused}\PYG{p}{,} \PYG{n}{has\PYGZus{}imported\PYGZus{}pause}\PYG{p}{;}
    \PYG{c+c1}{// Should always be false in the base class}
    \PYG{k+kt}{bool} \PYG{n}{bIsProtracted}\PYG{p}{;}
    \PYG{c+c1}{// variable for storing the paused sim location if files have been moved during paused/resumed simulations!}
    \PYG{n}{string} \PYG{n}{pause\PYGZus{}sim\PYGZus{}directory}\PYG{p}{;}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifdef DEBUG}
    \PYG{c+c1}{// For debugging purposes}
    \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{count\PYGZus{}dispersal\PYGZus{}fails}\PYG{p}{,} \PYG{n}{count\PYGZus{}density\PYGZus{}fails}\PYG{p}{;}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif}
\PYG{k}{public}\PYG{o}{:}
    \PYG{n}{Tree}\PYG{p}{(}\PYG{p}{)} \PYG{o}{:} \PYG{n}{community}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{data}\PYG{p}{)}\PYG{p}{,} \PYG{n}{this\PYGZus{}step}\PYG{p}{(}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{has\PYGZus{}imported\PYGZus{}vars} \PYG{o}{=} \PYG{n+nb}{false}\PYG{p}{;}
        \PYG{n}{enddata} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
        \PYG{n}{seeded} \PYG{o}{=} \PYG{n+nb}{false}\PYG{p}{;}
        \PYG{n}{the\PYGZus{}seed} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{10}\PYG{p}{;}
        \PYG{c+c1}{// set this equal to true if you want to log every 5 seconds to a logfile.}
        \PYG{n}{the\PYGZus{}task} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{;}
        \PYG{n}{sqloutname} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{null}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
        \PYG{n}{sim\PYGZus{}complete} \PYG{o}{=} \PYG{n+nb}{false}\PYG{p}{;}
        \PYG{n}{time\PYGZus{}taken} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}  \PYG{c+c1}{// the time taken starts at 0, unless imported from file.}
        \PYG{n}{maxtime} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
        \PYG{c+c1}{// Set the database to NULL pointers.}
        \PYG{n}{database} \PYG{o}{=} \PYG{k}{nullptr}\PYG{p}{;}
        \PYG{n}{outdatabase} \PYG{o}{=} \PYG{k}{nullptr}\PYG{p}{;}
        \PYG{n}{has\PYGZus{}times\PYGZus{}file} \PYG{o}{=} \PYG{n+nb}{false}\PYG{p}{;}
        \PYG{n}{start} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
        \PYG{n}{sim\PYGZus{}start} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
        \PYG{n}{sim\PYGZus{}end} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
        \PYG{n}{now} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
        \PYG{n}{sim\PYGZus{}finish} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
        \PYG{n}{out\PYGZus{}finish} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
        \PYG{n}{endactive} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
        \PYG{n}{startendactive} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
        \PYG{n}{maxsimsize} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
        \PYG{n}{steps} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
        \PYG{n}{generation} \PYG{o}{=} \PYG{l+m+mf}{0.0}\PYG{p}{;}
        \PYG{n}{spec} \PYG{o}{=} \PYG{l+m+mf}{0.0}\PYG{p}{;}
        \PYG{n}{deme\PYGZus{}sample} \PYG{o}{=} \PYG{l+m+mf}{0.0}\PYG{p}{;}
        \PYG{n}{deme} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
        \PYG{n}{bFullmode} \PYG{o}{=} \PYG{n+nb}{false}\PYG{p}{;}
        \PYG{n}{bResume} \PYG{o}{=} \PYG{n+nb}{false}\PYG{p}{;}
        \PYG{n}{bConfig} \PYG{o}{=} \PYG{n+nb}{true}\PYG{p}{;}
        \PYG{n}{has\PYGZus{}paused} \PYG{o}{=} \PYG{n+nb}{false}\PYG{p}{;}
        \PYG{n}{has\PYGZus{}imported\PYGZus{}pause} \PYG{o}{=} \PYG{n+nb}{false}\PYG{p}{;}
        \PYG{n}{bIsProtracted} \PYG{o}{=} \PYG{n+nb}{false}\PYG{p}{;}
        \PYG{n}{pause\PYGZus{}sim\PYGZus{}directory} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{null}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{k}{virtual} \PYG{o}{\PYGZti{}}\PYG{n}{Tree}\PYG{p}{(}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{sqlite3\PYGZus{}close\PYGZus{}v2}\PYG{p}{(}\PYG{n}{database}\PYG{p}{)}\PYG{p}{;}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifdef sql\PYGZus{}ram}
        \PYG{n}{sqlite3\PYGZus{}close\PYGZus{}v2}\PYG{p}{(}\PYG{n}{outdatabase}\PYG{p}{)}\PYG{p}{;}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif}
    \PYG{p}{\PYGZcb{}}


    \PYG{k}{virtual} \PYG{k+kt}{void} \PYG{n}{importSimulationVariables}\PYG{p}{(}\PYG{k}{const} \PYG{n}{string} \PYG{o}{\PYGZam{}}\PYG{n}{configfile}\PYG{p}{)}\PYG{p}{;}

    \PYG{k+kt}{void} \PYG{n+nf}{internalSetup}\PYG{p}{(}\PYG{k}{const} \PYG{n}{SimParameters} \PYG{o}{\PYGZam{}}\PYG{n}{sim\PYGZus{}parameters\PYGZus{}in}\PYG{p}{)}\PYG{p}{;}

    \PYG{k+kt}{bool} \PYG{n+nf}{checkOutputDirectory}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}


    \PYG{k+kt}{void} \PYG{n+nf}{checkSims}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

    \PYG{k+kt}{void} \PYG{n+nf}{checkSims}\PYG{p}{(}\PYG{n}{string} \PYG{n}{output\PYGZus{}dir}\PYG{p}{,} \PYG{k+kt}{long} \PYG{n}{seed}\PYG{p}{,} \PYG{k+kt}{long} \PYG{n}{task}\PYG{p}{)}\PYG{p}{;}

    \PYG{k}{virtual} \PYG{k+kt}{void} \PYG{n+nf}{setParameters}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

    \PYG{k}{virtual} \PYG{k+kt}{void} \PYG{n+nf}{setProtractedVariables}\PYG{p}{(}\PYG{k+kt}{double} \PYG{n}{speciation\PYGZus{}gen\PYGZus{}min}\PYG{p}{,} \PYG{k+kt}{double} \PYG{n}{speciation\PYGZus{}gen\PYGZus{}max}\PYG{p}{)}\PYG{p}{;}

    \PYG{k+kt}{bool} \PYG{n+nf}{hasPaused}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

    \PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{double}\PYG{o}{\PYGZgt{}} \PYG{n}{getTemporalSampling}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

    \PYG{k+kt}{long} \PYG{k+kt}{long} \PYG{n+nf}{getSeed}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

    \PYG{k+kt}{void} \PYG{n+nf}{setSeed}\PYG{p}{(}\PYG{k+kt}{long} \PYG{k+kt}{long} \PYG{n}{seed\PYGZus{}in}\PYG{p}{)}\PYG{p}{;}

    \PYG{k}{virtual} \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n+nf}{getInitialCount}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

    \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n+nf}{setObjectSizes}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

    \PYG{k}{virtual} \PYG{k+kt}{void} \PYG{n+nf}{setup}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

    \PYG{k+kt}{void} \PYG{n+nf}{setInitialValues}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

    \PYG{k+kt}{void} \PYG{n+nf}{setSimStartVariables}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

    \PYG{k+kt}{void} \PYG{n+nf}{printSetup}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

    \PYG{k+kt}{void} \PYG{n+nf}{setTimes}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

    \PYG{k+kt}{void} \PYG{n+nf}{determineSpeciationRates}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

    \PYG{k+kt}{void} \PYG{n+nf}{generateObjects}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

    \PYG{k}{virtual} \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n+nf}{fillObjects}\PYG{p}{(}\PYG{k}{const} \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{initial\PYGZus{}count}\PYG{p}{)}\PYG{p}{;}

     \PYG{k}{virtual} \PYG{k+kt}{bool} \PYG{n+nf}{runSimulation}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

    \PYG{k+kt}{void} \PYG{n+nf}{writeSimStartToConsole}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

    \PYG{k+kt}{void} \PYG{n+nf}{writeStepToConsole}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

    \PYG{k}{virtual} \PYG{k+kt}{void} \PYG{n+nf}{incrementGeneration}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

    \PYG{k+kt}{void} \PYG{n+nf}{chooseRandomLineage}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

    \PYG{k}{virtual} \PYG{k+kt}{void} \PYG{n+nf}{updateStepCoalescenceVariables}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

    \PYG{k+kt}{void} \PYG{n+nf}{speciation}\PYG{p}{(}\PYG{k}{const} \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{chosen}\PYG{p}{)}\PYG{p}{;}

    \PYG{k}{virtual} \PYG{k+kt}{void} \PYG{n+nf}{speciateLineage}\PYG{p}{(}\PYG{k}{const} \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{data\PYGZus{}position}\PYG{p}{)}\PYG{p}{;}
    \PYG{k}{virtual} \PYG{k+kt}{void} \PYG{n+nf}{removeOldPosition}\PYG{p}{(}\PYG{k}{const} \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{chosen}\PYG{p}{)}\PYG{p}{;}

    \PYG{k}{virtual} \PYG{k+kt}{void} \PYG{n+nf}{switchPositions}\PYG{p}{(}\PYG{k}{const} \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{chosen}\PYG{p}{)}\PYG{p}{;}

    \PYG{k}{virtual} \PYG{k+kt}{void} \PYG{n+nf}{calcNextStep}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

    \PYG{k}{virtual} \PYG{k+kt}{bool} \PYG{n+nf}{calcSpeciation}\PYG{p}{(}\PYG{k}{const} \PYG{k+kt}{long} \PYG{k+kt}{double} \PYG{o}{\PYGZam{}}\PYG{n}{random\PYGZus{}number}\PYG{p}{,}
                                \PYG{k}{const} \PYG{k+kt}{long} \PYG{k+kt}{double} \PYG{o}{\PYGZam{}}\PYG{n}{speciation\PYGZus{}rate}\PYG{p}{,}
                                \PYG{k}{const} \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{no\PYGZus{}generations}\PYG{p}{)}\PYG{p}{;}

    \PYG{k+kt}{void} \PYG{n+nf}{coalescenceEvent}\PYG{p}{(}\PYG{k}{const} \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{chosen}\PYG{p}{,} \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{coalchosen}\PYG{p}{)}\PYG{p}{;}

    \PYG{k+kt}{void} \PYG{n+nf}{checkTimeUpdate}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

    \PYG{k}{virtual} \PYG{k+kt}{void} \PYG{n+nf}{addLineages}\PYG{p}{(}\PYG{k+kt}{double} \PYG{n}{generation\PYGZus{}in}\PYG{p}{)}\PYG{p}{;}

    \PYG{k+kt}{void} \PYG{n+nf}{checkSimSize}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{req\PYGZus{}data}\PYG{p}{,} \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{req\PYGZus{}active}\PYG{p}{)}\PYG{p}{;}


    \PYG{k+kt}{void} \PYG{n+nf}{makeTip}\PYG{p}{(}\PYG{k}{const} \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{tmp\PYGZus{}active}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{double} \PYG{o}{\PYGZam{}}\PYG{n}{generation\PYGZus{}in}\PYG{p}{)}\PYG{p}{;}

    \PYG{k+kt}{void} \PYG{n+nf}{convertTip}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{i}\PYG{p}{,} \PYG{k+kt}{double} \PYG{n}{generationin}\PYG{p}{)}\PYG{p}{;}

    \PYG{k+kt}{bool} \PYG{n+nf}{stopSimulation}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

    \PYG{k+kt}{void} \PYG{n+nf}{applySpecRate}\PYG{p}{(}\PYG{k+kt}{long} \PYG{k+kt}{double} \PYG{n}{sr}\PYG{p}{,} \PYG{k+kt}{double} \PYG{n}{t}\PYG{p}{)}\PYG{p}{;}

    \PYG{k+kt}{void} \PYG{n+nf}{applySpecRateInternal}\PYG{p}{(}\PYG{k+kt}{long} \PYG{k+kt}{double} \PYG{n}{sr}\PYG{p}{,} \PYG{k+kt}{double} \PYG{n}{t}\PYG{p}{)}\PYG{p}{;}

    \PYG{n}{Row}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{unsigned} \PYG{k+kt}{long}\PYG{o}{\PYGZgt{}} \PYG{o}{*}\PYG{n}{getCumulativeAbundances}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kt}{void} \PYG{n+nf}{setupTreeGeneration}\PYG{p}{(}\PYG{k+kt}{long} \PYG{k+kt}{double} \PYG{n}{sr}\PYG{p}{,} \PYG{k+kt}{double} \PYG{n}{t}\PYG{p}{)}\PYG{p}{;}

    \PYG{k+kt}{void} \PYG{n+nf}{applySpecRate}\PYG{p}{(}\PYG{k+kt}{long} \PYG{k+kt}{double} \PYG{n}{sr}\PYG{p}{)}\PYG{p}{;}

    \PYG{k+kt}{void} \PYG{n+nf}{applyMultipleRates}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

    \PYG{k}{virtual} \PYG{k+kt}{bool} \PYG{n+nf}{getProtracted}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

    \PYG{k}{virtual} \PYG{n}{string} \PYG{n+nf}{getProtractedVariables}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

    \PYG{k}{virtual} \PYG{k+kt}{double} \PYG{n+nf}{getProtractedGenerationMin}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

    \PYG{k}{virtual} \PYG{k+kt}{double} \PYG{n+nf}{getProtractedGenerationMax}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}


    \PYG{k+kt}{void} \PYG{n+nf}{sqlOutput}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

    \PYG{k+kt}{void} \PYG{n+nf}{outputData}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

    \PYG{k+kt}{void} \PYG{n+nf}{outputData}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{species\PYGZus{}richness}\PYG{p}{)}\PYG{p}{;}

    \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n+nf}{sortData}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

    \PYG{k+kt}{void} \PYG{n+nf}{writeTimes}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}


    \PYG{k+kt}{void} \PYG{n+nf}{sqlCreate}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

    \PYG{k+kt}{void} \PYG{n+nf}{sqlCreateSimulationParameters}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

    \PYG{k}{virtual} \PYG{n}{string} \PYG{n+nf}{simulationParametersSqlInsertion}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

    \PYG{k}{virtual} \PYG{n}{string} \PYG{n+nf}{protractedVarsToString}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}


    \PYG{k}{virtual} \PYG{k+kt}{void} \PYG{n+nf}{simPause}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

    \PYG{n}{string} \PYG{n+nf}{initiatePause}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

    \PYG{k+kt}{void} \PYG{n+nf}{dumpMain}\PYG{p}{(}\PYG{n}{string} \PYG{n}{pause\PYGZus{}folder}\PYG{p}{)}\PYG{p}{;}

    \PYG{k+kt}{void} \PYG{n+nf}{dumpActive}\PYG{p}{(}\PYG{n}{string} \PYG{n}{pause\PYGZus{}folder}\PYG{p}{)}\PYG{p}{;}

    \PYG{k+kt}{void} \PYG{n+nf}{dumpData}\PYG{p}{(}\PYG{n}{string} \PYG{n}{pause\PYGZus{}folder}\PYG{p}{)}\PYG{p}{;}

    \PYG{k+kt}{void} \PYG{n+nf}{completePause}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

    \PYG{k+kt}{void} \PYG{n+nf}{setResumeParameters}\PYG{p}{(}\PYG{n}{string} \PYG{n}{pausedir}\PYG{p}{,} \PYG{n}{string} \PYG{n}{outdir}\PYG{p}{,} \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{seed}\PYG{p}{,} \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{task}\PYG{p}{,}
                             \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{new\PYGZus{}max\PYGZus{}time}\PYG{p}{)}\PYG{p}{;}

    \PYG{k+kt}{void} \PYG{n+nf}{setResumeParameters}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

    \PYG{k}{virtual} \PYG{k+kt}{void} \PYG{n+nf}{loadMainSave}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

    \PYG{k+kt}{void} \PYG{n+nf}{loadDataSave}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

    \PYG{k+kt}{void} \PYG{n+nf}{loadActiveSave}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

    \PYG{k+kt}{void} \PYG{n+nf}{initiateResume}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

    \PYG{k}{virtual} \PYG{k+kt}{void} \PYG{n+nf}{simResume}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifdef DEBUG}

    \PYG{k}{virtual} \PYG{k+kt}{void} \PYG{n+nf}{validateLineages}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

    \PYG{k}{virtual} \PYG{k+kt}{void} \PYG{n+nf}{debugEndStep}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

    \PYG{k+kt}{void} \PYG{n+nf}{debugCoalescence}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

    \PYG{k}{virtual} \PYG{k+kt}{void} \PYG{n+nf}{runChecks}\PYG{p}{(}\PYG{k}{const} \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{chosen}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{coalchosen}\PYG{p}{)}\PYG{p}{;}

    \PYG{k+kt}{void} \PYG{n+nf}{miniCheck}\PYG{p}{(}\PYG{k}{const} \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{chosen}\PYG{p}{)}\PYG{p}{;}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif }\PYG{c+c1}{// DEBUG}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}


\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif }\PYG{c+c1}{//TREE\PYGZus{}H}
\end{sphinxVerbatim}


\subsubsection{Detailed Description}
\label{\detokenize{api/file_necsim_Tree.h:detailed-description}}
Samuel Thompson
24/03/17
BSD-3 Licence.


\subsubsection{Includes}
\label{\detokenize{api/file_necsim_Tree.h:includes}}\begin{itemize}
\item {} 
\sphinxcode{Community.h} ({\hyperref[\detokenize{api/file_necsim_Community.h:file-necsim-community-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File Community.h}}}})

\item {} 
\sphinxcode{CustomExceptions.h} ({\hyperref[\detokenize{api/file_necsim_CustomExceptions.h:file-necsim-customexceptions-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File CustomExceptions.h}}}})

\item {} 
\sphinxcode{DataPoint.h} ({\hyperref[\detokenize{api/file_necsim_DataPoint.h:file-necsim-datapoint-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File DataPoint.h}}}})

\item {} 
\sphinxcode{Filesystem.h} ({\hyperref[\detokenize{api/file_necsim_Filesystem.h:file-necsim-filesystem-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File Filesystem.h}}}})

\item {} 
\sphinxcode{Matrix.h} ({\hyperref[\detokenize{api/file_necsim_Matrix.h:file-necsim-matrix-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File Matrix.h}}}})

\item {} 
\sphinxcode{NRrand.h} ({\hyperref[\detokenize{api/file_necsim_NRrand.h:file-necsim-nrrand-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File NRrand.h}}}})

\item {} 
\sphinxcode{SimParameters.h} ({\hyperref[\detokenize{api/file_necsim_SimParameters.h:file-necsim-simparameters-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File SimParameters.h}}}})

\item {} 
\sphinxcode{Step.h} ({\hyperref[\detokenize{api/file_necsim_Step.h:file-necsim-step-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File Step.h}}}})

\item {} 
\sphinxcode{TreeNode.h} ({\hyperref[\detokenize{api/file_necsim_TreeNode.h:file-necsim-treenode-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File TreeNode.h}}}})

\item {} 
\sphinxcode{sqlite3.h}

\end{itemize}


\subsubsection{Included By}
\label{\detokenize{api/file_necsim_Tree.h:included-by}}\begin{itemize}
\item {} 
{\hyperref[\detokenize{api/file_necsim_SpatialTree.h:file-necsim-spatialtree-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File SpatialTree.h}}}}

\item {} 
{\hyperref[\detokenize{api/file_necsim_Metacommunity.h:file-necsim-metacommunity-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File Metacommunity.h}}}}

\item {} 
{\hyperref[\detokenize{api/file_necsim_Tree.cpp:file-necsim-tree-cpp}]{\sphinxcrossref{\DUrole{std,std-ref}{File Tree.cpp}}}}

\end{itemize}


\subsubsection{Classes}
\label{\detokenize{api/file_necsim_Tree.h:classes}}\begin{itemize}
\item {} 
{\hyperref[\detokenize{api/class_Tree:class-tree}]{\sphinxcrossref{\DUrole{std,std-ref}{Class Tree}}}}

\end{itemize}


\subsubsection{Defines}
\label{\detokenize{api/file_necsim_Tree.h:defines}}\begin{itemize}
\item {} 
{\hyperref[\detokenize{api/define_sql_ram:define-sql-ram}]{\sphinxcrossref{\DUrole{std,std-ref}{Define sql\_ram}}}}

\end{itemize}


\subsection{File TreeNode.cpp}
\label{\detokenize{api/file_necsim_TreeNode.cpp:file-necsim-treenode-cpp}}\label{\detokenize{api/file_necsim_TreeNode.cpp::doc}}\label{\detokenize{api/file_necsim_TreeNode.cpp:file-treenode-cpp}}
Contains the {\hyperref[\detokenize{api/class_TreeNode:class-treenode}]{\sphinxcrossref{\DUrole{std,std-ref}{Class TreeNode}}}} class for storing the coalescence tree.

\begin{sphinxShadowBox}
\sphinxstyletopictitle{Contents}
\begin{itemize}
\item {} 
\phantomsection\label{\detokenize{api/file_necsim_TreeNode.cpp:id1}}{\hyperref[\detokenize{api/file_necsim_TreeNode.cpp:definition-necsim-treenode-cpp}]{\sphinxcrossref{Definition (\sphinxcode{necsim/TreeNode.cpp})}}}

\item {} 
\phantomsection\label{\detokenize{api/file_necsim_TreeNode.cpp:id2}}{\hyperref[\detokenize{api/file_necsim_TreeNode.cpp:detailed-description}]{\sphinxcrossref{Detailed Description}}}

\item {} 
\phantomsection\label{\detokenize{api/file_necsim_TreeNode.cpp:id3}}{\hyperref[\detokenize{api/file_necsim_TreeNode.cpp:includes}]{\sphinxcrossref{Includes}}}

\item {} 
\phantomsection\label{\detokenize{api/file_necsim_TreeNode.cpp:id4}}{\hyperref[\detokenize{api/file_necsim_TreeNode.cpp:functions}]{\sphinxcrossref{Functions}}}

\end{itemize}
\end{sphinxShadowBox}


\subsubsection{Definition (\sphinxstyleliteralintitle{necsim/TreeNode.cpp})}
\label{\detokenize{api/file_necsim_TreeNode.cpp:definition-necsim-treenode-cpp}}

\paragraph{Program Listing for File TreeNode.cpp}
\label{\detokenize{api/program_listing_file_necsim_TreeNode.cpp:program-listing-file-necsim-treenode-cpp}}\label{\detokenize{api/program_listing_file_necsim_TreeNode.cpp:program-listing-for-file-treenode-cpp}}\label{\detokenize{api/program_listing_file_necsim_TreeNode.cpp::doc}}\begin{itemize}
\item {} 
Return to documentation for {\hyperref[\detokenize{api/file_necsim_TreeNode.cpp:file-necsim-treenode-cpp}]{\sphinxcrossref{\DUrole{std,std-ref}{File TreeNode.cpp}}}}

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{//This file is part of NECSim project which is released under BSD\PYGZhy{}3 license.}
\PYG{c+c1}{//See file **LICENSE.txt** or visit https://opensource.org/licenses/BSD\PYGZhy{}3\PYGZhy{}Clause) for full license details.}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZdq{}TreeNode.h\PYGZdq{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZdq{}Logging.h\PYGZdq{}}

\PYG{k+kt}{void} \PYG{n}{TreeNode}\PYG{o}{:}\PYG{o}{:}\PYG{n}{setup}\PYG{p}{(}\PYG{k+kt}{bool} \PYG{n}{z}\PYG{p}{,} \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{xp}\PYG{p}{,} \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{yp}\PYG{p}{,} \PYG{k+kt}{long} \PYG{n}{xi}\PYG{p}{,} \PYG{k+kt}{long} \PYG{n}{yi}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{n}{tip} \PYG{o}{=} \PYG{n}{z}\PYG{p}{;}
    \PYG{n}{parent} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
    \PYG{n}{speciated} \PYG{o}{=} \PYG{n+nb}{false}\PYG{p}{;}

    \PYG{n}{species\PYGZus{}id} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}

    \PYG{n}{xpos} \PYG{o}{=} \PYG{n}{xp}\PYG{p}{;}
    \PYG{n}{ypos} \PYG{o}{=} \PYG{n}{yp}\PYG{p}{;}
    \PYG{n}{xwrap} \PYG{o}{=} \PYG{n}{xi}\PYG{p}{;}
    \PYG{n}{ywrap} \PYG{o}{=} \PYG{n}{yi}\PYG{p}{;}
    \PYG{n}{speciation\PYGZus{}probability} \PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;}
    \PYG{n}{generations\PYGZus{}existed} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
    \PYG{n}{generation\PYGZus{}added} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{void} \PYG{n}{TreeNode}\PYG{o}{:}\PYG{o}{:}\PYG{n}{setup}\PYG{p}{(}\PYG{k+kt}{bool} \PYG{n}{z}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{n}{setup}\PYG{p}{(}\PYG{n}{z}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{void} \PYG{n}{TreeNode}\PYG{o}{:}\PYG{o}{:}\PYG{n}{setup}\PYG{p}{(}\PYG{k}{const} \PYG{k+kt}{bool} \PYG{o}{\PYGZam{}}\PYG{n}{is\PYGZus{}tip}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{xp}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{yp}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{xi}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{yi}\PYG{p}{,}
                     \PYG{k}{const} \PYG{k+kt}{long} \PYG{k+kt}{double} \PYG{o}{\PYGZam{}}\PYG{n}{generation}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{n}{tip} \PYG{o}{=} \PYG{n}{is\PYGZus{}tip}\PYG{p}{;}
    \PYG{n}{parent} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
    \PYG{n}{speciated} \PYG{o}{=} \PYG{n+nb}{false}\PYG{p}{;}
    \PYG{n}{species\PYGZus{}id} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
    \PYG{n}{xpos} \PYG{o}{=} \PYG{n}{xp}\PYG{p}{;}
    \PYG{n}{ypos} \PYG{o}{=} \PYG{n}{yp}\PYG{p}{;}
    \PYG{n}{xwrap} \PYG{o}{=} \PYG{n}{xi}\PYG{p}{;}
    \PYG{n}{ywrap} \PYG{o}{=} \PYG{n}{yi}\PYG{p}{;}
    \PYG{n}{speciation\PYGZus{}probability} \PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;}
    \PYG{n}{generations\PYGZus{}existed} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
    \PYG{n}{generation\PYGZus{}added} \PYG{o}{=} \PYG{n}{generation}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{void} \PYG{n}{TreeNode}\PYG{o}{:}\PYG{o}{:}\PYG{n}{setExistence}\PYG{p}{(}\PYG{k+kt}{bool} \PYG{n}{b}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{n}{does\PYGZus{}exist} \PYG{o}{=} \PYG{n}{b}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{void} \PYG{n}{TreeNode}\PYG{o}{:}\PYG{o}{:}\PYG{n}{setParent}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{x}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{n}{parent} \PYG{o}{=} \PYG{n}{x}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{void} \PYG{n}{TreeNode}\PYG{o}{:}\PYG{o}{:}\PYG{n}{qReset}\PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{n}{species\PYGZus{}id} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
    \PYG{n}{does\PYGZus{}exist} \PYG{o}{=} \PYG{n+nb}{false}\PYG{p}{;}
    \PYG{n}{speciated} \PYG{o}{=} \PYG{n+nb}{false}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{void} \PYG{n}{TreeNode}\PYG{o}{:}\PYG{o}{:}\PYG{n}{setPosition}\PYG{p}{(}\PYG{k+kt}{long} \PYG{n}{x}\PYG{p}{,} \PYG{k+kt}{long} \PYG{n}{y}\PYG{p}{,} \PYG{k+kt}{long} \PYG{n}{xw}\PYG{p}{,} \PYG{k+kt}{long} \PYG{n}{yw}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{n}{xpos} \PYG{o}{=} \PYG{n}{x}\PYG{p}{;}
    \PYG{n}{ypos} \PYG{o}{=} \PYG{n}{y}\PYG{p}{;}
    \PYG{n}{xwrap} \PYG{o}{=} \PYG{n}{xw}\PYG{p}{;}
    \PYG{n}{ywrap} \PYG{o}{=} \PYG{n}{yw}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{void} \PYG{n}{TreeNode}\PYG{o}{:}\PYG{o}{:}\PYG{n}{setSpec}\PYG{p}{(}\PYG{k+kt}{long} \PYG{k+kt}{double} \PYG{n}{d}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{n}{speciation\PYGZus{}probability} \PYG{o}{=} \PYG{n}{d}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{void} \PYG{n}{TreeNode}\PYG{o}{:}\PYG{o}{:}\PYG{n}{setGenerationRate}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{g}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{n}{generations\PYGZus{}existed} \PYG{o}{=} \PYG{n}{g}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{void} \PYG{n}{TreeNode}\PYG{o}{:}\PYG{o}{:}\PYG{n}{setGeneration}\PYG{p}{(}\PYG{k+kt}{long} \PYG{k+kt}{double} \PYG{n}{d}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{n}{generation\PYGZus{}added} \PYG{o}{=} \PYG{n}{d}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{void} \PYG{n}{TreeNode}\PYG{o}{:}\PYG{o}{:}\PYG{n}{setSpeciation}\PYG{p}{(}\PYG{k+kt}{bool} \PYG{n}{s}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{n}{speciated} \PYG{o}{=} \PYG{n}{s}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{void} \PYG{n}{TreeNode}\PYG{o}{:}\PYG{o}{:}\PYG{n}{burnSpecies}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{idin}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k}{if} \PYG{p}{(}\PYG{n}{species\PYGZus{}id} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{species\PYGZus{}id} \PYG{o}{=} \PYG{n}{idin}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{void} \PYG{n}{TreeNode}\PYG{o}{:}\PYG{o}{:}\PYG{n}{setTip}\PYG{p}{(}\PYG{k+kt}{bool} \PYG{n}{b}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{n}{tip} \PYG{o}{=} \PYG{n}{b}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{void} \PYG{n}{TreeNode}\PYG{o}{:}\PYG{o}{:}\PYG{n}{resetSpecies}\PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{n}{species\PYGZus{}id} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{void} \PYG{n}{TreeNode}\PYG{o}{:}\PYG{o}{:}\PYG{n}{increaseGen}\PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{n}{generations\PYGZus{}existed}\PYG{o}{+}\PYG{o}{+}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{bool} \PYG{n}{TreeNode}\PYG{o}{:}\PYG{o}{:}\PYG{n}{getExistence}\PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k}{return} \PYG{n}{does\PYGZus{}exist}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{bool} \PYG{n}{TreeNode}\PYG{o}{:}\PYG{o}{:}\PYG{n}{isTip}\PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k}{return} \PYG{n}{tip}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{TreeNode}\PYG{o}{:}\PYG{o}{:}\PYG{n}{getParent}\PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k}{return} \PYG{n}{parent}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{TreeNode}\PYG{o}{:}\PYG{o}{:}\PYG{n}{getXpos}\PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k}{return} \PYG{n}{xpos}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{TreeNode}\PYG{o}{:}\PYG{o}{:}\PYG{n}{getYpos}\PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k}{return} \PYG{n}{ypos}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{long} \PYG{n}{TreeNode}\PYG{o}{:}\PYG{o}{:}\PYG{n}{getXwrap}\PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k}{return} \PYG{n}{xwrap}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{long} \PYG{n}{TreeNode}\PYG{o}{:}\PYG{o}{:}\PYG{n}{getYwrap}\PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k}{return} \PYG{n}{ywrap}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{bool} \PYG{n}{TreeNode}\PYG{o}{:}\PYG{o}{:}\PYG{n}{hasSpeciated}\PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k}{return} \PYG{n}{speciated}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{TreeNode}\PYG{o}{:}\PYG{o}{:}\PYG{n}{getSpeciesID}\PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k}{return} \PYG{n}{species\PYGZus{}id}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{long} \PYG{k+kt}{double} \PYG{n}{TreeNode}\PYG{o}{:}\PYG{o}{:}\PYG{n}{getSpecRate}\PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k}{return} \PYG{n}{speciation\PYGZus{}probability}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{TreeNode}\PYG{o}{:}\PYG{o}{:}\PYG{n}{getGenRate}\PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k}{return} \PYG{n}{generations\PYGZus{}existed}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{long} \PYG{k+kt}{double} \PYG{n}{TreeNode}\PYG{o}{:}\PYG{o}{:}\PYG{n}{getGeneration}\PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k}{return} \PYG{n}{generation\PYGZus{}added}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{void} \PYG{n}{TreeNode}\PYG{o}{:}\PYG{o}{:}\PYG{n}{speciate}\PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{n}{speciated} \PYG{o}{=} \PYG{n+nb}{true}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{n}{ostream} \PYG{o}{\PYGZam{}}\PYG{k}{operator}\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{p}{(}\PYG{n}{ostream} \PYG{o}{\PYGZam{}}\PYG{n}{os}\PYG{p}{,} \PYG{k}{const} \PYG{n}{TreeNode} \PYG{o}{\PYGZam{}}\PYG{n}{t}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{n}{os} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{setprecision}\PYG{p}{(}\PYG{l+m+mi}{64}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{os} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{n}{t}\PYG{p}{.}\PYG{n}{tip} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{,}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{t}\PYG{p}{.}\PYG{n}{parent} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{,}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{t}\PYG{p}{.}\PYG{n}{speciated} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{,}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{t}\PYG{p}{.}\PYG{n}{does\PYGZus{}exist} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{,}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{t}\PYG{p}{.}\PYG{n}{species\PYGZus{}id} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{,}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{t}\PYG{p}{.}\PYG{n}{xpos} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{,}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{t}\PYG{p}{.}\PYG{n}{ypos} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{,}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{t}\PYG{p}{.}\PYG{n}{xwrap} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{,}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
    \PYG{n}{os} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{t}\PYG{p}{.}\PYG{n}{ywrap} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{,}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{t}\PYG{p}{.}\PYG{n}{speciation\PYGZus{}probability} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{,}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{t}\PYG{p}{.}\PYG{n}{generations\PYGZus{}existed} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{,}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{t}\PYG{p}{.}\PYG{n}{generation\PYGZus{}added} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
    \PYG{k}{return} \PYG{n}{os}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{n}{istream} \PYG{o}{\PYGZam{}}\PYG{k}{operator}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{n}{istream} \PYG{o}{\PYGZam{}}\PYG{n}{is}\PYG{p}{,} \PYG{n}{TreeNode} \PYG{o}{\PYGZam{}}\PYG{n}{t}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{c+c1}{//is \PYGZlt{}\PYGZlt{} m.numRows\PYGZlt{}\PYGZlt{}\PYGZdq{} , \PYGZdq{}\PYGZlt{}\PYGZlt{}m.numCols\PYGZlt{}\PYGZlt{}\PYGZdq{} , \PYGZdq{}\PYGZlt{}\PYGZlt{}endl;}
    \PYG{k+kt}{char} \PYG{n}{delim}\PYG{p}{;}
    \PYG{n}{is} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}}\PYG{n}{t}\PYG{p}{.}\PYG{n}{tip} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{delim} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{t}\PYG{p}{.}\PYG{n}{parent} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{delim} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{t}\PYG{p}{.}\PYG{n}{speciated} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{delim} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{t}\PYG{p}{.}\PYG{n}{does\PYGZus{}exist} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{delim} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{t}\PYG{p}{.}\PYG{n}{species\PYGZus{}id} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{delim} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{t}\PYG{p}{.}\PYG{n}{xpos} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{delim}\PYG{p}{;}
    \PYG{n}{is} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{t}\PYG{p}{.}\PYG{n}{ypos} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{delim} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{t}\PYG{p}{.}\PYG{n}{xwrap} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{delim} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{t}\PYG{p}{.}\PYG{n}{ywrap} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{delim} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{t}\PYG{p}{.}\PYG{n}{speciation\PYGZus{}probability} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{delim} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{t}\PYG{p}{.}\PYG{n}{generations\PYGZus{}existed} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{delim} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{t}\PYG{p}{.}\PYG{n}{generation\PYGZus{}added}\PYG{p}{;}
    \PYG{k}{return} \PYG{n}{is}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{n}{TreeNode} \PYG{o}{\PYGZam{}}\PYG{n}{TreeNode}\PYG{o}{:}\PYG{o}{:}\PYG{k}{operator}\PYG{o}{=}\PYG{p}{(}\PYG{k}{const} \PYG{n}{TreeNode} \PYG{o}{\PYGZam{}}\PYG{n}{t}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{n}{tip} \PYG{o}{=} \PYG{n}{t}\PYG{p}{.}\PYG{n}{tip}\PYG{p}{;}
    \PYG{n}{parent} \PYG{o}{=} \PYG{n}{t}\PYG{p}{.}\PYG{n}{parent}\PYG{p}{;}
    \PYG{n}{speciated} \PYG{o}{=} \PYG{n}{t}\PYG{p}{.}\PYG{n}{speciated}\PYG{p}{;}
    \PYG{n}{does\PYGZus{}exist} \PYG{o}{=} \PYG{n}{t}\PYG{p}{.}\PYG{n}{does\PYGZus{}exist}\PYG{p}{;}
    \PYG{n}{species\PYGZus{}id} \PYG{o}{=} \PYG{n}{t}\PYG{p}{.}\PYG{n}{species\PYGZus{}id}\PYG{p}{;}
    \PYG{n}{xpos} \PYG{o}{=} \PYG{n}{t}\PYG{p}{.}\PYG{n}{xpos}\PYG{p}{;}
    \PYG{n}{ypos} \PYG{o}{=} \PYG{n}{t}\PYG{p}{.}\PYG{n}{ypos}\PYG{p}{;}
    \PYG{n}{xwrap} \PYG{o}{=} \PYG{n}{t}\PYG{p}{.}\PYG{n}{xwrap}\PYG{p}{;}
    \PYG{n}{ywrap} \PYG{o}{=} \PYG{n}{t}\PYG{p}{.}\PYG{n}{ywrap}\PYG{p}{;}
    \PYG{n}{speciation\PYGZus{}probability} \PYG{o}{=} \PYG{n}{t}\PYG{p}{.}\PYG{n}{speciation\PYGZus{}probability}\PYG{p}{;}
    \PYG{n}{generation\PYGZus{}added} \PYG{o}{=} \PYG{n}{t}\PYG{p}{.}\PYG{n}{generation\PYGZus{}added}\PYG{p}{;}
    \PYG{n}{generations\PYGZus{}existed} \PYG{o}{=} \PYG{n}{t}\PYG{p}{.}\PYG{n}{generations\PYGZus{}existed}\PYG{p}{;}
    \PYG{k}{return} \PYG{o}{*}\PYG{k}{this}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifdef DEBUG}
\PYG{k+kt}{void} \PYG{n}{TreeNode}\PYG{o}{:}\PYG{o}{:}\PYG{n}{logLineageInformation}\PYG{p}{(}\PYG{k}{const} \PYG{k+kt}{int} \PYG{o}{\PYGZam{}}\PYG{n}{level}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{n}{writeLog}\PYG{p}{(}\PYG{n}{level}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Logging lineage information}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{writeLog}\PYG{p}{(}\PYG{n}{level}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{parent: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{+} \PYG{n}{to\PYGZus{}string}\PYG{p}{(}\PYG{n}{parent}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{writeLog}\PYG{p}{(}\PYG{n}{level}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{tip: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{+} \PYG{n}{to\PYGZus{}string}\PYG{p}{(}\PYG{n}{tip}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{writeLog}\PYG{p}{(}\PYG{n}{level}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{speciated: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{+} \PYG{n}{to\PYGZus{}string}\PYG{p}{(}\PYG{n}{speciated}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{writeLog}\PYG{p}{(}\PYG{n}{level}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{existance: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{+} \PYG{n}{to\PYGZus{}string}\PYG{p}{(}\PYG{n}{does\PYGZus{}exist}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{writeLog}\PYG{p}{(}\PYG{n}{level}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{x, y, (x wrap, y wrap): }\PYG{l+s}{\PYGZdq{}} \PYG{o}{+} \PYG{n}{to\PYGZus{}string}\PYG{p}{(}\PYG{n}{xpos}\PYG{p}{)} \PYG{o}{+} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{, }\PYG{l+s}{\PYGZdq{}} \PYG{o}{+} \PYG{n}{to\PYGZus{}string}\PYG{p}{(}\PYG{n}{ypos}\PYG{p}{)} \PYG{o}{+} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{, }\PYG{l+s}{\PYGZdq{}} \PYG{o}{+}
                    \PYG{n}{to\PYGZus{}string}\PYG{p}{(}\PYG{n}{xwrap}\PYG{p}{)} \PYG{o}{+} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{, }\PYG{l+s}{\PYGZdq{}} \PYG{o}{+} \PYG{n}{to\PYGZus{}string}\PYG{p}{(}\PYG{n}{ywrap}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{writeLog}\PYG{p}{(}\PYG{n}{level}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{speciation rate: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{+} \PYG{n}{to\PYGZus{}string}\PYG{p}{(}\PYG{n}{speciation\PYGZus{}probability}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{writeLog}\PYG{p}{(}\PYG{n}{level}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{generations (added, existed): }\PYG{l+s}{\PYGZdq{}} \PYG{o}{+} \PYG{n}{to\PYGZus{}string}\PYG{p}{(}\PYG{n}{generation\PYGZus{}added}\PYG{p}{)} \PYG{o}{+} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{, }\PYG{l+s}{\PYGZdq{}} \PYG{o}{+}
                    \PYG{n}{to\PYGZus{}string}\PYG{p}{(}\PYG{n}{generations\PYGZus{}existed}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}


\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif }\PYG{c+c1}{// DEBUG}
\end{sphinxVerbatim}


\subsubsection{Detailed Description}
\label{\detokenize{api/file_necsim_TreeNode.cpp:detailed-description}}
Samuel Thompson
{\hyperref[\detokenize{api/class_TreeNode:class-treenode}]{\sphinxcrossref{\DUrole{std,std-ref}{Class TreeNode}}}} objects are used both during simulation runs and afterwards, when different calculations need to be performed on the coalescence tree.


\subsubsection{Includes}
\label{\detokenize{api/file_necsim_TreeNode.cpp:includes}}\begin{itemize}
\item {} 
\sphinxcode{Logging.h} ({\hyperref[\detokenize{api/file_necsim_Logging.h:file-necsim-logging-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File Logging.h}}}})

\item {} 
\sphinxcode{TreeNode.h} ({\hyperref[\detokenize{api/file_necsim_TreeNode.h:file-necsim-treenode-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File TreeNode.h}}}})

\end{itemize}


\subsubsection{Functions}
\label{\detokenize{api/file_necsim_TreeNode.cpp:functions}}\begin{itemize}
\item {} 
{\hyperref[\detokenize{api/function_operator_LT__LT:function-operator-lt-lt}]{\sphinxcrossref{\DUrole{std,std-ref}{Function operator\textless{}\textless{}}}}}

\item {} 
{\hyperref[\detokenize{api/function_operator_GT__GT:function-operator-gt-gt}]{\sphinxcrossref{\DUrole{std,std-ref}{Function operator\textgreater{}\textgreater{}}}}}

\end{itemize}


\subsection{File TreeNode.h}
\label{\detokenize{api/file_necsim_TreeNode.h:file-necsim-treenode-h}}\label{\detokenize{api/file_necsim_TreeNode.h:file-treenode-h}}\label{\detokenize{api/file_necsim_TreeNode.h::doc}}
Contains the {\hyperref[\detokenize{api/class_TreeNode:class-treenode}]{\sphinxcrossref{\DUrole{std,std-ref}{Class TreeNode}}}} class for storing the coalescence tree.

\begin{sphinxShadowBox}
\sphinxstyletopictitle{Contents}
\begin{itemize}
\item {} 
\phantomsection\label{\detokenize{api/file_necsim_TreeNode.h:id1}}{\hyperref[\detokenize{api/file_necsim_TreeNode.h:definition-necsim-treenode-h}]{\sphinxcrossref{Definition (\sphinxcode{necsim/TreeNode.h})}}}

\item {} 
\phantomsection\label{\detokenize{api/file_necsim_TreeNode.h:id2}}{\hyperref[\detokenize{api/file_necsim_TreeNode.h:detailed-description}]{\sphinxcrossref{Detailed Description}}}

\item {} 
\phantomsection\label{\detokenize{api/file_necsim_TreeNode.h:id3}}{\hyperref[\detokenize{api/file_necsim_TreeNode.h:includes}]{\sphinxcrossref{Includes}}}

\item {} 
\phantomsection\label{\detokenize{api/file_necsim_TreeNode.h:id4}}{\hyperref[\detokenize{api/file_necsim_TreeNode.h:included-by}]{\sphinxcrossref{Included By}}}

\item {} 
\phantomsection\label{\detokenize{api/file_necsim_TreeNode.h:id5}}{\hyperref[\detokenize{api/file_necsim_TreeNode.h:classes}]{\sphinxcrossref{Classes}}}

\end{itemize}
\end{sphinxShadowBox}


\subsubsection{Definition (\sphinxstyleliteralintitle{necsim/TreeNode.h})}
\label{\detokenize{api/file_necsim_TreeNode.h:definition-necsim-treenode-h}}

\paragraph{Program Listing for File TreeNode.h}
\label{\detokenize{api/program_listing_file_necsim_TreeNode.h:program-listing-file-necsim-treenode-h}}\label{\detokenize{api/program_listing_file_necsim_TreeNode.h::doc}}\label{\detokenize{api/program_listing_file_necsim_TreeNode.h:program-listing-for-file-treenode-h}}\begin{itemize}
\item {} 
Return to documentation for {\hyperref[\detokenize{api/file_necsim_TreeNode.h:file-necsim-treenode-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File TreeNode.h}}}}

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{//This file is part of NECSim project which is released under BSD\PYGZhy{}3 license.}
\PYG{c+c1}{//See file **LICENSE.txt** or visit https://opensource.org/licenses/BSD\PYGZhy{}3\PYGZhy{}Clause) for full license details.}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifndef TREENODE}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define TREENODE}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}cstdio\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}iostream\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}iomanip\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZdq{}Logging.h\PYGZdq{}}

\PYG{k}{using} \PYG{k}{namespace} \PYG{n}{std}\PYG{p}{;}
\PYG{k}{class} \PYG{n+nc}{TreeNode}
\PYG{p}{\PYGZob{}}

\PYG{k}{private}\PYG{o}{:}
    \PYG{c+c1}{// 0 means that this node is just here to mark a coalescense}
    \PYG{c+c1}{// and therefore this node of no real other relevance}
    \PYG{c+c1}{// 1 means that this node is a leaf node and counts towards diversity}
    \PYG{k+kt}{bool} \PYG{n}{tip}\PYG{p}{;}
    \PYG{c+c1}{// this stores the parent of the individual}
    \PYG{c+c1}{// 0 means there is no parent \PYGZhy{} we are at the end of the tree}
    \PYG{c+c1}{// (as far as has been calculated)}
    \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{parent}\PYG{p}{;}
    \PYG{c+c1}{// true if this lineage has speciated in which case it should not have a parent}
    \PYG{c+c1}{// because under the present implementation lineages are not traced beyond speciation}
    \PYG{c+c1}{// boolean for checking whether the lineage actually exists at the end. If all children of the lineages have}
    \PYG{c+c1}{// speciated, then the lineage no longer exists.}
    \PYG{k+kt}{bool} \PYG{n}{speciated}\PYG{p}{;}
    \PYG{c+c1}{// the species identity of the node}
    \PYG{k+kt}{bool} \PYG{n}{does\PYGZus{}exist}\PYG{p}{;}
    \PYG{c+c1}{// the following 4 variables describe the position of the lineage in the present day.}
    \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{species\PYGZus{}id}\PYG{p}{;}
    \PYG{c+c1}{// x position}
    \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{xpos}\PYG{p}{;}
    \PYG{c+c1}{// y position}
    \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{ypos}\PYG{p}{;}
    \PYG{c+c1}{// number of wraps of x around the torus}
    \PYG{k+kt}{long} \PYG{n}{xwrap}\PYG{p}{;}
    \PYG{c+c1}{// number of wraps of y around the torus}
    \PYG{k+kt}{long} \PYG{n}{ywrap}\PYG{p}{;}
    \PYG{c+c1}{// the speciation probability. This needs to be multiplied by the number of generations in order to generate the}
    \PYG{c+c1}{// actual probability.}
    \PYG{k+kt}{long} \PYG{k+kt}{double} \PYG{n}{speciation\PYGZus{}probability}\PYG{p}{;}
    \PYG{c+c1}{// Number of generations this lineage has existed since coalescence (or tracking began).}
    \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{generations\PYGZus{}existed}\PYG{p}{;}
    \PYG{c+c1}{// Simulation generation timer that the lineage was created at}
    \PYG{k+kt}{long} \PYG{k+kt}{double} \PYG{n}{generation\PYGZus{}added}\PYG{p}{;}
\PYG{k}{public}\PYG{o}{:}
    \PYG{n}{TreeNode}\PYG{p}{(}\PYG{p}{)} \PYG{o}{:} \PYG{n}{tip}\PYG{p}{(}\PYG{n+nb}{false}\PYG{p}{)}\PYG{p}{,}\PYG{n}{parent}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{,}\PYG{n}{speciated}\PYG{p}{(}\PYG{n+nb}{false}\PYG{p}{)}\PYG{p}{,}\PYG{n}{does\PYGZus{}exist}\PYG{p}{(}\PYG{n+nb}{false}\PYG{p}{)}\PYG{p}{,}\PYG{n}{species\PYGZus{}id}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{,}\PYG{n}{xpos}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{,}\PYG{n}{ypos}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{,}\PYG{n}{xwrap}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{,}
                 \PYG{n}{ywrap}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{,} \PYG{n}{speciation\PYGZus{}probability}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{,} \PYG{n}{generations\PYGZus{}existed}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{,}\PYG{n}{generation\PYGZus{}added}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}

    \PYG{p}{\PYGZcb{}}

    \PYG{o}{\PYGZti{}}\PYG{n}{TreeNode}\PYG{p}{(}\PYG{p}{)}
    \PYG{o}{=} \PYG{k}{default}\PYG{p}{;}

    \PYG{k+kt}{void} \PYG{n+nf}{setup}\PYG{p}{(}\PYG{k+kt}{bool} \PYG{n}{z}\PYG{p}{,} \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{xp}\PYG{p}{,} \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{yp}\PYG{p}{,} \PYG{k+kt}{long} \PYG{n}{xi}\PYG{p}{,} \PYG{k+kt}{long} \PYG{n}{yi}\PYG{p}{)}\PYG{p}{;}

    \PYG{k+kt}{void} \PYG{n+nf}{setup}\PYG{p}{(}\PYG{k+kt}{bool} \PYG{n}{z}\PYG{p}{)}\PYG{p}{;}

    \PYG{k+kt}{void} \PYG{n+nf}{setup}\PYG{p}{(}\PYG{k}{const} \PYG{k+kt}{bool} \PYG{o}{\PYGZam{}}\PYG{n}{is\PYGZus{}tip}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{xp}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{yp}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{xi}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{long} \PYG{o}{\PYGZam{}}\PYG{n}{yi}\PYG{p}{,}
               \PYG{k}{const} \PYG{k+kt}{long} \PYG{k+kt}{double} \PYG{o}{\PYGZam{}}\PYG{n}{generation}\PYG{p}{)}\PYG{p}{;}

    \PYG{k+kt}{void} \PYG{n+nf}{setExistence}\PYG{p}{(}\PYG{k+kt}{bool} \PYG{n}{b}\PYG{p}{)}\PYG{p}{;}

    \PYG{k+kt}{void} \PYG{n+nf}{setParent}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{x}\PYG{p}{)}\PYG{p}{;}

    \PYG{k+kt}{void} \PYG{n+nf}{qReset}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

    \PYG{k+kt}{void} \PYG{n+nf}{setPosition}\PYG{p}{(}\PYG{k+kt}{long} \PYG{n}{x}\PYG{p}{,}\PYG{k+kt}{long} \PYG{n}{y}\PYG{p}{,} \PYG{k+kt}{long} \PYG{n}{xw}\PYG{p}{,} \PYG{k+kt}{long} \PYG{n}{yw}\PYG{p}{)}\PYG{p}{;}

    \PYG{k+kt}{void} \PYG{n+nf}{setSpec}\PYG{p}{(}\PYG{k+kt}{long} \PYG{k+kt}{double} \PYG{n}{d}\PYG{p}{)}\PYG{p}{;}

    \PYG{k+kt}{void} \PYG{n+nf}{setGenerationRate}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{g}\PYG{p}{)}\PYG{p}{;}

    \PYG{k+kt}{void} \PYG{n+nf}{setGeneration}\PYG{p}{(}\PYG{k+kt}{long} \PYG{k+kt}{double} \PYG{n}{d}\PYG{p}{)}\PYG{p}{;}

    \PYG{k+kt}{void} \PYG{n+nf}{setSpeciation}\PYG{p}{(}\PYG{k+kt}{bool} \PYG{n}{s}\PYG{p}{)}\PYG{p}{;}

    \PYG{k+kt}{void} \PYG{n+nf}{burnSpecies}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{idin}\PYG{p}{)}\PYG{p}{;}

    \PYG{k+kt}{void} \PYG{n+nf}{setTip}\PYG{p}{(}\PYG{k+kt}{bool} \PYG{n}{b}\PYG{p}{)}\PYG{p}{;}

    \PYG{k+kt}{void} \PYG{n+nf}{resetSpecies}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

    \PYG{k+kt}{void} \PYG{n+nf}{increaseGen}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
    \PYG{c+c1}{// we don\PYGZsq{}t allow the other variables to be changed}
    \PYG{c+c1}{// because they only need to be set once at the start of the coalescence}
    \PYG{c+c1}{// it\PYGZsq{}s actually safer to leave out setters.}
    \PYG{c+c1}{// similarly we don\PYGZsq{}t allow speciation to be changed once it has been set.}

    \PYG{c+c1}{// standard getters}

    \PYG{k+kt}{bool} \PYG{n+nf}{getExistence}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

    \PYG{k+kt}{bool} \PYG{n+nf}{isTip}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

    \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n+nf}{getParent}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

    \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n+nf}{getXpos}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

    \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n+nf}{getYpos}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

    \PYG{k+kt}{long} \PYG{n+nf}{getXwrap}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

    \PYG{k+kt}{long} \PYG{n+nf}{getYwrap}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

    \PYG{k+kt}{bool} \PYG{n+nf}{hasSpeciated}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

    \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n+nf}{getSpeciesID}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

    \PYG{k+kt}{long} \PYG{k+kt}{double} \PYG{n+nf}{getSpecRate}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

    \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n+nf}{getGenRate}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

    \PYG{k+kt}{long} \PYG{k+kt}{double} \PYG{n+nf}{getGeneration}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

    \PYG{k+kt}{void} \PYG{n+nf}{speciate}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}



    \PYG{k}{friend} \PYG{n}{ostream}\PYG{o}{\PYGZam{}} \PYG{k}{operator}\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{p}{(}\PYG{n}{ostream}\PYG{o}{\PYGZam{}} \PYG{n}{os}\PYG{p}{,}\PYG{k}{const} \PYG{n}{TreeNode}\PYG{o}{\PYGZam{}} \PYG{n}{t}\PYG{p}{)}\PYG{p}{;}

    \PYG{k}{friend} \PYG{n}{istream}\PYG{o}{\PYGZam{}} \PYG{k}{operator}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{n}{istream}\PYG{o}{\PYGZam{}} \PYG{n}{is}\PYG{p}{,}\PYG{n}{TreeNode}\PYG{o}{\PYGZam{}} \PYG{n}{t}\PYG{p}{)}\PYG{p}{;}

    \PYG{n}{TreeNode} \PYG{o}{\PYGZam{}} \PYG{k}{operator}\PYG{o}{=}\PYG{p}{(}\PYG{k}{const} \PYG{n}{TreeNode} \PYG{o}{\PYGZam{}}\PYG{n}{t}\PYG{p}{)}\PYG{p}{;}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifdef DEBUG}

    \PYG{k+kt}{void} \PYG{n+nf}{logLineageInformation}\PYG{p}{(}\PYG{k}{const} \PYG{k+kt}{int} \PYG{o}{\PYGZam{}}\PYG{n}{level}\PYG{p}{)}\PYG{p}{;}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif }\PYG{c+c1}{// DEBUG}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif}
\end{sphinxVerbatim}


\subsubsection{Detailed Description}
\label{\detokenize{api/file_necsim_TreeNode.h:detailed-description}}
Samuel Thompson
{\hyperref[\detokenize{api/class_TreeNode:class-treenode}]{\sphinxcrossref{\DUrole{std,std-ref}{Class TreeNode}}}} objects are used both during simulation runs and afterwards, when different calculations need to be performed on the coalescence tree.


\subsubsection{Includes}
\label{\detokenize{api/file_necsim_TreeNode.h:includes}}\begin{itemize}
\item {} 
\sphinxcode{Logging.h} ({\hyperref[\detokenize{api/file_necsim_Logging.h:file-necsim-logging-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File Logging.h}}}})

\item {} 
\sphinxcode{cstdio}

\item {} 
\sphinxcode{iomanip}

\item {} 
\sphinxcode{iostream}

\end{itemize}


\subsubsection{Included By}
\label{\detokenize{api/file_necsim_TreeNode.h:included-by}}\begin{itemize}
\item {} 
{\hyperref[\detokenize{api/file_necsim_Community.h:file-necsim-community-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File Community.h}}}}

\item {} 
{\hyperref[\detokenize{api/file_necsim_Tree.h:file-necsim-tree-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File Tree.h}}}}

\item {} 
{\hyperref[\detokenize{api/file_necsim_SpatialTree.h:file-necsim-spatialtree-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File SpatialTree.h}}}}

\item {} 
{\hyperref[\detokenize{api/file_necsim_SpeciationCommands.h:file-necsim-speciationcommands-h}]{\sphinxcrossref{\DUrole{std,std-ref}{File SpeciationCommands.h}}}}

\item {} 
{\hyperref[\detokenize{api/file_necsim_TreeNode.cpp:file-necsim-treenode-cpp}]{\sphinxcrossref{\DUrole{std,std-ref}{File TreeNode.cpp}}}}

\end{itemize}


\subsubsection{Classes}
\label{\detokenize{api/file_necsim_TreeNode.h:classes}}\begin{itemize}
\item {} 
{\hyperref[\detokenize{api/class_TreeNode:class-treenode}]{\sphinxcrossref{\DUrole{std,std-ref}{Class TreeNode}}}}

\end{itemize}


\chapter{Code Documentation}
\label{\detokenize{index:code-documentation}}

\section{Modules}
\label{\detokenize{modules:modules}}\label{\detokenize{modules::doc}}

\subsection{pycoalescence package}
\label{\detokenize{pycoalescence:module-pycoalescence}}\label{\detokenize{pycoalescence::doc}}\label{\detokenize{pycoalescence:pycoalescence-package}}\index{pycoalescence (module)}
pycoalescence provides the facilities for running spatially-explicit neutral coalescence ecological simulations
and performing basic analysis of the simulation outputs. The program requires necsim to function properly.


\subsubsection{Module Contents}
\label{\detokenize{pycoalescence:module-contents}}

\subsubsection{Submodules}
\label{\detokenize{pycoalescence:submodules}}

\paragraph{batch\_process module}
\label{\detokenize{pycoalescence:batch-process-module}}\label{\detokenize{pycoalescence:module-pycoalescence.batch_process}}\index{pycoalescence.batch\_process (module)}
Contains the operations for performing batch analysis on multiple outputs of a PyCoalescence simulation.


\paragraph{coalescence\_tree module}
\label{\detokenize{pycoalescence:coalescence-tree-module}}
Detailed \DUrole{xref,std,std-ref}{here}.
\phantomsection\label{\detokenize{pycoalescence:module-pycoalescence.coalescence_tree}}\index{pycoalescence.coalescence\_tree (module)}
Contains basic analyses for the output of a pycoalescence simulation.
\index{CoalescenceTree (class in pycoalescence.coalescence\_tree)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pycoalescence:pycoalescence.coalescence_tree.CoalescenceTree}}\pysiglinewithargsret{\sphinxstrong{class }\sphinxbfcode{CoalescenceTree}}{\emph{database=None}, \emph{logging\_level=30}, \emph{log\_output=None}}{}
Bases: \sphinxcode{object}

Contains the coalescence tree and performs various calculations of different biodiversity metrics, which are then
stored in the SQLite database.

The general process is
\begin{itemize}
\item {} 
Import the database ({\hyperref[\detokenize{pycoalescence:pycoalescence.coalescence_tree.CoalescenceTree.set_database}]{\sphinxcrossref{\sphinxcode{set\_database()}}}}) and import the comparison data,
if required ({\hyperref[\detokenize{pycoalescence:pycoalescence.coalescence_tree.CoalescenceTree.import_comparison_data}]{\sphinxcrossref{\sphinxcode{import\_comparison\_data()}}}})

\item {} 
Apply additional speciation rates (if required) using {\hyperref[\detokenize{pycoalescence:pycoalescence.coalescence_tree.CoalescenceTree.set_speciation_params}]{\sphinxcrossref{\sphinxcode{set\_speciation\_params()}}}} and then
{\hyperref[\detokenize{pycoalescence:pycoalescence.coalescence_tree.CoalescenceTree.apply_speciation}]{\sphinxcrossref{\sphinxcode{apply\_speciation()}}}}

\item {} 
Calculate required metrics (such as {\hyperref[\detokenize{pycoalescence:pycoalescence.coalescence_tree.CoalescenceTree.calculate_fragment_richness}]{\sphinxcrossref{\sphinxcode{calculate\_fragment\_richness()}}}})

\item {} 
Optionally, calculate the goodness of fit ({\hyperref[\detokenize{pycoalescence:pycoalescence.coalescence_tree.CoalescenceTree.calculate_goodness_of_fit}]{\sphinxcrossref{\sphinxcode{calculate\_goodness\_of\_fit()}}}})

\end{itemize}
\index{adjust\_data() (CoalescenceTree method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pycoalescence:pycoalescence.coalescence_tree.CoalescenceTree.adjust_data}}\pysiglinewithargsret{\sphinxbfcode{adjust\_data}}{}{}
Ensures that the numbers of individuals are equalised between the comparison and simulated datasets, and
modifies the relevant tables with the new data

\end{fulllineitems}

\index{apply\_speciation() (CoalescenceTree method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pycoalescence:pycoalescence.coalescence_tree.CoalescenceTree.apply_speciation}}\pysiglinewithargsret{\sphinxbfcode{apply\_speciation}}{}{}
Creates the list of speciation options and performs the speciation analysis by calling SpeciationCounter.
This must be run after the main coalescence simulations are complete.
It will create additional fields and tables in the SQLite database which contains the requested data.

\end{fulllineitems}

\index{calculate\_alpha\_diversity() (CoalescenceTree method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pycoalescence:pycoalescence.coalescence_tree.CoalescenceTree.calculate_alpha_diversity}}\pysiglinewithargsret{\sphinxbfcode{calculate\_alpha\_diversity}}{}{}
Calculates the system alpha diversity for each set of parameters stored in COMMUNITY\_PARAMETERS.
Stores the output in ALPHA\_DIVERSITY table.

\end{fulllineitems}

\index{calculate\_beta\_diversity() (CoalescenceTree method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pycoalescence:pycoalescence.coalescence_tree.CoalescenceTree.calculate_beta_diversity}}\pysiglinewithargsret{\sphinxbfcode{calculate\_beta\_diversity}}{}{}
Calculates the beta diversity for the system for each speciation parameter set and stores the output in
BETA\_DIVERSITY.
Will calculate alpha diversity and species richness tables if they have not already been performed.

\end{fulllineitems}

\index{calculate\_comparison\_octaves() (CoalescenceTree method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pycoalescence:pycoalescence.coalescence_tree.CoalescenceTree.calculate_comparison_octaves}}\pysiglinewithargsret{\sphinxbfcode{calculate\_comparison\_octaves}}{\emph{store=False}}{}
Calculates the octave classes for the comparison data and for fragments (if required).
If the octaves exist in the FRAGMENT\_OCTAVES table in the comparison database, the data will be imported
instead of being re-calculated.

Stores the new octave classes in self.comparison\_octaves.

\begin{sphinxadmonition}{note}{Note:}
If store is True, will store an EDITED version of the comparison octaves, such that the number of
individuals is equal between the comparison and simulated data.
\end{sphinxadmonition}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{store} -- if True, stores within the comparison database.

\end{description}\end{quote}

\end{fulllineitems}

\index{calculate\_fragment\_abundances() (CoalescenceTree method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pycoalescence:pycoalescence.coalescence_tree.CoalescenceTree.calculate_fragment_abundances}}\pysiglinewithargsret{\sphinxbfcode{calculate\_fragment\_abundances}}{}{}
Calculates the fragment abundances, including equalising with the comparison database, if it has already been
set.

Sets fragment\_abundances object.

\end{fulllineitems}

\index{calculate\_fragment\_octaves() (CoalescenceTree method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pycoalescence:pycoalescence.coalescence_tree.CoalescenceTree.calculate_fragment_octaves}}\pysiglinewithargsret{\sphinxbfcode{calculate\_fragment\_octaves}}{}{}
Calculates the octave classes for each fragment. Outputs the calculated richness into the SQL database within a
FRAGMENT\_OCTAVES table

\end{fulllineitems}

\index{calculate\_fragment\_richness() (CoalescenceTree method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pycoalescence:pycoalescence.coalescence_tree.CoalescenceTree.calculate_fragment_richness}}\pysiglinewithargsret{\sphinxbfcode{calculate\_fragment\_richness}}{}{}
Calculates the fragment richness and stores it in a new table called FRAGMENT\_RICHNESS. Also adds the record to
BIODIVERSITY METRICS for
If the table already exists, it will simply be returned. Each time point and speciation rate combination will be
recorded as a new variable.

\end{fulllineitems}

\index{calculate\_goodness\_of\_fit() (CoalescenceTree method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pycoalescence:pycoalescence.coalescence_tree.CoalescenceTree.calculate_goodness_of_fit}}\pysiglinewithargsret{\sphinxbfcode{calculate\_goodness\_of\_fit}}{}{}
Calculates the goodness-of-fit measure based on the calculated biodiversity metrics, scaling each metric by the
number of individuals involved in the metric.

This requires that import\_comparison\_data() has already been successfully run.

\begin{sphinxadmonition}{note}{Note:}
This doesn't calculate anything for values which have not yet been written to the
BIODIVERSITY\_METRICS table. All in-built functions (e.g. calculate\_alpha\_diversity,
calculate\_fragment\_richness) write to the BIODIVERSITY\_METRICS table automatically, so this is only relevant
for custom functions.
\end{sphinxadmonition}

The resulting value will then be written to the BIODIVERSITY\_METRICS table in the SQL database.

\end{fulllineitems}

\index{calculate\_octaves() (CoalescenceTree method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pycoalescence:pycoalescence.coalescence_tree.CoalescenceTree.calculate_octaves}}\pysiglinewithargsret{\sphinxbfcode{calculate\_octaves}}{}{}
Calculates the octave classes for the landscape. Outputs the calculated richness into the SQL database within a
FRAGMENT\_OCTAVES table.

\end{fulllineitems}

\index{calculate\_octaves\_error() (CoalescenceTree method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pycoalescence:pycoalescence.coalescence_tree.CoalescenceTree.calculate_octaves_error}}\pysiglinewithargsret{\sphinxbfcode{calculate\_octaves\_error}}{}{}
Calculates the error in octaves classes between the simulated data and the comparison data.
Stores each error value as a new entry in BIODIVERSITY\_METRICS under fragment\_octaves.
Calculates the error by comparing each octave class and summing the relative difference.
Octaves are then averaged for each fragment.

\end{fulllineitems}

\index{calculate\_richness() (CoalescenceTree method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pycoalescence:pycoalescence.coalescence_tree.CoalescenceTree.calculate_richness}}\pysiglinewithargsret{\sphinxbfcode{calculate\_richness}}{}{}
Calculates the landscape richness from across all fragments and stores result in a new table in
SPECIES\_RICHNESS
Stores a separate result for each speciation rate and time.

\end{fulllineitems}

\index{check\_biodiversity\_table\_exists() (CoalescenceTree method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pycoalescence:pycoalescence.coalescence_tree.CoalescenceTree.check_biodiversity_table_exists}}\pysiglinewithargsret{\sphinxbfcode{check\_biodiversity\_table\_exists}}{}{}
Checks whether the biodiversity table exists and creates the table if required.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
the max reference value currently existing

\end{description}\end{quote}

\end{fulllineitems}

\index{clear\_calculations() (CoalescenceTree method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pycoalescence:pycoalescence.coalescence_tree.CoalescenceTree.clear_calculations}}\pysiglinewithargsret{\sphinxbfcode{clear\_calculations}}{}{}
Removes the BIODIVERSITY\_METRICS and FRAGMENT\_OCTAVES tables completely.

\begin{sphinxadmonition}{note}{Note:}
that this cannot be undone (other than re-running the calculations).
\end{sphinxadmonition}

\end{fulllineitems}

\index{dispersal\_parameters() (CoalescenceTree method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pycoalescence:pycoalescence.coalescence_tree.CoalescenceTree.dispersal_parameters}}\pysiglinewithargsret{\sphinxbfcode{dispersal\_parameters}}{}{}
Reads the dispersal parameters from the database and returns them.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
a list of the dispersal parameters {[}sigma, tau, m\_probability, cutoff{]}

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_alpha\_diversity() (CoalescenceTree method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pycoalescence:pycoalescence.coalescence_tree.CoalescenceTree.get_alpha_diversity}}\pysiglinewithargsret{\sphinxbfcode{get\_alpha\_diversity}}{\emph{reference=1}}{}
Gets the system alpha diversity for the provided community reference parameters.
Alpha diversity is the mean number of species per fragment.
:param reference: the community reference for speciation parameters
:return: the alpha diversity of the system

\end{fulllineitems}

\index{get\_beta\_diversity() (CoalescenceTree method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pycoalescence:pycoalescence.coalescence_tree.CoalescenceTree.get_beta_diversity}}\pysiglinewithargsret{\sphinxbfcode{get\_beta\_diversity}}{\emph{reference=1}}{}
Gets the system beta diversity for the provided community reference parameters.
Beta diversity is the true beta diversity (gamma / alpha).
:param reference: the community reference for speciation parameters
:return: the beta diversity of the system

\end{fulllineitems}

\index{get\_community\_parameters() (CoalescenceTree method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pycoalescence:pycoalescence.coalescence_tree.CoalescenceTree.get_community_parameters}}\pysiglinewithargsret{\sphinxbfcode{get\_community\_parameters}}{\emph{reference=1}}{}
Returns a dictionary containing the parameters for the calculated community.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{reference} -- the reference key for the calculated parameters. (default is 1)

\item[{Returns}] \leavevmode
dictionary containing the speciation\_rate, time, fragments and metacommunity\_reference

\item[{Return type}] \leavevmode
dict

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_community\_reference() (CoalescenceTree method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pycoalescence:pycoalescence.coalescence_tree.CoalescenceTree.get_community_reference}}\pysiglinewithargsret{\sphinxbfcode{get\_community\_reference}}{\emph{speciation\_rate}, \emph{time}, \emph{fragments}, \emph{metacommunity\_size=0}, \emph{metacommunity\_speciation\_rate=0.0}}{}
Gets the community reference associated with the supplied community parameters
\begin{quote}\begin{description}
\item[{Raises}] \leavevmode
\sphinxstyleliteralstrong{KeyError} -- if COMMUNITY\_PARAMETERS (or METACOMMUNITY\_PARAMETERS) does not exist in database or no
reference exists for the supplied parameters

\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{speciation\_rate} -- the speciation rate of the community

\item {} 
\sphinxstyleliteralstrong{time} -- the time in generations of the community

\item {} 
\sphinxstyleliteralstrong{fragments} -- whether fragments were determined for the community

\item {} 
\sphinxstyleliteralstrong{metacommunity\_size} -- the metacommunity size

\item {} 
\sphinxstyleliteralstrong{metacommunity\_speciation\_rate} -- the metacommunity speciation rate

\end{itemize}

\item[{Returns}] \leavevmode
the reference associated with this set of simulation parameters

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_community\_references() (CoalescenceTree method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pycoalescence:pycoalescence.coalescence_tree.CoalescenceTree.get_community_references}}\pysiglinewithargsret{\sphinxbfcode{get\_community\_references}}{}{}
Gets a list of all the commuity references already calculated for the simulation.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
list of all calculated community references

\item[{Return type}] \leavevmode
list

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_fragment\_abundances() (CoalescenceTree method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pycoalescence:pycoalescence.coalescence_tree.CoalescenceTree.get_fragment_abundances}}\pysiglinewithargsret{\sphinxbfcode{get\_fragment\_abundances}}{\emph{fragment}, \emph{reference}}{}
Gets the species abundances for the supplied fragment and community reference.
:param fragment: the name of the fragment to obtain
:param reference: the reference for speciation parameters to obtain for
:return: a list of species ids and abundances

\end{fulllineitems}

\index{get\_fragment\_list() (CoalescenceTree method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pycoalescence:pycoalescence.coalescence_tree.CoalescenceTree.get_fragment_list}}\pysiglinewithargsret{\sphinxbfcode{get\_fragment\_list}}{}{}
Returns a list of all fragments that exist in FRAGMENT\_ABUNDANCES.
:return: list all all fragment names

\end{fulllineitems}

\index{get\_fragment\_octaves() (CoalescenceTree method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pycoalescence:pycoalescence.coalescence_tree.CoalescenceTree.get_fragment_octaves}}\pysiglinewithargsret{\sphinxbfcode{get\_fragment\_octaves}}{\emph{fragment=None}, \emph{reference=None}}{}
Get the pre-calculated octave data for the specified fragment, speciation rate and time. If fragment and
speciation\_rate are None, returns the entire FRAGMENT\_OCTAVES object
This requires self.calculate\_fragment\_octaves() to have been run successfully at some point previously.

Returns are of form {[}id, fragment, community\_reference, octave class, number of species{]}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{fragment} -- the desired fragment (defaults to None)

\item {} 
\sphinxstyleliteralstrong{reference} -- the reference key for the calculated community parameters

\end{itemize}

\item[{Returns}] \leavevmode
output from FRAGMENT\_OCTAVES for the selected variables

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_fragment\_richness() (CoalescenceTree method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pycoalescence:pycoalescence.coalescence_tree.CoalescenceTree.get_fragment_richness}}\pysiglinewithargsret{\sphinxbfcode{get\_fragment\_richness}}{\emph{fragment=None}, \emph{reference=None}}{}
Gets the fragment richness for each speciation rate and time for the specified simulation. If the fragment
richness has not yet been calculated, it tries to calculate the fragment richness,
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{fragment} -- the desired fragment (defaults to None)

\item {} 
\sphinxstyleliteralstrong{reference} -- the reference key for the calculated community parameters

\end{itemize}

\item[{Raises}] \leavevmode
sqlite3.OperationalError if no table FRAGMENT\_ABUNDANCES exists

\item[{Raises}] \leavevmode
RuntimeError if no data for the specified fragment, speciation rate and time exists.

\item[{Returns}] \leavevmode
A list containing the fragment richness, or a value of the fragment richness

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_goodness\_of\_fit() (CoalescenceTree method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pycoalescence:pycoalescence.coalescence_tree.CoalescenceTree.get_goodness_of_fit}}\pysiglinewithargsret{\sphinxbfcode{get\_goodness\_of\_fit}}{\emph{reference=1}}{}
Returns the goodness of fit from the file.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{reference} -- the community reference to get from

\item[{Returns}] \leavevmode
the full output from the SQL query

\item[{Return type}] \leavevmode
list

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_goodness\_of\_fit\_fragment\_octaves() (CoalescenceTree method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pycoalescence:pycoalescence.coalescence_tree.CoalescenceTree.get_goodness_of_fit_fragment_octaves}}\pysiglinewithargsret{\sphinxbfcode{get\_goodness\_of\_fit\_fragment\_octaves}}{\emph{reference=1}}{}
Returns the goodness of fit for fragment octaves from the file.
\begin{quote}\begin{description}
\item[{Raises}] \leavevmode
\sphinxstyleliteralstrong{ValueError} -- if BIODIVERSITY\_METRICS table does not exist.

\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{reference} -- the community reference number

\item[{Returns}] \leavevmode
the full output from the SQL query

\item[{Return type}] \leavevmode
list

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_goodness\_of\_fit\_fragment\_richness() (CoalescenceTree method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pycoalescence:pycoalescence.coalescence_tree.CoalescenceTree.get_goodness_of_fit_fragment_richness}}\pysiglinewithargsret{\sphinxbfcode{get\_goodness\_of\_fit\_fragment\_richness}}{\emph{reference=1}}{}
Returns the goodness of fit for fragment richness from the file.
\begin{quote}\begin{description}
\item[{Raises}] \leavevmode
\sphinxstyleliteralstrong{ValueError} -- if BIODIVERSITY\_METRICS table does not exist.

\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{reference} -- the community reference number

\item[{Returns}] \leavevmode
the full output from the SQL query

\item[{Return type}] \leavevmode
float

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_goodness\_of\_fit\_metric() (CoalescenceTree method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pycoalescence:pycoalescence.coalescence_tree.CoalescenceTree.get_goodness_of_fit_metric}}\pysiglinewithargsret{\sphinxbfcode{get\_goodness\_of\_fit\_metric}}{\emph{metric}, \emph{reference=1}}{}
Gets the goodness-of-fit measure for the specified metric and community reference.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{metric} -- the metric goodness of fit has been calculated for to obtain

\item {} 
\sphinxstyleliteralstrong{reference} -- the community reference to fetch fits for

\end{itemize}

\item[{Returns}] \leavevmode
the goodness of fit value

\item[{Return type}] \leavevmode
float

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_job() (CoalescenceTree method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pycoalescence:pycoalescence.coalescence_tree.CoalescenceTree.get_job}}\pysiglinewithargsret{\sphinxbfcode{get\_job}}{}{}
Gets the job number (the seed) and the job type (the task identifier).
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
list containing {[}seed, job\_type (the task identifier){]}

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_landscape\_richness() (CoalescenceTree method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pycoalescence:pycoalescence.coalescence_tree.CoalescenceTree.get_landscape_richness}}\pysiglinewithargsret{\sphinxbfcode{get\_landscape\_richness}}{\emph{reference=1}}{}
Reads the landscape richness from the SPECIES\_RICHNESS table in the database. Returns the richness for
each speciation rate and time.

\begin{sphinxadmonition}{note}{Note:}
This should produce the same result as get\_richness(sr, t) with the corresponding sr and t.
\end{sphinxadmonition}

\begin{sphinxadmonition}{note}{Note:}
Return type of this function changes based on whether speciation rates and times were supplied.
If they were, returns a single integer. Otherwise, returns a list of all species richnesses.
\end{sphinxadmonition}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{speciation\_rate} -- the required speciation rate (optional)

\item {} 
\sphinxstyleliteralstrong{reference} -- the reference key for the calculated community parameters

\end{itemize}

\item[{Returns}] \leavevmode
either a list containing the speciation\_rate, time, richness OR (if specific speciation rate and time
provided), the species richness at that time and speciation rate.

\item[{Return type}] \leavevmode
int, list

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_metacommunity\_parameters() (CoalescenceTree method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pycoalescence:pycoalescence.coalescence_tree.CoalescenceTree.get_metacommunity_parameters}}\pysiglinewithargsret{\sphinxbfcode{get\_metacommunity\_parameters}}{\emph{reference=1}}{}
Returns a dictionary containing the parameters for the calculated community.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{reference} -- the reference key for the calculated parameters. (default is 1)

\item[{Raises}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{sqlite3.OperationalError} -- if the METACOMMUNITY\_PARAMETERS table does not exist, or some other sqlite
error occurs

\item {} 
\sphinxstyleliteralstrong{KeyError} -- if the supplied reference does not exist in the METACOMMUNITY\_PARAMETERS table

\end{itemize}

\item[{Returns}] \leavevmode
dictionary containing the speciation\_rate, time, fragments and metacommunity\_reference

\item[{Return type}] \leavevmode
dict

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_metacommunity\_references() (CoalescenceTree method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pycoalescence:pycoalescence.coalescence_tree.CoalescenceTree.get_metacommunity_references}}\pysiglinewithargsret{\sphinxbfcode{get\_metacommunity\_references}}{}{}
Gets a list of all the metacommuity references already calculated for the simulation.

\begin{sphinxadmonition}{note}{Note:}
Returns an empty list and logs an error message if the METACOMMUNITY\_PARAMETERS table does not exist.
\end{sphinxadmonition}
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
list of all calculated metacommunity references

\item[{Return type}] \leavevmode
list

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_number\_individuals() (CoalescenceTree method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pycoalescence:pycoalescence.coalescence_tree.CoalescenceTree.get_number_individuals}}\pysiglinewithargsret{\sphinxbfcode{get\_number\_individuals}}{\emph{fragment=None}, \emph{community\_reference=None}}{}
Gets the number of individuals that exist, either in the provided fragment, or on the whole landscape.
Counts individuals from FRAGMENT\_ABUNDANCES or SPECIES\_ABUNDANCES, respectively.

If a community reference is provided, only individuals for that time slice will be counted, otherwise a mean is
taken across time slices.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{fragment} -- the name of the fragment to get a count of individuals from

\item[{Returns}] \leavevmode
the number of individuals that exists in the desired location

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_octaves() (CoalescenceTree method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pycoalescence:pycoalescence.coalescence_tree.CoalescenceTree.get_octaves}}\pysiglinewithargsret{\sphinxbfcode{get\_octaves}}{\emph{reference}}{}
Get the pre-calculated octave data for the parameters associated with the supplied reference.
This will call self.calculate\_octaves() if it hasn't been called previously.

Returns are of form {[}id, `whole', time, speciation rate, octave class, number of species{]}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{reference} -- community reference which contains the parameters of interest

\item[{Returns}] \leavevmode
output from FRAGMENT\_OCTAVES on the whole landscape for the selected variables

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_parameter\_description() (CoalescenceTree method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pycoalescence:pycoalescence.coalescence_tree.CoalescenceTree.get_parameter_description}}\pysiglinewithargsret{\sphinxbfcode{get\_parameter\_description}}{\emph{key=None}}{}
Gets the description of the parameter matching the key from those contained in SIMULATION\_PARAMETERS

Simply accesses the \_parameter\_descriptions data stored in parameter\_descriptions.json
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
string containing the parameter description or a dict containing all values if no key is supplied

\item[{Return type}] \leavevmode
str

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_richness() (CoalescenceTree method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pycoalescence:pycoalescence.coalescence_tree.CoalescenceTree.get_richness}}\pysiglinewithargsret{\sphinxbfcode{get\_richness}}{\emph{reference=1}}{}
Get the system richness for the parameters associated with the supplied community reference.

\begin{sphinxadmonition}{note}{Note:}
Richness of 0 is returned if there has been some problem; it is assumed that species richness
will be above 0 for any simulation.
\end{sphinxadmonition}

\begin{sphinxadmonition}{note}{Note:}
Values generated by this method should be identical to those produced by self.get\_landscape\_richness()
\end{sphinxadmonition}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{reference} -- community reference which contains the parameters of interest

\item[{Returns}] \leavevmode
the system species richness

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_simulation\_parameters() (CoalescenceTree method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pycoalescence:pycoalescence.coalescence_tree.CoalescenceTree.get_simulation_parameters}}\pysiglinewithargsret{\sphinxbfcode{get\_simulation\_parameters}}{\emph{guild=None}}{}
Reads the simulation parameters from the database and returns them.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
a dictionary mapping names to values for seed, job\_type, output\_dir, speciation\_rate, sigma, L\_value, deme,

\end{description}\end{quote}

sample\_size, maxtime, dispersal\_relative\_cost, min\_spec, habitat\_change\_rate, gen\_since\_pristine, time\_config,
coarse\_map vars, fine map vars, sample\_file, gridx, gridy, pristine coarse map, pristine fine map, sim\_complete,
dispersal\_method, m\_probability, cutoff, infinite\_landscape, protracted, min\_speciation\_gen, max\_speciation\_gen,
dispersal\_map

\end{fulllineitems}

\index{get\_species\_abundances() (CoalescenceTree method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pycoalescence:pycoalescence.coalescence_tree.CoalescenceTree.get_species_abundances}}\pysiglinewithargsret{\sphinxbfcode{get\_species\_abundances}}{\emph{fragment=None}, \emph{reference=None}}{}
Gets the species abundance for a particular fragment, speciation rate and time. If fragment is None, returns the
whole landscape species abundances.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{fragment} -- the fragment to obtain the species abundance of. If None, returns landscape abundances.

\item {} 
\sphinxstyleliteralstrong{speciation\_rate} -- speciation rate to obtain abundances for

\item {} 
\sphinxstyleliteralstrong{time} -- the time to obtain abundances for

\end{itemize}

\item[{Returns}] \leavevmode
list of species abundances {[}reference, species ID, speciation rate, number of individuals, generation{]}

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_species\_list() (CoalescenceTree method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pycoalescence:pycoalescence.coalescence_tree.CoalescenceTree.get_species_list}}\pysiglinewithargsret{\sphinxbfcode{get\_species\_list}}{}{}
Gets the entirety of the SPECIES\_LIST table, returning a tuple with an entry for each row. This can be used to
construct custom analyses of the coalescence tree.

\begin{sphinxadmonition}{note}{Note:}
The species list will be produced in an unprocessed format
\end{sphinxadmonition}
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
a list of each coalescence and speciation event, with locations, performed in the simulation

\item[{Return type}] \leavevmode
tuple

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_species\_locations() (CoalescenceTree method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pycoalescence:pycoalescence.coalescence_tree.CoalescenceTree.get_species_locations}}\pysiglinewithargsret{\sphinxbfcode{get\_species\_locations}}{\emph{community\_reference=None}}{}
Gets the list of species locations after coalescence.

If a community reference is provided, will return just the species for that community reference, otherwise
returns the whole table
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{community\_reference} (\sphinxstyleliteralemphasis{int}) -- community reference number

\item[{Returns}] \leavevmode
a list of lists containing each row of the SPECIES\_LOCATIONS table

\end{description}\end{quote}

\end{fulllineitems}

\index{import\_comparison\_data() (CoalescenceTree method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pycoalescence:pycoalescence.coalescence_tree.CoalescenceTree.import_comparison_data}}\pysiglinewithargsret{\sphinxbfcode{import\_comparison\_data}}{\emph{filename}, \emph{ignore\_mismatch=False}}{}
Imports the SQL database that contains the biodiversity metrics that we want to compare against.

This can either be real data (for comparing simulated data) or other simulated data (for comparing between models).

If the SQL database does not contain the relevant biodiversity metrics, they will be calculated (if possible) or skipped.

The expected form of the database is the same as the BIODIVERSITY\_METRICS table, except without any speciation
rates or time references, and a new column containing the number of individuals involved in each metric.

\begin{sphinxadmonition}{note}{Note:}
This also equalises the comparison data if ignore\_mismatch is not True, so that the number of individuals
is equal between the simulated and comparison datasets.
\end{sphinxadmonition}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{filename} (\sphinxstyleliteralemphasis{str}) -- the file containing the comparison biodiversity metrics.

\item {} 
\sphinxstyleliteralstrong{ignore\_mismatch} (\sphinxstyleliteralemphasis{bool}) -- set to true to ignore abundance mismatches between the comparison and simulated data.

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{is\_completed() (CoalescenceTree method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pycoalescence:pycoalescence.coalescence_tree.CoalescenceTree.is_completed}}\pysiglinewithargsret{\sphinxbfcode{is\_completed}}{}{}
Indicates whether the simulation has been performed to completion, or if the simulation has been paused and
needs to be completed before analysis can be performed.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
bool: true if simulation is complete

\end{description}\end{quote}

\end{fulllineitems}

\index{is\_protracted() (CoalescenceTree method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pycoalescence:pycoalescence.coalescence_tree.CoalescenceTree.is_protracted}}\pysiglinewithargsret{\sphinxbfcode{is\_protracted}}{}{}
Indicates whether the simulation is a protracted simulation or not. This is read from the completed database file.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
boolean, true if the simulation was performed with protracted speciation.

\end{description}\end{quote}

\end{fulllineitems}

\index{sample\_fragment\_richness() (CoalescenceTree method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pycoalescence:pycoalescence.coalescence_tree.CoalescenceTree.sample_fragment_richness}}\pysiglinewithargsret{\sphinxbfcode{sample\_fragment\_richness}}{\emph{fragment}, \emph{number\_of\_individuals}, \emph{community\_reference=1}, \emph{n=1}}{}
Samples from the database from FRAGMENT\_ABUNDANCES, the desired number of individuals.

Randomly selects the desired number of individuals from the database n times and returns the mean richness for
the random samples.
\begin{quote}\begin{description}
\item[{Raises}] \leavevmode
\sphinxstyleliteralstrong{IOError} -- if the FRAGMENT\_ABUNDANCES table does not exist in the database.

\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{fragment} -- the reference of the fragment to aquire the richness for

\item {} 
\sphinxstyleliteralstrong{number\_of\_individuals} -- the number of individuals to sample

\item {} 
\sphinxstyleliteralstrong{community\_reference} -- the reference for the community parameters

\item {} 
\sphinxstyleliteralstrong{n} -- number of times to repeatedly sample

\end{itemize}

\item[{Returns}] \leavevmode
the mean of the richness from the repeats

\item[{Return type}] \leavevmode
float

\end{description}\end{quote}

\end{fulllineitems}

\index{sample\_landscape\_richness() (CoalescenceTree method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pycoalescence:pycoalescence.coalescence_tree.CoalescenceTree.sample_landscape_richness}}\pysiglinewithargsret{\sphinxbfcode{sample\_landscape\_richness}}{\emph{number\_of\_individuals}, \emph{n=1}, \emph{community\_reference=1}}{}
Samples from the landscape the required number of individuals, returning the mean of the species richnesses
produced.

If number\_of\_individuals is a dictionary mapping fragment names to numbers sampled, will sample the respective
number from each fragment and return the whole landscape richness.
\begin{quote}\begin{description}
\item[{Raises}] \leavevmode
\sphinxstyleliteralstrong{KeyError} -- if the dictionary supplied contains more sampled individuals than exist in a fragment, or
if the fragment is not contained within the dictionary.

\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{number\_of\_individuals} (\sphinxstyleliteralemphasis{int/dict}) -- either an int containing the number of individuals to be sampled, or a
dictionary mapping fragment names to numbers of individuals to be sampled

\item {} 
\sphinxstyleliteralstrong{n} -- the number of repeats to average over

\item {} 
\sphinxstyleliteralstrong{community\_reference} -- the community reference to fetch abundances for

\end{itemize}

\item[{Returns}] \leavevmode
the mean of the richness from the repeats for the whole landscape

\item[{Return type}] \leavevmode
float

\end{description}\end{quote}

\end{fulllineitems}

\index{set\_database() (CoalescenceTree method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pycoalescence:pycoalescence.coalescence_tree.CoalescenceTree.set_database}}\pysiglinewithargsret{\sphinxbfcode{set\_database}}{\emph{filename}}{}
Sets the database to the specified file and opens the sqlite connection.

This must be done before any other operations can be performed and the
file must exist.
\begin{quote}\begin{description}
\item[{Raises}] \leavevmode
\sphinxstyleliteralstrong{IOError} -- if the simulation is not complete, as analysis can only be performed on complete simulations.
However, the database WILL be set before the error is thrown, allowing for analysis of
incomplete simulations if the error is handled correctly.

\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{filename} -- the SQLite database file to import

\end{description}\end{quote}

\end{fulllineitems}

\index{set\_speciation\_params() (CoalescenceTree method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pycoalescence:pycoalescence.coalescence_tree.CoalescenceTree.set_speciation_params}}\pysiglinewithargsret{\sphinxbfcode{set\_speciation\_params}}{\emph{record\_spatial}, \emph{record\_fragments}, \emph{speciation\_rates}, \emph{sample\_file=None}, \emph{time\_config\_file=None}, \emph{protracted\_speciation\_min=None}, \emph{protracted\_speciation\_max=None}, \emph{metacommunity\_size=None}, \emph{metacommunity\_speciation\_rate=None}}{}
Set the parameters for the application of speciation rates. If no config files or time\_config files are provided,
they will be taken from the main coalescence simulation.
\begin{quote}\begin{description}
\item[{Return type}] \leavevmode
None

\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{str record\_spatial} (\sphinxstyleliteralemphasis{bool}\sphinxstyleliteralemphasis{,}) -- a boolean of whether to record spatial data

\item {} 
\sphinxstyleliteralstrong{str record\_fragments} (\sphinxstyleliteralemphasis{bool}\sphinxstyleliteralemphasis{,}) -- either a csv file containing fragment data, or T/F for whether fragments should be
calculated from squares of continuous habitat.

\item {} 
\sphinxstyleliteralstrong{speciation\_rates} (\sphinxstyleliteralemphasis{list}) -- a list of speciation rates to apply

\item {} 
\sphinxstyleliteralstrong{sample\_file} (\sphinxstyleliteralemphasis{str}) -- a sample tif or csv specifying the sampling mask

\item {} 
\sphinxstyleliteralstrong{time\_config\_file} (\sphinxstyleliteralemphasis{str}) -- a configuration file of temporal sampling points

\item {} 
\sphinxstyleliteralstrong{protracted\_speciation\_min} (\sphinxstyleliteralemphasis{float}) -- the minimum number of generations required for speciation to occur

\item {} 
\sphinxstyleliteralstrong{protracted speciation\_max} (\sphinxstyleliteralemphasis{float}) -- the maximum number of generations before speciation occurs

\item {} 
\sphinxstyleliteralstrong{metacommunity\_size} (\sphinxstyleliteralemphasis{float}) -- the size of the metacommunity to apply

\item {} 
\sphinxstyleliteralstrong{metacommunity\_speciation\_rate} (\sphinxstyleliteralemphasis{float}) -- speciation rate for the metacommunity

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{setup() (CoalescenceTree method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pycoalescence:pycoalescence.coalescence_tree.CoalescenceTree.setup}}\pysiglinewithargsret{\sphinxbfcode{setup}}{\emph{speciation\_program='/Users/samthompson/Documents/PhD/Code/pycoalescence/pycoalescence/build/default/SpeciationCounter'}}{}
Sets up the link to the SpeciationCounter program. Defaults to the build/default/SpeciationCounter
:param speciation\_program: optionally provide a path to an alternative SpeciationCounter program.

\DUrole{versionmodified}{Deprecated since version 1.2.4: }Deprecated due to movement towards using python API for applying speciation rates.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
None

\end{description}\end{quote}

\end{fulllineitems}

\index{wipe\_data() (CoalescenceTree method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pycoalescence:pycoalescence.coalescence_tree.CoalescenceTree.wipe_data}}\pysiglinewithargsret{\sphinxbfcode{wipe\_data}}{}{}
Wipes all calculated data apart from the original, unformatted coalescence tree.
The Speciation\_Counter program will have to be re-run to perform any analyses.

\end{fulllineitems}


\end{fulllineitems}

\index{check\_sql\_table\_exist() (in module pycoalescence.coalescence\_tree)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pycoalescence:pycoalescence.coalescence_tree.check_sql_table_exist}}\pysiglinewithargsret{\sphinxbfcode{check\_sql\_table\_exist}}{\emph{database}, \emph{table\_name}}{}
Checks that the supplied table exists in the supplied database.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{database} -- the database to check existence in

\item {} 
\sphinxstyleliteralstrong{table\_name} -- the table name to check for

\end{itemize}

\item[{Returns}] \leavevmode
boolean of whether the table exists

\item[{Return type}] \leavevmode
bool

\end{description}\end{quote}

\end{fulllineitems}

\index{collate\_fits() (in module pycoalescence.coalescence\_tree)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pycoalescence:pycoalescence.coalescence_tree.collate_fits}}\pysiglinewithargsret{\sphinxbfcode{collate\_fits}}{\emph{file\_dir}, \emph{filename='Collated\_fits.db'}}{}
Collates the goodness of fit values from every file in the specified directory and places them in one new file.

\begin{sphinxadmonition}{note}{Note:}
Files with `collated' in the name will be ignored.
\end{sphinxadmonition}

\begin{sphinxadmonition}{note}{Note:}
If the output file exists, it will be deleted.
\end{sphinxadmonition}

Creates three separate tables in the output file, one for overall goodness of fit, one for fragment richness fits,
and one for fragment octaves fits.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{file\_dir} -- the file directory to examine

\item {} 
\sphinxstyleliteralstrong{filename} -- {[}optional{]} the output file name.

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{fetch\_table\_from\_sql() (in module pycoalescence.coalescence\_tree)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pycoalescence:pycoalescence.coalescence_tree.fetch_table_from_sql}}\pysiglinewithargsret{\sphinxbfcode{fetch\_table\_from\_sql}}{\emph{database}, \emph{table\_name}}{}
Returns a list of the data contained by the provided table in the database.
\begin{quote}\begin{description}
\item[{Raises}] \leavevmode
\sphinxstyleliteralstrong{sqlite3.OperationalError} -- if the table is not contained in the database (protects SQL injections).

\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{database} -- the database to obtain from

\item {} 
\sphinxstyleliteralstrong{table\_name} -- the table name to fetch data from

\end{itemize}

\item[{Returns}] \leavevmode
a list of lists, containing all data within the provided table in the database

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_parameter\_description() (in module pycoalescence.coalescence\_tree)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pycoalescence:pycoalescence.coalescence_tree.get_parameter_description}}\pysiglinewithargsret{\sphinxbfcode{get\_parameter\_description}}{\emph{key=None}}{}
Gets the parameter descriptions for the supplied key. If the key is None, returns all keys.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{key} -- the simulation parameter

\item[{Returns}] \leavevmode
string containing the parameter description or a dict containing all values if no key is supplied

\end{description}\end{quote}

\end{fulllineitems}

\index{isclose() (in module pycoalescence.coalescence\_tree)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pycoalescence:pycoalescence.coalescence_tree.isclose}}\pysiglinewithargsret{\sphinxbfcode{isclose}}{\emph{a}, \emph{b}, \emph{rel\_tol=1e-09}, \emph{abs\_tol=0.0}}{}~\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{a} -- value 1

\item {} 
\sphinxstyleliteralstrong{b} -- value 2

\item {} 
\sphinxstyleliteralstrong{rel\_tol} -- percentage relative to larger value

\item {} 
\sphinxstyleliteralstrong{abs\_tol} -- absolute value for similarity

\end{itemize}

\item[{Returns}] \leavevmode
true for significantly different a and b, false otherwise

\end{description}\end{quote}

\end{fulllineitems}

\index{scale\_simulation\_fit() (in module pycoalescence.coalescence\_tree)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pycoalescence:pycoalescence.coalescence_tree.scale_simulation_fit}}\pysiglinewithargsret{\sphinxbfcode{scale\_simulation\_fit}}{\emph{simulated\_value}, \emph{actual\_value}, \emph{number\_individuals}, \emph{total\_individuals}}{}
Calculates goodness of fit for the provided values, and scales based on the total number of individuals that exist.
The calculation is 1 - ({\color{red}\bfseries{}\textbar{}x - y\textbar{}}/max(x, y)) * n/n\_tot for x, y simulated and actual values, n, n\_tot for metric and total
number of individuals.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{simulated\_value} -- the simulated value of the metric

\item {} 
\sphinxstyleliteralstrong{actual\_value} -- the actual value of the metric

\item {} 
\sphinxstyleliteralstrong{number\_individuals} -- the number of individuals this metric relates to

\item {} 
\sphinxstyleliteralstrong{total\_individuals} -- the total number of individuals across all sites for this metric

\end{itemize}

\item[{Returns}] \leavevmode
the scaled fit value

\end{description}\end{quote}

\end{fulllineitems}



\paragraph{simulation module}
\label{\detokenize{pycoalescence:simulation-module}}
Detailed {\hyperref[\detokenize{README_pycoalescence:performing-simulations}]{\sphinxcrossref{\DUrole{std,std-ref}{here}}}}.
\phantomsection\label{\detokenize{pycoalescence:module-pycoalescence.simulation}}\index{pycoalescence.simulation (module)}
Contains the Simulation class as part of the pycoalescence package.

Operations involve setting up and running simulations, plus basic tree generation after simulations have been completed.
\index{FileExistsError}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pycoalescence:pycoalescence.simulation.FileExistsError}}\pysigline{\sphinxstrong{exception }\sphinxbfcode{FileExistsError}}
Bases: \sphinxcode{exceptions.IOError}

\end{fulllineitems}

\index{FileNotFoundError}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pycoalescence:pycoalescence.simulation.FileNotFoundError}}\pysigline{\sphinxstrong{exception }\sphinxbfcode{FileNotFoundError}}
Bases: \sphinxcode{exceptions.IOError}

\end{fulllineitems}

\index{Simulation (class in pycoalescence.simulation)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pycoalescence:pycoalescence.simulation.Simulation}}\pysiglinewithargsret{\sphinxstrong{class }\sphinxbfcode{Simulation}}{\emph{logging\_level=30}, \emph{log\_output=None}, \emph{**kwargs}}{}
A class containing routines to set up and run simulations, including detecting map dimensions from tif files.
\index{add\_pristine\_map() (Simulation method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pycoalescence:pycoalescence.simulation.Simulation.add_pristine_map}}\pysiglinewithargsret{\sphinxbfcode{add\_pristine\_map}}{\emph{fine\_map}, \emph{coarse\_map}, \emph{time}, \emph{rate}}{}
Adds an extra map to the list of pristine maps.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{fine\_map} -- the pristine fine map file to add

\item {} 
\sphinxstyleliteralstrong{coarse\_map} -- the pristine coarse map file to add

\item {} 
\sphinxstyleliteralstrong{time} -- the time to add (when the map is accurate)

\item {} 
\sphinxstyleliteralstrong{rate} -- the rate to add (the rate of habitat change at this time)

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{add\_sample\_time() (Simulation method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pycoalescence:pycoalescence.simulation.Simulation.add_sample_time}}\pysiglinewithargsret{\sphinxbfcode{add\_sample\_time}}{\emph{time}}{}
Adds an extra sample time to the list of times.

This allows for multiple temporal sample points from within the same simulation.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{time} -- the sample time to add

\end{description}\end{quote}

\end{fulllineitems}

\index{calculate\_sql\_database() (Simulation method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pycoalescence:pycoalescence.simulation.Simulation.calculate_sql_database}}\pysiglinewithargsret{\sphinxbfcode{calculate\_sql\_database}}{}{}
Saves the output database location to self.output\_database.

\end{fulllineitems}

\index{check\_maps() (Simulation method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pycoalescence:pycoalescence.simulation.Simulation.check_maps}}\pysiglinewithargsret{\sphinxbfcode{check\_maps}}{}{}
Checks that the maps all exist and that the file structure makes sense.
\begin{quote}\begin{description}
\item[{Raises}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{TypeError} -- if a dispersal map or reproduction map is specified, we must have a fine map specified, but
not a coarse map.

\item {} 
\sphinxstyleliteralstrong{IOError} -- if one of the required maps does not exist

\end{itemize}

\item[{Returns}] \leavevmode
None

\end{description}\end{quote}

\end{fulllineitems}

\index{check\_sample\_map\_equals\_sample\_grid() (Simulation method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pycoalescence:pycoalescence.simulation.Simulation.check_sample_map_equals_sample_grid}}\pysiglinewithargsret{\sphinxbfcode{check\_sample\_map\_equals\_sample\_grid}}{}{}
Checks if the grid and sample map are the same size and offset (in which case, future operations can be simplified\sphinxquotedblright{}
:return:

\end{fulllineitems}

\index{check\_simulation\_params() (Simulation method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pycoalescence:pycoalescence.simulation.Simulation.check_simulation_params}}\pysiglinewithargsret{\sphinxbfcode{check\_simulation\_params}}{}{}
Checks that simulation parameters have been correctly set and the program is ready for running.
Note that these checks have not been fully tested and are probably unnecessary in a large number of cases.

\end{fulllineitems}

\index{check\_sql\_database() (Simulation method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pycoalescence:pycoalescence.simulation.Simulation.check_sql_database}}\pysiglinewithargsret{\sphinxbfcode{check\_sql\_database}}{\emph{expected=False}}{}
Checks whether the output database exists. If the existance does not match the expected variable, raises an
error.
\begin{quote}\begin{description}
\item[{Raises}] \leavevmode\begin{itemize}
\item {} 
{\hyperref[\detokenize{pycoalescence:pycoalescence.fragments.FileExistsError}]{\sphinxcrossref{\sphinxstyleliteralstrong{FileExistsError}}}} -- if the file already exists when it's not expected to

\item {} 
\sphinxstyleliteralstrong{FileNotExistsError} -- if the file does not exist when we expect it to

\end{itemize}

\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{expected} -- boolean for expected existance of the output file

\end{description}\end{quote}

:rtype None

\end{fulllineitems}

\index{count\_individuals() (Simulation method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pycoalescence:pycoalescence.simulation.Simulation.count_individuals}}\pysiglinewithargsret{\sphinxbfcode{count\_individuals}}{}{}
Estimates the number of individuals to be simulated. This may be inaccurate if using multiple time points and
historical maps.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
a count of the number of individuals to be simulated

\end{description}\end{quote}

:rtype float

\end{fulllineitems}

\index{create\_config() (Simulation method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pycoalescence:pycoalescence.simulation.Simulation.create_config}}\pysiglinewithargsret{\sphinxbfcode{create\_config}}{\emph{output\_file=None}}{}
Generates the output config files. This version creates the concise version of the config file.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{output\_file} (\sphinxstyleliteralemphasis{str}) -- the file to generate the config option. Must be a path to a .txt file.

\end{description}\end{quote}

\end{fulllineitems}

\index{create\_map\_config() (Simulation method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pycoalescence:pycoalescence.simulation.Simulation.create_map_config}}\pysiglinewithargsret{\sphinxbfcode{create\_map\_config}}{\emph{output\_file=None}}{}
Generates the map config file from reading the spatial structure of each of the provided files.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{output\_file} (\sphinxstyleliteralemphasis{str}) -- the file to output configuration data to (the map config file)

\end{description}\end{quote}

\end{fulllineitems}

\index{create\_temporal\_sampling\_config() (Simulation method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pycoalescence:pycoalescence.simulation.Simulation.create_temporal_sampling_config}}\pysiglinewithargsret{\sphinxbfcode{create\_temporal\_sampling\_config}}{\emph{config\_file=None}}{}
Creates the time-sampling config file
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{config\_file} -- the config file to output to

\end{description}\end{quote}

\end{fulllineitems}

\index{detect\_map\_dimensions() (Simulation method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pycoalescence:pycoalescence.simulation.Simulation.detect_map_dimensions}}\pysiglinewithargsret{\sphinxbfcode{detect\_map\_dimensions}}{}{}
Detects all the map dimensions for the provided files (where possible) and sets the respective values.
This is intended to be run after set\_map\_files()
\begin{quote}\begin{description}
\item[{Raises}] \leavevmode
\sphinxstyleliteralstrong{TypeError} -- if a dispersal map or reproduction map is specified, we must have a fine map specified, but

\end{description}\end{quote}

not a coarse map.
:raises IOError: if one of the required maps does not exist
:raises ValueError: if the dimensions of the dispersal map do not make sense when used with the fine map
provided
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
None

\end{description}\end{quote}

\end{fulllineitems}

\index{estimate\_ram\_usage() (Simulation method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pycoalescence:pycoalescence.simulation.Simulation.estimate_ram_usage}}\pysiglinewithargsret{\sphinxbfcode{estimate\_ram\_usage}}{\emph{grid\_individuals}}{}
Estimates the RAM usage for the program with the current parameters.

Note this estimates the upper bound of memory usage and is likely inaccurate, especially for simulations with
multiple time sampling points.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{grid\_individuals} -- the number of individuals existing on the grid

\item[{Returns}] \leavevmode
the estimated RAM usage in bytes

\end{description}\end{quote}

:rtype float

\end{fulllineitems}

\index{finalise\_setup() (Simulation method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pycoalescence:pycoalescence.simulation.Simulation.finalise_setup}}\pysiglinewithargsret{\sphinxbfcode{finalise\_setup}}{\emph{config\_default=True}, \emph{expected=False}, \emph{ignore\_errors=False}}{}
Runs all setup routines to provide a complete simulation. Should be called immediately before run\_coalescence()
to ensure the simulation setup is complete.
Calls check\_simulation\_params, generate\_command() and run\_checks()
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{config\_default} -- set to false if want config file to only be created if necessary. Defaults to True

\item {} 
\sphinxstyleliteralstrong{ignore\_errors} -- if true, any FileNotFoundError and FileExistsError raised by checking the output database

\end{itemize}

\end{description}\end{quote}

are ignored
:param expected: set to true if we expect the output file to exist

\end{fulllineitems}

\index{generate\_command() (Simulation method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pycoalescence:pycoalescence.simulation.Simulation.generate_command}}\pysiglinewithargsret{\sphinxbfcode{generate\_command}}{}{}
Completes the setup process by creating the list that will be passed to the c++ executable

\end{fulllineitems}

\index{get\_average\_density() (Simulation method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pycoalescence:pycoalescence.simulation.Simulation.get_average_density}}\pysiglinewithargsret{\sphinxbfcode{get\_average\_density}}{}{}
Gets the average density across the fine map, subsetted for the sample grid.

\end{fulllineitems}

\index{get\_optimised\_solution() (Simulation method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pycoalescence:pycoalescence.simulation.Simulation.get_optimised_solution}}\pysiglinewithargsret{\sphinxbfcode{get\_optimised\_solution}}{}{}
Gets the optimised solution as a dictionary containing the important optimised variables.
This can be read back in with set\_optimised\_solution

:return dict containing the important optimised variables
:rtype dict

\end{fulllineitems}

\index{get\_protracted() (Simulation method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pycoalescence:pycoalescence.simulation.Simulation.get_protracted}}\pysiglinewithargsret{\sphinxbfcode{get\_protracted}}{}{}
Gets whether the simulation pointed to by this object is a protracted simulation or not.

\end{fulllineitems}

\index{get\_richness() (Simulation method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pycoalescence:pycoalescence.simulation.Simulation.get_richness}}\pysiglinewithargsret{\sphinxbfcode{get\_richness}}{\emph{reference=1}}{}
Calls coal\_analyse.get\_richness() with the supplied variables.

Requires successful import of coal\_analyse and sqlite3.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{speciation\_rate} -- the speciation rate to extract system richness from.

\item {} 
\sphinxstyleliteralstrong{time} -- the time to extract system richness from

\end{itemize}

\item[{Returns}] \leavevmode
the species richness.

\end{description}\end{quote}

\end{fulllineitems}

\index{grid\_density\_actual() (Simulation method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pycoalescence:pycoalescence.simulation.Simulation.grid_density_actual}}\pysiglinewithargsret{\sphinxbfcode{grid\_density\_actual}}{\emph{x\_off}, \emph{y\_off}, \emph{x\_dim}, \emph{y\_dim}}{}
Counts the density total for a subset of the grid by sampling from the fine map.

Note that for large maps this can take a very long time.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{x\_off} -- the x offset of the grid map subset

\item {} 
\sphinxstyleliteralstrong{y\_off} -- the y offset of the grid map subset

\item {} 
\sphinxstyleliteralstrong{x\_dim} -- the x dimension of the grid map subset

\item {} 
\sphinxstyleliteralstrong{y\_dim} -- the y dimension of the grid map subset

\end{itemize}

\item[{Returns}] \leavevmode
the total individuals that exist in the subset.

\end{description}\end{quote}

:rtype int

\end{fulllineitems}

\index{grid\_density\_estimate() (Simulation method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pycoalescence:pycoalescence.simulation.Simulation.grid_density_estimate}}\pysiglinewithargsret{\sphinxbfcode{grid\_density\_estimate}}{\emph{x\_off}, \emph{y\_off}, \emph{x\_dim}, \emph{y\_dim}}{}
Counts the density total for a subset of the grid by sampling from the fine map

Note that this function is an approximation (based on the average density of the fine map) and does not produce
a perfect value. This is done for performance reasons. The actual value can be obtained with
grid\_density\_actual().
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{x\_off} -- the x offset of the grid map subset

\item {} 
\sphinxstyleliteralstrong{y\_off} -- the y offset of the grid map subset

\item {} 
\sphinxstyleliteralstrong{x\_dim} -- the x dimension of the grid map subset

\item {} 
\sphinxstyleliteralstrong{y\_dim} -- the y dimension of the grid map subset

\end{itemize}

\item[{Returns}] \leavevmode
an estimate of the total individuals that exist in the subset.

\end{description}\end{quote}

:rtype int

\end{fulllineitems}

\index{import\_fine\_map\_array() (Simulation method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pycoalescence:pycoalescence.simulation.Simulation.import_fine_map_array}}\pysiglinewithargsret{\sphinxbfcode{import\_fine\_map\_array}}{}{}
Imports the fine map array to the in-memory object, subsetted to the same size as the sample grid.
:rtype None

\end{fulllineitems}

\index{import\_sample\_map\_array() (Simulation method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pycoalescence:pycoalescence.simulation.Simulation.import_sample_map_array}}\pysiglinewithargsret{\sphinxbfcode{import\_sample\_map\_array}}{}{}
Imports the sample map array to the in-memory object.
:rtype None

\end{fulllineitems}

\index{load\_config() (Simulation method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pycoalescence:pycoalescence.simulation.Simulation.load_config}}\pysiglinewithargsret{\sphinxbfcode{load\_config}}{\emph{config\_file}}{}
Loads the config file by reading the lines in order.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{config\_file} (\sphinxstyleliteralemphasis{str}) -- the config file to read in.

\end{description}\end{quote}

\end{fulllineitems}

\index{optimise\_ram() (Simulation method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pycoalescence:pycoalescence.simulation.Simulation.optimise_ram}}\pysiglinewithargsret{\sphinxbfcode{optimise\_ram}}{\emph{ram\_limit=None}}{}
Optimises the maps for a specific RAM usage.

If ram\_limit is None, this function does nothing.

:note This function assumes that the c++ compiler has sizeof(long) = 8 bytes for calculating space usage.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{ram\_limit} -- the desired amount of RAM to limit to, in GB

\item[{Raises}] \leavevmode
\sphinxstyleliteralstrong{MemoryError} -- if the desired simulation cannot be compressed into available RAM

\end{description}\end{quote}

\end{fulllineitems}

\index{persistent\_ram\_usage() (Simulation method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pycoalescence:pycoalescence.simulation.Simulation.persistent_ram_usage}}\pysiglinewithargsret{\sphinxbfcode{persistent\_ram\_usage}}{}{}
This is the persistent RAM usage which cannot be optimised by the program for a particular set of maps
:return: the total persistent RAM usage in bytes

\end{fulllineitems}

\index{resume\_coalescence() (Simulation method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pycoalescence:pycoalescence.simulation.Simulation.resume_coalescence}}\pysiglinewithargsret{\sphinxbfcode{resume\_coalescence}}{\emph{pause\_directory}, \emph{seed}, \emph{job\_type}, \emph{max\_time}, \emph{out\_directory=None}, \emph{protracted=None}, \emph{spatial=None}}{}
Resumes the simulation from the specified directory, looking for the simulation with the specified seed and task
referencing.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{pause\_directory} -- the directory to search for the paused simulation

\item {} 
\sphinxstyleliteralstrong{seed} -- the seed of the paused simulation

\item {} 
\sphinxstyleliteralstrong{job\_type} -- the task of the paused simulation

\item {} 
\sphinxstyleliteralstrong{max\_time} -- the maximum time to run simulations for

\item {} 
\sphinxstyleliteralstrong{out\_directory} -- optionally provide an alternative output location. Defaults to same location as

\end{itemize}

\end{description}\end{quote}

pause\_directory
:param bool protracted: protractedness of the simulation
:param bool spatial: if the simulation is to be run with spatial complexity
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
None

\end{description}\end{quote}

\end{fulllineitems}

\index{run\_checks() (Simulation method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pycoalescence:pycoalescence.simulation.Simulation.run_checks}}\pysiglinewithargsret{\sphinxbfcode{run\_checks}}{\emph{expected=False}}{}
Check that the simulation is correctly set up and that all the required files exist.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{expected} -- set to true if we expect the output file to already exist

\item[{Raises}] \leavevmode
\sphinxstyleliteralstrong{RuntimeError} -- if previous set-up routines are not complete

\end{description}\end{quote}

\end{fulllineitems}

\index{run\_coalescence() (Simulation method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pycoalescence:pycoalescence.simulation.Simulation.run_coalescence}}\pysiglinewithargsret{\sphinxbfcode{run\_coalescence}}{}{}
Attempt to run the simulation with the given simulation set-up.
This is the main routine performing the actual simulation which will take a considerable amount of time.

\end{fulllineitems}

\index{run\_from\_config() (Simulation method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pycoalescence:pycoalescence.simulation.Simulation.run_from_config}}\pysiglinewithargsret{\sphinxbfcode{run\_from\_config}}{\emph{logger}, \emph{config\_file}}{}
Calls NECSim to run from config within a new thread
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{logger} -- 

\item {} 
\sphinxstyleliteralstrong{config\_file} -- 

\end{itemize}

\item[{Returns}] \leavevmode


\end{description}\end{quote}

\end{fulllineitems}

\index{run\_simple() (Simulation method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pycoalescence:pycoalescence.simulation.Simulation.run_simple}}\pysiglinewithargsret{\sphinxbfcode{run\_simple}}{\emph{seed}, \emph{task}, \emph{output}, \emph{alpha}, \emph{sigma}, \emph{size}}{}
Runs a simple coalescence simulation on a square infinite landscape with the provided parameters.
This requires a separate compilation of the inf\_land version of the coalescence simulator.

Note that this function returns richness=0 for failure to read from the file. It is assumed that there will
be at least one species in the simulation.

Note that the maximum time for this function is set as 10 hours (36000 seconds) and will raise an exception if
the simulation does not complete in this time).
\begin{quote}\begin{description}
\item[{Raises}] \leavevmode
\sphinxstyleliteralstrong{RuntimeError} -- if the simulation didn't complete in time.

\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{seed} -- the simulation seed

\item {} 
\sphinxstyleliteralstrong{task} -- the task (for file naming)

\item {} 
\sphinxstyleliteralstrong{output} -- the output directory

\item {} 
\sphinxstyleliteralstrong{alpha} -- the speciation rate

\item {} 
\sphinxstyleliteralstrong{sigma} -- the normal distribution sigma value for dispersal

\item {} 
\sphinxstyleliteralstrong{size} -- the size of the world (so there will be size\textasciicircum{}2 individuals simulated)

\end{itemize}

\item[{Returns}] \leavevmode
the species richness in the simulation

\end{description}\end{quote}

\end{fulllineitems}

\index{set\_map() (Simulation method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pycoalescence:pycoalescence.simulation.Simulation.set_map}}\pysiglinewithargsret{\sphinxbfcode{set\_map}}{\emph{map\_file}, \emph{x\_size=None}, \emph{y\_size=None}}{}
Quick function for setting a single map file for both the sample map and fine map, of dimensions x and y.
Sets the sample file to \sphinxquotedblleft{}null\sphinxquotedblright{} and coarse file and pristine files to \sphinxquotedblleft{}none\sphinxquotedblright{}.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{map\_file} (\sphinxstyleliteralemphasis{str}) -- path to the map file

\item {} 
\sphinxstyleliteralstrong{x\_size} -- the x dimension, or None to detect automatically from the \sphinxquotedblright{}.tif\sphinxquotedblright{} file

\item {} 
\sphinxstyleliteralstrong{y\_size} -- the y dimension, or None to detect automatically from the \sphinxquotedblright{}.tif\sphinxquotedblright{} file

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{set\_map\_config() (Simulation method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pycoalescence:pycoalescence.simulation.Simulation.set_map_config}}\pysiglinewithargsret{\sphinxbfcode{set\_map\_config}}{\emph{file}}{}
Sets a specific map config and tells the program that full commmand-line parsing is not required.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{file} (\sphinxstyleliteralemphasis{str}) -- the file to read map config options from

\end{description}\end{quote}

\end{fulllineitems}

\index{set\_map\_files() (Simulation method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pycoalescence:pycoalescence.simulation.Simulation.set_map_files}}\pysiglinewithargsret{\sphinxbfcode{set\_map\_files}}{\emph{sample\_file}, \emph{fine\_file=None}, \emph{coarse\_file=None}, \emph{pristine\_fine\_file=None}, \emph{pristine\_coarse\_file=None}, \emph{dispersal\_map=None}, \emph{reproduction\_map=None}}{}
Sets the map files (or to null, if none specified). It then calls detect\_map\_dimensions() to correctly read in
the specified dimensions.
Note that if sample\_file is \sphinxquotedblleft{}null\sphinxquotedblright{}, values will remain at 0.
If coarse\_file is \sphinxquotedblleft{}null\sphinxquotedblright{}, it will default to the size of fine\_file with zero offset.
If the coarse file is \sphinxquotedblleft{}none\sphinxquotedblright{}, it will not be used.
If the pristine fine or coarse files are \sphinxquotedblleft{}none\sphinxquotedblright{}, they will not be used.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{sample\_file} (\sphinxstyleliteralemphasis{str}) -- the sample map file. Provide \sphinxquotedblleft{}null\sphinxquotedblright{} if on samplemask is required

\item {} 
\sphinxstyleliteralstrong{fine\_file} (\sphinxstyleliteralemphasis{str}) -- the fine map file. Defaults to \sphinxquotedblleft{}null\sphinxquotedblright{} if none provided

\item {} 
\sphinxstyleliteralstrong{coarse\_file} (\sphinxstyleliteralemphasis{str}) -- the coarse map file. Defaults to \sphinxquotedblleft{}none\sphinxquotedblright{} if none provided

\item {} 
\sphinxstyleliteralstrong{pristine\_fine\_file} (\sphinxstyleliteralemphasis{str}) -- the pristine fine map file. Defaults to \sphinxquotedblleft{}none\sphinxquotedblright{} if none provided

\item {} 
\sphinxstyleliteralstrong{pristine\_coarse\_file} (\sphinxstyleliteralemphasis{str}) -- the pristine coarse map file. Defaults to \sphinxquotedblleft{}none\sphinxquotedblright{} if none provided

\item {} 
\sphinxstyleliteralstrong{dispersal\_map} (\sphinxstyleliteralemphasis{str}) -- the dispersal map for reading dispersal values. Default to \sphinxquotedblleft{}none\sphinxquotedblright{} if none provided

\item {} 
\sphinxstyleliteralstrong{reproduction\_map} (\sphinxstyleliteralemphasis{str}) -- a map of relative reproduction probabilities, at the scale of the fine map

\end{itemize}

\end{description}\end{quote}

:rtype None

:return None

\end{fulllineitems}

\index{set\_map\_parameters() (Simulation method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pycoalescence:pycoalescence.simulation.Simulation.set_map_parameters}}\pysiglinewithargsret{\sphinxbfcode{set\_map\_parameters}}{\emph{sample\_file}, \emph{sample\_x}, \emph{sample\_y}, \emph{fine\_file}, \emph{fine\_x}, \emph{fine\_y}, \emph{fine\_x\_offset}, \emph{fine\_y\_offset}, \emph{coarse\_file}, \emph{coarse\_x}, \emph{coarse\_y}, \emph{coarse\_x\_offset}, \emph{coarse\_y\_offset}, \emph{coarse\_scale}, \emph{pristine\_fine\_map}, \emph{pristine\_coarse\_map}}{}
Set up the map objects with the required parameters. This is required for csv file usage.

Note that this function is not recommended for tif file usage, as it is much simpler to call set\_map\_files() and
which should automatically calculate map offsets, scaling and dimensions.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{sample\_file} -- the sample file to use, which should contain a boolean mask of where to sample

\item {} 
\sphinxstyleliteralstrong{sample\_x} -- the x dimension of the sample file

\item {} 
\sphinxstyleliteralstrong{sample\_y} -- the y dimension of the sample file

\item {} 
\sphinxstyleliteralstrong{fine\_file} -- the fine map file to use (must be equal to or larger than the sample file)

\item {} 
\sphinxstyleliteralstrong{fine\_x} -- the x dimension of the fine map file

\item {} 
\sphinxstyleliteralstrong{fine\_y} -- the y dimension of the fine map file

\item {} 
\sphinxstyleliteralstrong{fine\_x\_offset} -- the x offset of the fine map file

\item {} 
\sphinxstyleliteralstrong{fine\_y\_offset} -- the y offset of the fine map file

\item {} 
\sphinxstyleliteralstrong{coarse\_file} -- the coarse map file to use (must be equal to or larger than fine map file)

\item {} 
\sphinxstyleliteralstrong{coarse\_x} -- the x dimension of the coarse map file

\item {} 
\sphinxstyleliteralstrong{coarse\_y} -- the y dimension of the coarse map file

\item {} 
\sphinxstyleliteralstrong{coarse\_x\_offset} -- the x offset of the coarse map file at the resolution of the fine map

\item {} 
\sphinxstyleliteralstrong{coarse\_y\_offset} -- the y offset of the coarse map file at the resoultion of the fine map

\item {} 
\sphinxstyleliteralstrong{coarse\_scale} -- the relative scale of the coarse map compared to the fine map (must match x and y scaling)

\item {} 
\sphinxstyleliteralstrong{pristine\_fine\_map} -- the pristine fine map file to use (must have dimensions equal to fine map)

\item {} 
\sphinxstyleliteralstrong{pristine\_coarse\_map} -- the pristine coarse map file to use (must have dimensions equal to coarse map)

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{set\_optimised\_solution() (Simulation method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pycoalescence:pycoalescence.simulation.Simulation.set_optimised_solution}}\pysiglinewithargsret{\sphinxbfcode{set\_optimised\_solution}}{\emph{dict\_in}}{}
Sets the optimised RAM solution from the variables in the provided dictionary.
This should contain the grid\_x\_size, grid\_y\_size, grid\_file\_name, sample\_x\_offset and sample\_y\_offset.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{dict\_in} (\sphinxstyleliteralemphasis{dict}) -- the dictionary containing the optimised RAM solution variables

\end{description}\end{quote}

:rtype None

\end{fulllineitems}

\index{set\_simulation\_params() (Simulation method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pycoalescence:pycoalescence.simulation.Simulation.set_simulation_params}}\pysiglinewithargsret{\sphinxbfcode{set\_simulation\_params}}{\emph{seed}, \emph{job\_type}, \emph{output\_directory}, \emph{min\_speciation\_rate}, \emph{sigma=1.0}, \emph{tau=1.0}, \emph{deme=1}, \emph{sample\_size=1.0}, \emph{max\_time=3600}, \emph{dispersal\_method=None}, \emph{m\_prob=0.0}, \emph{cutoff=0}, \emph{dispersal\_relative\_cost=1}, \emph{min\_num\_species=1}, \emph{habitat\_change\_rate=0.0}, \emph{gen\_since\_pristine=1}, \emph{time\_config\_file='null'}, \emph{restrict\_self=False}, \emph{infinite\_landscape=False}, \emph{protracted=False}, \emph{min\_speciation\_gen=None}, \emph{max\_speciation\_gen=None}, \emph{spatial=True}, \emph{uses\_spatial\_sampling=False}}{}
Set all the simulation parameters apart from the map objects.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{seed} (\sphinxstyleliteralemphasis{int}) -- the unique job number for this simulation set

\item {} 
\sphinxstyleliteralstrong{job\_type} (\sphinxstyleliteralemphasis{int}) -- the job type (used for easy file identification after simulations are complete)

\item {} 
\sphinxstyleliteralstrong{output\_directory} (\sphinxstyleliteralemphasis{str}) -- the output directory to store the SQL database

\item {} 
\sphinxstyleliteralstrong{min\_speciation\_rate} (\sphinxstyleliteralemphasis{float}) -- the minimum speciation rate to simulate

\item {} 
\sphinxstyleliteralstrong{sigma} (\sphinxstyleliteralemphasis{float}) -- the dispersal sigma value

\item {} 
\sphinxstyleliteralstrong{tau} (\sphinxstyleliteralemphasis{float}) -- the fat-tailed dispersal tau value

\item {} 
\sphinxstyleliteralstrong{deme} (\sphinxstyleliteralemphasis{int}) -- the deme size (in individuals per cell)

\item {} 
\sphinxstyleliteralstrong{sample\_size} (\sphinxstyleliteralemphasis{float}) -- the sample size of the deme (decimal 0-1)

\item {} 
\sphinxstyleliteralstrong{max\_time} (\sphinxstyleliteralemphasis{float}) -- the maximum allowed simulation time (in seconds)

\item {} 
\sphinxstyleliteralstrong{dispersal\_method} (\sphinxstyleliteralemphasis{str}) -- the dispersal kernel method. Should be one of {[}normal, fat-tail, norm-uniform{]}

\item {} 
\sphinxstyleliteralstrong{m\_prob} (\sphinxstyleliteralemphasis{float}) -- the probability of drawing from the uniform dispersal. Only relevant for uniform dispersals

\item {} 
\sphinxstyleliteralstrong{cutoff} (\sphinxstyleliteralemphasis{float}) -- the maximum value for the uniform dispersal. Only relevant for uniform dispersals.

\item {} 
\sphinxstyleliteralstrong{dispersal\_relative\_cost} (\sphinxstyleliteralemphasis{float}) -- the relative cost of travelling through non-habitat (defaults to 1)

\item {} 
\sphinxstyleliteralstrong{min\_num\_species} (\sphinxstyleliteralemphasis{int}) -- the minimum number of species known to exist (defaults to 1

\item {} 
\sphinxstyleliteralstrong{habitat\_change\_rate} (\sphinxstyleliteralemphasis{float}) -- the rate of habitat change over time

\item {} 
\sphinxstyleliteralstrong{gen\_since\_pristine} (\sphinxstyleliteralemphasis{float}) -- the time in generations since a pristine state was achieved

\item {} 
\sphinxstyleliteralstrong{time\_config\_file} (\sphinxstyleliteralemphasis{str}) -- the path to the time config file (or null)

\item {} 
\sphinxstyleliteralstrong{restrict\_self} (\sphinxstyleliteralemphasis{bool}) -- if true, restricts dispersal from own cell

\item {} 
\sphinxstyleliteralstrong{infinite\_landscape} (\sphinxstyleliteralemphasis{bool/str}) -- if false or \sphinxquotedblleft{}closed\sphinxquotedblright{}, restricts dispersal to the provided maps, otherwise

\end{itemize}

\end{description}\end{quote}

can be \sphinxquotedblleft{}infinite\sphinxquotedblright{}, or a tiled landscape using \sphinxquotedblleft{}tiled\_coarse\sphinxquotedblright{} or \sphinxquotedblleft{}tiled\_fine\sphinxquotedblright{}.
:param bool protracted: if true, uses protracted speciation application
:param float min\_speciation\_gen: the minimum amount of time a lineage must exist before speciation occurs.
:param float max\_speciation\_gen: the maximum amount of time a lineage can exist before speciating.
:param bool spatial: if true, means that the simulation is spatial
:param bool uses\_spatial\_sampling: if true, the sample mask is interpreted as a proportional sampling mask,
\begin{quote}

where the number of individuals sampled in the cell is equal to the
density * deme\_sample * cell sampling proportion
\end{quote}

\end{fulllineitems}

\index{set\_speciation\_rates() (Simulation method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pycoalescence:pycoalescence.simulation.Simulation.set_speciation_rates}}\pysiglinewithargsret{\sphinxbfcode{set\_speciation\_rates}}{\emph{speciation\_rates}}{}
Add speciation rates for analysis at the end of the simulation. This is optional
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{speciation\_rates} (\sphinxstyleliteralemphasis{list}) -- a list of speciation rates to apply at the end of the simulation

\end{description}\end{quote}

\end{fulllineitems}

\index{setup() (Simulation method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pycoalescence:pycoalescence.simulation.Simulation.setup}}\pysiglinewithargsret{\sphinxbfcode{setup}}{\emph{coalescence\_simulator='/Users/samthompson/Documents/PhD/Code/pycoalescence/pycoalescence/build/default/./NECSim'}}{}
Set the location of the coalescence and speciation executables. Make sure that both programs have been compiled
for the operating system running the simulations.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{coalescence\_simulator} (\sphinxstyleliteralemphasis{str}) -- the path to the Coal\_v1 executable

\end{description}\end{quote}

\DUrole{versionmodified}{Deprecated since version 1.2.4: }No longer required as of 1.2.4 as all components have been migrated to use Python API
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
None

\end{description}\end{quote}

\end{fulllineitems}

\index{setup\_necsim() (Simulation method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pycoalescence:pycoalescence.simulation.Simulation.setup_necsim}}\pysiglinewithargsret{\sphinxbfcode{setup\_necsim}}{}{}
Sets the logging function and the logger object for the necsim object. Enforcing this function is always called
ensures no seg faults occur.

\end{fulllineitems}


\end{fulllineitems}



\paragraph{fragments module}
\label{\detokenize{pycoalescence:fragments-module}}
Detailed \DUrole{xref,std,std-ref}{here}.
\phantomsection\label{\detokenize{pycoalescence:module-pycoalescence.fragments}}\index{pycoalescence.fragments (module)}
Contains the FragmentedLandscape class for creating a fragmented landscape using hexagonal packing and an even spread of
individuals between fragments. Requires scipy and matplotlib.
\index{FileExistsError}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pycoalescence:pycoalescence.fragments.FileExistsError}}\pysigline{\sphinxstrong{exception }\sphinxbfcode{FileExistsError}}
Bases: \sphinxcode{exceptions.IOError}

\end{fulllineitems}

\index{Fragment (class in pycoalescence.fragments)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pycoalescence:pycoalescence.fragments.Fragment}}\pysiglinewithargsret{\sphinxstrong{class }\sphinxbfcode{Fragment}}{\emph{x=None}, \emph{y=None}}{}
Simple class containing the centres of fragments for a fragmented landscape
\index{place\_on\_grid() (Fragment method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pycoalescence:pycoalescence.fragments.Fragment.place_on_grid}}\pysiglinewithargsret{\sphinxbfcode{place\_on\_grid}}{}{}
Changes the x and y positions to integers (always rounds down).
\begin{quote}\begin{description}
\item[{Return type}] \leavevmode
None

\end{description}\end{quote}

\end{fulllineitems}

\index{setup() (Fragment method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pycoalescence:pycoalescence.fragments.Fragment.setup}}\pysiglinewithargsret{\sphinxbfcode{setup}}{\emph{x}, \emph{y}}{}
Sets up the fragment from the x and y position.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{x} -- the x position of the fragment centre

\item {} 
\sphinxstyleliteralstrong{y} -- the y position of the fragment centre

\end{itemize}

\item[{Return type}] \leavevmode
None

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{FragmentedLandscape (class in pycoalescence.fragments)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pycoalescence:pycoalescence.fragments.FragmentedLandscape}}\pysiglinewithargsret{\sphinxstrong{class }\sphinxbfcode{FragmentedLandscape}}{\emph{number\_fragments=None}, \emph{size=None}, \emph{total=None}, \emph{output\_file=None}}{}
Contains hexagonal packing algorithms for spacing clumps evenly on the landscape. Includes a LLoyd's smoothing
algorithm for better spacing of fragments.

\begin{sphinxadmonition}{note}{Note:}
Fragments will not be distinct units for unfragmented landscapes (with above around 50\% habitat cover).
\end{sphinxadmonition}
\index{create() (FragmentedLandscape method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pycoalescence:pycoalescence.fragments.FragmentedLandscape.create}}\pysiglinewithargsret{\sphinxbfcode{create}}{\emph{override\_smoothing=None}, \emph{n=10}}{}
Creates the landscape, including running the hexagonal packing and smoothing algorithms (if required).

\begin{sphinxadmonition}{note}{Note:}
smoothing is recommended for any landscape that is doesn't contain a square number of fragments.
\end{sphinxadmonition}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{override\_smoothing} -- if true, overrides the default smoothing settings (enabled for landscapes with fewer
than 100000 fragments.

\item {} 
\sphinxstyleliteralstrong{n} -- the number of iterations to run Lloyd's algorithm for

\end{itemize}

\item[{Return type}] \leavevmode
None

\end{description}\end{quote}

\end{fulllineitems}

\index{fill\_grid() (FragmentedLandscape method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pycoalescence:pycoalescence.fragments.FragmentedLandscape.fill_grid}}\pysiglinewithargsret{\sphinxbfcode{fill\_grid}}{}{}
Distributes the sizes evenly between the fragments, generating the actual landscape.
\begin{quote}\begin{description}
\item[{Return type}] \leavevmode
None

\end{description}\end{quote}

\end{fulllineitems}

\index{generate() (FragmentedLandscape method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pycoalescence:pycoalescence.fragments.FragmentedLandscape.generate}}\pysiglinewithargsret{\sphinxbfcode{generate}}{\emph{override\_smoothing=None}, \emph{n=10}}{}
Convenience function for creating fragments in one function. Generates the landscape and writes out to the
output file.

If smoothing is true, will run Lloyd's algorithm
after the hexagonal packing algorithm to increase the equality of the spacing.

\begin{sphinxadmonition}{note}{Note:}
smoothing is recommended for any landscape that is doesn't contain a square number of fragments.
\end{sphinxadmonition}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{override\_smoothing} -- if true, overrides the default smoothing settings (enabled for landscapes with fewer
than 100000 fragments.

\item {} 
\sphinxstyleliteralstrong{n} -- the number of iterations to run Lloyd's algorithm for

\end{itemize}

\item[{Return type}] \leavevmode
None

\end{description}\end{quote}

\end{fulllineitems}

\index{place\_fragments() (FragmentedLandscape method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pycoalescence:pycoalescence.fragments.FragmentedLandscape.place_fragments}}\pysiglinewithargsret{\sphinxbfcode{place\_fragments}}{\emph{smoothing=True}, \emph{n=10}}{}
Places the fragments evenly on the landscape. If smoothing is true, will run Lloyd's algorithm after the
hexagonal packing algorithm to increase the equality of the spacing.

\begin{sphinxadmonition}{note}{Note:}
smoothing is recommended for any landscape that is doesn't contain a square number of fragments.
\end{sphinxadmonition}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{smoothing} -- if true, runs Lloyd's algorithm after the hexagonal packing

\item {} 
\sphinxstyleliteralstrong{n} -- the number of iterations to run Lloyd's algorithm for

\end{itemize}

\item[{Return type}] \leavevmode
None

\end{description}\end{quote}

\end{fulllineitems}

\index{plot() (FragmentedLandscape method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pycoalescence:pycoalescence.fragments.FragmentedLandscape.plot}}\pysiglinewithargsret{\sphinxbfcode{plot}}{}{}
Returns a matplotlib.pyplot.figure object containing an image of the fragmented landscape (with axes removed).

Requires that the fragmented landscape has been created already using {\hyperref[\detokenize{pycoalescence:pycoalescence.fragments.FragmentedLandscape.create}]{\sphinxcrossref{\sphinxcode{create()}}}}.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
figure object containing the fragmented landscape.

\item[{Return type}] \leavevmode
matplotlib.pyplot.figure

\end{description}\end{quote}

\end{fulllineitems}

\index{setup() (FragmentedLandscape method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pycoalescence:pycoalescence.fragments.FragmentedLandscape.setup}}\pysiglinewithargsret{\sphinxbfcode{setup}}{\emph{number\_fragments}, \emph{size}, \emph{total}, \emph{output\_file}}{}
Sets up the landscape by checking parameters and setting object sizes.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{number\_fragments} -- the number of individual fragments to exist on the landscape

\item {} 
\sphinxstyleliteralstrong{size} -- the size of the x and y dimensions of the landscape

\item {} 
\sphinxstyleliteralstrong{total} -- the total number of individuals to place on the landscape

\item {} 
\sphinxstyleliteralstrong{output\_file} -- the output tif file to write the output to

\end{itemize}

\item[{Return type}] \leavevmode
None

\end{description}\end{quote}

\end{fulllineitems}

\index{write\_to\_raster() (FragmentedLandscape method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pycoalescence:pycoalescence.fragments.FragmentedLandscape.write_to_raster}}\pysiglinewithargsret{\sphinxbfcode{write\_to\_raster}}{}{}
Writes the landscape to a tif file.
\begin{quote}\begin{description}
\item[{Raises}] \leavevmode
{\hyperref[\detokenize{pycoalescence:pycoalescence.fragments.FileExistsError}]{\sphinxcrossref{\sphinxstyleliteralstrong{FileExistsError}}}} -- if the output file already exists

\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{output\_file} -- the path to the tif file to write out to.

\item[{Return type}] \leavevmode
None

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}



\paragraph{map module}
\label{\detokenize{pycoalescence:map-module}}
Detailed \DUrole{xref,std,std-ref}{here}.
\phantomsection\label{\detokenize{pycoalescence:module-pycoalescence.map}}\index{pycoalescence.map (module)}
Contains the Map class as part of the PyCoalescence Project.

Operations involve simulating dispersal kernels on maps, detecting map file dimensions and obtaining offsets between
maps.
\index{Map (class in pycoalescence.map)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pycoalescence:pycoalescence.map.Map}}\pysiglinewithargsret{\sphinxstrong{class }\sphinxbfcode{Map}}{\emph{file=None}, \emph{is\_sample=None}, \emph{logging\_level=30}, \emph{dispersal\_db=None}}{}
Bases: \sphinxcode{object}

A class for the map object, containing the file name and the variables associated with this map object.

The internal array of the tif file is stored in self.data, and band 1 of the file can be opened by using
open()
\begin{quote}\begin{description}
\item[{Variables}] \leavevmode
\sphinxstyleliteralstrong{data} -- if the map file has been opened, contains the full tif data as a numpy array.

\end{description}\end{quote}
\index{calculate\_offset() (Map method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pycoalescence:pycoalescence.map.Map.calculate_offset}}\pysiglinewithargsret{\sphinxbfcode{calculate\_offset}}{\emph{file\_offset}}{}
Calculates the offset of the map object from the supplied file\_offset.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{file\_offset} (\sphinxstyleliteralemphasis{str/Map}) -- the path to the file to calculate the offset.
Can also be a Map object with the filename contained.

\item[{Returns}] \leavevmode
the offset x and y (at the resolution of the file\_home) in integers

\end{description}\end{quote}

\end{fulllineitems}

\index{calculate\_scale() (Map method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pycoalescence:pycoalescence.map.Map.calculate_scale}}\pysiglinewithargsret{\sphinxbfcode{calculate\_scale}}{\emph{file\_scaled}}{}
Calculates the scale of map object from the supplied file\_scaled.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{file\_scaled} (\sphinxstyleliteralemphasis{str/Map}) -- the path to the file to calculate the scale.

\item[{Returns}] \leavevmode
the scale (of the x dimension)

\end{description}\end{quote}

\end{fulllineitems}

\index{check\_map() (Map method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pycoalescence:pycoalescence.map.Map.check_map}}\pysiglinewithargsret{\sphinxbfcode{check\_map}}{}{}
Checks that the dimensions for the map have been set and that the map file exists

\end{fulllineitems}

\index{create() (Map method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pycoalescence:pycoalescence.map.Map.create}}\pysiglinewithargsret{\sphinxbfcode{create}}{\emph{file}}{}
Create the file output and writes the grid to the output.
:param file: the output file to create

\end{fulllineitems}

\index{get\_cached\_subset() (Map method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pycoalescence:pycoalescence.map.Map.get_cached_subset}}\pysiglinewithargsret{\sphinxbfcode{get\_cached\_subset}}{\emph{x\_offset}, \emph{y\_offset}, \emph{x\_size}, \emph{y\_size}}{}
Gets a subset of the map file, BUT rounds all numbers to integers to save RAM and keeps the entire array in
memory to speed up fetches.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{x\_offset} -- the x offset from the top left corner of the map

\item {} 
\sphinxstyleliteralstrong{y\_offset} -- the y offset from the top left corner of the map

\item {} 
\sphinxstyleliteralstrong{x\_size} -- the x size of the subset to obtain

\item {} 
\sphinxstyleliteralstrong{y\_size} -- the y size of the subset to obtain

\end{itemize}

\item[{Returns}] \leavevmode
a numpy array containing the subsetted data

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_database\_parameters() (Map method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pycoalescence:pycoalescence.map.Map.get_database_parameters}}\pysiglinewithargsret{\sphinxbfcode{get\_database\_parameters}}{}{}
Gets the dispersal simulation parameters from the dispersal\_db
:return: the dispersal simulation parameters

\end{fulllineitems}

\index{get\_dimensions() (Map method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pycoalescence:pycoalescence.map.Map.get_dimensions}}\pysiglinewithargsret{\sphinxbfcode{get\_dimensions}}{}{}
Calls read\_dimensions() if dimensions have not been read, or reads stored information.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
a list containing {[}0{]} x, {[}1{]} y, {[}2{]} upper left x, {[}3{]} upper left y, {[}4{]} x resolution, {[}5{]} y resolution

\end{description}\end{quote}

\begin{sphinxadmonition}{note}{Note:}
the returned list will contain the x and y offset values instead of the ulx and uly values if the
dimensions have already been set (i.e. self.x\_size != 0 and self.y\_size != 0)
\end{sphinxadmonition}

\end{fulllineitems}

\index{get\_mean\_dispersal() (Map method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pycoalescence:pycoalescence.map.Map.get_mean_dispersal}}\pysiglinewithargsret{\sphinxbfcode{get\_mean\_dispersal}}{\emph{database=None}, \emph{parameter\_reference=1}}{}
Gets the mean dispersal for the map if test\_mean\_dispersal has already been run.
\begin{quote}\begin{description}
\item[{Raises}] \leavevmode
ValueError if dispersal\_database is None and so test\_average\_dispersal() has not been run

\item[{Raises}] \leavevmode
IOError if the output database does not exist

\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{database} (\sphinxstyleliteralemphasis{str}) -- the database to open

\item {} 
\sphinxstyleliteralstrong{parameter\_reference} (\sphinxstyleliteralemphasis{int}) -- the parameter reference to use (or 1 for default parameter reference).

\end{itemize}

\item[{Returns}] \leavevmode
mean dispersal from the database

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_mean\_distance\_travelled() (Map method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pycoalescence:pycoalescence.map.Map.get_mean_distance_travelled}}\pysiglinewithargsret{\sphinxbfcode{get\_mean\_distance\_travelled}}{\emph{database=None}, \emph{parameter\_reference=1}}{}
Gets the mean dispersal for the map if test\_mean\_dispersal has already been run.
\begin{quote}\begin{description}
\item[{Raises}] \leavevmode
ValueError if dispersal\_database is None and so test\_average\_dispersal() has not been run

\item[{Raises}] \leavevmode
IOError if the output database does not exist

\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{database} (\sphinxstyleliteralemphasis{str}) -- the database to open

\item {} 
\sphinxstyleliteralstrong{parameter\_reference} (\sphinxstyleliteralemphasis{int}) -- the parameter reference to use (or 1 for default parameter reference).

\end{itemize}

\item[{Returns}] \leavevmode
mean of dispersal from the database

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_stdev\_dispersal() (Map method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pycoalescence:pycoalescence.map.Map.get_stdev_dispersal}}\pysiglinewithargsret{\sphinxbfcode{get\_stdev\_dispersal}}{\emph{database=None}, \emph{parameter\_reference=1}}{}
Gets the standard deviation of dispersal for the map if test\_mean\_dispersal has already been run.
\begin{quote}\begin{description}
\item[{Raises}] \leavevmode
ValueError if dispersal\_database is None and so test\_average\_dispersal() has not been run

\item[{Raises}] \leavevmode
IOError if the output database does not exist

\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{database} (\sphinxstyleliteralemphasis{str}) -- the database to open

\item {} 
\sphinxstyleliteralstrong{parameter\_reference} (\sphinxstyleliteralemphasis{int}) -- the parameter reference to use (or 1 for default parameter reference).

\end{itemize}

\item[{Returns}] \leavevmode
standard deviation of dispersal from the database

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_stdev\_distance\_travelled() (Map method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pycoalescence:pycoalescence.map.Map.get_stdev_distance_travelled}}\pysiglinewithargsret{\sphinxbfcode{get\_stdev\_distance\_travelled}}{\emph{database=None}, \emph{parameter\_reference=1}}{}
Gets the standard deviation of the  distance travelled for the map if test\_mean\_distance\_travelled has already
been run.
\begin{quote}\begin{description}
\item[{Raises}] \leavevmode
ValueError if dispersal\_database is None and so test\_average\_dispersal() has not been run

\item[{Raises}] \leavevmode
IOError if the output database does not exist

\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{database} (\sphinxstyleliteralemphasis{str}) -- the database to open

\item {} 
\sphinxstyleliteralstrong{parameter\_reference} (\sphinxstyleliteralemphasis{int}) -- the parameter reference to use (or 1 for default parameter reference).

\end{itemize}

\item[{Returns}] \leavevmode
standard deviation of dispersal from the database

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_subset() (Map method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pycoalescence:pycoalescence.map.Map.get_subset}}\pysiglinewithargsret{\sphinxbfcode{get\_subset}}{\emph{x\_offset}, \emph{y\_offset}, \emph{x\_size}, \emph{y\_size}}{}
Gets a subset of the map file
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{x\_offset} -- the x offset from the top left corner of the map

\item {} 
\sphinxstyleliteralstrong{y\_offset} -- the y offset from the top left corner of the map

\item {} 
\sphinxstyleliteralstrong{x\_size} -- the x size of the subset to obtain

\item {} 
\sphinxstyleliteralstrong{y\_size} -- the y size of the subset to obtain

\end{itemize}

\item[{Returns}] \leavevmode
a numpy array containing the subsetted data

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_x\_y() (Map method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pycoalescence:pycoalescence.map.Map.get_x_y}}\pysiglinewithargsret{\sphinxbfcode{get\_x\_y}}{}{}
Simply returns the x and y dimension of the file.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
the x and y dimensions

\end{description}\end{quote}

\end{fulllineitems}

\index{open() (Map method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pycoalescence:pycoalescence.map.Map.open}}\pysiglinewithargsret{\sphinxbfcode{open}}{\emph{file=None}, \emph{band\_no=1}}{}
Reads the raster file from memory into the data object.
This allows direct access to the internal numpy array using the data object.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{file} (\sphinxstyleliteralemphasis{str}) -- path to file to open (or None to use self.file\_name

\item {} 
\sphinxstyleliteralstrong{band\_no} (\sphinxstyleliteralemphasis{int}) -- the band number to read from

\end{itemize}

\item[{Return type}] \leavevmode
None

\end{description}\end{quote}

\end{fulllineitems}

\index{read\_dimensions() (Map method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pycoalescence:pycoalescence.map.Map.read_dimensions}}\pysiglinewithargsret{\sphinxbfcode{read\_dimensions}}{}{}
Return a list containing the geospatial coordinate system for the file.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
a list containing {[}0{]} x, {[}1{]} y, {[}2{]} upper left x, {[}3{]} upper left y, {[}4{]} x resolution, {[}5{]} y resolution

\end{description}\end{quote}

\end{fulllineitems}

\index{set\_dimensions() (Map method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pycoalescence:pycoalescence.map.Map.set_dimensions}}\pysiglinewithargsret{\sphinxbfcode{set\_dimensions}}{\emph{file\_name=None}, \emph{x\_size=None}, \emph{y\_size=None}, \emph{x\_offset=None}, \emph{y\_offset=None}}{}
Sets the dimensions and file for the Map object
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{file\_name} (\sphinxstyleliteralemphasis{str}) -- the location of the map object (a csv or tif file). If None, required that file\_name is already provided.

\item {} 
\sphinxstyleliteralstrong{x\_size} (\sphinxstyleliteralemphasis{int}) -- the x dimension

\item {} 
\sphinxstyleliteralstrong{y\_size} (\sphinxstyleliteralemphasis{int}) -- the y dimension

\item {} 
\sphinxstyleliteralstrong{x\_offset} (\sphinxstyleliteralemphasis{int}) -- the x offset from the north-west corner

\item {} 
\sphinxstyleliteralstrong{y\_offset} (\sphinxstyleliteralemphasis{int}) -- the y offset from the north-west corner

\end{itemize}

\item[{Returns}] \leavevmode
None

\end{description}\end{quote}

\end{fulllineitems}

\index{set\_sample() (Map method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pycoalescence:pycoalescence.map.Map.set_sample}}\pysiglinewithargsret{\sphinxbfcode{set\_sample}}{\emph{is\_sample}}{}
Set the is\_sample attribute to true if this is a sample mask rather than an offset map
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{is\_sample} (\sphinxstyleliteralemphasis{bool}) -- indicates this is a sample mask rather than offset map

\end{description}\end{quote}

\end{fulllineitems}

\index{test\_mean\_dispersal() (Map method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pycoalescence:pycoalescence.map.Map.test_mean_dispersal}}\pysiglinewithargsret{\sphinxbfcode{test\_mean\_dispersal}}{\emph{number\_repeats}, \emph{output\_database='output.db'}, \emph{map\_file=None}, \emph{seed=1}, \emph{dispersal\_method='normal'}, \emph{landscape\_type='tiled'}, \emph{sigma=1}, \emph{tau=1}, \emph{m\_prob=0.0}, \emph{cutoff=100}, \emph{sequential=False}}{}
Tests the dispersal kernel on the provided map, producing a database containing each dispersal distance for
analysis purposes.

\begin{sphinxadmonition}{note}{Note:}
should be equivalent to {\hyperref[\detokenize{pycoalescence:pycoalescence.map.Map.test_mean_distance_travelled}]{\sphinxcrossref{\sphinxcode{test\_mean\_distance\_travelled()}}}} with number\_steps = 1
\end{sphinxadmonition}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{number\_repeats} (\sphinxstyleliteralemphasis{int}) -- the number of times to iterate on the map

\item {} 
\sphinxstyleliteralstrong{output\_database} (\sphinxstyleliteralemphasis{str}) -- the path to the output database

\item {} 
\sphinxstyleliteralstrong{map\_file} (\sphinxstyleliteralemphasis{str}) -- the path to the map file to iterate on

\item {} 
\sphinxstyleliteralstrong{seed} (\sphinxstyleliteralemphasis{int}) -- the random seed

\item {} 
\sphinxstyleliteralstrong{dispersal\_method} (\sphinxstyleliteralemphasis{str}) -- the dispersal method to use (\sphinxquotedblleft{}normal\sphinxquotedblright{}, \sphinxquotedblleft{}fat-tailed\sphinxquotedblright{} or \sphinxquotedblleft{}norm-uniform\sphinxquotedblright{})

\item {} 
\sphinxstyleliteralstrong{landscape\_type} (\sphinxstyleliteralemphasis{str}) -- the landscape type to use (\sphinxquotedblleft{}infinite\sphinxquotedblright{}, \sphinxquotedblleft{}tiled\sphinxquotedblright{} or \sphinxquotedblleft{}closed\sphinxquotedblright{})

\item {} 
\sphinxstyleliteralstrong{sigma} (\sphinxstyleliteralemphasis{float}) -- the sigma value to use for normal and norm-uniform dispersal

\item {} 
\sphinxstyleliteralstrong{tau} (\sphinxstyleliteralemphasis{float}) -- the tau value to use for fat-tailed dispersal

\item {} 
\sphinxstyleliteralstrong{m\_prob} (\sphinxstyleliteralemphasis{float}) -- the m\_prob to use for norm-uniform dispersal

\item {} 
\sphinxstyleliteralstrong{cutoff} (\sphinxstyleliteralemphasis{float}) -- the cutoff value to use for norm-uniform dispersal

\item {} 
\sphinxstyleliteralstrong{sequential} (\sphinxstyleliteralemphasis{bool}) -- if true, end locations of one dispersal event are used as the start for the next. Otherwise,

\end{itemize}

\end{description}\end{quote}

a new random cell is chosen

\end{fulllineitems}

\index{test\_mean\_distance\_travelled() (Map method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pycoalescence:pycoalescence.map.Map.test_mean_distance_travelled}}\pysiglinewithargsret{\sphinxbfcode{test\_mean\_distance\_travelled}}{\emph{number\_repeats}, \emph{number\_steps}, \emph{output\_database='output.db'}, \emph{map\_file=None}, \emph{seed=1}, \emph{dispersal\_method='normal'}, \emph{landscape\_type='tiled'}, \emph{sigma=1}, \emph{tau=1}, \emph{m\_prob=0.0}, \emph{cutoff=100}}{}
Tests the dispersal kernel on the provided map, producing a database containing the average distance travelled
after number\_steps have been moved.

\begin{sphinxadmonition}{note}{Note:}
mean distance travelled with number\_steps=1 should be equivalent to running
{\hyperref[\detokenize{pycoalescence:pycoalescence.map.Map.test_mean_dispersal}]{\sphinxcrossref{\sphinxcode{test\_mean\_dispersal()}}}}
\end{sphinxadmonition}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{number\_repeats} (\sphinxstyleliteralemphasis{int}) -- the number of times to iterate on the map

\item {} 
\sphinxstyleliteralstrong{number\_steps} (\sphinxstyleliteralemphasis{int}) -- the number of steps to take each time before recording the distance travelled

\item {} 
\sphinxstyleliteralstrong{output\_database} (\sphinxstyleliteralemphasis{str}) -- the path to the output database

\item {} 
\sphinxstyleliteralstrong{map\_file} (\sphinxstyleliteralemphasis{str}) -- the path to the map file to iterate on

\item {} 
\sphinxstyleliteralstrong{seed} (\sphinxstyleliteralemphasis{int}) -- the random seed

\item {} 
\sphinxstyleliteralstrong{dispersal\_method} (\sphinxstyleliteralemphasis{str}) -- the dispersal method to use (\sphinxquotedblleft{}normal\sphinxquotedblright{}, \sphinxquotedblleft{}fat-tailed\sphinxquotedblright{} or \sphinxquotedblleft{}norm-uniform\sphinxquotedblright{})

\item {} 
\sphinxstyleliteralstrong{landscape\_type} (\sphinxstyleliteralemphasis{str}) -- the landscape type to use (\sphinxquotedblleft{}infinite\sphinxquotedblright{}, \sphinxquotedblleft{}tiled\sphinxquotedblright{} or \sphinxquotedblleft{}closed\sphinxquotedblright{})

\item {} 
\sphinxstyleliteralstrong{sigma} (\sphinxstyleliteralemphasis{float}) -- the sigma value to use for normal and norm-uniform dispersal

\item {} 
\sphinxstyleliteralstrong{tau} (\sphinxstyleliteralemphasis{float}) -- the tau value to use for fat-tailed dispersal

\item {} 
\sphinxstyleliteralstrong{m\_prob} (\sphinxstyleliteralemphasis{float}) -- the m\_prob to use for norm-uniform dispersal

\item {} 
\sphinxstyleliteralstrong{cutoff} (\sphinxstyleliteralemphasis{float}) -- the cutoff value to use for norm-uniform dispersal

\end{itemize}

\item[{Returns}] \leavevmode


\end{description}\end{quote}

\end{fulllineitems}

\index{write() (Map method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pycoalescence:pycoalescence.map.Map.write}}\pysiglinewithargsret{\sphinxbfcode{write}}{\emph{file=None}, \emph{band\_no=None}}{}
Writes the array in self.data to the output array.
The output file must exist, and the array will be overridden in the band.
Intended for writing changes to the same file the data was read from.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{file} -- the path to the file to write to

\item {} 
\sphinxstyleliteralstrong{band\_no} -- the band number to write into

\end{itemize}

\end{description}\end{quote}

:rtype None

\end{fulllineitems}

\index{zero\_offsets() (Map method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pycoalescence:pycoalescence.map.Map.zero_offsets}}\pysiglinewithargsret{\sphinxbfcode{zero\_offsets}}{}{}
Sets the x and y offsets to 0

\end{fulllineitems}


\end{fulllineitems}



\paragraph{setup file}
\label{\detokenize{pycoalescence:setup-file}}\label{\detokenize{pycoalescence:module-pycoalescence.setup}}\index{pycoalescence.setup (module)}
Sets up the NECSim executables. It configures the install by detecting system components and compiles the \sphinxcode{c++} files,
if possible. Command line flags can be provided (see {\hyperref[\detokenize{README_pycoalescence:sec-compilation-options}]{\sphinxcrossref{\DUrole{std,std-ref}{Compilation Options}}}} for more
information) to modify the install.
\index{autoconf() (in module pycoalescence.setup)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pycoalescence:pycoalescence.setup.autoconf}}\pysiglinewithargsret{\sphinxbfcode{autoconf}}{}{}
Runs the \sphinxtitleref{autoconf} bash function (assuming that autoconf is available) to create the \sphinxtitleref{configure} executable.

\end{fulllineitems}

\index{backup\_makefile() (in module pycoalescence.setup)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pycoalescence:pycoalescence.setup.backup_makefile}}\pysiglinewithargsret{\sphinxbfcode{backup\_makefile}}{}{}
Copies the makefile to a saved folder so that even if the original is overwritten, the last successful
compilation can be recorded.

\end{fulllineitems}

\index{clean() (in module pycoalescence.setup)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pycoalescence:pycoalescence.setup.clean}}\pysiglinewithargsret{\sphinxbfcode{clean}}{}{}
Runs make clean in the NECSim directory to wipe any previous potential compile attempts.

\end{fulllineitems}

\index{configure() (in module pycoalescence.setup)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pycoalescence:pycoalescence.setup.configure}}\pysiglinewithargsret{\sphinxbfcode{configure}}{\emph{opts=None}}{}
Runs ./configure --opts with the supplied options. This should create the makefile for compilation, otherwise a
RuntimeError will be thrown.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{opts} -- a list of options to pass to the ./configure call

\end{description}\end{quote}

\end{fulllineitems}

\index{configure\_and\_compile() (in module pycoalescence.setup)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pycoalescence:pycoalescence.setup.configure_and_compile}}\pysiglinewithargsret{\sphinxbfcode{configure\_and\_compile}}{\emph{argv={[}None{]}, logging\_level=20}}{}
Calls the configure script, then runs the compilation.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{argv} -- the arguments to pass to configure script

\item {} 
\sphinxstyleliteralstrong{logging\_level} -- the logging level to utilise (defaults to INFO).

\end{itemize}

\item[{Return type}] \leavevmode
None

\end{description}\end{quote}

\end{fulllineitems}

\index{copy\_makefile() (in module pycoalescence.setup)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pycoalescence:pycoalescence.setup.copy_makefile}}\pysiglinewithargsret{\sphinxbfcode{copy\_makefile}}{}{}
Copies the backup makefile to the main directory, if it exists.
Throws an IOError if no makefile is found.

\end{fulllineitems}

\index{do\_compile() (in module pycoalescence.setup)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pycoalescence:pycoalescence.setup.do_compile}}\pysiglinewithargsret{\sphinxbfcode{do\_compile}}{}{}
Compiles the c++ NECSim program by running make. This changes the working directory to wherever the module has been
installed for the subprocess call.

\end{fulllineitems}

\index{get\_build\_dir() (in module pycoalescence.setup)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pycoalescence:pycoalescence.setup.get_build_dir}}\pysiglinewithargsret{\sphinxbfcode{get\_build\_dir}}{}{}
Gets the build directory for this python version.
:return: the build directory path for the current python interpreter

\end{fulllineitems}

\index{get\_compilation\_flags() (in module pycoalescence.setup)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pycoalescence:pycoalescence.setup.get_compilation_flags}}\pysiglinewithargsret{\sphinxbfcode{get\_compilation\_flags}}{\emph{display\_warnings=False}}{}
Generates the compilation flags for passing to ./configure.
:param display\_warnings: If true, runs with the -Wall flag for compilation (displaying all warnings). Default is False.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
list of compilation flags.

\item[{Return type}] \leavevmode
list

\end{description}\end{quote}

\end{fulllineitems}

\index{move\_executable() (in module pycoalescence.setup)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pycoalescence:pycoalescence.setup.move_executable}}\pysiglinewithargsret{\sphinxbfcode{move\_executable}}{\emph{directory='/Users/samthompson/Documents/PhD/Code/pycoalescence/pycoalescence/build/default/'}}{}
Moves the executable to the specified directory from within NECSim. Will always look for NECSim relative to the
setup.py (so can be called from another module location).
This allows for multiple compilation options with different versions stored in different folders.

Throws an IOError when the NECSim executable is not found.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{directory} -- the directory to move the NECSim excecutable to.

\end{description}\end{quote}

\end{fulllineitems}

\index{move\_shared\_object\_file() (in module pycoalescence.setup)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pycoalescence:pycoalescence.setup.move_shared_object_file}}\pysiglinewithargsret{\sphinxbfcode{move\_shared\_object\_file}}{}{}
Moves the shared object (.so) file to the build directory.
:return:

\end{fulllineitems}

\index{run\_configure() (in module pycoalescence.setup)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pycoalescence:pycoalescence.setup.run_configure}}\pysiglinewithargsret{\sphinxbfcode{run\_configure}}{\emph{argv={[}None{]}, logging\_level=20, display\_warnings=False}}{}
Configures the install for compile options provided via the command line, or with default options if no options exist.
Running with \sphinxcode{-help} or \sphinxtitleref{-h} will display the compilation configurations called from \sphinxcode{./configure}.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{argv} -- the arguments to pass to configure script

\item {} 
\sphinxstyleliteralstrong{logging\_level} -- the logging level to utilise (defaults to INFO).

\item {} 
\sphinxstyleliteralstrong{display\_warnings} -- If true, runs with the -Wall flag for compilation (displaying all warnings). Default is False.

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}



\paragraph{hpc\_setup file}
\label{\detokenize{pycoalescence:hpc-setup-file}}\label{\detokenize{pycoalescence:module-pycoalescence.hpc_setup}}\index{pycoalescence.hpc\_setup (module)}
Sets up pycoalescence for usage on HPC systems, including providing intel compiler flags for optimisation, and specific
verbose patterns to add support for certain types of file systems.
\index{build\_hpc() (in module pycoalescence.hpc\_setup)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pycoalescence:pycoalescence.hpc_setup.build_hpc}}\pysiglinewithargsret{\sphinxbfcode{build\_hpc}}{}{}
Compiles NECSim with the \sphinxcode{-{-}with-hpc} and \sphinxcode{-{-}with-verbose} flags, which adds extra support for intel compilers
and provides a selection of optimisation flags for high-performance systems.
:return:

\end{fulllineitems}



\chapter{Indices and tables}
\label{\detokenize{index:indices-and-tables}}\begin{itemize}
\item {} 
\DUrole{xref,std,std-ref}{genindex}

\item {} 
\DUrole{xref,std,std-ref}{modindex}

\item {} 
\DUrole{xref,std,std-ref}{search}

\end{itemize}

Version 1.2.5


\chapter{Citations}
\label{\detokenize{index:citations}}
\begin{sphinxthebibliography}{Hubbell2001}
\bibitem[Hubbell2001]{\detokenize{Hubbell2001}}{\phantomsection\label{\detokenize{index:hubbell2001}} 
Hubbell, S. P. (2001). The Unified Neutral Theory of Biodiversity and Biogeography. Monographs in Population Biology, 17(3), 375. \sphinxurl{http://doi.org/10.1016/S0006-3207(02)00228-8}
}
\end{sphinxthebibliography}


\renewcommand{\indexname}{Python Module Index}
\begin{sphinxtheindex}
\def\bigletter#1{{\Large\sffamily#1}\nopagebreak\vspace{1mm}}
\bigletter{p}
\item {\sphinxstyleindexentry{pycoalescence}}\sphinxstyleindexpageref{pycoalescence:\detokenize{module-pycoalescence}}
\item {\sphinxstyleindexentry{pycoalescence.batch\_process}}\sphinxstyleindexpageref{pycoalescence:\detokenize{module-pycoalescence.batch_process}}
\item {\sphinxstyleindexentry{pycoalescence.coalescence\_tree}}\sphinxstyleindexpageref{pycoalescence:\detokenize{module-pycoalescence.coalescence_tree}}
\item {\sphinxstyleindexentry{pycoalescence.fragments}}\sphinxstyleindexpageref{pycoalescence:\detokenize{module-pycoalescence.fragments}}
\item {\sphinxstyleindexentry{pycoalescence.hpc\_setup}}\sphinxstyleindexpageref{pycoalescence:\detokenize{module-pycoalescence.hpc_setup}}
\item {\sphinxstyleindexentry{pycoalescence.map}}\sphinxstyleindexpageref{pycoalescence:\detokenize{module-pycoalescence.map}}
\item {\sphinxstyleindexentry{pycoalescence.setup}}\sphinxstyleindexpageref{pycoalescence:\detokenize{module-pycoalescence.setup}}
\item {\sphinxstyleindexentry{pycoalescence.simulation}}\sphinxstyleindexpageref{pycoalescence:\detokenize{module-pycoalescence.simulation}}
\end{sphinxtheindex}

\renewcommand{\indexname}{Index}
\printindex
\end{document}